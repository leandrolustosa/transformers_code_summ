code	desc
protected final void fastpathorderedemit ( u value , boolean delayerror , disposable disposable ) { final observer < ? super v > observer = downstream ; final simpleplainqueue < u > q = queue ; if ( wip . get ( ) == num_ && wip . compareandset ( num_ , num_ ) ) { if ( q . isempty ( ) ) { accept ( observer , value ) ; if ( leave ( - num_ ) == num_ ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } queuedrainhelper . drainloop ( q , observer , delayerror , disposable , this ) ; }	Makes sure the fast-path emits in order.
@ checkreturnvalue @ schedulersupport ( schedulersupport . none ) public static < t > observable < t > wrap ( observablesource < t > source ) { objecthelper . requirenonnull ( source , str_ ) ; if ( source instanceof observable ) { return rxjavaplugins . onassembly ( ( observable < t > ) source ) ; } return rxjavaplugins . onassembly ( new observablefromunsafesource < t > ( source ) ) ; }	Wraps an ObservableSource into an Observable if not already an Observable. Scheduler: {.
@ checkreturnvalue @ schedulersupport ( schedulersupport . none ) public final observable < t > sorted ( comparator < ? super t > sortfunction ) { objecthelper . requirenonnull ( sortfunction , str_ ) ; return tolist ( ) . toobservable ( ) . map ( functions . listsorter ( sortfunction ) ) . flatmapiterable ( functions . < list < t > > identity ( ) ) ; }	Returns an Observable that emits the events emitted by source ObservableSource, in asorted order based on a specified comparison function. Note that calling {.
public static < t > connectableobservable < t > observeon ( final connectableobservable < t > co , final scheduler scheduler ) { final observable < t > observable = co . observeon ( scheduler ) ; return rxjavaplugins . onassembly ( new replay < t > ( co , observable ) ) ; }	Child Observers will observe the events of the ConnectableObservable on thespecified scheduler.
@ checkreturnvalue @ nonnull public static < t > unicastprocessor < t > create ( int capacityhint ) { return new unicastprocessor < t > ( capacityhint ) ; }	Creates an UnicastProcessor with the given internal buffer capacity hint.
@ checkreturnvalue @ nonnull public static < t > unicastprocessor < t > create ( int capacityhint , runnable oncancelled ) { objecthelper . requirenonnull ( oncancelled , str_ ) ; return new unicastprocessor < t > ( capacityhint , oncancelled ) ; }	Creates an UnicastProcessor with the given internal buffer capacity hint and a callback forthe case when the single Subscriber cancels its subscription.
@ suppresswarnings ( str_ ) public static < t , r > boolean tryscalarxmapsubscribe ( publisher < t > source , subscriber < ? super r > subscriber , function < ? super t , ? extends publisher < ? extends r > > mapper ) { if ( source instanceof callable ) { t t ; try { t = ( ( callable < t > ) source ) . call ( ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptysubscription . error ( ex , subscriber ) ; return bool_ ; } if ( t == null ) { emptysubscription . complete ( subscriber ) ; return bool_ ; } publisher < ? extends r > r ; try { r = objecthelper . requirenonnull ( mapper . apply ( t ) , str_ ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptysubscription . error ( ex , subscriber ) ; return bool_ ; } if ( r instanceof callable ) { r u ; try { u = ( ( callable < r > ) r ) . call ( ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptysubscription . error ( ex , subscriber ) ; return bool_ ; } if ( u == null ) { emptysubscription . complete ( subscriber ) ; return bool_ ; } subscriber . onsubscribe ( new scalarsubscription < r > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return bool_ ; } return bool_ ; }	Tries to subscribe to a possibly Callable source's mapped Publisher.
public static < t , u > flowable < u > scalarxmap ( final t value , final function < ? super t , ? extends publisher < ? extends u > > mapper ) { return rxjavaplugins . onassembly ( new scalarxmapflowable < t , u > ( value , mapper ) ) ; }	Maps a scalar value into a Publisher and emits its values.
public static void reset ( ) { seterrorhandler ( null ) ; setschedulehandler ( null ) ; setcomputationschedulerhandler ( null ) ; setinitcomputationschedulerhandler ( null ) ; setioschedulerhandler ( null ) ; setinitioschedulerhandler ( null ) ; setsingleschedulerhandler ( null ) ; setinitsingleschedulerhandler ( null ) ; setnewthreadschedulerhandler ( null ) ; setinitnewthreadschedulerhandler ( null ) ; setonflowableassembly ( null ) ; setonflowablesubscribe ( null ) ; setonobservableassembly ( null ) ; setonobservablesubscribe ( null ) ; setonsingleassembly ( null ) ; setonsinglesubscribe ( null ) ; setoncompletableassembly ( null ) ; setoncompletablesubscribe ( null ) ; setonconnectableflowableassembly ( null ) ; setonconnectableobservableassembly ( null ) ; setonmaybeassembly ( null ) ; setonmaybesubscribe ( null ) ; setonparallelassembly ( null ) ; setfailonnonblockingscheduler ( bool_ ) ; setonbeforeblocking ( null ) ; }	Removes all handlers and resets to default behavior.
@ checkreturnvalue @ nonnull @ schedulersupport ( schedulersupport . none ) public static < t > maybe < t > fromcompletable ( completablesource completablesource ) { objecthelper . requirenonnull ( completablesource , str_ ) ; return rxjavaplugins . onassembly ( new maybefromcompletable < t > ( completablesource ) ) ; }	Wraps a CompletableSource into a Maybe. Scheduler: {.
@ checkreturnvalue @ nonnull @ schedulersupport ( schedulersupport . none ) public static < t > maybe < t > fromsingle ( singlesource < t > singlesource ) { objecthelper . requirenonnull ( singlesource , str_ ) ; return rxjavaplugins . onassembly ( new maybefromsingle < t > ( singlesource ) ) ; }	Wraps a SingleSource into a Maybe. Scheduler: {.
@ checkreturnvalue @ schedulersupport ( schedulersupport . none ) public final maybe < t > retry ( long times , predicate < ? super throwable > predicate ) { return toflowable ( ) . retry ( times , predicate ) . singleelement ( ) ; }	Retries at most times or until the predicate returns false, whichever happens first. Scheduler: {.
public static < t > t requirenonnull ( t object , string message ) { if ( object == null ) { throw new nullpointerexception ( message ) ; } return object ; }	Verifies if the object is not null and returns it or throws a NullPointerExceptionwith the given message.
@ suppresswarnings ( str_ ) public static < t > function < t , t > identity ( ) { return ( function < t , t > ) identity ; }	Returns an identity function that simply returns its argument.
public static < t > callable < t > justcallable ( t value ) { return new justvalue < object , t > ( value ) ; }	Returns a Callable that returns the given value.
public static < t , u > function < t , u > justfunction ( u value ) { return new justvalue < t , u > ( value ) ; }	Returns a Function that ignores its parameter and returns the given value.
public static < t , u > function < t , u > castfunction ( class < u > target ) { return new casttoclass < t , u > ( target ) ; }	Returns a function that cast the incoming values via a Class object.
@ checkreturnvalue @ nonnull public static < t > unicastsubject < t > create ( ) { return new unicastsubject < t > ( buffersize ( ) , bool_ ) ; }	Creates an UnicastSubject with an internal buffer capacity hint 16.
@ checkreturnvalue @ nonnull public static < t > unicastsubject < t > create ( int capacityhint ) { return new unicastsubject < t > ( capacityhint , bool_ ) ; }	Creates an UnicastSubject with the given internal buffer capacity hint.
@ checkreturnvalue @ nonnull public static < t > unicastsubject < t > create ( int capacityhint , runnable onterminate ) { return new unicastsubject < t > ( capacityhint , onterminate , bool_ ) ; }	Creates an UnicastSubject with the given internal buffer capacity hint and a callback forthe case when the single Subscriber cancels its subscription.
@ checkreturnvalue @ nonnull public static < t > unicastsubject < t > create ( boolean delayerror ) { return new unicastsubject < t > ( buffersize ( ) , delayerror ) ; }	Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.
public throwable blockinggeterror ( ) { if ( getcount ( ) != num_ ) { try { blockinghelper . verifynonblocking ( ) ; await ( ) ; } catch ( interruptedexception ex ) { dispose ( ) ; return ex ; } } return error ; }	Block until the latch is counted down and return the error received or null if noerror happened.
public throwable blockinggeterror ( long timeout , timeunit unit ) { if ( getcount ( ) != num_ ) { try { blockinghelper . verifynonblocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw exceptionhelper . wraporthrow ( new timeoutexception ( timeoutmessage ( timeout , unit ) ) ) ; } } catch ( interruptedexception ex ) { dispose ( ) ; throw exceptionhelper . wraporthrow ( ex ) ; } } return error ; }	Block until the latch is counted down and return the error received orwhen the wait is interrupted or times out, null otherwise.
public boolean blockingawait ( long timeout , timeunit unit ) { if ( getcount ( ) != num_ ) { try { blockinghelper . verifynonblocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return bool_ ; } } catch ( interruptedexception ex ) { dispose ( ) ; throw exceptionhelper . wraporthrow ( ex ) ; } } throwable ex = error ; if ( ex != null ) { throw exceptionhelper . wraporthrow ( ex ) ; } return bool_ ; }	Block until the observer terminates and return true; return false ifthe wait times out.
public static < t , u > void drainmaxloop ( simpleplainqueue < t > q , subscriber < ? super u > a , boolean delayerror , disposable dispose , queuedrain < t , u > qd ) { int missed = num_ ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; t v = q . poll ( ) ; boolean empty = v == null ; if ( checkterminated ( d , empty , a , delayerror , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != num_ ) { if ( qd . accept ( a , v ) ) { if ( r != long . max_value ) { qd . produced ( num_ ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onerror ( new missingbackpressureexception ( str_ ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == num_ ) { break ; } } }	Drain the queue but give up with an error if there aren't enough requests.
public static void request ( subscription s , int prefetch ) { s . request ( prefetch < num_ ? long . max_value : prefetch ) ; }	Requests Long.MAX_VALUE if prefetch is negative or the exactamount if prefetch is positive.
protected final void complete ( r n ) { long p = produced ; if ( p != num_ ) { backpressurehelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & complete_mask ) != num_ ) { ondrop ( n ) ; return ; } if ( ( r & request_mask ) != num_ ) { lazyset ( complete_mask + num_ ) ; downstream . onnext ( n ) ; downstream . oncomplete ( ) ; return ; } value = n ; if ( compareandset ( num_ , complete_mask ) ) { return ; } value = null ; } }	Signals the given value and an onComplete if the downstream is ready to receive the final value.
@ suppresswarnings ( str_ ) @ nullable public t getvalue ( ) { object o = value ; if ( o != null && ! notificationlite . iserror ( o ) ) { return ( t ) value ; } return null ; }	Returns the contained value if this notification is an onNextsignal, null otherwise.
@ nullable public throwable geterror ( ) { object o = value ; if ( notificationlite . iserror ( o ) ) { return notificationlite . geterror ( o ) ; } return null ; }	Returns the container Throwable error if this notification is an onErrorsignal, null otherwise.
public static boolean validate ( disposable upstream , disposable next , class < ? > observer ) { objecthelper . requirenonnull ( next , str_ ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != disposablehelper . disposed ) { reportdoublesubscription ( observer ) ; } return bool_ ; } return bool_ ; }	Ensures that the upstream Disposable is null and returns true, otherwisedisposes the next Disposable and if the upstream is not the shareddisposed instance, reports a ProtocolViolationException due tomultiple subscribe attempts.
public static boolean setonce ( atomicreference < disposable > upstream , disposable next , class < ? > observer ) { objecthelper . requirenonnull ( next , str_ ) ; if ( ! upstream . compareandset ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != disposablehelper . disposed ) { reportdoublesubscription ( observer ) ; } return bool_ ; } return bool_ ; }	Atomically updates the target upstream AtomicReference from null to the non-nullnext Disposable, otherwise disposes next and reports a ProtocolViolationExceptionif the AtomicReference doesn't contain the shared disposed indicator.
public static boolean validate ( subscription upstream , subscription next , class < ? > subscriber ) { objecthelper . requirenonnull ( next , str_ ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != subscriptionhelper . cancelled ) { reportdoublesubscription ( subscriber ) ; } return bool_ ; } return bool_ ; }	Ensures that the upstream Subscription is null and returns true, otherwisecancels the next Subscription and if the upstream is not the sharedcancelled instance, reports a ProtocolViolationException due tomultiple subscribe attempts.
public static boolean setonce ( atomicreference < subscription > upstream , subscription next , class < ? > subscriber ) { objecthelper . requirenonnull ( next , str_ ) ; if ( ! upstream . compareandset ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != subscriptionhelper . cancelled ) { reportdoublesubscription ( subscriber ) ; } return bool_ ; } return bool_ ; }	Atomically updates the target upstream AtomicReference from null to the non-nullnext Subscription, otherwise cancels next and reports a ProtocolViolationExceptionif the AtomicReference doesn't contain the shared cancelled indicator.
public static long addcap ( long a , long b ) { long u = a + b ; if ( u < num_ ) { return long . max_value ; } return u ; }	Adds two long values and caps the sum at Long.MAX_VALUE.
public static long multiplycap ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) > > > num_ ) != num_ ) { if ( u / a != b ) { return long . max_value ; } } return u ; }	Multiplies two long values and caps the product at Long.MAX_VALUE.
public static long add ( atomiclong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == long . max_value ) { return long . max_value ; } long u = addcap ( r , n ) ; if ( requested . compareandset ( r , u ) ) { return r ; } } }	Atomically adds the positive value n to the requested value in the AtomicLong andcaps the result at Long.MAX_VALUE and returns the previous value.
private static nullpointerexception tonpe ( throwable ex ) { nullpointerexception npe = new nullpointerexception ( str_ ) ; npe . initcause ( ex ) ; return npe ; }	Creates a NullPointerException instance and sets the given Throwable as its initial cause.
public void add ( object o ) {	Adds a new element to this list.
public static void shutdown ( ) { scheduledexecutorservice exec = purge_thread . getandset ( null ) ; if ( exec != null ) { exec . shutdownnow ( ) ; } pools . clear ( ) ; }	Stops the purge thread.
public static scheduledexecutorservice create ( threadfactory factory ) { final scheduledexecutorservice exec = executors . newscheduledthreadpool ( num_ , factory ) ; tryputintopool ( purge_enabled , exec ) ; return exec ; }	Creates a ScheduledExecutorService with the given factory.
public final void setsubscription ( subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } objecthelper . requirenonnull ( s , str_ ) ; if ( get ( ) == num_ && compareandset ( num_ , num_ ) ) { subscription a = actual ; if ( a != null && cancelonreplace ) { a . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementandget ( ) != num_ ) { drainloop ( ) ; } if ( r != num_ ) { s . request ( r ) ; } return ; } subscription a = missedsubscription . getandset ( s ) ; if ( a != null && cancelonreplace ) { a . cancel ( ) ; } drain ( ) ; }	Atomically sets a new subscription.
void emitloop ( ) { for ( ; ; ) { appendonlylinkedarraylist < object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = bool_ ; return ; } queue = null ; } q . foreachwhile ( this ) ; } }	Loops until all notifications in the queue has been processed.
public static runtimeexception wraporthrow ( throwable error ) { if ( error instanceof error ) { throw ( error ) error ; } if ( error instanceof runtimeexception ) { return ( runtimeexception ) error ; } return new runtimeexception ( error ) ; }	If the provided Throwable is an Error this methodthrows it, otherwise returns a RuntimeException wrapping the errorif that error is a checked exception.
public static list < throwable > flatten ( throwable t ) { list < throwable > list = new arraylist < throwable > ( ) ; arraydeque < throwable > deque = new arraydeque < throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isempty ( ) ) { throwable e = deque . removefirst ( ) ; if ( e instanceof compositeexception ) { compositeexception ce = ( compositeexception ) e ; list < throwable > exceptions = ce . getexceptions ( ) ; for ( int i = exceptions . size ( ) - num_ ; i >= num_ ; i -- ) { deque . offerfirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }	Returns a flattened list of Throwables from tree-like CompositeException chain.
@ suppresswarnings ( str_ ) public static < e extends throwable > exception throwifthrowable ( throwable e ) throws e { if ( e instanceof exception ) { return ( exception ) e ; } throw ( e ) e ; }	Workaround for Java 6 not supporting throwing a final Throwable from a catch block.
public void clear ( ) { if ( disposed ) { return ; } openhashset < disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }	Atomically clears the container, then disposes all the previously contained Disposables.
public int size ( ) { if ( disposed ) { return num_ ; } synchronized ( this ) { if ( disposed ) { return num_ ; } openhashset < disposable > set = resources ; return set != null ? set . size ( ) : num_ ; } }	Returns the number of currently held Disposables.
@ suppresswarnings ( str_ ) public static < t , r > boolean tryscalarxmapsubscribe ( observablesource < t > source , observer < ? super r > observer , function < ? super t , ? extends observablesource < ? extends r > > mapper ) { if ( source instanceof callable ) { t t ; try { t = ( ( callable < t > ) source ) . call ( ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptydisposable . error ( ex , observer ) ; return bool_ ; } if ( t == null ) { emptydisposable . complete ( observer ) ; return bool_ ; } observablesource < ? extends r > r ; try { r = objecthelper . requirenonnull ( mapper . apply ( t ) , str_ ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptydisposable . error ( ex , observer ) ; return bool_ ; } if ( r instanceof callable ) { r u ; try { u = ( ( callable < r > ) r ) . call ( ) ; } catch ( throwable ex ) { exceptions . throwiffatal ( ex ) ; emptydisposable . error ( ex , observer ) ; return bool_ ; } if ( u == null ) { emptydisposable . complete ( observer ) ; return bool_ ; } scalardisposable < r > sd = new scalardisposable < r > ( observer , u ) ; observer . onsubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return bool_ ; } return bool_ ; }	Tries to subscribe to a possibly Callable source's mapped ObservableSource.
public static < t , u > observable < u > scalarxmap ( t value , function < ? super t , ? extends observablesource < ? extends u > > mapper ) { return rxjavaplugins . onassembly ( new scalarxmapobservable < t , u > ( value , mapper ) ) ; }	Maps a scalar value into an Observable and emits its values.
public < u > boolean accept ( subscriber < ? super u > subscriber ) { object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = num_ ; i < c ; i ++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notificationlite . acceptfull ( o , subscriber ) ) { return bool_ ; } } a = ( object [ ] ) a [ c ] ; } return bool_ ; }	Interprets the contents as NotificationLite objects and callsthe appropriate Subscriber method.
public < u > boolean accept ( observer < ? super u > observer ) { object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = num_ ; i < c ; i ++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notificationlite . acceptfull ( o , observer ) ) { return bool_ ; } } a = ( object [ ] ) a [ c ] ; } return bool_ ; }	Interprets the contents as NotificationLite objects and callsthe appropriate Observer method.
public void start ( ) { if ( subscriptionhelper . setonce ( upstream , emptysubscription . instance ) ) { queue = new spscarrayqueue < t > ( buffersize ) ; } }	Initializes this Processor by setting an upstream Subscription thatignores request amounts, uses a fixed bufferand allows using the onXXX and offer methodsafterwards.
public void startunbounded ( ) { if ( subscriptionhelper . setonce ( upstream , emptysubscription . instance ) ) { queue = new spsclinkedarrayqueue < t > ( buffersize ) ; } }	Initializes this Processor by setting an upstream Subscription thatignores request amounts, uses an unbounded bufferand allows using the onXXX and offer methodsafterwards.
public boolean offer ( t t ) { if ( once . get ( ) ) { return bool_ ; } objecthelper . requirenonnull ( t , str_ ) ; if ( fusionmode == queuesubscription . none ) { if ( queue . offer ( t ) ) { drain ( ) ; return bool_ ; } } return bool_ ; }	Tries to offer an item into the internal queue and returns falseif the queue is full.
@ nullable public disposable get ( ) { disposable d = resource . get ( ) ; if ( d == disposablehelper . disposed ) { return disposables . disposed ( ) ; } return d ; }	Returns the currently contained Disposable or null if this container is empty.
public final void complete ( t value ) { int state = get ( ) ; if ( ( state & ( fused_ready | fused_consumed | terminated | disposed ) ) != num_ ) { return ; } observer < ? super t > a = downstream ; if ( state == fused_empty ) { this . value = value ; lazyset ( fused_ready ) ; a . onnext ( null ) ; } else { lazyset ( terminated ) ; a . onnext ( value ) ; } if ( get ( ) != disposed ) { a . oncomplete ( ) ; } }	Complete the target with a single value or indicate there is a value available infusion mode.
public final void error ( throwable t ) { int state = get ( ) ; if ( ( state & ( fused_ready | fused_consumed | terminated | disposed ) ) != num_ ) { rxjavaplugins . onerror ( t ) ; return ; } lazyset ( terminated ) ; downstream . onerror ( t ) ; }	Complete the target with an error signal.
public final void complete ( ) { int state = get ( ) ; if ( ( state & ( fused_ready | fused_consumed | terminated | disposed ) ) != num_ ) { return ; } lazyset ( terminated ) ; downstream . oncomplete ( ) ; }	Complete the target without any value.
public perfasyncconsumer await ( int count ) { if ( count <= num_ ) { while ( getcount ( ) != num_ ) { } } else { try { await ( ) ; } catch ( interruptedexception ex ) { throw new runtimeexception ( ex ) ; } } return this ; }	Wait for the terminal signal.
protected final void request ( long n ) { subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }	Requests from the upstream Subscription.
boolean add ( publishdisposable < t > ps ) { for ( ; ; ) { publishdisposable < t > [ ] a = subscribers . get ( ) ; if ( a == terminated ) { return bool_ ; } int n = a . length ; @ suppresswarnings ( str_ ) publishdisposable < t > [ ] b = new publishdisposable [ n + num_ ] ; system . arraycopy ( a , num_ , b , num_ , n ) ; b [ n ] = ps ; if ( subscribers . compareandset ( a , b ) ) { return bool_ ; } } }	Tries to add the given subscriber to the subscribers array atomicallyor returns false if the subject has terminated.
@ suppresswarnings ( str_ ) void remove ( publishdisposable < t > ps ) { for ( ; ; ) { publishdisposable < t > [ ] a = subscribers . get ( ) ; if ( a == terminated || a == empty ) { return ; } int n = a . length ; int j = - num_ ; for ( int i = num_ ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < num_ ) { return ; } publishdisposable < t > [ ] b ; if ( n == num_ ) { b = empty ; } else { b = new publishdisposable [ n - num_ ] ; system . arraycopy ( a , num_ , b , num_ , j ) ; system . arraycopy ( a , j + num_ , b , j , n - j - num_ ) ; } if ( subscribers . compareandset ( a , b ) ) { return ; } } }	Atomically removes the given subscriber if it is subscribed to the subject.
public static < t > connectableflowable < t > observeon ( final connectableflowable < t > cf , final scheduler scheduler ) { final flowable < t > flowable = cf . observeon ( scheduler ) ; return rxjavaplugins . onassembly ( new connectableflowablereplay < t > ( cf , flowable ) ) ; }	Child Subscribers will observe the events of the ConnectableObservable on thespecified scheduler.
static < responset , returnt > httpservicemethod < responset , returnt > parseannotations ( retrofit retrofit , method method , requestfactory requestfactory ) { boolean iskotlinsuspendfunction = requestfactory . iskotlinsuspendfunction ; boolean continuationwantsresponse = bool_ ; boolean continuationbodynullable = bool_ ; annotation [ ] annotations = method . getannotations ( ) ; type adaptertype ; if ( iskotlinsuspendfunction ) { type [ ] parametertypes = method . getgenericparametertypes ( ) ; type responsetype = utils . getparameterlowerbound ( num_ , ( parameterizedtype ) parametertypes [ parametertypes . length - num_ ] ) ; if ( getrawtype ( responsetype ) == response . class && responsetype instanceof parameterizedtype ) {	Inspects the annotations on an interface method to construct a reusable service method thatspeaks HTTP.
public void setdelay ( long amount , timeunit unit ) { if ( amount < num_ ) { throw new illegalargumentexception ( str_ ) ; } this . delayms = unit . tomillis ( amount ) ; }	Set the network round trip delay.
public response < ? > createerrorresponse ( ) { response < ? > call ; try { call = errorfactory . call ( ) ; } catch ( exception e ) { throw new illegalstateexception ( str_ , e ) ; } if ( call == null ) { throw new illegalstateexception ( str_ ) ; } if ( call . issuccessful ( ) ) { throw new illegalstateexception ( str_ ) ; } return call ; }	The HTTP error to be used when an error is triggered.
public long calculatedelay ( timeunit unit ) { float delta = variancepercent / num_ ;	Get the delay that should be used for delaying a response in accordance with configuredbehavior.
private void createsampledata ( string username , string password ) { assert . notnull ( documentdao , str_ ) ; assert . hastext ( username , str_ ) ; authentication auth = new usernamepasswordauthenticationtoken ( username , password ) ; try {	Creates a directory for the user, and a series of sub-directories.
private static httpmethod valueof ( string method ) { try { return httpmethod . valueof ( method ) ; } catch ( illegalargumentexception e ) { } return null ; }	Provides a save way of obtaining the HttpMethod from a String.
@ override public dircontextoperations searchforuser ( string username ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + username + str_ + this ) ; } springsecurityldaptemplate template = new springsecurityldaptemplate ( contextsource ) ; template . setsearchcontrols ( searchcontrols ) ; try { return template . searchforsingleentry ( searchbase , searchfilter , new string [ ] { username } ) ; } catch ( incorrectresultsizedataaccessexception notfound ) { if ( notfound . getactualsize ( ) == num_ ) { throw new usernamenotfoundexception ( str_ + username + str_ ) ; }	Return the LdapUserDetails containing the user's information.
public string encode ( charsequence rawpassword ) { string salt = prefix + this . saltgenerator . generatekey ( ) + suffix ; return digest ( salt , rawpassword ) ; }	Encodes the rawPass using a MessageDigest.
public boolean matches ( charsequence rawpassword , string encodedpassword ) { string salt = extractsalt ( encodedpassword ) ; string rawpasswordencoded = digest ( salt , rawpassword ) ; return passwordencoderutils . equals ( encodedpassword . tostring ( ) , rawpasswordencoded ) ; }	Takes a previously encoded password and compares it with a rawpassword after mixingin the salt and encoding that value.
private static void performversionchecks ( string minspringversion ) { if ( minspringversion == null ) { return ; }	Perform version checks with specific min Spring Version.
private static boolean disablechecks ( string springversion , string springsecurityversion ) { if ( springversion == null || springversion . equals ( springsecurityversion ) ) { return bool_ ; } return boolean . getboolean ( disable_checks ) ; }	Disable if springVersion and springSecurityVersion are the same to allow workingwith Uber Jars.
private static string getspringversion ( ) { properties properties = new properties ( ) ; try { properties . load ( springsecuritycoreversion . class . getclassloader ( ) . getresourceasstream ( str_ ) ) ; } catch ( ioexception | nullpointerexception e ) { return null ; } return properties . getproperty ( str_ ) ; }	Loads the spring version or null if it cannot be found.
public attributeexchangeconfigurer attributeexchange ( string identifierpattern ) { attributeexchangeconfigurer attributeexchangeconfigurer = new attributeexchangeconfigurer ( identifierpattern ) ; this . attributeexchangeconfigurers . add ( attributeexchangeconfigurer ) ; return attributeexchangeconfigurer ; }	Sets up OpenID attribute exchange for OpenID's matching the specified pattern.
public oauth2clientconfigurer < httpsecurity > oauth2client ( ) throws exception { oauth2clientconfigurer < httpsecurity > configurer = getorapply ( new oauth2clientconfigurer < > ( ) ) ; this . postprocess ( configurer ) ; return configurer ; }	Configures OAuth 2.0 Client support.
public oauth2resourceserverconfigurer < httpsecurity > oauth2resourceserver ( ) throws exception { oauth2resourceserverconfigurer < httpsecurity > configurer = getorapply ( new oauth2resourceserverconfigurer < > ( getcontext ( ) ) ) ; this . postprocess ( configurer ) ; return configurer ; }	Configures OAuth 2.0 Resource Server support.
public boolean compare ( final string dn , final string attributename , final object value ) { final string comparisonfilter = str_ + attributename + str_ ; class ldapcomparecallback implements contextexecutor { public object executewithcontext ( dircontext ctx ) throws namingexception { searchcontrols ctls = new searchcontrols ( ) ; ctls . setreturningattributes ( no_attrs ) ; ctls . setsearchscope ( searchcontrols . object_scope ) ; namingenumeration < searchresult > results = ctx . search ( dn , comparisonfilter , new object [ ] { value } , ctls ) ; boolean match = boolean . valueof ( results . hasmore ( ) ) ; ldaputils . closeenumeration ( results ) ; return match ; } } boolean matches = ( boolean ) executereadonly ( new ldapcomparecallback ( ) ) ; return matches . booleanvalue ( ) ; }	Performs an LDAP compare operation of the value of an attribute for a particulardirectory entry.
public dircontextoperations retrieveentry ( final string dn , final string [ ] attributestoretrieve ) { return ( dircontextoperations ) executereadonly ( new contextexecutor ( ) { public object executewithcontext ( dircontext ctx ) throws namingexception { attributes attrs = ctx . getattributes ( dn , attributestoretrieve ) ;	Composes an object from the attributes of the given DN.
public set < string > searchforsingleattributevalues ( final string base , final string filter , final object [ ] params , final string attributename ) { string [ ] attributenames = new string [ ] { attributename } ; set < map < string , list < string > > > multipleattributevalues = searchformultipleattributevalues ( base , filter , params , attributenames ) ; set < string > result = new hashset < > ( ) ; for ( map < string , list < string > > map : multipleattributevalues ) { list < string > values = map . get ( attributename ) ; if ( values != null ) { result . addall ( values ) ; } } return result ; }	Performs a search using the supplied filter and returns the union of the values ofthe named attribute found in all entries matched by the search.
public static dircontextoperations searchforsingleentryinternal ( dircontext ctx , searchcontrols searchcontrols , string base , string filter , object [ ] params ) throws namingexception { final distinguishedname ctxbasedn = new distinguishedname ( ctx . getnameinnamespace ( ) ) ; final distinguishedname searchbasedn = new distinguishedname ( base ) ; final namingenumeration < searchresult > resultsenum = ctx . search ( searchbasedn , filter , params , buildcontrols ( searchcontrols ) ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + ctxbasedn + str_ + searchbasedn + str_ + filter + str_ ) ; } set < dircontextoperations > results = new hashset < > ( ) ; try { while ( resultsenum . hasmore ( ) ) { searchresult searchresult = resultsenum . next ( ) ; dircontextadapter dca = ( dircontextadapter ) searchresult . getobject ( ) ; assert . notnull ( dca , str_ ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + dca . getdn ( ) ) ; } results . add ( dca ) ; } } catch ( partialresultexception e ) { ldaputils . closeenumeration ( resultsenum ) ; logger . info ( str_ ) ; } if ( results . size ( ) == num_ ) { throw new incorrectresultsizedataaccessexception ( num_ , num_ ) ; } if ( results . size ( ) > num_ ) { throw new incorrectresultsizedataaccessexception ( num_ , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }	Internal method extracted to avoid code duplication in AD search.
private static searchcontrols buildcontrols ( searchcontrols originalcontrols ) { return new searchcontrols ( originalcontrols . getsearchscope ( ) , originalcontrols . getcountlimit ( ) , originalcontrols . gettimelimit ( ) , originalcontrols . getreturningattributes ( ) , return_object , originalcontrols . getdereflinkflag ( ) ) ; }	We need to make sure the search controls has the return object flag set to true, inorder for the search to return DirContextAdapter instances.
private void lookupprimarykeys ( final map < serializable , acl > acls , final set < long > findnow , final list < sid > sids ) { assert . notnull ( acls , str_ ) ; assert . notempty ( findnow , str_ ) ; string sql = computerepeatingsql ( lookupprimarykeyswhereclause , findnow . size ( ) ) ; set < long > parentstolookup = jdbctemplate . query ( sql , new preparedstatementsetter ( ) { public void setvalues ( preparedstatement ps ) throws sqlexception { int i = num_ ; for ( long tofind : findnow ) { i ++ ; ps . setlong ( i , tofind ) ; } } } , new processresultset ( acls , sids ) ) ;	Locates the primary key IDs specified in "findNow", adding AclImpl instances withStubAclParents to the "acls" Map.
public preauthenticatedgrantedauthoritieswebauthenticationdetails builddetails ( httpservletrequest context ) { collection < string > j2eeuserroles = getuserroles ( context ) ; collection < ? extends grantedauthority > usergas = j2eeuserroles2grantedauthoritiesmapper . getgrantedauthorities ( j2eeuserroles ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + j2eeuserroles + str_ + usergas + str_ ) ; } preauthenticatedgrantedauthoritieswebauthenticationdetails result = new preauthenticatedgrantedauthoritieswebauthenticationdetails ( context , usergas ) ; return result ; }	Builds the authentication details object.
private rootbeandefinition createembeddedserver ( element element , parsercontext parsercontext ) { object source = parsercontext . extractsource ( element ) ; string suffix = element . getattribute ( att_root_suffix ) ; if ( ! stringutils . hastext ( suffix ) ) { suffix = opt_default_root_suffix ; } string port = element . getattribute ( att_port ) ; if ( ! stringutils . hastext ( port ) ) { port = getdefaultport ( ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + port ) ; } } string url = str_ + port + str_ + suffix ; beandefinitionbuilder contextsource = beandefinitionbuilder . rootbeandefinition ( context_source_class ) ; contextsource . addconstructorargvalue ( url ) ; contextsource . addpropertyvalue ( str_ , str_ ) ; contextsource . addpropertyvalue ( str_ , str_ ) ; rootbeandefinition apachecontainer = new rootbeandefinition ( str_ , null , null ) ; apachecontainer . setsource ( source ) ; apachecontainer . getconstructorargumentvalues ( ) . addgenericargumentvalue ( suffix ) ; string ldifs = element . getattribute ( att_ldif_file ) ; if ( ! stringutils . hastext ( ldifs ) ) { ldifs = opt_default_ldif_file ; } apachecontainer . getconstructorargumentvalues ( ) . addgenericargumentvalue ( ldifs ) ; apachecontainer . getpropertyvalues ( ) . addpropertyvalue ( str_ , port ) ; logger . info ( str_ + url ) ; if ( parsercontext . getregistry ( ) . containsbeandefinition ( beanids . embedded_apache_ds ) ) { parsercontext . getreadercontext ( ) . error ( str_ , element ) ; } parsercontext . getregistry ( ) . registerbeandefinition ( beanids . embedded_apache_ds , apachecontainer ) ; return ( rootbeandefinition ) contextsource . getbeandefinition ( ) ; }	Will be called if no url attribute is supplied.Registers beans to create an embedded apache directory server.
private void createservletapifilter ( beanreference authenticationmanager ) { final string att_servlet_api_provision = str_ ; final string def_servlet_api_provision = str_ ; string provideservletapi = httpelt . getattribute ( att_servlet_api_provision ) ; if ( ! stringutils . hastext ( provideservletapi ) ) { provideservletapi = def_servlet_api_provision ; } if ( str_ . equals ( provideservletapi ) ) { servapifilter = grantedauthoritydefaultsparserutils . registerwithdefaultroleprefix ( pc , securitycontextholderawarerequestfilterbeanfactory . class ) ; servapifilter . getpropertyvalues ( ) . add ( str_ , authenticationmanager ) ; } }	Adds the servlet-api integration filter if required.
private void createjaasapifilter ( ) { final string att_jaas_api_provision = str_ ; final string def_jaas_api_provision = str_ ; string providejaasapi = httpelt . getattribute ( att_jaas_api_provision ) ; if ( ! stringutils . hastext ( providejaasapi ) ) { providejaasapi = def_jaas_api_provision ; } if ( str_ . equals ( providejaasapi ) ) { jaasapifilter = new rootbeandefinition ( jaasapiintegrationfilter . class ) ; } }	Adds the jaas-api integration filter if required.
private static typeresolverbuilder < ? extends typeresolverbuilder > createwhitelisteddefaulttyping ( ) { typeresolverbuilder < ? extends typeresolverbuilder > result = new whitelisttyperesolverbuilder ( objectmapper . defaulttyping . non_final ) ; result = result . init ( jsontypeinfo . id . class , null ) ; result = result . inclusion ( jsontypeinfo . as . property ) ; return result ; }	Creates a TypeResolverBuilder that performs whitelisting.
private void insertspringsecurityfilterchain ( servletcontext servletcontext ) { string filtername = default_filter_name ; delegatingfilterproxy springsecurityfilterchain = new delegatingfilterproxy ( filtername ) ; string contextattribute = getwebapplicationcontextattribute ( ) ; if ( contextattribute != null ) { springsecurityfilterchain . setcontextattribute ( contextattribute ) ; } registerfilter ( servletcontext , bool_ , filtername , springsecurityfilterchain ) ; }	Registers the springSecurityFilterChain.
public persistentremembermetoken gettokenforseries ( string seriesid ) { try { return getjdbctemplate ( ) . queryforobject ( tokensbyseriessql , new rowmapper < persistentremembermetoken > ( ) { public persistentremembermetoken maprow ( resultset rs , int rownum ) throws sqlexception { return new persistentremembermetoken ( rs . getstring ( num_ ) , rs . getstring ( num_ ) , rs . getstring ( num_ ) , rs . gettimestamp ( num_ ) ) ; } } , seriesid ) ; } catch ( emptyresultdataaccessexception zeroresults ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + seriesid + str_ , zeroresults ) ; } } catch ( incorrectresultsizedataaccessexception morethanone ) { logger . error ( str_ + seriesid + str_ + str_ ) ; } catch ( dataaccessexception e ) { logger . error ( str_ + seriesid , e ) ; } return null ; }	Loads the token data for the supplied series identifier.If an error occurs, it will be reported and null will be returned (since the resultshould just be a failed persistent login).
public list < grantedauthority > getgrantedauthorities ( collection < string > attributes ) { list < grantedauthority > result = new arraylist < > ( attributes . size ( ) ) ; for ( string attribute : attributes ) { result . add ( getgrantedauthority ( attribute ) ) ; } return result ; }	Map the given list of string attributes one-to-one to Spring SecurityGrantedAuthorities.
public static cipher newcipher ( string algorithm ) { try { return cipher . getinstance ( algorithm ) ; } catch ( nosuchalgorithmexception e ) { throw new illegalargumentexception ( str_ , e ) ; } catch ( nosuchpaddingexception e ) { throw new illegalstateexception ( str_ , e ) ; } }	Constructs a new Cipher.
@ override public void afterpropertiesset ( ) { try { super . afterpropertiesset ( ) ; } catch ( servletexception e ) {	Check whether all required properties have been set.
public void dofilter ( servletrequest request , servletresponse response , filterchain chain ) throws ioexception , servletexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + securitycontextholder . getcontext ( ) . getauthentication ( ) ) ; } if ( requiresauthentication ( ( httpservletrequest ) request ) ) { doauthenticate ( ( httpservletrequest ) request , ( httpservletresponse ) response ) ; } chain . dofilter ( request , response ) ; }	Try to authenticate a pre-authenticated user with Spring Security if the user hasnot yet been authenticated.
protected boolean principalchanged ( httpservletrequest request , authentication currentauthentication ) { object principal = getpreauthenticatedprincipal ( request ) ; if ( ( principal instanceof string ) && currentauthentication . getname ( ) . equals ( principal ) ) { return bool_ ; } if ( principal != null && principal . equals ( currentauthentication . getprincipal ( ) ) ) { return bool_ ; } if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + principal + str_ ) ; } return bool_ ; }	Determines if the current principal has changed. The default implementation tries If the {.
private void doauthenticate ( httpservletrequest request , httpservletresponse response ) throws ioexception , servletexception { authentication authresult ; object principal = getpreauthenticatedprincipal ( request ) ; object credentials = getpreauthenticatedcredentials ( request ) ; if ( principal == null ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ ) ; } return ; } if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + principal + str_ ) ; } try { preauthenticatedauthenticationtoken authrequest = new preauthenticatedauthenticationtoken ( principal , credentials ) ; authrequest . setdetails ( authenticationdetailssource . builddetails ( request ) ) ; authresult = authenticationmanager . authenticate ( authrequest ) ; successfulauthentication ( request , response , authresult ) ; } catch ( authenticationexception failed ) { unsuccessfulauthentication ( request , response , failed ) ; if ( ! continuefilterchainonunsuccessfulauthentication ) { throw failed ; } } }	Do the actual authentication for a pre-authenticated user.
private void checkcontentlength ( long contentlengthtowrite ) { this . contentwritten += contentlengthtowrite ; boolean isbodyfullywritten = this . contentlength > num_ && this . contentwritten >= this . contentlength ; int buffersize = getbuffersize ( ) ; boolean requiresflush = buffersize > num_ && this . contentwritten >= buffersize ; if ( isbodyfullywritten || requiresflush ) { doonresponsecommitted ( ) ; } }	Adds the contentLengthToWrite to the total contentWritten size and checks to see ifthe response should be written.
public set < grantedauthority > mapauthorities ( collection < ? extends grantedauthority > authorities ) { hashset < grantedauthority > mapped = new hashset < > ( authorities . size ( ) ) ; for ( grantedauthority authority : authorities ) { mapped . add ( mapauthority ( authority . getauthority ( ) ) ) ; } if ( defaultauthority != null ) { mapped . add ( defaultauthority ) ; } return mapped ; }	Creates a mapping of the supplied authorities based on the case-conversion andprefix settings.
public t loginprocessingurl ( string loginprocessingurl ) { this . loginprocessingurl = loginprocessingurl ; authfilter . setrequiresauthenticationrequestmatcher ( createloginprocessingurlmatcher ( loginprocessingurl ) ) ; return getself ( ) ; }	Specifies the URL to validate the credentials.
protected final void updateauthenticationdefaults ( ) { if ( loginprocessingurl == null ) { loginprocessingurl ( loginpage ) ; } if ( failurehandler == null ) { failureurl ( loginpage + str_ ) ; } final logoutconfigurer < b > logoutconfigurer = getbuilder ( ) . getconfigurer ( logoutconfigurer . class ) ; if ( logoutconfigurer != null && ! logoutconfigurer . iscustomlogoutsuccess ( ) ) { logoutconfigurer . logoutsuccessurl ( loginpage + str_ ) ; } }	Updates the default values for authentication.
protected final void updateaccessdefaults ( b http ) { if ( permitall ) { permitallsupport . permitall ( http , loginpage , loginprocessingurl , failureurl ) ; } }	Updates the default values for access.
protected string mappassword ( object passwordvalue ) { if ( ! ( passwordvalue instanceof string ) ) {	Extension point to allow customized creation of the user's password from theattribute stored in the directory.
protected string extractremembermecookie ( httpservletrequest request ) { cookie [ ] cookies = request . getcookies ( ) ; if ( ( cookies == null ) || ( cookies . length == num_ ) ) { return null ; } for ( cookie cookie : cookies ) { if ( cookiename . equals ( cookie . getname ( ) ) ) { return cookie . getvalue ( ) ; } } return null ; }	Locates the Spring Security remember me cookie in the request and returns itsvalue.
protected string encodecookie ( string [ ] cookietokens ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < cookietokens . length ; i ++ ) { try { sb . append ( urlencoder . encode ( cookietokens [ i ] , standardcharsets . utf_8 . tostring ( ) ) ) ; } catch ( unsupportedencodingexception e ) { logger . error ( e . getmessage ( ) , e ) ; } if ( i < cookietokens . length - num_ ) { sb . append ( delimiter ) ; } } string value = sb . tostring ( ) ; sb = new stringbuilder ( new string ( base64 . getencoder ( ) . encode ( value . getbytes ( ) ) ) ) ; while ( sb . charat ( sb . length ( ) - num_ ) == str_ ) { sb . deletecharat ( sb . length ( ) - num_ ) ; } return sb . tostring ( ) ; }	Inverse operation of decodeCookie.
protected void setcookie ( string [ ] tokens , int maxage , httpservletrequest request , httpservletresponse response ) { string cookievalue = encodecookie ( tokens ) ; cookie cookie = new cookie ( cookiename , cookievalue ) ; cookie . setmaxage ( maxage ) ; cookie . setpath ( getcookiepath ( request ) ) ; if ( cookiedomain != null ) { cookie . setdomain ( cookiedomain ) ; } if ( maxage < num_ ) { cookie . setversion ( num_ ) ; } if ( usesecurecookie == null ) { cookie . setsecure ( request . issecure ( ) ) ; } else { cookie . setsecure ( usesecurecookie ) ; } cookie . sethttponly ( bool_ ) ; response . addcookie ( cookie ) ; }	Sets the cookie on the response.By default a secure cookie will be used if the connection is secure.
@ override public mono < object > resolveargument ( methodparameter parameter , bindingcontext bindingcontext , serverwebexchange exchange ) { reactiveadapter adapter = getadapterregistry ( ) . getadapter ( parameter . getparametertype ( ) ) ; mono < securitycontext > reactivesecuritycontext = reactivesecuritycontextholder . getcontext ( ) ; if ( reactivesecuritycontext == null ) { return null ; } return reactivesecuritycontext . flatmap ( a -> { object p = resolvesecuritycontext ( parameter , a ) ; mono < object > o = mono . justorempty ( p ) ; return adapter == null ? o : mono . just ( adapter . frompublisher ( o ) ) ; } ) ; }	resolve the argument to inject into the controller parameter.
private string getquerystring ( final httpservletrequest request , final pattern artifactpattern ) { final string query = request . getquerystring ( ) ; if ( query == null ) { return null ; } final string result = artifactpattern . matcher ( query ) . replacefirst ( str_ ) ; if ( result . length ( ) == num_ ) { return null ; }	If present, removes the artifactParameterName and the corresponding value from thequery String.
private static int getserviceport ( url casserviceurl ) { int port = casserviceurl . getport ( ) ; if ( port == - num_ ) { port = casserviceurl . getdefaultport ( ) ; } return port ; }	Gets the port from the casServiceURL ensuring to return the proper value if thedefault port is being used.
public string getprincipal ( ) { authentication authentication = securitycontextholder . getcontext ( ) . getauthentication ( ) ; if ( authentication == null ) { log . warn ( str_ ) ; return str_ ; } object principal = authentication . getprincipal ( ) ; if ( principal instanceof ldapuserdetails ) { ldapuserdetails details = ( ldapuserdetails ) principal ; return details . getdn ( ) ; } else if ( authentication instanceof anonymousauthenticationtoken ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ ) ; } return str_ ; } else { throw new illegalargumentexception ( str_ + str_ ) ; } }	Get the principals of the logged in user, in this case the distinguished name.
public void logout ( httpservletrequest request , httpservletresponse response , authentication authentication ) { assert . notnull ( request , str_ ) ; if ( invalidatehttpsession ) { httpsession session = request . getsession ( bool_ ) ; if ( session != null ) { logger . debug ( str_ + session . getid ( ) ) ; session . invalidate ( ) ; } } if ( clearauthentication ) { securitycontext context = securitycontextholder . getcontext ( ) ; context . setauthentication ( null ) ; } securitycontextholder . clearcontext ( ) ; }	Requires the request to be passed in.
public authentication authenticate ( authentication auth ) throws authenticationexception { if ( ! ( auth instanceof usernamepasswordauthenticationtoken ) ) { return null ; } usernamepasswordauthenticationtoken request = ( usernamepasswordauthenticationtoken ) auth ; set < grantedauthority > authorities ; try {	Attempts to login the user given the Authentication objects principal andcredential.
public void setcontextenvironmentproperties ( map < string , object > environment ) { assert . notempty ( environment , str_ ) ; this . contextenvironmentproperties = new hashtable < > ( environment ) ; }	Allows a custom environment properties to be used to create initial LDAP context.
@ override public string getredirecturl ( ) { return urlutils . buildfullrequesturl ( scheme , servername , serverport , requesturi , querystring ) ; }	Indicates the URL that the user agent used for this request.
public int doendtag ( ) throws jspexception { try { if ( ! authorized && taglibconfig . isuisecuritydisabled ( ) ) { pagecontext . getout ( ) . write ( taglibconfig . getsecureduisuffix ( ) ) ; } } catch ( ioexception e ) { throw new jspexception ( e ) ; } return eval_page ; }	Default processing of the end tag returning EVAL_PAGE.
@ override protected void inituserdetailsservice ( ) throws exception { for ( userdetailsbuilder userbuilder : userbuilders ) { getuserdetailsservice ( ) . createuser ( userbuilder . build ( ) ) ; } for ( userdetails userdetails : this . users ) { getuserdetailsservice ( ) . createuser ( userdetails ) ; } }	Populates the users that have been added.
private userdetailsservice getuserdetailsservice ( ) { map < string , ? > beans = getbeansoftype ( cachinguserdetailsservice . class ) ; if ( beans . size ( ) == num_ ) { beans = getbeansoftype ( userdetailsservice . class ) ; } if ( beans . size ( ) == num_ ) { throw new applicationcontextexception ( str_ ) ; } else if ( beans . size ( ) > num_ ) { throw new applicationcontextexception ( str_ + str_ ) ; } return ( userdetailsservice ) beans . values ( ) . toarray ( ) [ num_ ] ; }	Obtains a user details service for use in RememberMeServices etc.
private void addpkceparameters ( map < string , object > attributes , map < string , object > additionalparameters ) { string codeverifier = this . codeverifiergenerator . generatekey ( ) ; attributes . put ( pkceparameternames . code_verifier , codeverifier ) ; try { string codechallenge = createcodechallenge ( codeverifier ) ; additionalparameters . put ( pkceparameternames . code_challenge , codechallenge ) ; additionalparameters . put ( pkceparameternames . code_challenge_method , str_ ) ; } catch ( nosuchalgorithmexception e ) { additionalparameters . put ( pkceparameternames . code_challenge , codeverifier ) ; } }	Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests.
protected boolean requiresauthentication ( final httpservletrequest request , final httpservletresponse response ) { final boolean serviceticketrequest = serviceticketrequest ( request , response ) ; final boolean result = serviceticketrequest || proxyreceptorrequest ( request ) || ( proxyticketrequest ( serviceticketrequest , request ) ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + result ) ; } return result ; }	Overridden to provide proxying capabilities.
private boolean serviceticketrequest ( final httpservletrequest request , final httpservletresponse response ) { boolean result = super . requiresauthentication ( request , response ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + result ) ; } return result ; }	Indicates if the request is elgible to process a service ticket.
private boolean proxyticketrequest ( final boolean serviceticketrequest , final httpservletrequest request ) { if ( serviceticketrequest ) { return bool_ ; } final boolean result = authenticateallartifacts && obtainartifact ( request ) != null && ! authenticated ( ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + result ) ; } return result ; }	Indicates if the request is elgible to process a proxy ticket.
private boolean authenticated ( ) { authentication authentication = securitycontextholder . getcontext ( ) . getauthentication ( ) ; return authentication != null && authentication . isauthenticated ( ) && ! ( authentication instanceof anonymousauthenticationtoken ) ; }	Determines if a user is already authenticated.
private boolean proxyreceptorrequest ( final httpservletrequest request ) { final boolean result = proxyreceptorconfigured ( ) && proxyreceptormatcher . matches ( request ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + result ) ; } return result ; }	Indicates if the request is elgible to be processed as the proxy receptor.
protected methodsecurityexpressionoperations createsecurityexpressionroot ( authentication authentication , methodinvocation invocation ) { methodsecurityexpressionroot root = new methodsecurityexpressionroot ( authentication ) ; root . setthis ( invocation . getthis ( ) ) ; root . setpermissionevaluator ( getpermissionevaluator ( ) ) ; root . settrustresolver ( gettrustresolver ( ) ) ; root . setrolehierarchy ( getrolehierarchy ( ) ) ; root . setdefaultroleprefix ( getdefaultroleprefix ( ) ) ; return root ; }	Creates the root object for expression evaluation.
private mono < jwkset > getjwkset ( ) { return this . webclient . get ( ) . uri ( this . jwkseturl ) . retrieve ( ) . bodytomono ( string . class ) . map ( this :: parse ) . doonnext ( jwkset -> this . cachedjwkset . set ( mono . just ( jwkset ) ) ) . cache ( ) ; }	Updates the cached JWK set from the configured URL.
private string utf8urlencode ( string value ) { try { return urlencoder . encode ( value , str_ ) ; } catch ( unsupportedencodingexception e ) { error err = new assertionerror ( str_ ) ; err . initcause ( e ) ; throw err ; } }	Performs URL encoding with UTF-8.
private collection < ? extends grantedauthority > getwebspheregroupsbasedgrantedauthorities ( ) { list < string > webspheregroups = washelper . getgroupsforcurrentuser ( ) ; collection < ? extends grantedauthority > usergas = webspheregroups2grantedauthoritiesmapper . getgrantedauthorities ( webspheregroups ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + webspheregroups + str_ + usergas ) ; } return usergas ; }	Get a list of Granted Authorities based on the current user's WebSphere groups.
protected userdetails loaduserbyassertion ( final assertion assertion ) { final casassertionauthenticationtoken token = new casassertionauthenticationtoken ( assertion , str_ ) ; return this . authenticationuserdetailsservice . loaduserdetails ( token ) ; }	Template method for retrieving the UserDetails based on the assertion.
protected object getpreauthenticatedprincipal ( httpservletrequest httprequest ) { object principal = washelper . getcurrentusername ( ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + principal ) ; } return principal ; }	Return the WebSphere user name.
public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = num_ ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newarray = new byte [ length ] ; int destpos = num_ ; for ( byte [ ] array : arrays ) { system . arraycopy ( array , num_ , newarray , destpos , array . length ) ; destpos += array . length ; } return newarray ; }	Combine the individual byte arrays into one array.
public static byte [ ] subarray ( byte [ ] array , int beginindex , int endindex ) { int length = endindex - beginindex ; byte [ ] subarray = new byte [ length ] ; system . arraycopy ( array , beginindex , subarray , num_ , length ) ; return subarray ; }	Extract a sub array of bytes out of the byte array.
public list < grantedauthority > getgrantedauthorities ( collection < string > attributes ) { arraylist < grantedauthority > galist = new arraylist < > ( ) ; for ( string attribute : attributes ) { collection < grantedauthority > c = attributes2grantedauthoritiesmap . get ( attribute ) ; if ( c != null ) { galist . addall ( c ) ; } } galist . trimtosize ( ) ; return galist ; }	Map the given array of attributes to Spring Security GrantedAuthorities.
private map < string , collection < grantedauthority > > preprocessmap ( map < ? , ? > orgmap ) { map < string , collection < grantedauthority > > result = new hashmap < string , collection < grantedauthority > > ( orgmap . size ( ) ) ; for ( map . entry < ? , ? > entry : orgmap . entryset ( ) ) { assert . isinstanceof ( string . class , entry . getkey ( ) , str_ ) ; result . put ( ( string ) entry . getkey ( ) , getgrantedauthoritycollection ( entry . getvalue ( ) ) ) ; } return result ; }	Preprocess the given map to convert all the values to GrantedAuthority collections.
private collection < grantedauthority > getgrantedauthoritycollection ( object value ) { collection < grantedauthority > result = new arraylist < > ( ) ; addgrantedauthoritycollection ( result , value ) ; return result ; }	Convert the given value to a collection of Granted Authorities.
private void addgrantedauthoritycollection ( collection < grantedauthority > result , object value ) { if ( value == null ) { return ; } if ( value instanceof collection < ? > ) { addgrantedauthoritycollection ( result , ( collection < ? > ) value ) ; } else if ( value instanceof object [ ] ) { addgrantedauthoritycollection ( result , ( object [ ] ) value ) ; } else if ( value instanceof string ) { addgrantedauthoritycollection ( result , ( string ) value ) ; } else if ( value instanceof grantedauthority ) { result . add ( ( grantedauthority ) value ) ; } else { throw new illegalargumentexception ( str_ + value . getclass ( ) . getname ( ) ) ; } }	Convert the given value to a collection of Granted Authorities, adding the resultto the given result collection.
protected object getpreauthenticatedprincipal ( httpservletrequest httprequest ) { object principal = httprequest . getuserprincipal ( ) == null ? null : httprequest . getuserprincipal ( ) . getname ( ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + principal ) ; } return principal ; }	Return the J2EE user name.
@ suppresswarnings ( str_ ) public < c > c getsharedobject ( class < c > sharedtype ) { return ( c ) this . sharedobjects . get ( sharedtype ) ; }	Gets a shared Object.
protected string buildhttpsredirecturlforrequest ( httpservletrequest request ) throws ioexception , servletexception { int serverport = portresolver . getserverport ( request ) ; integer httpsport = portmapper . lookuphttpsport ( integer . valueof ( serverport ) ) ; if ( httpsport != null ) { redirecturlbuilder urlbuilder = new redirecturlbuilder ( ) ; urlbuilder . setscheme ( str_ ) ; urlbuilder . setservername ( request . getservername ( ) ) ; urlbuilder . setport ( httpsport . intvalue ( ) ) ; urlbuilder . setcontextpath ( request . getcontextpath ( ) ) ; urlbuilder . setservletpath ( request . getservletpath ( ) ) ; urlbuilder . setpathinfo ( request . getpathinfo ( ) ) ; urlbuilder . setquery ( request . getquerystring ( ) ) ; return urlbuilder . geturl ( ) ; }	Builds a URL to redirect the supplied request to HTTPS.
public object invoke ( joinpoint jp , aspectjcallback advisorproceed ) { interceptorstatustoken token = super . beforeinvocation ( new methodinvocationadapter ( jp ) ) ; object result ; try { result = advisorproceed . proceedwithobject ( ) ; } finally { super . finallyinvocation ( token ) ; } return super . afterinvocation ( token , result ) ; }	Method that is suitable for user with traditional AspectJ-code aspects.
private static string hasrole ( string role ) { assert . istrue ( ! role . startswith ( str_ ) , ( ) -> role + str_ ) ; return str_ + role ; }	Creates a String for specifying a user requires a role.
private static string [ ] hasanyrole ( string ... roles ) { for ( int i = num_ ; i < roles . length ; i ++ ) { roles [ i ] = str_ + roles [ i ] ; } return roles ; }	Creates a String for specifying that a user requires one of many roles.
protected void onloginsuccess ( httpservletrequest request , httpservletresponse response , authentication successfulauthentication ) { string username = successfulauthentication . getname ( ) ; logger . debug ( str_ + username ) ; persistentremembermetoken persistenttoken = new persistentremembermetoken ( username , generateseriesdata ( ) , generatetokendata ( ) , new date ( ) ) ; try { tokenrepository . createnewtoken ( persistenttoken ) ; addcookie ( persistenttoken , request , response ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } }	Creates a new persistent login token with a new series number, stores the data inthe persistent token repository and adds the corresponding cookie to the response.
protected authentication attemptswitchuser ( httpservletrequest request ) throws authenticationexception { usernamepasswordauthenticationtoken targetuserrequest ; string username = request . getparameter ( this . usernameparameter ) ; if ( username == null ) { username = str_ ; } if ( this . logger . isdebugenabled ( ) ) { this . logger . debug ( str_ + username + str_ ) ; } userdetails targetuser = this . userdetailsservice . loaduserbyusername ( username ) ; this . userdetailschecker . check ( targetuser ) ;	Attempt to switch to another user.
protected authentication attemptexituser ( httpservletrequest request ) throws authenticationcredentialsnotfoundexception {	Attempt to exit from an already switched user.
public void setexituserurl ( string exituserurl ) { assert . istrue ( urlutils . isvalidredirecturl ( exituserurl ) , str_ ) ; this . exitusermatcher = creatematcher ( exituserurl ) ; }	Set the URL to respond to exit user processing.
@ requestmapping ( value = str_ , method = requestmethod . get ) public modelandview displaypublicindex ( ) { contact rnd = contactmanager . getrandomcontact ( ) ; return new modelandview ( str_ , str_ , rnd ) ; }	The public index page, used for unauthenticated users.
@ bean ( name = abstractsecuritywebapplicationinitializer . default_filter_name ) public filter springsecurityfilterchain ( ) throws exception { boolean hasconfigurers = websecurityconfigurers != null && ! websecurityconfigurers . isempty ( ) ; if ( ! hasconfigurers ) { websecurityconfigureradapter adapter = objectobjectpostprocessor . postprocess ( new websecurityconfigureradapter ( ) { } ) ; websecurity . apply ( adapter ) ; } return websecurity . build ( ) ; }	Creates the Spring Security Filter Chain.
@ override public jwt decode ( string token ) throws jwtexception { jwt jwt = parse ( token ) ; if ( jwt instanceof signedjwt ) { jwt createdjwt = createjwt ( token , jwt ) ; return validatejwt ( createdjwt ) ; } throw new jwtexception ( str_ + jwt . getheader ( ) . getalgorithm ( ) ) ; }	Decode and validate the JWT from its compact claims representation format.
public boolean authorizeusingaccessexpression ( ) throws ioexception { if ( securitycontextholder . getcontext ( ) . getauthentication ( ) == null ) { return bool_ ; } securityexpressionhandler < filterinvocation > handler = getexpressionhandler ( ) ; expression accessexpression ; try { accessexpression = handler . getexpressionparser ( ) . parseexpression ( getaccess ( ) ) ; } catch ( parseexception e ) { ioexception ioexception = new ioexception ( ) ; ioexception . initcause ( e ) ; throw ioexception ; } return expressionutils . evaluateasboolean ( accessexpression , createexpressionevaluationcontext ( handler ) ) ; }	Make an authorization decision based on a Spring EL expression.
public boolean authorizeusingurlcheck ( ) throws ioexception { string contextpath = ( ( httpservletrequest ) getrequest ( ) ) . getcontextpath ( ) ; authentication currentuser = securitycontextholder . getcontext ( ) . getauthentication ( ) ; return getprivilegeevaluator ( ) . isallowed ( contextpath , geturl ( ) , getmethod ( ) , currentuser ) ; }	Make an authorization decision based on the URL and HTTP method attributes.
@ override public collection < grantedauthority > convert ( jwt jwt ) { return getscopes ( jwt ) . stream ( ) . map ( authority -> scope_authority_prefix + authority ) . map ( simplegrantedauthority :: new ) . collect ( collectors . tolist ( ) ) ; }	Extracts the authorities.
@ override public csrftoken generatetoken ( httpservletrequest request ) { return wrap ( request , this . delegate . generatetoken ( request ) ) ; }	Generates a new token.
@ requestmapping ( value = str_ , method = requestmethod . get ) public modelandview displayadminpage ( @ requestparam ( str_ ) int contactid ) { contact contact = contactmanager . getbyid ( long . valueof ( contactid ) ) ; acl acl = aclservice . readaclbyid ( new objectidentityimpl ( contact ) ) ; map < string , object > model = new hashmap < > ( ) ; model . put ( str_ , contact ) ; model . put ( str_ , acl ) ; return new modelandview ( str_ , str_ , model ) ; }	Displays the permission admin page for a particular contact.
@ requestmapping ( value = str_ , method = requestmethod . get ) public modelandview displayaddpermissionpageforcontact ( @ requestparam ( str_ ) long contactid ) { contact contact = contactmanager . getbyid ( contactid ) ; addpermission addpermission = new addpermission ( ) ; addpermission . setcontact ( contact ) ; map < string , object > model = new hashmap < > ( ) ; model . put ( str_ , addpermission ) ; model . put ( str_ , listrecipients ( ) ) ; model . put ( str_ , listpermissions ( ) ) ; return new modelandview ( str_ , model ) ; }	Displays the "add permission" page for a contact.
@ requestmapping ( value = str_ , method = requestmethod . post ) public string addpermission ( addpermission addpermission , bindingresult result , modelmap model ) { addpermissionvalidator . validate ( addpermission , result ) ; if ( result . haserrors ( ) ) { model . put ( str_ , listrecipients ( ) ) ; model . put ( str_ , listpermissions ( ) ) ; return str_ ; } principalsid sid = new principalsid ( addpermission . getrecipient ( ) ) ; permission permission = permissionfactory . buildfrommask ( addpermission . getpermission ( ) ) ; try { contactmanager . addpermission ( addpermission . getcontact ( ) , sid , permission ) ; } catch ( dataaccessexception existingpermission ) { existingpermission . printstacktrace ( ) ; result . rejectvalue ( str_ , str_ , str_ ) ; model . put ( str_ , listrecipients ( ) ) ; model . put ( str_ , listpermissions ( ) ) ; return str_ ; } return str_ ; }	Handles submission of the "add permission" form.
private static string getrolewithdefaultprefix ( string defaultroleprefix , string role ) { if ( role == null ) { return role ; } if ( defaultroleprefix == null || defaultroleprefix . length ( ) == num_ ) { return role ; } if ( role . startswith ( defaultroleprefix ) ) { return role ; } return defaultroleprefix + role ; }	Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if roledoes not already start with defaultRolePrefix.
public static userdetailsresourcefactorybean fromstring ( string users ) { inmemoryresource resource = new inmemoryresource ( users ) ; return fromresource ( resource ) ; }	Creates a UserDetailsResourceFactoryBean with a resource from the provided String.
public list < string > getattributevalues ( string name ) { list < string > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = collections . emptylist ( ) ; } return result ; }	Returns the values for a specific attribute.
public string getfirstattributevalue ( string name ) { list < string > result = getattributevalues ( name ) ; if ( result . isempty ( ) ) { return null ; } else { return result . get ( num_ ) ; } }	Returns the first attribute value for a specified attribute.
public static byte [ ] encode ( charsequence string ) { try { bytebuffer bytes = charset . newencoder ( ) . encode ( charbuffer . wrap ( string ) ) ; byte [ ] bytescopy = new byte [ bytes . limit ( ) ] ; system . arraycopy ( bytes . array ( ) , num_ , bytescopy , num_ , bytes . limit ( ) ) ; return bytescopy ; } catch ( charactercodingexception e ) { throw new illegalargumentexception ( str_ , e ) ; } }	Get the bytes of the String in UTF-8 encoded form.
public static string decode ( byte [ ] bytes ) { try { return charset . newdecoder ( ) . decode ( bytebuffer . wrap ( bytes ) ) . tostring ( ) ; } catch ( charactercodingexception e ) { throw new illegalargumentexception ( str_ , e ) ; } }	Decode the bytes in UTF-8 form into a String.
private < t extends accessibleobject > string [ ] lookupparameternames ( parameternamefactory < t > parameternamefactory , t t ) { annotation [ ] [ ] parameterannotations = parameternamefactory . findparameterannotations ( t ) ; int parametercount = parameterannotations . length ; string [ ] paramnames = new string [ parametercount ] ; boolean found = bool_ ; for ( int i = num_ ; i < parametercount ; i ++ ) { annotation [ ] annotations = parameterannotations [ i ] ; string parametername = findparametername ( annotations ) ; if ( parametername != null ) { found = bool_ ; paramnames [ i ] = parametername ; } } return found ? paramnames : null ; }	Gets the parameter names or null if not found.
@ requestmapping ( value = str_ , method = requestmethod . post ) public string addcontact ( webcontact form , bindingresult result ) { validator . validate ( form , result ) ; if ( result . haserrors ( ) ) { return str_ ; } contact contact = new contact ( form . getname ( ) , form . getemail ( ) ) ; contactmanager . create ( contact ) ; return str_ ; }	Handles the submission of the contact form, creating a new instance if the usernameand email are valid.
@ override protected collection < configattribute > findattributes ( method method , class < ? > targetclass ) { if ( targetclass == null ) { return null ; } return findattributesspecifiedagainst ( method , targetclass ) ; }	Will walk the method inheritance tree to find the most specific declarationapplicable.
private void addsecuremethod ( registeredmethod method , list < configattribute > attr ) { assert . notnull ( method , str_ ) ; assert . notnull ( attr , str_ ) ; if ( logger . isinfoenabled ( ) ) { logger . info ( str_ + method + str_ + attr + str_ ) ; } this . methodmap . put ( method , attr ) ; }	Add configuration attributes for a secure method.
@ override public collection < configattribute > getallconfigattributes ( ) { set < configattribute > allattributes = new hashset < > ( ) ; for ( list < configattribute > attributelist : methodmap . values ( ) ) { allattributes . addall ( attributelist ) ; } return allattributes ; }	Obtains the configuration attributes explicitly defined against this bean.
private boolean ismatch ( string methodname , string mappedname ) { return ( mappedname . endswith ( str_ ) && methodname . startswith ( mappedname . substring ( num_ , mappedname . length ( ) - num_ ) ) ) || ( mappedname . startswith ( str_ ) && methodname . endswith ( mappedname . substring ( num_ , mappedname . length ( ) ) ) ) ; }	Return if the given method name matches the mapped name.
public c anyrequest ( ) { assert . state ( ! this . anyrequestconfigured , str_ ) ; c configurer = requestmatchers ( any_request ) ; this . anyrequestconfigured = bool_ ; return configurer ; }	Maps any request.
protected void handlebindexception ( string userdn , string username , throwable cause ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + userdn + str_ + cause ) ; } }	Allows subclasses to inspect the exception thrown by an attempt to bind with aparticular DN.
@ transactional ( readonly = bool_ ) public contact getrandomcontact ( ) { logger . debug ( str_ ) ; random rnd = new random ( ) ; list < contact > contacts = contactdao . findall ( ) ; int getnumber = rnd . nextint ( contacts . size ( ) ) ; return contacts . get ( getnumber ) ; }	This is a public method.
protected final void clearauthenticationattributes ( httpservletrequest request ) { httpsession session = request . getsession ( bool_ ) ; if ( session == null ) { return ; } session . removeattribute ( webattributes . authentication_exception ) ; }	Removes temporary authentication-related data which may have been stored in thesession during the authentication process.
public static field getfield ( class < ? > clazz , string fieldname ) throws illegalstateexception { assert . notnull ( clazz , str_ ) ; assert . hastext ( fieldname , str_ ) ; try { return clazz . getdeclaredfield ( fieldname ) ; } catch ( nosuchfieldexception nsf ) {	Attempts to locate the specified field on the class.
protected string createserviceurl ( final httpservletrequest request , final httpservletresponse response ) { return commonutils . constructserviceurl ( null , response , this . serviceproperties . getservice ( ) , null , this . serviceproperties . getartifactparameter ( ) , this . encodeserviceurlwithsessionid ) ; }	Constructs a new Service Url.
protected string createredirecturl ( final string serviceurl ) { return commonutils . constructredirecturl ( this . loginurl , this . serviceproperties . getserviceparameter ( ) , serviceurl , this . serviceproperties . issendrenew ( ) , bool_ ) ; }	Constructs the Url for Redirection to the CAS server.
private string extractprefix ( string encpass ) { if ( ! encpass . startswith ( str_ ) ) { return null ; } int secondbrace = encpass . lastindexof ( str_ ) ; if ( secondbrace < num_ ) { throw new illegalargumentexception ( str_ ) ; } return encpass . substring ( num_ , secondbrace + num_ ) ; }	Returns the hash prefix or null if there isn't one.
public void commence ( httpservletrequest request , httpservletresponse response , authenticationexception arg2 ) throws ioexception , servletexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ ) ; } response . senderror ( httpservletresponse . sc_forbidden , str_ ) ; }	Always returns a 403 error code to the client.
private void checkfilterstack ( list < filter > filters ) { checkforduplicates ( securitycontextpersistencefilter . class , filters ) ; checkforduplicates ( usernamepasswordauthenticationfilter . class , filters ) ; checkforduplicates ( sessionmanagementfilter . class , filters ) ; checkforduplicates ( basicauthenticationfilter . class , filters ) ; checkforduplicates ( securitycontextholderawarerequestfilter . class , filters ) ; checkforduplicates ( jaasapiintegrationfilter . class , filters ) ; checkforduplicates ( exceptiontranslationfilter . class , filters ) ; checkforduplicates ( filtersecurityinterceptor . class , filters ) ; }	Checks the filter list for possible errors and logs them.
@ suppresswarnings ( str_ ) final class < ? extends throwable > [ ] getregisteredtypes ( ) { set < class < ? extends throwable > > typelist = this . extractormap . keyset ( ) ; return typelist . toarray ( new class [ typelist . size ( ) ] ) ; }	Returns an array containing the classes for which extractors are registered.
private throwable extractcause ( throwable throwable ) { for ( map . entry < class < ? extends throwable > , throwablecauseextractor > entry : extractormap . entryset ( ) ) { class < ? extends throwable > throwabletype = entry . getkey ( ) ; if ( throwabletype . isinstance ( throwable ) ) { throwablecauseextractor extractor = entry . getvalue ( ) ; return extractor . extractcause ( throwable ) ; } } return null ; }	Extracts the cause of the given throwable using an appropriate extractor.
@ suppresswarnings ( { str_ , str_ } ) private string registeraccessmanager ( parsercontext pc , boolean jsr250enabled , beandefinition expressionvoter ) { beandefinitionbuilder accessmgrbuilder = beandefinitionbuilder . rootbeandefinition ( affirmativebased . class ) ; managedlist voters = new managedlist ( num_ ) ; if ( expressionvoter != null ) { voters . add ( expressionvoter ) ; } voters . add ( new rootbeandefinition ( rolevoter . class ) ) ; voters . add ( new rootbeandefinition ( authenticatedvoter . class ) ) ; if ( jsr250enabled ) { voters . add ( new rootbeandefinition ( jsr250voter . class ) ) ; } accessmgrbuilder . addconstructorargvalue ( voters ) ; beandefinition accessmanager = accessmgrbuilder . getbeandefinition ( ) ; string id = pc . getreadercontext ( ) . generatebeanname ( accessmanager ) ; pc . registerbeancomponent ( new beancomponentdefinition ( accessmanager , id ) ) ; return id ; }	Register the default AccessDecisionManager.
public static set < string > authoritylisttoset ( collection < ? extends grantedauthority > userauthorities ) { assert . notnull ( userauthorities , str_ ) ; set < string > set = new hashset < > ( userauthorities . size ( ) ) ; for ( grantedauthority authority : userauthorities ) { set . add ( authority . getauthority ( ) ) ; } return set ; }	Converts an array of GrantedAuthority objects to a Set.
private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return bool_ ; } int result = num_ ; for ( int i = num_ ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == num_ ; }	Constant time comparison to prevent against timing attacks.
public void setdefaultfailureurl ( string defaultfailureurl ) { assert . istrue ( urlutils . isvalidredirecturl ( defaultfailureurl ) , ( ) -> str_ + defaultfailureurl + str_ ) ; this . defaultfailureurl = defaultfailureurl ; }	The URL which will be used as the failure destination.
public void setresolvehiddeninputs ( function < httpservletrequest , map < string , string > > resolvehiddeninputs ) { assert . notnull ( resolvehiddeninputs , str_ ) ; this . resolvehiddeninputs = resolvehiddeninputs ; }	Sets a Function used to resolve a Map of the hidden inputs where the key is thename of the input and the value is the value of the input.
private static string buildrequesturl ( string servletpath , string requesturi , string contextpath , string pathinfo , string querystring ) { stringbuilder url = new stringbuilder ( ) ; if ( servletpath != null ) { url . append ( servletpath ) ; if ( pathinfo != null ) { url . append ( pathinfo ) ; } } else { url . append ( requesturi . substring ( contextpath . length ( ) ) ) ; } if ( querystring != null ) { url . append ( str_ ) . append ( querystring ) ; } return url . tostring ( ) ; }	Obtains the web application-specific fragment of the URL.
public static boolean isabsoluteurl ( string url ) { if ( url == null ) { return bool_ ; } final pattern absolute_url = pattern . compile ( str_ , pattern . case_insensitive ) ; return absolute_url . matcher ( url ) . matches ( ) ; }	Decides if a URL is absolute based on whether it contains a valid scheme name, asdefined in RFC 1738.
public list < openidattribute > createattributelist ( string identifier ) { for ( map . entry < pattern , list < openidattribute > > entry : idtoattributes . entryset ( ) ) { if ( entry . getkey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getvalue ( ) ; } } return collections . emptylist ( ) ; }	Iterates through the patterns stored in the map and returns the list of attributesdefined for the first match.
serializable identifierfrom ( serializable identifier , resultset resultset ) throws sqlexception { if ( isstring ( identifier ) && hasvalidclassidtype ( resultset ) && canconvertfromstringto ( classidtypefrom ( resultset ) ) ) { identifier = convertfromstringto ( ( string ) identifier , classidtypefrom ( resultset ) ) ; } else {	Converts the raw type from the database into the right Java type.
protected void createentries ( final mutableacl acl ) { if ( acl . getentries ( ) . isempty ( ) ) { return ; } jdbcoperations . batchupdate ( insertentry , new batchpreparedstatementsetter ( ) { public int getbatchsize ( ) { return acl . getentries ( ) . size ( ) ; } public void setvalues ( preparedstatement stmt , int i ) throws sqlexception { accesscontrolentry entry_ = acl . getentries ( ) . get ( i ) ; assert . istrue ( entry_ instanceof accesscontrolentryimpl , str_ ) ; accesscontrolentryimpl entry = ( accesscontrolentryimpl ) entry_ ; stmt . setlong ( num_ , ( ( long ) acl . getid ( ) ) . longvalue ( ) ) ; stmt . setint ( num_ , i ) ; stmt . setlong ( num_ , createorretrievesidprimarykey ( entry . getsid ( ) , bool_ ) . longvalue ( ) ) ; stmt . setint ( num_ , entry . getpermission ( ) . getmask ( ) ) ; stmt . setboolean ( num_ , entry . isgranting ( ) ) ; stmt . setboolean ( num_ , entry . isauditsuccess ( ) ) ; stmt . setboolean ( num_ , entry . isauditfailure ( ) ) ; } } ) ; }	Creates a new row in acl_entry for every ACE defined in the passed MutableAclobject.
protected void createobjectidentity ( objectidentity object , sid owner ) { long sidid = createorretrievesidprimarykey ( owner , bool_ ) ; long classid = createorretrieveclassprimarykey ( object . gettype ( ) , bool_ , object . getidentifier ( ) . getclass ( ) ) ; jdbcoperations . update ( insertobjectidentity , classid , object . getidentifier ( ) . tostring ( ) , sidid , boolean . true ) ; }	Creates an entry in the acl_object_identity table for the passed ObjectIdentity.The Sid is also necessary, as acl_object_identity has defined the sid column asnon-null.
protected void updateobjectidentity ( mutableacl acl ) { long parentid = null ; if ( acl . getparentacl ( ) != null ) { assert . isinstanceof ( objectidentityimpl . class , acl . getparentacl ( ) . getobjectidentity ( ) , str_ ) ; objectidentityimpl oii = ( objectidentityimpl ) acl . getparentacl ( ) . getobjectidentity ( ) ; parentid = retrieveobjectidentityprimarykey ( oii ) ; } assert . notnull ( acl . getowner ( ) , str_ ) ; long ownersid = createorretrievesidprimarykey ( acl . getowner ( ) , bool_ ) ; int count = jdbcoperations . update ( updateobjectidentity , parentid , ownersid , boolean . valueof ( acl . isentriesinheriting ( ) ) , acl . getid ( ) ) ; if ( count != num_ ) { throw new notfoundexception ( str_ ) ; } }	Updates an existing acl_object_identity row, with new information presented in thepassed MutableAcl object.
public void saverequest ( httpservletrequest request , httpservletresponse response ) { if ( requestmatcher . matches ( request ) ) { defaultsavedrequest savedrequest = new defaultsavedrequest ( request , portresolver ) ; if ( createsessionallowed || request . getsession ( bool_ ) != null ) {	Stores the current request, provided the configuration properties allow it.
public static serverwebexchangematcher pathmatchers ( httpmethod method , string ... patterns ) { list < serverwebexchangematcher > matchers = new arraylist < > ( patterns . length ) ; for ( string pattern : patterns ) { matchers . add ( new pathpatternparserserverwebexchangematcher ( pattern , method ) ) ; } return new orserverwebexchangematcher ( matchers ) ; }	Creates a matcher that matches on the specific method and any of the provided patterns.
public static serverwebexchangematcher anyexchange ( ) {	Matches any exchange.
public static textencryptor delux ( charsequence password , charsequence salt ) { return new hexencodingtextencryptor ( stronger ( password , salt ) ) ; }	Creates a text encryptor that uses "stronger" password-based encryption.
public static textencryptor text ( charsequence password , charsequence salt ) { return new hexencodingtextencryptor ( standard ( password , salt ) ) ; }	Creates a text encryptor that uses "standard" password-based encryption.
public static textencryptor queryabletext ( charsequence password , charsequence salt ) { return new hexencodingtextencryptor ( new aesbytesencryptor ( password . tostring ( ) , salt ) ) ; }	Creates an encryptor for queryable text strings that uses standard password-basedencryption.
public void writeheaders ( httpservletrequest request , httpservletresponse response ) { if ( xframeoptionsmode . allow_from . equals ( frameoptionsmode ) ) { string allowfromvalue = this . allowfromstrategy . getallowfromvalue ( request ) ; if ( xframeoptionsmode . deny . getmode ( ) . equals ( allowfromvalue ) ) { if ( ! response . containsheader ( xframe_options_header ) ) { response . setheader ( xframe_options_header , xframeoptionsmode . deny . getmode ( ) ) ; } } else if ( allowfromvalue != null ) { if ( ! response . containsheader ( xframe_options_header ) ) { response . setheader ( xframe_options_header , xframeoptionsmode . allow_from . getmode ( ) + str_ + allowfromvalue ) ; } } } else { response . setheader ( xframe_options_header , frameoptionsmode . getmode ( ) ) ; } }	Writes the X-Frame-Options header value, overwritting any previous value.
protected string determinetargeturl ( httpservletrequest request , httpservletresponse response , authentication authentication ) { return determinetargeturl ( request , response ) ; }	Builds the target URL according to the logic defined in the main class Javadoc.
protected string determinetargeturl ( httpservletrequest request , httpservletresponse response ) { if ( isalwaysusedefaulttargeturl ( ) ) { return defaulttargeturl ; }	Builds the target URL according to the logic defined in the main class Javadoc.
public void settargeturlparameter ( string targeturlparameter ) { if ( targeturlparameter != null ) { assert . hastext ( targeturlparameter , str_ ) ; } this . targeturlparameter = targeturlparameter ; }	If this property is set, the current request will be checked for this a parameterwith this name and the value used as the target URL if present.
private directory getdirectorywithimmediateparentpopulated ( final long id ) { return getjdbctemplate ( ) . queryforobject ( select_from_directory_single , new object [ ] { id } , new rowmapper < directory > ( ) { public directory maprow ( resultset rs , int rownumber ) throws sqlexception { long parentdirectoryid = new long ( rs . getlong ( str_ ) ) ; directory parentdirectory = directory . root_directory ; if ( parentdirectoryid != null && ! parentdirectoryid . equals ( new long ( - num_ ) ) ) {	Executes recursive SQL as needed to build a full Directory hierarchy of objects.
public distinguishedname builddn ( string username ) { distinguishedname dn = new distinguishedname ( userdnbase ) ; dn . add ( usernameattribute , username ) ; return dn ; }	Assembles the Distinguished Name that should be used the given username.
private map < class < ? extends object > , object > createsharedobjects ( ) { map < class < ? extends object > , object > sharedobjects = new hashmap < class < ? extends object > , object > ( ) ; sharedobjects . putall ( localconfigureauthenticationbldr . getsharedobjects ( ) ) ; sharedobjects . put ( userdetailsservice . class , userdetailsservice ( ) ) ; sharedobjects . put ( applicationcontext . class , context ) ; sharedobjects . put ( contentnegotiationstrategy . class , contentnegotiationstrategy ) ; sharedobjects . put ( authenticationtrustresolver . class , trustresolver ) ; return sharedobjects ; }	Creates the shared objects.
private void configurejaasusingloop ( ) throws ioexception { string loginconfigurl = convertloginconfigtourl ( ) ; boolean alreadyset = bool_ ; int n = num_ ; final string prefix = str_ ; string existing ; while ( ( existing = security . getproperty ( prefix + n ) ) != null ) { alreadyset = existing . equals ( loginconfigurl ) ; if ( alreadyset ) { break ; } n ++ ; } if ( ! alreadyset ) { string key = prefix + n ; log . debug ( str_ + key + str_ + loginconfigurl ) ; security . setproperty ( key , loginconfigurl ) ; } }	Loops through the login.config.url.1,login.config.url.2 properties looking for thelogin configuration.
public static string getcurrentdate ( ) { long now = system . currenttimemillis ( ) ; if ( ( now - currentdategenerated ) > num_ ) { synchronized ( format ) { if ( ( now - currentdategenerated ) > num_ ) { currentdategenerated = now ; currentdate = format . format ( new date ( now ) ) ; } } } return currentdate ; }	Gets the current date in HTTP format.
private static long internalparsedate ( string value , dateformat [ ] formats ) { date date = null ; for ( int i = num_ ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( parseexception ignored ) { } } if ( date == null ) { return null ; } return new long ( date . gettime ( ) ) ; }	Parses date with given formatters.
@ suppresswarnings ( str_ ) private static void updatecache ( hashmap cache , object key , object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > num_ ) { cache . clear ( ) ; } cache . put ( key , value ) ; }	Updates cache.
protected void setdetails ( httpservletrequest request , usernamepasswordauthenticationtoken authrequest ) { authrequest . setdetails ( authenticationdetailssource . builddetails ( request ) ) ; }	Provided so that subclasses may configure what is put into the authenticationrequest's details property.
private static string getsecurityname ( final subject subject ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + subject ) ; } string usersecurityname = null ; if ( subject != null ) {	Get the security name for the given subject.
@ suppresswarnings ( str_ ) private static list < string > getwebspheregroups ( final string securityname ) { context ic = null ; try {	Get the WebSphere group names for the given security name.
protected distinguishedname buildgroupdn ( string group ) { distinguishedname dn = new distinguishedname ( groupsearchbase ) ; dn . add ( grouproleattributename , group . tolowercase ( ) ) ; return dn ; }	Creates a DN from a group name.
protected void allowablesessionsexceeded ( list < sessioninformation > sessions , int allowablesessions , sessionregistry registry ) throws sessionauthenticationexception { if ( exceptionifmaximumexceeded || ( sessions == null ) ) { throw new sessionauthenticationexception ( messages . getmessage ( str_ , new object [ ] { integer . valueof ( allowablesessions ) } , str_ ) ) ; }	Allows subclasses to customise behaviour when too many sessions are detected.
private void copydetails ( authentication source , authentication dest ) { if ( ( dest instanceof abstractauthenticationtoken ) && ( dest . getdetails ( ) == null ) ) { abstractauthenticationtoken token = ( abstractauthenticationtoken ) dest ; token . setdetails ( source . getdetails ( ) ) ; } }	Copies the authentication details from a source Authentication object to adestination one, provided the latter does not already have one set.
private list < filter > getfilters ( httpservletrequest request ) { for ( securityfilterchain chain : filterchains ) { if ( chain . matches ( request ) ) { return chain . getfilters ( ) ; } } return null ; }	Returns the first filter chain matching the supplied URL.
public list < filter > getfilters ( string url ) { return getfilters ( firewall . getfirewalledrequest ( ( new filterinvocation ( url , str_ ) . getrequest ( ) ) ) ) ; }	Convenience method, mainly for testing.
protected applicationcontext getcontext ( pagecontext pagecontext ) { servletcontext servletcontext = pagecontext . getservletcontext ( ) ; return securitywebapplicationcontextutils . findrequiredwebapplicationcontext ( servletcontext ) ; }	Allows test cases to override where application context obtained from.
public static distinguishedname getfulldn ( distinguishedname dn , context basectx ) throws namingexception { distinguishedname basedn = new distinguishedname ( basectx . getnameinnamespace ( ) ) ; if ( dn . contains ( basedn ) ) { return dn ; } basedn . append ( dn ) ; return basedn ; }	Gets the full dn of a name by prepending the name of the context it is relative to.If the name already contains the base name, it is returned unaltered.
public mockmvcrequestspecification sessionattrs ( map < string , object > sessionattributes ) { notnull ( sessionattributes , str_ ) ; parameterupdater . updateparameters ( convert ( cfg . getmockmvcparamconfig ( ) . sessionattributesupdatestrategy ( ) ) , sessionattributes , this . sessionattributes ) ; return this ; }	Set session attributes.
public authenticationscheme basic ( string username , string password ) { final preemptivebasicauthscheme preemptivebasicauthscheme = new preemptivebasicauthscheme ( ) ; preemptivebasicauthscheme . setusername ( username ) ; preemptivebasicauthscheme . setpassword ( password ) ; return preemptivebasicauthscheme ; }	Use preemptive http basic authentication.
public static void filters ( list < filter > filters ) { validate . notnull ( filters , str_ ) ; restassured . filters . addall ( filters ) ; }	Add default filters that will be applied to each request.
public static void filters ( filter filter , filter ... additionalfilters ) { validate . notnull ( filter , str_ ) ; restassured . filters . add ( filter ) ; if ( additionalfilters != null ) { collections . addall ( restassured . filters , additionalfilters ) ; } }	Add default filters to apply to each request.
public static authenticationscheme basic ( string username , string password ) { final basicauthscheme scheme = new basicauthscheme ( ) ; scheme . setusername ( username ) ; scheme . setpassword ( password ) ; return scheme ; }	Create a http basic authentication scheme.
public static authenticationscheme ntlm ( string username , string password , string workstation , string domain ) { final ntlmauthscheme scheme = new ntlmauthscheme ( ) ; scheme . setusername ( username ) ; scheme . setpassword ( password ) ; scheme . setworkstation ( workstation ) ; scheme . setdomain ( domain ) ; return scheme ; }	Create a NTLM authentication scheme.
public static authenticationscheme form ( string username , string password , formauthconfig config ) { if ( username == null ) { throw new illegalargumentexception ( str_ ) ; } if ( password == null ) { throw new illegalargumentexception ( str_ ) ; } final formauthscheme scheme = new formauthscheme ( ) ; scheme . setusername ( username ) ; scheme . setpassword ( password ) ; scheme . setconfig ( config ) ; return scheme ; }	Use form authentication with the supplied configuration.
public static void proxy ( uri uri ) { if ( uri == null ) { throw new illegalargumentexception ( str_ ) ; } proxy ( new proxyspecification ( uri . gethost ( ) , uri . getport ( ) , uri . getscheme ( ) ) ) ; }	Instruct REST Assured to connect to a proxy using a URI.
public static string print ( responseoptions responseoptions , responsebody responsebody , printstream stream , logdetail logdetail , boolean shouldprettyprint ) { final stringbuilder builder = new stringbuilder ( ) ; if ( logdetail == all || logdetail == status ) { builder . append ( responseoptions . statusline ( ) ) ; } if ( logdetail == all || logdetail == headers ) { final headers headers = responseoptions . headers ( ) ; if ( headers . exist ( ) ) { appendnewlineifall ( logdetail , builder ) . append ( tostring ( headers ) ) ; } } else if ( logdetail == cookies ) { final cookies cookies = responseoptions . detailedcookies ( ) ; if ( cookies . exist ( ) ) { appendnewlineifall ( logdetail , builder ) . append ( cookies . tostring ( ) ) ; } } if ( logdetail == all || logdetail == body ) { string responsebodytoappend ; if ( shouldprettyprint ) { responsebodytoappend = new prettifier ( ) . getprettifiedbodyifpossible ( responseoptions , responsebody ) ; } else { responsebodytoappend = responsebody . asstring ( ) ; } if ( logdetail == all && ! isblank ( responsebodytoappend ) ) { builder . append ( systemutils . line_separator ) . append ( systemutils . line_separator ) ; } builder . append ( responsebodytoappend ) ; } string response = builder . tostring ( ) ; stream . println ( response ) ; return response ; }	Prints the response to the print stream.
public restassuredconfig redirect ( redirectconfig redirectconfig ) { notnull ( redirectconfig , str_ ) ; return new restassuredconfig ( redirectconfig , conf ( httpclientconfig . class ) , conf ( logconfig . class ) , conf ( encoderconfig . class ) , conf ( decoderconfig . class ) , conf ( sessionconfig . class ) , conf ( objectmapperconfig . class ) , conf ( connectionconfig . class ) , conf ( jsonconfig . class ) , conf ( xmlconfig . class ) , conf ( sslconfig . class ) , conf ( matcherconfig . class ) , conf ( headerconfig . class ) , conf ( multipartconfig . class ) , conf ( paramconfig . class ) , conf ( oauthconfig . class ) , conf ( failureconfig . class ) ) ; }	Set the redirect config.
public encoderconfig defaultqueryparametercharset ( string charset ) { return new encoderconfig ( defaultcontentcharset , charset , shouldappenddefaultcontentcharsettocontenttypeifundefined , contentencoders , contenttypetodefaultcharset , bool_ ) ; }	Specify the default charset for query parameters.
public objectmapperconfig defaultobjectmappertype ( objectmappertype defaultobjectmappertype ) { return new objectmapperconfig ( defaultobjectmapper , defaultobjectmappertype , gsonobjectmapperfactory , jackson1objectmapperfactory , jackson2objectmapperfactory , jaxbobjectmapperfactory , johnzonobjectmapperfactory , bool_ ) ; }	Creates an object mapper configuration that uses the specified object mapper as default.
public objectmapperconfig jaxbobjectmapperfactory ( jaxbobjectmapperfactory jaxbobjectmapperfactory ) { return new objectmapperconfig ( defaultobjectmapper , defaultobjectmappertype , gsonobjectmapperfactory , jackson1objectmapperfactory , jackson2objectmapperfactory , jaxbobjectmapperfactory , johnzonobjectmapperfactory , bool_ ) ; }	Specify a custom JAXB object mapper factory.
public restassuredmockmvcconfig logconfig ( logconfig logconfig ) { notnull ( logconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the Log config.
public restassuredmockmvcconfig sessionconfig ( sessionconfig sessionconfig ) { notnull ( sessionconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the session config.
public restassuredmockmvcconfig objectmapperconfig ( objectmapperconfig objectmapperconfig ) { notnull ( objectmapperconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the object mapper config.
public restassuredmockmvcconfig jsonconfig ( jsonconfig jsonconfig ) { notnull ( jsonconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the Json config.
public restassuredmockmvcconfig xmlconfig ( xmlconfig xmlconfig ) { notnull ( xmlconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the Xml config.
public restassuredmockmvcconfig encoderconfig ( encoderconfig encoderconfig ) { notnull ( encoderconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the encoder config.
public restassuredmockmvcconfig headerconfig ( headerconfig headerconfig ) { notnull ( headerconfig , str_ ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the header config.
public restassuredmockmvcconfig asyncconfig ( asyncconfig asyncconfig ) { notnull ( asyncconfig , asyncconfig . class ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the async config.
public restassuredmockmvcconfig mockmvcconfig ( mockmvcconfig mockmvcconfig ) { notnull ( mockmvcconfig , mockmvcconfig . class ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the MockMVC config.
public restassuredmockmvcconfig multipartconfig ( multipartconfig multipartconfig ) { notnull ( multipartconfig , multipartconfig . class ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the multi-part config.
public restassuredmockmvcconfig paramconfig ( mockmvcparamconfig paramconfig ) { notnull ( paramconfig , multipartconfig . class ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the parameter config.
public restassuredmockmvcconfig matcherconfig ( matcherconfig matcherconfig ) { notnull ( matcherconfig , matcherconfig . class ) ; return new restassuredmockmvcconfig ( logconfig , encoderconfig , decoderconfig , sessionconfig , objectmapperconfig , jsonconfig , xmlconfig , headerconfig , asyncconfig , multipartconfig , mockmvcconfig , paramconfig , matcherconfig ) ; }	Set the matcher config.
public certificateauthsettings allowallhostnames ( ) { return new certificateauthsettings ( keystoretype , truststoretype , port , truststore , keystore , allow_all_hostname_verifier , sslsocketfactory ) ; }	Configure the CertificateAuthSettings to allow all host names.
public xmlpathconfig declarenamespaces ( map < string , string > namespacestodeclare ) { return new xmlpathconfig ( jaxbobjectmapperfactory , defaultparsertype , defaultdeserializer , charset , features , namespacestodeclare , properties , validating , namespaceaware , allowdoctypedeclaration ) ; }	Specify declared namespaces that will be used when parsing XML.
public xmlpathconfig declarednamespace ( string prefix , string namespaceuri ) { validate . notempty ( prefix , str_ ) ; validate . notempty ( namespaceuri , str_ ) ; map < string , string > updatednamespaces = new hashmap < string , string > ( declarednamespaces ) ; updatednamespaces . put ( prefix , namespaceuri ) ; return new xmlpathconfig ( jaxbobjectmapperfactory , defaultparsertype , defaultdeserializer , charset , features , updatednamespaces , properties , validating , bool_ , allowdoctypedeclaration ) ; }	Declares a namespace.
public object request ( string method , boolean hasbody , closure configclosure ) throws clientprotocolexception , ioexception { return this . dorequest ( this . defaulturi . touri ( ) , method , this . defaultcontenttype , hasbody , configclosure ) ; }	Make an HTTP request to the default URI, and parse using the defaultcontent-type.
public void setheaders ( map < ? , ? > headers ) { this . defaultrequestheaders . clear ( ) ; if ( headers == null ) return ; for ( object key : headers . keyset ( ) ) { object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultrequestheaders . put ( key . tostring ( ) , val . tostring ( ) ) ; } }	Set the default headers to add to all requests made by this builderinstance.
public void setproxy ( string host , int port , string scheme ) { getclient ( ) . getparams ( ) . setparameter ( connroutepnames . default_proxy , new httphost ( host , port , scheme ) ) ; }	Set the default HTTP proxy to be used for all requests.
public multipartspecbuilder controlname ( string controlname ) { validate . notempty ( controlname , str_ ) ; this . controlname = controlname ; this . iscontrolnameexplicit = bool_ ; return this ; }	Specify the control name of this multi-part.
public multipartspecbuilder header ( string name , string value ) { validate . notempty ( name , str_ ) ; validate . notempty ( value , str_ ) ;	Add a header to this multipart specification.
public void basic ( string host , int port , string user , string pass ) { builder . getclient ( ) . getcredentialsprovider ( ) . setcredentials ( new authscope ( host , port ) , new usernamepasswordcredentials ( user , pass ) ) ; }	Set authentication credentials to be used for the given host and port.
public void ntlm ( string host , int port , string user , string pass , string workstation , string domain ) { builder . getclient ( ) . getcredentialsprovider ( ) . setcredentials ( new authscope ( host , port ) , new ntcredentials ( user , pass , workstation , domain ) ) ; }	Set NTLM authentication credentials to be used for the given host and port.
public static headers headers ( header header , header ... additionalheaders ) { notnull ( header , str_ ) ; final list < header > headerlist = new linkedlist < header > ( ) ; headerlist . add ( header ) ; if ( additionalheaders != null ) { collections . addall ( headerlist , additionalheaders ) ; } return new headers ( headerlist ) ; }	An alternative way to create a Headers object from the constructor.
public static void reset ( ) { mockmvcfactory = null ; config = null ; basepath = str_ ; resulthandlers . clear ( ) ; requestpostprocessors . clear ( ) ; responsespecification = null ; requestspecification = null ; authentication = null ; }	Reset all static configurations to their default values.
public responsebuilder setheader ( string name , string value ) { notnull ( name , str_ ) ; notnull ( value , str_ ) ; list < header > newheaders = new arraylist < header > ( restassuredresponse . headers ( ) . aslist ( ) ) ; newheaders . add ( new header ( name , value ) ) ; restassuredresponse . setresponseheaders ( new headers ( newheaders ) ) ; if ( trim ( name ) . equalsignorecase ( content_type ) ) { restassuredresponse . setcontenttype ( value ) ; } return this ; }	Set a specific header.
public response build ( ) { final int statuscode = restassuredresponse . statuscode ( ) ; if ( statuscode < num_ || statuscode >= num_ ) { throw new illegalargumentexception ( format ( str_ , statuscode ) ) ; } if ( stringutils . isblank ( restassuredresponse . statusline ( ) ) ) { restassuredresponse . setstatusline ( restassuredresponse . statuscode ( ) ) ; } restassuredresponse . setrpr ( new responseparserregistrar ( ) ) ; return restassuredresponse ; }	Build the actual response.
public detailedcookiematcher value ( matcher < ? super string > valuematcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , valuematcher ) ) ) ; }	Verifies whether value of cookie satisfies specified matcher.
public detailedcookiematcher comment ( matcher < ? super string > commentmatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , commentmatcher ) ) ) ; }	Verifies whether comment of cookie satisfies specified matcher.
public detailedcookiematcher expirydate ( matcher < ? super date > expirydatematcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , expirydatematcher ) ) ) ; }	Verifies whether expiry date of cookie satisfies specified matcher.
public detailedcookiematcher domain ( matcher < ? super string > domainmatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , domainmatcher ) ) ) ; }	Verifies whether domain of cookie satisfies specified matcher.
public detailedcookiematcher path ( matcher < ? super string > pathmatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , pathmatcher ) ) ) ; }	Verifies whether path of cookie satisfies specified matcher.
public detailedcookiematcher secured ( matcher < ? super boolean > securedmatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , securedmatcher ) ) ) ; }	Verifies whether secured property of cookie satisfies specified matcher.
public detailedcookiematcher httponly ( matcher < ? super boolean > httponlymatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , httponlymatcher ) ) ) ; }	Verifies whether http-only property of cookie satisfies specified matcher.
public detailedcookiematcher version ( matcher < ? super integer > versionmatcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , versionmatcher ) ) ) ; }	Verifies whether version of cookie satisfies specified matcher.
public detailedcookiematcher maxage ( matcher < ? super integer > maxagematcher ) { return new detailedcookiematcher ( and ( matchers . hasproperty ( str_ , maxagematcher ) ) ) ; }	Verifies whether max age of cookie satisfies specified matcher.
public responsespecbuilder expectheader ( string headername , matcher < string > expectedvaluematcher ) { spec . header ( headername , expectedvaluematcher ) ; return this ; }	Expect that a response header matches the supplied header name and hamcrest matcher.
public responsespecbuilder expectheader ( string headername , string expectedvalue ) { spec . header ( headername , expectedvalue ) ; return this ; }	Expect that a response header matches the supplied name and value.
public responsespecbuilder expectcookie ( string cookiename , string expectedvalue ) { spec . cookie ( cookiename , expectedvalue ) ; return this ; }	Expect that a response cookie matches the supplied name and value.
public proxyspecification withhost ( string host ) { return new proxyspecification ( host , port , scheme , username , password ) ; }	Specify the hostname of the proxy.
public jsonpathconfig numberreturntype ( numberreturntype numberreturntype ) { return new jsonpathconfig ( numberreturntype , defaultparsertype , gsonobjectmapperfactory , jackson1objectmapperfactory , jackson2objectmapperfactory , johnzonobjectmapperfactory , defaultdeserializer , charset ) ; }	Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.
public jsonpathconfig defaultparsertype ( jsonparsertype defaultparsertype ) { return new jsonpathconfig ( numberreturntype , defaultparsertype , gsonobjectmapperfactory , jackson1objectmapperfactory , jackson2objectmapperfactory , johnzonobjectmapperfactory , defaultdeserializer , charset ) ; }	Creates an json path configuration that uses the specified parser type as default.
public logconfig defaultstream ( printstream printstream ) { return new logconfig ( printstream , bool_ , logdetailifvalidationfails , urlencoderequesturi , bool_ ) ; }	Specify a new default stream to the print to.
public logconfig enableloggingofrequestandresponseifvalidationfails ( logdetail logdetail ) { return new logconfig ( defaultprintstream , prettyprintingenabled , logdetail , urlencoderequesturi , bool_ ) ; }	Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail.
static httprequestbase createhttprequest ( uri uri , string httpmethod , boolean hasbody ) { string method = notnull ( uppercase ( trimtonull ( httpmethod ) ) , str_ ) ; class < ? extends httprequestbase > type = http_method_to_http_request_type . get ( method ) ; final httprequestbase httprequest ;	Get the HttpRequest class that represents this request type.
public multipartconfig defaultboundary ( string defaultboundary ) { return new multipartconfig ( defaultcontrolname , defaultfilename , defaultsubtype , defaultboundary , defaultcharset , bool_ ) ; }	Specify an explicit default multipart boundary to use when sending multi-part data.
public mockmvcrequestspecbuilder addattribute ( string attributename , object attributevalue ) { spec . attribute ( attributename , attributevalue ) ; return this ; }	Add request attribute.
public mockmvcrequestspecbuilder addheader ( string headername , string headervalue ) { spec . header ( headername , headervalue ) ; return this ; }	Add a header to be sent with the request.
public mockmvcrequestspecbuilder addmultipart ( string controlname , string contentbody , string mimetype ) { spec . multipart ( controlname , mimetype ) ; return this ; }	Specify a string to send to the server using multi-part form data with a specific mime-type.
public mockmvcrequestspecbuilder addresulthandlers ( resulthandler resulthandler , resulthandler ... additionalresulthandlers ) { spec . resulthandlers ( resulthandler , additionalresulthandlers ) ; return this ; }	Add a result handler.
public < t > httpclientconfig setparam ( string parametername , t parametervalue ) { notnull ( parametername , str_ ) ; final map < string , object > newparams = new hashmap < string , object > ( httpclientparams ) ; newparams . put ( parametername , parametervalue ) ; return new httpclientconfig ( httpclientfactory , newparams , httpmultipartmode , shouldreusehttpclientinstance , no_http_client , bool_ ) ; }	Set a http client parameter.
public httpclientconfig addparams ( map < string , ? > httpclientparams ) { notnull ( httpclientparams , str_ ) ; final map < string , object > newparams = new hashmap < string , object > ( this . httpclientparams ) ; newparams . putall ( httpclientparams ) ; return new httpclientconfig ( httpclientfactory , newparams , httpmultipartmode , shouldreusehttpclientinstance , no_http_client , bool_ ) ; }	Add the given parameters to an already configured number of parameters.
public httpclientconfig httpclientfactory ( httpclientfactory httpclientfactory ) { return new httpclientconfig ( httpclientfactory , httpclientparams , httpmultipartmode , shouldreusehttpclientinstance , no_http_client , bool_ ) ; }	Set the http client factory that Rest Assured should use when making request.
public httpclientconfig httpmultipartmode ( httpmultipartmode httpmultipartmode ) { return new httpclientconfig ( httpclientfactory , httpclientparams , httpmultipartmode , shouldreusehttpclientinstance , httpclient , bool_ ) ; }	Specify the HTTP Multipart mode when sending multi-part data.
public < t > t get ( string path ) { final jsonassertion jsonassertion = createjsonassertion ( path , params ) ; final object json = jsonparser . parsewith ( createconfigurablejsonslurper ( ) ) ; return ( t ) jsonassertion . getresult ( json , null ) ; }	Get the result of an Object path expression as a boolean.
public int getint ( string path ) {	Get the result of an Object path expression as an int.
public byte getbyte ( string path ) {	Get the result of an Object path expression as a byte.
public short getshort ( string path ) {	Get the result of an Object path expression as a short.
public float getfloat ( string path ) { final object value = get ( path ) ;	Get the result of an Object path expression as a float.
public double getdouble ( string path ) { final object value = get ( path ) ; if ( value instanceof double ) { return ( double ) value ; } return objectconverter . convertobjectto ( value , double . class ) ; }	Get the result of an Object path expression as a double.
public long getlong ( string path ) {	Get the result of an Object path expression as a long.
public < t > list < t > getlist ( string path , class < t > generictype ) { if ( generictype == null ) { throw new illegalargumentexception ( str_ ) ; } final list < t > original = get ( path ) ; final list < t > newlist = new linkedlist < t > ( ) ; if ( original != null ) { for ( t t : original ) { t e ; if ( t instanceof map && ! generictype . isassignablefrom ( map . class ) ) {	Get the result of an Object path expression as a list.
public < k , v > map < k , v > getmap ( string path ) { return get ( path ) ; }	Get the result of an Object path expression as a map.
public < t > t getobject ( string path , class < t > objecttype ) { object object = getfrompath ( path , bool_ ) ; return getobjectastype ( object , objecttype ) ; }	Get an XML document as a Java Object.
public requestspecbuilder setbody ( object object , objectmapper mapper ) { spec . body ( object , mapper ) ; return this ; }	Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper.This works for the POST, PATCH and PUT methods only.
public requestspecbuilder addcookie ( string key , object value , object ... cookienamevaluepairs ) { spec . cookie ( key , value , cookienamevaluepairs ) ; return this ; }	Add a cookie to be sent with the request.
public requestspecbuilder addparam ( string parametername , object ... parametervalues ) { spec . param ( parametername , parametervalues ) ; return this ; }	Add a parameter to be sent with the request.
public requestspecbuilder addparam ( string parametername , collection < ? > parametervalues ) { spec . param ( parametername , parametervalues ) ; return this ; }	Add a multi-value parameter to be sent with the request.
public mockmvcparamconfig formparamsupdatestrategy ( updatestrategy updatestrategy ) { return new mockmvcparamconfig ( queryparamsupdatestrategy , updatestrategy , requestparameterupdatestrategy , attributeupdatestrategy , sessionupdatestrategy , bool_ ) ; }	Set form parameter update strategy to the given value.
public static filter logresponsetoifmatches ( printstream stream , matcher < integer > matcher ) { return new responseloggingfilter ( stream , matcher ) ; }	Create a new logging filter without using the "new" operator.Will make the DSL look nicer.
public static cookies cookies ( cookie cookie , cookie ... additionalcookies ) { assertparameter . notnull ( cookie , str_ ) ; final list < cookie > cookielist = new linkedlist < cookie > ( ) ; cookielist . add ( cookie ) ; collections . addall ( cookielist , additionalcookies ) ; return new cookies ( cookielist ) ; }	An alternative way to create a Cookies object from the constructor.
private void cleanupforcollectedstate ( set < keyandsource > keysandsources ) { synchronized ( lock ) { for ( keyandsource keyandsource : keysandsources ) { multiset < object > set = backingmap . get ( keyandsource . key ) ; if ( set != null ) { set . remove ( keyandsource . source ) ; if ( set . isempty ( ) ) { backingmap . remove ( keyandsource . key ) ; } } } } }	There may be multiple child injectors blacklisting a certain key so only remove the sourcethat's relevant.
void index ( ) { for ( binding < ? > binding : state . getexplicitbindingsthislevel ( ) . values ( ) ) { bindingsmultimap . put ( binding . getkey ( ) . gettypeliteral ( ) , binding ) ; } }	Indexes bindings by type.
< t > bindingimpl < t > getbindingorthrow ( key < t > key , errors errors , jitlimitation jittype ) throws errorsexception {	Gets a binding implementation.
private < t > bindingimpl < t > convertconstantstringbinding ( key < t > key , errors errors ) throws errorsexception {	Converts a constant string binding to the required type.
private boolean cleanup ( bindingimpl < ? > binding , set < key > encountered ) { boolean bindingfailed = bool_ ; set < dependency < ? > > deps = getinternaldependencies ( binding ) ; for ( dependency dep : deps ) { key < ? > depkey = dep . getkey ( ) ; injectionpoint ip = dep . getinjectionpoint ( ) ; if ( encountered . add ( depkey ) ) {	Iterates through the binding's dependencies to clean up any stray bindings that were leftoverfrom a failed JIT binding.
private void removefailedjitbinding ( binding < ? > binding , injectionpoint ip ) { failedjitbindings . add ( binding . getkey ( ) ) ; jitbindings . remove ( binding . getkey ( ) ) ; membersinjectorstore . remove ( binding . getkey ( ) . gettypeliteral ( ) ) ; provisionlistenerstore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }	Cleans up any state that may have been cached when constructing the JIT binding.
@ suppresswarnings ( str_ ) private set < dependency < ? > > getinternaldependencies ( bindingimpl < ? > binding ) { if ( binding instanceof constructorbindingimpl ) { return ( ( constructorbindingimpl ) binding ) . getinternaldependencies ( ) ; } else if ( binding instanceof hasdependencies ) { return ( ( hasdependencies ) binding ) . getdependencies ( ) ; } else { return immutableset . of ( ) ; } }	Safely gets the dependencies of possibly not initialized bindings.
< t > bindingimpl < t > createuninitializedbinding ( key < t > key , scoping scoping , object source , errors errors , boolean jitbinding ) throws errorsexception { class < ? > rawtype = key . gettypeliteral ( ) . getrawtype ( ) ; implementedby implementedby = rawtype . getannotation ( implementedby . class ) ;	Creates a binding for an injectable type with the given scope.
static object [ ] getall ( internalcontext context , singleparameterinjector < ? > [ ] parameterinjectors ) throws internalprovisionexception { if ( parameterinjectors == null ) { return no_arguments ; } int size = parameterinjectors . length ; object [ ] parameters = new object [ size ] ;	Returns an array of parameter values.
private static void bindinjector ( injectorimpl injector ) { key < injector > key = key . get ( injector . class ) ; injectorfactory injectorfactory = new injectorfactory ( injector ) ; injector . state . putbinding ( key , new providerinstancebindingimpl < injector > ( injector , key , sourceprovider . unknown_source , injectorfactory , scoping . unscoped , injectorfactory , immutableset . < injectionpoint > of ( ) ) ) ; }	The Injector is a special case because we allow both parent and child injectors to both have abinding for that key.
private static void bindlogger ( injectorimpl injector ) { key < logger > key = key . get ( logger . class ) ; loggerfactory loggerfactory = new loggerfactory ( ) ; injector . state . putbinding ( key , new providerinstancebindingimpl < logger > ( injector , key , sourceprovider . unknown_source , loggerfactory , scoping . unscoped , loggerfactory , immutableset . < injectionpoint > of ( ) ) ) ; }	The Logger is a special case because it knows the injection point of the injected member.
private static boolean checkformisplacedbindingannotations ( member member , errors errors ) { annotation misplacedbindingannotation = annotations . findbindingannotation ( errors , member , ( ( annotatedelement ) member ) . getannotations ( ) ) ; if ( misplacedbindingannotation == null ) { return bool_ ; }	Returns true if the binding annotation is in the wrong place.
private static boolean overrides ( method a , method b ) {	Returns true if a overrides b.
public void initializedelegate ( membersinjector < t > delegate ) { checkstate ( this . delegate == null , str_ ) ; this . delegate = checknotnull ( delegate , str_ ) ; }	Sets the actual members injector.
@ suppresswarnings ( str_ ) final typeliteral < provider < t > > providertype ( ) {	Gets the type of this type's provider.
private list < typeliteral < ? > > resolveall ( type [ ] types ) { typeliteral < ? > [ ] result = new typeliteral < ? > [ types . length ] ; for ( int t = num_ ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return immutablelist . copyof ( result ) ; }	Returns an immutable list of the resolved types.
public static < t > typeliteral < t > canonicalizeforkey ( typeliteral < t > typeliteral ) { type type = typeliteral . gettype ( ) ; if ( ! isfullyspecified ( type ) ) { errors errors = new errors ( ) . keynotfullyspecified ( typeliteral ) ; throw new configurationexception ( errors . getmessages ( ) ) ; } if ( typeliteral . getrawtype ( ) == javax . inject . provider . class ) { parameterizedtype parameterizedtype = ( parameterizedtype ) type ;	Returns an type that's appropriate for use in a key. If the raw type of {.
static void preparebuiltinconverters ( injectorimpl injector ) {	Installs default converters for primitives, enums, and class literals.
private static classloader canonicalize ( classloader classloader ) { return classloader != null ? classloader : systembridgeholder . system_bridge . getparent ( ) ; }	Attempts to canonicalize null references to the system class loader.
private static boolean hassameversionofcglib ( classloader classloader ) { class < ? > fc = net . sf . cglib . reflect . fastclass . class ; try { return classloader . loadclass ( fc . getname ( ) ) == fc ; } catch ( classnotfoundexception e ) { return bool_ ; } }	Returns true if the types classloader has the same version of cglib that BytecodeGen has.
private static boolean ispubliclycallable ( member member ) { if ( ! modifier . ispublic ( member . getmodifiers ( ) ) ) { return bool_ ; } class < ? > [ ] parametertypes ; if ( member instanceof constructor ) { parametertypes = ( ( constructor ) member ) . getparametertypes ( ) ; } else { method method = ( method ) member ; if ( ! modifier . ispublic ( method . getreturntype ( ) . getmodifiers ( ) ) ) { return bool_ ; } parametertypes = method . getparametertypes ( ) ; } for ( class < ? > type : parametertypes ) { if ( ! modifier . ispublic ( type . getmodifiers ( ) ) ) { return bool_ ; } } return bool_ ; }	Returns true if the member can be called by a fast class generated in a different classloader.
public key < ? > fixannotations ( key < ? > key ) { return key . getannotation ( ) == null ? key : key . get ( key . gettypeliteral ( ) , key . getannotation ( ) . annotationtype ( ) ) ; }	Replace annotation instances with annotation types, this is only appropriate for testing if akey is bound and not for injecting.
< t > initializable < t > requestinjection ( injectorimpl injector , t instance , binding < t > binding , object source , set < injectionpoint > injectionpoints ) { checknotnull ( source ) ; preconditions . checkstate ( ! validationstarted , str_ ) ; provisionlistenerstackcallback < t > provisioncallback = binding == null ? null : injector . provisionlistenerstore . get ( binding ) ;	Registers an instance for member injection when that step is performed.
void validateoustandinginjections ( errors errors ) { validationstarted = bool_ ; initializablescache . clear ( ) ; for ( injectablereference < ? > reference : pendinginjections ) { try { reference . validate ( errors ) ; } catch ( errorsexception e ) { errors . merge ( e . geterrors ( ) ) ; } } }	Prepares member injectors for all injected instances.
public t newinstance ( object [ ] args ) throws throwable { constructor . setaccessible ( bool_ ) ; try { return constructor . newinstance ( args ) ; } catch ( invocationtargetexception e ) { throw e . getcause ( ) ; } }	Returns an instance of T, constructed using this constructor, with the supplied arguments.
static < t > internalfactory < ? extends t > scope ( key < t > key , injectorimpl injector , internalfactory < ? extends t > creator , object source , scoping scoping ) { if ( scoping . isnoscope ( ) ) { return creator ; } scope scope = scoping . getscopeinstance ( ) ;	Scopes an internal factory.
static scoping makeinjectable ( scoping scoping , injectorimpl injector , errors errors ) { class < ? extends annotation > scopeannotation = scoping . getscopeannotation ( ) ; if ( scopeannotation == null ) { return scoping ; } scopebinding scope = injector . state . getscopebinding ( scopeannotation ) ; if ( scope != null ) { return forinstance ( scope . getscope ( ) ) ; } errors . scopenotfound ( scopeannotation ) ; return unscoped ; }	Replaces annotation scopes with instance scopes using the Injector's annotation-to-instancemap.
static string normalizepath ( string path ) { stringbuilder sb = new stringbuilder ( path . length ( ) ) ; int querystart = path . indexof ( str_ ) ; string query = null ; if ( querystart != - num_ ) { query = path . substring ( querystart ) ; path = path . substring ( num_ , querystart ) ; }	Normalizes a path by unescaping all safe, percent encoded characters.
public static < t extends annotation > t generateannotation ( class < t > annotationtype ) { preconditions . checkstate ( isalldefaultmethods ( annotationtype ) , str_ , annotationtype ) ; return ( t ) cache . getunchecked ( annotationtype ) ; }	Generates an Annotation for the annotation class.
public static boolean isretainedatruntime ( class < ? extends annotation > annotationtype ) { retention retention = annotationtype . getannotation ( retention . class ) ; return retention != null && retention . value ( ) == retentionpolicy . runtime ; }	Returns true if the given annotation is retained at runtime.
public static class < ? extends annotation > findscopeannotation ( errors errors , annotation [ ] annotations ) { class < ? extends annotation > found = null ; for ( annotation annotation : annotations ) { class < ? extends annotation > annotationtype = annotation . annotationtype ( ) ; if ( isscopeannotation ( annotationtype ) ) { if ( found != null ) { errors . duplicatescopeannotations ( found , annotationtype ) ; } else { found = annotationtype ; } } } return found ; }	Returns the scoping annotation, or null if there isn't one.
public static key < ? > getkey ( typeliteral < ? > type , member member , annotation [ ] annotations , errors errors ) throws errorsexception { int numerrorsbefore = errors . size ( ) ; annotation found = findbindingannotation ( errors , member , annotations ) ; errors . throwifnewerrors ( numerrorsbefore ) ; return found == null ? key . get ( type ) : key . get ( type , found ) ; }	Gets a key for the given type, member and annotations.
public static string nameof ( key < ? > key ) { annotation annotation = key . getannotation ( ) ; class < ? extends annotation > annotationtype = key . getannotationtype ( ) ; if ( annotation != null && ! ismarker ( annotationtype ) ) { return key . getannotation ( ) . tostring ( ) ; } else if ( key . getannotationtype ( ) != null ) { return str_ + key . getannotationtype ( ) . getname ( ) ; } else { return str_ ; } }	Returns the name the binding should use.
public void initializedelegate ( provider < t > delegate ) { checkstate ( this . delegate == null , str_ ) ; this . delegate = checknotnull ( delegate , str_ ) ; }	Sets the actual provider.
private void adddirecttypebinding ( binder binder ) { binder . bind ( bindingselection . getdirectkey ( ) ) . toprovider ( new realdirecttypeprovider < t > ( bindingselection ) ) ; }	Adds a binding for T.
public constructorinjector < ? > get ( injectionpoint constructorinjector , errors errors ) throws errorsexception { return cache . get ( constructorinjector , errors ) ; }	Returns a new complete constructor injector with injection listeners registered.
private static boolean hasscope ( class < ? extends interceptor > interceptorclass ) { for ( annotation annotation : interceptorclass . getannotations ( ) ) { if ( annotations . isscopeannotation ( annotation . annotationtype ( ) ) ) { return bool_ ; } } return bool_ ; }	Returns true if the given class has a scope annotation.
static < k , v > realmapbinder < k , v > newrealmapbinder ( binder binder , typeliteral < k > keytype , key < v > valuetypeandannotation ) { binder = binder . skipsources ( realmapbinder . class ) ; typeliteral < v > valuetype = valuetypeandannotation . gettypeliteral ( ) ; return newrealmapbinder ( binder , keytype , valuetype , valuetypeandannotation . oftype ( mapof ( keytype , valuetype ) ) , realmultibinder . newrealsetbinder ( binder , valuetypeandannotation . oftype ( entryofproviderof ( keytype , valuetype ) ) ) ) ; }	since it's an easy way to group a type and an optional annotation type or instance.
key < v > getkeyfornewvalue ( k key ) { checknotnull ( key , str_ ) ; checkconfiguration ( ! bindingselection . isinitialized ( ) , str_ ) ; realmultibinder < map . entry < k , provider < v > > > entrysetbinder = bindingselection . getentrysetbinder ( ) ; key < v > valuekey = key . get ( bindingselection . getvaluetype ( ) , new realelement ( entrysetbinder . getsetname ( ) , mapbinder , bindingselection . getkeytype ( ) . tostring ( ) ) ) ; entrysetbinder . addbinding ( ) . toprovider ( new providermapentry < k , v > ( key , valuekey ) ) ; return valuekey ; }	Adds a binding to the map for the given key.
private t provision ( internalcontext context , constructioncontext < t > constructioncontext ) throws internalprovisionexception { try { t t ; try { object [ ] parameters = singleparameterinjector . getall ( context , parameterinjectors ) ; t = constructionproxy . newinstance ( parameters ) ; constructioncontext . setproxydelegates ( t ) ; } finally { constructioncontext . finishconstruction ( ) ; }	Provisions a new T.
private object writereplace ( ) throws objectstreamexception { object [ ] sourcesasstrings = sources . toarray ( ) ; for ( int i = num_ ; i < sourcesasstrings . length ; i ++ ) { sourcesasstrings [ i ] = errors . convert ( sourcesasstrings [ i ] ) . tostring ( ) ; } return new message ( immutablelist . copyof ( sourcesasstrings ) , message , cause ) ; }	When serialized, we eagerly convert sources to strings.
static module formodule ( module module ) {	Returns a module which creates bindings for provider methods from the given module.
@ override @ suppresswarnings ( str_ ) public collection < assistedmethod > getassistedmethods ( ) { return ( collection < assistedmethod > ) ( collection < ? > ) assistdatabymethod . values ( ) ; }	the collection is immutable.
private boolean istypenotspecified ( typeliteral < ? > typeliteral , configurationexception ce ) { collection < message > messages = ce . geterrormessages ( ) ; if ( messages . size ( ) == num_ ) { message msg = iterables . getonlyelement ( new errors ( ) . keynotfullyspecified ( typeliteral ) . getmessages ( ) ) ; return msg . getmessage ( ) . equals ( iterables . getonlyelement ( messages ) . getmessage ( ) ) ; } else { return bool_ ; } }	Returns true if the ConfigurationException is due to an error of TypeLiteral not being fullyspecified.
private boolean constructorhasmatchingparams ( typeliteral < ? > type , constructor < ? > constructor , list < key < ? > > paramlist , errors errors ) throws errorsexception { list < typeliteral < ? > > params = type . getparametertypes ( constructor ) ; annotation [ ] [ ] paramannotations = constructor . getparameterannotations ( ) ; int p = num_ ; list < key < ? > > constructorkeys = lists . newarraylist ( ) ; for ( typeliteral < ? > param : params ) { key < ? > paramkey = annotations . getkey ( param , constructor , paramannotations [ p ++ ] , errors ) ; constructorkeys . add ( paramkey ) ; }	Matching logic for constructors annotated with AssistedInject. This returns true if and only ifall .
private set < dependency < ? > > getdependencies ( injectionpoint ctorpoint , typeliteral < ? > implementation ) { immutableset . builder < dependency < ? > > builder = immutableset . builder ( ) ; builder . addall ( ctorpoint . getdependencies ( ) ) ; if ( ! implementation . getrawtype ( ) . isinterface ( ) ) { for ( injectionpoint ip : injectionpoint . forinstancemethodsandfields ( implementation ) ) { builder . addall ( ip . getdependencies ( ) ) ; } } return builder . build ( ) ; }	Calculates all dependencies required by the implementation and constructor.
private set < dependency < ? > > removeassisteddeps ( set < dependency < ? > > deps ) { immutableset . builder < dependency < ? > > builder = immutableset . builder ( ) ; for ( dependency < ? > dep : deps ) { class < ? > annotationtype = dep . getkey ( ) . getannotationtype ( ) ; if ( annotationtype == null || ! annotationtype . equals ( assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }	Return all non-assisted dependencies.
private boolean isvalidforoptimizedassistedinject ( set < dependency < ? > > dependencies , class < ? > implementation , typeliteral < ? > factorytype ) { set < dependency < ? > > baddeps = null ;	Returns true if all dependencies are suitable for the optimized version of AssistedInject.
public binding < ? > getbindingfromnewinjector ( final method method , final object [ ] args , final assistdata data ) { checkstate ( injector != null , str_ ) ; final key < ? > returntype = data . returntype ;	Creates a child injector that binds the args, and returns the binding for the method's result.
@ override public object invoke ( object proxy , final method method , final object [ ] args ) throws throwable {	When a factory method is invoked, we create a child injector that binds all parameters, thenuse that to get an instance of the return type.
< t > errors missingimplementationwithhint ( key < t > key , injector injector ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( format ( str_ , key ) ) ;	Within guice's core, allow for better missing binding messages.
public static < t > realmultibinder < t > newrealsetbinder ( binder binder , key < t > key ) { binder = binder . skipsources ( realmultibinder . class ) ; realmultibinder < t > result = new realmultibinder < > ( binder , key ) ; binder . install ( result ) ; return result ; }	Implementation of newSetBinder.
key < t > getkeyfornewitem ( ) { checkconfiguration ( ! bindingselection . isinitialized ( ) , str_ ) ; return key . get ( bindingselection . getelementtypeliteral ( ) , new realelement ( bindingselection . getsetname ( ) , multibinder , str_ ) ) ; }	Adds a new entry to the set and returns the key for it.
private filter findnextfilter ( httpservletrequest request ) { while ( ++ index < filterdefinitions . length ) { filter filter = filterdefinitions [ index ] . getfilterifmatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }	Iterates over the remaining filter definitions.
private static boolean hasatinject ( constructor cxtor ) { return cxtor . isannotationpresent ( inject . class ) || cxtor . isannotationpresent ( javax . inject . inject . class ) ; }	Returns true if the inject annotation is on the constructor.
injectionpoint getinternalconstructor ( ) { if ( factory . constructorinjector != null ) { return factory . constructorinjector . getconstructionproxy ( ) . getinjectionpoint ( ) ; } else { return constructorinjectionpoint ; } }	Returns an injection point that can be used to clean up the constructor store.
set < dependency < ? > > getinternaldependencies ( ) { immutableset . builder < injectionpoint > builder = immutableset . builder ( ) ; if ( factory . constructorinjector == null ) { builder . add ( constructorinjectionpoint ) ;	Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.
public static module formodule ( object module , moduleannotatedmethodscanner scanner ) { return forobject ( module , bool_ , scanner ) ; }	Returns a module which creates bindings methods in the module that match the scanner.
private annotation getannotation ( binder binder , method method ) { if ( method . isbridge ( ) || method . issynthetic ( ) ) { return null ; } annotation annotation = null ; for ( class < ? extends annotation > annotationclass : scanner . annotationclasses ( ) ) { annotation foundannotation = method . getannotation ( annotationclass ) ; if ( foundannotation != null ) { if ( annotation != null ) { binder . adderror ( str_ + str_ , scanner , method ) ; return null ; } annotation = foundannotation ; } } return annotation ; }	Returns the annotation that is claimed by the scanner, or null if there is none.
public integer getlinenumber ( member member ) { preconditions . checkargument ( type == member . getdeclaringclass ( ) , str_ , member , member . getdeclaringclass ( ) , type ) ; return lines . get ( memberkey ( member ) ) ; }	Get the line number associated with the given member.
void initialize ( errors errors ) { injector . lookups = injector ; new lookupprocessor ( errors ) . process ( injector , lookups ) ; }	Initialize the specified lookups, either immediately or when the injector is created.
private static object validateandcanonicalizevalue ( key < ? > key , object object ) { if ( object == null || object == nullobject . instance ) { return nullobject . instance ; } if ( ! key . gettypeliteral ( ) . getrawtype ( ) . isinstance ( object ) ) { throw new illegalargumentexception ( str_ + object + str_ + object . getclass ( ) . getname ( ) + str_ + key + str_ ) ; } return object ; }	Validates the key and object, ensuring the value matches the key type, and canonicalizing nullobjects to the null sentinel.
@ suppresswarnings ( str_ )	Returns a new complete members injector with injection listeners registered.
private < t > membersinjectorimpl < t > createwithlisteners ( typeliteral < t > type , errors errors ) throws errorsexception { int numerrorsbefore = errors . size ( ) ; set < injectionpoint > injectionpoints ; try { injectionpoints = injectionpoint . forinstancemethodsandfields ( type ) ; } catch ( configurationexception e ) { errors . merge ( e . geterrormessages ( ) ) ; injectionpoints = e . getpartialvalue ( ) ; } immutablelist < singlememberinjector > injectors = getinjectors ( injectionpoints , errors ) ; errors . throwifnewerrors ( numerrorsbefore ) ; encounterimpl < t > encounter = new encounterimpl < > ( errors , injector . lookups ) ; set < typelistener > alreadyseenlisteners = sets . newhashset ( ) ; for ( typelistenerbinding binding : typelistenerbindings ) { typelistener typelistener = binding . getlistener ( ) ; if ( ! alreadyseenlisteners . contains ( typelistener ) && binding . gettypematcher ( ) . matches ( type ) ) { alreadyseenlisteners . add ( typelistener ) ; try { typelistener . hear ( type , encounter ) ; } catch ( runtimeexception e ) { errors . errornotifyingtypelistener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwifnewerrors ( numerrorsbefore ) ; return new membersinjectorimpl < t > ( injector , type , encounter , injectors ) ; }	Creates a new members injector and attaches both injection listeners and method aspects.
immutablelist < singlememberinjector > getinjectors ( set < injectionpoint > injectionpoints , errors errors ) { list < singlememberinjector > injectors = lists . newarraylist ( ) ; for ( injectionpoint injectionpoint : injectionpoints ) { try { errors errorsformember = injectionpoint . isoptional ( ) ? new errors ( injectionpoint ) : errors . withsource ( injectionpoint ) ; singlememberinjector injector = injectionpoint . getmember ( ) instanceof field ? new singlefieldinjector ( this . injector , injectionpoint , errorsformember ) : new singlemethodinjector ( this . injector , injectionpoint , errorsformember ) ; injectors . add ( injector ) ; } catch ( errorsexception ignoredfornow ) {	Returns the injectors for the specified injection points.
static < t > key < t > get ( class < t > type , annotationstrategy annotationstrategy ) { return new key < t > ( type , annotationstrategy ) ; }	Gets a key for an injection type and an annotation strategy.
static annotationstrategy strategyfor ( annotation annotation ) { checknotnull ( annotation , str_ ) ; class < ? extends annotation > annotationtype = annotation . annotationtype ( ) ; ensureretainedatruntime ( annotationtype ) ; ensureisbindingannotation ( annotationtype ) ; if ( annotations . ismarker ( annotationtype ) ) { return new annotationtypestrategy ( annotationtype , annotation ) ; } return new annotationinstancestrategy ( annotations . canonicalizeifnamed ( annotation ) ) ; }	Gets the strategy for an annotation.
static annotationstrategy strategyfor ( class < ? extends annotation > annotationtype ) { annotationtype = annotations . canonicalizeifnamed ( annotationtype ) ; if ( isalldefaultmethods ( annotationtype ) ) { return strategyfor ( generateannotation ( annotationtype ) ) ; } checknotnull ( annotationtype , str_ ) ; ensureretainedatruntime ( annotationtype ) ; ensureisbindingannotation ( annotationtype ) ; return new annotationtypestrategy ( annotationtype , null ) ; }	Gets the strategy for an annotation type.
private void prunestacktrace ( throwable throwable ) { for ( throwable t = throwable ; t != null ; t = t . getcause ( ) ) { stacktraceelement [ ] stacktrace = t . getstacktrace ( ) ; list < stacktraceelement > pruned = lists . newarraylist ( ) ; for ( stacktraceelement element : stacktrace ) { string classname = element . getclassname ( ) ; if ( ! aop_internal_classes . contains ( classname ) && ! classname . contains ( str_ ) ) { pruned . add ( element ) ; } } t . setstacktrace ( pruned . toarray ( new stacktraceelement [ pruned . size ( ) ] ) ) ; } }	Removes stacktrace elements related to AOP internal mechanics from the throwable's stack traceand any causes it may have.
public string getbindingsource ( ) { if ( source instanceof class ) { return stacktraceelements . fortype ( ( class ) source ) . tostring ( ) ; } else if ( source instanceof member ) { return stacktraceelements . formember ( ( member ) source ) . tostring ( ) ; } else { return source . tostring ( ) ; } }	Returns a string describing where this dependency was bound.
public static message create ( string messageformat , object ... arguments ) { return create ( null , messageformat , arguments ) ; }	Creates a new Message without a cause.
public static message create ( throwable cause , string messageformat , object ... arguments ) { return create ( cause , immutablelist . of ( ) , messageformat , arguments ) ; }	Creates a new Message with the given cause.
public static message create ( throwable cause , list < object > sources , string messageformat , object ... arguments ) { string message = format ( messageformat , arguments ) ; return new message ( sources , message , cause ) ; }	Creates a new Message with the given cause and a binding source stack.
static object convert ( object o ) { elementsource source = null ; if ( o instanceof elementsource ) { source = ( elementsource ) o ; o = source . getdeclaringsource ( ) ; } return convert ( o , source ) ; }	Formats an object in a user friendly way.
private boolean shouldbeskipped ( string classname ) { return ( parent != null && parent . shouldbeskipped ( classname ) ) || classnamestoskip . contains ( classname ) ; }	Returns true if the className should be skipped.
public object getfromclassnames ( list < string > moduleclassnames ) { preconditions . checknotnull ( moduleclassnames , str_ ) ; for ( final string moduleclassname : moduleclassnames ) { if ( ! shouldbeskipped ( moduleclassname ) ) { return new stacktraceelement ( moduleclassname , str_ , null , - num_ ) ; } } return unknown_source ; }	Returns the non-skipped module class name.
public static void main ( string [ ] args ) throws exception { if ( args . length != num_ ) { system . err . println ( str_ + manager . class . getname ( ) + str_ ) ; system . err . println ( str_ ) ; system . exit ( num_ ) ; } module module = ( module ) class . forname ( args [ num_ ] ) . newinstance ( ) ; injector injector = guice . createinjector ( module ) ; manage ( args [ num_ ] , injector ) ; system . out . println ( str_ ) ;	Run with no arguments for usage instructions.
dependency < ? > pushdependency ( dependency < ? > dependency , object source ) { dependency < ? > previous = this . dependency ; this . dependency = dependency ; dopushstate ( dependency , source ) ; return previous ; }	Sets the new current dependency & adds it to the state.
void pushstate ( com . google . inject . key < ? > key , object source ) { dopushstate ( key , source ) ; }	Adds to the state without setting the dependency.
static < t > initializable < t > of ( final t instance ) { return new initializable < t > ( ) { @ override public t get ( ) { return instance ; } @ override public string tostring ( ) { return string . valueof ( instance ) ; } } ; }	Returns an initializable for an instance that requires no initialization.
protected t provision ( provider < ? extends t > provider , dependency < ? > dependency , constructioncontext < t > constructioncontext ) throws internalprovisionexception { t t = provider . get ( ) ; if ( t == null && ! dependency . isnullable ( ) ) { internalprovisionexception . onnullinjectedintononnullabledependency ( source , dependency ) ; } constructioncontext . setproxydelegates ( t ) ; return t ; }	Provisions a new instance.
public void onevent ( connectioneventtype type , string remoteaddr , connection conn ) { list < connectioneventprocessor > processorlist = this . processors . get ( type ) ; if ( processorlist != null ) { for ( connectioneventprocessor processor : processorlist ) { processor . onevent ( remoteaddr , conn ) ; } } }	Dispatch events.
public void addconnectioneventprocessor ( connectioneventtype type , connectioneventprocessor processor ) { list < connectioneventprocessor > processorlist = this . processors . get ( type ) ; if ( processorlist == null ) { this . processors . putifabsent ( type , new arraylist < connectioneventprocessor > ( num_ ) ) ; processorlist = this . processors . get ( type ) ; } processorlist . add ( processor ) ; }	Add event processor.
public static < t > t getfuturetaskresult ( runstaterecordedfuturetask < t > task , logger logger ) { t t = null ; if ( null != task ) { try { t = task . getafterrun ( ) ; } catch ( interruptedexception e ) { logger . error ( str_ , e ) ; } catch ( executionexception e ) { logger . error ( str_ , e ) ; } catch ( futuretasknotrunyetexception e ) { logger . error ( str_ , e ) ; } catch ( futuretasknotcompleted e ) { logger . error ( str_ , e ) ; } } return t ; }	get the result of a future taskNotice: the run method of this task should have been called at first.
public static void launderthrowable ( throwable t ) { if ( t instanceof runtimeexception ) { throw ( runtimeexception ) t ; } else if ( t instanceof error ) { throw ( error ) t ; } else { throw new illegalstateexception ( str_ , t ) ; } }	launder the throwable.
public void registerprocessor ( commandcode cmdcode , remotingprocessor < ? > processor ) { if ( this . cmd2processors . containskey ( cmdcode ) ) { logger . warn ( str_ , cmdcode , cmd2processors . get ( cmdcode ) . getclass ( ) . getname ( ) , processor . getclass ( ) . getname ( ) ) ; } this . cmd2processors . put ( cmdcode , processor ) ; }	Register processor to process command that has the command code of cmdCode.
public void registerdefaultprocessor ( remotingprocessor < ? > processor ) { if ( this . defaultprocessor == null ) { this . defaultprocessor = processor ; } else { throw new illegalstateexception ( str_ + this . defaultprocessor . getclass ( ) ) ; } }	Register the default processor to process command with no specific processor registered.
public remotingprocessor < ? > getprocessor ( commandcode cmdcode ) { remotingprocessor < ? > processor = this . cmd2processors . get ( cmdcode ) ; if ( processor != null ) { return processor ; } return this . defaultprocessor ; }	Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.
private url tryget ( string url ) { softreference < url > softref = url . parsedurls . get ( url ) ; return ( null == softref ) ? null : softref . get ( ) ; }	try get from cache.
protected protocolcode decodeprotocolcode ( bytebuf in ) { if ( in . readablebytes ( ) >= protocolcodelength ) { byte [ ] protocolcodebytes = new byte [ protocolcodelength ] ; in . readbytes ( protocolcodebytes ) ; return protocolcode . frombytes ( protocolcodebytes ) ; } return null ; }	decode the protocol code.
@ override public map < string , list < connection > > getall ( ) { map < string , list < connection > > allconnections = new hashmap < string , list < connection > > ( ) ; iterator < map . entry < string , runstaterecordedfuturetask < connectionpool > > > iterator = this . getconnpools ( ) . entryset ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { map . entry < string , runstaterecordedfuturetask < connectionpool > > entry = iterator . next ( ) ; connectionpool pool = futuretaskutil . getfuturetaskresult ( entry . getvalue ( ) , logger ) ; if ( null != pool ) { allconnections . put ( entry . getkey ( ) , pool . getall ( ) ) ; } } return allconnections ; }	Get all connections of all poolKey.
@ override public void scan ( ) { if ( null != this . conntasks && ! this . conntasks . isempty ( ) ) { iterator < string > iter = this . conntasks . keyset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { string poolkey = iter . next ( ) ; connectionpool pool = this . getconnectionpool ( this . conntasks . get ( poolkey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isempty ( ) ) { if ( ( system . currenttimemillis ( ) - pool . getlastaccesstimestamp ( ) ) > default_expire_time ) { iter . remove ( ) ; logger . warn ( str_ , poolkey ) ; } } } } } }	in case of cache pollution and connection leak, to do schedule scan.
@ override public connection getandcreateifabsent ( url url ) throws interruptedexception , remotingexception {	If no task cached, create one and initialize the connections.
@ override public void createconnectionandhealifneed ( url url ) throws interruptedexception , remotingexception {	If no task cached, create one and initialize the connections.If task cached, check whether the number of connections adequate, if not then heal it.
private void removetask ( string poolkey ) { runstaterecordedfuturetask < connectionpool > task = this . conntasks . remove ( poolkey ) ; if ( null != task ) { connectionpool pool = futuretaskutil . getfuturetaskresult ( task , logger ) ; if ( null != pool ) { pool . removeallandtryclose ( ) ; } } }	remove task and remove all connections.
private void healifneed ( connectionpool pool , url url ) throws remotingexception , interruptedexception { string poolkey = url . getuniquekey ( ) ;	execute heal connection tasks if the actual number of connections in pool is less than expected.
private void docreate ( final url url , final connectionpool pool , final string taskname , final int synccreatenumwhennotwarmup ) throws remotingexception { final int actualnum = pool . size ( ) ; final int expectnum = url . getconnnum ( ) ; if ( actualnum < expectnum ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ , actualnum , expectnum , taskname ) ; } if ( url . isconnwarmup ( ) ) { for ( int i = actualnum ; i < expectnum ; ++ i ) { connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( synccreatenumwhennotwarmup < num_ || synccreatenumwhennotwarmup > url . getconnnum ( ) ) { throw new illegalargumentexception ( str_ + url . getconnnum ( ) + str_ ) ; }	do create connections.
public void closeconnection ( string addr ) { url url = this . addressparser . parse ( addr ) ; this . connectionmanager . remove ( url . getuniquekey ( ) ) ; }	Close all connections of a address.
public void onclose ( ) { iterator < entry < integer , invokefuture > > iter = invokefuturemap . entryset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { entry < integer , invokefuture > entry = iter . next ( ) ; iter . remove ( ) ; invokefuture future = entry . getvalue ( ) ; if ( future != null ) { future . putresponse ( future . createconnectionclosedresponse ( this . getremoteaddress ( ) ) ) ; future . canceltimeout ( ) ; future . tryasyncexecuteinvokecallbackabnormally ( ) ; } } }	Do something when closing.
public void close ( ) { if ( closed . compareandset ( bool_ , bool_ ) ) { try { if ( this . getchannel ( ) != null ) { this . getchannel ( ) . close ( ) . addlistener ( new channelfuturelistener ( ) { @ override public void operationcomplete ( channelfuture future ) throws exception { if ( logger . isinfoenabled ( ) ) { logger . info ( str_ , remotingutil . parseremoteaddress ( connection . this . getchannel ( ) ) , future . issuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( exception e ) { logger . warn ( str_ , remotingutil . parseremoteaddress ( connection . this . getchannel ( ) ) , e ) ; } } }	Close the connection.
public object setattributeifabsent ( string key , object value ) { return attributes . putifabsent ( key , value ) ; }	set attribute if key absent.
public static void registeruserprocessor ( userprocessor < ? > processor , concurrenthashmap < string , userprocessor < ? > > userprocessors ) { if ( null == processor ) { throw new runtimeexception ( str_ ) ; } if ( processor instanceof multiinterestuserprocessor ) { registeruserprocessor ( ( multiinterestuserprocessor ) processor , userprocessors ) ; } else { if ( stringutils . isblank ( processor . interest ( ) ) ) { throw new runtimeexception ( str_ ) ; } userprocessor < ? > preprocessor = userprocessors . putifabsent ( processor . interest ( ) , processor ) ; if ( preprocessor != null ) { string errmsg = str_ + processor . interest ( ) + str_ ; throw new runtimeexception ( errmsg ) ; } } }	Help register single-interest user processor.
private static void registeruserprocessor ( multiinterestuserprocessor < ? > processor , concurrenthashmap < string , userprocessor < ? > > userprocessors ) { if ( null == processor . multiinterest ( ) || processor . multiinterest ( ) . isempty ( ) ) { throw new runtimeexception ( str_ ) ; } for ( string interest : processor . multiinterest ( ) ) { userprocessor < ? > preprocessor = userprocessors . putifabsent ( interest , processor ) ; if ( preprocessor != null ) { string errmsg = str_ + interest + str_ ; throw new runtimeexception ( errmsg ) ; } } }	Help register multi-interest user processor.
private void dispatchtouserprocessor ( remotingcontext ctx , rpcrequestcommand cmd ) { final int id = cmd . getid ( ) ; final byte type = cmd . gettype ( ) ;	dispatch request command to user processor.
private boolean deserializerequestcommand ( remotingcontext ctx , rpcrequestcommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = bool_ ; } catch ( deserializationexception e ) { logger . error ( str_ , cmd . getid ( ) , rpcdeserializelevel . valueof ( level ) , e ) ; sendresponseifnecessary ( ctx , cmd . gettype ( ) , this . getcommandfactory ( ) . createexceptionresponse ( cmd . getid ( ) , responsestatus . server_deserial_exception , e ) ) ; result = bool_ ; } catch ( throwable t ) { string errmsg = str_ + cmd . getid ( ) + str_ + level ; logger . error ( errmsg , t ) ; sendresponseifnecessary ( ctx , cmd . gettype ( ) , this . getcommandfactory ( ) . createexceptionresponse ( cmd . getid ( ) , t , errmsg ) ) ; result = bool_ ; } return result ; }	deserialize request command.
private void preprocessremotingcontext ( remotingcontext ctx , rpcrequestcommand cmd , long currenttimestamp ) { ctx . setarrivetimestamp ( cmd . getarrivetime ( ) ) ; ctx . settimeout ( cmd . gettimeout ( ) ) ; ctx . setrpccommandtype ( cmd . gettype ( ) ) ; ctx . getinvokecontext ( ) . putifabsent ( invokecontext . bolt_process_wait_time , currenttimestamp - cmd . getarrivetime ( ) ) ; }	pre process remoting context, initial some useful infos and pass to biz.
private void timeoutlog ( final rpcrequestcommand cmd , long currenttimestamp , remotingcontext ctx ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ , cmd . getid ( ) , currenttimestamp , cmd . getarrivetime ( ) , ( currenttimestamp - cmd . getarrivetime ( ) ) , cmd . gettimeout ( ) ) ; } string remoteaddr = str_ ; if ( null != ctx ) { channelhandlercontext channelctx = ctx . getchannelcontext ( ) ; channel channel = channelctx . channel ( ) ; if ( null != channel ) { remoteaddr = remotingutil . parseremoteaddress ( channel ) ; } } logger . warn ( str_ , cmd . getid ( ) , remoteaddr , ( currenttimestamp - cmd . getarrivetime ( ) ) , cmd . gettimeout ( ) ) ; }	print some log when request timeout and discarded in io thread.
private void debuglog ( remotingcontext ctx , rpcrequestcommand cmd , long currenttimestamp ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ , cmd . getid ( ) , remotingutil . parseremoteaddress ( ctx . getchannelcontext ( ) . channel ( ) ) ) ; logger . debug ( str_ , cmd . getid ( ) , currenttimestamp , cmd . getarrivetime ( ) , ( currenttimestamp - cmd . getarrivetime ( ) ) , cmd . gettimeout ( ) ) ; } }	print some debug log when receive request.
@ override public void process ( remotingcontext ctx , t msg , executorservice defaultexecutor ) throws exception { processtask task = new processtask ( ctx , msg ) ; if ( this . getexecutor ( ) != null ) { this . getexecutor ( ) . execute ( task ) ; } else { defaultexecutor . execute ( task ) ; } }	Process the remoting command with its own executor or with the defaultExecutor if its own if null.
protected void oneway ( final connection conn , final remotingcommand request ) { try { conn . getchannel ( ) . writeandflush ( request ) . addlistener ( new channelfuturelistener ( ) { @ override public void operationcomplete ( channelfuture f ) throws exception { if ( ! f . issuccess ( ) ) { logger . error ( str_ , remotingutil . parseremoteaddress ( conn . getchannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( exception e ) { if ( null == conn ) { logger . error ( str_ ) ; } else { logger . error ( str_ , remotingutil . parseremoteaddress ( conn . getchannel ( ) ) , e ) ; } } }	Oneway invocation.
public static byte tobyte ( bitset bs ) { int value = num_ ; for ( int i = num_ ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += num_ << i ; } } if ( bs . length ( ) > num_ ) { throw new illegalargumentexception ( str_ + value + str_ + bs + str_ + byte . min_value + str_ + byte . max_value + str_ ) ; } return ( byte ) value ; }	from bit set to byte.
public static bitset tobitset ( int value ) { if ( value > byte . max_value || value < byte . min_value ) { throw new illegalargumentexception ( str_ + value + str_ + byte . min_value + str_ + byte . max_value + str_ ) ; } bitset bs = new bitset ( ) ; int index = num_ ; while ( value != num_ ) { if ( value % num_ != num_ ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value > > num_ ) ; } return bs ; }	from byte to bit set.
public void addreconnecttask ( url url ) { reconnecttask task = new reconnecttask ( ) ; task . url = url ; tasks . add ( task ) ; }	add reconnect task.
protected remotingcommand toremotingcommand ( object request , connection conn , invokecontext invokecontext , int timeoutmillis ) throws serializationexception { rpcrequestcommand command = this . getcommandfactory ( ) . createrequestcommand ( request ) ; if ( null != invokecontext ) {	Convert application request object to remoting request command.
@ override public map < string , list < connection > > filter ( list < connection > connections ) { list < connection > serviceonconnections = new arraylist < connection > ( ) ; list < connection > serviceoffconnections = new arraylist < connection > ( ) ; map < string , list < connection > > filteredconnections = new concurrenthashmap < string , list < connection > > ( ) ; for ( connection connection : connections ) { string servicestatus = ( string ) connection . getattribute ( configs . conn_service_status ) ; if ( servicestatus != null ) { if ( connection . isinvokefuturemapfinish ( ) && ! freshselectconnections . containsvalue ( connection ) ) { serviceoffconnections . add ( connection ) ; } } else { serviceonconnections . add ( connection ) ; } } filteredconnections . put ( configs . conn_service_status_on , serviceonconnections ) ; filteredconnections . put ( configs . conn_service_status_off , serviceoffconnections ) ; return filteredconnections ; }	Filter connections to monitor.
private void closefreshselectconnections ( connection lastselectconnect , list < connection > serviceoffconnections ) throws interruptedexception { if ( null != lastselectconnect ) { if ( lastselectconnect . isinvokefuturemapfinish ( ) ) { serviceoffconnections . add ( lastselectconnect ) ; } else { thread . sleep ( retry_detect_period ) ; if ( lastselectconnect . isinvokefuturemapfinish ( ) ) { serviceoffconnections . add ( lastselectconnect ) ; } else { if ( logger . isinfoenabled ( ) ) { logger . info ( str_ , remotingutil . parseremoteaddress ( lastselectconnect . getchannel ( ) ) ) ; } } } } }	close the connection of the fresh select connections.
public static boolean getbool ( string key , string defaultvalue ) { return boolean . parseboolean ( system . getproperty ( key , defaultvalue ) ) ; }	~~~ public helper methods to retrieve system property.
private void infolog ( string format , string addr ) { if ( logger . isinfoenabled ( ) ) { if ( stringutils . isnotempty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , str_ ) ; } } }	print info log.
public boolean isrequesttimeout ( ) { if ( this . timeout > num_ && ( this . rpccommandtype != rpccommandtype . request_oneway ) && ( system . currenttimemillis ( ) - this . arrivetimestamp ) > this . timeout ) { return bool_ ; } return bool_ ; }	whether this request already timeout.
public userprocessor < ? > getuserprocessor ( string classname ) { return stringutils . isblank ( classname ) ? null : this . userprocessors . get ( classname ) ; }	Get user processor for class name.
private connection randomget ( list < connection > conns ) { if ( null == conns || conns . isempty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = num_ ; connection result = null ; while ( ( result == null || ! result . isfine ( ) ) && tries ++ < max_times ) { result = conns . get ( this . random . nextint ( size ) ) ; } if ( result != null && ! result . isfine ( ) ) { result = null ; } return result ; }	get one connection randomly.
@ suppresswarnings ( str_ ) public < t > t get ( string key , t defaultifnotfound ) { return this . context . get ( key ) != null ? ( t ) this . context . get ( key ) : defaultifnotfound ; }	get and use default if not found.
public string getproperty ( string key ) { if ( properties == null ) { return null ; } return properties . getproperty ( key ) ; }	Get property value according to property key.
public static object resolveresponseobject ( responsecommand responsecommand , string addr ) throws remotingexception { preprocess ( responsecommand , addr ) ; if ( responsecommand . getresponsestatus ( ) == responsestatus . success ) { return toresponseobject ( responsecommand ) ; } else { string msg = string . format ( str_ , responsecommand . getresponsestatus ( ) , addr , responsecommand . getid ( ) ) ; logger . warn ( msg ) ; if ( responsecommand . getcause ( ) != null ) { throw new invokeexception ( msg , responsecommand . getcause ( ) ) ; } else { throw new invokeexception ( msg + str_ ) ; } } }	Analyze the response command and generate the response object.
private static object toresponseobject ( responsecommand responsecommand ) throws codecexception { rpcresponsecommand response = ( rpcresponsecommand ) responsecommand ; response . deserialize ( ) ; return response . getresponseobject ( ) ; }	Convert remoting response command to application response object.
private static throwable tothrowable ( responsecommand responsecommand ) throws codecexception { rpcresponsecommand resp = ( rpcresponsecommand ) responsecommand ; resp . deserialize ( ) ; object ex = resp . getresponseobject ( ) ; if ( ex != null && ex instanceof throwable ) { return ( throwable ) ex ; } return null ; }	Convert remoting response command to throwable if it is a throwable, otherwise return null.
private static string detailerrmsg ( string clienterrmsg , responsecommand responsecommand ) { rpcresponsecommand resp = ( rpcresponsecommand ) responsecommand ; if ( stringutils . isnotblank ( resp . geterrormsg ( ) ) ) { return string . format ( str_ , clienterrmsg , resp . geterrormsg ( ) ) ; } else { return string . format ( str_ , clienterrmsg ) ; } }	Detail your error msg with the error msg returned from response command.
private rpcserverexception createserverexception ( throwable t , string errmsg ) { string formattederrmsg = string . format ( str_ , t . getclass ( ) . getname ( ) , t . getmessage ( ) , errmsg ) ; rpcserverexception e = new rpcserverexception ( formattederrmsg ) ; e . setstacktrace ( t . getstacktrace ( ) ) ; return e ; }	create server exception using error msg and fill the stack trace using the stack trace of throwable.
public static void printconnectiontracelog ( logger logger , string traceid , invokecontext invokecontext ) { string sourceip = invokecontext . get ( invokecontext . client_local_ip ) ; integer sourceport = invokecontext . get ( invokecontext . client_local_port ) ; string targetip = invokecontext . get ( invokecontext . client_remote_ip ) ; integer targetport = invokecontext . get ( invokecontext . client_remote_port ) ; stringbuilder logmsg = new stringbuilder ( ) ; logmsg . append ( traceid ) . append ( str_ ) ; logmsg . append ( sourceip ) . append ( str_ ) ; logmsg . append ( sourceport ) . append ( str_ ) ; logmsg . append ( targetip ) . append ( str_ ) ; logmsg . append ( targetport ) ; if ( logger . isinfoenabled ( ) ) { logger . info ( logmsg . tostring ( ) ) ; } }	print trace log.
public static eventloopgroup neweventloopgroup ( int nthreads , threadfactory threadfactory ) { return epollenabled ? new epolleventloopgroup ( nthreads , threadfactory ) : new nioeventloopgroup ( nthreads , threadfactory ) ; }	Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.
public static string parseremoteaddress ( final channel channel ) { if ( null == channel ) { return stringutils . empty ; } final socketaddress remote = channel . remoteaddress ( ) ; return doparse ( remote != null ? remote . tostring ( ) . trim ( ) : stringutils . empty ) ; }	Parse the remote address of the channel.
public static string parselocaladdress ( final channel channel ) { if ( null == channel ) { return stringutils . empty ; } final socketaddress local = channel . localaddress ( ) ; return doparse ( local != null ? local . tostring ( ) . trim ( ) : stringutils . empty ) ; }	Parse the local address of the channel.
public static string parseremoteip ( final channel channel ) { if ( null == channel ) { return stringutils . empty ; } final inetsocketaddress remote = ( inetsocketaddress ) channel . remoteaddress ( ) ; if ( remote != null ) { return remote . getaddress ( ) . gethostaddress ( ) ; } return stringutils . empty ; }	Parse the remote host ip of the channel.
public static string parseremotehostname ( final channel channel ) { if ( null == channel ) { return stringutils . empty ; } final inetsocketaddress remote = ( inetsocketaddress ) channel . remoteaddress ( ) ; if ( remote != null ) { return remote . getaddress ( ) . gethostname ( ) ; } return stringutils . empty ; }	Parse the remote hostname of the channel.Note: take care to use this method, for a reverse name lookup takes uncertain time in {.
public static string parselocalip ( final channel channel ) { if ( null == channel ) { return stringutils . empty ; } final inetsocketaddress local = ( inetsocketaddress ) channel . localaddress ( ) ; if ( local != null ) { return local . getaddress ( ) . gethostaddress ( ) ; } return stringutils . empty ; }	Parse the local host ip of the channel.
public static int parseremoteport ( final channel channel ) { if ( null == channel ) { return - num_ ; } final inetsocketaddress remote = ( inetsocketaddress ) channel . remoteaddress ( ) ; if ( remote != null ) { return remote . getport ( ) ; } return - num_ ; }	Parse the remote host port of the channel.
public static int parselocalport ( final channel channel ) { if ( null == channel ) { return - num_ ; } final inetsocketaddress local = ( inetsocketaddress ) channel . localaddress ( ) ; if ( local != null ) { return local . getport ( ) ; } return - num_ ; }	Parse the local host port of the channel.
public static string parsesocketaddresstohostip ( socketaddress socketaddress ) { final inetsocketaddress addrs = ( inetsocketaddress ) socketaddress ; if ( addrs != null ) { inetaddress addr = addrs . getaddress ( ) ; if ( null != addr ) { return addr . gethostaddress ( ) ; } } return stringutils . empty ; }	Parse the host ip of socket address.e.g.
public void add ( connection connection ) { markaccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addifabsent ( connection ) ; if ( res ) { connection . increaseref ( ) ; } }	add a connection.
public void removeandtryclose ( connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseref ( ) ; } if ( connection . noref ( ) ) { connection . close ( ) ; } }	removeAndTryClose a connection.
public static void registercustomserializer ( string classname , customserializer serializer ) { customserializer prevserializer = classcustomserializer . putifabsent ( classname , serializer ) ; if ( prevserializer != null ) { throw new runtimeexception ( str_ + classname + str_ + prevserializer . getclass ( ) . getname ( ) ) ; } }	Register custom serializer for class name.
public static customserializer getcustomserializer ( string classname ) { if ( ! classcustomserializer . isempty ( ) ) { return classcustomserializer . get ( classname ) ; } return null ; }	Get the custom serializer for class name.
public static void registercustomserializer ( commandcode code , customserializer serializer ) { customserializer prevserializer = commandcustomserializer . putifabsent ( code , serializer ) ; if ( prevserializer != null ) { throw new runtimeexception ( str_ + code + str_ + prevserializer . getclass ( ) . getname ( ) ) ; } }	Register custom serializer for command code.
public static customserializer getcustomserializer ( commandcode code ) { if ( ! commandcustomserializer . isempty ( ) ) { return commandcustomserializer . get ( code ) ; } return null ; }	Get the custom serializer for command code.
public boolean isconnected ( string remoteaddr ) { url url = this . rpcremoting . addressparser . parse ( remoteaddr ) ; return this . isconnected ( url ) ; }	check whether a client address connected.
private void initwritebufferwatermark ( ) { int lowwatermark = this . netty_buffer_low_watermark ( ) ; int highwatermark = this . netty_buffer_high_watermark ( ) ; if ( lowwatermark > highwatermark ) { throw new illegalargumentexception ( string . format ( str_ , highwatermark , lowwatermark ) ) ; } else { logger . warn ( str_ , lowwatermark , highwatermark ) ; } this . bootstrap . childoption ( channeloption . write_buffer_water_mark , new writebufferwatermark ( lowwatermark , highwatermark ) ) ; }	init netty write buffer water mark.
public static framedataimpl1 get ( opcode opcode ) { if ( opcode == null ) { throw new illegalargumentexception ( str_ ) ; } switch ( opcode ) { case ping : return new pingframe ( ) ; case pong : return new pongframe ( ) ; case text : return new textframe ( ) ; case binary : return new binaryframe ( ) ; case closing : return new closeframe ( ) ; case continuous : return new continuousframe ( ) ; default : throw new illegalargumentexception ( str_ ) ; } }	Get a frame with a specific opcode.
public static boolean batch ( websocketimpl ws , bytechannel sockchannel ) throws ioexception { if ( ws == null ) { return bool_ ; } bytebuffer buffer = ws . outqueue . peek ( ) ; wrappedbytechannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof wrappedbytechannel ) { c = ( wrappedbytechannel ) sockchannel ; if ( c . isneedwrite ( ) ) { c . writemore ( ) ; } } } else { do {	Returns whether the whole outQueue has been flushed.
public void setcode ( int code ) { this . code = code ;	Set the close code for this close frame.
private void validateutf8 ( bytebuffer payload , int mark ) throws invaliddataexception { try { payload . position ( payload . position ( ) + num_ ) ; reason = charsetfunctions . stringutf8 ( payload ) ; } catch ( illegalargumentexception e ) { throw new invaliddataexception ( closeframe . no_utf8 ) ; } finally { payload . position ( mark ) ; } }	Validate the payload to valid utf8.
private void updatepayload ( ) { byte [ ] by = charsetfunctions . utf8bytes ( reason ) ; bytebuffer buf = bytebuffer . allocate ( num_ ) ; buf . putint ( code ) ; buf . position ( num_ ) ; bytebuffer pay = bytebuffer . allocate ( num_ + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setpayload ( pay ) ; }	Update the payload to represent the close code and the reason.
private handshakestate containsrequestedprotocol ( string requestedprotocol ) { for ( iprotocol knownprotocol : knownprotocols ) { if ( knownprotocol . acceptprovidedprotocol ( requestedprotocol ) ) { protocol = knownprotocol ; log . trace ( str_ , protocol ) ; return handshakestate . matched ; } } return handshakestate . not_matched ; }	Check if the requested protocol is part of this draft.
private void translatesingleframechecklengthlimit ( long length ) throws limitexceededexception { if ( length > integer . max_value ) { log . trace ( str_ ) ; throw new limitexceededexception ( str_ ) ; } if ( length > maxframesize ) { log . trace ( str_ , maxframesize , length ) ; throw new limitexceededexception ( str_ , maxframesize ) ; } if ( length < num_ ) { log . trace ( str_ ) ; throw new limitexceededexception ( str_ ) ; } }	Check if the frame size exceeds the allowed limit.
private void translatesingleframecheckpacketsize ( int maxpacketsize , int realpacketsize ) throws incompleteexception { if ( maxpacketsize < realpacketsize ) { log . trace ( str_ ) ; throw new incompleteexception ( realpacketsize ) ; } }	Check if the max packet size is smaller than the real packet size.
private string generatefinalkey ( string in ) { string seckey = in . trim ( ) ; string acc = seckey + str_ ; messagedigest sh1 ; try { sh1 = messagedigest . getinstance ( str_ ) ; } catch ( nosuchalgorithmexception e ) { throw new illegalstateexception ( e ) ; } return base64 . encodebytes ( sh1 . digest ( acc . getbytes ( ) ) ) ; }	Generate a final key from a input string.
private void processframecontinuousandnonfin ( websocketimpl websocketimpl , framedata frame , opcode curop ) throws invaliddataexception { if ( curop != opcode . continuous ) { processframeisnotfin ( frame ) ; } else if ( frame . isfin ( ) ) { processframeisfin ( websocketimpl , frame ) ; } else if ( currentcontinuousframe == null ) { log . error ( str_ ) ; throw new invaliddataexception ( closeframe . protocol_error , str_ ) ; }	Process the frame if it is a continuous frame or the fin bit is not set.
private void processframebinary ( websocketimpl websocketimpl , framedata frame ) { try { websocketimpl . getwebsocketlistener ( ) . onwebsocketmessage ( websocketimpl , frame . getpayloaddata ( ) ) ; } catch ( runtimeexception e ) { logruntimeexception ( websocketimpl , e ) ; } }	Process the frame if it is a binary frame.
private void logruntimeexception ( websocketimpl websocketimpl , runtimeexception e ) { log . error ( str_ , e ) ; websocketimpl . getwebsocketlistener ( ) . onwebsocketerror ( websocketimpl , e ) ; }	Log the runtime exception to the specific WebSocketImpl.
private void processframetext ( websocketimpl websocketimpl , framedata frame ) throws invaliddataexception { try { websocketimpl . getwebsocketlistener ( ) . onwebsocketmessage ( websocketimpl , charsetfunctions . stringutf8 ( frame . getpayloaddata ( ) ) ) ; } catch ( runtimeexception e ) { logruntimeexception ( websocketimpl , e ) ; } }	Process the frame if it is a text frame.
private void processframeisfin ( websocketimpl websocketimpl , framedata frame ) throws invaliddataexception { if ( currentcontinuousframe == null ) { log . trace ( str_ ) ; throw new invaliddataexception ( closeframe . protocol_error , str_ ) ; } addtobufferlist ( frame . getpayloaddata ( ) ) ; checkbufferlimit ( ) ; if ( currentcontinuousframe . getopcode ( ) == opcode . text ) { ( ( framedataimpl1 ) currentcontinuousframe ) . setpayload ( getpayloadfrombytebufferlist ( ) ) ; ( ( framedataimpl1 ) currentcontinuousframe ) . isvalid ( ) ; try { websocketimpl . getwebsocketlistener ( ) . onwebsocketmessage ( websocketimpl , charsetfunctions . stringutf8 ( currentcontinuousframe . getpayloaddata ( ) ) ) ; } catch ( runtimeexception e ) { logruntimeexception ( websocketimpl , e ) ; } } else if ( currentcontinuousframe . getopcode ( ) == opcode . binary ) { ( ( framedataimpl1 ) currentcontinuousframe ) . setpayload ( getpayloadfrombytebufferlist ( ) ) ; ( ( framedataimpl1 ) currentcontinuousframe ) . isvalid ( ) ; try { websocketimpl . getwebsocketlistener ( ) . onwebsocketmessage ( websocketimpl , currentcontinuousframe . getpayloaddata ( ) ) ; } catch ( runtimeexception e ) { logruntimeexception ( websocketimpl , e ) ; } } currentcontinuousframe = null ; clearbufferlist ( ) ; }	Process the frame if it is the last frame.
private void processframeisnotfin ( framedata frame ) throws invaliddataexception { if ( currentcontinuousframe != null ) { log . trace ( str_ ) ; throw new invaliddataexception ( closeframe . protocol_error , str_ ) ; } currentcontinuousframe = frame ; addtobufferlist ( frame . getpayloaddata ( ) ) ; checkbufferlimit ( ) ; }	Process the frame if it is not the last frame.
private void processframeclosing ( websocketimpl websocketimpl , framedata frame ) { int code = closeframe . nocode ; string reason = str_ ; if ( frame instanceof closeframe ) { closeframe cf = ( closeframe ) frame ; code = cf . getclosecode ( ) ; reason = cf . getmessage ( ) ; } if ( websocketimpl . getreadystate ( ) == readystate . closing ) {	Process the frame if it is a closing frame.
private void checkbufferlimit ( ) throws limitexceededexception { long totalsize = getbytebufferlistsize ( ) ; if ( totalsize > maxframesize ) { clearbufferlist ( ) ; log . trace ( str_ , maxframesize , totalsize ) ; throw new limitexceededexception ( maxframesize ) ; } }	Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size.
private bytebuffer getpayloadfrombytebufferlist ( ) throws limitexceededexception { long totalsize = num_ ; bytebuffer resultingbytebuffer ; synchronized ( bytebufferlist ) { for ( bytebuffer buffer : bytebufferlist ) { totalsize += buffer . limit ( ) ; } checkbufferlimit ( ) ; resultingbytebuffer = bytebuffer . allocate ( ( int ) totalsize ) ; for ( bytebuffer buffer : bytebufferlist ) { resultingbytebuffer . put ( buffer ) ; } } resultingbytebuffer . flip ( ) ; return resultingbytebuffer ; }	Method to generate a full bytebuffer out of all the fragmented frame payload.
private long getbytebufferlistsize ( ) { long totalsize = num_ ; synchronized ( bytebufferlist ) { for ( bytebuffer buffer : bytebufferlist ) { totalsize += buffer . limit ( ) ; } } return totalsize ; }	Get the current size of the resulting bytebuffer in the bytebuffer list.
private static handshakebuilder translatehandshakehttpserver ( string [ ] firstlinetokens , string line ) throws invalidhandshakeexception {	Checking the handshake for the role as server.
private static handshakebuilder translatehandshakehttpclient ( string [ ] firstlinetokens , string line ) throws invalidhandshakeexception {	Checking the handshake for the role as client.
public void decode ( bytebuffer socketbuffer ) { assert ( socketbuffer . hasremaining ( ) ) ; log . trace ( str_ , socketbuffer . remaining ( ) , ( socketbuffer . remaining ( ) > num_ ? str_ : new string ( socketbuffer . array ( ) , socketbuffer . position ( ) , socketbuffer . remaining ( ) ) ) ) ; if ( readystate != readystate . not_yet_connected ) { if ( readystate == readystate . open ) { decodeframes ( socketbuffer ) ; } } else { if ( decodehandshake ( socketbuffer ) && ( ! isclosing ( ) && ! isclosed ( ) ) ) { assert ( tmphandshakebytes . hasremaining ( ) != socketbuffer . hasremaining ( ) || ! socketbuffer . hasremaining ( ) ) ;	Method to decode the provided ByteBuffer.
private void closeconnectionduetowronghandshake ( invaliddataexception exception ) { write ( generatehttpresponseduetoerror ( num_ ) ) ; flushandclose ( exception . getclosecode ( ) , exception . getmessage ( ) , bool_ ) ; }	Close the connection if the received handshake was not correct.
private void closeconnectionduetointernalservererror ( runtimeexception exception ) { write ( generatehttpresponseduetoerror ( num_ ) ) ; flushandclose ( closeframe . never_connected , exception . getmessage ( ) , bool_ ) ; }	Close the connection if there was a server error by a RuntimeException.
private bytebuffer generatehttpresponseduetoerror ( int errorcode ) { string errorcodedescription ; switch ( errorcode ) { case num_ : errorcodedescription = str_ ; break ; case num_ : default : errorcodedescription = str_ ; } return bytebuffer . wrap ( charsetfunctions . asciibytes ( str_ + errorcodedescription + str_ + ( num_ + errorcodedescription . length ( ) ) + str_ + errorcodedescription + str_ ) ) ; }	Generate a simple response for the corresponding endpoint to indicate some error.
@ override public void send ( string text ) { if ( text == null ) throw new illegalargumentexception ( str_ ) ; send ( draft . createframes ( text , role == role . client ) ) ; }	Send Text data to the other end.
private void reset ( ) { thread current = thread . currentthread ( ) ; if ( current == writethread || current == connectreadthread ) { throw new illegalstateexception ( str_ ) ; } try { closeblocking ( ) ; if ( writethread != null ) { this . writethread . interrupt ( ) ; this . writethread = null ; } if ( connectreadthread != null ) { this . connectreadthread . interrupt ( ) ; this . connectreadthread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( exception e ) { onerror ( e ) ; engine . closeconnection ( closeframe . abnormal_close , e . getmessage ( ) ) ; return ; } connectlatch = new countdownlatch ( num_ ) ; closelatch = new countdownlatch ( num_ ) ; this . engine = new websocketimpl ( this , this . draft ) ; }	Reset everything relevant to allow a reconnect.
public void connect ( ) { if ( connectreadthread != null ) throw new illegalstateexception ( str_ ) ; connectreadthread = new thread ( this ) ; connectreadthread . setname ( str_ + connectreadthread . getid ( ) ) ; connectreadthread . start ( ) ; }	Initiates the websocket connection.
private int getport ( ) { int port = uri . getport ( ) ; if ( port == - num_ ) { string scheme = uri . getscheme ( ) ; if ( str_ . equals ( scheme ) ) { return websocketimpl . default_wss_port ; } else if ( str_ . equals ( scheme ) ) { return websocketimpl . default_port ; } else { throw new illegalargumentexception ( str_ + scheme ) ; } } return port ; }	Extract the specified port.
private void sendhandshake ( ) throws invalidhandshakeexception { string path ; string part1 = uri . getrawpath ( ) ; string part2 = uri . getrawquery ( ) ; if ( part1 == null || part1 . length ( ) == num_ ) path = str_ ; else path = part1 ; if ( part2 != null ) path += str_ + part2 ; int port = getport ( ) ; string host = uri . gethost ( ) + ( ( port != websocketimpl . default_port && port != websocketimpl . default_wss_port ) ? str_ + port : str_ ) ; handshakeimpl1client handshake = new handshakeimpl1client ( ) ; handshake . setresourcedescriptor ( path ) ; handshake . put ( str_ , host ) ; if ( headers != null ) { for ( map . entry < string , string > kv : headers . entryset ( ) ) { handshake . put ( kv . getkey ( ) , kv . getvalue ( ) ) ; } } engine . starthandshake ( handshake ) ; }	Create and send the handshake to the other endpoint.
public void setconnectionlosttimeout ( int connectionlosttimeout ) { synchronized ( syncconnectionlost ) { this . connectionlosttimeout = timeunit . seconds . tonanos ( connectionlosttimeout ) ; if ( this . connectionlosttimeout <= num_ ) { log . trace ( str_ ) ; cancelconnectionlosttimer ( ) ; return ; } if ( this . websocketrunning ) { log . trace ( str_ ) ;	Setter for the interval checking for lost connectionsA value lower or equal 0 results in the check to be deactivated.
protected void stopconnectionlosttimer ( ) { synchronized ( syncconnectionlost ) { if ( connectionlostcheckerservice != null || connectionlostcheckerfuture != null ) { this . websocketrunning = bool_ ; log . trace ( str_ ) ; cancelconnectionlosttimer ( ) ; } } }	Stop the connection lost timer.
protected void startconnectionlosttimer ( ) { synchronized ( syncconnectionlost ) { if ( this . connectionlosttimeout <= num_ ) { log . trace ( str_ ) ; return ; } log . trace ( str_ ) ; this . websocketrunning = bool_ ; restartconnectionlosttimer ( ) ; } }	Start the connection lost timer.
private void restartconnectionlosttimer ( ) { cancelconnectionlosttimer ( ) ; connectionlostcheckerservice = executors . newsinglethreadscheduledexecutor ( new namedthreadfactory ( str_ ) ) ; runnable connectionlostchecker = new runnable ( ) { private arraylist < websocket > connections = new arraylist < websocket > ( ) ; @ override public void run ( ) { connections . clear ( ) ; try { connections . addall ( getconnections ( ) ) ; long minimumpongtime = ( long ) ( system . nanotime ( ) - ( connectionlosttimeout * num_ ) ) ; for ( websocket conn : connections ) { executeconnectionlostdetection ( conn , minimumpongtime ) ; } } catch ( exception e ) {	This methods allows the reset of the connection lost timer in case of a changed parameter.
private void executeconnectionlostdetection ( websocket websocket , long minimumpongtime ) { if ( ! ( websocket instanceof websocketimpl ) ) { return ; } websocketimpl websocketimpl = ( websocketimpl ) websocket ; if ( websocketimpl . getlastpong ( ) < minimumpongtime ) { log . trace ( str_ , websocketimpl ) ; websocketimpl . closeconnection ( closeframe . abnormal_close , str_ ) ; } else { if ( websocketimpl . isopen ( ) ) { websocketimpl . sendping ( ) ; } else { log . trace ( str_ , websocketimpl ) ; } } }	Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping.
private void cancelconnectionlosttimer ( ) { if ( connectionlostcheckerservice != null ) { connectionlostcheckerservice . shutdownnow ( ) ; connectionlostcheckerservice = null ; } if ( connectionlostcheckerfuture != null ) { connectionlostcheckerfuture . cancel ( bool_ ) ; connectionlostcheckerfuture = null ; } }	Cancel any running timer for the connection lost detection.
@ override public serverhandshakebuilder onwebsockethandshakereceivedasserver ( websocket conn , draft draft , clienthandshake request ) throws invaliddataexception { return new handshakeimpl1server ( ) ; }	This default implementation does not do anything.
@ override public void onwebsocketping ( websocket conn , framedata f ) { conn . sendframe ( new pongframe ( ( pingframe ) f ) ) ; }	This default implementation will send a pong in response to the received ping.The pong frame will have the same payload as the ping frame.
public void stop ( int timeout ) throws interruptedexception { if ( ! isclosed . compareandset ( bool_ , bool_ ) ) {	Closes all connected clients sockets, then closes the underlyingServerSocketChannel, effectively killing the server socket selectorthread,freeing the port the server was bound to and stops all internal workerthreads.If this method is called before the server is started it will never start.
public int getport ( ) { int port = getaddress ( ) . getport ( ) ; if ( port == num_ && server != null ) { port = server . socket ( ) . getlocalport ( ) ; } return port ; }	Gets the port number that this server listens on.
private void doadditionalread ( ) throws interruptedexception , ioexception { websocketimpl conn ; while ( ! iqueue . isempty ( ) ) { conn = iqueue . remove ( num_ ) ; wrappedbytechannel c = ( ( wrappedbytechannel ) conn . getchannel ( ) ) ; bytebuffer buf = takebuffer ( ) ; try { if ( socketchanneliohelper . readmore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasremaining ( ) ) { conn . inqueue . put ( buf ) ; queue ( conn ) ; } else { pushbuffer ( buf ) ; } } catch ( ioexception e ) { pushbuffer ( buf ) ; throw e ; } } }	Do an additional read.
private void doaccept ( selectionkey key , iterator < selectionkey > i ) throws ioexception , interruptedexception { if ( ! onconnect ( key ) ) { key . cancel ( ) ; return ; } socketchannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureblocking ( bool_ ) ; socket socket = channel . socket ( ) ; socket . settcpnodelay ( istcpnodelay ( ) ) ; socket . setkeepalive ( bool_ ) ; websocketimpl w = wsf . createwebsocket ( this , drafts ) ; w . setselectionkey ( channel . register ( selector , selectionkey . op_read , w ) ) ; try { w . setchannel ( wsf . wrapchannel ( channel , w . getselectionkey ( ) ) ) ; i . remove ( ) ; allocatebuffers ( w ) ; } catch ( ioexception ex ) { if ( w . getselectionkey ( ) != null ) w . getselectionkey ( ) . cancel ( ) ; handleioexception ( w . getselectionkey ( ) , null , ex ) ; } }	Execute a accept operation.
private boolean doread ( selectionkey key , iterator < selectionkey > i ) throws interruptedexception , ioexception { websocketimpl conn = ( websocketimpl ) key . attachment ( ) ; bytebuffer buf = takebuffer ( ) ; if ( conn . getchannel ( ) == null ) { key . cancel ( ) ; handleioexception ( key , conn , new ioexception ( ) ) ; return bool_ ; } try { if ( socketchanneliohelper . read ( buf , conn , conn . getchannel ( ) ) ) { if ( buf . hasremaining ( ) ) { conn . inqueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getchannel ( ) instanceof wrappedbytechannel && ( ( wrappedbytechannel ) conn . getchannel ( ) ) . isneedread ( ) ) { iqueue . add ( conn ) ; } } else { pushbuffer ( buf ) ; } } else { pushbuffer ( buf ) ; } } catch ( ioexception e ) { pushbuffer ( buf ) ; throw e ; } return bool_ ; }	Execute a read operation.
private void dowrite ( selectionkey key ) throws ioexception { websocketimpl conn = ( websocketimpl ) key . attachment ( ) ; if ( socketchanneliohelper . batch ( conn , conn . getchannel ( ) ) ) { if ( key . isvalid ( ) ) { key . interestops ( selectionkey . op_read ) ; } } }	Execute a write operation.
private boolean dosetupselectorandserverthread ( ) { selectorthread . setname ( str_ + selectorthread . getid ( ) ) ; try { server = serversocketchannel . open ( ) ; server . configureblocking ( bool_ ) ; serversocket socket = server . socket ( ) ; socket . setreceivebuffersize ( websocketimpl . rcvbuf ) ; socket . setreuseaddress ( isreuseaddr ( ) ) ; socket . bind ( address ) ; selector = selector . open ( ) ; server . register ( selector , server . validops ( ) ) ; startconnectionlosttimer ( ) ; for ( websocketworker ex : decoders ) { ex . start ( ) ; } onstart ( ) ; } catch ( ioexception ex ) { handlefatal ( null , ex ) ; return bool_ ; } return bool_ ; }	Setup the selector thread as well as basic server settings.
private boolean doensuresinglethread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new illegalstateexception ( getclass ( ) . getname ( ) + str_ ) ; selectorthread = thread . currentthread ( ) ; if ( isclosed . get ( ) ) { return bool_ ; } } return bool_ ; }	The websocket server can only be started once.
private void doservershutdown ( ) { stopconnectionlosttimer ( ) ; if ( decoders != null ) { for ( websocketworker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( ioexception e ) { log . error ( str_ , e ) ; onerror ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( ioexception e ) { log . error ( str_ , e ) ; onerror ( null , e ) ; } } }	Clean up everything after a shutdown.
private socket getsocket ( websocket conn ) { websocketimpl impl = ( websocketimpl ) conn ; return ( ( socketchannel ) impl . getselectionkey ( ) . channel ( ) ) . socket ( ) ; }	Getter to return the socket used by this specific connection.
public void broadcast ( byte [ ] data , collection < websocket > clients ) { if ( data == null || clients == null ) { throw new illegalargumentexception ( ) ; } broadcast ( bytebuffer . wrap ( data ) , clients ) ; }	Send a byte array to a specific collection of websocket connections.
public void broadcast ( string text , collection < websocket > clients ) { if ( text == null || clients == null ) { throw new illegalargumentexception ( ) ; } dobroadcast ( text , clients ) ; }	Send a text to a specific collection of websocket connections.
private void dobroadcast ( object data , collection < websocket > clients ) { string sdata = null ; if ( data instanceof string ) { sdata = ( string ) data ; } bytebuffer bdata = null ; if ( data instanceof bytebuffer ) { bdata = ( bytebuffer ) data ; } if ( sdata == null && bdata == null ) { return ; } map < draft , list < framedata > > draftframes = new hashmap < draft , list < framedata > > ( ) ; for ( websocket client : clients ) { if ( client != null ) { draft draft = client . getdraft ( ) ; fillframes ( draft , draftframes , sdata , bdata ) ; try { client . sendframe ( draftframes . get ( draft ) ) ; } catch ( websocketnotconnectedexception e ) {	Private method to cache all the frames to improve memory footprint and conversion time.
private void fillframes ( draft draft , map < draft , list < framedata > > draftframes , string sdata , bytebuffer bdata ) { if ( ! draftframes . containskey ( draft ) ) { list < framedata > frames = null ; if ( sdata != null ) { frames = draft . createframes ( sdata , bool_ ) ; } if ( bdata != null ) { frames = draft . createframes ( bdata , bool_ ) ; } if ( frames != null ) { draftframes . put ( draft , frames ) ; } } }	Fills the draftFrames with new data for the broadcast.
public static int transferbytebuffer ( bytebuffer source , bytebuffer dest ) { if ( source == null || dest == null ) { throw new illegalargumentexception ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }	Transfer from one ByteBuffer to another ByteBuffer.
public jpaapi start ( ) { jpaconfig . persistenceunits ( ) . foreach ( persistenceunit -> emfs . put ( persistenceunit . name , persistence . createentitymanagerfactory ( persistenceunit . unitname ) ) ) ; return this ; }	Initialise JPA entity manager factories.
public entitymanager em ( string name ) { entitymanagerfactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createentitymanager ( ) ; }	Get a newly created EntityManager for the specified persistence unit name.
public void withtransaction ( consumer < entitymanager > block ) { withtransaction ( em -> { block . accept ( em ) ; return null ; } ) ; }	Run a block of code with a newly created EntityManager for the default Persistence Unit.
private static seq < object > convertargstoscalabuffer ( final object ... args ) { return scala . collection . javaconverters . asscalabufferconverter ( wrapargstolistifneeded ( args ) ) . asscala ( ) . tolist ( ) ; }	Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate listif necessary.
@ safevarargs private static < t > list < t > wrapargstolistifneeded ( final t ... args ) { list < t > out ; if ( args != null && args . length == num_ && args [ num_ ] instanceof list ) { out = ( list < t > ) args [ num_ ] ; } else { out = arrays . aslist ( args ) ; } return out ; }	Wraps arguments passed into a list if necessary.
public string get ( play . api . i18n . lang lang , string key , object ... args ) { seq < object > scalaargs = convertargstoscalabuffer ( args ) ; return messages . apply ( key , scalaargs , lang ) ; }	Translates a message. Uses `java.text.MessageFormat` internally to format the message.
public string get ( play . api . i18n . lang lang , list < string > keys , object ... args ) { buffer < string > keyargs = scala . collection . javaconverters . asscalabufferconverter ( keys ) . asscala ( ) ; seq < object > scalaargs = convertargstoscalabuffer ( args ) ; return messages . apply ( keyargs . toseq ( ) , scalaargs , lang ) ; }	Translates the first defined message.
public boolean isdefinedat ( play . api . i18n . lang lang , string key ) { return messages . isdefinedat ( key , lang ) ; }	Check if a message key is defined.
public messages preferred ( collection < lang > candidates ) { seq < lang > cs = scala . asscala ( candidates ) ; play . api . i18n . messages msgs = messages . preferred ( ( seq ) cs ) ; return new messagesimpl ( new lang ( msgs . lang ( ) ) , this ) ; }	Get a messages context appropriate for the given candidates.
public messages preferred ( http . requestheader request ) { play . api . i18n . messages msgs = messages . preferred ( request ) ; return new messagesimpl ( new lang ( msgs . lang ( ) ) , this ) ; }	Get a messages context appropriate for the given request.
public result setlang ( result result , lang lang ) { return messages . setlang ( result . asscala ( ) , lang ) . asjava ( ) ; }	Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.
public final self bindings ( guiceablemodule ... modules ) { return newbuilder ( delegate . bindings ( scala . varargs ( modules ) ) ) ; }	Add bindings from guiceable modules.
public final self bindings ( play . api . inject . module ... modules ) { return bindings ( guiceable . modules ( modules ) ) ; }	Add bindings from Play modules.
public final self bindings ( play . api . inject . binding < ? > ... bindings ) { return bindings ( guiceable . bindings ( bindings ) ) ; }	Add Play bindings.
public final self overrides ( guiceablemodule ... modules ) { return newbuilder ( delegate . overrides ( scala . varargs ( modules ) ) ) ; }	Override bindings using guiceable modules.
public final self overrides ( play . api . inject . module ... modules ) { return overrides ( guiceable . modules ( modules ) ) ; }	Override bindings using Play modules.
public final self overrides ( play . api . inject . binding < ? > ... bindings ) { return overrides ( guiceable . bindings ( bindings ) ) ; }	Override bindings using Play bindings.
public final self disable ( class < ? > ... moduleclasses ) { return newbuilder ( delegate . disable ( scala . toseq ( moduleclasses ) ) ) ; }	Disable modules by class.
public completionstage < result > call ( request req ) {	Executes this action with the given HTTP request and returns the result.
public optional < file > getexistingfile ( string relativepath ) { return optionconverters . tojava ( env . getexistingfile ( relativepath ) ) ; }	Retrieves a file relative to the application root path.
public < a extends annotation > binding < t > in ( final class < a > scope ) { return underlying . in ( scope ) . asjava ( ) ; }	Configure the scope for this binding.
public static < a , b > tuple < a , b > tuple ( a a , b b ) { return new tuple < a , b > ( a , b ) ; }	Constructs a tuple of A,B.
public static < a , b , c , d , e > tuple5 < a , b , c , d , e > tuple5 ( a a , b b , c c , d d , e e ) { return new tuple5 < a , b , c , d , e > ( a , b , c , d , e ) ; }	Constructs a tuple of A,B,C,D,E.
private static executor toexecutor ( executioncontext ec ) { executioncontext prepared = ec . prepare ( ) ; if ( prepared instanceof executor ) { return ( executor ) prepared ; } else { return prepared :: execute ; } }	Converts the execution context to an executor, preparing it first.
public static jpaconfig of ( string name , string unitname ) { return new defaultjpaconfig ( new jpaconfig . persistenceunit ( name , unitname ) ) ; }	Create a default JPA configuration with the given name and unit name.
public static jpaconfig of ( string n1 , string u1 , string n2 , string u2 ) { return new defaultjpaconfig ( new jpaconfig . persistenceunit ( n1 , u1 ) , new jpaconfig . persistenceunit ( n2 , u2 ) ) ; }	Create a default JPA configuration with the given names and unit names.
public static jpaconfig from ( map < string , string > map ) { immutableset . builder < jpaconfig . persistenceunit > persistenceunits = new immutableset . builder < jpaconfig . persistenceunit > ( ) ; for ( map . entry < string , string > entry : map . entryset ( ) ) { persistenceunits . add ( new jpaconfig . persistenceunit ( entry . getkey ( ) , entry . getvalue ( ) ) ) ; } return new defaultjpaconfig ( persistenceunits . build ( ) ) ; }	Create a default JPA configuration from a map of names to unit names.
public static flow < string , bytestring , notused > string ( string callbackname ) { return flow . of ( string . class ) . map ( str -> { return bytestring . fromstring ( str_ + stringescapeutils . escapeecmascript ( str ) + str_ ) ; } ) . via ( flow ( callbackname ) ) ; }	Produces a Flow of escaped ByteString from a series of String elements.
public static flow < jsonnode , bytestring , notused > json ( string callbackname ) { return flow . of ( jsonnode . class ) . map ( json -> { return bytestring . fromstring ( json . stringify ( json ) ) ; } ) . via ( flow ( callbackname ) ) ; }	Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode.
public < t extends constraintvalidator < ? , ? > > mappedconstraintvalidatorfactory addconstraintvalidator ( class < t > key , t constraintvalidator ) { validators . put ( key , ( ) -> constraintvalidator ) ; return this ; }	Adds validator as a singleton.
private < t extends constraintvalidator < ? , ? > > t newinstance ( class < t > key ) { try { return key . getdeclaredconstructor ( ) . newinstance ( ) ; } catch ( instantiationexception | runtimeexception | illegalaccessexception | nosuchmethodexception | invocationtargetexception ex ) { throw new runtimeexception ( ex ) ; } }	need to do so.
public static method getmatchingaccessiblemethod ( final class < ? > cls , final string methodname , final class < ? > ... parametertypes ) { try { final method method = cls . getmethod ( methodname , parametertypes ) ; memberutils . setaccessibleworkaround ( method ) ; return method ; } catch ( final nosuchmethodexception e ) {	Finds an accessible method that matches the given name and has compatible parameters.Compatible parameters mean that every method parameter is assignable from the given parameters.In other words, it finds a method with the given name that will take the parameters given.
@ override public completionstage < result > onclienterror ( requestheader request , int statuscode , string message ) { if ( statuscode == num_ ) { return onbadrequest ( request , message ) ; } else if ( statuscode == num_ ) { return onforbidden ( request , message ) ; } else if ( statuscode == num_ ) { return onnotfound ( request , message ) ; } else if ( statuscode >= num_ && statuscode < num_ ) { return onotherclienterror ( request , statuscode , message ) ; } else { throw new illegalargumentexception ( str_ + statuscode + str_ + message ) ; } }	Invoked when a client error occurs, that is, an error in the 4xx series.
protected completionstage < result > onbadrequest ( requestheader request , string message ) { return completablefuture . completedfuture ( results . badrequest ( views . html . defaultpages . badrequest . render ( request . method ( ) , request . uri ( ) , message , request . asscala ( ) ) ) ) ; }	Invoked when a client makes a bad request.
protected completionstage < result > onforbidden ( requestheader request , string message ) { return completablefuture . completedfuture ( results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asscala ( ) ) ) ) ; }	Invoked when a client makes a request that was forbidden.
protected completionstage < result > onnotfound ( requestheader request , string message ) { if ( environment . isprod ( ) ) { return completablefuture . completedfuture ( results . notfound ( views . html . defaultpages . notfound . render ( request . method ( ) , request . uri ( ) , request . asscala ( ) ) ) ) ; } else { return completablefuture . completedfuture ( results . notfound ( views . html . defaultpages . devnotfound . render ( request . method ( ) , request . uri ( ) , some . apply ( routes . get ( ) ) , request . asscala ( ) ) ) ) ; } }	Invoked when a handler or resource is not found.
@ override public completionstage < result > onservererror ( requestheader request , throwable exception ) { try { usefulexception usefulexception = throwabletousefulexception ( exception ) ; logservererror ( request , usefulexception ) ; switch ( environment . mode ( ) ) { case prod : return onprodservererror ( request , usefulexception ) ; default : return ondevservererror ( request , usefulexception ) ; } } catch ( exception e ) { logger . error ( str_ , e ) ; return completablefuture . completedfuture ( results . internalservererror ( ) ) ; } }	Invoked when a server error occurs.
protected void logservererror ( requestheader request , usefulexception usefulexception ) { logger . error ( string . format ( str_ , usefulexception . id , request . method ( ) , request . uri ( ) ) , usefulexception ) ; }	Responsible for logging server errors.
protected final usefulexception throwabletousefulexception ( final throwable throwable ) { return httperrorhandlerexceptions . throwabletousefulexception ( sourcemapper . sourcemapper ( ) , environment . isprod ( ) , throwable ) ; }	Convert the given exception to an exception that Play can report more information about.
protected completionstage < result > ondevservererror ( requestheader request , usefulexception exception ) { return completablefuture . completedfuture ( results . internalservererror ( views . html . defaultpages . deverror . render ( playeditor , exception , request . asscala ( ) ) ) ) ; }	Invoked in dev mode when a server error occurs.
protected completionstage < result > onprodservererror ( requestheader request , usefulexception exception ) { return completablefuture . completedfuture ( results . internalservererror ( views . html . defaultpages . error . render ( exception , request . asscala ( ) ) ) ) ; }	Invoked in prod mode when a server error occurs. The base implementation returns {.
public static builddochandler fromresources ( file [ ] files , string [ ] basedirs ) throws ioexception { assert ( files . length == basedirs . length ) ; filerepository [ ] repositories = new filerepository [ files . length ] ; list < jarfile > jarfiles = new arraylist < > ( ) ; for ( int i = num_ ; i < files . length ; i ++ ) { file file = files [ i ] ; string basedir = basedirs [ i ] ; if ( file . isdirectory ( ) ) { repositories [ i ] = new filesystemrepository ( file ) ; } else {	Create a BuildDocHandler that serves documentation from the given files, which could either bedirectories or jar files.
public static builddochandler fromdirectory ( file directory ) { filerepository repo = new filesystemrepository ( directory ) ; return new documentationhandler ( repo ) ; }	Create an BuildDocHandler that serves documentation from a given directory by wrapping aFilesystemRepository.
public static builddochandler fromdirectoryandjar ( file directory , jarfile jarfile , string base ) { return fromdirectoryandjar ( directory , jarfile , base , bool_ ) ; }	Create an BuildDocHandler that serves the manual from a given directory by wrapping aFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.
public static builddochandler fromdirectoryandjar ( file directory , jarfile jarfile , string base , boolean fallbacktojar ) { filerepository filerepo = new filesystemrepository ( directory ) ; filerepository jarrepo = new jarrepository ( jarfile , option . apply ( base ) ) ; filerepository manualrepo ; if ( fallbacktojar ) { manualrepo = new aggregatefilerepository ( new filerepository [ ] { filerepo , jarrepo } ) ; } else { manualrepo = filerepo ; } return new documentationhandler ( manualrepo , jarrepo ) ; }	Create an BuildDocHandler that serves the manual from a given directory by wrapping aFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.
public static builddochandler fromjar ( jarfile jarfile , string base ) { filerepository repo = new jarrepository ( jarfile , option . apply ( base ) ) ; return new documentationhandler ( repo ) ; }	Create an BuildDocHandler that serves documentation from a given JAR file by wrapping aJarRepository.
public completionstage < bytestring > consumedata ( materializer mat ) { return datastream ( ) . runfold ( bytestring . empty ( ) , bytestring :: concat , mat ) ; }	Consumes the data. This method should be used carefully, since if the source represents an ephemeral stream,then the entity may not be usable after this method is invoked.
public static final httpentity fromcontent ( content content , string charset ) { string body ; if ( content instanceof xml ) {	Create an entity from the given content.
public static final httpentity fromstring ( string content , string charset ) { return new strict ( bytestring . fromstring ( content , charset ) , optional . of ( str_ + charset ) ) ; }	Create an entity from the given String.
public static final httpentity chunked ( source < bytestring , ? > data , optional < string > contenttype ) { return new chunked ( data . map ( httpchunk . chunk :: new ) , contenttype ) ; }	Convert the given source of ByteStrings to a chunked entity.
public static result status ( int status , jsonnode content ) { return status ( status , content , jsonencoding . utf8 ) ; }	Generates a simple result with json content and UTF8 encoding.
public static result status ( int status , jsonnode content , jsonencoding encoding ) { if ( content == null ) { throw new nullpointerexception ( str_ ) ; } return status ( status ) . sendjson ( content , encoding ) ; }	Generates a simple result with json content.
public static result status ( int status , byte [ ] content ) { if ( content == null ) { throw new nullpointerexception ( str_ ) ; } return new result ( status , new httpentity . strict ( bytestring . fromarray ( content ) , optional . empty ( ) ) ) ; }	Generates a simple result with byte-array content.
public static result status ( int status , inputstream content , long contentlength ) { return status ( status ) . sendinputstream ( content , contentlength ) ; }	Generates a chunked result.
public static result status ( int status , file content ) { return status ( status , content , staticfilemimetypes . filemimetypes ( ) ) ; }	Generates a result with file contents.
private user findbyid ( long id ) { if ( id > num_ ) return null ; user user = new user ( ) ; user . id = id ; user . name = str_ + string . valueof ( id ) ; return user ; }	designed to be lightweight operation.
public lang preferred ( collection < lang > candidates ) { return new lang ( langs . preferred ( ( scala . collection . immutable . seq ) scala . asscala ( candidates ) . toseq ( ) ) ) ; }	Select a preferred language, given the list of candidates.
public call unique ( ) { return new play . api . mvc . call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }	Append a unique identifier to the URL.
public call withfragment ( string fragment ) { return new play . api . mvc . call ( method ( ) , url ( ) , fragment ) ; }	Returns a new Call with the given fragment.
public string absoluteurl ( http . request request ) { return absoluteurl ( request . secure ( ) , request . host ( ) ) ; }	Transform this call to an absolute URL.
public string websocketurl ( http . request request ) { return websocketurl ( request . secure ( ) , request . host ( ) ) ; }	Transform this call to an WebSocket URL.
abstractfunction1 < connection , boxedunit > connectionfunction ( final connectionrunnable block ) { return new abstractfunction1 < connection , boxedunit > ( ) { public boxedunit apply ( connection connection ) { try { block . run ( connection ) ; return boxedunit . unit ; } catch ( java . sql . sqlexception e ) { throw new runtimeexception ( str_ , e ) ; } } } ; }	Create a Scala function wrapper for ConnectionRunnable.
< a > abstractfunction1 < connection , a > connectionfunction ( final connectioncallable < a > block ) { return new abstractfunction1 < connection , a > ( ) { public a apply ( connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . sqlexception e ) { throw new runtimeexception ( str_ , e ) ; } } } ; }	Create a Scala function wrapper for ConnectionCallable.
public static server forrouter ( mode mode , int port , function < builtincomponents , router > block ) { return new builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }	Create a server for the router returned by the given block.
public static jsonnode tojson ( final object data ) { try { return mapper ( ) . valuetotree ( data ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Converts an object to JsonNode.
public static < a > a fromjson ( jsonnode json , class < a > clazz ) { try { return mapper ( ) . treetovalue ( json , clazz ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Converts a JsonNode to a Java value.
public static jsonnode parse ( string src ) { try { return mapper ( ) . readtree ( src ) ; } catch ( throwable t ) { throw new runtimeexception ( t ) ; } }	Parses a String representing a json, and return it as a JsonNode.
public static jsonnode parse ( java . io . inputstream src ) { try { return mapper ( ) . readtree ( src ) ; } catch ( throwable t ) { throw new runtimeexception ( t ) ; } }	Parses a InputStream representing a json, and return it as a JsonNode.
public static string relative ( string startpath , string targetpath ) {	Create a path to targetPath that's relative to the given startPath.
public static string canonical ( string url ) { string [ ] urlpath = tosegments ( url ) ; stack < string > canonical = new stack < > ( ) ; for ( string comp : urlpath ) { if ( comp . isempty ( ) || comp . equals ( current_dir ) ) continue ; if ( ! comp . equals ( parent_dir ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( parent_dir ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } string prefixsep = url . startswith ( separator ) ? separator : str_ ; string trailingsep = url . endswith ( separator ) ? separator : str_ ; return prefixsep + canonical . stream ( ) . collect ( collectors . joining ( separator ) ) + trailingsep ; }	Create a canonical path that does not contain parent directories, current directories, orsuperfluous directory separators.
public static list < tuple < string , list < object > > > displayableconstraint ( set < constraintdescriptor < ? > > constraints ) { return constraints . parallelstream ( ) . filter ( c -> c . getannotation ( ) . annotationtype ( ) . isannotationpresent ( display . class ) ) . map ( c -> displayableconstraint ( c ) ) . collect ( collectors . tolist ( ) ) ; }	Converts a set of constraints to human-readable values.
public static tuple < string , list < object > > displayableconstraint ( constraintdescriptor < ? > constraint ) { final display displayannotation = constraint . getannotation ( ) . annotationtype ( ) . getannotation ( display . class ) ; return tuple ( displayannotation . name ( ) , collections . unmodifiablelist ( stream . of ( displayannotation . attributes ( ) ) . map ( attr -> constraint . getattributes ( ) . get ( attr ) ) . collect ( collectors . tolist ( ) ) ) ) ; }	Converts a constraint to a human-readable value.
@ override public < a > completionstage < a > timeout ( final completionstage < a > stage , final long amount , final timeunit unit ) { requirenonnull ( stage , str_ ) ; requirenonnull ( unit , str_ ) ; finiteduration duration = finiteduration . apply ( amount , unit ) ; return tojava ( delegate . timeout ( duration , scala . asscalawithfuture ( ( ) -> stage ) ) ) ; }	Creates a CompletionStage that returns either the input stage, or a futures.
public static date parsecronexpression ( string cron ) { try { return new cronexpression ( cron ) . getnextvalidtimeafter ( new date ( ) ) ; } catch ( exception e ) { throw new illegalargumentexception ( str_ + cron , e ) ; } }	Parses a CRON expression.
public static long croninterval ( string cron , date date ) { try { return new cronexpression ( cron ) . getnextinterval ( date ) ; } catch ( exception e ) { throw new illegalargumentexception ( str_ + cron , e ) ; } }	Compute the number of milliseconds between the next valid date and the one after.
public static ahcwsclient create ( ahcwsclientconfig config , ahchttpcache cache , materializer materializer ) { final standaloneahcwsclient client = standaloneahcwsclient . create ( config , cache , materializer ) ; return new ahcwsclient ( client , materializer ) ; }	Creates WS client manually from configuration, internally creating a new instance ofAsyncHttpClient and managing its own thread pool.
public guiceapplicationbuilder builder ( applicationloader . context context ) { return initialbuilder . in ( context . environment ( ) ) . loadconfig ( context . initialconfig ( ) ) . overrides ( overrides ( context ) ) ; }	Construct a builder to use for loading the given context.
public static result todo ( request request ) { return status ( not_implemented , views . html . defaultpages . todo . render ( request . asscala ( ) ) ) ; }	Generates a 501 NOT_IMPLEMENTED simple result.
@ deprecated public static void session ( string key , string value ) { session ( ) . put ( key , value ) ; }	Puts a new value into the current session.
@ deprecated public static void flash ( string key , string value ) { flash ( ) . put ( key , value ) ; }	Puts a new value into the flash scope.
public < a extends annotation > bindingkey < t > qualifiedwith ( final a instance ) { return underlying . qualifiedwith ( instance ) . asjava ( ) ; }	Qualify this binding key with the given instance of an annotation.
public < a extends annotation > bindingkey < t > qualifiedwith ( final class < a > annotation ) { return underlying . qualifiedwith ( annotation ) . asjava ( ) ; }	Qualify this binding key with the given annotation.
public binding < t > to ( final class < ? extends t > implementation ) { return underlying . to ( implementation ) . asjava ( ) ; }	Bind this binding key to the given implementation class.
public binding < t > to ( final provider < ? extends t > provider ) { return underlying . to ( provider ) . asjava ( ) ; }	Bind this binding key to the given provider instance.
public < a extends t > binding < t > to ( final supplier < a > instance ) { return underlying . to ( new fromjavasupplier < > ( instance ) ) . asjava ( ) ; }	Bind this binding key to the given instance.
public binding < t > to ( final bindingkey < ? extends t > key ) { return underlying . to ( key . asscala ( ) ) . asjava ( ) ; }	Bind this binding key to another binding key.
public < p extends provider < ? extends t > > binding < t > toprovider ( final class < p > provider ) { return underlying . toprovider ( provider ) . asjava ( ) ; }	Bind this binding key to the given provider class.
public static list < lang > availables ( application app ) { play . api . i18n . langs langs = app . injector ( ) . instanceof ( play . api . i18n . langs . class ) ; list < play . api . i18n . lang > availablelangs = scala . asjava ( langs . availables ( ) ) ; return availablelangs . stream ( ) . map ( lang :: new ) . collect ( tolist ( ) ) ; }	Retrieve Lang availables from the application configuration.
public static lang preferred ( application app , list < lang > availablelangs ) { play . api . i18n . langs langs = app . injector ( ) . instanceof ( play . api . i18n . langs . class ) ; stream < lang > stream = availablelangs . stream ( ) ; list < play . api . i18n . lang > langseq = stream . map ( l -> new play . api . i18n . lang ( l . tolocale ( ) ) ) . collect ( tolist ( ) ) ; return new lang ( langs . preferred ( scala . toseq ( langseq ) ) ) ; }	Guess the preferred lang in the langs set passed as argument.
public static play . api . db . evolutions . evolutionsreader frommap ( map < string , list < evolution > > evolutions ) { return new simpleevolutionsreader ( evolutions ) ; }	Create an evolutions reader based on a simple map of database names to evolutions.
public static play . api . db . evolutions . evolutionsreader fordefault ( evolution ... evolutions ) { map < string , list < evolution > > map = new hashmap < string , list < evolution > > ( ) ; map . put ( str_ , arrays . aslist ( evolutions ) ) ; return frommap ( map ) ; }	Create an evolutions reader for the default database from a list of evolutions.
public static void cleanupevolutions ( database database , boolean autocommit , string schema ) { databaseevolutions evolutions = new databaseevolutions ( database . asscala ( ) , schema ) ; evolutions . evolve ( evolutions . resetscripts ( ) , autocommit ) ; }	Cleanup evolutions for the given database.
public guiceapplicationbuilder withconfigloader ( function < environment , config > load ) { return newbuilder ( delegate . loadconfig ( func ( ( play . api . environment env ) -> new play . api . configuration ( load . apply ( new environment ( env ) ) ) ) ) ) ; }	Set the initial configuration loader.
public guiceapplicationbuilder withmoduleloader ( bifunction < environment , config , list < guiceablemodule > > loader ) { return newbuilder ( delegate . load ( func ( ( play . api . environment env , play . api . configuration conf ) -> scala . toseq ( loader . apply ( new environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }	Set the module loader.
public guiceapplicationbuilder load ( guiceablemodule ... modules ) { return newbuilder ( delegate . load ( scala . varargs ( modules ) ) ) ; }	Override the module loader with the given guiceable modules.
public guiceapplicationbuilder load ( com . google . inject . module ... modules ) { return load ( guiceable . modules ( modules ) ) ; }	Override the module loader with the given Guice modules.
public guiceapplicationbuilder load ( play . api . inject . module ... modules ) { return load ( guiceable . modules ( modules ) ) ; }	Override the module loader with the given Play modules.
public guiceapplicationbuilder load ( play . api . inject . binding < ? > ... bindings ) { return load ( guiceable . bindings ( bindings ) ) ; }	Override the module loader with the given Play bindings.
protected guiceapplicationbuilder newbuilder ( play . api . inject . guice . guiceapplicationbuilder builder ) { return new guiceapplicationbuilder ( builder ) ; }	Implementation of Self creation for GuiceBuilder.
public string encode ( cookie cookie ) { if ( cookie == null ) { throw new nullpointerexception ( str_ ) ; } stringbuilder buf = new stringbuilder ( ) ; encode ( buf , cookie ) ; return striptrailingseparator ( buf ) ; }	Encodes the specified cookie into a Cookie header value.
public entitymanager em ( ) { deque < entitymanager > ems = this . emstack ( bool_ ) ; if ( ems . isempty ( ) ) { http . context . safecurrent ( ) . map ( ctx -> { throw new runtimeexception ( str_ ) ; } ) . orelseget ( ( ) -> { throw new runtimeexception ( str_ ) ; } ) ; } return ems . peekfirst ( ) ; }	Get the default EntityManager for this thread.
@ suppresswarnings ( str_ ) public deque < entitymanager > emstack ( boolean threadlocalfallback ) { return http . context . safecurrent ( ) . map ( context -> { object emsobject = context . args . get ( current_entity_manager ) ; if ( emsobject != null ) { return ( deque < entitymanager > ) emsobject ; } else { deque < entitymanager > ems = new arraydeque < > ( ) ; context . args . put ( current_entity_manager , ems ) ; return ems ; } } ) . orelseget ( ( ) -> {	Get the EntityManager stack.
void pushorpopem ( entitymanager em , boolean threadlocalfallback ) { deque < entitymanager > ems = this . emstack ( threadlocalfallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isempty ( ) ) { throw new illegalstateexception ( str_ ) ; } ems . pop ( ) ; } }	Pushes or pops the EntityManager stack depending on the value of the em argument.
public static < in , flowin , out > flow < in , out , ? > bypasswith ( function < in , f . either < flowin , out > > splitter , flow < flowin , out , ? > flow ) { return bypasswith ( flow . < in > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . akkastreams . onlyfirstcanfinishmerge ( num_ ) , flow ) ; }	Bypass the given flow using the given splitter function.
public static < in , flowin , out > flow < in , out , ? > bypasswith ( flow < in , f . either < flowin , out > , ? > splitter , graph < uniformfaninshape < out , out > , ? > mergestrategy , flow < flowin , out , ? > flow ) { return splitter . via ( flow . fromgraph ( graphdsl . < flowshape < f . either < flowin , out > , out > > create ( builder -> {	Using the given splitter flow, allow messages to bypass a flow.
private list < object > converterrorarguments ( object [ ] arguments ) { if ( arguments == null ) { return collections . emptylist ( ) ; } list < object > converted = arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . defaultmessagesourceresolvable ) ) . collect ( collectors . tolist ( ) ) ; return collections . unmodifiablelist ( converted ) ; }	Convert the error arguments.
public form < t > fill ( t value ) { if ( value == null ) { throw new runtimeexception ( str_ ) ; } return new form < > ( rootname , backedtype , new hashmap < > ( ) , new hashmap < > ( ) , new arraylist < > ( ) , optional . ofnullable ( value ) , groups , messagesapi , formatters , validatorfactory , config , lang , directfieldaccess ) ; }	Populates this form with an existing value, used for edit forms.
public list < validationerror > globalerrors ( ) { return collections . unmodifiablelist ( errors . stream ( ) . filter ( error -> error . key ( ) . isempty ( ) ) . collect ( collectors . tolist ( ) ) ) ; }	Retrieve all global errors - errors without a key.
public jsonnode errorsasjson ( lang lang ) { map < string , list < string > > allmessages = new hashmap < > ( ) ; errors . foreach ( error -> { if ( error != null ) { final list < string > messages = new arraylist < > ( ) ; if ( messagesapi != null && lang != null ) { final list < string > reversedmessages = new arraylist < > ( error . messages ( ) ) ; collections . reverse ( reversedmessages ) ; messages . add ( messagesapi . get ( lang , reversedmessages , translatemsgarg ( error . arguments ( ) , messagesapi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allmessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . json . tojson ( allmessages ) ; }	Returns the form errors serialized as Json using the given Lang.
public optional < object > value ( string key ) { return super . value ( ) . map ( v -> v . getdata ( ) . get ( asnormalkey ( key ) ) ) ; }	Gets the concrete value.
public dynamicform fill ( map < string , object > value ) { form < dynamic > form = super . fill ( new dynamic ( value ) ) ; return new dynamicform ( form . rawdata ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesapi , formatters , validatorfactory , config , lang ( ) . orelse ( null ) ) ; }	Fills the form with existing data.
public < t > t parse ( string text , class < t > clazz ) { return conversion . convert ( text , clazz ) ; }	Parses this string as instance of the given class.
@ suppresswarnings ( str_ ) public < t > t parse ( field field , string text ) { return ( t ) conversion . convert ( text , new typedescriptor ( field ) ) ; }	Parses this string as instance of a specific field.
public < t > string print ( t t ) { if ( t == null ) { return str_ ; } if ( conversion . canconvert ( t . getclass ( ) , string . class ) ) { return conversion . convert ( t , string . class ) ; } else { return t . tostring ( ) ; } }	Computes the display string for any value.
public < t > string print ( field field , t t ) { return print ( new typedescriptor ( field ) , t ) ; }	Computes the display string for any value, for a specific field.
public < t > string print ( typedescriptor desc , t t ) { if ( t == null ) { return str_ ; } if ( desc != null && conversion . canconvert ( desc , typedescriptor . valueof ( string . class ) ) ) { return ( string ) conversion . convert ( t , desc , typedescriptor . valueof ( string . class ) ) ; } else if ( conversion . canconvert ( t . getclass ( ) , string . class ) ) { return conversion . convert ( t , string . class ) ; } else { return t . tostring ( ) ; } }	Computes the display string for any value, for a specific type.
private formatters registeroptional ( ) { conversion . addconverter ( new genericconverter ( ) { public object convert ( object source , typedescriptor sourcetype , typedescriptor targettype ) { if ( sourcetype . getobjecttype ( ) . equals ( string . class ) ) {	Converter for String -> Optional and Optional -> String.
public < t > formatters register ( final class < t > clazz , final simpleformatter < t > formatter ) { conversion . addformatterforfieldtype ( clazz , new org . springframework . format . formatter < t > ( ) { public t parse ( string text , locale locale ) throws java . text . parseexception { return formatter . parse ( text , locale ) ; } public string print ( t t , locale locale ) { return formatter . print ( t , locale ) ; } public string tostring ( ) { return formatter . tostring ( ) ; } } ) ; return this ; }	Registers a simple formatter.
public string encode ( cookie cookie ) { if ( cookie == null ) { throw new nullpointerexception ( str_ ) ; } final string name = cookie . name ( ) ; final string value = cookie . value ( ) != null ? cookie . value ( ) : str_ ; validatecookie ( name , value ) ; stringbuilder buf = new stringbuilder ( ) ; if ( cookie . wrap ( ) ) { addquoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxage ( ) != integer . min_value ) { add ( buf , cookieheadernames . max_age , cookie . maxage ( ) ) ; date expires = cookie . maxage ( ) <= num_ ? new date ( num_ )	Encodes the specified cookie into a Set-Cookie header value.
public static nodelist selectnodes ( string path , object node ) { return selectnodes ( path , node , null ) ; }	Select all nodes that are selected by this XPath expression.
public static < t > scala . collection . immutable . seq < t > toseq ( java . util . list < t > list ) { return scala . collection . javaconverters . asscalabufferconverter ( list ) . asscala ( ) . tolist ( ) ; }	Converts a Java List to Scala Seq.
public static < t > scala . collection . immutable . seq < t > toseq ( t [ ] array ) { return toseq ( java . util . arrays . aslist ( array ) ) ; }	Converts a Java Array to Scala Seq.
@ safevarargs public static < t > scala . collection . immutable . seq < t > varargs ( t ... array ) { return toseq ( array ) ; }	Converts a Java varargs to Scala varargs.
public static < in , out > mappedwebsocketacceptor < in , out > json ( class < in > in ) { return new mappedwebsocketacceptor < > ( scala . partialfunction ( message -> { try { if ( message instanceof message . binary ) { return f . either . left ( play . libs . json . mapper ( ) . readvalue ( ( ( message . binary ) message ) . data ( ) . iterator ( ) . asinputstream ( ) , in ) ) ; } else if ( message instanceof message . text ) { return f . either . left ( play . libs . json . mapper ( ) . readvalue ( ( ( message . text ) message ) . data ( ) , in ) ) ; } } catch ( exception e ) { return f . either . right ( new message . close ( closecodes . unacceptable ( ) , e . getmessage ( ) ) ) ; } throw scala . nomatch ( ) ; } ) , outmessage -> { try { return new message . text ( play . libs . json . mapper ( ) . writevalueasstring ( outmessage ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } } ) ; }	Acceptor for JSON WebSockets.
private static < in , out > websocket acceptorresult ( partialfunction < message , f . either < in , message > > inmapper , function < http . requestheader , completionstage < f . either < result , flow < in , out , ? > > > > f , function < out , message > outmapper ) { return new websocket ( ) { @ override public completionstage < f . either < result , flow < message , message , ? > > > apply ( http . requestheader request ) { return f . apply ( request ) . thenapply ( resultorflow -> { if ( resultorflow . left . ispresent ( ) ) { return f . either . left ( resultorflow . left . get ( ) ) ; } else { flow < message , message , ? > flow = akkastreams . bypasswith ( flow . < message > create ( ) . collect ( inmapper ) , play . api . libs . streams . akkastreams . onlyfirstcanfinishmerge ( num_ ) , resultorflow . right . get ( ) . map ( outmapper :: apply ) ) ; return f . either . right ( flow ) ; } } ) ; } } ; }	Helper to create handlers for WebSockets.
private static float getprimitivepromotioncost ( final class < ? > srcclass , final class < ? > destclass ) { float cost = num_ ; class < ? > cls = srcclass ; if ( ! cls . isprimitive ( ) ) {	Gets the number of steps required to promote a primitive number to another type.
private static float gettotaltransformationcost ( final class < ? > [ ] srcargs , final executable executable ) { final class < ? > [ ] destargs = executable . getparametertypes ( ) ; final boolean isvarargs = executable . isvarargs ( ) ;	Returns the sum of the object transformation cost for each class in the source argument list.
private static float getobjecttransformationcost ( class < ? > srcclass , final class < ? > destclass ) { if ( destclass . isprimitive ( ) ) { return getprimitivepromotioncost ( srcclass , destclass ) ; } float cost = num_ ; while ( srcclass != null && ! destclass . equals ( srcclass ) ) { if ( destclass . isinterface ( ) && classutils . isassignable ( srcclass , destclass ) ) {	Gets the number of steps required needed to turn the source class into the destination class.This represents the number of steps in the object hierarchy graph.
public string at ( string key , object ... args ) { return messagesapi . get ( lang , key , args ) ; }	Get the message at the given key.
public string at ( list < string > keys , object ... args ) { return messagesapi . get ( lang , keys , args ) ; }	Get the message at the first defined key.
public static database createfrom ( string driver , string url , map < string , ? extends object > config ) { return createfrom ( str_ , driver , url , config ) ; }	Create a pooled database named "default" with the given configuration.
public static parallelsorter create ( object [ ] arrays ) { generator gen = new generator ( ) ; gen . setarrays ( arrays ) ; return gen . create ( ) ; }	Create a new ParallelSorter object for a set of arrays.
public void quicksort ( int index , int lo , int hi , comparator cmp ) { choosecomparer ( index , cmp ) ; super . quicksort ( lo , hi - num_ ) ; }	Sort the arrays using the quicksort algorithm.
public void mergesort ( int index , int lo , int hi , comparator cmp ) { choosecomparer ( index , cmp ) ; super . mergesort ( lo , hi - num_ ) ; }	Sort the arrays using an in-place merge sort.
public object invoke ( object obj , object [ ] args ) throws throwable { try { init ( ) ; fastclassinfo fci = fastclassinfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( invocationtargetexception e ) { throw e . gettargetexception ( ) ; } catch ( illegalargumentexception e ) { if ( fastclassinfo . i1 < num_ ) throw new illegalargumentexception ( str_ + sig1 ) ; throw e ; } }	Invoke the original method, on a different object of the same type.
public void load_arg ( int index ) { load_local ( state . argumenttypes [ index ] , state . localoffset + skipargs ( index ) ) ; }	Pushes the specified argument of the current method onto the stack.
void emit_field ( int opcode , type ctype , string name , type ftype ) { mv . visitfieldinsn ( opcode , ctype . getinternalname ( ) , name , ftype . getdescriptor ( ) ) ; }	package-protected for EmitUtils, try to fix.
public void zero_or_null ( type type ) { if ( typeutils . isprimitive ( type ) ) { switch ( type . getsort ( ) ) { case type . double : push ( num_ ) ; break ; case type . long : push ( num_ ) ; break ; case type . float : push ( num_ ) ; break ; case type . void : aconst_null ( ) ; default : push ( num_ ) ; } } else { aconst_null ( ) ; } }	Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.
public void unbox_or_zero ( type type ) { if ( typeutils . isprimitive ( type ) ) { if ( type != type . void_type ) { label nonnull = make_label ( ) ; label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonnull ) ; pop ( ) ; zero_or_null ( type ) ; goto ( end ) ; mark ( nonnull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }	Unboxes the object on the top of the stack.
public static void process_array ( codeemitter e , type type , processarraycallback callback ) { type componenttype = typeutils . getcomponenttype ( type ) ; local array = e . make_local ( ) ; local loopvar = e . make_local ( type . int_type ) ; label loopbody = e . make_label ( ) ; label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( num_ ) ; e . store_local ( loopvar ) ; e . goto ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componenttype ) ; callback . processelement ( componenttype ) ; e . iinc ( loopvar , num_ ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . lt , loopbody ) ; }	Process an array on the stack.
private static void nullcmp ( codeemitter e , label onenull , label bothnull ) { e . dup2 ( ) ; label nonnull = e . make_label ( ) ; label onenullhelper = e . make_label ( ) ; label end = e . make_label ( ) ; e . ifnonnull ( nonnull ) ; e . ifnonnull ( onenullhelper ) ; e . pop2 ( ) ; e . goto ( bothnull ) ; e . mark ( nonnull ) ; e . ifnull ( onenullhelper ) ; e . goto ( end ) ; e . mark ( onenullhelper ) ; e . pop2 ( ) ; e . goto ( onenull ) ; e . mark ( end ) ; }	If both objects on the top of the stack are non-null, does nothing.If one is null, or both are null, both are popped off and executionbranches to the respective label.
public map resolveall ( ) { map resolved = new hashmap ( ) ; for ( iterator entryiter = decltobridge . entryset ( ) . iterator ( ) ; entryiter . hasnext ( ) ; ) { map . entry entry = ( map . entry ) entryiter . next ( ) ; class owner = ( class ) entry . getkey ( ) ; set bridges = ( set ) entry . getvalue ( ) ; try { inputstream is = classloader . getresourceasstream ( owner . getname ( ) . replace ( str_ , str_ ) + str_ ) ; if ( is == null ) { return resolved ; } try { new classreader ( is ) . accept ( new bridgedfinder ( bridges , resolved ) , classreader . skip_frames | classreader . skip_debug ) ; } finally { is . close ( ) ; } } catch ( ioexception ignored ) { } } return resolved ; }	Finds all bridge methods that are being called with invokespecial &returns them.
protected void filterconstructors ( class sc , list constructors ) { collectionutils . filter ( constructors , new visibilitypredicate ( sc , bool_ ) ) ; if ( constructors . size ( ) == num_ ) throw new illegalargumentexception ( str_ + sc ) ; }	Filter the list of constructors from the superclass.
public void setsuperclass ( class superclass ) { if ( superclass != null && superclass . equals ( object . class ) ) { superclass = null ; } this . superclass = superclass ; }	Set the class which the generated class will extend.
private void getfield ( string [ ] names ) throws exception { final codeemitter e = begin_method ( constants . acc_public , provider_get , null ) ; e . load_this ( ) ; e . load_arg ( num_ ) ; emitutils . string_switch ( e , names , constants . switch_style_hash , new objectswitchcallback ( ) { public void processcase ( object key , label end ) { type type = ( type ) fields . get ( key ) ; e . getfield ( ( string ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processdefault ( ) { e . throw_exception ( illegal_argument_exception , str_ ) ; } } ) ; e . end_method ( ) ; }	to avoid JVM hashcode implementation incompatibilities.
public void add ( method method ) { add ( reflectutils . getsignature ( method ) , reflectutils . getexceptiontypes ( method ) ) ; }	Add a method signature to the interface.
public int cardinality ( ) { int w = value ; int c = num_ ; while ( w != num_ ) { c += t [ w & num_ ] ; w >>= num_ ; } return c ; }	If bit 31 is set then this method results in an infinite loop.
public void setnamingpolicy ( namingpolicy namingpolicy ) { if ( namingpolicy == null ) namingpolicy = defaultnamingpolicy . instance ; this . namingpolicy = namingpolicy ; }	Override the default naming policy.
public static method [ ] findmethods ( string [ ] namesanddescriptors , method [ ] methods ) { map map = new hashmap ( ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { method method = methods [ i ] ; map . put ( method . getname ( ) + type . getmethoddescriptor ( method ) , method ) ; } method [ ] result = new method [ namesanddescriptors . length / num_ ] ; for ( int i = num_ ; i < result . length ; i ++ ) { result [ i ] = ( method ) map . get ( namesanddescriptors [ i * num_ ] + namesanddescriptors [ i * num_ + num_ ] ) ; if ( result [ i ] == null ) {	used by MethodInterceptorGenerated generated code.
public static path resolve ( final path base , string child ) { if ( stringutil . startswithchar ( child , file . separatorchar ) ) { child = child . substring ( num_ ) ; } return base . resolve ( child ) ; }	Resolves subpath in safer way.
public static string readstring ( final path path ) throws ioexception { try ( bufferedreader reader = files . newbufferedreader ( path , standardcharsets . utf_8 ) ) { stringwriter writer = new stringwriter ( ) ;	Reads path content.
public httprequest host ( final string host ) { this . host = host ; if ( headers . contains ( header_host ) ) { headeroverwrite ( header_host , host ) ; } return this ; }	Sets request host name.
public static httprequest create ( final string method , final string destination ) { return new httprequest ( ) . method ( method . touppercase ( ) ) . set ( destination ) ; }	Generic request builder, usually used when method is a variable.Otherwise, use one of the other static request builder methods.
public static httprequest connect ( final string destination ) { return new httprequest ( ) . method ( httpmethod . connect ) . set ( destination ) ; }	Builds a CONNECT request.
public static httprequest get ( final string destination ) { return new httprequest ( ) . method ( httpmethod . get ) . set ( destination ) ; }	Builds a GET request.
public static httprequest post ( final string destination ) { return new httprequest ( ) . method ( httpmethod . post ) . set ( destination ) ; }	Builds a POST request.
public static httprequest put ( final string destination ) { return new httprequest ( ) . method ( httpmethod . put ) . set ( destination ) ; }	Builds a PUT request.
public static httprequest patch ( final string destination ) { return new httprequest ( ) . method ( httpmethod . patch ) . set ( destination ) ; }	Builds a PATCH request.
public static httprequest delete ( final string destination ) { return new httprequest ( ) . method ( httpmethod . delete ) . set ( destination ) ; }	Builds a DELETE request.
public static httprequest head ( final string destination ) { return new httprequest ( ) . method ( httpmethod . head ) . set ( destination ) ; }	Builds a HEAD request.
public static httprequest trace ( final string destination ) { return new httprequest ( ) . method ( httpmethod . trace ) . set ( destination ) ; }	Builds a TRACE request.
public static httprequest options ( final string destination ) { return new httprequest ( ) . method ( httpmethod . options ) . set ( destination ) ; }	Builds an OPTIONS request.
public httprequest path ( string path ) {	Sets request path. Query string is allowed.Adds a slash if path doesn't start with one.Query will be stripped out from the path.Previous query is discarded.
public httprequest cookies ( final cookie ... cookies ) { if ( cookies . length == num_ ) { return this ; } stringbuilder cookiestring = new stringbuilder ( ) ; boolean first = bool_ ; for ( cookie cookie : cookies ) { integer maxage = cookie . getmaxage ( ) ; if ( maxage != null && maxage . intvalue ( ) == num_ ) { continue ; } if ( ! first ) { cookiestring . append ( str_ ) ; } first = bool_ ; cookiestring . append ( cookie . getname ( ) ) ; cookiestring . append ( str_ ) ; cookiestring . append ( cookie . getvalue ( ) ) ; } headeroverwrite ( str_ , cookiestring . tostring ( ) ) ; return this ; }	Sets cookies to the request.
public httprequest query ( final string name1 , final object value1 , final object ... parameters ) { query ( name1 , value1 == null ? null : value1 . tostring ( ) ) ; for ( int i = num_ ; i < parameters . length ; i += num_ ) { string name = parameters [ i ] . tostring ( ) ; string value = parameters [ i + num_ ] . tostring ( ) ; query . add ( name , value ) ; } return this ; }	Adds many query parameters at once.
public httprequest query ( final map < string , string > querymap ) { for ( map . entry < string , string > entry : querymap . entryset ( ) ) { query . add ( entry . getkey ( ) , entry . getvalue ( ) ) ; } return this ; }	Adds all parameters from the provided map.
public httprequest querystring ( final string querystring , final boolean decode ) { this . query = httputil . parsequery ( querystring , decode ) ; return this ; }	Sets query from provided query string.
public string querystring ( ) { if ( query == null ) { return stringpool . empty ; } return httputil . buildquery ( query , queryencoding ) ; }	Generates query string. All values are URL encoded.
public string hosturl ( ) { stringband url = new stringband ( num_ ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( str_ ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != defaults . default_port ) { url . append ( str_ ) ; url . append ( port ) ; } return url . tostring ( ) ; }	Returns just host url, without path and query.
public httprequest basicauthentication ( final string username , final string password ) { if ( username != null && password != null ) { string data = username . concat ( stringpool . colon ) . concat ( password ) ; string base64 = base64 . encodetostring ( data ) ; headeroverwrite ( header_authorization , str_ + base64 ) ; } return this ; }	Enables basic authentication by adding required header.
public httprequest sethostheader ( ) { string hostport = this . host ; if ( port != defaults . default_port ) { hostport += stringpool . colon + port ; } headeroverwrite ( header_host , hostport ) ; return this ; }	Sets 'Host' header from current host and port.
@ override protected buffer buffer ( final boolean fullrequest ) {	Prepares the request buffer.
static handler removerange ( final handler firsthandler , final label start , final label end ) { if ( firsthandler == null ) { return null ; } else { firsthandler . nexthandler = removerange ( firsthandler . nexthandler , start , end ) ; } int handlerstart = firsthandler . startpc . bytecodeoffset ; int handlerend = firsthandler . endpc . bytecodeoffset ; int rangestart = start . bytecodeoffset ; int rangeend = end == null ? integer . max_value : end . bytecodeoffset ;	Removes the range between start and end from the Handler list that begins with the givenelement.
static int getexceptiontablelength ( final handler firsthandler ) { int length = num_ ; handler handler = firsthandler ; while ( handler != null ) { length ++ ; handler = handler . nexthandler ; } return length ; }	Returns the number of elements of the Handler list that begins with the given element.
protected void collectactioninterceptors ( ) { final collection < ? extends actioninterceptor > interceptorvalues = interceptorsmanager . getallinterceptors ( ) ; interceptors = new arraylist < > ( ) ; interceptors . addall ( interceptorvalues ) ; interceptors . sort ( comparator . comparing ( a -> a . getclass ( ) . getsimplename ( ) ) ) ; }	Collects all interceptors.
protected void collectactionfilters ( ) { final collection < ? extends actionfilter > filtervalues = filtersmanager . getallfilters ( ) ; filters = new arraylist < > ( ) ; filters . addall ( filtervalues ) ; filters . sort ( comparator . comparing ( a -> a . getclass ( ) . getsimplename ( ) ) ) ; }	Collects all filters.
protected void collectactionresults ( ) { final collection < actionresult > resultsvalues = resultsmanager . getallactionresults ( ) ; results = new arraylist < > ( ) ; results . addall ( resultsvalues ) ; results . sort ( comparator . comparing ( a -> a . getclass ( ) . getsimplename ( ) ) ) ; }	Collects all action results.
protected void collectactionruntimes ( ) { actions = actionsmanager . getallactionruntimes ( ) ; actions . sort ( comparator . comparing ( actionruntime :: getactionpath ) ) ; }	Collects all action runtime configurations.
@ suppresswarnings ( { str_ } ) protected void setsimpleproperty ( final beanproperty bp , final object value ) { setter setter = bp . getsetter ( isdeclared ) ;	Sets a value of simple property.
@ override public < t > t getproperty ( final object bean , final string name ) { beanproperty beanproperty = new beanproperty ( this , bean , name ) ; if ( ! issilent ) { resolvenestedproperties ( beanproperty ) ; return ( t ) getindexproperty ( beanproperty ) ; } else { try { resolvenestedproperties ( beanproperty ) ; return ( t ) getindexproperty ( beanproperty ) ; } catch ( exception ignore ) { return null ; } } }	Returns value of bean's property.
@ override public string extractthisreference ( final string propertyname ) { int ndx = stringutil . indexofchars ( propertyname , index_chars ) ; if ( ndx == - num_ ) { return propertyname ; } return propertyname . substring ( num_ , ndx ) ; }	Extract the first name of this reference.
@ override public printwriter getwriter ( ) { if ( writer == null ) { writer = new fastchararraywriter ( ) ; printwriter = new printwriter ( writer ) ; } return printwriter ; }	Returns buffered writer. Buffer will be created if not already used.
public void setobjectreference ( final string name , final object object ) { if ( objectrefs == null ) { objectrefs = new hashmap < > ( ) ; } objectrefs . put ( name , object ) ; }	Saves object reference.
public object getobjectreference ( final string name ) { if ( objectrefs == null ) { return null ; } return objectrefs . get ( name ) ; }	Returns object reference.
public object lookupobject ( final string ref ) { object value = getobjectreference ( ref ) ; if ( value == null ) { throw new dbsqlbuilderexception ( str_ + ref ) ; } return value ; }	Lookups for object reference and throws an exception if reference doesn't exist.
public dbentitydescriptor gettabledescriptor ( final string tableref ) { if ( tablerefs == null ) { return null ; } tablerefdata t = tablerefs . get ( tableref ) ; return t == null ? null : t . desc ; }	Returns entity descriptor for provided table reference.
public dbentitydescriptor findtabledescriptorbycolumnref ( final string columnref ) { for ( map . entry < string , tablerefdata > entry : tablerefs . entryset ( ) ) { dbentitydescriptor ded = entry . getvalue ( ) . desc ; if ( ded . findbypropertyname ( columnref ) != null ) { return ded ; } } return null ; }	Finds entity descriptor of a table that contains provided column reference.
public string gettablealias ( final string tableref ) { if ( tablerefs == null ) { return null ; } tablerefdata t = tablerefs . get ( tableref ) ; return t == null ? null : t . alias ; }	Returns table alias for provided table reference.
public void registertablereference ( final string tablereference , final dbentitydescriptor ded , final string tablealias ) { if ( tablerefs == null ) { tablerefs = new hashmap < > ( ) ; } tablerefdata t = new tablerefdata ( ded , tablealias ) ; if ( tablerefs . put ( tablereference , t ) != null ) { throw new dbsqlbuilderexception ( str_ + tablereference ) ; } }	Registers table reference for provided entity.
protected dbentitydescriptor lookuptableref ( final string tableref ) { dbentitydescriptor ded = gettabledescriptor ( tableref ) ; if ( ded == null ) { throw new dbsqlbuilderexception ( str_ + tableref ) ; } return ded ; }	Lookups for table reference and throws an exception if table reference not found.
public void registerhint ( final string hint ) { if ( hints == null ) { hints = new arraylist < > ( hintcount ) ; } hints . add ( hint ) ; }	Registers a hint.
@ override public final boolean serialize ( final jsoncontext jsoncontext , final t value ) { if ( jsoncontext . pushvalue ( value ) ) {	Detects circular dependencies and pushes value as currenttype context.
protected void injectattributes ( final httpservletrequest servletrequest , final targets targets ) { final enumeration < string > attributenames = servletrequest . getattributenames ( ) ; while ( attributenames . hasmoreelements ( ) ) { final string attrname = attributenames . nextelement ( ) ; targets . foreachtargetandin ( this , ( target , in ) -> { final string name = in . matchedname ( attrname ) ; if ( name != null ) { final object attrvalue = servletrequest . getattribute ( attrname ) ; target . writevalue ( name , attrvalue , bool_ ) ; } } ) ; } }	Injects request attributes.
protected void injectparameters ( final httpservletrequest servletrequest , final targets targets ) { final boolean encode = encodegetparams && servletrequest . getmethod ( ) . equals ( str_ ) ; final enumeration < string > paramnames = servletrequest . getparameternames ( ) ; while ( paramnames . hasmoreelements ( ) ) { final string paramname = paramnames . nextelement ( ) ; if ( servletrequest . getattribute ( paramname ) != null ) { continue ; } targets . foreachtargetandin ( this , ( target , in ) -> { final string name = in . matchedname ( paramname ) ; if ( name != null ) { string [ ] paramvalues = servletrequest . getparametervalues ( paramname ) ; paramvalues = servletutil . prepareparameters ( paramvalues , treatemptyparamsasnull , ignoreemptyrequestparams ) ; if ( paramvalues != null ) { if ( encode ) { for ( int j = num_ ; j < paramvalues . length ; j ++ ) { final string p = paramvalues [ j ] ; if ( p != null ) { final string encoding = madvocencoding . getencoding ( ) ; paramvalues [ j ] = stringutil . convertcharset ( p , stringpool . iso_8859_1 , encoding ) ; } } } final object value = ( paramvalues . length != num_ ? paramvalues : paramvalues [ num_ ] ) ; target . writevalue ( name , value , bool_ ) ; } } } ) ; } }	Inject request parameters.
protected void injectuploadedfiles ( final httpservletrequest servletrequest , final targets targets ) { if ( ! ( servletrequest instanceof multipartrequestwrapper ) ) { return ; } final multipartrequestwrapper multipartrequest = ( multipartrequestwrapper ) servletrequest ; if ( ! multipartrequest . ismultipart ( ) ) { return ; } final enumeration < string > paramnames = multipartrequest . getfileparameternames ( ) ; while ( paramnames . hasmoreelements ( ) ) { final string paramname = paramnames . nextelement ( ) ; if ( servletrequest . getattribute ( paramname ) != null ) { continue ; } targets . foreachtargetandin ( this , ( target , in ) -> { final string name = in . matchedname ( paramname ) ; if ( name != null ) { final fileupload [ ] paramvalues = multipartrequest . getfiles ( paramname ) ; if ( ignoreinvaliduploadfiles ) { for ( int j = num_ ; j < paramvalues . length ; j ++ ) { final fileupload paramvalue = paramvalues [ j ] ; if ( ( ! paramvalue . isvalid ( ) ) || ( ! paramvalue . isuploaded ( ) ) ) { paramvalues [ j ] = null ; } } } final object value = ( paramvalues . length == num_ ? paramvalues [ num_ ] : paramvalues ) ; target . writevalue ( name , value , bool_ ) ; } } ) ; } }	Inject uploaded files from multipart request parameters.
public string convertpropertynametocolumnname ( final string propertyname ) { stringbuilder tablename = new stringbuilder ( propertyname . length ( ) * num_ ) ; if ( splitcamelcase ) { string convertedtablename = format . fromcamelcase ( propertyname , separatorchar ) ; tablename . append ( convertedtablename ) ; } else { tablename . append ( propertyname ) ; } if ( ! changecase ) { return tablename . tostring ( ) ; } return uppercase ? touppercase ( tablename ) . tostring ( ) : tolowercase ( tablename ) . tostring ( ) ; }	Converts property name to column name.
public string convertcolumnnametopropertyname ( final string columnname ) { stringbuilder propertyname = new stringbuilder ( columnname . length ( ) ) ; int len = columnname . length ( ) ; if ( splitcamelcase ) { boolean toupper = bool_ ; for ( int i = num_ ; i < len ; i ++ ) { char c = columnname . charat ( i ) ; if ( c == separatorchar ) { toupper = bool_ ; continue ; } if ( toupper ) { propertyname . append ( character . touppercase ( c ) ) ; toupper = bool_ ; } else { propertyname . append ( character . tolowercase ( c ) ) ; } } return propertyname . tostring ( ) ; } return columnname ; }	Converts column name to property name.
public string applytocolumnname ( final string columnname ) { string propertyname = convertcolumnnametopropertyname ( columnname ) ; return convertpropertynametocolumnname ( propertyname ) ; }	Applies column naming strategy to given column name hint.Returns full column name.
public void storevalue ( final preparedstatement st , final int index , final object value , final int dbsqltype ) throws sqlexception { t t = typeconvertermanager . get ( ) . converttype ( value , sqltype ) ; set ( st , index , t , dbsqltype ) ; }	Stores value in database.
@ suppresswarnings ( { str_ } ) protected < e > e preparegetvalue ( final t t , final class < e > destinationtype ) { if ( t == null ) { return null ; } if ( destinationtype == null ) { return ( e ) t ; } return typeconvertermanager . get ( ) . converttype ( t , destinationtype ) ; }	Once when value is read from result set, prepare it to match destination type.
protected set < t > getall ( ) { final set < t > set = new hashset < > ( wrappers . size ( ) ) ; set . addall ( wrappers . values ( ) ) ; return set ; }	Returns all action wrappers.
public t resolve ( final class < ? extends t > wrapperclass ) { string wrapperclassname = wrapperclass . getname ( ) ; t wrapper = lookup ( wrapperclassname ) ; if ( wrapper == null ) { wrapper = createwrapper ( wrapperclass ) ; initializewrapper ( wrapper ) ; wrappers . put ( wrapperclassname , wrapper ) ; } return wrapper ; }	Resolves single wrapper. Creates new wrapper instance if not already registered.Does not expand the wrappers.
protected < r extends t > r createwrapper ( final class < r > wrapperclass ) { try { return classutil . newinstance ( wrapperclass ) ; } catch ( exception ex ) { throw new madvocexception ( str_ + wrapperclass , ex ) ; } }	Creates new wrapper.
public static string separatorstosystem ( final string path ) { if ( path == null ) { return null ; } if ( system_separator == windows_separator ) { return separatorstowindows ( path ) ; } else { return separatorstounix ( path ) ; } }	Converts all separators to the system separator.
private static string dogetpath ( final string filename , final int separatoradd ) { if ( filename == null ) { return null ; } int prefix = getprefixlength ( filename ) ; if ( prefix < num_ ) { return null ; } int index = indexoflastseparator ( filename ) ; int endindex = index + separatoradd ; if ( prefix >= filename . length ( ) || index < num_ || prefix >= endindex ) { return stringpool . empty ; } return filename . substring ( prefix , endindex ) ; }	Does the work of getting the path.
public static string [ ] split ( final string filename ) { string prefix = getprefix ( filename ) ; if ( prefix == null ) { prefix = stringpool . empty ; } int lastseparatorindex = indexoflastseparator ( filename ) ; int lastextensionindex = indexofextension ( filename ) ; string path ; string basename ; string extension ; if ( lastseparatorindex == - num_ ) { path = stringpool . empty ; if ( lastextensionindex == - num_ ) { basename = filename . substring ( prefix . length ( ) ) ; extension = stringpool . empty ; } else { basename = filename . substring ( prefix . length ( ) , lastextensionindex ) ; extension = filename . substring ( lastextensionindex + num_ ) ; } } else { path = filename . substring ( prefix . length ( ) , lastseparatorindex + num_ ) ; if ( lastextensionindex == - num_ ) { basename = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = stringpool . empty ; } else { basename = filename . substring ( prefix . length ( ) + path . length ( ) , lastextensionindex ) ; extension = filename . substring ( lastextensionindex + num_ ) ; } } return new string [ ] { prefix , path , basename , extension } ; }	Splits filename into a array of four Strings containing prefix, path, basename and extension.Path will contain ending separator.
public static string relativepath ( final string targetpath , final string basepath ) { return new file ( basepath ) . topath ( ) . relativize ( new file ( targetpath ) . topath ( ) ) . tostring ( ) ; }	Calculates relative path of target path on base path.
public webapp registercomponent ( final class < ? > madvoccomponent ) { objects . requirenonnull ( madvoccomponent ) ; madvoccomponents . add ( classconsumer . of ( madvoccomponent ) ) ; return this ; }	Registers additional Madvoc components after the registration of default components.
public < a extends actionconfig > webapp withactionconfig ( final class < a > actionconfigtype , final consumer < a > actionconfigconsumer ) { withregisteredcomponent ( actionconfigmanager . class , acm -> acm . with ( actionconfigtype , actionconfigconsumer ) ) ; return this ; }	Configures the action configurations.
public webapp start ( ) { log = loggerfactory . getlogger ( webapp . class ) ; log . debug ( str_ ) ;	Initializes and starts web application.
protected void registermadvoccomponents ( ) { if ( madvoccontainer == null ) { throw new madvocexception ( str_ ) ; } log . debug ( str_ ) ; madvoccontainer . registercomponent ( madvocencoding . class ) ; madvoccontainer . registercomponentinstance ( new servletcontextprovider ( servletcontext ) ) ; madvoccontainer . registercomponent ( actionconfigmanager . class ) ; madvoccontainer . registercomponent ( actionmethodparamnameresolver . class ) ; madvoccontainer . registercomponent ( actionmethodparser . class ) ; madvoccontainer . registercomponent ( actionpathrewriter . class ) ; madvoccontainer . registercomponent ( actionsmanager . class ) ; madvoccontainer . registercomponent ( contextinjectorcomponent . class ) ; madvoccontainer . registercomponent ( interceptorsmanager . class ) ; madvoccontainer . registercomponent ( filtersmanager . class ) ; madvoccontainer . registercomponent ( madvoccontroller . class ) ; madvoccontainer . registercomponent ( rootpackages . class ) ; madvoccontainer . registercomponent ( resultsmanager . class ) ; madvoccontainer . registercomponent ( resultmapper . class ) ; madvoccontainer . registercomponent ( scoperesolver . class ) ; madvoccontainer . registercomponent ( scopedatainspector . class ) ; madvoccontainer . registercomponent ( asyncactionexecutor . class ) ; madvoccontainer . registercomponent ( fileuploader . class ) ; }	Registers default Madvoc components.
public classscanner excludejars ( final string ... excludedjars ) { for ( final string excludedjar : excludedjars ) { rulesjars . exclude ( excludedjar ) ; } return this ; }	Specify excluded jars.
public classscanner includejars ( final string ... includedjars ) { for ( final string includedjar : includedjars ) { rulesjars . include ( includedjar ) ; } return this ; }	Specify included jars.
public classscanner includeentries ( final string ... includedentries ) { for ( final string includedentry : includedentries ) { rulesentries . include ( includedentry ) ; } return this ; }	Sets included set of names that will be considered during configuration.
public classscanner excludeentries ( final string ... excludedentries ) { for ( final string excludedentry : excludedentries ) { rulesentries . exclude ( excludedentry ) ; } return this ; }	Sets excluded names that narrows included set of packages.
protected void scanjarfile ( final file file ) { final zipfile zipfile ; try { zipfile = new zipfile ( file ) ; } catch ( ioexception ioex ) { if ( ! ignoreexception ) { throw new findfileexception ( str_ + file . getname ( ) , ioex ) ; } return ; } final enumeration entries = zipfile . entries ( ) ; while ( entries . hasmoreelements ( ) ) { final zipentry zipentry = ( zipentry ) entries . nextelement ( ) ; final string zipentryname = zipentry . getname ( ) ; try { if ( stringutil . endswithignorecase ( zipentryname , class_file_ext ) ) { final string entryname = prepareentryname ( zipentryname , bool_ ) ; final classpathentry classpathentry = new classpathentry ( entryname , zipfile , zipentry ) ; try { scanentry ( classpathentry ) ; } finally { classpathentry . closeinputstream ( ) ; } } else if ( includeresources ) { final string entryname = prepareentryname ( zipentryname , bool_ ) ; final classpathentry classpathentry = new classpathentry ( entryname , zipfile , zipentry ) ; try { scanentry ( classpathentry ) ; } finally { classpathentry . closeinputstream ( ) ; } } } catch ( runtimeexception rex ) { if ( ! ignoreexception ) { ziputil . close ( zipfile ) ; throw rex ; } } } ziputil . close ( zipfile ) ; }	Scans classes inside single JAR archive.
protected void scanclasspath ( final file root ) { string rootpath = root . getabsolutepath ( ) ; if ( ! rootpath . endswith ( file . separator ) ) { rootpath += file . separatorchar ; } final findfile ff = findfile . create ( ) . includedirs ( bool_ ) . recursive ( bool_ ) . searchpath ( rootpath ) ; file file ; while ( ( file = ff . nextfile ( ) ) != null ) { final string filepath = file . getabsolutepath ( ) ; try { if ( stringutil . endswithignorecase ( filepath , class_file_ext ) ) { scanclassfile ( filepath , rootpath , file , bool_ ) ; } else if ( includeresources ) { scanclassfile ( filepath , rootpath , file , bool_ ) ; } } catch ( runtimeexception rex ) { if ( ! ignoreexception ) { throw rex ; } } } }	Scans single classpath directory.
public static byte [ ] bytecodesignatureoftype ( final class type ) { final string name = str_ + type . getname ( ) . replace ( str_ , str_ ) + str_ ; return name . getbytes ( ) ; }	Returns type signature bytes used for searching in class file.
public classscanner scan ( final string ... paths ) { for ( final string path : paths ) { filestoscan . add ( new file ( path ) ) ; } return this ; }	Scans provided paths.
public void start ( ) { if ( detectentriesmode ) { rulesentries . detectmode ( ) ; } filestoscan . foreach ( file -> { final string path = file . getabsolutepath ( ) ; if ( stringutil . endswithignorecase ( path , jar_file_ext ) ) { if ( ! acceptjar ( file ) ) { return ; } scanjarfile ( file ) ; } else if ( file . isdirectory ( ) ) { scanclasspath ( file ) ; } } ) ; }	Starts with the scanner.
@ override protected jtxtransaction createnewtransaction ( final jtxtransactionmode tm , final object scope , final boolean active ) { return new dbjtxtransaction ( this , tm , scope , active ) ; }	Builds new transaction instance.
@ suppresswarnings ( str_ ) public < s extends madvocscope > s defaultorscopetype ( final class < s > scopeclass ) { if ( scopeclass == null ) { return ( s ) getorinitscope ( requestscope . class ) ; } return ( s ) getorinitscope ( scopeclass ) ; }	Lookups the scope instance of given scope annotation.If instance does not exist, it will be created, cached and returned.
protected madvocscope getorinitscope ( final class < ? extends madvocscope > madvocscopetype ) { for ( final madvocscope s : allscopes ) { if ( s . getclass ( ) . equals ( madvocscopetype ) ) { return s ; } }	Performs search for the scope class and returns it's instance.
public void forscope ( final class < ? extends madvocscope > scopetype , final consumer < madvocscope > madvocscopeconsumer ) { final madvocscope scope = getorinitscope ( scopetype ) ; madvocscopeconsumer . accept ( scope ) ; }	Finds a given scope and consumes it.
@ suppresswarnings ( { str_ } ) public static string preparecsrftoken ( final httpsession session , final int timetolive ) { set < token > tokenset = ( set < token > ) session . getattribute ( csrf_token_set ) ; if ( tokenset == null ) { tokenset = new hashset < > ( ) ; session . setattribute ( csrf_token_set , tokenset ) ; } string value ; boolean unique ; do { value = randomstring . get ( ) . randomalphanumeric ( num_ ) ; assuresize ( tokenset ) ; unique = tokenset . add ( new token ( value , timetolive ) ) ; } while ( ! unique ) ; return value ; }	Generates new CSRF token and puts it in the session.
protected static void assuresize ( final set < token > tokenset ) { if ( tokenset . size ( ) < maxtokenspersession ) { return ; } long validuntilmin = long . max_value ; token tokentoremove = null ; iterator < token > iterator = tokenset . iterator ( ) ; while ( iterator . hasnext ( ) ) { token token = iterator . next ( ) ; if ( token . isexpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validuntil < validuntilmin ) { validuntilmin = token . validuntil ; tokentoremove = token ; } } if ( ( tokentoremove != null ) && ( tokenset . size ( ) >= maxtokenspersession ) ) { tokenset . remove ( tokentoremove ) ; } }	Removes expired tokens if token set is full.
@ suppresswarnings ( { str_ } ) public static boolean checkcsrftoken ( final httpsession session , final string tokenvalue ) { set < token > tokenset = ( set < token > ) session . getattribute ( csrf_token_set ) ; if ( ( tokenset == null ) && ( tokenvalue == null ) ) { return bool_ ; } if ( ( tokenset == null ) || ( tokenvalue == null ) ) { return bool_ ; } boolean found = bool_ ; iterator < token > it = tokenset . iterator ( ) ; while ( it . hasnext ( ) ) { token t = it . next ( ) ; if ( t . isexpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getvalue ( ) . equals ( tokenvalue ) ) { it . remove ( ) ; found = bool_ ; } } return found ; }	Checks token value.C.
public static beancopy from ( final object source ) { beancopy beancopy = new beancopy ( source ) ; beancopy . issourcemap = source instanceof map ; return beancopy ; }	Defines source, detects a map.
public void copy ( ) { beanutil = new beanutilbean ( ) . declared ( declared ) . forced ( forced ) . silent ( bool_ ) ; visit ( ) ; }	Performs the copying.
@ override protected boolean visitproperty ( string name , final object value ) { if ( istargetmap ) { name = left_sq_bracket + name + right_sq_bracket ; } beanutil . setproperty ( destination , name , value ) ; return bool_ ; }	Copies single property to the destination.Exceptions are ignored, so copying continues ifdestination does not have some of the sources properties.
@ override public void init ( final templatedata templatedata ) { super . init ( templatedata ) ; if ( entity != null ) { ded = lookuptype ( entity ) ; } else { object object = templatedata . getobjectreference ( entityname ) ; if ( object != null ) { ded = lookuptype ( resolveclass ( object ) ) ; } else { ded = lookupname ( entityname ) ; } } string tablereference = this . tablereference ; if ( tablereference == null ) { tablereference = tablealias ; } if ( tablereference == null ) { tablereference = entityname ; } if ( tablereference == null ) { tablereference = ded . getentityname ( ) ; } templatedata . registertablereference ( tablereference , ded , tablealias ) ; }	Resolves and registers table references.
@ suppresswarnings ( str_ ) public < s extends scope > s resolvescope ( final class < s > scopetype ) { s scope = ( s ) scopes . get ( scopetype ) ; if ( scope == null ) { try { scope = newinternalinstance ( scopetype , ( petitecontainer ) this ) ; } catch ( exception ex ) { throw new petiteexception ( str_ + scopetype . getname ( ) , ex ) ; } registerscope ( scopetype , scope ) ; scopes . put ( scopetype , scope ) ; } return scope ; }	Resolves and registers scope from a scope type.
public < t > beandefinition < t > registerpetitebean ( final class < t > type , string name , class < ? extends scope > scopetype , wiringmode wiringmode , final boolean define , final consumer < t > consumer ) { if ( name == null ) { name = resolvebeanname ( type ) ; } if ( wiringmode == null ) { wiringmode = annotationresolver . resolvebeanwiringmode ( type ) ; } if ( wiringmode == wiringmode . default ) { wiringmode = petiteconfig . getdefaultwiringmode ( ) ; } if ( scopetype == null ) { scopetype = annotationresolver . resolvebeanscopetype ( type ) ; } if ( scopetype == null ) { scopetype = singletonscope . class ; }	Registers or defines a bean.
protected void registerbean ( final string name , final beandefinition beandefinition ) { beans . put ( name , beandefinition ) ; if ( ! petiteconfig . isusealtbeannames ( ) ) { return ; } class type = beandefinition . type ( ) ; if ( annotationresolver . beanhasannotationname ( type ) ) { return ; } class [ ] interfaces = classutil . resolveallinterfaces ( type ) ; for ( class aninterface : interfaces ) { string altname = annotationresolver . resolvebeanname ( aninterface , petiteconfig . getusefulltypenames ( ) ) ; if ( name . equals ( altname ) ) { continue ; } if ( beans . containskey ( altname ) ) { continue ; } if ( beansalt . containskey ( altname ) ) { beandefinition existing = beansalt . get ( altname ) ; if ( existing != null ) { beansalt . put ( altname , null ) ;	Registers bean definition by putting it in the beans map.
public void removebean ( final class type ) {	Removes all petite beans of provided type.
protected string [ ] resolvebeannamesfortype ( final class type ) { string [ ] beannames = beancollections . get ( type ) ; if ( beannames != null ) { return beannames ; } arraylist < string > list = new arraylist < > ( ) ; for ( map . entry < string , beandefinition > entry : beans . entryset ( ) ) { beandefinition beandefinition = entry . getvalue ( ) ; if ( classutil . istypeof ( beandefinition . type , type ) ) { string beanname = entry . getkey ( ) ; list . add ( beanname ) ; } } if ( list . isempty ( ) ) { beannames = stringpool . empty_array ; } else { beannames = list . toarray ( new string [ num_ ] ) ; } beancollections . put ( type , beannames ) ; return beannames ; }	Resolves bean names for give type.
public void registerpetitectorinjectionpoint ( final string beanname , final class [ ] paramtypes , final string [ ] references ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; constructor constructor = null ; if ( paramtypes == null ) { ctordescriptor [ ] ctors = cd . getallctordescriptors ( ) ; if ( ctors != null && ctors . length > num_ ) { if ( ctors . length > num_ ) { throw new petiteexception ( ctors . length + str_ + beandefinition . type . getname ( ) ) ; } constructor = ctors [ num_ ] . getconstructor ( ) ; } } else { ctordescriptor ctordescriptor = cd . getctordescriptor ( paramtypes , bool_ ) ; if ( ctordescriptor != null ) { constructor = ctordescriptor . getconstructor ( ) ; } } if ( constructor == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) ) ; } beanreferences [ ] ref = referencesresolver . resolvereferencefromvalues ( constructor , references ) ; beandefinition . ctor = new ctorinjectionpoint ( constructor , ref ) ; }	Registers constructor injection point.
public void registerpetitepropertyinjectionpoint ( final string beanname , final string property , final string reference ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; propertydescriptor propertydescriptor = cd . getpropertydescriptor ( property , bool_ ) ; if ( propertydescriptor == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) + str_ + property ) ; } beanreferences ref = referencesresolver . resolvereferencefromvalue ( propertydescriptor , reference ) ; propertyinjectionpoint pip = new propertyinjectionpoint ( propertydescriptor , ref ) ; beandefinition . addpropertyinjectionpoint ( pip ) ; }	Registers property injection point.
public void registerpetitesetinjectionpoint ( final string beanname , final string property ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; propertydescriptor propertydescriptor = cd . getpropertydescriptor ( property , bool_ ) ; if ( propertydescriptor == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) + str_ + property ) ; } setinjectionpoint sip = new setinjectionpoint ( propertydescriptor ) ; beandefinition . addsetinjectionpoint ( sip ) ; }	Registers set injection point.
public void registerpetitemethodinjectionpoint ( final string beanname , final string methodname , final class [ ] arguments , final string [ ] references ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; method method = null ; if ( arguments == null ) { methoddescriptor [ ] methods = cd . getallmethoddescriptors ( methodname ) ; if ( methods != null && methods . length > num_ ) { if ( methods . length > num_ ) { throw new petiteexception ( methods . length + str_ + beandefinition . type . getname ( ) + str_ + methodname ) ; } method = methods [ num_ ] . getmethod ( ) ; } } else { methoddescriptor md = cd . getmethoddescriptor ( methodname , arguments , bool_ ) ; if ( md != null ) { method = md . getmethod ( ) ; } } if ( method == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) + str_ + methodname ) ; } beanreferences [ ] ref = referencesresolver . resolvereferencefromvalues ( method , references ) ; methodinjectionpoint mip = new methodinjectionpoint ( method , ref ) ; beandefinition . addmethodinjectionpoint ( mip ) ; }	Registers method injection point.
public void registerpetiteinitmethods ( final string beanname , final initmethodinvocationstrategy invocationstrategy , string ... initmethodnames ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; if ( initmethodnames == null ) { initmethodnames = stringpool . empty_array ; } int total = initmethodnames . length ; initmethodpoint [ ] initmethodpoints = new initmethodpoint [ total ] ; int i ; for ( i = num_ ; i < initmethodnames . length ; i ++ ) { methoddescriptor md = cd . getmethoddescriptor ( initmethodnames [ i ] , classutil . empty_class_array , bool_ ) ; if ( md == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) + str_ + initmethodnames [ i ] ) ; } initmethodpoints [ i ] = new initmethodpoint ( md . getmethod ( ) , i , invocationstrategy ) ; } beandefinition . addinitmethodpoints ( initmethodpoints ) ; }	Registers init method.
public void registerpetitedestroymethods ( final string beanname , string ... destroymethodnames ) { beandefinition beandefinition = lookupexistingbeandefinition ( beanname ) ; classdescriptor cd = classintrospector . get ( ) . lookup ( beandefinition . type ) ; if ( destroymethodnames == null ) { destroymethodnames = stringpool . empty_array ; } int total = destroymethodnames . length ; destroymethodpoint [ ] destroymethodpoints = new destroymethodpoint [ total ] ; int i ; for ( i = num_ ; i < destroymethodnames . length ; i ++ ) { methoddescriptor md = cd . getmethoddescriptor ( destroymethodnames [ i ] , classutil . empty_class_array , bool_ ) ; if ( md == null ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) + str_ + destroymethodnames [ i ] ) ; } destroymethodpoints [ i ] = new destroymethodpoint ( md . getmethod ( ) ) ; } beandefinition . adddestroymethodpoints ( destroymethodpoints ) ; }	Registers destroy method.
public void registerpetiteprovider ( final string providername , final string beanname , final string methodname , final class [ ] arguments ) { beandefinition beandefinition = lookupbeandefinition ( beanname ) ; if ( beandefinition == null ) { throw new petiteexception ( str_ + beanname ) ; } class beantype = beandefinition . type ; classdescriptor cd = classintrospector . get ( ) . lookup ( beantype ) ; methoddescriptor md = cd . getmethoddescriptor ( methodname , arguments , bool_ ) ; if ( md == null ) { throw new petiteexception ( str_ + methodname ) ; } providerdefinition providerdefinition = new providerdefinition ( providername , beanname , md . getmethod ( ) ) ; providers . put ( providername , providerdefinition ) ; }	Registers instance method provider.
public void registerpetiteprovider ( final string providername , final class type , final string staticmethodname , final class [ ] arguments ) { classdescriptor cd = classintrospector . get ( ) . lookup ( type ) ; methoddescriptor md = cd . getmethoddescriptor ( staticmethodname , arguments , bool_ ) ; if ( md == null ) { throw new petiteexception ( str_ + staticmethodname ) ; } providerdefinition providerdefinition = new providerdefinition ( providername , md . getmethod ( ) ) ; providers . put ( providername , providerdefinition ) ; }	Registers static method provider.
public void foreachbeantype ( final class type , final consumer < string > beannameconsumer ) { foreachbean ( bd -> { if ( classutil . istypeof ( bd . type , type ) ) { beannameconsumer . accept ( bd . name ) ; } } ) ; }	Iterates all beans that are of given type.
public void defineparameters ( final map < ? , ? > properties ) { for ( map . entry < ? , ? > entry : properties . entryset ( ) ) { defineparameter ( entry . getkey ( ) . tostring ( ) , entry . getvalue ( ) ) ; } }	Defines many parameters at once.
@ override public object intercept ( final actionrequest actionrequest ) throws exception { printbefore ( actionrequest ) ; long starttime = system . currenttimemillis ( ) ; object result = null ; try { result = actionrequest . invoke ( ) ; } catch ( exception ex ) { result = str_ ; throw ex ; } catch ( throwable th ) { result = str_ ; throw new exception ( th ) ; } finally { long executiontime = system . currenttimemillis ( ) - starttime ; printafter ( actionrequest , executiontime , result ) ; } return result ; }	Measure action invocation time.
public static int resolvejavaversion ( final int version ) { final int javaversionnumber = systemutil . info ( ) . getjavaversionnumber ( ) ; final int platformversion = javaversionnumber - num_ + num_ ; return version > platformversion ? version : platformversion ; }	Resolves Java version from current version.
public static void pushint ( final methodvisitor mv , final int value ) { if ( value <= num_ ) { mv . visitinsn ( iconst_0 + value ) ; } else if ( value <= byte . max_value ) { mv . visitintinsn ( bipush , value ) ; } else { mv . visitintinsn ( sipush , value ) ; } }	Pushes int value in an optimal way.
public static void checkargumentindex ( final methodinfo methodinfo , final int argindex ) { if ( ( argindex < num_ ) || ( argindex > methodinfo . getargumentscount ( ) ) ) { throw new proxettaexception ( str_ + argindex ) ; } }	Validates argument index.
public static string advicefieldname ( final string name , final int index ) { return proxettanames . fieldprefix + name + proxettanames . fielddivider + index ; }	Builds advice field name.
public static string advicemethodname ( final string name , final int index ) { return proxettanames . methodprefix + name + proxettanames . methoddivider + index ; }	Builds advice method name.
public static void loadspecialmethodarguments ( final methodvisitor mv , final methodinfo methodinfo ) { mv . visitvarinsn ( aload , num_ ) ; for ( int i = num_ ; i <= methodinfo . getargumentscount ( ) ; i ++ ) { loadmethodargument ( mv , methodinfo , i ) ; } }	Loads all method arguments before INVOKESPECIAL call.
public static void loadstaticmethodarguments ( final methodvisitor mv , final methodinfo methodinfo ) { for ( int i = num_ ; i < methodinfo . getargumentscount ( ) ; i ++ ) { loadmethodargument ( mv , methodinfo , i ) ; } }	Loads all method arguments before INVOKESTATIC call.
public static void loadvirtualmethodarguments ( final methodvisitor mv , final methodinfo methodinfo ) { for ( int i = num_ ; i <= methodinfo . getargumentscount ( ) ; i ++ ) { loadmethodargument ( mv , methodinfo , i ) ; } }	Loads all method arguments before INVOKEVIRTUAL call.
public static void loadmethodargument ( final methodvisitor mv , final methodinfo methodinfo , final int index ) { int offset = methodinfo . getargumentoffset ( index ) ; int type = methodinfo . getargument ( index ) . getopcode ( ) ; switch ( type ) { case str_ : break ; case str_ : case str_ : case str_ : case str_ : case str_ : mv . visitvarinsn ( iload , offset ) ; break ; case str_ : mv . visitvarinsn ( lload , offset ) ; break ; case str_ : mv . visitvarinsn ( fload , offset ) ; break ; case str_ : mv . visitvarinsn ( dload , offset ) ; break ; default : mv . visitvarinsn ( aload , offset ) ; } }	Loads one argument. Index is 1-based. No conversion occurs.
public static void storemethodargument ( final methodvisitor mv , final methodinfo methodinfo , final int index ) { int offset = methodinfo . getargumentoffset ( index ) ; int type = methodinfo . getargument ( index ) . getopcode ( ) ; switch ( type ) { case str_ : break ; case str_ : case str_ : case str_ : case str_ : case str_ : mv . visitvarinsn ( istore , offset ) ; break ; case str_ : mv . visitvarinsn ( lstore , offset ) ; break ; case str_ : mv . visitvarinsn ( fstore , offset ) ; break ; case str_ : mv . visitvarinsn ( dstore , offset ) ; break ; default : mv . visitvarinsn ( astore , offset ) ; } }	Stores one argument. Index is 1-based. No conversion occurs.
public static void preparereturnvalue ( final methodvisitor mv , final methodinfo methodinfo , int varoffset ) { varoffset += methodinfo . getallargumentssize ( ) ; switch ( methodinfo . getreturntype ( ) . getopcode ( ) ) { case str_ : mv . visitinsn ( aconst_null ) ; break ; case str_ : asmutil . valueofbyte ( mv ) ; break ; case str_ : asmutil . valueofcharacter ( mv ) ; break ; case str_ : asmutil . valueofshort ( mv ) ; break ; case str_ : asmutil . valueofinteger ( mv ) ; break ; case str_ : asmutil . valueofboolean ( mv ) ; break ; case str_ : asmutil . valueoflong ( mv ) ; break ; case str_ : asmutil . valueoffloat ( mv ) ; break ; case str_ : asmutil . valueofdouble ( mv ) ; break ; } }	Prepares return value.
public static string createmethodsignatureskey ( final int access , final string methodname , final string description , final string classname ) { return new stringband ( num_ ) . append ( access ) . append ( colon ) . append ( description ) . append ( stringpool . underscore ) . append ( classname ) . append ( stringpool . hash ) . append ( methodname ) . tostring ( ) ; }	Creates unique key for method signatures map.
public static void newarray ( final methodvisitor mv , final class componenttype ) { if ( componenttype == int . class ) { mv . visitintinsn ( newarray , t_int ) ; return ; } if ( componenttype == long . class ) { mv . visitintinsn ( newarray , t_long ) ; return ; } if ( componenttype == float . class ) { mv . visitintinsn ( newarray , t_float ) ; return ; } if ( componenttype == double . class ) { mv . visitintinsn ( newarray , t_double ) ; return ; } if ( componenttype == byte . class ) { mv . visitintinsn ( newarray , t_byte ) ; return ; } if ( componenttype == short . class ) { mv . visitintinsn ( newarray , t_short ) ; return ; } if ( componenttype == boolean . class ) { mv . visitintinsn ( newarray , t_boolean ) ; return ; } if ( componenttype == char . class ) { mv . visitintinsn ( newarray , t_char ) ; return ; } mv . visittypeinsn ( anewarray , asmutil . typetosignature ( componenttype ) ) ; }	Creates new array.
public static void storeintoarray ( final methodvisitor mv , final class componenttype ) { if ( componenttype == int . class ) { mv . visitinsn ( iastore ) ; return ; } if ( componenttype == long . class ) { mv . visitinsn ( lastore ) ; return ; } if ( componenttype == float . class ) { mv . visitinsn ( fastore ) ; return ; } if ( componenttype == double . class ) { mv . visitinsn ( dastore ) ; return ; } if ( componenttype == byte . class ) { mv . visitinsn ( bastore ) ; return ; } if ( componenttype == short . class ) { mv . visitinsn ( sastore ) ; return ; } if ( componenttype == boolean . class ) { mv . visitinsn ( bastore ) ; return ; } if ( componenttype == char . class ) { mv . visitinsn ( castore ) ; return ; } mv . visitinsn ( aastore ) ; }	Stores element on stack into an array.
public static string extractencoding ( final string contenttype , string defaultencoding ) { string encoding = extractencoding ( contenttype ) ; if ( encoding == null ) { if ( defaultencoding == null ) { defaultencoding = joddcore . encoding ; } encoding = defaultencoding ; } return encoding ; }	Extracts encoding from a given content type.
public static boolean isemptyflags ( flags flags ) { if ( flags == null ) return bool_ ; flags . flag [ ] systemflags = flags . getsystemflags ( ) ; if ( systemflags != null && systemflags . length > num_ ) { return bool_ ; } string [ ] userflags = flags . getuserflags ( ) ; if ( userflags != null && userflags . length > num_ ) { return bool_ ; } return bool_ ; }	Check whether flags is a empty flags.
public static string resolveauthbearertoken ( final httpservletrequest request ) { string header = request . getheader ( header_authorization ) ; if ( header == null ) { return null ; } int ndx = header . indexof ( str_ ) ; if ( ndx == - num_ ) { return null ; } return header . substring ( ndx + num_ ) . trim ( ) ; }	Returns Bearer token.
public static void requireauthentication ( final httpservletresponse resp , final string realm ) throws ioexception { resp . setheader ( www_authenticate , str_ + realm + str_ ) ; resp . senderror ( httpservletresponse . sc_unauthorized ) ; }	Sends correct headers to require basic authentication for the given realm.
public static void preparedownload ( final httpservletresponse response , final file file , final string mimetype ) { if ( ! file . exists ( ) ) { throw new illegalargumentexception ( str_ + file ) ; } if ( file . length ( ) > integer . max_value ) { throw new illegalargumentexception ( str_ + file ) ; } prepareresponse ( response , file . getabsolutepath ( ) , mimetype , ( int ) file . length ( ) ) ; }	Prepares response for file download with provided mime type.
public static void prepareresponse ( final httpservletresponse response , final string filename , string mimetype , final int filesize ) { if ( ( mimetype == null ) && ( filename != null ) ) { string extension = filenameutil . getextension ( filename ) ; mimetype = mimetypes . getmimetype ( extension ) ; } if ( mimetype != null ) { response . setcontenttype ( mimetype ) ; } if ( filesize >= num_ ) { response . setcontentlength ( filesize ) ; }	Prepares response for various provided data.
public static cookie [ ] getallcookies ( final httpservletrequest request , final string cookiename ) { cookie [ ] cookies = request . getcookies ( ) ; if ( cookies == null ) { return null ; } arraylist < cookie > list = new arraylist < > ( cookies . length ) ; for ( cookie cookie : cookies ) { if ( cookie . getname ( ) . equals ( cookiename ) ) { list . add ( cookie ) ; } } if ( list . isempty ( ) ) { return null ; } return list . toarray ( new cookie [ num_ ] ) ; }	Returns all cookies from client that matches provided name.
public static string readrequestbodyfromreader ( final httpservletrequest request ) throws ioexception { bufferedreader buff = request . getreader ( ) ; stringwriter out = new stringwriter ( ) ; streamutil . copy ( buff , out ) ; return out . tostring ( ) ; }	Reads HTTP request body using the request reader. Once body is read,it cannot be read again!.
public static string readrequestbodyfromstream ( final httpservletrequest request ) throws ioexception { string charencoding = request . getcharacterencoding ( ) ; if ( charencoding == null ) { charencoding = joddcore . encoding ; } chararraywriter chararraywriter = new chararraywriter ( ) ; bufferedreader bufferedreader = null ; try { inputstream inputstream = request . getinputstream ( ) ; if ( inputstream != null ) { bufferedreader = new bufferedreader ( new inputstreamreader ( inputstream , charencoding ) ) ; streamutil . copy ( bufferedreader , chararraywriter ) ; } else { return stringpool . empty ; } } finally { streamutil . close ( bufferedreader ) ; } return chararraywriter . tostring ( ) ; }	Reads HTTP request body using the request stream. Once body is read,it cannot be read again!.
public static void storecontextpath ( final pagecontext pagecontext , final string contextpathvariablename ) { string ctxpath = getcontextpath ( pagecontext ) ; httpservletrequest request = ( httpservletrequest ) pagecontext . getrequest ( ) ; request . setattribute ( contextpathvariablename , ctxpath ) ; servletcontext servletcontext = pagecontext . getservletcontext ( ) ; servletcontext . setattribute ( contextpathvariablename , ctxpath ) ; }	Stores context path in server context and request scope.
public static void storecontextpath ( final servletcontext servletcontext , final string contextpathvariablename ) { string ctxpath = getcontextpath ( servletcontext ) ; servletcontext . setattribute ( contextpathvariablename , ctxpath ) ; }	Stores context path in page context and request scope.
public boolean isgetparameter ( final httpservletrequest request , string name ) { name = urlcoder . encodequeryparam ( name ) + str_ ; string query = request . getquerystring ( ) ; string [ ] namevaluepairs = stringutil . splitc ( query , str_ ) ; for ( string namevaluepair : namevaluepairs ) { if ( namevaluepair . startswith ( name ) ) { return bool_ ; } } return bool_ ; }	Checks if some parameter is in GET parameters.
public static string [ ] prepareparameters ( final string [ ] paramvalues , final boolean treatemptyparamsasnull , final boolean ignoreemptyrequestparams ) { if ( treatemptyparamsasnull || ignoreemptyrequestparams ) { int emptycount = num_ ; int total = paramvalues . length ; for ( int i = num_ ; i < paramvalues . length ; i ++ ) { string paramvalue = paramvalues [ i ] ; if ( paramvalue == null ) { emptycount ++ ; continue ; } if ( paramvalue . length ( ) == num_ ) { emptycount ++ ; if ( treatemptyparamsasnull ) { paramvalue = null ; } } paramvalues [ i ] = paramvalue ; } if ( ( ignoreemptyrequestparams ) && ( emptycount == total ) ) { return null ; } } return paramvalues ; }	Prepares parameters for further processing.
public static void copyparamstoattributes ( final httpservletrequest servletrequest , final boolean treatemptyparamsasnull , final boolean ignoreemptyrequestparams ) { enumeration paramnames = servletrequest . getparameternames ( ) ; while ( paramnames . hasmoreelements ( ) ) { string paramname = ( string ) paramnames . nextelement ( ) ; if ( servletrequest . getattribute ( paramname ) != null ) { continue ; } string [ ] paramvalues = servletrequest . getparametervalues ( paramname ) ; paramvalues = prepareparameters ( paramvalues , treatemptyparamsasnull , ignoreemptyrequestparams ) ; if ( paramvalues == null ) { continue ; } servletrequest . setattribute ( paramname , paramvalues . length == num_ ? paramvalues [ num_ ] : paramvalues ) ; }	Copies all request parameters to attributes.
public static void invokebody ( final jspfragment body ) throws jspexception { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( ioexception ioex ) { throw new jspexception ( str_ , ioex ) ; } }	Invokes tag body.
public static char [ ] renderbody ( final jspfragment body ) throws jspexception { fastchararraywriter writer = new fastchararraywriter ( ) ; invokebody ( body , writer ) ; return writer . tochararray ( ) ; }	Renders tag body to char array.
public static string renderbodytostring ( final jspfragment body ) throws jspexception { char [ ] result = renderbody ( body ) ; return new string ( result ) ; }	Renders tag body to string.
public void invokeinitmethods ( final initmethodinvocationstrategy invocationstrategy ) { for ( final initmethodpoint initmethod : beandefinition . initmethodpoints ( ) ) { if ( invocationstrategy != initmethod . invocationstrategy ) { continue ; } try { initmethod . method . invoke ( bean ) ; } catch ( exception ex ) { throw new petiteexception ( str_ + initmethod , ex ) ; } } }	Invokes init methods.
public void calldestroymethods ( ) { for ( final destroymethodpoint destroymethodpoint : beandefinition . destroymethodpoints ( ) ) { try { destroymethodpoint . method . invoke ( bean ) ; } catch ( exception ex ) { throw new petiteexception ( str_ + destroymethodpoint . method , ex ) ; } } }	Calls destroy methods on given BeanData.
public object newbeaninstance ( ) { if ( beandefinition . ctor == ctorinjectionpoint . empty ) { throw new petiteexception ( str_ + beandefinition . type . getname ( ) ) ; } int paramno = beandefinition . ctor . references . length ; object [ ] args = new object [ paramno ] ;	Creates a new instance.
public void injectparams ( final parammanager parammanager , final boolean implicitparaminjection ) { if ( beandefinition . name == null ) { return ; } if ( implicitparaminjection ) {	Injects all parameters.
@ suppresswarnings ( { str_ } ) public string rewrite ( final httpservletrequest servletrequest , final string actionpath , final string httpmethod ) { return actionpath ; }	Rewrites action path.
public void addheader ( final string name , final string value ) { list < string > valueslist = super . getall ( name ) ; if ( valueslist . isempty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valueslist . add ( value ) ; super . addall ( name , valueslist ) ; }	Adds new header value.
protected void put ( final string profile , final map < string , propsentry > map , final string key , final string value , final boolean append ) { string realvalue = value ; if ( append || appendduplicateprops ) { propsentry pv = map . get ( key ) ; if ( pv != null ) { realvalue = pv . value + append_separator + realvalue ; } } propsentry propsentry = new propsentry ( key , realvalue , profile , this ) ;	Puts key-value pair into the map, with respect of appending duplicate properties.
public void putbaseproperty ( final string key , final string value , final boolean append ) { put ( null , baseproperties , key , value , append ) ; }	Adds base property.
public void putprofileproperty ( final string key , final string value , final string profile , final boolean append ) { map < string , propsentry > map = profileproperties . computeifabsent ( profile , k -> new hashmap < > ( ) ) ; put ( profile , map , key , value , append ) ; }	Adds profile property.
public propsentry getprofileproperty ( final string profile , final string key ) { final map < string , propsentry > profilemap = profileproperties . get ( profile ) ; if ( profilemap == null ) { return null ; } return profilemap . get ( key ) ; }	Returns profile property.
public string resolvemacros ( string value , final string ... profiles ) {	Resolves all macros in this props set.
public map extract ( map target , final string [ ] profiles , final string [ ] wildcardpatterns , string prefix ) { if ( target == null ) { target = new hashmap ( ) ; }	Extracts props to target map.
private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = num_ ; int off = offp [ num_ ] ; for ( i = num_ ; i < num_ ; i ++ ) { word = ( word << num_ ) | ( data [ off ] & num_ ) ; off = ( off + num_ ) % data . length ; } offp [ num_ ] = off ; return word ; }	Cycically extract a word of key material.
public static string hashpw ( string password , string salt ) { bcrypt b ; string real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) num_ ; int rounds , off ; stringbuffer rs = new stringbuffer ( ) ; if ( salt . charat ( num_ ) != str_ || salt . charat ( num_ ) != str_ ) { throw new illegalargumentexception ( str_ ) ; } if ( salt . charat ( num_ ) == str_ ) { off = num_ ; } else { minor = salt . charat ( num_ ) ; if ( minor != str_ || salt . charat ( num_ ) != str_ ) { throw new illegalargumentexception ( str_ ) ; } off = num_ ; }	Hash a password using the OpenBSD bcrypt scheme.
public static boolean checkpw ( string plaintext , string hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { string try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getbytes ( str_ ) ; try_bytes = try_pw . getbytes ( str_ ) ; } catch ( unsupportedencodingexception uee ) { return bool_ ; } if ( hashed_bytes . length != try_bytes . length ) { return bool_ ; } byte ret = num_ ; for ( int i = num_ ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == num_ ; }	Check that a plaintext password matches a previously hashedone.
public int copyall ( final outputstream out ) throws ioexception { int count = num_ ; while ( bool_ ) { byte b = readbyte ( ) ; if ( isboundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }	Copies bytes from this stream to some output until boundary isreached.
public int copymax ( final outputstream out , final int maxbytes ) throws ioexception { int count = num_ ; while ( bool_ ) { byte b = readbyte ( ) ; if ( isboundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxbytes ) { return count ; } } return count ; }	Copies max or less number of bytes to output stream.
public actionruntime parse ( final class < ? > actionclass , final method actionmethod , actiondefinition actiondefinition ) { final actionannotationvalues annotationvalues = detectactionannotationvalues ( actionmethod ) ; final actionconfig actionconfig = resolveactionconfig ( annotationvalues ) ;	Parses java action method annotation and returns its action runtime.
protected actionconfig resolveactionconfig ( final actionannotationvalues annotationvalues ) { final class < ? extends annotation > annotationtype ; if ( annotationvalues == null ) { annotationtype = action . class ; } else { annotationtype = annotationvalues . annotationtype ( ) ; } return actionconfigmanager . lookup ( annotationtype ) ; }	Resolves action config.
protected void detectandregisteralias ( final actionannotationvalues annotationvalues , final actiondefinition actiondefinition ) { final string alias = parsemethodalias ( annotationvalues ) ; if ( alias != null ) { string aliaspath = stringutil . cuttoindexof ( actiondefinition . actionpath ( ) , stringpool . hash ) ; actionsmanager . registerpathalias ( alias , aliaspath ) ; } }	Detects if alias is defined in annotation and registers it if so.
protected class < ? extends actioninterceptor > [ ] readactioninterceptors ( final annotatedelement actionclassormethod ) { class < ? extends actioninterceptor > [ ] result = null ; interceptedby interceptedby = actionclassormethod . getannotation ( interceptedby . class ) ; if ( interceptedby != null ) { result = interceptedby . value ( ) ; if ( result . length == num_ ) { result = null ; } } return result ; }	Reads class or method annotation for action interceptors.
protected class < ? extends actionfilter > [ ] readactionfilters ( final annotatedelement actionclassormethod ) { class < ? extends actionfilter > [ ] result = null ; filteredby filteredby = actionclassormethod . getannotation ( filteredby . class ) ; if ( filteredby != null ) { result = filteredby . value ( ) ; if ( result . length == num_ ) { result = null ; } } return result ; }	Reads class or method annotation for action filters.
protected string [ ] readpackageactionpath ( final class actionclass ) { package actionpackage = actionclass . getpackage ( ) ; final string actionpackagename = actionpackage . getname ( ) ;	Reads action path for package.If annotation is not set on package-level, class package will be used forpackage action path part.
protected string [ ] readmethodactionpath ( final string methodname , final actionannotationvalues annotationvalues , final actionconfig actionconfig ) {	Reads action path from the action method.
protected string parsemethodalias ( final actionannotationvalues annotationvalues ) { string alias = null ; if ( annotationvalues != null ) { alias = annotationvalues . alias ( ) ; } return alias ; }	Reads method's alias value.
public actionruntime createactionruntime ( final actionhandler actionhandler , final class actionclass , final method actionclassmethod , final class < ? extends actionresult > actionresult , final class < ? extends actionresult > defaultactionresult , final actionfilter [ ] filters , final actioninterceptor [ ] interceptors , final actiondefinition actiondefinition , final boolean async , final boolean auth ) { if ( actionhandler != null ) { return new actionruntime ( actionhandler , actionclass , actionclassmethod , filters , interceptors , actiondefinition , noneactionresult . class , noneactionresult . class , async , auth , null , null ) ; } final scopedata scopedata = scopedatainspector . inspectclassscopes ( actionclass ) ;	Creates new instance of action runtime configuration.Initialize caches.
@ override protected void preresponsecommit ( ) { long lastmodified = lastmodifieddata . getlastmodified ( ) ; long ifmodifiedsince = request . getdateheader ( str_ ) ; if ( lastmodified > - num_ && ! response . containsheader ( str_ ) ) { if ( ifmodifiedsince < ( lastmodified / num_ * num_ ) ) { response . setdateheader ( str_ , lastmodified ) ; } else { response . reset ( ) ; response . setstatus ( httpservletresponse . sc_not_modified ) ; } } }	todo move to BufferResponseWrapper ?.
public static < t > t applyadvice ( final class < t > targetclass ) { class adviceclass = cache . get ( targetclass ) ; if ( adviceclass == null ) {	Applies advice on given target class and returns proxy instance.
public static void injecttargetintoproxy ( final object proxy , final object target ) { class proxyclass = proxy . getclass ( ) ; try { field field = proxyclass . getfield ( str_ ) ; field . set ( proxy , target ) ; } catch ( exception ex ) { throw new proxettaexception ( ex ) ; } }	Injects target into proxy.
public annotationvisitor visitannotation ( final string descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitannotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of the field.
public string resolverealname ( final string jsonname ) { if ( jsonnames == null ) { return jsonname ; } int jsonindex = arraysutil . indexof ( jsonnames , jsonname ) ; if ( jsonindex == - num_ ) { return jsonname ; } return realnames [ jsonindex ] ; }	Resolves real name from JSON name.
public string resolvejsonname ( final string realname ) { if ( realnames == null ) { return realname ; } int realindex = arraysutil . indexof ( realnames , realname ) ; if ( realindex == - num_ ) { return realname ; } return jsonnames [ realindex ] ; }	Resolves JSON name from real name.
public typedata lookuptypedata ( final class type ) { typedata typedata = typedatamap . get ( type ) ; if ( typedata == null ) { if ( serializationsubclassaware ) { typedata = findsubclasstypedata ( type ) ; } if ( typedata == null ) { typedata = scanclassforannotations ( type ) ; typedatamap . put ( type , typedata ) ; } } return typedata ; }	Returns all includes for given type.
protected typedata _lookuptypedata ( final class type ) { typedata typedata = typedatamap . get ( type ) ; if ( typedata == null ) { typedata = scanclassforannotations ( type ) ; typedatamap . put ( type , typedata ) ; } return typedata ; }	Lookups type data and creates one if missing.
protected typedata findsubclasstypedata ( final class type ) { final class < ? extends annotation > defaultannotation = jsonannotation ; if ( type . getannotation ( defaultannotation ) != null ) {	Finds type data of first annotated superclass or interface.
public string resolvejsonname ( final class type , final string name ) { typedata typedata = lookuptypedata ( type ) ; return typedata . resolvejsonname ( name ) ; }	Returns different name of a property if set by annotation.
public string resolverealname ( final class type , final string jsonname ) { typedata typedata = lookuptypedata ( type ) ; return typedata . resolverealname ( jsonname ) ; }	Returns real property name for given JSON property.
@ override public byte [ ] getfilecontent ( ) throws ioexception { if ( data != null ) { return data ; } if ( tempfile != null ) { return fileutil . readbytes ( tempfile ) ; } return null ; }	Returns the content of file upload item.
private void copybootstrapmethods ( final classreader classreader , final char [ ] charbuffer ) {	Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries ofthe SymbolTable.
int setmajorversionandclassname ( final int majorversion , final string classname ) { this . majorversion = majorversion ; this . classname = classname ; return addconstantclass ( classname ) . index ; }	Sets the major version and the name of the class to which this symbol table belongs.
void putconstantpool ( final bytevector output ) { output . putshort ( constantpoolcount ) . putbytearray ( constantpool . data , num_ , constantpool . length ) ; }	Puts this symbol table's constant_pool array in the given ByteVector, preceded by theconstant_pool_count value.
void putbootstrapmethods ( final bytevector output ) { if ( bootstrapmethods != null ) { output . putshort ( addconstantutf8 ( constants . bootstrap_methods ) ) . putint ( bootstrapmethods . length + num_ ) . putshort ( bootstrapmethodcount ) . putbytearray ( bootstrapmethods . data , num_ , bootstrapmethods . length ) ; } }	Puts this symbol table's BootstrapMethods attribute in the given ByteVector.
symbol addconstantfieldref ( final string owner , final string name , final string descriptor ) { return addconstantmemberreference ( symbol . constant_fieldref_tag , owner , name , descriptor ) ; }	Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table.
symbol addconstantmethodref ( final string owner , final string name , final string descriptor , final boolean isinterface ) { int tag = isinterface ? symbol . constant_interface_methodref_tag : symbol . constant_methodref_tag ; return addconstantmemberreference ( tag , owner , name , descriptor ) ; }	Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of thissymbol table.
private entry addconstantmemberreference ( final int tag , final string owner , final string name , final string descriptor ) { int hashcode = hash ( tag , owner , name , descriptor ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantpool . put122 ( tag , addconstantclass ( owner ) . index , addconstantnameandtype ( name , descriptor ) ) ; return put ( new entry ( constantpoolcount ++ , tag , owner , name , descriptor , num_ , hashcode ) ) ; }	Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info tothe constant pool of this symbol table.
private void addconstantmemberreference ( final int index , final int tag , final string owner , final string name , final string descriptor ) { add ( new entry ( index , tag , owner , name , descriptor , num_ , hash ( tag , owner , name , descriptor ) ) ) ; }	Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_infoto the constant pool of this symbol table.
private symbol addconstantintegerorfloat ( final int tag , final int value ) { int hashcode = hash ( tag , value ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . data == value ) { return entry ; } entry = entry . next ; } constantpool . putbyte ( tag ) . putint ( value ) ; return put ( new entry ( constantpoolcount ++ , tag , value , hashcode ) ) ; }	Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.Does nothing if the constant pool already contains a similar item.
private void addconstantintegerorfloat ( final int index , final int tag , final int value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symboltable.
private symbol addconstantlongordouble ( final int tag , final long value ) { int hashcode = hash ( tag , value ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantpoolcount ; constantpool . putbyte ( tag ) . putlong ( value ) ; constantpoolcount += num_ ; return put ( new entry ( index , tag , value , hashcode ) ) ; }	Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.Does nothing if the constant pool already contains a similar item.
private void addconstantlongordouble ( final int index , final int tag , final long value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symboltable.
int addconstantnameandtype ( final string name , final string descriptor ) { final int tag = symbol . constant_name_and_type_tag ; int hashcode = hash ( tag , name , descriptor ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantpool . put122 ( tag , addconstantutf8 ( name ) , addconstantutf8 ( descriptor ) ) ; return put ( new entry ( constantpoolcount ++ , tag , name , descriptor , hashcode ) ) . index ; }	Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table.
private void addconstantnameandtype ( final int index , final string name , final string descriptor ) { final int tag = symbol . constant_name_and_type_tag ; add ( new entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }	Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.
int addconstantutf8 ( final string value ) { int hashcode = hash ( symbol . constant_utf8_tag , value ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == symbol . constant_utf8_tag && entry . hashcode == hashcode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantpool . putbyte ( symbol . constant_utf8_tag ) . pututf8 ( value ) ; return put ( new entry ( constantpoolcount ++ , symbol . constant_utf8_tag , value , hashcode ) ) . index ; }	Adds a CONSTANT_Utf8_info to the constant pool of this symbol table.
private void addconstantutf8 ( final int index , final string value ) { add ( new entry ( index , symbol . constant_utf8_tag , value , hash ( symbol . constant_utf8_tag , value ) ) ) ; }	Adds a new CONSTANT_String_info to the constant pool of this symbol table.
private void addconstantmethodhandle ( final int index , final int referencekind , final string owner , final string name , final string descriptor ) { final int tag = symbol . constant_method_handle_tag ; int hashcode = hash ( tag , owner , name , descriptor , referencekind ) ; add ( new entry ( index , tag , owner , name , descriptor , referencekind , hashcode ) ) ; }	Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.
symbol addconstantdynamic ( final string name , final string descriptor , final handle bootstrapmethodhandle , final object ... bootstrapmethodarguments ) { symbol bootstrapmethod = addbootstrapmethod ( bootstrapmethodhandle , bootstrapmethodarguments ) ; return addconstantdynamicorinvokedynamicreference ( symbol . constant_dynamic_tag , name , descriptor , bootstrapmethod . index ) ; }	Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table.
symbol addconstantinvokedynamic ( final string name , final string descriptor , final handle bootstrapmethodhandle , final object ... bootstrapmethodarguments ) { symbol bootstrapmethod = addbootstrapmethod ( bootstrapmethodhandle , bootstrapmethodarguments ) ; return addconstantdynamicorinvokedynamicreference ( symbol . constant_invoke_dynamic_tag , name , descriptor , bootstrapmethod . index ) ; }	Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table.
private symbol addconstantdynamicorinvokedynamicreference ( final int tag , final string name , final string descriptor , final int bootstrapmethodindex ) { int hashcode = hash ( tag , name , descriptor , bootstrapmethodindex ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . data == bootstrapmethodindex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantpool . put122 ( tag , bootstrapmethodindex , addconstantnameandtype ( name , descriptor ) ) ; return put ( new entry ( constantpoolcount ++ , tag , null , name , descriptor , bootstrapmethodindex , hashcode ) ) ; }	Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symboltable.
private void addconstantdynamicorinvokedynamicreference ( final int tag , final int index , final string name , final string descriptor , final int bootstrapmethodindex ) { int hashcode = hash ( tag , name , descriptor , bootstrapmethodindex ) ; add ( new entry ( index , tag , null , name , descriptor , bootstrapmethodindex , hashcode ) ) ; }	Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of thissymbol table.
private symbol addconstantutf8reference ( final int tag , final string value ) { int hashcode = hash ( tag , value ) ; entry entry = get ( hashcode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashcode == hashcode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantpool . put12 ( tag , addconstantutf8 ( value ) ) ; return put ( new entry ( constantpoolcount ++ , tag , value , hashcode ) ) ; }	Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
private void addconstantutf8reference ( final int index , final int tag , final string value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
symbol addbootstrapmethod ( final handle bootstrapmethodhandle , final object ... bootstrapmethodarguments ) { bytevector bootstrapmethodsattribute = bootstrapmethods ; if ( bootstrapmethodsattribute == null ) { bootstrapmethodsattribute = bootstrapmethods = new bytevector ( ) ; }	Adds a bootstrap method to the BootstrapMethods attribute of this symbol table.
int addmergedtype ( final int typetableindex1 , final int typetableindex2 ) {	Adds a merged type in the type table of this symbol table.
private int hash ( final string name ) { int h = num_ ; for ( int i = name . length ( ) - num_ ; i >= num_ ; i -- ) { char c = name . charat ( i ) ; if ( ! casesensitive ) { if ( c >= str_ && c <= str_ ) { c += num_ ; } } h = num_ * h + c ; } if ( h > num_ ) { return h ; } if ( h == integer . min_value ) { return integer . max_value ; } return - h ; }	Calculates hash value of the input string.
public httpmultimap < v > clear ( ) { for ( int i = num_ ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }	Clears the map.
public list < v > getall ( final string name ) { linkedlist < v > values = new linkedlist < > ( ) ; int h = hash ( name ) ; int i = index ( h ) ; mapentry < v > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addfirst ( e . getvalue ( ) ) ; } e = e . next ; } return values ; }	Returns all values associated with the name.
@ override public iterator < map . entry < string , v > > iterator ( ) { final mapentry [ ] e = { head . after } ; return new iterator < map . entry < string , v > > ( ) { @ override public boolean hasnext ( ) { return e [ num_ ] != head ; } @ override @ suppresswarnings ( str_ ) public map . entry < string , v > next ( ) { if ( ! hasnext ( ) ) { throw new nosuchelementexception ( str_ ) ; } mapentry < v > next = e [ num_ ] ; e [ num_ ] = e [ num_ ] . after ; return next ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; }	Returns iterator of all entries.
public list < map . entry < string , v > > entries ( ) { list < map . entry < string , v > > all = new linkedlist < > ( ) ; mapentry < v > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }	Returns all the entries of this map.
private void grow ( final int mincapacity ) { final int oldcapacity = buffer . length ; int newcapacity = oldcapacity << num_ ; if ( newcapacity - mincapacity < num_ ) {	Grows the buffer.
@ override public fastcharbuffer append ( final charsequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charat ( i ) ) ; } return this ; }	Appends character sequence to buffer.
@ override public annotationvisitor visitannotation ( final string desc , final boolean visible ) { annotationvisitor destann = methodvisitor . visitannotation ( desc , visible ) ;	Copies target method annotations.
@ override public void visitend ( ) { createfirstchaindelegate_continue ( tmd ) ; for ( int p = num_ ; p < tmd . proxydata . length ; p ++ ) { tmd . selectcurrentproxy ( p ) ; createproxymethod ( tmd ) ; } }	Finally, builds proxy methods if applied to current method.
protected void createfirstchaindelegate_start ( ) {	Starts creation of first chain delegate.
protected void createfirstchaindelegate_continue ( final targetmethoddata tmd ) { methodvisitor . visitcode ( ) ; if ( tmd . msign . isstatic ) { loadstaticmethodarguments ( methodvisitor , tmd . msign ) ; methodvisitor . visitmethodinsn ( invokestatic , wd . thisreference , tmd . firstmethodname ( ) , tmd . msign . getdescription ( ) , bool_ ) ; } else { loadspecialmethodarguments ( methodvisitor , tmd . msign ) ; methodvisitor . visitmethodinsn ( invokespecial , wd . thisreference , tmd . firstmethodname ( ) , tmd . msign . getdescription ( ) , bool_ ) ; } visitreturn ( methodvisitor , tmd . msign , bool_ ) ; methodvisitor . visitmaxs ( num_ , num_ ) ; methodvisitor . visitend ( ) ; }	Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.This method mirrors the target method.
public static path parse ( final string path ) { return path == null ? new path ( ) : new path ( stringutil . splitc ( path , str_ ) ) ; }	Parses input dot-separated string that represents a path.
public path push ( final charsequence field ) { _push ( field ) ; if ( altpath != null ) { altpath . push ( field ) ; } return this ; }	Push element to the path.
private void configureservletcontext ( final servletcontext servletcontext ) { servletcontext . addlistener ( jodd . servlet . requestcontextlistener . class ) ; if ( decoraenabled ) { final filterregistration filter = servletcontext . addfilter ( str_ , jodd . decora . decoraservletfilter . class ) ; filter . addmappingforurlpatterns ( null , bool_ , contextpath ) ; } final filterregistration filter = servletcontext . addfilter ( str_ , jodd . madvoc . madvocservletfilter . class ) ; filter . addmappingforurlpatterns ( madvocdispatchertypes , bool_ , contextpath ) ; }	Configures servlet context.
public object execute ( ) { string methodname = targetmethodname ( ) ; class returntype = returntype ( ) ; object next = pathref . continuewith ( this , methodname , returntype ) ; return proxytarget . returnvalue ( next ) ; }	Reads method name and appends it.
public fielddescriptor [ ] getallfielddescriptors ( ) { if ( allfields == null ) { fielddescriptor [ ] allfields = new fielddescriptor [ fieldsmap . size ( ) ] ; int index = num_ ; for ( fielddescriptor fielddescriptor : fieldsmap . values ( ) ) { allfields [ index ] = fielddescriptor ; index ++ ; } arrays . sort ( allfields , comparator . comparing ( fd -> fd . getfield ( ) . getname ( ) ) ) ; this . allfields = allfields ; } return allfields ; }	Returns all fields of this collection.
@ suppresswarnings ( str_ ) @ override protected < t > beandefinition < t > createbeandefinitionforregistration ( final string name , class < t > type , final scope scope , final wiringmode wiringmode , final consumer < t > consumer ) { if ( proxetta != null ) { final class originaltype = type ; final proxettafactory builder = proxetta . proxy ( ) ; builder . settarget ( type ) ; type = builder . define ( ) ; return new proxettabeandefinition ( name , type , scope , wiringmode , originaltype , proxetta . getaspects ( new proxyaspect [ num_ ] ) , consumer ) ; } return super . createbeandefinitionforregistration ( name , type , scope , wiringmode , consumer ) ; }	Applies proxetta on bean class before bean registration.
public static dbtransactionmode converttodbmode ( final jtxtransactionmode txmode ) { final int isolation ; switch ( txmode . getisolationlevel ( ) ) { case isolation_default : isolation = dbtransactionmode . isolation_default ; break ; case isolation_none : isolation = dbtransactionmode . isolation_none ; break ; case isolation_read_committed : isolation = dbtransactionmode . isolation_read_committed ; break ; case isolation_read_uncommitted : isolation = dbtransactionmode . isolation_read_uncommitted ; break ; case isolation_repeatable_read : isolation = dbtransactionmode . isolation_repeatable_read ; break ; case isolation_serializable : isolation = dbtransactionmode . isolation_serializable ; break ; default : throw new illegalargumentexception ( ) ; } return new dbtransactionmode ( isolation , txmode . isreadonly ( ) ) ; }	Converter JTX transaction mode to DB transaction mode.
private object readproperty ( final object source , final propertydescriptor propertydescriptor ) { getter getter = propertydescriptor . getgetter ( declared ) ; if ( getter != null ) { try { return getter . invokegetter ( source ) ; } catch ( exception ex ) { throw new jsonexception ( ex ) ; } } return null ; }	Reads property using property descriptor.
@ override public void putall ( final map t ) { for ( object o : t . entryset ( ) ) { map . entry e = ( map . entry ) o ; put ( e . getkey ( ) , e . getvalue ( ) ) ; } }	Copies all of the mappings from the specified map to this one.These mappings replace any mappings that this map had for any of thekeys currently in the specified Map.
public buffer append ( final buffer buffer ) { if ( buffer . list . isempty ( ) ) {	Appends other buffer to this one.
public void writeto ( final writer writer ) throws ioexception { for ( object o : list ) { if ( o instanceof fastbytebuffer ) { fastbytebuffer fastbytebuffer = ( fastbytebuffer ) o ; byte [ ] array = fastbytebuffer . toarray ( ) ; writer . write ( new string ( array , stringpool . iso_8859_1 ) ) ; } else if ( o instanceof uploadable ) { uploadable uploadable = ( uploadable ) o ; inputstream inputstream = uploadable . openinputstream ( ) ; try { streamutil . copy ( inputstream , writer , stringpool . iso_8859_1 ) ; } finally { streamutil . close ( inputstream ) ; } } } }	Writes content to the writer.
public void writeto ( final outputstream out ) throws ioexception { for ( object o : list ) { if ( o instanceof fastbytebuffer ) { fastbytebuffer fastbytebuffer = ( fastbytebuffer ) o ; out . write ( fastbytebuffer . toarray ( ) ) ; } else if ( o instanceof uploadable ) { uploadable uploadable = ( uploadable ) o ; inputstream inputstream = uploadable . openinputstream ( ) ; try { streamutil . copy ( inputstream , out ) ; } finally { streamutil . close ( inputstream ) ; } } } }	Writes content to the output stream.
public void writeto ( final outputstream out , final httpprogresslistener progresslistener ) throws ioexception {	Writes content to the output stream, using progress listener to track the sending progress.
public string getstring ( final string key ) { charsequence cs = ( charsequence ) map . get ( key ) ; return cs == null ? null : cs . tostring ( ) ; }	Returns the string value with the specified key.
public integer getinteger ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof integer ) { return ( integer ) number ; } return number . intvalue ( ) ; }	returns the integer value with the specified key.
public long getlong ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof long ) { return ( long ) number ; } return number . longvalue ( ) ; }	Returns the long value with the specified key.
public double getdouble ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof double ) { return ( double ) number ; } return number . doublevalue ( ) ; }	Returns the double value with the specified key.
public float getfloat ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof float ) { return ( float ) number ; } return number . floatvalue ( ) ; }	Returns the float value with the specified key.
@ suppresswarnings ( str_ ) public < t > t getvalue ( final string key ) { t val = ( t ) map . get ( key ) ; if ( val instanceof map ) { return ( t ) new jsonobject ( ( map ) val ) ; } if ( val instanceof list ) { return ( t ) new jsonarray ( ( list ) val ) ; } return val ; }	Returns the value with the specified key, as an object.
public jsonobject put ( final string key , final string value ) { objects . requirenonnull ( key ) ; map . put ( key , value ) ; return this ; }	Puts a string into the JSON object with the specified key.
public void usefolder ( final string foldername ) { closefolderifopened ( folder ) ; try { this . foldername = foldername ; this . folder = getservice ( ) . getfolder ( foldername ) ; try { folder . open ( folder . read_write ) ; } catch ( final mailexception ignore ) { folder . open ( folder . read_only ) ; } } catch ( final messagingexception msgexc ) { throw new mailexception ( str_ + foldername , msgexc ) ; } }	Opens new folder and closes previously opened folder.
receivedemail [ ] receivemessages ( final emailfilter filter , final flags flagstoset , final flags flagstounset , final boolean envelope , final consumer < message [ ] > processedmessageconsumer ) { useandopenfolderifnotset ( ) ; final message [ ] messages ; try { if ( filter == null ) { messages = folder . getmessages ( ) ; } else { messages = folder . search ( filter . getsearchterm ( ) ) ; } if ( messages . length == num_ ) { return receivedemail . empty_array ; } if ( envelope ) { final fetchprofile fetchprofile = new fetchprofile ( ) ; fetchprofile . add ( fetchprofile . item . envelope ) ; fetchprofile . add ( fetchprofile . item . flags ) ; folder . fetch ( messages , fetchprofile ) ; }	The main email receiving method.
public void updateemailflags ( final receivedemail receivedemail ) { useandopenfolderifnotset ( ) ; try { folder . setflags ( new int [ ] { receivedemail . messagenumber ( ) } , receivedemail . flags ( ) , bool_ ) ; } catch ( messagingexception mex ) { throw new mailexception ( str_ , mex ) ; } }	Updates the email flags on the server.
protected void closefolderifopened ( final folder folder ) { if ( folder != null ) { try { folder . close ( bool_ ) ; } catch ( final messagingexception ignore ) { } } }	Closes folder if opened and expunge deleted messages.
dbquerynamedparameter lookupnamedparameter ( final string name ) { dbquerynamedparameter p = rootnp ; while ( p != null ) { if ( p . equalsname ( name ) ) { return p ; } p = p . next ; } return null ; }	Lookup for named parameter.
protected boolean validateaction ( final string ... profiles ) { preparevalidator ( ) ; vtor . useprofiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetprofiles ( ) ; list < violation > violations = vtor . getviolations ( ) ; return violations == null ; }	Validates action. Profiles are reset after the invocation.
protected void addviolation ( final string name , final object invalidvalue ) { preparevalidator ( ) ; vtor . addviolation ( new violation ( name , this , invalidvalue ) ) ; }	Adds action violation.
public rawdata as ( final string mimeorextension ) { if ( mimeorextension . contains ( stringpool . slash ) ) { this . mimetype = mimeorextension ; } else { this . mimetype = mimetypes . getmimetype ( mimeorextension ) ; } return this ; }	Defines mime type by providing real mime type or just extension!.
public rawdata downloadableas ( final string downloadfilename ) { this . downloadfilename = downloadfilename ; this . mimetype = mimetypes . getmimetype ( filenameutil . getextension ( downloadfilename ) ) ; return this ; }	Defines download file name and mime type from the name extension.
protected t settarget ( final inputstream target ) { asserttargetisnotdefined ( ) ; targetinputstream = target ; targetclass = null ; targetclassname = null ; return _this ( ) ; }	Defines class input stream as a target.
protected t settarget ( final string targetname ) { asserttargetisnotdefined ( ) ; try { targetinputstream = classloaderutil . getclassasstream ( targetname ) ; if ( targetinputstream == null ) { throw new proxettaexception ( str_ + targetname ) ; } targetclassname = targetname ; targetclass = null ; } catch ( ioexception ioex ) { streamutil . close ( targetinputstream ) ; throw new proxettaexception ( str_ + targetname , ioex ) ; } return _this ( ) ; }	Defines class name as a target.Class will not be loaded by classloader!.
public t settarget ( final class target ) { asserttargetisnotdefined ( ) ; try { targetinputstream = classloaderutil . getclassasstream ( target ) ; if ( targetinputstream == null ) { throw new proxettaexception ( str_ + target . getname ( ) ) ; } targetclass = target ; targetclassname = target . getname ( ) ; } catch ( ioexception ioex ) { streamutil . close ( targetinputstream ) ; throw new proxettaexception ( str_ + target . getname ( ) , ioex ) ; } return _this ( ) ; }	Defines class as a target.
protected void process ( ) { if ( targetinputstream == null ) { throw new proxettaexception ( str_ + targetclassname ) ; }	Reads the target and creates destination class.
public byte [ ] create ( ) { process ( ) ; byte [ ] result = tobytearray ( ) ; dumpclassindebugfolder ( result ) ; if ( ( ! proxetta . isforced ( ) ) && ( ! isproxyapplied ( ) ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ + stringutil . tosafestring ( targetclassname ) ) ; } return null ; } if ( log . isdebugenabled ( ) ) { log . debug ( str_ + stringutil . tosafestring ( targetclassname ) ) ; } return result ; }	Returns byte array of created class.
public object newinstance ( ) { class type = define ( ) ; try { return classutil . newinstance ( type ) ; } catch ( exception ex ) { throw new proxettaexception ( str_ , ex ) ; } }	Creates new instance of created class.Assumes default no-arg constructor.
protected void dumpclassindebugfolder ( final byte [ ] bytes ) { file debugfolder = proxetta . getdebugfolder ( ) ; if ( debugfolder == null ) { return ; } if ( ! debugfolder . exists ( ) || ! debugfolder . isdirectory ( ) ) { log . warn ( str_ + debugfolder ) ; } string filename = proxyclassname ; if ( filename == null ) { filename = str_ + system . currenttimemillis ( ) ; } filename += str_ ; file file = new file ( debugfolder , filename ) ; try { fileutil . writebytes ( file , bytes ) ; } catch ( ioexception ioex ) { log . warn ( str_ + file , ioex ) ; } }	Writes created class content to output folder for debugging purposes.
public t from ( final string personalname , final string from ) { return from ( new emailaddress ( personalname , from ) ) ; }	Sets the FROM address by providing personal name and address.
public t to ( final emailaddress to ) { this . to = arraysutil . append ( this . to , to ) ; return _this ( ) ; }	Appends TO address.
public t to ( final string personalname , final string to ) { return to ( new emailaddress ( personalname , to ) ) ; }	Appends TO address by personal name and email address.
public t replyto ( final emailaddress ... replyto ) { this . replyto = arraysutil . join ( this . replyto , valueoremptyarray ( replyto ) ) ; return _this ( ) ; }	Appends REPLY-TO addresses.
public t cc ( final emailaddress ... ccs ) { this . cc = arraysutil . join ( this . cc , valueoremptyarray ( ccs ) ) ; return _this ( ) ; }	Appends CC addresses.
public t textmessage ( final string text , final string encoding ) { return message ( new emailmessage ( text , mimetypes . mime_text_plain , encoding ) ) ; }	Adds plain message text.
public t htmlmessage ( final string html , final string encoding ) { return message ( new emailmessage ( html , mimetypes . mime_text_html , encoding ) ) ; }	Adds HTML message.
public t header ( final string name , final string value ) { headers . put ( name , value ) ; return _this ( ) ; }	Sets header value.
public static string get ( final string name , final string defaultvalue ) { objects . requirenonnull ( name ) ; string value = null ; try { if ( system . getsecuritymanager ( ) == null ) { value = system . getproperty ( name ) ; } else { value = accesscontroller . doprivileged ( ( privilegedaction < string > ) ( ) -> system . getproperty ( name ) ) ; } } catch ( exception ignore ) { } if ( value == null ) { return defaultvalue ; } return value ; }	Returns system property. If key is not available, returns the default value.
public static boolean getboolean ( final string name , final boolean defaultvalue ) { string value = get ( name ) ; if ( value == null ) { return defaultvalue ; } value = value . trim ( ) . tolowercase ( ) ; switch ( value ) { case str_ : case str_ : case str_ : case str_ : return bool_ ; case str_ : case str_ : case str_ : case str_ : return bool_ ; default : return defaultvalue ; } }	Returns system property as boolean.
public static long getint ( final string name , final int defaultvalue ) { string value = get ( name ) ; if ( value == null ) { return defaultvalue ; } value = value . trim ( ) . tolowercase ( ) ; try { return integer . parseint ( value ) ; } catch ( numberformatexception nfex ) { return defaultvalue ; } }	Returns system property as an int.
public static long getlong ( final string name , final long defaultvalue ) { string value = get ( name ) ; if ( value == null ) { return defaultvalue ; } value = value . trim ( ) . tolowercase ( ) ; try { return long . parselong ( value ) ; } catch ( numberformatexception nfex ) { return defaultvalue ; } }	Returns system property as a long.
methodparameter [ ] getresolvedparameters ( ) { if ( paramextractor == null ) { return methodparameter . empty_array ; } if ( ! paramextractor . debuginfopresent ) { throw new paramoexception ( str_ + declaringclass . getname ( ) + str_ + methodname ) ; } return paramextractor . getmethodparameters ( ) ; }	Returns method parameters once when method is parsed.If method has no parameters, an empty array is returned.
protected int serializekeyvalue ( final jsoncontext jsoncontext , final path currentpath , final object key , final object value , int count ) { if ( ( value == null ) && jsoncontext . isexcludenulls ( ) ) { return count ; } if ( key != null ) { currentpath . push ( key . tostring ( ) ) ; } else { currentpath . push ( stringpool . null ) ; }	Serializes key and a value.
protected string lookupalias ( final string alias ) { string value = actionsmanager . lookuppathalias ( alias ) ; if ( value == null ) { actionruntime cfg = actionsmanager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getactionpath ( ) ; } } return value ; }	Lookups value as an alias and, if not found, as a default alias.
protected string resolvealias ( final string value ) { final stringbuilder result = new stringbuilder ( value . length ( ) ) ; int i = num_ ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexof ( str_ , i ) ; if ( ndx == - num_ ) {	Returns resolved alias result value or passed on, if alias doesn't exist.
public resultpath resolveresultpath ( string path , string value ) { boolean absolutepath = bool_ ; if ( value != null ) {	Resolves result path.
public string resolveresultpathstring ( final string path , final string value ) { final resultpath resultpath = resolveresultpath ( path , value ) ; final string result = resultpath . pathvalue ( ) ; return resolvealias ( result ) ; }	Resolves result path as a string, when parts are not importantand when only full string matters.
public static int lastindexofslashdot ( final string str ) { int slashndx = str . lastindexof ( str_ ) ; int dotndx = stringutil . lastindexof ( str , str_ , str . length ( ) , slashndx ) ; if ( dotndx == - num_ ) { if ( slashndx == - num_ ) { return - num_ ; } slashndx ++ ; if ( slashndx < str . length ( ) - num_ ) { dotndx = slashndx ; } else { dotndx = - num_ ; } } return dotndx ; }	Locates last dot after the last slash or just slash.
public static int lastindexofdotafterslash ( final string str ) { int slashndx = str . lastindexof ( str_ ) ; slashndx ++ ; return stringutil . lastindexof ( str , str_ , str . length ( ) , slashndx ) ; }	Locates last index of dot after the optional last slash.
public static int indexofdotafterslash ( final string str ) { int slashndx = str . lastindexof ( str_ ) ; if ( slashndx == - num_ ) { slashndx = num_ ; } return str . indexof ( str_ , slashndx ) ; }	Locates first dot after the last slash.
public static string resolveschemaname ( final class < ? > type , final string defaultschemaname ) { string schemaname = null ; final dbtable dbtable = type . getannotation ( dbtable . class ) ; if ( dbtable != null ) { schemaname = dbtable . schema ( ) . trim ( ) ; } if ( ( schemaname == null ) || ( schemaname . length ( ) == num_ ) ) { schemaname = defaultschemaname ; } return schemaname ; }	Resolves schema name from a type.
public static dbentitycolumndescriptor resolvecolumndescriptors ( final dbentitydescriptor dbentitydescriptor , final propertydescriptor property , final boolean isannotated , final columnnamingstrategy columnnamingstrategy ) { string columnname = null ; boolean isid = bool_ ; class < ? extends sqltype > sqltypeclass = null ;	Resolves column descriptor from property.
public void init ( final long [ ] key , final long [ ] tweak ) { final int newnw = key . length ;	Initialize the cipher using the key and the tweak value.
private void mix ( final int j , final int d ) { y [ num_ ] = x [ num_ ] + x [ num_ ] ; final long rotl = r [ d % depth_of_d_in_r ] [ j ] ;	Implementation of the MIX function.
private void demix ( final int j , final int d ) { y [ num_ ] ^= y [ num_ ] ; final long rotr = r [ d % depth_of_d_in_r ] [ j ] ;	Implementation of the un-MIX function.
private void keyschedule ( final int s ) { for ( int i = num_ ; i < nw ; i ++ ) {	Creates the subkeys.
public void init ( final string keymessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blocksize / byte . size ] ; byte [ ] keydata = stringutil . getbytes ( keymessage ) ; system . arraycopy ( keydata , num_ , key , num_ , key . length < keydata . length ? key . length : keydata . length ) ; init ( bytestolongs ( key ) , tweak ) ; }	Initializes cipher in a simple way.
@ override public byte [ ] encryptblock ( final byte [ ] content , final int offset ) { long [ ] contentblock = bytestolongs ( content , offset , blocksizeinbytes ) ; long [ ] encryptedblock = new long [ blocksize / long . size ] ; blockencrypt ( contentblock , encryptedblock ) ; return longstobytes ( encryptedblock ) ; }	Encrypts a block.
protected static long [ ] bytestolongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size > > num_ ] ; int i8 = offset ; for ( int i = num_ ; i < result . length ; i ++ ) { result [ i ] = bits . getlong ( ba , i8 ) ; i8 += num_ ; } return result ; }	Converts segment of byte array into long array.
private static string removeanybounding ( final char s , final char e , final string str ) { if ( str == null || str . length ( ) < num_ ) { return str ; } if ( str . startswith ( string . valueof ( s ) ) && str . endswith ( string . valueof ( e ) ) ) { return str . substring ( num_ , str . length ( ) - num_ ) ; } return str ; }	If the string starts and ends with start and end char, remove them,otherwise return the string as it was passed in.
public string path ( ) { if ( methref != null ) { final string methodname = methref . ref ( ) ; return target . getname ( ) + str_ + methodname ; } return path ; }	Returns path value.
public static file zlib ( final file file ) throws ioexception { if ( file . isdirectory ( ) ) { throw new ioexception ( str_ ) ; } fileinputstream fis = new fileinputstream ( file ) ; deflater deflater = new deflater ( deflater . best_compression ) ; string zlibfilename = file . getabsolutepath ( ) + zlib_ext ; deflateroutputstream dos = new deflateroutputstream ( new fileoutputstream ( zlibfilename ) , deflater ) ; try { streamutil . copy ( fis , dos ) ; } finally { streamutil . close ( dos ) ; streamutil . close ( fis ) ; } return new file ( zlibfilename ) ; }	Compresses a file into zlib archive.
public static file gzip ( final file file ) throws ioexception { if ( file . isdirectory ( ) ) { throw new ioexception ( str_ ) ; } fileinputstream fis = new fileinputstream ( file ) ; string gzipname = file . getabsolutepath ( ) + gzip_ext ; gzipoutputstream gzos = new gzipoutputstream ( new fileoutputstream ( gzipname ) ) ; try { streamutil . copy ( fis , gzos ) ; } finally { streamutil . close ( gzos ) ; streamutil . close ( fis ) ; } return new file ( gzipname ) ; }	Compresses a file into gzip archive.
public static file ungzip ( final file file ) throws ioexception { string outfilename = filenameutil . removeextension ( file . getabsolutepath ( ) ) ; file out = new file ( outfilename ) ; out . createnewfile ( ) ; fileoutputstream fos = new fileoutputstream ( out ) ; gzipinputstream gzis = new gzipinputstream ( new fileinputstream ( file ) ) ; try { streamutil . copy ( gzis , fos ) ; } finally { streamutil . close ( fos ) ; streamutil . close ( gzis ) ; } return out ; }	Decompress gzip archive.
public static list < string > listzip ( final file zipfile ) throws ioexception { list < string > entries = new arraylist < > ( ) ; zipfile zip = new zipfile ( zipfile ) ; enumeration zipentries = zip . entries ( ) ; while ( zipentries . hasmoreelements ( ) ) { zipentry entry = ( zipentry ) zipentries . nextelement ( ) ; string entryname = entry . getname ( ) ; entries . add ( entryname ) ; } return collections . unmodifiablelist ( entries ) ; }	Lists zip content.
public static void unzip ( final string zipfile , final string destdir , final string ... patterns ) throws ioexception { unzip ( new file ( zipfile ) , new file ( destdir ) , patterns ) ; }	Extracts zip file content to the target directory.
public static void addtozip ( final zipoutputstream zos , final file file , string path , final string comment , final boolean recursive ) throws ioexception { if ( ! file . exists ( ) ) { throw new filenotfoundexception ( file . tostring ( ) ) ; } if ( path == null ) { path = file . getname ( ) ; } while ( path . length ( ) != num_ && path . charat ( num_ ) == str_ ) { path = path . substring ( num_ ) ; } boolean isdir = file . isdirectory ( ) ; if ( isdir ) {	Adds single entry to ZIP output stream.
public static void addtozip ( final zipoutputstream zos , final byte [ ] content , string path , final string comment ) throws ioexception { while ( path . length ( ) != num_ && path . charat ( num_ ) == str_ ) { path = path . substring ( num_ ) ; } if ( stringutil . endswithchar ( path , str_ ) ) { path = path . substring ( num_ , path . length ( ) - num_ ) ; } zipentry zipentry = new zipentry ( path ) ; zipentry . settime ( system . currenttimemillis ( ) ) ; if ( comment != null ) { zipentry . setcomment ( comment ) ; } zos . putnextentry ( zipentry ) ; inputstream is = new bytearrayinputstream ( content ) ; try { streamutil . copy ( is , zos ) ; } finally { streamutil . close ( is ) ; } zos . closeentry ( ) ; }	Adds byte content into the zip as a file.
public fielddescriptor getfielddescriptor ( final string name , final boolean declared ) { final fielddescriptor fielddescriptor = getfields ( ) . getfielddescriptor ( name ) ; if ( fielddescriptor != null ) { if ( ! fielddescriptor . matchdeclared ( declared ) ) { return null ; } } return fielddescriptor ; }	Returns field descriptor.
public propertydescriptor getpropertydescriptor ( final string name , final boolean declared ) { propertydescriptor propertydescriptor = getproperties ( ) . getpropertydescriptor ( name ) ; if ( ( propertydescriptor != null ) && propertydescriptor . matchdeclared ( declared ) ) { return propertydescriptor ; } return null ; }	Returns property descriptor. Declared flag is matched on both read and writemethods.
public static void setrequestbundlename ( final servletrequest request , final string bundlename ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ + bundlename ) ; } request . setattribute ( request_bundle_name_attr , bundlename ) ; }	Sets bundle name for provided servlet request.
public static void setsessionlocale ( final httpsession session , final string localecode ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ + localecode ) ; } locale locale = locale . forlanguagetag ( localecode ) ; session . setattribute ( session_locale_attr , locale ) ; }	Saves Locale to HTTP session.
public static locale getsessionlocale ( final httpsession session ) { locale locale = ( locale ) session . getattribute ( session_locale_attr ) ; return locale == null ? message_resolver . getfallbacklocale ( ) : locale ; }	Returns current locale from session.s.
public string [ ] filterparametersforbeanname ( string beanname , final boolean resolvereferenceparams ) { beanname = beanname + str_ ; list < string > list = new arraylist < > ( ) ; for ( map . entry < string , object > entry : params . entryset ( ) ) { string key = entry . getkey ( ) ; if ( ! key . startswith ( beanname ) ) { continue ; } list . add ( key ) ; if ( ! resolvereferenceparams ) { continue ; }	Returns an array of param keys that belongs to provided bean.Optionally resolves the value of returned parameters.
public propsentries profile ( final string ... profiles ) { if ( profiles == null ) { return this ; } for ( string profile : profiles ) { addprofiles ( profile ) ; } return this ; }	Enables profiles to iterate.
public static long getlonglittleendian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + num_ ] << num_ )	Gets a long from a byte buffer in little endian byte order.
private static byte [ ] readstream ( final inputstream inputstream , final boolean close ) throws ioexception { if ( inputstream == null ) { throw new ioexception ( str_ ) ; } try { bytearrayoutputstream outputstream = new bytearrayoutputstream ( ) ; byte [ ] data = new byte [ input_stream_data_chunk_size ] ; int bytesread ; while ( ( bytesread = inputstream . read ( data , num_ , data . length ) ) != - num_ ) { outputstream . write ( data , num_ , bytesread ) ; } outputstream . flush ( ) ; return outputstream . tobytearray ( ) ; } finally { if ( close ) { inputstream . close ( ) ; } } }	Reads the given input stream and returns its content as a byte array.
protected label readlabel ( final int bytecodeoffset , final label [ ] labels ) { if ( labels [ bytecodeoffset ] == null ) { labels [ bytecodeoffset ] = new label ( ) ; } return labels [ bytecodeoffset ] ; }	Returns the label corresponding to the given bytecode offset.
private int gettypeannotationbytecodeoffset ( final int [ ] typeannotationoffsets , final int typeannotationindex ) { if ( typeannotationoffsets == null || typeannotationindex >= typeannotationoffsets . length || readbyte ( typeannotationoffsets [ typeannotationindex ] ) < typereference . instanceof ) { return - num_ ; } return readunsignedshort ( typeannotationoffsets [ typeannotationindex ] + num_ ) ; }	Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or-1 if there is no such type_annotation of if it does not have a bytecode offset.
private int [ ] readbootstrapmethodsattribute ( final int maxstringlength ) { char [ ] charbuffer = new char [ maxstringlength ] ; int currentattributeoffset = getfirstattributeoffset ( ) ; int [ ] currentbootstrapmethodoffsets = null ; for ( int i = readunsignedshort ( currentattributeoffset - num_ ) ; i > num_ ; -- i ) {	Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
protected ctordescriptor [ ] inspectconstructors ( ) { class type = classdescriptor . gettype ( ) ; constructor [ ] ctors = type . getdeclaredconstructors ( ) ; ctordescriptor [ ] allctors = new ctordescriptor [ ctors . length ] ; for ( int i = num_ ; i < ctors . length ; i ++ ) { constructor ctor = ctors [ i ] ; ctordescriptor ctordescriptor = createctordescriptor ( ctor ) ; allctors [ i ] = ctordescriptor ; if ( ctordescriptor . isdefault ( ) ) { defaultctor = ctordescriptor ; } } return allctors ; }	Inspects all declared constructors of a target type.
public ctordescriptor getctordescriptor ( final class ... args ) { ctors : for ( ctordescriptor ctordescriptor : allctors ) { class [ ] arg = ctordescriptor . getparameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = num_ ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctordescriptor ; } return null ; }	Finds constructor description that matches given argument types.
@ suppresswarnings ( str_ ) protected map < string , transientbeandata > getrequestmap ( final httpservletrequest servletrequest ) { return ( map < string , transientbeandata > ) servletrequest . getattribute ( attr_name ) ; }	Returns instance map from http request.
protected map < string , transientbeandata > createrequestmap ( final httpservletrequest servletrequest ) { map < string , transientbeandata > map = new hashmap < > ( ) ; servletrequest . setattribute ( attr_name , map ) ; return map ; }	Creates instance map and stores it in the request.
protected long [ ] convertarraytoarray ( final object value ) { final class valuecomponenttype = value . getclass ( ) . getcomponenttype ( ) ; final long [ ] result ; if ( valuecomponenttype . isprimitive ( ) ) { result = convertprimitivearraytoarray ( value , valuecomponenttype ) ; } else {	Converts array value to array.
@ override public void init ( final filterconfig filterconfig ) throws servletexception {	Initializes Decora filter. Loads manager and parser from init parameters.
public findfile searchpath ( final uri searchpath ) { file file ; try { file = new file ( searchpath ) ; } catch ( exception ex ) { throw new findfileexception ( str_ + searchpath , ex ) ; } addpath ( file ) ; return this ; }	Specifies the search path.
public findfile searchpath ( final url searchpath ) { file file = fileutil . tocontainerfile ( searchpath ) ; if ( file == null ) { throw new findfileexception ( str_ + searchpath ) ; } addpath ( file ) ; return this ; }	Specifies the search path.
public findfile include ( final string ... patterns ) { for ( string pattern : patterns ) { rules . include ( pattern ) ; } return this ; }	Defines include patterns.
public findfile exclude ( final string ... patterns ) { for ( string pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }	Defines exclude patterns.
protected void addpath ( final file path ) { if ( ! path . exists ( ) ) { return ; } if ( pathlist == null ) { pathlist = new linkedlist < > ( ) ; } pathlist . add ( path ) ; }	Adds existing search path to the file list.Non existing files are ignored.If path is a folder, it will be scanned for all files.
public list < file > findall ( ) { list < file > allfiles = new arraylist < > ( ) ; file file ; while ( ( file = nextfile ( ) ) != null ) { allfiles . add ( file ) ; } return allfiles ; }	Finds all files and returns list of founded files.
protected void init ( ) { rules . detectmode ( ) ; todofiles = new linkedlist < > ( ) ; todofolders = new linkedlist < > ( ) ; if ( pathlist == null ) { pathlist = new linkedlist < > ( ) ; return ; } if ( pathlistoriginal == null ) { pathlistoriginal = ( linkedlist < file > ) pathlist . clone ( ) ; } string [ ] files = new string [ pathlist . size ( ) ] ; int index = num_ ; iterator < file > iterator = pathlist . iterator ( ) ; while ( iterator . hasnext ( ) ) { file file = iterator . next ( ) ; if ( file . isfile ( ) ) { files [ index ++ ] = file . getabsolutepath ( ) ; iterator . remove ( ) ; } } if ( index != num_ ) { filesiterator filesiterator = new filesiterator ( files ) ; todofiles . add ( filesiterator ) ; } }	Initializes file walking.Separates input files and folders.
@ override public iterator < file > iterator ( ) { return new iterator < file > ( ) { private file nextfile ; @ override public boolean hasnext ( ) { nextfile = nextfile ( ) ; return nextfile != null ; } @ override public file next ( ) { if ( nextfile == null ) { throw new nosuchelementexception ( ) ; } return nextfile ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; }	Returns file walking iterator.
public wiringmode resolvebeanwiringmode ( final class type ) { petitebean petitebean = ( ( class < ? > ) type ) . getannotation ( petitebean . class ) ; return petitebean != null ? petitebean . wiring ( ) : wiringmode . default ; }	Resolves bean's auto-wire flag from the annotation.
public string resolvebeanname ( final class type , final boolean uselongtypename ) { petitebean petitebean = ( ( class < ? > ) type ) . getannotation ( petitebean . class ) ; string name = null ; if ( petitebean != null ) { name = petitebean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == num_ ) ) { if ( uselongtypename ) { name = type . getname ( ) ; } else { name = stringutil . uncapitalize ( type . getsimplename ( ) ) ; } } return name ; }	Resolves bean's name from bean annotation or type name.
public printwriter getwriter ( ) { if ( outwriter == null ) { if ( outstream != null ) { throw new illegalstateexception ( str_ ) ; } bufferedwriter = new fastchararraywriter ( ) ; outwriter = new printwriter ( bufferedwriter ) { @ override public void close ( ) {	Returns a writer.
public servletoutputstream getoutputstream ( ) { if ( outstream == null ) { if ( outwriter != null ) { throw new illegalstateexception ( str_ ) ; } bufferoutputstream = new fastbytearrayservletoutputstream ( ) ; outstream = bufferoutputstream ; } return outstream ; }	Returns a servlet output stream.
public string getclassname ( ) { switch ( sort ) { case void : return str_ ; case boolean : return str_ ; case char : return str_ ; case byte : return str_ ; case short : return str_ ; case int : return str_ ; case float : return str_ ; case long : return str_ ; case double : return str_ ; case array : stringbuilder stringbuilder = new stringbuilder ( getelementtype ( ) . getclassname ( ) ) ; for ( int i = getdimensions ( ) ; i > num_ ; -- i ) { stringbuilder . append ( str_ ) ; } return stringbuilder . tostring ( ) ; case object : case internal : return valuebuffer . substring ( valuebegin , valueend ) . replace ( str_ , str_ ) ; default : throw new assertionerror ( ) ; } }	Returns the binary name of the class corresponding to this type.
public static string getconstructordescriptor ( final constructor < ? > constructor ) { stringbuilder stringbuilder = new stringbuilder ( ) ; stringbuilder . append ( str_ ) ; class < ? > [ ] parameters = constructor . getparametertypes ( ) ; for ( class < ? > parameter : parameters ) { appenddescriptor ( parameter , stringbuilder ) ; } return stringbuilder . append ( str_ ) . tostring ( ) ; }	Returns the descriptor corresponding to the given constructor.
public static string getmethoddescriptor ( final type returntype , final type ... argumenttypes ) { stringbuilder stringbuilder = new stringbuilder ( ) ; stringbuilder . append ( str_ ) ; for ( type argumenttype : argumenttypes ) { argumenttype . appenddescriptor ( stringbuilder ) ; } stringbuilder . append ( str_ ) ; returntype . appenddescriptor ( stringbuilder ) ; return stringbuilder . tostring ( ) ; }	Returns the descriptor corresponding to the given argument and return types.
public static string getmethoddescriptor ( final method method ) { stringbuilder stringbuilder = new stringbuilder ( ) ; stringbuilder . append ( str_ ) ; class < ? > [ ] parameters = method . getparametertypes ( ) ; for ( class < ? > parameter : parameters ) { appenddescriptor ( parameter , stringbuilder ) ; } stringbuilder . append ( str_ ) ; appenddescriptor ( method . getreturntype ( ) , stringbuilder ) ; return stringbuilder . tostring ( ) ; }	Returns the descriptor corresponding to the given method.
private void appenddescriptor ( final stringbuilder stringbuilder ) { if ( sort == object ) { stringbuilder . append ( valuebuffer , valuebegin - num_ , valueend + num_ ) ; } else if ( sort == internal ) { stringbuilder . append ( str_ ) . append ( valuebuffer , valuebegin , valueend ) . append ( str_ ) ; } else { stringbuilder . append ( valuebuffer , valuebegin , valueend ) ; } }	Appends the descriptor corresponding to this type to the given string buffer.
public int getsize ( ) { switch ( sort ) { case void : return num_ ; case boolean : case char : case byte : case short : case int : case float : case array : case object : case internal : return num_ ; case long : case double : return num_ ; default : throw new assertionerror ( ) ; } }	Returns the size of values of this type.
public static int getargumentsandreturnsizes ( final string methoddescriptor ) { int argumentssize = num_ ;	Computes the size of the arguments and of the return value of a method.
public void setrollbackonly ( final throwable th ) { if ( ! isnotransaction ( ) ) { if ( ( status != status_marked_rollback ) && ( status != status_active ) ) { throw new jtxexception ( str_ ) ; } } rollbackcause = th ; status = status_marked_rollback ; }	Modify the transaction associated with the target object such that the only possible outcomeof the transaction is to roll back the transaction.
protected void commitorrollback ( boolean docommit ) { if ( log . isdebugenabled ( ) ) { if ( docommit ) { log . debug ( str_ ) ; } else { log . debug ( str_ ) ; } } boolean forcedrollback = bool_ ; if ( ! isnotransaction ( ) ) { if ( isrollbackonly ( ) ) { if ( docommit ) { docommit = bool_ ; forcedrollback = bool_ ; } } else if ( ! isactive ( ) ) { if ( iscompleted ( ) ) { throw new jtxexception ( str_ ) ; } throw new jtxexception ( str_ + ( docommit ? str_ : str_ ) ) ; } } if ( docommit ) { commitallresources ( ) ; } else { rollbackallresources ( forcedrollback ) ; } }	Performs either commit or rollback on all transaction resources.
protected void rollbackallresources ( final boolean wasforced ) { status = status_rolling_back ; exception lastexception = null ; iterator < jtxresource > it = resources . iterator ( ) ; while ( it . hasnext ( ) ) { jtxresource resource = it . next ( ) ; try { resource . rollbacktransaction ( ) ; } catch ( exception ex ) { lastexception = ex ; } finally { it . remove ( ) ; } } txmanager . removetransaction ( this ) ; status = status_rolledback ; if ( lastexception != null ) { status = status_unknown ; throw new jtxexception ( str_ , lastexception ) ; } if ( wasforced ) { throw new jtxexception ( str_ , rollbackcause ) ; } }	Rollbacks all attached resources.
public < e > e requestresource ( final class < e > resourcetype ) { if ( iscompleted ( ) ) { throw new jtxexception ( str_ ) ; } if ( isrollbackonly ( ) ) { throw new jtxexception ( str_ , rollbackcause ) ; } if ( ! isnotransaction ( ) && ! isactive ( ) ) { throw new jtxexception ( str_ ) ; } checktimeout ( ) ; e resource = lookupresource ( resourcetype ) ; if ( resource == null ) { int maxresources = txmanager . getmaxresourcespertransaction ( ) ; if ( ( maxresources != - num_ ) && ( resources . size ( ) >= maxresources ) ) { throw new jtxexception ( str_ ) ; } jtxresourcemanager < e > resourcemanager = txmanager . lookupresourcemanager ( resourcetype ) ; resource = resourcemanager . begintransaction ( mode , isactive ( ) ) ; resources . add ( new jtxresource < > ( this , resourcemanager , resource ) ) ; } return resource ; }	Requests a resource. If resource is not found, it will be created and new transaction will be started on it.
protected void popname ( ) { if ( ispushed ) { if ( pushedcomma ) { writecomma ( ) ; } string name = pushedname ; pushedname = null ; ispushed = bool_ ; writename ( name ) ; } }	Writes stored name to JSON string.
public void writestring ( final string value ) { popname ( ) ; write ( stringpool . quote ) ; int len = value . length ( ) ; for ( int i = num_ ; i < len ; i ++ ) { char c = value . charat ( i ) ; switch ( c ) { case str_ : write ( str_ ) ; break ; case str_ : write ( str_ ) ; break ; case str_ : if ( strictstringencoding ) { write ( str_ ) ; } else { write ( c ) ; } break ; case str_ : write ( str_ ) ; break ; case str_ : write ( str_ ) ; break ; case str_ : write ( str_ ) ; break ; case str_ : write ( str_ ) ; break ; case str_ : write ( str_ ) ; break ; default : if ( character . isisocontrol ( c ) ) { unicode ( c ) ; } else { write ( c ) ; } } } write ( stringpool . quote ) ; }	Write a quoted and escaped value to the output.
protected void unicode ( final char c ) { write ( str_ ) ; int n = c ; for ( int i = num_ ; i < num_ ; ++ i ) { int digit = ( n & num_ ) > > num_ ; char hex = charutil . int2hex ( digit ) ; write ( hex ) ; n <<= num_ ; } }	Writes unicode representation of a character.
public void write ( final charsequence charsequence ) { popname ( ) ; try { out . append ( charsequence ) ; } catch ( ioexception ioex ) { throw new jsonexception ( ioex ) ; } }	Appends char sequence to the buffer.
public lagartodombuilderconfig setparsingerrorloglevelname ( string loglevel ) { loglevel = loglevel . trim ( ) . touppercase ( ) ; parsingerrorloglevel = logger . level . valueof ( loglevel ) ; return this ; }	Sets parsing error log level as a name.
public void startregion ( final int start , final int taglen , final int deeplevel ) { this . regionstart = start + taglen ; this . regionlength = num_ ; this . regiontagstart = start ; this . deeplevel = deeplevel ; }	Starts defining region by setting the start index and reset region length to zero.
public boolean iscontaining ( final string include ) { if ( value == null ) { return bool_ ; } if ( splits == null ) { splits = stringutil . splitc ( value , str_ ) ; } for ( string s : splits ) { if ( s . equals ( include ) ) { return bool_ ; } } return bool_ ; }	Returns true if attribute is containing some value.
public static void registerpseudofunction ( final class < ? extends pseudofunction > pseudofunctiontype ) { pseudofunction pseudofunction ; try { pseudofunction = classutil . newinstance ( pseudofunctiontype ) ; } catch ( exception ex ) { throw new cssellyexception ( ex ) ; } pseudo_function_map . put ( pseudofunction . getpseudofunctionname ( ) , pseudofunction ) ; }	Registers pseudo function.
public static pseudofunction < ? > lookuppseudofunction ( final string pseudofunctionname ) { pseudofunction pseudofunction = pseudo_function_map . get ( pseudofunctionname ) ; if ( pseudofunction == null ) { throw new cssellyexception ( str_ + pseudofunctionname ) ; } return pseudofunction ; }	Lookups pseudo function for given pseudo function name.
@ override public void visit ( final int version , int access , final string name , final string signature , final string supername , final string [ ] interfaces ) { wd . init ( name , supername , this . suffix , this . reqproxyclassname ) ;	Creates destination subclass header from current target class.
@ override public annotationvisitor visitannotation ( final string desc , final boolean visible ) { annotationvisitor destann = wd . dest . visitannotation ( desc , visible ) ;	Copies all destination type annotations to the target.
protected void makestaticinitblock ( ) { if ( wd . adviceclinits != null ) { methodvisitor mv = wd . dest . visitmethod ( asmutil . acc_static , clinit , desc_void , null , null ) ; mv . visitcode ( ) ; for ( string name : wd . adviceclinits ) { mv . visitmethodinsn ( invokestatic , wd . thisreference , name , desc_void , bool_ ) ; } mv . visitinsn ( return ) ; mv . visitmaxs ( num_ , num_ ) ; mv . visitend ( ) ; } }	Creates static initialization block that simply calls alladvice static init methods in correct order.
protected void makeproxyconstructor ( ) { methodvisitor mv = wd . dest . visitmethod ( asmutil . acc_private | asmutil . acc_final , proxettanames . initmethodname , desc_void , null , null ) ; mv . visitcode ( ) ; if ( wd . adviceinits != null ) { for ( string name : wd . adviceinits ) { mv . visitvarinsn ( aload , num_ ) ; mv . visitmethodinsn ( invokespecial , wd . thisreference , name , desc_void , bool_ ) ; } } mv . visitinsn ( return ) ; mv . visitmaxs ( num_ , num_ ) ; mv . visitend ( ) ; }	Creates init method that simply calls all advice constructor methods in correct order.This created init method is called from each destination's constructor.
protected void processsupermethods ( ) { for ( classreader cr : targetclassinfo . superclassreaders ) { cr . accept ( new emptyclassvisitor ( ) { string declaredclassname ; @ override public void visit ( final int version , final int access , final string name , final string signature , final string supername , final string [ ] interfaces ) { declaredclassname = name ; } @ override public methodvisitor visitmethod ( final int access , final string name , final string desc , final string signature , final string [ ] exceptions ) { if ( name . equals ( init ) || name . equals ( clinit ) ) { return null ; } methodsignaturevisitor msign = targetclassinfo . lookupmethodsignaturevisitor ( access , name , desc , declaredclassname ) ; if ( msign == null ) { return null ; } return applyproxy ( msign ) ; } } , num_ ) ; } }	Checks for all public super methods that are not overridden.
public int findlast ( int low , int high ) { int ndx = - num_ ; while ( low <= high ) { int mid = ( low + high ) > > > num_ ; int delta = compare ( mid ) ; if ( delta > num_ ) { high = mid - num_ ; } else { if ( delta == num_ ) { ndx = mid ; } low = mid + num_ ; } } if ( ndx == - num_ ) { return - ( low + num_ ) ; } return ndx ; }	Finds very last index of given element in inclusive index range.
public string on ( final string string ) { if ( ! enabled ) { return string ; } final stringbuilder sb = new stringbuilder ( ) ; if ( prefix != null ) { sb . append ( prefix ) . append ( str_ ) ; } sb . append ( string ) ; if ( suffix != null ) { sb . append ( suffix ) . append ( str_ ) ; } return sb . tostring ( ) ; }	Returns chalked string.
private byte [ ] replaceasminstructions ( final byte [ ] classfile , final boolean hasframes ) { final attribute [ ] attributes = getattributeprototypes ( ) ; firstfield = null ; lastfield = null ; firstmethod = null ; lastmethod = null ; lastruntimevisibleannotation = null ; lastruntimeinvisibleannotation = null ; lastruntimevisibletypeannotation = null ; lastruntimeinvisibletypeannotation = null ; modulewriter = null ; nesthostclassindex = num_ ; numberofnestmemberclasses = num_ ; nestmemberclasses = null ; firstattribute = null ; compute = hasframes ? methodwriter . compute_inserted_frames : methodwriter . compute_nothing ; new classreader ( classfile , num_ , bool_ ) . accept ( this , attributes , ( hasframes ? classreader . expand_frames : num_ ) | classreader . expand_asm_insns ) ; return tobytearray ( ) ; }	Returns the equivalent of the given class file, with the ASM specific instructions replacedwith standard ones.
private attribute [ ] getattributeprototypes ( ) { attribute . set attributeprototypes = new attribute . set ( ) ; attributeprototypes . addattributes ( firstattribute ) ; fieldwriter fieldwriter = firstfield ; while ( fieldwriter != null ) { fieldwriter . collectattributeprototypes ( attributeprototypes ) ; fieldwriter = ( fieldwriter ) fieldwriter . fv ; } methodwriter methodwriter = firstmethod ; while ( methodwriter != null ) { methodwriter . collectattributeprototypes ( attributeprototypes ) ; methodwriter = ( methodwriter ) methodwriter . mv ; } return attributeprototypes . toarray ( ) ; }	Returns the prototypes of the attributes used by this class, its fields and its methods.
public void register ( final class type , final class < ? extends sqltype > sqltypeclass ) { types . put ( type , lookupsqltype ( sqltypeclass ) ) ; }	Registers sql type for provided type.
public sqltype lookup ( final class clazz ) { sqltype sqltype ; for ( class x = clazz ; x != null ; x = x . getsuperclass ( ) ) { sqltype = types . get ( clazz ) ; if ( sqltype != null ) { return sqltype ; } class [ ] interfaces = x . getinterfaces ( ) ; for ( class i : interfaces ) { sqltype = types . get ( i ) ; if ( sqltype != null ) { return sqltype ; } } } return null ; }	Retrieves SQL type for provided type.
public sqltype lookupsqltype ( final class < ? extends sqltype > sqltypeclass ) { sqltype sqltype = sqltypes . get ( sqltypeclass ) ; if ( sqltype == null ) { try { sqltype = classutil . newinstance ( sqltypeclass ) ; } catch ( exception ex ) { throw new dbsqlexception ( str_ + sqltypeclass . getsimplename ( ) , ex ) ; } sqltypes . put ( sqltypeclass , sqltype ) ; } return sqltype ; }	Returns sql type instance.
public static proxyinfo socks4proxy ( final string proxyaddress , final int proxyport , final string proxyuser ) { return new proxyinfo ( proxytype . socks4 , proxyaddress , proxyport , proxyuser , null ) ; }	Creates SOCKS4 proxy.
public static proxyinfo socks5proxy ( final string proxyaddress , final int proxyport , final string proxyuser , final string proxypassword ) { return new proxyinfo ( proxytype . socks5 , proxyaddress , proxyport , proxyuser , proxypassword ) ; }	Creates SOCKS5 proxy.
public static proxyinfo httpproxy ( final string proxyaddress , final int proxyport , final string proxyuser , final string proxypassword ) { return new proxyinfo ( proxytype . http , proxyaddress , proxyport , proxyuser , proxypassword ) ; }	Creates HTTP proxy.
public int totalthreadtransactions ( ) { arraylist < jtxtransaction > txlist = txstack . get ( ) ; if ( txlist == null ) { return num_ ; } return txlist . size ( ) ; }	Returns total number of transactions associated with current thread.
public int totalthreadtransactionswithstatus ( final jtxstatus status ) { arraylist < jtxtransaction > txlist = txstack . get ( ) ; if ( txlist == null ) { return num_ ; } int count = num_ ; for ( jtxtransaction tx : txlist ) { if ( tx . getstatus ( ) == status ) { count ++ ; } } return count ; }	Returns total number of transactions of the specified status associated with current thread.
protected void associatetransaction ( final jtxtransaction tx ) { totaltransactions ++ ; arraylist < jtxtransaction > txlist = txstack . get ( ) ; if ( txlist == null ) { txlist = new arraylist < > ( ) ; txstack . set ( txlist ) ; } txlist . add ( tx ) ;	Associate transaction to current thread.
protected void continuetx ( final jtxtransaction sourcetx , final jtxtransactionmode destmode ) { if ( ! validateexistingtransaction ) { return ; } jtxtransactionmode sourcemode = sourcetx . gettransactionmode ( ) ; jtxisolationlevel destisolationlevel = destmode . getisolationlevel ( ) ; if ( destisolationlevel != isolation_default ) { jtxisolationlevel currentisolationlevel = sourcemode . getisolationlevel ( ) ; if ( currentisolationlevel != destisolationlevel ) { throw new jtxexception ( str_ + destisolationlevel + str_ + currentisolationlevel ) ; } } if ( ( ! destmode . isreadonly ( ) ) && ( sourcemode . isreadonly ( ) ) ) { throw new jtxexception ( str_ ) ; } }	Check if propagation of a transaction is possible, due to source and destination transaction modes.
protected < e > jtxresourcemanager < e > lookupresourcemanager ( final class < e > resourcetype ) {	Lookups resource manager for provided type.
protected c createproxyobject ( class < c > target ) { target = proxettautil . resolvetargetclass ( target ) ; class proxyclass = cache . get ( target ) ; if ( proxyclass == null ) { proxyclass = proxetta . defineproxy ( target ) ; cache . put ( target , proxyclass ) ; } c proxy ; try { proxy = ( c ) classutil . newinstance ( proxyclass ) ; } catch ( exception ex ) { throw new pathrefexception ( ex ) ; } return proxy ; }	Creates proxy object.
protected void append ( final string methodname ) { if ( path . length ( ) != num_ ) { path += stringpool . dot ; } if ( methodname . startswith ( stringpool . left_sq_bracket ) ) { path = stringutil . substring ( path , num_ , - num_ ) ; } path += methodname ; }	Appends method name to existing path.
public static string alignleftandpad ( final string text , final int size ) { int textlength = text . length ( ) ; if ( textlength > size ) { return text . substring ( num_ , size ) ; } final stringbuilder sb = new stringbuilder ( size ) ; sb . append ( text ) ; while ( textlength ++ < size ) { sb . append ( str_ ) ; } return sb . tostring ( ) ; }	Puts the text to the left and pads with spaces until the size is reached.
public static string tocamelcase ( final string input , final boolean firstcharuppercase , final char separator ) { final int length = input . length ( ) ; final stringbuilder sb = new stringbuilder ( length ) ; boolean uppercase = firstcharuppercase ; for ( int i = num_ ; i < length ; i ++ ) { final char ch = input . charat ( i ) ; if ( ch == separator ) { uppercase = bool_ ; } else if ( uppercase ) { sb . append ( character . touppercase ( ch ) ) ; uppercase = bool_ ; } else { sb . append ( ch ) ; } } return sb . tostring ( ) ; }	Converts separated string value to CamelCase.
public static string formatparagraph ( final string src , final int len , final boolean breakonwhitespace ) { stringbuilder str = new stringbuilder ( ) ; int total = src . length ( ) ; int from = num_ ; while ( from < total ) { int to = from + len ; if ( to >= total ) { to = total ; } else if ( breakonwhitespace ) { int ndx = stringutil . lastindexofwhitespace ( src , to - num_ , from ) ; if ( ndx != - num_ ) { to = ndx + num_ ; } } int cutfrom = stringutil . indexofnonwhitespace ( src , from , to ) ; if ( cutfrom != - num_ ) { int cutto = stringutil . lastindexofnonwhitespace ( src , to - num_ , from ) + num_ ; str . append ( src , cutfrom , cutto ) ; } str . append ( str_ ) ; from = to ; } return str . tostring ( ) ; }	Formats provided string as paragraph.
public static string converttabstospaces ( final string line , final int tabwidth ) { int tab_index , tab_size ; int last_tab_index = num_ ; int added_chars = num_ ; if ( tabwidth == num_ ) { return stringutil . remove ( line , str_ ) ; } stringbuilder result = new stringbuilder ( ) ; while ( ( tab_index = line . indexof ( str_ , last_tab_index ) ) != - num_ ) { tab_size = tabwidth - ( ( tab_index + added_chars ) % tabwidth ) ; if ( tab_size == num_ ) { tab_size = tabwidth ; } added_chars += tab_size - num_ ; result . append ( line , last_tab_index , tab_index ) ; result . append ( stringutil . repeat ( str_ , tab_size ) ) ; last_tab_index = tab_index + num_ ; } if ( last_tab_index == num_ ) { return line ; } result . append ( line . substring ( last_tab_index ) ) ; return result . tostring ( ) ; }	Converts all tabs on a line to spaces according to the provided tab width.This is not a simple tab to spaces replacement, since the resultingindentation remains the same.
public static string escapejava ( final string string ) { int strlen = string . length ( ) ; stringbuilder sb = new stringbuilder ( strlen ) ; for ( int i = num_ ; i < strlen ; i ++ ) { char c = string . charat ( i ) ; switch ( c ) { case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; default : if ( ( c < num_ ) || ( c > num_ ) ) { string hex = integer . tohexstring ( c ) ; sb . append ( str_ ) ; for ( int k = hex . length ( ) ; k < num_ ; k ++ ) { sb . append ( str_ ) ; } sb . append ( hex ) ; } else { sb . append ( c ) ; } } } return sb . tostring ( ) ; }	Escapes a string using java rules.
public static string unescapejava ( final string str ) { char [ ] chars = str . tochararray ( ) ; stringbuilder sb = new stringbuilder ( str . length ( ) ) ; for ( int i = num_ ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c != str_ ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; switch ( c ) { case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : char hex = ( char ) integer . parseint ( new string ( chars , i + num_ , num_ ) , num_ ) ; sb . append ( hex ) ; i += num_ ; break ; default : throw new illegalargumentexception ( str_ + c ) ; } } return sb . tostring ( ) ; }	Unescapes a string using java rules.
@ suppresswarnings ( { str_ } ) public < t > t getbean ( final class < t > type ) { string name = resolvebeanname ( type ) ; return ( t ) getbean ( name ) ; }	Returns Petite bean instance.
public < t > t getbean ( final string name ) {	Returns Petite bean instance.Petite container will find the bean in corresponding scope and all its dependencies,either by constructor or property injection.
protected void initbeandefinition ( final beandefinition def ) {	Resolves and initializes bean definition.
protected object invokeprovider ( final providerdefinition provider ) { if ( provider . method != null ) { final object bean ; if ( provider . beanname != null ) {	Invokes provider to get a bean.
public void addbean ( final string name , final object bean , wiringmode wiringmode ) { wiringmode = petiteconfig . resolvewiringmode ( wiringmode ) ; registerpetitebean ( bean . getclass ( ) , name , singletonscope . class , wiringmode , bool_ , null ) ; beandefinition def = lookupexistingbeandefinition ( name ) ; registerbeanandwireandinjectparamsandinvokeinitmethods ( new beandata ( this , def , bean ) ) ; }	Adds object instance to the container as singleton bean.
public void setbeanproperty ( final string name , final object value ) { object bean = null ; int ndx = name . length ( ) ; while ( bool_ ) { ndx = name . lastindexof ( str_ , ndx ) ; if ( ndx == - num_ ) { break ; } string beanname = name . substring ( num_ , ndx ) ; bean = getbean ( beanname ) ; if ( bean != null ) { break ; } ndx -- ; } if ( bean == null ) { throw new petiteexception ( str_ + name ) ; } try { beanutil . declared . setproperty ( bean , name . substring ( ndx + num_ ) , value ) ; } catch ( exception ex ) { throw new petiteexception ( str_ + name , ex ) ; } }	Sets petite bean property.
public object getbeanproperty ( final string name ) { int ndx = name . indexof ( str_ ) ; if ( ndx == - num_ ) { throw new petiteexception ( str_ + name ) ; } string beanname = name . substring ( num_ , ndx ) ; object bean = getbean ( beanname ) ; if ( bean == null ) { throw new petiteexception ( str_ + name ) ; } try { return beanutil . declared . getproperty ( bean , name . substring ( ndx + num_ ) ) ; } catch ( exception ex ) { throw new petiteexception ( str_ + name , ex ) ; } }	Returns petite bean property value.
public void shutdown ( ) { scopes . foreachvalue ( scope :: shutdown ) ; externalscache . clear ( ) ; beans . clear ( ) ; beansalt . clear ( ) ; scopes . clear ( ) ; providers . clear ( ) ; beancollections . clear ( ) ; }	Shutdowns container. After container is down, it can't be used anymore.
public static methodparameter [ ] resolveparameters ( final accessibleobject methodorctor ) { class [ ] paramtypes ; class declaringclass ; string name ; if ( methodorctor instanceof method ) { method method = ( method ) methodorctor ; paramtypes = method . getparametertypes ( ) ; name = method . getname ( ) ; declaringclass = method . getdeclaringclass ( ) ; } else { constructor constructor = ( constructor ) methodorctor ; paramtypes = constructor . getparametertypes ( ) ; declaringclass = constructor . getdeclaringclass ( ) ; name = ctor_method ; } if ( paramtypes . length == num_ ) { return methodparameter . empty_array ; } inputstream stream ; try { stream = classloaderutil . getclassasstream ( declaringclass ) ; } catch ( ioexception ioex ) { throw new paramoexception ( str_ + declaringclass . getname ( ) , ioex ) ; } if ( stream == null ) { throw new paramoexception ( str_ + declaringclass ) ; } try { classreader reader = new classreader ( stream ) ; methodfinder visitor = new methodfinder ( declaringclass , name , paramtypes ) ; reader . accept ( visitor , num_ ) ; return visitor . getresolvedparameters ( ) ; } catch ( ioexception ioex ) { throw new paramoexception ( ioex ) ; } finally { streamutil . close ( stream ) ; } }	Resolves method parameters from a method or constructor.Returns an empty array when target does not contain any parameter.No caching is involved in this process, i.e.
@ override public int doafterbody ( ) throws jspexception { bodycontent body = getbodycontent ( ) ; jspwriter out = body . getenclosingwriter ( ) ; string bodytext = populateform ( body . getstring ( ) , name -> value ( name , pagecontext ) ) ; try { out . print ( bodytext ) ; } catch ( ioexception ioex ) { throw new jspexception ( ioex ) ; } return skip_body ; }	Performs smart form population.
public string getvalue ( final string ... profiles ) { if ( hasmacro ) { return propsdata . resolvemacros ( value , profiles ) ; } return value ; }	Returns the property value, with replaced macros.
@ override public void end ( ) { if ( parentnode != rootnode ) { node thisnode = parentnode ; while ( thisnode != rootnode ) { if ( dombuilder . config . isimpliedendtags ( ) ) { if ( implrules . implicitlyclosetagoneof ( thisnode . getnodename ( ) ) ) { thisnode = thisnode . getparentnode ( ) ; continue ; } } error ( str_ + thisnode . getnodename ( ) + str_ ) ; thisnode = thisnode . getparentnode ( ) ; } }	Finishes the tree building.
protected element createelementnode ( final tag tag ) { boolean hasvoidtags = htmlvoidrules != null ; boolean isvoid = bool_ ; boolean selfclosed = bool_ ; if ( hasvoidtags ) { isvoid = htmlvoidrules . isvoidtag ( tag . getname ( ) ) ;	Creates new element with correct configuration.
protected void removelastchildnodeifemptytext ( final node parentnode , final boolean closedtag ) { if ( parentnode == null ) { return ; } node lastchild = parentnode . getlastchild ( ) ; if ( lastchild == null ) { return ; } if ( lastchild . getnodetype ( ) != node . nodetype . text ) { return ; } if ( closedtag ) { if ( parentnode . getchildnodescount ( ) == num_ ) { return ; } } text text = ( text ) lastchild ; if ( text . isblank ( ) ) { lastchild . detachfromparent ( ) ; } }	Removes last child node if contains just empty text.
public string getquerystring ( ) { if ( sqltemplate == null ) { return tostring ( ) ; } if ( parametervalues == null ) { return sqltemplate ; } final stringbuilder sb = new stringbuilder ( ) ; int qmarkcount = num_ ; final stringtokenizer tok = new stringtokenizer ( sqltemplate + str_ , str_ ) ; while ( tok . hasmoretokens ( ) ) { final string onechunk = tok . nexttoken ( ) ; sb . append ( onechunk ) ; try { object value = null ; if ( parametervalues . size ( ) > num_ + qmarkcount ) { value = parametervalues . get ( num_ + qmarkcount ) ; qmarkcount ++ ; } else { if ( ! tok . hasmoretokens ( ) ) { value = str_ ; } } if ( value == null ) { value = str_ ; } sb . append ( value ) ; } catch ( throwable th ) { sb . append ( str_ ) . append ( th . tostring ( ) ) ; } } return sb . tostring ( ) . trim ( ) ; }	Returns the query string.
protected string getactionclassname ( final object action ) { class clazz = action . getclass ( ) ; clazz = proxettautil . resolvetargetclass ( clazz ) ; return clazz . getname ( ) ; }	Returns correct action class name.
protected int calculateto ( final int from , final int count , final int size ) { int to = size ; if ( count != - num_ ) { to = from + count ; if ( to > size ) { to = size ; } } return to ; }	Calculates 'TO'.
public static string replace ( final string s , final string sub , final string with ) { if ( sub . isempty ( ) ) { return s ; } int c = num_ ; int i = s . indexof ( sub , c ) ; if ( i == - num_ ) { return s ; } int length = s . length ( ) ; stringbuilder sb = new stringbuilder ( length + with . length ( ) ) ; do { sb . append ( s , c , i ) ; sb . append ( with ) ; c = i + sub . length ( ) ; } while ( ( i = s . indexof ( sub , c ) ) != - num_ ) ; if ( c < length ) { sb . append ( s , c , length ) ; } return sb . tostring ( ) ; }	Replaces all occurrences of a certain pattern in a string with areplacement string.
public static string replacechar ( final string s , final char sub , final char with ) { int startindex = s . indexof ( sub ) ; if ( startindex == - num_ ) { return s ; } char [ ] str = s . tochararray ( ) ; for ( int i = startindex ; i < str . length ; i ++ ) { if ( str [ i ] == sub ) { str [ i ] = with ; } } return new string ( str ) ; }	Replaces all occurrences of a character in a string.
public static string replacechars ( final string s , final char [ ] sub , final char [ ] with ) { char [ ] str = s . tochararray ( ) ; for ( int i = num_ ; i < str . length ; i ++ ) { char c = str [ i ] ; for ( int j = num_ ; j < sub . length ; j ++ ) { if ( c == sub [ j ] ) { str [ i ] = with [ j ] ; break ; } } } return new string ( str ) ; }	Replaces all occurrences of a characters in a string.
public static string replacefirst ( final string s , final string sub , final string with ) { int i = s . indexof ( sub ) ; if ( i == - num_ ) { return s ; } return s . substring ( num_ , i ) + with + s . substring ( i + sub . length ( ) ) ; }	Replaces the very first occurrence of a substring with supplied string.
public static string replacefirst ( final string s , final char sub , final char with ) { int index = s . indexof ( sub ) ; if ( index == - num_ ) { return s ; } char [ ] str = s . tochararray ( ) ; str [ index ] = with ; return new string ( str ) ; }	Replaces the very first occurrence of a character in a string.
public static string replacelast ( final string s , final string sub , final string with ) { int i = s . lastindexof ( sub ) ; if ( i == - num_ ) { return s ; } return s . substring ( num_ , i ) + with + s . substring ( i + sub . length ( ) ) ; }	Replaces the very last occurrence of a substring with supplied string.
public static string replacelast ( final string s , final char sub , final char with ) { int index = s . lastindexof ( sub ) ; if ( index == - num_ ) { return s ; } char [ ] str = s . tochararray ( ) ; str [ index ] = with ; return new string ( str ) ; }	Replaces the very last occurrence of a character in a string.
public static string remove ( final string s , final string sub ) { int c = num_ ; int sublen = sub . length ( ) ; if ( sublen == num_ ) { return s ; } int i = s . indexof ( sub , c ) ; if ( i == - num_ ) { return s ; } stringbuilder sb = new stringbuilder ( s . length ( ) ) ; do { sb . append ( s , c , i ) ; c = i + sublen ; } while ( ( i = s . indexof ( sub , c ) ) != - num_ ) ; if ( c < s . length ( ) ) { sb . append ( s , c , s . length ( ) ) ; } return sb . tostring ( ) ; }	Removes all substring occurrences from the string.
public static string remove ( final string string , final char ch ) { int stringlen = string . length ( ) ; char [ ] result = new char [ stringlen ] ; int offset = num_ ; for ( int i = num_ ; i < stringlen ; i ++ ) { char c = string . charat ( i ) ; if ( c == ch ) { continue ; } result [ offset ] = c ; offset ++ ; } if ( offset == stringlen ) { return string ;	Removes a single character from string.
public static boolean isallempty ( final string ... strings ) { for ( string string : strings ) { if ( ! isempty ( string ) ) { return bool_ ; } } return bool_ ; }	Determines if string array contains empty strings.
public static boolean isallblank ( final string ... strings ) { for ( string string : strings ) { if ( ! isblank ( string ) ) { return bool_ ; } } return bool_ ; }	Determines if string array contains just blank strings.
public static string [ ] tostringarray ( final object value ) { if ( value == null ) { return new string [ num_ ] ; } class < ? > type = value . getclass ( ) ; if ( ! type . isarray ( ) ) { return new string [ ] { value . tostring ( ) } ; } class componenttype = type . getcomponenttype ( ) ; if ( componenttype . isprimitive ( ) ) { if ( componenttype == int . class ) { return arraysutil . tostringarray ( ( int [ ] ) value ) ; } else if ( componenttype == long . class ) { return arraysutil . tostringarray ( ( long [ ] ) value ) ; } else if ( componenttype == double . class ) { return arraysutil . tostringarray ( ( double [ ] ) value ) ; } else if ( componenttype == float . class ) { return arraysutil . tostringarray ( ( float [ ] ) value ) ; } else if ( componenttype == boolean . class ) { return arraysutil . tostringarray ( ( boolean [ ] ) value ) ; } else if ( componenttype == short . class ) { return arraysutil . tostringarray ( ( short [ ] ) value ) ; } else if ( componenttype == byte . class ) { return arraysutil . tostringarray ( ( byte [ ] ) value ) ; } else { throw new illegalargumentexception ( ) ; } } else { return arraysutil . tostringarray ( ( object [ ] ) value ) ; } }	Converts an array object to array of strings, where every elementof input array is converted to a string.
private static string changefirstcharactercase ( final boolean capitalize , final string string ) { int strlen = string . length ( ) ; if ( strlen == num_ ) { return string ; } char ch = string . charat ( num_ ) ; char modifiedch ; if ( capitalize ) { modifiedch = character . touppercase ( ch ) ; } else { modifiedch = character . tolowercase ( ch ) ; } if ( modifiedch == ch ) {	Internal method for changing the first character case.
public static string title ( final string string ) { char [ ] chars = string . tochararray ( ) ; boolean waswhitespace = bool_ ; for ( int i = num_ ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( charutil . iswhitespace ( c ) ) { waswhitespace = bool_ ; } else { if ( waswhitespace ) { chars [ i ] = character . touppercase ( c ) ; } else { chars [ i ] = character . tolowercase ( c ) ; } waswhitespace = bool_ ; } } return new string ( chars ) ; }	Makes a title-cased string from given input.
public static string compresschars ( final string s , final char c ) { int len = s . length ( ) ; stringbuilder sb = new stringbuilder ( len ) ; boolean waschar = bool_ ; for ( int i = num_ ; i < len ; i ++ ) { char c1 = s . charat ( i ) ; if ( c1 == c ) { if ( waschar ) { continue ; } waschar = bool_ ; } else { waschar = bool_ ; } sb . append ( c1 ) ; } if ( sb . length ( ) == len ) { return s ; } return sb . tostring ( ) ; }	Compress multiple occurrences of given char into one appearance.
public static boolean startswithignorecase ( final string src , final string subs , final int startindex ) { string sub = subs . tolowercase ( ) ; int sublen = sub . length ( ) ; if ( startindex + sublen > src . length ( ) ) { return bool_ ; } int j = num_ ; int i = startindex ; while ( j < sublen ) { char source = character . tolowercase ( src . charat ( i ) ) ; if ( sub . charat ( j ) != source ) { return bool_ ; } j ++ ; i ++ ; } return bool_ ; }	Tests if this string starts with the specified prefix with ignored caseand with the specified prefix beginning a specified index.
public static boolean endswithchar ( final string s , final char c ) { if ( s . length ( ) == num_ ) { return bool_ ; } return s . charat ( s . length ( ) - num_ ) == c ; }	Returns if string ends with provided character.
public static int countignorecase ( final string source , final string sub ) { int count = num_ ; int j = num_ ; int sublen = sub . length ( ) ; if ( sublen == num_ ) { return num_ ; } while ( bool_ ) { int i = indexofignorecase ( source , sub , j ) ; if ( i == - num_ ) { break ; } count ++ ; j = i + sublen ; } return count ; }	Count substring occurrences in a source string, ignoring case.
public static boolean equalsignorecase ( final string [ ] as , final string [ ] as1 ) { if ( as . length != as1 . length ) { return bool_ ; } for ( int i = num_ ; i < as . length ; i ++ ) { if ( ! as [ i ] . equalsignorecase ( as1 [ i ] ) ) { return bool_ ; } } return bool_ ; }	Compares two string arrays.
public static int indexofwhitespace ( final string string , final int startindex , final int endindex ) { for ( int i = startindex ; i < endindex ; i ++ ) { if ( charutil . iswhitespace ( string . charat ( i ) ) ) { return i ; } } return - num_ ; }	Returns first index of a whitespace character, starting from specified index offset.
public static string stripleadingchar ( final string string , final char c ) { if ( string . length ( ) > num_ ) { if ( string . charat ( num_ ) == c ) { return string . substring ( num_ ) ; } } return string ; }	Strips leading char if string starts with one.
public static string striptrailingchar ( final string string , final char c ) { if ( string . length ( ) > num_ ) { if ( string . charat ( string . length ( ) - num_ ) == c ) { return string . substring ( num_ , string . length ( ) - num_ ) ; } } return string ; }	Strips trailing char if string ends with one.
public static string stripchar ( final string string , final char c ) { if ( string . length ( ) == num_ ) { return string ; } if ( string . length ( ) == num_ ) { if ( string . charat ( num_ ) == c ) { return stringpool . empty ; } return string ; } int left = num_ ; int right = string . length ( ) ; if ( string . charat ( left ) == c ) { left ++ ; } if ( string . charat ( right - num_ ) == c ) { right -- ; } return string . substring ( left , right ) ; }	Strips leading and trailing char from given string.
public static string striptochar ( final string string , final char c ) { int ndx = string . indexof ( c ) ; if ( ndx == - num_ ) { return string ; } return string . substring ( ndx ) ; }	Strips everything up to the first appearance of given char.Character IS included in the returned string.
public static string stripfromchar ( final string string , final char c ) { int ndx = string . indexof ( c ) ; if ( ndx == - num_ ) { return string ; } return string . substring ( num_ , ndx ) ; }	Strips everything from the first appearance of given char.Character IS NOT included in the returned string.
public static void cropall ( final string ... strings ) { for ( int i = num_ ; i < strings . length ; i ++ ) { string string = strings [ i ] ; if ( string != null ) { string = crop ( strings [ i ] ) ; } strings [ i ] = string ; } }	Crops all elements of string array.
public static string trimleft ( final string src ) { int len = src . length ( ) ; int st = num_ ; while ( ( st < len ) && ( charutil . iswhitespace ( src . charat ( st ) ) ) ) { st ++ ; } return st > num_ ? src . substring ( st ) : src ; }	Trim whitespaces from the left.
public static string trimright ( final string src ) { int len = src . length ( ) ; int count = len ; while ( ( len > num_ ) && ( charutil . iswhitespace ( src . charat ( len - num_ ) ) ) ) { len -- ; } return ( len < count ) ? src . substring ( num_ , len ) : src ; }	Trim whitespaces from the right.
public static int [ ] indexofregion ( final string string , final string leftboundary , final string rightboundary , final int offset ) { int ndx = offset ; int [ ] res = new int [ num_ ] ; ndx = string . indexof ( leftboundary , ndx ) ; if ( ndx == - num_ ) { return null ; } res [ num_ ] = ndx ; ndx += leftboundary . length ( ) ; res [ num_ ] = ndx ; ndx = string . indexof ( rightboundary , ndx ) ; if ( ndx == - num_ ) { return null ; } res [ num_ ] = ndx ; res [ num_ ] = ndx + rightboundary . length ( ) ; return res ; }	Returns indexes of the first region without escaping character.
public static string join ( final collection collection , final char separator ) { if ( collection == null ) { return null ; } if ( collection . size ( ) == num_ ) { return stringpool . empty ; } final stringbuilder sb = new stringbuilder ( collection . size ( ) * num_ ) ; final iterator it = collection . iterator ( ) ; for ( int i = num_ ; i < collection . size ( ) ; i ++ ) { if ( i > num_ ) { sb . append ( separator ) ; } sb . append ( it . next ( ) ) ; } return sb . tostring ( ) ; }	Joins an collection of objects into one string with separator.
public static string join ( final object [ ] array , final string separator ) { if ( array == null ) { return null ; } if ( array . length == num_ ) { return stringpool . empty ; } if ( array . length == num_ ) { return string . valueof ( array [ num_ ] ) ; } final stringbuilder sb = new stringbuilder ( array . length * num_ ) ; for ( int i = num_ ; i < array . length ; i ++ ) { if ( i > num_ ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . tostring ( ) ; }	Joins an array of objects into one string with separator.
public static string convertcharset ( final string source , final string srccharsetname , final string newcharsetname ) { if ( srccharsetname . equals ( newcharsetname ) ) { return source ; } return stringutil . newstring ( stringutil . getbytes ( source , srccharsetname ) , newcharsetname ) ; }	Converts string charset. If charset names are the same, the same string is returned.
public static boolean ischaratequal ( final string string , final int index , final char chartocompare ) { if ( ( index < num_ ) || ( index >= string . length ( ) ) ) { return bool_ ; } return string . charat ( index ) == chartocompare ; }	Safely compares provided char with char on given location.
public static string surround ( string string , final string prefix , final string suffix ) { if ( ! string . startswith ( prefix ) ) { string = prefix + string ; } if ( ! string . endswith ( suffix ) ) { string += suffix ; } return string ; }	Surrounds the string with provided prefix and suffix if such missing from string.
public static string prefix ( string string , final string prefix ) { if ( ! string . startswith ( prefix ) ) { string = prefix + string ; } return string ; }	Inserts prefix if doesn't exist.
public static string suffix ( string string , final string suffix ) { if ( ! string . endswith ( suffix ) ) { string += suffix ; } return string ; }	Appends suffix if doesn't exist.
public static string cuttoindexof ( string string , final string substring ) { int i = string . indexof ( substring ) ; if ( i != - num_ ) { string = string . substring ( num_ , i ) ; } return string ; }	Cuts the string from beginning to the first index of provided substring.
public static string cutfromindexof ( string string , final string substring ) { int i = string . indexof ( substring ) ; if ( i != - num_ ) { string = string . substring ( i ) ; } return string ; }	Cuts the string from the first index of provided substring to the end.
public static string cutprefix ( string string , final string prefix ) { if ( string . startswith ( prefix ) ) { string = string . substring ( prefix . length ( ) ) ; } return string ; }	Cuts prefix if exists.
public static string cutsuffix ( string string , final string suffix ) { if ( string . endswith ( suffix ) ) { string = string . substring ( num_ , string . length ( ) - suffix . length ( ) ) ; } return string ; }	Cuts sufix if exists.
public static string cutsurrounding ( final string string , final string prefix , final string suffix ) { int start = num_ ; int end = string . length ( ) ; if ( string . startswith ( prefix ) ) { start = prefix . length ( ) ; } if ( string . endswith ( suffix ) ) { end -= suffix . length ( ) ; } if ( end <= start ) { return stringpool . empty ; } return string . substring ( start , end ) ; }	Removes surrounding prefix and suffixes.
public static string insert ( final string src , final string insert , int offset ) { if ( offset < num_ ) { offset = num_ ; } if ( offset > src . length ( ) ) { offset = src . length ( ) ; } stringbuilder sb = new stringbuilder ( src ) ; sb . insert ( offset , insert ) ; return sb . tostring ( ) ; }	Inserts a string on provided offset.
public static string repeat ( final string source , int count ) { stringband result = new stringband ( count ) ; while ( count > num_ ) { result . append ( source ) ; count -- ; } return result . tostring ( ) ; }	Creates a new string that contains the provided string a number of times.
public static string reverse ( final string s ) { stringbuilder result = new stringbuilder ( s . length ( ) ) ; for ( int i = s . length ( ) - num_ ; i >= num_ ; i -- ) { result . append ( s . charat ( i ) ) ; } return result . tostring ( ) ; }	Reverse a string.
public static string maxcommonprefix ( final string one , final string two ) { final int minlength = math . min ( one . length ( ) , two . length ( ) ) ; final stringbuilder sb = new stringbuilder ( minlength ) ; for ( int pos = num_ ; pos < minlength ; pos ++ ) { final char currentchar = one . charat ( pos ) ; if ( currentchar != two . charat ( pos ) ) { break ; } sb . append ( currentchar ) ; } return sb . tostring ( ) ; }	Returns max common prefix of two strings.
public static string findcommonprefix ( final string ... strings ) { stringbuilder prefix = new stringbuilder ( ) ; int index = num_ ; char c = num_ ; loop : while ( bool_ ) { for ( int i = num_ ; i < strings . length ; i ++ ) { string s = strings [ i ] ; if ( index == s . length ( ) ) { break loop ; } if ( i == num_ ) { c = s . charat ( index ) ; } else { if ( s . charat ( index ) != c ) { break loop ; } } } index ++ ; prefix . append ( c ) ; } return prefix . length ( ) == num_ ? stringpool . empty : prefix . tostring ( ) ; }	Finds common prefix for several strings.
public static string shorten ( string s , int length , final string suffix ) { length -= suffix . length ( ) ; if ( s . length ( ) > length ) { for ( int j = length ; j >= num_ ; j -- ) { if ( charutil . iswhitespace ( s . charat ( j ) ) ) { length = j ; break ; } } string temp = s . substring ( num_ , length ) ; s = temp . concat ( suffix ) ; } return s ; }	Shorten string to given length.
public static string touppercase ( final string s , locale locale ) { if ( s == null ) { return null ; } stringbuilder sb = null ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c > num_ ) {	Converts all of the characters in the string to upper case, based on thelocale.
public static string removequotes ( final string string ) { if ( ( startswithchar ( string , str_ ) && endswithchar ( string , str_ ) ) || ( startswithchar ( string , str_ ) && endswithchar ( string , str_ ) ) || ( startswithchar ( string , str_ ) && endswithchar ( string , str_ ) ) ) { return substring ( string , num_ , - num_ ) ; } return string ; }	Removes starting and ending single or double quotes.
public static string tohexstring ( final byte [ ] bytes ) { char [ ] chars = new char [ bytes . length * num_ ] ; int i = num_ ; for ( byte b : bytes ) { chars [ i ++ ] = charutil . int2hex ( ( b & num_ ) > > num_ ) ; chars [ i ++ ] = charutil . int2hex ( b & num_ ) ; } return new string ( chars ) ; }	Converts bytes to hex string.
public static byte [ ] getbytes ( final string string ) { try { return string . getbytes ( joddcore . encoding ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }	Returns String bytes using Jodds default encoding.
public static char detectquotechar ( final string str ) { if ( str . length ( ) < num_ ) { return num_ ; } final char c = str . charat ( num_ ) ; if ( c != str . charat ( str . length ( ) - num_ ) ) { return num_ ; } if ( c == str_ || c == str_ || c == str_ ) { return c ; } return num_ ; }	Detects quote character or return 0.
public void visitenum ( final string name , final string descriptor , final string value ) { if ( av != null ) { av . visitenum ( name , descriptor , value ) ; } }	Visits an enumeration value of the annotation.
public annotationvisitor visitannotation ( final string name , final string descriptor ) { if ( av != null ) { return av . visitannotation ( name , descriptor ) ; } return null ; }	Visits a nested annotation value of the annotation.
public < e > dbentitydescriptor < e > registertype ( final class < e > type ) { dbentitydescriptor < e > ded = createdbentitydescriptor ( type ) ; dbentitydescriptor < e > existing = descriptorsmap . put ( type , ded ) ; if ( log . isdebugenabled ( ) ) { log . debug ( str_ + type . getname ( ) + str_ + ded . gettablename ( ) ) ; } if ( existing != null ) { if ( ded . gettype ( ) == type ) { return ded ; } throw new dboomexception ( str_ + existing . gettype ( ) ) ; } existing = entitynamesmap . put ( ded . getentityname ( ) , ded ) ; if ( existing != null ) { throw new dboomexception ( str_ + ded . getentityname ( ) + str_ + existing . gettype ( ) ) ; } return ded ; }	Registers just type and entity names.
public < e > dbentitydescriptor < e > registerentity ( final class < e > type , final boolean force ) { if ( force ) { removeentity ( type ) ; } return registerentity ( type ) ; }	Registers entity. Existing entity will be removed if exist, so no exception will be thrown.
public < e > dbentitydescriptor < e > removeentity ( final class < e > type ) { dbentitydescriptor < e > ded = descriptorsmap . remove ( type ) ; if ( ded == null ) { ded = createdbentitydescriptor ( type ) ; } entitynamesmap . remove ( ded . getentityname ( ) ) ; tablenamesmap . remove ( ded . gettablename ( ) ) ; return ded ; }	Removes entity and returns removed descriptor.
public < e > e createentityinstance ( final class < e > type ) { try { return classutil . newinstance ( type ) ; } catch ( exception ex ) { throw new dboomexception ( ex ) ; } }	Creates new entity instances.
public wrapperproxettafactory settargetinterface ( final class targetinterface ) { if ( ! targetinterface . isinterface ( ) ) { throw new proxettaexception ( str_ + targetinterface . getname ( ) ) ; } this . targetinterface = targetinterface ; return this ; }	Defines the interface of the resulting class.
public void injecttargetintowrapper ( final object target , final object wrapper ) { proxettautil . injecttargetintowrapper ( target , wrapper , targetfieldname ) ; }	Injects target into wrapper.
protected propertydescriptor [ ] lookupannotatedproperties ( final class type ) { propertydescriptor [ ] properties = annotatedproperties . get ( type ) ; if ( properties != null ) { return properties ; } classdescriptor cd = classintrospector . get ( ) . lookup ( type ) ; propertydescriptor [ ] allproperties = cd . getallpropertydescriptors ( ) ; list < propertydescriptor > list = new arraylist < > ( ) ; for ( propertydescriptor propertydescriptor : allproperties ) { annotation ann = null ; if ( propertydescriptor . getfielddescriptor ( ) != null ) { ann = propertydescriptor . getfielddescriptor ( ) . getfield ( ) . getannotation ( annotations ) ; } if ( ann == null && propertydescriptor . getwritemethoddescriptor ( ) != null ) { ann = propertydescriptor . getwritemethoddescriptor ( ) . getmethod ( ) . getannotation ( annotations ) ; } if ( ann == null && propertydescriptor . getreadmethoddescriptor ( ) != null ) { ann = propertydescriptor . getreadmethoddescriptor ( ) . getmethod ( ) . getannotation ( annotations ) ; } if ( ann != null ) { list . add ( propertydescriptor ) ; } } if ( list . isempty ( ) ) { properties = empty ; } else { properties = list . toarray ( new propertydescriptor [ num_ ] ) ; } annotatedproperties . put ( type , properties ) ; return properties ; }	Lookups for annotated properties.
public dbserver detectdatabaseandconfiguredboom ( final connectionprovider cp , final dboomconfig dboomconfig ) { cp . init ( ) ; final connection connection = cp . getconnection ( ) ; final dbserver dbserver = detectdatabase ( connection ) ; cp . closeconnection ( connection ) ; dbserver . accept ( dboomconfig ) ; return dbserver ; }	Detects database and configure DbOom engine.
@ override public void close ( ) throws ioexception { if ( closed ) { return ; } if ( gzipstream != null ) { flushtogzip ( ) ; gzipstream . close ( ) ; gzipstream = null ; } else { if ( buffercount > num_ ) { output . write ( buffer , num_ , buffercount ) ; buffercount = num_ ; } } output . close ( ) ; closed = bool_ ; }	Closes this output stream, causing any buffered data to be flushed and anyfurther output data to throw an IOException.
@ override public void write ( final int b ) throws ioexception { if ( closed ) { throw new ioexception ( str_ ) ; } if ( buffercount >= buffer . length ) { flushtogzip ( ) ; } buffer [ buffercount ++ ] = ( byte ) b ; }	Writes the specified byte to our output stream.
@ override public void dofilter ( final servletrequest request , final servletresponse response , final filterchain chain ) throws ioexception , servletexception { httpservletrequest httprequest = ( httpservletrequest ) request ; httpservletresponse httpresponse = ( httpservletresponse ) response ; if ( isrequestedsessionidfromurl ( httprequest ) ) { httpsession session = httprequest . getsession ( bool_ ) ; if ( session != null ) { session . invalidate ( ) ;	Filters requests to remove URL-based session identifiers.
public string getencodedname ( ) { if ( name == null ) { return null ; } try { return mimeutility . encodetext ( name ) ; } catch ( final unsupportedencodingexception ueex ) { throw new mailexception ( ueex ) ; } }	Returns encoded attachment name.
public byte [ ] tobytearray ( ) { final fastbytearrayoutputstream out ; if ( size != - num_ ) { out = new fastbytearrayoutputstream ( size ) ; } else { out = new fastbytearrayoutputstream ( ) ; } writetostream ( out ) ; return out . tobytearray ( ) ; }	Returns byte content of the attachment.
public void writetofile ( final file destination ) { inputstream input = null ; final outputstream output ; try { input = getdatasource ( ) . getinputstream ( ) ; output = new fileoutputstream ( destination ) ; streamutil . copy ( input , output ) ; } catch ( final ioexception ioex ) { throw new mailexception ( ioex ) ; } finally { streamutil . close ( input ) ; } }	Saves attachment to a file.
public void writetostream ( final outputstream out ) { inputstream input = null ; try { input = getdatasource ( ) . getinputstream ( ) ; streamutil . copy ( input , out ) ; } catch ( final ioexception ioex ) { throw new mailexception ( ioex ) ; } finally { streamutil . close ( input ) ; } }	Saves attachment to the output stream.
protected static string appendargument ( final string desc , final string type ) { int ndx = desc . indexof ( str_ ) ; return desc . substring ( num_ , ndx ) + type + desc . substring ( ndx ) ; }	Appends argument to the existing description.
protected static string prependargument ( final string desc , final string type ) { int ndx = desc . indexof ( str_ ) ; ndx ++ ; return desc . substring ( num_ , ndx ) + type + desc . substring ( ndx ) ; }	Prepends argument to the existing description.
protected static string changereturntype ( final string desc , final string type ) { int ndx = desc . indexof ( str_ ) ; return desc . substring ( num_ , ndx + num_ ) + type ; }	Changes return type.
@ override public void text ( final charsequence text ) { if ( ! strip ) { super . text ( text ) ; return ; } int textlength = text . length ( ) ; char [ ] dest = new char [ textlength ] ; int ndx = num_ ; boolean regularchar = bool_ ; for ( int i = num_ ; i < textlength ; i ++ ) { char c = text . charat ( i ) ; if ( charutil . iswhitespace ( c ) ) { if ( regularchar ) { regularchar = bool_ ; c = str_ ; } else { continue ; } } else { regularchar = bool_ ; } dest [ ndx ] = c ; ndx ++ ; } if ( regularchar || ( ndx != num_ ) ) { super . text ( charbuffer . wrap ( dest , num_ , ndx ) ) ; strippedcharscount += textlength - ndx ; } else { strippedcharscount += textlength ; } }	Cleans unnecessary whitespaces.
public < t > void register ( final class < t > type , final typeconverter < t > typeconverter ) { converters . put ( type , typeconverter ) ; }	Registers a converter for specified type.User must register converter for all super-classes as well.
public < t > typeconverter < t > lookup ( final class < t > type ) { return converters . get ( type ) ; }	Retrieves converter for provided type.
public list < node > select ( final string query ) { collection < list < cssselector > > selectorscollection = csselly . parse ( query ) ; return select ( selectorscollection ) ; }	Selects nodes using CSS3 selector query.
public list < node > select ( final collection < list < cssselector > > selectorscollection ) { list < node > results = new arraylist < > ( ) ; for ( list < cssselector > selectors : selectorscollection ) { processselectors ( results , selectors ) ; } return results ; }	Selected nodes using pre-parsed CSS selectors.
protected void processselectors ( final list < node > results , final list < cssselector > selectors ) { list < node > selectednodes = select ( rootnode , selectors ) ; for ( node selectednode : selectednodes ) { if ( ! results . contains ( selectednode ) ) { results . add ( selectednode ) ; } } }	Process selectors and keep adding results.
public node selectfirst ( final string query ) { list < node > selectednodes = select ( query ) ; if ( selectednodes . isempty ( ) ) { return null ; } return selectednodes . get ( num_ ) ; }	Selects nodes using CSS3 selector query and returns the very first one.
protected void walkdescendantsiteratively ( final linkedlist < node > nodes , final cssselector cssselector , final list < node > result ) { while ( ! nodes . isempty ( ) ) { node node = nodes . removefirst ( ) ; selectandadd ( node , cssselector , result ) ;	Walks over the child notes, maintaining the tree order and not using recursion.
protected void walk ( final node rootnode , final cssselector cssselector , final list < node > result ) {	Finds nodes in the tree that matches single selector.
protected void selectandadd ( final node node , final cssselector cssselector , final list < node > result ) {	Selects single node for single selector and appends it to the results.
private static char [ ] zzunpackcmap ( final string packed ) { char [ ] map = new char [ num_ ] ; int i = num_ ; int j = num_ ; while ( i < num_ ) { int count = packed . charat ( i ++ ) ; char value = packed . charat ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > num_ ) ; } return map ; }	Unpacks the compressed character translation table.
private boolean zzrefill ( ) { if ( zzbuffer == null ) { zzbuffer = zzchars ; zzendread += zzchars . length ; return bool_ ; } return bool_ ; }	Refills the input buffer.
protected < t > pagedata < t > page ( string sql , final map params , final int page , final int pagesize , final string sortcolumnname , final boolean ascending , final class [ ] target ) { if ( sortcolumnname != null ) { sql = buildordersql ( sql , sortcolumnname , ascending ) ; } int from = ( page - num_ ) * pagesize ; string pagesql = buildpagesql ( sql , from , pagesize ) ; dbsqlbuilder dbsql = sql ( pagesql ) ; dboomquery query = query ( dbsql ) ; query . setmaxrows ( pagesize ) ; query . setfetchsize ( pagesize ) ; query . setmap ( params ) ; list < t > list = query . list ( pagesize , target ) ; query . close ( ) ; string countsql = buildcountsql ( sql ) ; dbsql = sql ( countsql ) ; query = query ( dbsql ) ; query . setmap ( params ) ; long count = query . executecount ( ) ; query . close ( ) ; return new pagedata < > ( page , ( int ) count , pagesize , list ) ; }	Pages given page.
protected string removeselect ( string sql ) { int ndx = stringutil . indexofignorecase ( sql , str_ ) ; if ( ndx != - num_ ) { sql = sql . substring ( ndx + num_ ) ;	Removes the first 'select' from the sql query.
protected string removetofrom ( string sql ) { int from = num_ ; int fromcount = num_ ; int selectcount = num_ ; int lastndx = num_ ; while ( bool_ ) { int ndx = stringutil . indexofignorecase ( sql , str_ , from ) ; if ( ndx == - num_ ) { break ; }	Removes the first part of the sql up to the relevant 'from'.Tries to detect sub-queries in the 'select' part.
protected string removelastorderby ( string sql ) { int ndx = stringutil . lastindexofignorecase ( sql , str_ ) ; if ( ndx != - num_ ) { int ndx2 = sql . lastindexof ( sql , str_ ) ; if ( ndx > ndx2 ) { sql = sql . substring ( num_ , ndx ) ; } } return sql ; }	Removes everything from last "order by".
public static string decode ( final string html ) { int ndx = html . indexof ( str_ ) ; if ( ndx == - num_ ) { return html ; } stringbuilder result = new stringbuilder ( html . length ( ) ) ; int lastindex = num_ ; int len = html . length ( ) ; mainloop : while ( ndx != - num_ ) { result . append ( html . substring ( lastindex , ndx ) ) ; lastindex = ndx ; while ( html . charat ( lastindex ) != str_ ) { lastindex ++ ; if ( lastindex == len ) { lastindex = ndx ; break mainloop ; } } if ( html . charat ( ndx + num_ ) == str_ ) {	Decodes HTML text. Assumes that all character references are properly closed with semi-colon.
public static string detectname ( final char [ ] input , int ndx ) { final ptr ptr = new ptr ( ) ; int firstindex = num_ ; int lastindex = entity_names . length - num_ ; int len = input . length ; char [ ] lastname = null ; final binarysearchbase binarysearch = new binarysearchbase ( ) { @ override protected int compare ( final int index ) { char [ ] name = entity_names [ index ] ; if ( ptr . offset >= name . length ) { return - num_ ; } return name [ ptr . offset ] - ptr . c ; } } ; while ( bool_ ) { ptr . c = input [ ndx ] ; if ( ! charutil . isalphaordigit ( ptr . c ) ) { return lastname != null ? new string ( lastname ) : null ; } firstindex = binarysearch . findfirst ( firstindex , lastindex ) ; if ( firstindex < num_ ) { return lastname != null ? new string ( lastname ) : null ; } char [ ] element = entity_names [ firstindex ] ; if ( element . length == ptr . offset + num_ ) {	Detects the longest character reference name on given position in char array.
@ override protected string buildordersql ( string sql , final string column , final boolean ascending ) { sql += str_ + column ; if ( ! ascending ) { sql += str_ ; } return sql ; }	Appends ORDER BY keyword.
@ override protected string buildpagesql ( string sql , final int from , final int pagesize ) { sql = removeselect ( sql ) ; return str_ + from + str_ + pagesize + sql ; }	Builds page sql using LIMIT keyword after the SELECT.
private void resolvecolumnsandproperties ( final class type ) { propertydescriptor [ ] allproperties = classintrospector . get ( ) . lookup ( type ) . getallpropertydescriptors ( ) ; list < dbentitycolumndescriptor > declist = new arraylist < > ( allproperties . length ) ; int idcount = num_ ; hashset < string > names = new hashset < > ( allproperties . length ) ; for ( propertydescriptor propertydescriptor : allproperties ) { dbentitycolumndescriptor dec = dbmetautil . resolvecolumndescriptors ( this , propertydescriptor , isannotated , columnnamingstrategy ) ; if ( dec != null ) { if ( ! names . add ( dec . getcolumnname ( ) ) ) { throw new dboomexception ( str_ + dec . getcolumnname ( ) ) ; } declist . add ( dec ) ; if ( dec . isid ) { idcount ++ ; } } } if ( declist . isempty ( ) ) { throw new dboomexception ( str_ + type ) ; } columndescriptors = declist . toarray ( new dbentitycolumndescriptor [ num_ ] ) ; arrays . sort ( columndescriptors ) ;	Resolves list of all columns and properties.
public dbentitycolumndescriptor findbycolumnname ( final string columnname ) { if ( columnname == null ) { return null ; } init ( ) ; for ( dbentitycolumndescriptor columndescriptor : columndescriptors ) { if ( columndescriptor . columnname . equalsignorecase ( columnname ) ) { return columndescriptor ; } } return null ; }	Finds column descriptor by column name.
public dbentitycolumndescriptor findbypropertyname ( final string propertyname ) { if ( propertyname == null ) { return null ; } init ( ) ; for ( dbentitycolumndescriptor columndescriptor : columndescriptors ) { if ( columndescriptor . propertyname . equals ( propertyname ) ) { return columndescriptor ; } } return null ; }	Finds column descriptor by property name.
public string getpropertyname ( final string columnname ) { dbentitycolumndescriptor dec = findbycolumnname ( columnname ) ; return dec == null ? null : dec . propertyname ; }	Returns property name for specified column name.
public string getcolumnname ( final string propertyname ) { dbentitycolumndescriptor dec = findbypropertyname ( propertyname ) ; return dec == null ? null : dec . columnname ; }	Returns column name for specified property name..
public object getidvalue ( final e object ) { final string propertyname = getidpropertyname ( ) ; return beanutil . declared . getproperty ( object , propertyname ) ; }	Returns ID value for given entity instance.
public void setidvalue ( final e object , final object value ) { final string propertyname = getidpropertyname ( ) ; beanutil . declared . setproperty ( object , propertyname , value ) ; }	Sets ID value for given entity.
public string getkeyvalue ( final e object ) { object idvalue = getidvalue ( object ) ; string idvaluestring = idvalue == null ? stringpool . null : idvalue . tostring ( ) ; return type . getname ( ) . concat ( stringpool . colon ) . concat ( idvaluestring ) ; }	Returns unique key for this entity.
public stringband append ( string s ) { if ( s == null ) { s = stringpool . null ; } if ( index >= array . length ) { expandcapacity ( ) ; } array [ index ++ ] = s ; length += s . length ( ) ; return this ; }	Appends a string.
public void setindex ( final int newindex ) { if ( newindex < num_ ) { throw new arrayindexoutofboundsexception ( newindex ) ; } if ( newindex > array . length ) { string [ ] newarray = new string [ newindex ] ; system . arraycopy ( array , num_ , newarray , num_ , index ) ; array = newarray ; } if ( newindex > index ) { for ( int i = index ; i < newindex ; i ++ ) { array [ i ] = stringpool . empty ; } } else if ( newindex < index ) { for ( int i = newindex ; i < index ; i ++ ) { array [ i ] = null ; } } index = newindex ; length = calculatelength ( ) ; }	Specifies the new index.
protected void expandcapacity ( ) { string [ ] newarray = new string [ array . length << num_ ] ; system . arraycopy ( array , num_ , newarray , num_ , index ) ; array = newarray ; }	Expands internal string array by multiplying its size by 2.
protected int calculatelength ( ) { int len = num_ ; for ( int i = num_ ; i < index ; i ++ ) { len += array [ i ] . length ( ) ; } return len ; }	Calculates string length.
protected string createmixingmessage ( final beandefinition targetbeandefinition , final beandefinition refbeandefinition ) { return str_ + refbeandefinition . name + str_ + refbeandefinition . scope . getclass ( ) . getsimplename ( ) + str_ + targetbeandefinition . name + str_ + targetbeandefinition . scope . getclass ( ) . getsimplename ( ) ; }	Creates mixed scope message.
protected object createscopedproxybean ( final petitecontainer petitecontainer , final beandefinition refbeandefinition ) { class beantype = refbeandefinition . type ; class proxyclass = proxyclasses . get ( beantype ) ; if ( proxyclass == null ) {	Creates scoped proxy bean for given bean definition.
protected void init ( ) { file [ ] filesarray = dir . listfiles ( ) ; filescount = num_ ; if ( filesarray != null ) { filescount = filesarray . length ; for ( file file : filesarray ) { if ( ! acceptfile ( file ) ) { continue ; } map . put ( file , new mutablelong ( file . lastmodified ( ) ) ) ; } } }	Initializes dir watcher by reading all filesfrom watched folder.
protected boolean acceptfile ( final file file ) { if ( ! file . isfile ( ) ) { return bool_ ;	Accepts if a file is going to be watched.
public dirwatcher usewatchfile ( final string name ) { watchfile = new file ( dir , name ) ; if ( ! watchfile . isfile ( ) || ! watchfile . exists ( ) ) { try { fileutil . touch ( watchfile ) ; } catch ( ioexception ioex ) { throw new dirwatcherexception ( str_ + name , ioex ) ; } } watchfilelastaccesstime = watchfile . lastmodified ( ) ; return this ; }	Enables usage of provided watch file.
public void start ( final long pollinginterval ) { if ( timer == null ) { if ( ! startblank ) { init ( ) ; } timer = new timer ( bool_ ) ; timer . schedule ( new watchtask ( ) , num_ , pollinginterval ) ; } }	Starts the watcher.
protected void onchange ( final dirwatcherevent . type type , final file file ) { listeners . accept ( new dirwatcherevent ( type , file ) ) ; }	Triggers listeners on file change.
public void add ( final enumeration < t > enumeration ) { if ( allenumerations . contains ( enumeration ) ) { throw new illegalargumentexception ( str_ ) ; } allenumerations . add ( enumeration ) ; }	Adds an enumeration to this composite.
int computefieldinfosize ( ) {	Returns the size of the field_info JVMS structure generated by this FieldWriter.
void putfieldinfo ( final bytevector output ) { boolean usesyntheticattribute = symboltable . getmajorversion ( ) < opcodes . v1_5 ;	Puts the content of the field_info JVMS structure generated by this FieldWriter into the givenByteVector.
public static target ofvalue ( final object value , final scopedata scopedata ) { return new target ( value , null , scopedata , null , value_instance_creator ) ; }	Creates a common target over a value, with known scope data.
public void writevalue ( final injectionpoint injectionpoint , final object propertyvalue , final boolean silent ) { writevalue ( injectionpoint . targetname ( ) , propertyvalue , silent ) ; }	Writes value to this target.
public void decorate ( final writer writer , final char [ ] pagecontent , final char [ ] decoracontent ) throws ioexception { decoratag [ ] decoratags = parsedecorator ( decoracontent ) ; parsepage ( pagecontent , decoratags ) ; writedecoratedpage ( writer , decoracontent , pagecontent , decoratags ) ; }	Decorates page content with decorator template and outputs the result.
protected void parsepage ( final char [ ] pagecontent , final decoratag [ ] decoratags ) { lagartoparser lagartoparser = new lagartoparser ( pagecontent ) ; pageregionextractor writer = new pageregionextractor ( decoratags ) ; lagartoparser . parse ( writer ) ; }	Parses target page and extracts Decora regions for replacements.
protected void writedecoratedpage ( final writer out , final char [ ] decoratorcontent , final char [ ] pagecontent , final decoratag [ ] decoratags ) throws ioexception { int ndx = num_ ; for ( decoratag decoratag : decoratags ) {	Writes decorated content.
protected void writeregion ( final writer out , final char [ ] pagecontent , final decoratag decoratag , final decoratag [ ] decoratags ) throws ioexception { int regionstart = decoratag . getregionstart ( ) ; int regionlen = decoratag . getregionlength ( ) ; int regionend = regionstart + regionlen ; for ( decoratag innerdecoratag : decoratags ) { if ( decoratag == innerdecoratag ) { continue ; } if ( decoratag . isregionundefined ( ) ) { continue ; } if ( innerdecoratag . isinsideothertagregion ( decoratag ) ) {	Writes region to output, but extracts all inner regions.
public void start ( ) throws ioexception { serversocket = new serversocket ( listenport , socketbacklog ) ; serversocket . setreuseaddress ( bool_ ) ; executorservice = executors . newfixedthreadpool ( threadpoolsize ) ; running = bool_ ; while ( running ) { socket socket = serversocket . accept ( ) ; socket . setkeepalive ( bool_ ) ; executorservice . execute ( onsocketconnection ( socket ) ) ; } executorservice . shutdown ( ) ; }	Starts HTTP tunnel. Method ends when the tunnel is stopped.
public static processresult run ( final process process ) throws interruptedexception { final bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; final streamgobbler outputgobbler = new streamgobbler ( process . getinputstream ( ) , baos , output_prefix ) ; final streamgobbler errorgobbler = new streamgobbler ( process . geterrorstream ( ) , baos , error_prefix ) ; outputgobbler . start ( ) ; errorgobbler . start ( ) ; final int result = process . waitfor ( ) ; outputgobbler . waitfor ( ) ; errorgobbler . waitfor ( ) ; return new processresult ( result , baos . tostring ( ) ) ; }	Executes a process and returns the process output and exit code.
@ override protected imapsslstore getstore ( final session session ) { simpleauthenticator simpleauthenticator = ( simpleauthenticator ) authenticator ; final urlname url ; if ( simpleauthenticator == null ) { url = new urlname ( protocol_imap , host , port , stringpool . empty , null , null ) ; } else { final passwordauthentication pa = simpleauthenticator . getpasswordauthentication ( ) ; url = new urlname ( protocol_imap , host , port , stringpool . empty , pa . getusername ( ) , pa . getpassword ( ) ) ; } return new imapsslstore ( session , url ) ; }	Returns email store.
public servletoutputstream createoutputstream ( ) throws ioexception { gzipresponsestream gzstream = new gzipresponsestream ( origresponse ) ; gzstream . setbuffer ( threshold ) ; return gzstream ; }	Creates and returns a ServletOutputStream to write the content associatedwith this Response.
@ override public void init ( final templatedata templatedata ) { super . init ( templatedata ) ; if ( hint != null ) { templatedata . incrementhintscount ( ) ; } }	Counts actual real hints.
protected void appendcolumnname ( final stringbuilder query , final dbentitydescriptor ded , final dbentitycolumndescriptor dec ) { query . append ( resolvetable ( tableref , ded ) ) . append ( str_ ) . append ( dec . getcolumnname ( ) ) ; if ( templatedata . getcolumnaliastype ( ) != null ) {	Simply appends column name with optional table reference and alias.
protected void addrule ( final d ruledefinition , final boolean include ) { if ( rules == null ) { rules = new arraylist < > ( ) ; } if ( include ) { includescount ++ ; } else { excludescount ++ ; } rule < r > newrule = new rule < > ( makerule ( ruledefinition ) , include ) ; if ( rules . contains ( newrule ) ) { return ; } rules . add ( newrule ) ; }	Adds a rule. Duplicates are not allowed and will be ignored.
public boolean apply ( final v value , final boolean blacklist , boolean flag ) { if ( rules == null ) { return flag ; } if ( blacklist ) { flag = processexcludes ( value , flag ) ; flag = processincludes ( value , flag ) ; } else { flag = processincludes ( value , flag ) ; flag = processexcludes ( value , flag ) ; } return flag ; }	Applies rules on given flag.
protected boolean processincludes ( final v value , boolean include ) { if ( includescount > num_ ) { if ( ! include ) { for ( rule < r > rule : rules ) { if ( ! rule . include ) { continue ; } if ( inexrulematcher . accept ( value , rule . value , bool_ ) ) { include = bool_ ; break ; } } } } return include ; }	Process includes rules.
protected boolean processexcludes ( final v value , boolean include ) { if ( excludescount > num_ ) { if ( include ) { for ( rule < r > rule : rules ) { if ( rule . include ) { continue ; } if ( inexrulematcher . accept ( value , rule . value , bool_ ) ) { include = bool_ ; break ; } } } } return include ; }	Process excludes rules.
public string getpseudoclassname ( ) { string name = getclass ( ) . getsimplename ( ) . tolowercase ( ) ; name = name . replace ( str_ , str_ ) ; return name ; }	Returns pseudo-class name from simple class name.
@ override public boolean addall ( final collection < ? extends e > c ) { iterator < ? extends e > i = c . iterator ( ) ; boolean changed = bool_ ; while ( i . hasnext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }	Add all of the elements in the given collection to this list.
protected int findinsertionpoint ( final e o , int low , int high ) { while ( low <= high ) { int mid = ( low + high ) > > > num_ ; int delta = compare ( get ( mid ) , o ) ; if ( delta > num_ ) { high = mid - num_ ; } else { low = mid + num_ ; } } return low ; }	Conducts a binary search to find the index where Objectshould be inserted.
public void bindannotationconfig ( final class < ? extends annotation > annotationtype , final class < ? extends actionconfig > actionconfigclass ) { final actionconfig actionconfig = registernewactionconfiguration ( actionconfigclass ) ; actionconfigs . put ( annotationtype , actionconfig ) ; for ( final annotationparser annotationparser : annotationparsers ) { if ( annotationtype . equals ( annotationparser . getannotationtype ( ) ) ) {	Binds action annotation and the action config.
protected actionconfig registernewactionconfiguration ( final class < ? extends actionconfig > actionconfigclass ) { final actionconfig newactionconfig = createactionconfig ( actionconfigclass ) ; actionconfigs . put ( actionconfigclass , newactionconfig ) ; return newactionconfig ; }	Registers action configuration for given type.
public actionconfig lookup ( final class actiontypeorannotationtype ) { final actionconfig actionconfig = actionconfigs . get ( actiontypeorannotationtype ) ; if ( actionconfig == null ) { throw new madvocexception ( str_ + actiontypeorannotationtype . getname ( ) ) ; } return actionconfig ; }	Lookup for the action configuration.
public < t extends actionconfig > void with ( final class < t > actionconfigtype , final consumer < t > actionconfigconsumer ) { final t actionconfig = ( t ) lookup ( actionconfigtype ) ; actionconfigconsumer . accept ( actionconfig ) ; }	Fetch some action config and consumes it.
protected static void setupsystemmailproperties ( ) { system . setproperty ( str_ , boolean . valueof ( defaults . mailmimeencodefilename ) . tostring ( ) ) ; system . setproperty ( str_ , boolean . valueof ( defaults . mailmimedecodefilename ) . tostring ( ) ) ; }	Setups the system email properties.
public void validatewithin ( final validationcontext vctx , final object value ) { vtor . validate ( vctx , value , name ) ; }	Validates provided context and value withing this constraint content.
protected element findlasttable ( final node node ) { node tablenode = node ; while ( tablenode != null ) { if ( tablenode . getnodetype ( ) == node . nodetype . element ) { string tablenodename = tablenode . getnodename ( ) . tolowercase ( ) ; if ( tablenodename . equals ( str_ ) ) { break ; } } tablenode = tablenode . getparentnode ( ) ; } return ( element ) tablenode ; }	Finds the last table in stack of open elements.
protected void fixelements ( ) { for ( element fosterelement : fosterelements ) {	Performs the fix for elements.
protected map < string , beandata > registersessionbeans ( final httpsession httpsession ) { sessionbeans sessionbeans = new sessionbeans ( ) ; httpsession . setattribute ( session_beans_name , sessionbeans ) ; return sessionbeans . getbeanmap ( ) ; }	Registers new session destroy callback if not already registered.
@ suppresswarnings ( str_ ) protected map < string , beandata > getsessionmap ( final httpsession session ) { sessionbeans sessionbeans = ( sessionbeans ) session . getattribute ( session_beans_name ) ; if ( sessionbeans == null ) { return null ; } return sessionbeans . getbeanmap ( ) ; }	Returns instance map from http session.
public void init ( string name , final string supername , final string suffix , final string reqproxyclassname ) { int lastslash = name . lastindexof ( str_ ) ; this . targetpackage = lastslash == - num_ ? stringpool . empty : name . substring ( num_ , lastslash ) . replace ( str_ , str_ ) ; this . targetclassname = name . substring ( lastslash + num_ ) ; this . nextsupername = supername ; this . supername = name ;	Work data initialization.
void addadviceinitmethod ( final string name ) { if ( adviceinits == null ) { adviceinits = new arraylist < > ( ) ; } adviceinits . add ( name ) ; }	Saves used constructors of advices.
public void end ( ) { if ( newaction ) { bundleid = bundlesmanager . registerbundle ( contextpath , actionpath , bundleid , bundlecontenttype , sources ) ; } }	Called on end of parsing.
protected void add ( final string section , final string key , final stringbuilder value , final boolean trim , final operator operator ) {	Adds accumulated value to key and current section.
protected void extractprofilesandadd ( final string key , final string value , final operator operator ) { string fullkey = key ; int ndx = fullkey . indexof ( profile_left ) ; if ( ndx == - num_ ) { justadd ( fullkey , value , null , operator ) ; return ; }	Extracts profiles from the key name and adds key-value to them.
protected void justadd ( final string key , final string value , final arraylist < string > keyprofiles , final operator operator ) { if ( operator == operator . copy ) { hashmap < string , object > target = new hashmap < > ( ) ; string [ ] profiles = null ; if ( keyprofiles != null ) { profiles = keyprofiles . toarray ( new string [ num_ ] ) ; } string [ ] sources = stringutil . splitc ( value , str_ ) ; for ( string source : sources ) { source = source . trim ( ) ;	Core key-value addition.
public static string typedesc2classname ( final string desc ) { string classname = desc ; switch ( desc . charat ( num_ ) ) { case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : if ( desc . length ( ) != num_ ) { throw new illegalargumentexception ( invalid_base_type + desc ) ; } break ; case str_ : classname = classname . substring ( num_ , classname . length ( ) - num_ ) ; break ; case str_ :	Converts bytecode-like description to java class name that can be loadedwith a classloader.
public static string typeref2name ( final string desc ) { if ( desc . charat ( num_ ) != type_reference ) { throw new illegalargumentexception ( invalid_type_description + desc ) ; } string name = desc . substring ( num_ , desc . length ( ) - num_ ) ; return name . replace ( str_ , str_ ) ; }	Converts type reference to java-name.
public static string typetotyperef ( final class type ) { if ( ! type . isarray ( ) ) { if ( ! type . isprimitive ( ) ) { return str_ + typetosignature ( type ) + str_ ; } if ( type == int . class ) { return str_ ; } if ( type == long . class ) { return str_ ; } if ( type == boolean . class ) { return str_ ; } if ( type == double . class ) { return str_ ; } if ( type == float . class ) { return str_ ; } if ( type == short . class ) { return str_ ; } if ( type == void . class ) { return str_ ; } if ( type == byte . class ) { return str_ ; } if ( type == char . class ) { return str_ ; } } return type . getname ( ) ; }	Converts type to byteccode type ref.
public consumers < t > addall ( final consumer < t > ... consumers ) { collections . addall ( consumerlist , consumers ) ; return this ; }	Registers additional consumers.
@ suppresswarnings ( str_ ) protected collection < t > createcollection ( final int length ) { if ( collectiontype . isinterface ( ) ) { if ( collectiontype == list . class ) { if ( length > num_ ) { return new arraylist < > ( length ) ; } else { return new arraylist < > ( ) ; } } if ( collectiontype == set . class ) { if ( length > num_ ) { return new hashset < > ( length ) ; } else { return new hashset < > ( ) ; } } throw new typeconversionexception ( str_ + collectiontype . getname ( ) ) ; } if ( length > num_ ) { try { constructor < collection < t > > ctor = ( constructor < collection < t > > ) collectiontype . getconstructor ( int . class ) ; return ctor . newinstance ( integer . valueof ( length ) ) ; } catch ( exception ex ) {	Creates new collection of target component type.Default implementation uses reflection to createan collection of target type.
protected collection < t > converttosingleelementcollection ( final object value ) { collection < t > collection = createcollection ( num_ ) ;	Creates a collection with single element.
protected collection < t > convertvaluetocollection ( object value ) { if ( value instanceof iterable ) { iterable iterable = ( iterable ) value ; collection < t > collection = createcollection ( num_ ) ; for ( object element : iterable ) { collection . add ( converttype ( element ) ) ; } return collection ; } if ( value instanceof charsequence ) { value = csvutil . tostringarray ( value . tostring ( ) ) ; } class type = value . getclass ( ) ; if ( type . isarray ( ) ) {	Converts non-collection value to collection.
protected collection < t > convertcollectiontocollection ( final collection value ) { collection < t > collection = createcollection ( value . size ( ) ) ; for ( object v : value ) { collection . add ( converttype ( v ) ) ; } return collection ; }	Converts collection value to target collection.Each element is converted to target component type.
final void addlinenumber ( final int linenumber ) { if ( this . linenumber == num_ ) { this . linenumber = ( short ) linenumber ; } else { if ( otherlinenumbers == null ) { otherlinenumbers = new int [ line_numbers_capacity_increment ] ; } int otherlinenumberindex = ++ otherlinenumbers [ num_ ] ; if ( otherlinenumberindex >= otherlinenumbers . length ) { int [ ] newlinenumbers = new int [ otherlinenumbers . length + line_numbers_capacity_increment ] ; system . arraycopy ( otherlinenumbers , num_ , newlinenumbers , num_ , otherlinenumbers . length ) ; otherlinenumbers = newlinenumbers ; } otherlinenumbers [ otherlinenumberindex ] = linenumber ; } }	Adds a source line number corresponding to this label.
final void accept ( final methodvisitor methodvisitor , final boolean visitlinenumbers ) { methodvisitor . visitlabel ( this ) ; if ( visitlinenumbers && linenumber != num_ ) { methodvisitor . visitlinenumber ( linenumber & num_ , this ) ; if ( otherlinenumbers != null ) { for ( int i = num_ ; i <= otherlinenumbers [ num_ ] ; ++ i ) { methodvisitor . visitlinenumber ( otherlinenumbers [ i ] , this ) ; } } } }	Makes the given visitor visit this label and its source line numbers, if applicable.
final void put ( final bytevector code , final int sourceinsnbytecodeoffset , final boolean widereference ) { if ( ( flags & flag_resolved ) == num_ ) { if ( widereference ) { addforwardreference ( sourceinsnbytecodeoffset , forward_reference_type_wide , code . length ) ; code . putint ( - num_ ) ; } else { addforwardreference ( sourceinsnbytecodeoffset , forward_reference_type_short , code . length ) ; code . putshort ( - num_ ) ; } } else { if ( widereference ) { code . putint ( bytecodeoffset - sourceinsnbytecodeoffset ) ; } else { code . putshort ( bytecodeoffset - sourceinsnbytecodeoffset ) ; } } }	Puts a reference to this label in the bytecode of a method.
private void addforwardreference ( final int sourceinsnbytecodeoffset , final int referencetype , final int referencehandle ) { if ( forwardreferences == null ) { forwardreferences = new int [ forward_references_capacity_increment ] ; } int lastelementindex = forwardreferences [ num_ ] ; if ( lastelementindex + num_ >= forwardreferences . length ) { int [ ] newvalues = new int [ forwardreferences . length + forward_references_capacity_increment ] ; system . arraycopy ( forwardreferences , num_ , newvalues , num_ , forwardreferences . length ) ; forwardreferences = newvalues ; } forwardreferences [ ++ lastelementindex ] = sourceinsnbytecodeoffset ; forwardreferences [ ++ lastelementindex ] = referencetype | referencehandle ; forwardreferences [ num_ ] = lastelementindex ; }	Adds a forward reference to this label.
final void marksubroutine ( final short subroutineid ) {	Finds the basic blocks that belong to the subroutine starting with the basic blockcorresponding to this label, and marks these blocks as belonging to this subroutine.
protected int [ ] comparedigits ( final string str1 , int ndx1 , final string str2 , int ndx2 ) {	Compare digits at certain position in two strings.The longest run of digits wins.
private char fixaccent ( final char c ) { for ( int i = num_ ; i < accent_chars . length ; i += num_ ) { final char accentchar = accent_chars [ i ] ; if ( accentchar == c ) { return accent_chars [ i + num_ ] ; } } return c ; }	Fixes accent char.
public bytevector putbyte ( final int bytevalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } data [ currentlength ++ ] = ( byte ) bytevalue ; length = currentlength ; return this ; }	Puts a byte into this byte vector.
final bytevector put11 ( final int bytevalue1 , final int bytevalue2 ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) bytevalue1 ; currentdata [ currentlength ++ ] = ( byte ) bytevalue2 ; length = currentlength ; return this ; }	Puts two bytes into this byte vector.
public bytevector putshort ( final int shortvalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) ( shortvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) shortvalue ; length = currentlength ; return this ; }	Puts a short into this byte vector.
final bytevector put12 ( final int bytevalue , final int shortvalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) bytevalue ; currentdata [ currentlength ++ ] = ( byte ) ( shortvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) shortvalue ; length = currentlength ; return this ; }	Puts a byte and a short into this byte vector.
final bytevector put112 ( final int bytevalue1 , final int bytevalue2 , final int shortvalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) bytevalue1 ; currentdata [ currentlength ++ ] = ( byte ) bytevalue2 ; currentdata [ currentlength ++ ] = ( byte ) ( shortvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) shortvalue ; length = currentlength ; return this ; }	Puts two bytes and a short into this byte vector.
public bytevector putint ( final int intvalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) intvalue ; length = currentlength ; return this ; }	Puts an int into this byte vector.
final bytevector put122 ( final int bytevalue , final int shortvalue1 , final int shortvalue2 ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; currentdata [ currentlength ++ ] = ( byte ) bytevalue ; currentdata [ currentlength ++ ] = ( byte ) ( shortvalue1 > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) shortvalue1 ; currentdata [ currentlength ++ ] = ( byte ) ( shortvalue2 > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) shortvalue2 ; length = currentlength ; return this ; }	Puts one byte and two shorts into this byte vector.
public bytevector putlong ( final long longvalue ) { int currentlength = length ; if ( currentlength + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] currentdata = data ; int intvalue = ( int ) ( longvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) intvalue ; intvalue = ( int ) longvalue ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) ( intvalue > > > num_ ) ; currentdata [ currentlength ++ ] = ( byte ) intvalue ; length = currentlength ; return this ; }	Puts a long into this byte vector.
public bytevector putbytearray ( final byte [ ] bytearrayvalue , final int byteoffset , final int bytelength ) { if ( length + bytelength > data . length ) { enlarge ( bytelength ) ; } if ( bytearrayvalue != null ) { system . arraycopy ( bytearrayvalue , byteoffset , data , length , bytelength ) ; } length += bytelength ; return this ; }	Puts an array of bytes into this byte vector.
private void enlarge ( final int size ) { int doublecapacity = num_ * data . length ; int minimalcapacity = length + size ; byte [ ] newdata = new byte [ doublecapacity > minimalcapacity ? doublecapacity : minimalcapacity ] ; system . arraycopy ( data , num_ , newdata , num_ , length ) ; data = newdata ; }	Enlarges this byte vector so that it can receive 'size' more bytes.
protected t authenticateuserviahttpsession ( final actionrequest actionrequest ) { final httpservletrequest servletrequest = actionrequest . gethttpservletrequest ( ) ; final usersession < t > usersession = usersession . get ( servletrequest ) ; if ( usersession == null ) { return null ; } final t authtoken = usersession . getauthtoken ( ) ; if ( authtoken == null ) { return null ; }	Tries to authenticate user via HTTP session.
protected t authenticateuserviatoken ( final actionrequest actionrequest ) { final httpservletrequest servletrequest = actionrequest . gethttpservletrequest ( ) ;	Tries to authenticate user via token.
protected t authenticateuserviabasicauth ( final actionrequest actionrequest ) { final httpservletrequest servletrequest = actionrequest . gethttpservletrequest ( ) ; final string username = servletutil . resolveauthusername ( servletrequest ) ; if ( username == null ) { return null ; } final string password = servletutil . resolveauthpassword ( servletrequest ) ; final t authtoken = userauth ( ) . login ( username , password ) ; if ( authtoken == null ) { return null ; } return authtoken ; }	Tires to authenticate user via the basic authentication.
public string finddefaultmessage ( final locale locale , final string key ) { string indexedkey = calcindexkey ( key ) ; string msg = getmessage ( fallbackbundlename , locale , key , indexedkey ) ; if ( msg != null ) { return msg ; } for ( string bname : defaultbundles ) { msg = getmessage ( bname , locale , key , indexedkey ) ; if ( msg != null ) { return msg ; } } return null ; }	Finds message in default bundles only, starting from fallback bundlename.
protected resourcebundle getbundle ( final string bundlename , final locale locale , final classloader classloader ) { return resourcebundle . getbundle ( bundlename , locale , classloader ) ; }	Returns specified bundle. Invoked every time if cache is disabled.Input arguments are always valid.
protected k get ( final k [ ] array , final int index ) { return ( k ) array . get ( array , index ) ; }	Returns array's element at given index.
protected < e , id > void setentityid ( final dbentitydescriptor < e > ded , final e entity , final id newidvalue ) { ded . setidvalue ( entity , newidvalue ) ; }	Sets new ID value for entity.
public void save ( final object entity ) { final dbquery q = query ( dboom . entities ( ) . insert ( entity ) ) ; q . autoclose ( ) . executeupdate ( ) ; }	Simply inserts object into the database.
public void update ( final object entity ) { query ( dboom . entities ( ) . updateall ( entity ) ) . autoclose ( ) . executeupdate ( ) ; }	Updates single entity.
public < e > e updateproperty ( final e entity , final string name , final object newvalue ) { query ( dboom . entities ( ) . updatecolumn ( entity , name , newvalue ) ) . autoclose ( ) . executeupdate ( ) ; beanutil . declared . setproperty ( entity , name , newvalue ) ; return entity ; }	Updates single property in database and in the bean.
public < e > e updateproperty ( final e entity , final string name ) { object value = beanutil . declared . getproperty ( entity , name ) ; query ( dboom . entities ( ) . updatecolumn ( entity , name , value ) ) . autoclose ( ) . executeupdate ( ) ; return entity ; }	Updates property in the database by storing the current property value.
public < e , id > e findbyid ( final class < e > entitytype , final id id ) { return query ( dboom . entities ( ) . findbyid ( entitytype , id ) ) . autoclose ( ) . find ( entitytype ) ; }	Finds single entity by its id.
public < e > e findonebyproperty ( final class < e > entitytype , final string name , final object value ) { return query ( dboom . entities ( ) . findbycolumn ( entitytype , name , value ) ) . autoclose ( ) . find ( entitytype ) ; }	Finds single entity by matching property.
@ suppresswarnings ( { str_ } ) public < e > e findone ( final object criteria ) { return ( e ) query ( dboom . entities ( ) . find ( criteria ) ) . autoclose ( ) . find ( criteria . getclass ( ) ) ; }	Finds one entity for given criteria.
public < id > void deletebyid ( final class entitytype , final id id ) { query ( dboom . entities ( ) . deletebyid ( entitytype , id ) ) . autoclose ( ) . executeupdate ( ) ; }	Deleted single entity by its id.
public void deletebyid ( final object entity ) { if ( entity != null ) { int result = query ( dboom . entities ( ) . deletebyid ( entity ) ) . autoclose ( ) . executeupdate ( ) ; if ( result != num_ ) {	Delete single object by its id.
public long count ( final class entitytype ) { return query ( dboom . entities ( ) . count ( entitytype ) ) . autoclose ( ) . executecount ( ) ; }	Counts number of all entities.
public < id > void increaseproperty ( final class entitytype , final id id , final string name , final number delta ) { query ( dboom . entities ( ) . increasecolumn ( entitytype , id , name , delta , bool_ ) ) . autoclose ( ) . executeupdate ( ) ; }	Increases a property.
public < id > void decreaseproperty ( final class entitytype , final id id , final string name , final number delta ) { query ( dboom . entities ( ) . increasecolumn ( entitytype , id , name , delta , bool_ ) ) . autoclose ( ) . executeupdate ( ) ; }	Decreases a property.
public < e > list < e > findrelated ( final class < e > target , final object source ) { return query ( dboom . entities ( ) . findforeign ( target , source ) ) . autoclose ( ) . list ( target ) ; }	Finds related entity.
public < e > list < e > listall ( final class < e > target ) { return query ( dboom . entities ( ) . from ( target ) ) . autoclose ( ) . list ( target ) ; }	List all entities.
@ override public void clear ( ) { entries = null ; iterator < string > keys = getattributenames ( ) ; while ( keys . hasnext ( ) ) { removeattribute ( keys . next ( ) ) ; } }	Removes all attributes from the request as well as clears entries in this map.
@ override public set < entry < string , object > > entryset ( ) { if ( entries == null ) { entries = new hashset < > ( ) ; iterator < string > iterator = getattributenames ( ) ; while ( iterator . hasnext ( ) ) { final string key = iterator . next ( ) ; final object value = getattribute ( key ) ; entries . add ( new entry < string , object > ( ) { @ override public boolean equals ( final object obj ) { if ( obj == null ) { return bool_ ; } if ( this . getclass ( ) != obj . getclass ( ) ) { return bool_ ; } entry entry = ( entry ) obj ; return ( ( key == null ) ? ( entry . getkey ( ) == null ) : key . equals ( entry . getkey ( ) ) ) && ( ( value == null ) ? ( entry . getvalue ( ) == null ) : value . equals ( entry . getvalue ( ) ) ) ; } @ override public int hashcode ( ) { return ( ( key == null ) ? num_ : key . hashcode ( ) ) ^ ( ( value == null ) ? num_ : value . hashcode ( ) ) ; } @ override public string getkey ( ) { return key ; } @ override public object getvalue ( ) { return value ; } @ override public object setvalue ( final object obj ) { setattribute ( key , obj ) ; return value ; } } ) ; } } return entries ; }	Returns a Set of attributes from the http request.
@ override public object put ( final string key , final object value ) { entries = null ; object previous = get ( key ) ; setattribute ( key , value ) ; return previous ; }	Saves an attribute in the request.
@ override public object remove ( final object key ) { entries = null ; object value = get ( key ) ; removeattribute ( key . tostring ( ) ) ; return value ; }	Removes the specified request attribute.
@ suppresswarnings ( { str_ } ) public static stacktraceelement [ ] getcurrentstacktrace ( ) { stacktraceelement [ ] ste = new exception ( ) . getstacktrace ( ) ; if ( ste . length > num_ ) { stacktraceelement [ ] result = new stacktraceelement [ ste . length - num_ ] ; system . arraycopy ( ste , num_ , result , num_ , ste . length - num_ ) ; return result ; } else { return ste ; } }	Returns current stack trace in form of array of stack trace elements.First stack trace element is removed.Since an exception is thrown internally, this method is slow.
public static stacktraceelement [ ] getstacktrace ( final throwable t , final string [ ] allow , final string [ ] deny ) { stacktraceelement [ ] st = t . getstacktrace ( ) ; arraylist < stacktraceelement > result = new arraylist < > ( st . length ) ; elementloop : for ( stacktraceelement element : st ) { string classname = element . getclassname ( ) ; if ( allow != null ) { boolean validelemenet = bool_ ; for ( string filter : allow ) { if ( classname . contains ( filter ) ) { validelemenet = bool_ ; break ; } } if ( ! validelemenet ) { continue ; } } if ( deny != null ) { for ( string filter : deny ) { if ( classname . contains ( filter ) ) { continue elementloop ; } } } result . add ( element ) ; } st = new stacktraceelement [ result . size ( ) ] ; return result . toarray ( st ) ; }	Returns stack trace filtered by class names.
public static stacktraceelement [ ] [ ] getstacktracechain ( throwable t , final string [ ] allow , final string [ ] deny ) { arraylist < stacktraceelement [ ] > result = new arraylist < > ( ) ; while ( t != null ) { stacktraceelement [ ] stack = getstacktrace ( t , allow , deny ) ; result . add ( stack ) ; t = t . getcause ( ) ; } stacktraceelement [ ] [ ] allstacks = new stacktraceelement [ result . size ( ) ] [ ] ; for ( int i = num_ ; i < allstacks . length ; i ++ ) { allstacks [ i ] = result . get ( i ) ; } return allstacks ; }	Returns stack trace chain filtered by class names.
public static throwable [ ] getexceptionchain ( throwable throwable ) { arraylist < throwable > list = new arraylist < > ( ) ; list . add ( throwable ) ; while ( ( throwable = throwable . getcause ( ) ) != null ) { list . add ( throwable ) ; } throwable [ ] result = new throwable [ list . size ( ) ] ; return list . toarray ( result ) ; }	Returns exception chain starting from top up to root cause.
public static string exceptionstacktracetostring ( final throwable t ) { stringwriter sw = new stringwriter ( ) ; printwriter pw = new printwriter ( sw , bool_ ) ; t . printstacktrace ( pw ) ; streamutil . close ( pw ) ; streamutil . close ( sw ) ; return sw . tostring ( ) ; }	Prints stack trace into a String.
public static string exceptionchaintostring ( throwable t ) { stringwriter sw = new stringwriter ( ) ; printwriter pw = new printwriter ( sw , bool_ ) ; while ( t != null ) { t . printstacktrace ( pw ) ; t = t . getcause ( ) ; } streamutil . close ( pw ) ; streamutil . close ( sw ) ; return sw . tostring ( ) ; }	Prints full exception stack trace, from top to root cause, into a String.
public static string buildmessage ( final string message , throwable cause ) { if ( cause != null ) { cause = getrootcause ( cause ) ; stringbuilder buf = new stringbuilder ( ) ; if ( message != null ) { buf . append ( message ) . append ( str_ ) ; } buf . append ( str_ ) . append ( cause ) ; return buf . tostring ( ) ; } else { return message ; } }	Build a message for the given base message and its cause.
public static throwable unwrapthrowable ( final throwable wrappedthrowable ) { throwable unwrapped = wrappedthrowable ; while ( bool_ ) { if ( unwrapped instanceof invocationtargetexception ) { unwrapped = ( ( invocationtargetexception ) unwrapped ) . gettargetexception ( ) ; } else if ( unwrapped instanceof undeclaredthrowableexception ) { unwrapped = ( ( undeclaredthrowableexception ) unwrapped ) . getundeclaredthrowable ( ) ; } else { return unwrapped ; } } }	Unwraps invocation and undeclared exceptions to real cause.
protected void registerasconsumer ( final classscanner classscanner ) { classscanner . registerentryconsumer ( classpathentry -> { final string entryname = classpathentry . name ( ) ; if ( entryname . endswith ( actionclasssuffix ) ) { try { acceptactionclass ( classpathentry . loadclass ( ) ) ; } catch ( exception ex ) { log . debug ( str_ + entryname ) ; } } else if ( classpathentry . istypesignatureinuse ( madvoc_component_annotation ) ) { try { acceptmadvoccomponentclass ( classpathentry . loadclass ( ) ) ; } catch ( exception ex ) { log . debug ( str_ + entryname ) ; } } } ) ; }	Parses class name that matches madvoc-related names.
protected void acceptmadvoccomponentclass ( final class componentclass ) { if ( componentclass == null ) { return ; } if ( ! checkclass ( componentclass ) ) { return ; } madvoccomponents . add ( ( ) -> madvoccontainer . registercomponent ( componentclass ) ) ; }	Registers new Madvoc component.
public static classloader getsystemclassloader ( ) { if ( system . getsecuritymanager ( ) == null ) { return classloader . getsystemclassloader ( ) ; } else { return accesscontroller . doprivileged ( ( privilegedaction < classloader > ) classloader :: getsystemclassloader ) ; } }	Returns system class loader.
public static inputstream getresourceasstream ( final string resourcename , final classloader callingclass ) throws ioexception { url url = getresourceurl ( resourcename , callingclass ) ; if ( url != null ) { return url . openstream ( ) ; } return null ; }	Opens a resource of the specified name for reading.
public static inputstream getresourceasstream ( final string resourcename , final classloader callingclass , final boolean usecache ) throws ioexception { url url = getresourceurl ( resourcename , callingclass ) ; if ( url != null ) { urlconnection urlconnection = url . openconnection ( ) ; urlconnection . setusecaches ( usecache ) ; return urlconnection . getinputstream ( ) ; } return null ; }	Opens a resource of the specified name for reading.
public static inputstream getclassasstream ( final class clazz ) throws ioexception { return getresourceasstream ( classutil . convertclassnametofilename ( clazz ) , clazz . getclassloader ( ) ) ; }	Opens a class of the specified name for reading using class classloader.
public static inputstream getclassasstream ( final string classname , final classloader classloader ) throws ioexception { return getresourceasstream ( classutil . convertclassnametofilename ( classname ) , classloader ) ; }	Opens a class of the specified name for reading using provided class loader.
public routechunk add ( final string newvalue ) { routechunk routechunk = new routechunk ( routes , this , newvalue ) ; if ( children == null ) { children = new routechunk [ ] { routechunk } ; } else { children = arraysutil . append ( children , routechunk ) ; } return routechunk ; }	Adds a new child to the tree.
public routechunk findorcreatechild ( final string value ) { if ( children != null ) { for ( routechunk child : children ) { if ( child . get ( ) . equals ( value ) ) { return child ; } } } return add ( value ) ; }	Finds existing chunk or creates a new one if does not exist.
public void parserequest ( ) throws ioexception { if ( servletutil . ismultipartrequest ( request ) ) { parserequeststream ( request . getinputstream ( ) , characterencoding ) ; } else { enumeration names = request . getparameternames ( ) ; while ( names . hasmoreelements ( ) ) { string paramname = ( string ) names . nextelement ( ) ; string [ ] values = request . getparametervalues ( paramname ) ; putparameters ( paramname , values ) ; } } }	Checks if request if multi-part and parse it.
@ suppresswarnings ( str_ ) protected object converttocollection ( final object value , final class destinationtype , final class componenttype ) { return typeconvertermanager . converttocollection ( value , destinationtype , componenttype ) ; }	Converter to collection.
protected object invokesetter ( final setter setter , final beanproperty bp , object value ) { try { final mapperfunction settermapperfunction = setter . getmapperfunction ( ) ; if ( settermapperfunction != null ) { value = settermapperfunction . apply ( value ) ; } final class type = setter . getsetterrawtype ( ) ; if ( classutil . istypeof ( type , collection . class ) ) { class componenttype = setter . getsetterrawcomponenttype ( ) ; value = converttocollection ( value , type , componenttype ) ; } else {	Invokes setter, but first converts type to match the setter type.
protected void arrayforcedset ( final beanproperty bp , object array , final int index , object value ) { class componenttype = array . getclass ( ) . getcomponenttype ( ) ; array = ensurearraysize ( bp , array , componenttype , index ) ; value = converttype ( value , componenttype ) ; array . set ( array , index , value ) ; }	Sets the array element forced.
protected object createbeanproperty ( final beanproperty bp ) { setter setter = bp . getsetter ( bool_ ) ; if ( setter == null ) { return null ; } class type = setter . getsetterrawtype ( ) ; object newinstance ; try { newinstance = classutil . newinstance ( type ) ; } catch ( exception ex ) { if ( issilent ) { return null ; } throw new beanexception ( str_ + bp . name , bp , ex ) ; } newinstance = invokesetter ( setter , bp , newinstance ) ; return newinstance ; }	Creates new instance for current property name through its setter.It uses default constructor!.
protected class extracttype ( final beanproperty bp ) { getter getter = bp . getgetter ( isdeclared ) ; if ( getter != null ) { if ( bp . index != null ) { class type = getter . getgetterrawcomponenttype ( ) ; return type == null ? object . class : type ; } return getter . getgetterrawtype ( ) ; } return null ;	Extracts type of current property.
public static void stop ( final httpservletrequest servletrequest , final httpservletresponse servletresponse ) { final httpsession httpsession = servletrequest . getsession ( bool_ ) ; if ( httpsession != null ) { httpsession . removeattribute ( auth_session_name ) ; } final cookie cookie = servletutil . getcookie ( servletrequest , auth_cookie_name ) ; if ( cookie == null ) { return ; } cookie . setmaxage ( num_ ) ; cookie . setpath ( str_ ) ; servletresponse . addcookie ( cookie ) ; }	Stops the user session by removing it from the http session and invalidating the cookie.
public void start ( final httpservletrequest httpservletrequest , final httpservletresponse httpservletresponse ) { final httpsession httpsession = httpservletrequest . getsession ( bool_ ) ; httpsession . setattribute ( auth_session_name , this ) ; final cookie cookie = new cookie ( auth_cookie_name , authtokenvalue ) ;	Starts new user session.
public static date todate ( final localdate localdate ) { return date . from ( localdate . atstartofday ( zoneid . systemdefault ( ) ) . toinstant ( ) ) ; }	Converts local date to Date.
public static calendar tocalendar ( final localdatetime localdatetime ) { return gregoriancalendar . from ( zoneddatetime . of ( localdatetime , zoneid . systemdefault ( ) ) ) ; }	Converts local date time to Calendar.
public class defineproxy ( final class target ) { proxyproxettafactory builder = proxetta . proxy ( ) ; builder . settarget ( target ) ; return builder . define ( ) ; }	Generates new class.
public void add ( final check check ) { string name = check . getname ( ) ; list < check > list = map . computeifabsent ( name , k -> new arraylist < > ( ) ) ; list . add ( check ) ; }	Adds validation checks.
public static validationcontext resolvefor ( final class < ? > target ) { validationcontext vc = new validationcontext ( ) ; vc . addclasschecks ( target ) ; return vc ; }	Resolve validation context for provided target class.
public void addclasschecks ( final class target ) { final list < check > list = cache . get ( target , ( ) -> { final list < check > newlist = new arraylist < > ( ) ; final classdescriptor cd = classintrospector . get ( ) . lookup ( target ) ; final propertydescriptor [ ] allproperties = cd . getallpropertydescriptors ( ) ; for ( propertydescriptor propertydescriptor : allproperties ) { collectpropertyannotationchecks ( newlist , propertydescriptor ) ; } return newlist ; } ) ; addall ( list ) ; }	Parses class annotations and adds all checks.
protected void collectpropertyannotationchecks ( final list < check > annchecks , final propertydescriptor propertydescriptor ) { fielddescriptor fd = propertydescriptor . getfielddescriptor ( ) ; if ( fd != null ) { annotation [ ] annotations = fd . getfield ( ) . getannotations ( ) ; collectannotationchecks ( annchecks , propertydescriptor . gettype ( ) , propertydescriptor . getname ( ) , annotations ) ; } methoddescriptor md = propertydescriptor . getreadmethoddescriptor ( ) ; if ( md != null ) { annotation [ ] annotations = md . getmethod ( ) . getannotations ( ) ; collectannotationchecks ( annchecks , propertydescriptor . gettype ( ) , propertydescriptor . getname ( ) , annotations ) ; } md = propertydescriptor . getwritemethoddescriptor ( ) ; if ( md != null ) { annotation [ ] annotations = md . getmethod ( ) . getannotations ( ) ; collectannotationchecks ( annchecks , propertydescriptor . gettype ( ) , propertydescriptor . getname ( ) , annotations ) ; } }	Process all annotations of provided properties.
@ suppresswarnings ( { str_ } ) protected void collectannotationchecks ( final list < check > annchecks , final class targettype , final string targetname , final annotation [ ] annotations ) { for ( annotation annotation : annotations ) { constraint c = annotation . annotationtype ( ) . getannotation ( constraint . class ) ; class < ? extends validationconstraint > constraintclass ; if ( c == null ) {	Collect annotations for some target.
protected void copydefaultcheckproperties ( final check destcheck , final annotation annotation ) { integer severity = ( integer ) classutil . readannotationvalue ( annotation , ann_severity ) ; destcheck . setseverity ( severity . intvalue ( ) ) ; string [ ] profiles = ( string [ ] ) classutil . readannotationvalue ( annotation , ann_profiles ) ; destcheck . setprofiles ( profiles ) ; string message = ( string ) classutil . readannotationvalue ( annotation , ann_message ) ; destcheck . setmessage ( message ) ; }	Copies default properties from annotation to the check.
private static string encodeuricomponent ( final string source , final string encoding , final uripart uripart ) { if ( source == null ) { return null ; } byte [ ] bytes = encodebytes ( stringutil . getbytes ( source , encoding ) , uripart ) ; char [ ] chars = new char [ bytes . length ] ; for ( int i = num_ ; i < bytes . length ; i ++ ) { chars [ i ] = ( char ) bytes [ i ] ; } return new string ( chars ) ; }	Encodes single URI component.
public static string encode ( final string string , final string encoding ) { return encodeuricomponent ( string , encoding , uripart . unreserved ) ; }	Encodes string using default RFCP rules.
public static string encodescheme ( final string scheme , final string encoding ) { return encodeuricomponent ( scheme , encoding , uripart . scheme ) ; }	Encodes the given URI scheme with the given encoding.
public static string encodehost ( final string host , final string encoding ) { return encodeuricomponent ( host , encoding , uripart . host ) ; }	Encodes the given URI host with the given encoding.
public static string encodeport ( final string port , final string encoding ) { return encodeuricomponent ( port , encoding , uripart . port ) ; }	Encodes the given URI port with the given encoding.
public static string encodepath ( final string path , final string encoding ) { return encodeuricomponent ( path , encoding , uripart . path ) ; }	Encodes the given URI path with the given encoding.
public static string encodequery ( final string query , final string encoding ) { return encodeuricomponent ( query , encoding , uripart . query ) ; }	Encodes the given URI query with the given encoding.
public static string encodequeryparam ( final string queryparam , final string encoding ) { return encodeuricomponent ( queryparam , encoding , uripart . query_param ) ; }	Encodes the given URI query parameter with the given encoding.
public static string encodefragment ( final string fragment , final string encoding ) { return encodeuricomponent ( fragment , encoding , uripart . fragment ) ; }	Encodes the given URI fragment with the given encoding.
protected hashmap < string , propertydescriptor > inspectproperties ( ) { boolean scanaccessible = classdescriptor . isscanaccessible ( ) ; class type = classdescriptor . gettype ( ) ; hashmap < string , propertydescriptor > map = new hashmap < > ( ) ; method [ ] methods = scanaccessible ? classutil . getaccessiblemethods ( type ) : classutil . getsupportedmethods ( type ) ; for ( int iteration = num_ ; iteration < num_ ; iteration ++ ) {	Inspects all properties of target type.
public propertydescriptor [ ] getallpropertydescriptors ( ) { if ( allproperties == null ) { propertydescriptor [ ] allproperties = new propertydescriptor [ propertydescriptors . size ( ) ] ; int index = num_ ; for ( propertydescriptor propertydescriptor : propertydescriptors . values ( ) ) { allproperties [ index ] = propertydescriptor ; index ++ ; } arrays . sort ( allproperties , new comparator < propertydescriptor > ( ) { @ override public int compare ( final propertydescriptor pd1 , final propertydescriptor pd2 ) { return pd1 . getname ( ) . compareto ( pd2 . getname ( ) ) ; } } ) ; this . allproperties = allproperties ; } return allproperties ; }	Returns all property descriptors.Properties are sorted by name.
public cookie [ ] cookies ( ) { list < string > newcookies = headers ( str_ ) ; if ( newcookies == null ) { return new cookie [ num_ ] ; } list < cookie > cookielist = new arraylist < > ( newcookies . size ( ) ) ; for ( string cookievalue : newcookies ) { try { cookie cookie = new cookie ( cookievalue ) ; cookielist . add ( cookie ) ; } catch ( exception ex ) {	Returns list of valid cookies sent from server.If no cookie found, returns an empty array.
public httpresponse unzip ( ) { string contentencoding = contentencoding ( ) ; if ( contentencoding != null && contentencoding ( ) . equals ( str_ ) ) { if ( body != null ) { headerremove ( header_content_encoding ) ; try { bytearrayinputstream in = new bytearrayinputstream ( body . getbytes ( stringpool . iso_8859_1 ) ) ; gzipinputstream gzipinputstream = new gzipinputstream ( in ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; streamutil . copy ( gzipinputstream , out ) ; body ( out . tostring ( stringpool . iso_8859_1 ) ) ; } catch ( ioexception ioex ) { throw new httpexception ( ioex ) ; } } } return this ; }	Unzips GZip-ed body content, removes the content-encoding headerand sets the new content-length value.
public httpresponse close ( ) { httpconnection httpconnection = httprequest . httpconnection ; if ( httpconnection != null ) { httpconnection . close ( ) ; httprequest . httpconnection = null ; } return this ; }	Closes requests connection if it was open.Should be called when using keep-alive connections.Otherwise, connection will be already closed.
@ override public boolean accept ( final scope referencescope ) { class < ? extends scope > refscopetype = referencescope . getclass ( ) ; if ( refscopetype == protoscope . class ) { return bool_ ; } if ( refscopetype == singletonscope . class ) { return bool_ ; } if ( refscopetype == threadlocalscope . class ) { return bool_ ; } return bool_ ; }	Defines allowed referenced scopes that can be injected into thethread-local scoped bean.
public byte [ ] encrypt ( final byte [ ] content ) { fastbytebuffer fbb = new fastbytebuffer ( ) ; int length = content . length + num_ ; int blockcount = length / blocksizeinbytes ; int remaining = length ; int offset = num_ ; for ( int i = num_ ; i < blockcount ; i ++ ) { if ( remaining == blocksizeinbytes ) { break ; } byte [ ] encrypted = encryptblock ( content , offset ) ; fbb . append ( encrypted ) ; offset += blocksizeinbytes ; remaining -= blocksizeinbytes ; } if ( remaining != num_ ) {	Encrypts complete content, block by block.
public byte [ ] decrypt ( final byte [ ] encryptedcontent ) { fastbytebuffer fbb = new fastbytebuffer ( ) ; int length = encryptedcontent . length ; int blockcount = length / blocksizeinbytes ; int offset = num_ ; for ( int i = num_ ; i < blockcount - num_ ; i ++ ) { byte [ ] decrypted = decryptblock ( encryptedcontent , offset ) ; fbb . append ( decrypted ) ; offset += blocksizeinbytes ; }	Decrypts the whole content, block by block.
public object map2bean ( final map map , class targettype ) { object target = null ;	Converts map to target type.
private object generifylist ( final list list , final class componenttype ) { for ( int i = num_ ; i < list . size ( ) ; i ++ ) { object element = list . get ( i ) ; if ( element != null ) { if ( element instanceof map ) { object bean = map2bean ( ( map ) element , componenttype ) ; list . set ( i , bean ) ; } else { object value = convert ( element , componenttype ) ; list . set ( i , value ) ; } } } return list ; }	Converts type of all list elements to match the component type.
private void setvalue ( final object target , final propertydescriptor pd , object value ) throws invocationtargetexception , illegalaccessexception { class propertytype ; setter setter = pd . getsetter ( bool_ ) ; if ( setter != null ) { if ( value != null ) { propertytype = setter . getsetterrawtype ( ) ; value = jsonparser . converttype ( value , propertytype ) ; } setter . invokesetter ( target , value ) ; } }	Sets the property value.
protected < k , v > map < k , v > generifymap ( final map < object , object > map , final class < k > keytype , final class < v > valuetype ) { if ( keytype == string . class ) {	Change map elements to match key and value types.
@ override public int compareto ( final object o ) { dbentitycolumndescriptor that = ( dbentitycolumndescriptor ) o ; if ( this . isid != that . isid ) { return this . isid ? - num_ : num_ ;	Compares two column descriptors.
public httpbrowser setdefaultheader ( final string name , final string value ) { defaultheaders . addheader ( name , value ) ; return this ; }	Adds default header to all requests.
public httpresponse sendrequest ( httprequest httprequest ) { elapsedtime = system . currenttimemillis ( ) ;	Sends new request as a browser.
protected httpresponse _sendrequest ( final httprequest httprequest , final httpresponse previouseresponse ) { if ( ! keepalive ) { httprequest . open ( httpconnectionprovider ) ; } else {	Opens connection and sends a response.
protected void adddefaultheaders ( final httprequest httprequest ) { for ( map . entry < string , string > entry : defaultheaders . entries ( ) ) { string name = entry . getkey ( ) ; if ( ! httprequest . headers . contains ( name ) ) { httprequest . headers . add ( name , entry . getvalue ( ) ) ; } } }	Add default headers to the request.
protected void readcookies ( final httpresponse httpresponse ) { cookie [ ] newcookies = httpresponse . cookies ( ) ; for ( cookie cookie : newcookies ) { cookies . add ( cookie . getname ( ) , cookie ) ; } }	Reads cookies from response and adds to cookies list.
protected void addcookies ( final httprequest httprequest ) {	Add cookies to the request.
public string sendmail ( final email email ) { try { final mimemessage msg = createmessage ( email ) ; getservice ( ) . sendmessage ( msg , msg . getallrecipients ( ) ) ; return msg . getmessageid ( ) ; } catch ( final messagingexception msgexc ) { throw new mailexception ( str_ + email , msgexc ) ; } }	Prepares message and sends it.
private void setsubject ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception { if ( emailwithdata . subjectencoding ( ) != null ) { msgtoset . setsubject ( emailwithdata . subject ( ) , emailwithdata . subjectencoding ( ) ) ; } else { msgtoset . setsubject ( emailwithdata . subject ( ) ) ; } }	Sets subject in msgToSet from subject in emailWithData.
private void setsentdate ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception { date date = emailwithdata . sentdate ( ) ; if ( date == null ) { date = new date ( ) ; } msgtoset . setsentdate ( date ) ; }	Sets sent date in msgToSet with sent date from emailWithData.
private void setheaders ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception { final map < string , string > headers = emailwithdata . headers ( ) ; if ( headers != null ) { for ( final map . entry < string , string > entry : headers . entryset ( ) ) { msgtoset . setheader ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } }	Sets headers in msgToSet with headers from emailWithData.
private void setpeople ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception { msgtoset . setfrom ( emailwithdata . from ( ) . tointernetaddress ( ) ) ; msgtoset . setreplyto ( emailaddress . convert ( emailwithdata . replyto ( ) ) ) ; setrecipients ( emailwithdata , msgtoset ) ; }	Sets FROM, REPLY-TO and recipients.
private void setrecipients ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception {	Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.
private void addbodydata ( final email emailwithdata , final mimemessage msgtoset ) throws messagingexception { final list < emailmessage > messages = emailwithdata . messages ( ) ; final int totalmessages = messages . size ( ) ;	Adds message data and attachments.
private void setcontent ( final emailmessage emailwithdata , final part parttoset ) throws messagingexception { parttoset . setcontent ( emailwithdata . getcontent ( ) , emailwithdata . getmimetype ( ) + charset + emailwithdata . getencoding ( ) ) ; }	Sets emailWithData content into msgToSet.
protected mimebodypart createattachmentbodypart ( final emailattachment < ? extends datasource > attachment ) throws messagingexception { final mimebodypart part = new mimebodypart ( ) ; final string attachmentname = attachment . getencodedname ( ) ; if ( attachmentname != null ) { part . setfilename ( attachmentname ) ; } part . setdatahandler ( new datahandler ( attachment . getdatasource ( ) ) ) ; if ( attachment . getcontentid ( ) != null ) { part . setcontentid ( stringpool . left_chev + attachment . getcontentid ( ) + stringpool . right_chev ) ; } if ( attachment . isinline ( ) ) { part . setdisposition ( inline ) ; } return part ; }	Creates attachment body part.
private string getcontenttype ( final string dataheader ) { string token = str_ ; int start = dataheader . indexof ( token ) ; if ( start == - num_ ) { return stringpool . empty ; } start += token . length ( ) ; return dataheader . substring ( start ) . trim ( ) ; }	Strips content type information from requests data header.
protected void saveresultset ( final resultset rs ) { if ( resultsets == null ) { resultsets = new hashset < > ( ) ; } resultsets . add ( rs ) ; }	Stores result set.
public q closeallresultsets ( ) { final sqlexception sex = closequeryresultsets ( ) ; if ( sex != null ) { throw new dbsqlexception ( str_ , sex ) ; } return _this ( ) ; }	Closes all result sets created by this query.
protected sqlexception closequery ( ) { sqlexception sqlexception = closequeryresultsets ( ) ; if ( statement != null ) { try { statement . close ( ) ; } catch ( sqlexception sex ) { if ( sqlexception == null ) { sqlexception = sex ; } else { sqlexception . setnextexception ( sex ) ; } } statement = null ; } query = null ; querystate = closed ; return sqlexception ; }	Closes all assigned result sets and then closes the query.
@ override @ suppresswarnings ( { str_ } ) public void close ( ) { final sqlexception sqlexception = closequery ( ) ; connection = null ; if ( this . session != null ) { this . session . detachquery ( this ) ; } if ( sqlexception != null ) { throw new dbsqlexception ( str_ , sqlexception ) ; } }	Closes the query and all created results sets and detaches itself from the session.
public q setfetchsize ( final int rows ) { checknotclosed ( ) ; this . fetchsize = rows ; if ( statement != null ) { try { statement . setfetchsize ( fetchsize ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( this , str_ + fetchsize , sex ) ; } } return _this ( ) ; }	Gives the JDBC driver a hint as to the number of rows that should be fetched from the database whenmore rows are needed.
public q setmaxrows ( final int maxrows ) { checknotclosed ( ) ; this . maxrows = maxrows ; if ( statement != null ) { try { statement . setmaxrows ( maxrows ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( this , str_ + maxrows , sex ) ; } } return _this ( ) ; }	Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.If the limit is exceeded, the excess rows are silently dropped.
protected int executeupdate ( final boolean closequery ) { start = system . currenttimemillis ( ) ; init ( ) ; final int result ; if ( log . isdebugenabled ( ) ) { log . debug ( str_ + getquerystring ( ) ) ; } try { if ( preparedstatement == null ) { if ( generatedcolumns != null ) { if ( generatedcolumns . length == num_ ) { result = statement . executeupdate ( query . sql , statement . return_generated_keys ) ; } else { result = statement . executeupdate ( query . sql , generatedcolumns ) ; } } else { result = statement . executeupdate ( query . sql ) ; } } else { result = preparedstatement . executeupdate ( ) ; } } catch ( sqlexception sex ) { throw new dbsqlexception ( this , str_ , sex ) ; } if ( closequery ) { close ( ) ; } elapsed = system . currenttimemillis ( ) - start ; if ( log . isdebugenabled ( ) ) { log . debug ( str_ + elapsed + str_ ) ; } return result ; }	Executes UPDATE, INSERT or DELETE queries and optionally closes the query.
protected long executecount ( final boolean close ) { start = system . currenttimemillis ( ) ; init ( ) ; resultset rs = null ; if ( log . isdebugenabled ( ) ) { log . debug ( str_ + getquerystring ( ) ) ; } try { if ( preparedstatement == null ) { rs = statement . executequery ( query . sql ) ; } else { rs = preparedstatement . executequery ( ) ; } final long firstlong = dbutil . getfirstlong ( rs ) ; elapsed = system . currenttimemillis ( ) - start ; if ( log . isdebugenabled ( ) ) { log . debug ( str_ + elapsed + str_ ) ; } return firstlong ; } catch ( sqlexception sex ) { throw new dbsqlexception ( this , str_ , sex ) ; } finally { dbutil . close ( rs ) ; if ( close ) { close ( ) ; } } }	Executes count queries and optionally closes query afterwards.
public resultset getgeneratedcolumns ( ) { checkinitialized ( ) ; if ( generatedcolumns == null ) { throw new dbsqlexception ( this , str_ ) ; } final resultset rs ; try { rs = statement . getgeneratedkeys ( ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( this , str_ , sex ) ; } saveresultset ( rs ) ; totalopenresultsetcount ++ ; return rs ; }	Returns generated columns.
public string getquerystring ( ) { if ( debug ) { if ( ( callablestatement != null ) ) { if ( preparedstatement instanceof loggablecallablestatement ) { return ( ( loggablecallablestatement ) callablestatement ) . getquerystring ( ) ; } } if ( preparedstatement != null ) { if ( preparedstatement instanceof loggablepreparedstatement ) { return ( ( loggablepreparedstatement ) preparedstatement ) . getquerystring ( ) ; } } } if ( query != null ) { return query . sql ; } return sqlstring ; }	Returns query SQL string.
@ suppresswarnings ( str_ ) public static < t > t proxyof ( final t target , final class < ? extends aspect > aspectclass ) { final aspect aspect ; try { aspect = classutil . newinstance ( aspectclass , target ) ; } catch ( exception e ) { throw new illegalargumentexception ( str_ , e ) ; } return ( t ) newproxyinstance ( target . getclass ( ) . getclassloader ( ) , aspect , target . getclass ( ) . getinterfaces ( ) ) ; }	Creates a proxy of given target and the aspect.
public static < t > collection < t > collectionof ( final iterator < ? extends t > iterator ) { final list < t > list = new arraylist < > ( ) ; while ( iterator . hasnext ( ) ) { list . add ( iterator . next ( ) ) ; } return list ; }	Returns a collection containing all elements of the iterator.
public static < t > stream < t > streamof ( final iterator < t > iterator ) { return streamsupport . stream ( ( ( iterable < t > ) ( ) -> iterator ) . spliterator ( ) , bool_ ) ; }	Converts iterator to a stream.
@ override public int compare ( final t o1 , final t o2 ) { for ( comparator < t > comparator : comparators ) { int result = comparator . compare ( o1 , o2 ) ; if ( result != num_ ) { return result ; } } return num_ ; }	Compares two objects starting with first comparator; if they are equalsproceeds to the next comparator and so on.
public petiteconfig setdefaultwiringmode ( final wiringmode defaultwiringmode ) { if ( ( defaultwiringmode == null ) || ( defaultwiringmode == wiringmode . default ) ) { throw new petiteexception ( str_ + defaultwiringmode ) ; } this . defaultwiringmode = defaultwiringmode ; return this ; }	Specifies default wiring mode.
protected void print ( final level level , final string message , final throwable throwable ) { if ( ! isenabled ( level ) ) { return ; } stringbuilder msg = new stringbuilder ( ) . append ( slf . getelapsedtime ( ) ) . append ( str_ ) . append ( str_ ) . append ( level ) . append ( str_ ) . append ( str_ ) . append ( getcallerclass ( ) ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( message ) ; system . out . println ( msg . tostring ( ) ) ; if ( throwable != null ) { throwable . printstacktrace ( system . out ) ; } }	Prints error message if level is enabled.
protected string getcallerclass ( ) { exception exception = new exception ( ) ; stacktraceelement [ ] stacktrace = exception . getstacktrace ( ) ; for ( stacktraceelement stacktraceelement : stacktrace ) { string classname = stacktraceelement . getclassname ( ) ; if ( classname . equals ( simpleloggerprovider . class . getname ( ) ) ) { continue ; } if ( classname . equals ( simplelogger . class . getname ( ) ) ) { continue ; } if ( classname . equals ( logger . class . getname ( ) ) ) { continue ; } return shortenclassname ( classname ) + str_ + stacktraceelement . getmethodname ( ) + str_ + stacktraceelement . getlinenumber ( ) ; } return str_ ; }	Returns called class.
protected string shortenclassname ( final string classname ) { int lastdotindex = classname . lastindexof ( str_ ) ; if ( lastdotindex == - num_ ) { return classname ; } stringbuilder shortclassname = new stringbuilder ( classname . length ( ) ) ; int start = num_ ; while ( bool_ ) { shortclassname . append ( classname . charat ( start ) ) ; int next = classname . indexof ( str_ , start ) ; if ( next == lastdotindex ) { break ; } start = next + num_ ; shortclassname . append ( str_ ) ; } shortclassname . append ( classname . substring ( lastdotindex ) ) ; return shortclassname . tostring ( ) ; }	Returns shorten class name.
public jsonserializer excludetypes ( final class ... types ) { if ( excludedtypes == null ) { excludedtypes = types ; } else { excludedtypes = arraysutil . join ( excludedtypes , types ) ; } return this ; }	Excludes types. Supports interfaces and subclasses as well.
public void serialize ( final object source , final appendable target ) { jsoncontext jsoncontext = createjsoncontext ( target ) ; jsoncontext . serialize ( source ) ; }	Serializes object into provided appendable.
public string serialize ( final object source ) { fastcharbuffer fastcharbuffer = new fastcharbuffer ( ) ; serialize ( source , fastcharbuffer ) ; return fastcharbuffer . tostring ( ) ; }	Serializes object into source.
public static < t extends serializable > t cloneviaserialization ( final t obj ) throws ioexception , classnotfoundexception { fastbytearrayoutputstream bos = new fastbytearrayoutputstream ( ) ; objectoutputstream out = null ; objectinputstream in = null ; object objcopy = null ; try { out = new objectoutputstream ( bos ) ; out . writeobject ( obj ) ; out . flush ( ) ; byte [ ] bytes = bos . tobytearray ( ) ; in = new objectinputstream ( new bytearrayinputstream ( bytes ) ) ; objcopy = in . readobject ( ) ; } finally { streamutil . close ( out ) ; streamutil . close ( in ) ; } return ( t ) objcopy ; }	Create object copy using serialization mechanism.
public static void writeobject ( final file dest , final object object ) throws ioexception { fileoutputstream fos = null ; bufferedoutputstream bos = null ; objectoutputstream oos = null ; try { fos = new fileoutputstream ( dest ) ; bos = new bufferedoutputstream ( fos ) ; oos = new objectoutputstream ( bos ) ; oos . writeobject ( object ) ; } finally { streamutil . close ( oos ) ; streamutil . close ( bos ) ; streamutil . close ( fos ) ; } }	Writes serializable object to a file.
public static object readobject ( final file source ) throws ioexception , classnotfoundexception { object result = null ; fileinputstream fis = null ; bufferedinputstream bis = null ; objectinputstream ois = null ; try { fis = new fileinputstream ( source ) ; bis = new bufferedinputstream ( fis ) ; ois = new objectinputstream ( bis ) ; result = ois . readobject ( ) ; } finally { streamutil . close ( ois ) ; streamutil . close ( bis ) ; streamutil . close ( fis ) ; } return result ; }	Reads serialized object from the file.
public static byte [ ] objecttobytearray ( final object obj ) throws ioexception { fastbytearrayoutputstream bos = new fastbytearrayoutputstream ( ) ; objectoutputstream oos = null ; try { oos = new objectoutputstream ( bos ) ; oos . writeobject ( obj ) ; } finally { streamutil . close ( oos ) ; } return bos . tobytearray ( ) ; }	Serialize an object to byte array.
public static object bytearraytoobject ( final byte [ ] data ) throws ioexception , classnotfoundexception { object retobj = null ; bytearrayinputstream bais = new bytearrayinputstream ( data ) ; objectinputstream ois = null ; try { ois = new objectinputstream ( bais ) ; retobj = ois . readobject ( ) ; } finally { streamutil . close ( ois ) ; } return retobj ; }	De-serialize an object from byte array.
protected string [ ] [ ] resolvemappedtypestablenames ( final class [ ] types ) { if ( cachedmappednames == null ) { string [ ] [ ] names = new string [ types . length ] [ ] ; for ( int i = num_ ; i < types . length ; i ++ ) { class type = types [ i ] ; if ( type != null ) { dbentitydescriptor ded = cacheddbentitydescriptors [ i ] ; if ( ded != null ) { class [ ] mappedtypes = ded . getmappedtypes ( ) ; if ( mappedtypes != null ) { names [ i ] = createtypestablenames ( mappedtypes ) ; } } } } cachedmappednames = names ; } return cachedmappednames ; }	Resolved mapped type names for each type.
protected string [ ] createtypestablenames ( final class [ ] types ) { string [ ] names = new string [ types . length ] ; for ( int i = num_ ; i < types . length ; i ++ ) { if ( types [ i ] == null ) { names [ i ] = null ; continue ; } dbentitydescriptor ded = dbentitymanager . lookuptype ( types [ i ] ) ; if ( ded != null ) { string tablename = ded . gettablename ( ) ; tablename = tablename . touppercase ( ) ; names [ i ] = tablename ; } } return names ; }	Creates table names for given types.
@ suppresswarnings ( { str_ } ) protected object readcolumnvalue ( final int colndx , final class destinationtype , final class < ? extends sqltype > sqltypeclass , final int columndbsqltype ) { if ( colndx != cachedcolumnndx ) { try { sqltype sqltype ; if ( sqltypeclass != null ) { sqltype = sqltypemanager . get ( ) . lookupsqltype ( sqltypeclass ) ; } else { sqltype = sqltypemanager . get ( ) . lookup ( destinationtype ) ; } if ( sqltype != null ) { cachedcolumnvalue = sqltype . readvalue ( resultset , colndx + num_ , destinationtype , columndbsqltype ) ; } else { cachedcolumnvalue = resultset . getobject ( colndx + num_ ) ; cachedcolumnvalue = typeconvertermanager . get ( ) . converttype ( cachedcolumnvalue , destinationtype ) ; } } catch ( sqlexception sex ) { throw new dboomexception ( dboomquery , str_ + ( colndx + num_ ) , sex ) ; } cachedcolumnndx = colndx ; } return cachedcolumnvalue ; }	Reads column value from result set.
protected void cacheresultsetentities ( final object [ ] result ) { if ( entitiescache == null ) { entitiescache = new hashmap < > ( ) ; } for ( int i = num_ ; i < result . length ; i ++ ) { object object = result [ i ] ; if ( object == null ) { continue ; } dbentitydescriptor ded = cacheddbentitydescriptors [ i ] ; if ( ded == null ) {	Caches returned entities. Replaces new instances with existing ones.
public providerdefinition [ ] resolve ( final class type , final string name ) { classdescriptor cd = classintrospector . get ( ) . lookup ( type ) ; methoddescriptor [ ] methods = cd . getallmethoddescriptors ( ) ; list < providerdefinition > list = new arraylist < > ( ) ; for ( methoddescriptor methoddescriptor : methods ) { method method = methoddescriptor . getmethod ( ) ; petiteprovider petiteprovider = method . getannotation ( petiteprovider . class ) ; if ( petiteprovider == null ) { continue ; } string providername = petiteprovider . value ( ) ; if ( stringutil . isblank ( providername ) ) {	Resolves all providers in the class.
public string applytotablename ( final string tablename ) { string entityname = converttablenametoentityname ( tablename ) ; return convertentitynametotablename ( entityname ) ; }	Applies table naming strategy to given table name hint.Returns full table name.
private boolean isconnectionvalid ( final connectiondata connectiondata , final long now ) { if ( ! validateconnection ) { return bool_ ; } if ( now < connectiondata . lastused + validationtimeout ) { return bool_ ; } connection conn = connectiondata . connection ; if ( validationquery == null ) { try { return ! conn . isclosed ( ) ; } catch ( sqlexception sex ) { return bool_ ; } } boolean valid = bool_ ; statement st = null ; try { st = conn . createstatement ( ) ; st . execute ( validationquery ) ; } catch ( sqlexception sex ) { valid = bool_ ; } finally { if ( st != null ) { try { st . close ( ) ; } catch ( sqlexception ignore ) { } } } return valid ; }	Checks if existing connection is valid and available.
@ override protected void renderview ( final actionrequest actionrequest , final string target ) throws exception { httpservletrequest request = actionrequest . gethttpservletrequest ( ) ; httpservletresponse response = actionrequest . gethttpservletresponse ( ) ; requestdispatcher dispatcher = request . getrequestdispatcher ( target ) ; if ( dispatcher == null ) { response . senderror ( sc_not_found , str_ + target ) ;	Renders the view by dispatching to the target JSP.
@ override protected string locatetarget ( final actionrequest actionrequest , string path ) { string target ; if ( path . endswith ( stringpool . slash ) ) { path = path + defaultviewpagename ; } for ( final string ext : defaultviewextensions ) { target = path + ext ; if ( targetexists ( actionrequest , target ) ) { return target ; } } return null ; }	Locates target using path with various extensions appended.
@ override public printwriter getwriter ( ) throws ioexception { preresponsecommit ( ) ; if ( buffer == null ) { return getresponse ( ) . getwriter ( ) ; } return buffer . getwriter ( ) ; }	Returns buffered writer if buffering is enabled,otherwise returns the original writer.
@ override public servletoutputstream getoutputstream ( ) throws ioexception { preresponsecommit ( ) ; if ( buffer == null ) { return getresponse ( ) . getoutputstream ( ) ; } return buffer . getoutputstream ( ) ; }	Returns buffered output stream if buffering is enabled,otherwise returns the original stream.
public void writecontenttoresponse ( final char [ ] content ) throws ioexception { if ( buffer == null ) { return ; } if ( buffer . isusingstream ( ) ) { servletoutputstream outputstream = getresponse ( ) . getoutputstream ( ) ; string encoding = getcontenttypeencoding ( ) ; if ( encoding == null ) { outputstream . write ( charutil . tobytearray ( content ) ) ; } else { outputstream . write ( charutil . tobytearray ( content , encoding ) ) ; } outputstream . flush ( ) ; } else { writer out = getresponse ( ) . getwriter ( ) ; out . write ( content ) ; out . flush ( ) ; } }	Writes content to original output stream, using either output stream or writer, dependingon how the content was buffered.
@ override public void setcontenttype ( final string type ) { super . setcontenttype ( type ) ; contenttyperesolver = new contenttypeheaderresolver ( type ) ; if ( buffercontenttype ( type , contenttyperesolver . getmimetype ( ) , contenttyperesolver . getencoding ( ) ) ) { enablebuffering ( ) ; } else { disablebuffering ( ) ; } }	Sets the content type and enables or disables buffering.
public void print ( final string string ) throws ioexception { if ( isbufferstreambased ( ) ) { string encoding = getcontenttypeencoding ( ) ; byte [ ] bytes ; if ( encoding == null ) { bytes = string . getbytes ( ) ; } else { bytes = string . getbytes ( encoding ) ; } buffer . getoutputstream ( ) . write ( bytes ) ; return ; }	Appends string to the buffer.
protected jsonresult login ( ) { t authtoken ; authtoken = loginviabasicauth ( servletrequest ) ; if ( authtoken == null ) { authtoken = loginviarequestparams ( servletrequest ) ; } if ( authtoken == null ) { log . warn ( str_ ) ; return jsonresult . of ( httpstatus . error401 ( ) . unauthorized ( str_ ) ) ; } log . info ( str_ ) ; final usersession < t > usersession = new usersession < > ( authtoken , userauth . tokenvalue ( authtoken ) ) ; usersession . start ( servletrequest , servletresponse ) ;	Authenticate user and start user session.
protected jsonresult tokenasjson ( final t authtoken ) { final jsonobject jsonobject = new jsonobject ( ) ; jsonobject . put ( str_ , userauth . tokenvalue ( authtoken ) ) ; return jsonresult . of ( jsonobject ) ; }	Prepares the JSON payload that carries on the token value.
protected t loginviabasicauth ( final httpservletrequest servletrequest ) { final string username = servletutil . resolveauthusername ( servletrequest ) ; if ( username == null ) { return null ; } final string password = servletutil . resolveauthpassword ( servletrequest ) ; return userauth . login ( username , password ) ; }	Tries to login user with basic authentication.
public static file tocontainerfile ( final url url ) { string protocol = url . getprotocol ( ) ; if ( protocol . equals ( file_protocol ) ) { return tofile ( url ) ; } string path = url . getpath ( ) ; return new file ( uri . create ( path . substring ( zero , path . lastindexof ( str_ ) ) ) ) ; }	Returns a file of either a folder or a containing archive.
public static file mkdirs ( final file dirs ) throws ioexception { if ( dirs . exists ( ) ) { checkisdirectory ( dirs ) ; return dirs ; } return checkcreatedirectory ( dirs ) ; }	Creates all directories at once.
public static file mkdir ( final file dir ) throws ioexception { if ( dir . exists ( ) ) { checkisdirectory ( dir ) ; return dir ; } return checkcreatedirectory ( dir ) ; }	Creates single directory.
private static void _copyfile ( final file srcfile , final file destfile ) throws ioexception { if ( destfile . exists ( ) ) { if ( destfile . isdirectory ( ) ) { throw new ioexception ( str_ + destfile + str_ ) ; } }	Internal file copy when most of the pre-checking has passed.
public static void copydir ( final file srcdir , final file destdir ) throws ioexception { checkdircopy ( srcdir , destdir ) ; _copydirectory ( srcdir , destdir ) ; }	Copies directory with specified copy params.
public static file movefiletodir ( final file srcfile , final file destdir ) throws ioexception { checkexistsanddirectory ( destdir ) ; return movefile ( srcfile , file ( destdir , srcfile . getname ( ) ) ) ; }	Moves a file to a directory.
private static void _movedirectory ( final file srcdest , file destdir ) throws ioexception { if ( destdir . exists ( ) ) { checkisdirectory ( destdir ) ; destdir = file ( destdir , destdir . getname ( ) ) ; destdir . mkdir ( ) ; } final boolean rename = srcdest . renameto ( destdir ) ; if ( ! rename ) { _copydirectory ( srcdest , destdir ) ; deletedir ( srcdest ) ; } }	Moves a directory.
public static void cleandir ( final file destdir ) throws ioexception { checkexists ( destdir ) ; checkisdirectory ( destdir ) ; file [ ] files = destdir . listfiles ( ) ; if ( files == null ) { throw new ioexception ( str_ + destdir ) ; } ioexception exception = null ; for ( file file : files ) { try { if ( file . isdirectory ( ) ) { deletedir ( file ) ; } else { file . delete ( ) ; } } catch ( ioexception ioex ) { exception = ioex ; continue ; } } if ( exception != null ) { throw exception ; } }	Cleans a directory without deleting it.
public static char [ ] readutfchars ( final file file ) throws ioexception { checkexists ( file ) ; checkisfile ( file ) ; unicodeinputstream in = unicodeinputstreamof ( file ) ; try { return streamutil . readchars ( in , detectencoding ( in ) ) ; } finally { streamutil . close ( in ) ; } }	Reads UTF file content as char array.
public static char [ ] readchars ( final file file , final string encoding ) throws ioexception { checkexists ( file ) ; checkisfile ( file ) ; inputstream in = streamof ( file , encoding ) ; try { return streamutil . readchars ( in , encoding ) ; } finally { streamutil . close ( in ) ; } }	Reads file content as char array.
public static void writechars ( final file dest , final char [ ] data , final string encoding ) throws ioexception { outchars ( dest , data , encoding , bool_ ) ; }	Write characters. append = false.
public static void writestring ( final file dest , final string data , final string encoding ) throws ioexception { outstring ( dest , data , encoding , bool_ ) ; }	Writes String. append = false.
public static void appendstring ( final file dest , final string data , final string encoding ) throws ioexception { outstring ( dest , data , encoding , bool_ ) ; }	Appends String. append = true.
public static byte [ ] readbytes ( final file file , final int count ) throws ioexception { checkexists ( file ) ; checkisfile ( file ) ; long numtoread = file . length ( ) ; if ( numtoread >= integer . max_value ) { throw new ioexception ( str_ ) ; } if ( count > negative_one && count < numtoread ) { numtoread = count ; } byte [ ] bytes = new byte [ ( int ) numtoread ] ; randomaccessfile randomaccessfile = new randomaccessfile ( file , str_ ) ; randomaccessfile . readfully ( bytes ) ; randomaccessfile . close ( ) ; return bytes ; }	Read file and returns byte array with contents.
public static void writebytes ( final file dest , final byte [ ] data , final int off , final int len ) throws ioexception { outbytes ( dest , data , off , len , bool_ ) ; }	Write bytes. append = false.
public static void appendbytes ( final file dest , final byte [ ] data , final int off , final int len ) throws ioexception { outbytes ( dest , data , off , len , bool_ ) ; }	Appends bytes. append = true.
public static void copy ( final file src , final file dest ) throws ioexception { if ( src . isdirectory ( ) ) { copydir ( src , dest ) ; return ; } if ( dest . isdirectory ( ) ) { copyfiletodir ( src , dest ) ; return ; } copyfile ( src , dest ) ; }	Smart copy. If source is a directory, copy it to destination.Otherwise, if destination is directory, copy source file to it.Otherwise, try to copy source file to destination file.
public static void delete ( final file dest ) throws ioexception { if ( dest . isdirectory ( ) ) { deletedir ( dest ) ; return ; } deletefile ( dest ) ; }	Smart delete of destination file or directory.
public static file createtempdirectory ( final string prefix , final string suffix , final file tempdir ) throws ioexception { file file = createtempfile ( prefix , suffix , tempdir ) ; file . delete ( ) ; file . mkdir ( ) ; return file ; }	Creates temporary directory.
public static boolean isbinary ( final file file ) throws ioexception { byte [ ] bytes = readbytes ( file , num_ ) ; for ( byte b : bytes ) { if ( b < num_ && b != num_ && b != num_ && b != num_ ) { return bool_ ; } } return bool_ ; }	Checks the start of the file for ASCII control characters.
private static void checkdircopy ( final file srcdir , final file destdir ) throws ioexception { checkexists ( srcdir ) ; checkisdirectory ( srcdir ) ; if ( equals ( srcdir , destdir ) ) { throw new ioexception ( str_ + srcdir + str_ + destdir + str_ ) ; } }	Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.
private static void checkfilecopy ( final file srcfile , final file destfile ) throws ioexception { checkexists ( srcfile ) ; checkisfile ( srcfile ) ; if ( equals ( srcfile , destfile ) ) { throw new ioexception ( str_ + srcfile + str_ + destfile + str_ ) ; } file destparent = destfile . getparentfile ( ) ; if ( destparent != null && ! destparent . exists ( ) ) { checkcreatedirectory ( destparent ) ; } }	Checks that file copy can occur.
public void printusage ( final string commandname ) { final stringbuilder usage = new stringbuilder ( commandname ) ; for ( final option option : options ) { if ( option . shortname != null ) { usage . append ( str_ ) . append ( option . shortname ) . append ( str_ ) ; } else if ( option . longname != null ) { usage . append ( str_ ) . append ( option . longname ) . append ( str_ ) ; } } for ( final param param : params ) { usage . append ( str_ ) . append ( param . label ) ; } system . out . println ( usage ) ; }	Prints the usage line.
public method resolveactionmethod ( final class < ? > actionclass , final string methodname ) { methoddescriptor methoddescriptor = classintrospector . get ( ) . lookup ( actionclass ) . getmethoddescriptor ( methodname , bool_ ) ; if ( methoddescriptor == null ) { throw new madvocexception ( str_ + actionclass . getsimplename ( ) + str_ + methodname ) ; } return methoddescriptor . getmethod ( ) ; }	Resolves action method for given action class ane method name.
public actionruntime registeraction ( final class actionclass , final string actionmethodname , final actiondefinition actiondefinition ) { method actionmethod = resolveactionmethod ( actionclass , actionmethodname ) ; return registeraction ( actionclass , actionmethod , actiondefinition ) ; }	Registers action with provided action class and method name.
public void registerpathalias ( final string alias , final string path ) { final string existing = pathaliases . put ( alias , path ) ; if ( existing != null ) { throw new madvocexception ( str_ + alias + str_ + path + str_ + existing ) ; } }	Registers new path alias.
public boolean next ( ) { if ( ! looping ) { return bool_ ; } if ( last ) { return bool_ ; } if ( count == num_ ) { value = start ; first = bool_ ; } else { value += step ; first = bool_ ; } count ++ ; last = islastiteration ( value + step ) ; return bool_ ; }	Iterates to next value at the beginning of the loop.
public static chararraysequence from ( final char [ ] value , final int offset , final int len ) { final char [ ] buffer = new char [ value . length ] ; system . arraycopy ( value , offset , buffer , num_ , len ) ; return new chararraysequence ( buffer ) ; }	Static constructor that creates a char sequence by making a copy of provided char array.
public object execute ( ) throws exception { string methodname = proxytarget . targetmethodname ( ) ; class [ ] argtypes = proxytarget . createargumentsclassarray ( ) ; object [ ] args = proxytarget . createargumentsarray ( ) ;	Looks up for method in target object and invokes it using reflection.
public final boolean matchuppercase ( final char [ ] uppercasetarget ) { if ( ndx + uppercasetarget . length > total ) { return bool_ ; } int j = ndx ; for ( int i = num_ ; i < uppercasetarget . length ; i ++ , j ++ ) { final char c = charutil . toupperascii ( input [ j ] ) ; if ( c != uppercasetarget [ i ] ) { return bool_ ; } } return bool_ ; }	Matches char buffer given in uppercase with content at current location, that willbe converted to upper case to make case-insensitive matching.
protected final charsequence charsequence ( final int from , final int to ) { if ( from == to ) { return chararraysequence . empty ; } return chararraysequence . of ( input , from , to - from ) ; }	Creates char sub-sequence from the input.
public static url [ ] of ( classloader classloader , class clazz ) { if ( clazz == null ) { clazz = classpathurls . class ; } if ( classloader == null ) { classloader = clazz . getclassloader ( ) ; } final set < url > urls = new linkedhashset < > ( ) ; while ( classloader != null ) { if ( classloader instanceof urlclassloader ) { urlclassloader urlclassloader = ( urlclassloader ) classloader ; url [ ] allurls = urlclassloader . geturls ( ) ; collections . addall ( urls , allurls ) ; break ; } url classurl = classmoduleurl ( classloader , clazz ) ; if ( classurl != null ) { urls . add ( classurl ) ; } classurl = classmoduleurl ( classloader , classpathurls . class ) ; if ( classurl != null ) { urls . add ( classurl ) ; } moduledescriptor moduledescriptor = clazz . getmodule ( ) . getdescriptor ( ) ; if ( moduledescriptor != null ) { moduledescriptor . requires ( ) . foreach ( req -> { modulelayer . boot ( ) . findmodule ( req . name ( ) ) . ifpresent ( mod -> { classloader moduleclassloader = mod . getclassloader ( ) ; if ( moduleclassloader != null ) { url url = moduleclassloader . getresource ( manifest ) ; if ( url != null ) { url = fixmanifesturl ( url ) ; urls . add ( url ) ; } } } ) ; } ) ; } classloader = classloader . getparent ( ) ; } return urls . toarray ( new url [ num_ ] ) ; }	Returns urls for the classloader.
public email bcc ( final emailaddress ... bccs ) { this . bcc = arraysutil . join ( this . bcc , valueoremptyarray ( bccs ) ) ; return _this ( ) ; }	Appends one or more BCC addresses.
public void register ( final class type , final typejsonserializer typejsonserializer ) { map . put ( type , typejsonserializer ) ; cache . clear ( ) ; }	Registers new serializer.
protected typejsonserializer lookupserializer ( final class type ) { typejsonserializer tjs = map . get ( type ) ; if ( tjs == null ) { if ( defaultserializermap != null ) { tjs = defaultserializermap . map . get ( type ) ; } } return tjs ; }	Get type serializer from map.
public void parserequeststream ( final inputstream inputstream , final string encoding ) throws ioexception { setparsed ( ) ; multipartrequestinputstream input = new multipartrequestinputstream ( inputstream ) ; input . readboundary ( ) ; while ( bool_ ) { fileuploadheader header = input . readdataheader ( encoding ) ; if ( header == null ) { break ; } if ( header . isfile ) { string filename = header . filename ; if ( filename . length ( ) > num_ ) { if ( header . contenttype . indexof ( str_ ) > num_ ) { input . skipbytes ( num_ ) ; } } fileupload newfile = fileuploadfactory . create ( input ) ; newfile . processstream ( ) ; if ( filename . length ( ) == num_ ) {	Extracts uploaded files and parameters from the request data.
public string getparameter ( final string paramname ) { if ( requestparameters == null ) { return null ; } string [ ] values = requestparameters . get ( paramname ) ; if ( ( values != null ) && ( values . length > num_ ) ) { return values [ num_ ] ; } return null ; }	Returns single value of a parameter.
public string [ ] getparametervalues ( final string paramname ) { if ( requestparameters == null ) { return null ; } return requestparameters . get ( paramname ) ; }	Returns all values all of the values the given request parameter has.
public fileupload getfile ( final string paramname ) { if ( requestfiles == null ) { return null ; } fileupload [ ] values = requestfiles . get ( paramname ) ; if ( ( values != null ) && ( values . length > num_ ) ) { return values [ num_ ] ; } return null ; }	Returns uploaded file.
public fileupload [ ] getfiles ( final string paramname ) { if ( requestfiles == null ) { return null ; } return requestfiles . get ( paramname ) ; }	Returns all uploaded files the given request parameter has.
@ override public void init ( final filterconfig filterconfig ) { this . filterconfig = filterconfig ; this . encoding = filterconfig . getinitparameter ( str_ ) ; if ( this . encoding == null ) { this . encoding = joddcore . encoding ; } this . ignore = converter . get ( ) . tobooleanvalue ( filterconfig . getinitparameter ( str_ ) , bool_ ) ; }	Place this filter into service.
public void parse ( final dbsqlbuilder sqlbuilder , final string template ) { int length = template . length ( ) ; int last = num_ ; while ( bool_ ) { int mark = template . indexof ( str_ , last ) ; if ( mark == - num_ ) { if ( last < length ) { sqlbuilder . appendraw ( template . substring ( last ) ) ; } break ; } int escapescount = countescapes ( template , mark ) ;	Parses template and returns generated sql builder.
protected int findmacroend ( final string template , final int fromindex ) { int endindex = template . indexof ( str_ , fromindex ) ; if ( endindex == - num_ ) { throw new dbsqlbuilderexception ( str_ + template . substring ( fromindex ) ) ; } return endindex ; }	Finds macros end.
protected int countescapes ( final string template , int macroindex ) { macroindex -- ; int escapecount = num_ ; while ( macroindex >= num_ ) { if ( template . charat ( macroindex ) != escape_character ) { break ; } escapecount ++ ; macroindex -- ; } return escapecount ; }	Count escapes to the left.
public static string buildquery ( final httpmultimap < ? > querymap , final string encoding ) { if ( querymap . isempty ( ) ) { return stringpool . empty ; } int querymapsize = querymap . size ( ) ; stringband query = new stringband ( querymapsize * num_ ) ; int count = num_ ; for ( map . entry < string , ? > entry : querymap ) { string key = entry . getkey ( ) ; key = urlcoder . encodequeryparam ( key , encoding ) ; object value = entry . getvalue ( ) ; if ( value == null ) { if ( count != num_ ) { query . append ( str_ ) ; } query . append ( key ) ; count ++ ; } else { if ( count != num_ ) { query . append ( str_ ) ; } query . append ( key ) ; count ++ ; query . append ( str_ ) ; string valuestring = urlcoder . encodequeryparam ( value . tostring ( ) , encoding ) ; query . append ( valuestring ) ; } } return query . tostring ( ) ; }	Builds a query string from given query map.
public static httpmultimap < string > parsequery ( final string query , final boolean decode ) { final httpmultimap < string > querymap = httpmultimap . newcaseinsensitivemap ( ) ; if ( stringutil . isblank ( query ) ) { return querymap ; } int lastndx = num_ ; while ( lastndx < query . length ( ) ) { int ndx = query . indexof ( str_ , lastndx ) ; if ( ndx == - num_ ) { ndx = query . length ( ) ; } final string paramandvalue = query . substring ( lastndx , ndx ) ; ndx = paramandvalue . indexof ( str_ ) ; if ( ndx == - num_ ) { querymap . add ( paramandvalue , null ) ; } else { string name = paramandvalue . substring ( num_ , ndx ) ; if ( decode ) { name = urldecoder . decodequery ( name ) ; } string value = paramandvalue . substring ( ndx + num_ ) ; if ( decode ) { value = urldecoder . decodequery ( value ) ; } querymap . add ( name , value ) ; } lastndx += paramandvalue . length ( ) + num_ ; } return querymap ; }	Parses query from give query string.
public static string prepareheaderparametername ( final string headername ) {	Makes nice header names.
public static string extractmediatype ( final string contenttype ) { int index = contenttype . indexof ( str_ ) ; if ( index == - num_ ) { return contenttype ; } return contenttype . substring ( num_ , index ) ; }	Extracts media-type from value of "Content Type" header.
public string tohtml ( final node node , final appendable appendable ) { nodevisitor renderer = createrenderer ( appendable ) ; node . visit ( renderer ) ; return appendable . tostring ( ) ; }	Renders node to appendable.
public string toinnerhtml ( final node node , final appendable appendable ) { nodevisitor renderer = createrenderer ( appendable ) ; node . visitchildren ( renderer ) ; return appendable . tostring ( ) ; }	Renders node children to appendable.
public void configurewith ( final servletcontext servletcontext ) { webappclassname = servletcontext . getinitparameter ( param_madvoc_webapp ) ; paramsfiles = converter . get ( ) . tostringarray ( servletcontext . getinitparameter ( param_madvoc_params ) ) ; madvocconfiguratorclassname = servletcontext . getinitparameter ( param_madvoc_configurator ) ; }	Configures Madvoc by reading context init parameters.
protected void reset ( ) { this . ndx = num_ ; this . textlen = num_ ; this . path = new path ( ) ; this . notfirstobject = bool_ ; if ( usealtpaths ) { path . altpath = new path ( ) ; } if ( classmetadataname != null ) { maptobean = createmaptobean ( classmetadataname ) ; } }	Resets JSON parser, so it can be reused.
public jsonparser lazy ( final boolean lazy ) { this . lazy = lazy ; this . mapsupplier = lazy ? lazymap_supplier : hashmap_supplier ; this . listsupplier = lazy ? lazylist_supplier : arraylist_supplier ; return this ; }	Defines how JSON parser works.
protected class replacewithmappedtypeforpath ( final class target ) { if ( mappings == null ) { return target ; } class newtype ;	Replaces type with mapped type for current path.
public < t > list < t > parseaslist ( final string string , final class < t > componenttype ) { return new jsonparser ( ) . map ( jsonparser . values , componenttype ) . parse ( string ) ; }	Parses input JSON to a list with specified component type.
public < k , v > map < k , v > parseasmap ( final string string , final class < k > keytype , final class < v > valuetype ) { return new jsonparser ( ) . map ( jsonparser . keys , keytype ) . map ( jsonparser . values , valuetype ) . parse ( string ) ; }	Parses input JSON to a list with specified key and value types.
private object resolvelazyvalue ( object value ) { if ( value instanceof supplier ) { value = ( ( supplier ) value ) . get ( ) ; } return value ; }	Resolves lazy value during the parsing runtime.
private void skipobject ( ) { int bracketcount = num_ ; boolean insidestring = bool_ ; while ( ndx < total ) { final char c = input [ ndx ] ; if ( insidestring ) { if ( c == str_ && notprecededbyevennumberofbackslashes ( ) ) { insidestring = bool_ ; } } else if ( c == str_ ) { insidestring = bool_ ; } else if ( c == str_ ) { bracketcount ++ ; } else if ( c == str_ ) { bracketcount -- ; if ( bracketcount == num_ ) { ndx ++ ; return ; } } ndx ++ ; } }	Skips over complete object.
protected string parsestring ( ) { char quote = str_ ; if ( loosemode ) { quote = consumeoneof ( str_ , str_ ) ; if ( quote == num_ ) { return parseunquotedstringcontent ( ) ; } } else { consume ( quote ) ; } return parsestringcontent ( quote ) ; }	Parses a string.
protected string parsestringcontent ( final char quote ) { final int startndx = ndx ;	Parses string content, once when starting quote has been consumed.
protected char parseunicode ( ) { int i0 = charutil . hex2int ( input [ ndx ++ ] ) ; int i1 = charutil . hex2int ( input [ ndx ++ ] ) ; int i2 = charutil . hex2int ( input [ ndx ++ ] ) ; int i3 = charutil . hex2int ( input [ ndx ] ) ; return ( char ) ( ( i0 << num_ ) + ( i1 << num_ ) + ( i2 << num_ ) + i3 ) ; }	Parses 4 characters and returns unicode character.
protected string parseunquotedstringcontent ( ) { final int startndx = ndx ; while ( bool_ ) { final char c = input [ ndx ] ; if ( c <= str_ || charutil . equalsone ( c , unquoted_delimeters ) ) { final int currentndx = ndx ;	Parses un-quoted string content.
protected number parsenumber ( ) { final int startindex = ndx ; char c = input [ ndx ] ; boolean isdouble = bool_ ; boolean isexp = bool_ ; if ( c == str_ ) { ndx ++ ; } while ( bool_ ) { if ( iseof ( ) ) { break ; } c = input [ ndx ] ; if ( c >= str_ && c <= str_ ) { ndx ++ ; continue ; } if ( c <= num_ ) {	Parses JSON numbers.
protected object parsearraycontent ( class targettype , class componenttype ) {	Parses arrays, once when open bracket has been consumed.
protected void createemptyctor ( ) { final methodvisitor mv = wd . dest . visitmethod ( asmutil . acc_public , init , str_ , null , null ) ; mv . visitcode ( ) ; mv . visitvarinsn ( opcodes . aload , num_ ) ; mv . visitmethodinsn ( opcodes . invokespecial , asmutil . signature_java_lang_object , init , str_ , bool_ ) ; mv . visitinsn ( opcodes . return ) ; mv . visitmaxs ( num_ , num_ ) ; mv . visitend ( ) ; }	Created empty default constructor.
protected void createsimplemethodwrapper ( final methodsignaturevisitor msign ) { int access = msign . getaccessflags ( ) ; access &= ~ acc_abstract ; access &= ~ acc_native ; methodvisitor mv = wd . dest . visitmethod ( access , msign . getmethodname ( ) , msign . getdescription ( ) , msign . getasmmethodsignature ( ) , msign . getexceptions ( ) ) ; mv . visitcode ( ) ; mv . visitvarinsn ( aload , num_ ) ; mv . visitfieldinsn ( getfield , wd . thisreference , wd . wrapperref , wd . wrappertype ) ; loadvirtualmethodarguments ( mv , msign ) ; if ( wd . wrapinterface ) { mv . visitmethodinsn ( invokeinterface , wd . wrappertype . substring ( num_ , wd . wrappertype . length ( ) - num_ ) , msign . getmethodname ( ) , msign . getdescription ( ) , bool_ ) ; } else { mv . visitmethodinsn ( invokevirtual , wd . wrappertype . substring ( num_ , wd . wrappertype . length ( ) - num_ ) , msign . getmethodname ( ) , msign . getdescription ( ) , bool_ ) ; } proxettaasmutil . preparereturnvalue ( mv , msign , num_ ) ; visitreturn ( mv , msign , bool_ ) ; mv . visitmaxs ( num_ , num_ ) ; mv . visitend ( ) ; }	Creates simple method wrapper without proxy.
private string resolverawtypename ( string typename ) { if ( typename == null ) { return null ; } boolean isarray = typename . startswith ( stringpool . left_sq_bracket ) ; if ( isarray ) { typename = typename . substring ( num_ ) ; } string rawtypename ; if ( generics . containskey ( typename ) ) { rawtypename = generics . get ( typename ) ; } else { rawtypename = declaredtypegeneric . getordefault ( typename , typename ) ; } if ( isarray ) { rawtypename = str_ + rawtypename ; } return rawtypename ; }	Resolves raw type name using the generics information from the classor method information.
public beanreferences resolvereferencefromvalue ( final propertydescriptor propertydescriptor , final string refname ) { beanreferences references ; if ( refname == null || refname . isempty ( ) ) { references = builddefaultreference ( propertydescriptor ) ; } else { references = beanreferences . of ( refname ) ; } references = references . removeduplicatenames ( ) ; return references ; }	Resolves reference from given values.
public beanreferences [ ] resolvereferencefromvalues ( final executable methodorctor , final string ... parameterreferences ) { beanreferences [ ] references = convertreftoreferences ( parameterreferences ) ; if ( references == null || references . length == num_ ) { references = builddefaultreferences ( methodorctor ) ; } if ( methodorctor . getparametertypes ( ) . length != references . length ) { throw new petiteexception ( str_ + methodorctor . getdeclaringclass ( ) . getname ( ) + str_ + methodorctor . getname ( ) ) ; } removeallduplicatenames ( references ) ; return references ; }	Takes given parameters references and returns reference set for given method or constructor.
public beanreferences [ ] readallreferencesfromannotation ( final executable methodorctor ) { petiteinject petiteinject = methodorctor . getannotation ( petiteinject . class ) ; final parameter [ ] parameters = methodorctor . getparameters ( ) ; beanreferences [ ] references ; final boolean hasannotationonmethodorctor ; if ( petiteinject != null ) { references = convertannvaluetoreferences ( petiteinject . value ( ) ) ; hasannotationonmethodorctor = bool_ ; } else { references = new beanreferences [ parameters . length ] ; hasannotationonmethodorctor = bool_ ; } int parameterswithannotationcount = num_ ; for ( int i = num_ ; i < parameters . length ; i ++ ) { parameter parameter = parameters [ i ] ; petiteinject = parameter . getannotation ( petiteinject . class ) ; if ( petiteinject == null ) {	Extracts references from method or constructor annotation.
private beanreferences [ ] builddefaultreferences ( final executable methodorctor ) { final boolean useparamo = petiteconfig . getuseparamo ( ) ; final petitereferencetype [ ] lookupreferences = petiteconfig . getlookupreferences ( ) ; methodparameter [ ] methodparameters = null ; if ( useparamo ) { methodparameters = paramo . resolveparameters ( methodorctor ) ; } final class [ ] paramtypes = methodorctor . getparametertypes ( ) ; final beanreferences [ ] references = new beanreferences [ paramtypes . length ] ; for ( int j = num_ ; j < paramtypes . length ; j ++ ) { string [ ] ref = new string [ lookupreferences . length ] ; references [ j ] = beanreferences . of ( ref ) ; for ( int i = num_ ; i < ref . length ; i ++ ) { switch ( lookupreferences [ i ] ) { case name : ref [ i ] = methodparameters != null ? methodparameters [ j ] . getname ( ) : null ; break ; case type_short_name : ref [ i ] = stringutil . uncapitalize ( paramtypes [ j ] . getsimplename ( ) ) ; break ; case type_full_name : ref [ i ] = paramtypes [ j ] . getname ( ) ; break ; } } } return references ; }	Builds default method references.
public beanreferences builddefaultreference ( final propertydescriptor propertydescriptor ) { final petitereferencetype [ ] lookupreferences = petiteconfig . getlookupreferences ( ) ; final string [ ] references = new string [ lookupreferences . length ] ; for ( int i = num_ ; i < references . length ; i ++ ) { switch ( lookupreferences [ i ] ) { case name : references [ i ] = propertydescriptor . getname ( ) ; break ; case type_short_name : references [ i ] = stringutil . uncapitalize ( propertydescriptor . gettype ( ) . getsimplename ( ) ) ; break ; case type_full_name : references [ i ] = propertydescriptor . gettype ( ) . getname ( ) ; break ; } } return beanreferences . of ( references ) ; }	Builds default field references.
private void removeallduplicatenames ( final beanreferences [ ] allbeanreferences ) { for ( int i = num_ ; i < allbeanreferences . length ; i ++ ) { beanreferences references = allbeanreferences [ i ] ; allbeanreferences [ i ] = references . removeduplicatenames ( ) ; } }	Removes duplicate names from bean references.
private beanreferences [ ] convertreftoreferences ( final string [ ] references ) { if ( references == null ) { return null ; } beanreferences [ ] ref = new beanreferences [ references . length ] ; for ( int i = num_ ; i < references . length ; i ++ ) { ref [ i ] = beanreferences . of ( references [ i ] ) ; } return ref ; }	Converts single string array to an array of bean references.
private beanreferences [ ] convertannvaluetoreferences ( string value ) { if ( value == null ) { return null ; } value = value . trim ( ) ; if ( value . length ( ) == num_ ) { return null ; } string [ ] refnames = converter . get ( ) . tostringarray ( value ) ; beanreferences [ ] references = new beanreferences [ refnames . length ] ; for ( int i = num_ ; i < refnames . length ; i ++ ) { references [ i ] = beanreferences . of ( refnames [ i ] . trim ( ) ) ; } return references ; }	Converts comma-separated string into array of Bean references.
public void runjoy ( final consumer < joddjoyruntime > consumer ) { final joddjoy joddjoy = new joddjoy ( ) ; final joddjoyruntime joyruntime = joddjoy . startonlybackend ( ) ; joddjoy . withdb ( joydb -> setjtxmanager ( joyruntime . getjtxmanager ( ) ) ) ; final jtxtransaction tx = startrwtx ( ) ; final print print = new print ( ) ; try { print . line ( str_ , num_ ) ; print . newline ( ) ; consumer . accept ( joyruntime ) ; print . newline ( ) ; print . line ( str_ , num_ ) ; if ( tx != null ) { tx . commit ( ) ; } } catch ( throwable throwable ) { throwable . printstacktrace ( ) ; if ( tx != null ) { tx . rollback ( ) ; } } joddjoy . stop ( ) ; }	Runs JOY in standalone mode, with only backend.
public static method findmethod ( final class c , final string methodname ) { return finddeclaredmethod ( c , methodname , bool_ ) ; }	Returns method from an object, matched by name.
public static < t > constructor < t > findconstructor ( final class < t > clazz , final class < ? > ... parametertypes ) { final constructor < ? > [ ] constructors = clazz . getconstructors ( ) ; class < ? > [ ] pts ; for ( constructor < ? > constructor : constructors ) { pts = constructor . getparametertypes ( ) ; if ( isallassignablefrom ( pts , parametertypes ) ) { return ( constructor < t > ) constructor ; } } return null ; }	Finds constructor with given parameter types.
public static class [ ] resolveallinterfaces ( final class type ) { set < class > bag = new linkedhashset < > ( ) ; _resolveallinterfaces ( type , bag ) ; return bag . toarray ( new class [ num_ ] ) ; }	Resolves all interfaces of a type.
public static boolean compareparameters ( final class [ ] first , final class [ ] second ) { if ( first . length != second . length ) { return bool_ ; } for ( int i = num_ ; i < first . length ; i ++ ) { if ( first [ i ] != second [ i ] ) { return bool_ ; } } return bool_ ; }	Compares classes, usually method or ctor parameters.
public static void forceaccess ( final accessibleobject accobject ) { try { if ( system . getsecuritymanager ( ) == null ) accobject . setaccessible ( bool_ ) ; else { accesscontroller . doprivileged ( ( privilegedaction ) ( ) -> { accobject . setaccessible ( bool_ ) ; return null ; } ) ; } } catch ( securityexception sex ) {	Suppress access check against a reflection object.
@ suppresswarnings ( str_ ) public static < t > t newinstance ( final class < t > clazz , final object ... params ) throws instantiationexception , illegalaccessexception , invocationtargetexception , nosuchmethodexception { if ( params . length == num_ ) { return newinstance ( clazz ) ; } final class < ? > [ ] paramtypes = getclasses ( params ) ; final constructor < ? > constructor = findconstructor ( clazz , paramtypes ) ; if ( constructor == null ) { throw new instantiationexception ( str_ ) ; } return ( t ) constructor . newinstance ( params ) ; }	Creates new instance of given class with given optional arguments.
public static class [ ] getsuperclasses ( final class type ) { int i = num_ ; for ( class x = type . getsuperclass ( ) ; x != null ; x = x . getsuperclass ( ) ) { i ++ ; } class [ ] result = new class [ i ] ; i = num_ ; for ( class x = type . getsuperclass ( ) ; x != null ; x = x . getsuperclass ( ) ) { result [ i ] = x ; i ++ ; } return result ; }	Returns all superclasses.
public static class < ? > childclassof ( final class < ? > parentclass , final object instance ) { if ( instance == null || instance == object . class ) { return null ; } if ( parentclass != null ) { if ( parentclass . isinterface ( ) ) { return null ; } } class < ? > childclass = instance . getclass ( ) ; while ( bool_ ) { class < ? > parent = childclass . getsuperclass ( ) ; if ( parent == parentclass ) { return childclass ; } if ( parent == null ) { return null ; } childclass = parent ; } }	Returns the class of the immediate subclass of the given parent class forthe given object instance; or null if such immediate subclass cannot beuniquely identified for the given object instance.
public static jarfile jarfileof ( final class < ? > klass ) { url url = klass . getresource ( str_ + klass . getname ( ) . replace ( str_ , str_ ) + str_ ) ; if ( url == null ) { return null ; } string s = url . getfile ( ) ; int beginindex = s . indexof ( str_ ) + str_ . length ( ) ; int endindex = s . indexof ( str_ ) ; if ( endindex == - num_ ) { return null ; } endindex += str_ . length ( ) ; string f = s . substring ( beginindex , endindex ) ;	Returns the jar file from which the given class is loaded; or nullif no such jar file can be located.
public static void sleep ( final long ms ) { try { thread . sleep ( ms ) ; } catch ( interruptedexception iex ) { thread . currentthread ( ) . interrupt ( ) ; } }	Puts a thread to sleep, without throwing an InterruptedException.
public static void sleep ( ) { try { thread . sleep ( long . max_value ) ; } catch ( interruptedexception iex ) { thread . currentthread ( ) . interrupt ( ) ; } }	Puts a thread to sleep forever.
public static void wait ( final object obj ) { synchronized ( obj ) { try { obj . wait ( ) ; } catch ( interruptedexception inex ) { thread . currentthread ( ) . interrupt ( ) ; } } }	Waits for a object for synchronization purposes.
public static threadfactory daemonthreadfactory ( final string name , final int priority ) { return new threadfactory ( ) { private atomicinteger count = new atomicinteger ( ) ; @ override public thread newthread ( final runnable r ) { thread thread = new thread ( r ) ; thread . setname ( name + str_ + count . incrementandget ( ) ) ; thread . setdaemon ( bool_ ) ; thread . setpriority ( priority ) ; return thread ; } } ; }	Creates new daemon thread factory.
@ override public t get ( ) { if ( ! initialized ) { synchronized ( this ) { if ( ! initialized ) { final t t = supplier . get ( ) ; value = t ; initialized = bool_ ; supplier = null ; return t ; } } } return value ; }	Returns the value. Value will be computed on first call.
public void visitparameter ( final string name , final int access ) { if ( api < opcodes . asm5 ) { throw new unsupportedoperationexception ( requires_asm5 ) ; } if ( mv != null ) { mv . visitparameter ( name , access ) ; } }	Visits a parameter of this method.
public annotationvisitor visitannotation ( final string descriptor , final boolean visible ) { if ( mv != null ) { return mv . visitannotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of this method.
public void visitfieldinsn ( final int opcode , final string owner , final string name , final string descriptor ) { if ( mv != null ) { mv . visitfieldinsn ( opcode , owner , name , descriptor ) ; } }	Visits a field instruction.
public void visitmethodinsn ( final int opcode , final string owner , final string name , final string descriptor , final boolean isinterface ) { if ( api < opcodes . asm5 ) { if ( isinterface != ( opcode == opcodes . invokeinterface ) ) { throw new illegalargumentexception ( str_ ) ; } visitmethodinsn ( opcode , owner , name , descriptor ) ; return ; } if ( mv != null ) { mv . visitmethodinsn ( opcode , owner , name , descriptor , isinterface ) ; } }	Visits a method instruction.
public void visitinvokedynamicinsn ( final string name , final string descriptor , final handle bootstrapmethodhandle , final object ... bootstrapmethodarguments ) { if ( api < opcodes . asm5 ) { throw new unsupportedoperationexception ( requires_asm5 ) ; } if ( mv != null ) { mv . visitinvokedynamicinsn ( name , descriptor , bootstrapmethodhandle , bootstrapmethodarguments ) ; } }	Visits an invokedynamic instruction.
public void visitjumpinsn ( final int opcode , final label label ) { if ( mv != null ) { mv . visitjumpinsn ( opcode , label ) ; } }	Visits a jump instruction.
public void visitmultianewarrayinsn ( final string descriptor , final int numdimensions ) { if ( mv != null ) { mv . visitmultianewarrayinsn ( descriptor , numdimensions ) ; } }	Visits a MULTIANEWARRAY instruction.
public void visittrycatchblock ( final label start , final label end , final label handler , final string type ) { if ( mv != null ) { mv . visittrycatchblock ( start , end , handler , type ) ; } }	Visits a try catch block.
void converttowriter ( final writer writer , final properties properties , final map < string , properties > profiles ) throws ioexception { final bufferedwriter bw = getbufferedwriter ( writer ) ; writebaseandprofileproperties ( bw , properties , profiles ) ; writeprofilepropertiesthatarenotinthebase ( bw , properties , profiles ) ; bw . flush ( ) ; }	Convert Java Properties to Jodd Props format.
@ override public void processstream ( ) throws ioexception { fastbytearrayoutputstream out = new fastbytearrayoutputstream ( ) ; size = num_ ; if ( maxfilesize == - num_ ) { size += input . copyall ( out ) ; } else { size += input . copymax ( out , maxfilesize + num_ ) ;	Reads data from input stream into byte array and stores file size.
@ override public t next ( ) { if ( hasnext == null ) { hasnext = boolean . valueof ( movetonext ( ) ) ; } if ( hasnext == bool_ ) { throw new nosuchelementexception ( ) ; } if ( ! entityawaremode ) { hasnext = null ; return newelement ; } count ++ ; t result = previouselement ; previouselement = newelement ; hasnext = null ; return result ; }	Returns next mapped object.
private boolean movetonext ( ) { if ( last ) {	Moves to next element.
@ suppresswarnings ( { str_ } ) public static < t > t [ ] join ( t [ ] ... arrays ) { class < t > componenttype = ( class < t > ) arrays . getclass ( ) . getcomponenttype ( ) . getcomponenttype ( ) ; return join ( componenttype , arrays ) ; }	Joins arrays. Component type is resolved from the array argument.
@ suppresswarnings ( { str_ } ) public static < t > t [ ] join ( class < t > componenttype , t [ ] [ ] arrays ) { if ( arrays . length == num_ ) { return arrays [ num_ ] ; } int length = num_ ; for ( t [ ] array : arrays ) { length += array . length ; } t [ ] result = ( t [ ] ) array . newinstance ( componenttype , length ) ; length = num_ ; for ( t [ ] array : arrays ) { system . arraycopy ( array , num_ , result , length , array . length ) ; length += array . length ; } return result ; }	Joins arrays using provided component type.
public static < t > t [ ] resize ( t [ ] buffer , int newsize ) { class < t > componenttype = ( class < t > ) buffer . getclass ( ) . getcomponenttype ( ) ; t [ ] temp = ( t [ ] ) array . newinstance ( componenttype , newsize ) ; system . arraycopy ( buffer , num_ , temp , num_ , buffer . length >= newsize ? newsize : buffer . length ) ; return temp ; }	Resizes an array.
public static < t > t [ ] append ( t [ ] buffer , t newelement ) { t [ ] t = resize ( buffer , buffer . length + num_ ) ; t [ buffer . length ] = newelement ; return t ; }	Appends an element to array.
@ suppresswarnings ( { str_ } ) public static < t > t [ ] remove ( t [ ] buffer , int offset , int length , class < t > componenttype ) { int len2 = buffer . length - length ; t [ ] temp = ( t [ ] ) array . newinstance ( componenttype , len2 ) ; system . arraycopy ( buffer , num_ , temp , num_ , offset ) ; system . arraycopy ( buffer , offset + length , temp , offset , len2 - offset ) ; return temp ; }	Removes sub-array.
public static int indexof ( char [ ] array , char value ) { for ( int i = num_ ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { return i ; } } return - num_ ; }	Finds the first occurrence of an element in an array.
public static int indexof ( object [ ] array , object value ) { for ( int i = num_ ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( value ) ) { return i ; } } return - num_ ; }	Finds the first occurrence in an array.
public static int indexof ( byte [ ] array , byte [ ] sub , int startindex ) { return indexof ( array , sub , startindex , array . length ) ; }	Finds the first occurrence in an array from specified given position.
public lagartodombuilder enablexhtmlmode ( ) { config . ignorewhitespacesbetweentags = bool_ ;	Enables XHTML mode.
@ override public document parse ( final char [ ] content ) { lagartoparser lagartoparser = new lagartoparser ( content ) ; return doparse ( lagartoparser ) ; }	Creates DOM tree from provided content.
protected document doparse ( final lagartoparser lagartoparser ) { lagartoparser . setconfig ( config ) ; lagartodombuildertagvisitor dombuildertagvisitor = new lagartodombuildertagvisitor ( this ) ; lagartoparser . parse ( dombuildertagvisitor ) ; return dombuildertagvisitor . getdocument ( ) ; }	Parses the content using provided lagarto parser.
private void computemaxstackandlocal ( ) {	Computes the maximum stack size of the method.
private void endcurrentbasicblockwithnosuccessor ( ) { if ( compute == compute_all_frames ) { label nextbasicblock = new label ( ) ; nextbasicblock . frame = new frame ( nextbasicblock ) ; nextbasicblock . resolve ( code . data , code . length ) ; lastbasicblock . nextbasicblock = nextbasicblock ; lastbasicblock = nextbasicblock ; currentbasicblock = null ; } else if ( compute == compute_max_stack_and_local ) { currentbasicblock . outputstackmax = ( short ) maxrelativestacksize ; currentbasicblock = null ; } }	Ends the current basic block.
final void collectattributeprototypes ( final attribute . set attributeprototypes ) { attributeprototypes . addattributes ( firstattribute ) ; attributeprototypes . addattributes ( firstcodeattribute ) ; }	Collects the attributes of this method into the given set of attribute prototypes.
public void injectcontext ( final object targetobject ) { final class targettype = targetobject . getclass ( ) ; final scopedata scopedata = scopedatainspector . inspectclassscopeswithcache ( targettype ) ; final targets targets = new targets ( targetobject , scopedata ) ;	Inject context into target.
public static void registerpseudoclass ( final class < ? extends pseudoclass > pseudoclasstype ) { pseudoclass pseudoclass ; try { pseudoclass = classutil . newinstance ( pseudoclasstype ) ; } catch ( exception ex ) { throw new cssellyexception ( ex ) ; } pseudo_class_map . put ( pseudoclass . getpseudoclassname ( ) , pseudoclass ) ; }	Registers pseudo class.
public static pseudoclass lookuppseudoclass ( final string pseudoclassname ) { pseudoclass pseudoclass = pseudo_class_map . get ( pseudoclassname ) ; if ( pseudoclass == null ) { throw new cssellyexception ( str_ + pseudoclassname ) ; } return pseudoclass ; }	Lookups pseudo class for given pseudo class name.
public void invoke ( final actionrequest actionrequest ) { if ( executorservice == null ) { throw new madvocexception ( str_ ) ; } final httpservletrequest servletrequest = actionrequest . gethttpservletrequest ( ) ; log . debug ( ( ) -> str_ + actionrequest ) ; final asynccontext asynccontext = servletrequest . startasync ( ) ; executorservice . submit ( ( ) -> { try { actionrequest . invoke ( ) ; } catch ( exception ex ) { log . error ( str_ , exceptionutil . unwrapthrowable ( ex ) ) ; } finally { asynccontext . complete ( ) ; } } ) ; }	Invokes an action asynchronously by submitting it to the thread pool.
protected string [ ] getallbeanpropertynames ( final class type , final boolean declared ) { classdescriptor classdescriptor = classintrospector . get ( ) . lookup ( type ) ; propertydescriptor [ ] propertydescriptors = classdescriptor . getallpropertydescriptors ( ) ; arraylist < string > names = new arraylist < > ( propertydescriptors . length ) ; for ( propertydescriptor propertydescriptor : propertydescriptors ) { methoddescriptor getter = propertydescriptor . getreadmethoddescriptor ( ) ; if ( getter != null ) { if ( getter . matchdeclared ( declared ) ) { names . add ( propertydescriptor . getname ( ) ) ; } } else if ( includefields ) { fielddescriptor field = propertydescriptor . getfielddescriptor ( ) ; if ( field != null ) { if ( field . matchdeclared ( declared ) ) { names . add ( field . getname ( ) ) ; } } } } return names . toarray ( new string [ num_ ] ) ; }	Returns all bean property names.
public void visit ( ) { string [ ] properties = resolveproperties ( source , declared ) ; for ( string name : properties ) { if ( name == null ) { continue ; } if ( ! rules . match ( name , blacklist ) ) { continue ; } object value ; string propertyname = name ; if ( issourcemap ) { propertyname = left_sq_bracket + name + right_sq_bracket ; } if ( declared ) { value = beanutil . declared . getproperty ( source , propertyname ) ; } else { value = beanutil . pojo . getproperty ( source , propertyname ) ; } if ( value == null && ignorenullvalues ) { continue ; } if ( value instanceof string && stringutil . isempty ( ( string ) value ) ) { continue ; } visitproperty ( name , value ) ; } }	Starts visiting properties.
@ override public boolean accept ( final string propertyname , final string rule , final boolean include ) { return propertyname . equals ( rule ) ; }	Compares property name to the rules.
public methodinjectionpoint [ ] resolve ( final class type ) {	Resolve method injection points in given class.
protected void readfilterconfigparameters ( final filterconfig filterconfig , final object target , final string ... parameters ) { for ( string parameter : parameters ) { string value = filterconfig . getinitparameter ( parameter ) ; if ( value != null ) { beanutil . declared . setproperty ( target , parameter , value ) ; } } }	Reads filter config parameters and set into destination target.
protected void sendbundlefile ( final httpservletresponse resp , final file bundlefile ) throws ioexception { outputstream out = resp . getoutputstream ( ) ; fileinputstream fileinputstream = new fileinputstream ( bundlefile ) ; try { streamutil . copy ( fileinputstream , out ) ; } finally { streamutil . close ( fileinputstream ) ; } }	Outputs bundle file to the response.
public file lookupbundlefile ( string bundleid ) { if ( ( mirrors != null ) && ( ! mirrors . isempty ( ) ) ) { string realbundleid = mirrors . remove ( bundleid ) ; if ( realbundleid != null ) { bundleid = realbundleid ; } } return createbundlefile ( bundleid ) ; }	Lookups for bundle file.
public file lookupgzipbundlefile ( final file file ) throws ioexception { string path = file . getpath ( ) + ziputil . gzip_ext ; file gzipfile = new file ( path ) ; if ( ! gzipfile . exists ( ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ + path ) ; } ziputil . gzip ( file ) ; } return gzipfile ; }	Locates gzipped version of bundle file.
public synchronized string registerbundle ( final string contextpath , final string actionpath , final string tempbundleid , final string bundlecontenttype , final list < string > sources ) { if ( tempbundleid == null || sources . isempty ( ) ) { if ( strategy == strategy . action_managed ) {	Registers new bundle that consist of provided list of source paths.Returns the real bundle id, as provided one is just a temporary bundle id.
protected string createdigest ( final string source ) { final digestengine digestengine = digestengine . sha256 ( ) ; final byte [ ] bytes = digestengine . digest ( charutil . tosimplebytearray ( source ) ) ; string digest = base32 . encode ( bytes ) ; if ( uniquedigestkey != null ) { digest += uniquedigestkey ; } return digest ; }	Creates digest i.e. bundle id from given string.Returned digest must be filename safe, for all platforms.
protected void createbundle ( final string contextpath , final string actionpath , final string bundleid , final list < string > sources ) throws ioexception { final file bundlefile = createbundlefile ( bundleid ) ; if ( bundlefile . exists ( ) ) { return ; } stringband sb = new stringband ( sources . size ( ) * num_ ) ; for ( string src : sources ) { if ( sb . length ( ) != num_ ) { sb . append ( stringpool . newline ) ; } string content ; if ( isexternalresource ( src ) ) { content = downloadstring ( src ) ; } else { if ( ! downloadlocal ) {	Creates bundle file by loading resource files content. If bundle file alreadyexist it will not be recreated!.
public synchronized void reset ( ) { if ( strategy == strategy . action_managed ) { actionbundles . clear ( ) ; mirrors . clear ( ) ; } final findfile ff = new findfile ( ) ; ff . includedirs ( bool_ ) ; ff . searchpath ( new file ( bundlefolder , staplerpath ) ) ; file f ; int count = num_ ; while ( ( f = ff . nextfile ( ) ) != null ) { f . delete ( ) ; count ++ ; } if ( log . isinfoenabled ( ) ) { log . info ( str_ + count + str_ ) ; } }	Clears all settings and removes all created bundle files from file system.
protected string fixcssrelativeurls ( final string content , final string src ) { final string path = filenameutil . getpath ( src ) ; final matcher matcher = css_url_pattern . matcher ( content ) ; final stringbuilder sb = new stringbuilder ( content . length ( ) ) ; int start = num_ ; while ( matcher . find ( ) ) { sb . append ( content , start , matcher . start ( ) ) ; final string matchedurl = stringutil . removechars ( matcher . group ( num_ ) , str_ ) ; final string url ; if ( matchedurl . startswith ( str_ ) || matchedurl . startswith ( str_ ) || matchedurl . startswith ( str_ ) ) { url = str_ + matchedurl + str_ ; } else { url = fixrelativeurl ( matchedurl , path ) ; } sb . append ( url ) ; start = matcher . end ( ) ; } sb . append ( content . substring ( start ) ) ; return sb . tostring ( ) ; }	Returns the content with all relative URLs fixed.
public dbsqlbuilder updatecolumn ( final object entity , final string columnref ) { final object value = beanutil . pojo . getproperty ( entity , columnref ) ; return updatecolumn ( entity , columnref , value ) ; }	Reads property value and updates the DB.
protected static string createtablerefname ( final object entity ) { class type = entity . getclass ( ) ; type = ( type == class . class ? ( class ) entity : type ) ; return ( type . getsimplename ( ) + str_ ) ; }	Creates table reference name from entity type.Always appends an underscore to reference name in orderto circumvent SQL compatibility issues when entity class nameequals to a reserved word.
@ override public dbsession getdbsession ( ) { log . debug ( str_ ) ; final dbjtxtransaction jtx = ( dbjtxtransaction ) jtxtxmanager . gettransaction ( ) ; if ( jtx == null ) { throw new dbsqlexception ( str_ + str_ ) ; } return jtx . requestresource ( ) ; }	Returns session from JTX transaction manager and started transaction.
protected t [ ] converttosingleelementarray ( final object value ) { t [ ] singleelementarray = createarray ( num_ ) ; singleelementarray [ num_ ] = converttype ( value ) ; return singleelementarray ; }	Creates an array with single element.
public map < string , string > parsesignatureforgenerics ( final string signature , final boolean isinterface ) { if ( signature == null ) { return collections . emptymap ( ) ; } final map < string , string > genericsmap = new hashmap < > ( ) ; signaturereader sr = new signaturereader ( signature ) ; stringbuilder sb = new stringbuilder ( ) ; tracesignaturevisitor v = new tracesignaturevisitor ( sb , isinterface ) { string genericname ; @ override public void visitformaltypeparameter ( final string name ) { genericname = name ; super . visitformaltypeparameter ( name ) ; } @ override public void visitclasstype ( final string name ) { if ( genericname != null ) { genericsmap . put ( genericname , str_ + name + str_ ) ; genericname = null ; } super . visitclasstype ( name ) ; } } ; sr . accept ( v ) ; return genericsmap ; }	Parses signature for generic information and returns a map where key is generic nameand value is raw type.
public setinjectionpoint [ ] resolve ( final class type , final boolean autowire ) { classdescriptor cd = classintrospector . get ( ) . lookup ( type ) ; list < setinjectionpoint > list = new arraylist < > ( ) ; propertydescriptor [ ] allproperties = cd . getallpropertydescriptors ( ) ; for ( propertydescriptor propertydescriptor : allproperties ) { if ( propertydescriptor . isgetteronly ( ) ) { continue ; } class propertytype = propertydescriptor . gettype ( ) ; if ( ! classutil . istypeof ( propertytype , collection . class ) ) { continue ; } methoddescriptor writemethoddescriptor = propertydescriptor . getwritemethoddescriptor ( ) ; fielddescriptor fielddescriptor = propertydescriptor . getfielddescriptor ( ) ; petiteinject ref = null ; if ( writemethoddescriptor != null ) { ref = writemethoddescriptor . getmethod ( ) . getannotation ( petiteinject . class ) ; } if ( ref == null && fielddescriptor != null ) { ref = fielddescriptor . getfield ( ) . getannotation ( petiteinject . class ) ; } if ( ( ! autowire ) && ( ref == null ) ) { continue ; } list . add ( new setinjectionpoint ( propertydescriptor ) ) ; } setinjectionpoint [ ] fields ; if ( list . isempty ( ) ) { fields = setinjectionpoint . empty ; } else { fields = list . toarray ( new setinjectionpoint [ num_ ] ) ; } return fields ; }	Resolves all collections for given type.
public boolean matchignoredpropertytypes ( final class propertytype , final boolean excludemaps , final boolean include ) { if ( ! include ) { return bool_ ; } if ( propertytype != null ) { if ( ! jsonserializer . deep ) { classdescriptor propertytypeclassdescriptor = classintrospector . get ( ) . lookup ( propertytype ) ; if ( propertytypeclassdescriptor . isarray ( ) ) { return bool_ ; } if ( propertytypeclassdescriptor . iscollection ( ) ) { return bool_ ; } if ( excludemaps ) { if ( propertytypeclassdescriptor . ismap ( ) ) { return bool_ ; } } }	Matches property types that are ignored by default.
protected void openconnectionforquery ( ) { if ( connection == null ) { connection = connectionprovider . getconnection ( ) ; txactive = bool_ ;	Opens connection in auto-commit mode, if already not opened.
protected void opentx ( ) { if ( connection == null ) { connection = connectionprovider . getconnection ( ) ; } txactive = bool_ ; try { connection . setautocommit ( bool_ ) ; if ( txmode . getisolation ( ) != dbtransactionmode . isolation_default ) { connection . settransactionisolation ( txmode . getisolation ( ) ) ; } connection . setreadonly ( txmode . isreadonly ( ) ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( str_ , sex ) ; } }	Opens a transaction.
protected void closetx ( ) { txactive = bool_ ; try { connection . setautocommit ( bool_ ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( str_ , sex ) ; } }	Closes current transaction.
public void committransaction ( ) { log . debug ( str_ ) ; asserttxisactive ( ) ; try { connection . commit ( ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( str_ , sex ) ; } finally { closetx ( ) ; } }	Commit the current transaction, writing any unflushed changes to the database.Transaction mode is closed.
public void rollbacktransaction ( ) { log . debug ( str_ ) ; asserttxisactive ( ) ; try { connection . rollback ( ) ; } catch ( sqlexception sex ) { throw new dbsqlexception ( str_ , sex ) ; } finally { closetx ( ) ; } }	Roll back the current transaction.
public static properties createfromfile ( final file file ) throws ioexception { properties prop = new properties ( ) ; loadfromfile ( prop , file ) ; return prop ; }	Create properties from the file.
public static properties createfromstring ( final string data ) throws ioexception { properties p = new properties ( ) ; loadfromstring ( p , data ) ; return p ; }	Creates properties from string.
public static void loadfromstring ( final properties p , final string data ) throws ioexception { try ( bytearrayinputstream is = new bytearrayinputstream ( data . getbytes ( stringpool . iso_8859_1 ) ) ) { p . load ( is ) ; } }	Loads properties from string.
public static properties subset ( final properties p , string prefix , final boolean stripprefix ) { if ( stringutil . isblank ( prefix ) ) { return p ; } if ( ! prefix . endswith ( stringpool . dot ) ) { prefix += str_ ; } properties result = new properties ( ) ; int baselen = prefix . length ( ) ; for ( object o : p . keyset ( ) ) { string key = ( string ) o ; if ( key . startswith ( prefix ) ) { result . setproperty ( stripprefix ? key . substring ( baselen ) : key , p . getproperty ( key ) ) ; } } return result ; }	Creates new Properties object from the original one, by copyingthose properties that have specified first part of the key name.Prefix may be optionally stripped during this process.
public static properties createfromclasspath ( final string ... roottemplate ) { properties p = new properties ( ) ; return loadfromclasspath ( p , roottemplate ) ; }	Creates properties from classpath.
public static string getproperty ( final map map , final string key , final string defaultvalue ) { object val = map . get ( key ) ; return ( val instanceof string ) ? ( string ) val : defaultvalue ; }	Returns String property from a map.
public static void resolveallvariables ( final properties prop ) { for ( object o : prop . keyset ( ) ) { string key = ( string ) o ; string value = resolveproperty ( prop , key ) ; prop . setproperty ( key , value ) ; } }	Resolves all variables.
public static string resolveproperty ( final map map , final string key ) { string value = getproperty ( map , key ) ; if ( value == null ) { return null ; } value = stp . parse ( value , macroname -> getproperty ( map , macroname ) ) ; return value ; }	Returns property with resolved variables.
public string resolvescope ( final class type , final string methodname ) { if ( scopepattern == null ) { return null ; } string ctx = scopepattern ; ctx = stringutil . replace ( ctx , jtxctx_pattern_class , type . getname ( ) ) ; ctx = stringutil . replace ( ctx , jtxctx_pattern_method , methodname ) ; return ctx ; }	Resolves tx scope from scope pattern.
public synchronized jtxtransactionmode gettxmode ( final class type , final string methodname , final class [ ] methodargtypes , final string unique ) { string signature = type . getname ( ) + str_ + methodname + str_ + unique ; jtxtransactionmode txmode = txmap . get ( signature ) ; if ( txmode == null ) { if ( ! txmap . containskey ( signature ) ) { final method m ; try { m = type . getmethod ( methodname , methodargtypes ) ; } catch ( nosuchmethodexception nsmex ) { throw new proxettaexception ( nsmex ) ; } final transactionannotationvalues txann = readtransactionannotation ( m ) ; if ( txann != null ) { txmode = new jtxtransactionmode ( txann . propagation ( ) , txann . isolation ( ) , txann . readonly ( ) , txann . timeout ( ) ) ; } else { txmode = defaulttransactionmode ; } txmap . put ( signature , txmode ) ; } } return txmode ; }	Reads transaction mode from method annotation.
@ suppresswarnings ( { str_ } ) public void registerannotations ( final class < ? extends annotation > [ ] annotations ) { this . annotations = annotations ; this . annotationparsers = new annotationparser [ annotations . length ] ; for ( int i = num_ ; i < annotations . length ; i ++ ) { annotationparsers [ i ] = transactionannotationvalues . parserfor ( annotations [ i ] ) ; } }	Registers new TX annotations.
protected transactionannotationvalues readtransactionannotation ( final method method ) { for ( annotationparser annotationparser : annotationparsers ) { transactionannotationvalues tad = transactionannotationvalues . of ( annotationparser , method ) ; if ( tad != null ) { return tad ; } } return null ; }	Finds TX annotation.
@ override public boolean accept ( final node node ) {	Accepts single node.
protected boolean matchelement ( final node node ) { if ( node . getnodetype ( ) != node . nodetype . element ) { return bool_ ; } string element = getelement ( ) ; string nodename = node . getnodename ( ) ; return element . equals ( stringpool . star ) || element . equals ( nodename ) ; }	Matches element to css selector.
public boolean accept ( final list < node > currentresults , final node node , final int index ) {	Accepts node within current results.
protected string unescape ( final string value ) { if ( value . indexof ( str_ ) == - num_ ) { return value ; } return stringutil . remove ( value , str_ ) ; }	Unescapes CSS string by removing all backslash characters from it.
private string [ ] buildjrepackages ( final int javaversionnumber ) { final arraylist < string > packages = new arraylist < > ( ) ; switch ( javaversionnumber ) { case num_ : case num_ : case num_ : case num_ : case num_ :	Builds a set of java core packages.
protected < t extends node > t cloneto ( final t dest ) {	Copies all non-final values to the empty cloned object.Cache-related values are not copied.
public void detachfromparent ( ) { if ( parentnode == null ) { return ; } if ( parentnode . childnodes != null ) { parentnode . childnodes . remove ( siblingindex ) ; parentnode . reindexchildren ( ) ; } parentnode = null ; }	Removes this node from DOM tree.
public void addchild ( final node ... nodes ) { if ( nodes . length == num_ ) { return ;	Appends several child nodes at once.Reindex is done only once, after all children are added.
public void insertchild ( final node node , final int index ) { node . detachfromparent ( ) ; node . parentnode = this ; try { initchildnodes ( node ) ; childnodes . add ( index , node ) ; } catch ( indexoutofboundsexception ignore ) { throw new lagartodomexception ( str_ + index ) ; } reindexchildren ( ) ; }	Inserts node at given index.
public void insertbefore ( final node newchild , final node refchild ) { int siblingindex = refchild . getsiblingindex ( ) ; refchild . parentnode . insertchild ( newchild , siblingindex ) ; }	Inserts node before provided node.
public void insertbefore ( final node [ ] newchilds , final node refchild ) { if ( newchilds . length == num_ ) { return ; } int siblingindex = refchild . getsiblingindex ( ) ; refchild . parentnode . insertchild ( newchilds , siblingindex ) ; }	Inserts several child nodes before provided node.
public void insertafter ( final node newchild , final node refchild ) { int siblingindex = refchild . getsiblingindex ( ) + num_ ; if ( siblingindex == refchild . parentnode . getchildnodescount ( ) ) { refchild . parentnode . addchild ( newchild ) ; } else { refchild . parentnode . insertchild ( newchild , siblingindex ) ; } }	Inserts node after provided node.
public void insertafter ( final node [ ] newchilds , final node refchild ) { if ( newchilds . length == num_ ) { return ; } int siblingindex = refchild . getsiblingindex ( ) + num_ ; if ( siblingindex == refchild . parentnode . getchildnodescount ( ) ) { refchild . parentnode . addchild ( newchilds ) ; } else { refchild . parentnode . insertchild ( newchilds , siblingindex ) ; } }	Inserts several child nodes after referent node.
public void removeallchilds ( ) { list < node > removednodes = childnodes ; childnodes = null ; childelementnodes = null ; childelementnodescount = num_ ; if ( removednodes != null ) { for ( int i = num_ , removednodessize = removednodes . size ( ) ; i < removednodessize ; i ++ ) { node removednode = removednodes . get ( i ) ; removednode . detachfromparent ( ) ; } } }	Removes all child nodes.
public node findchildnodewithname ( final string name ) { if ( childnodes == null ) { return null ; } for ( final node childnode : childnodes ) { if ( childnode . getnodename ( ) . equals ( name ) ) { return childnode ; } } return null ; }	Finds the first child node with given node name.
public node [ ] filterchildnodes ( final predicate < node > nodepredicate ) { if ( childnodes == null ) { return new node [ num_ ] ; } return childnodes . stream ( ) . filter ( nodepredicate ) . toarray ( node [ ] :: new ) ; }	Filters child nodes.
public boolean check ( ) { if ( childnodes == null ) { return bool_ ; }	Checks the health of child nodes.
protected void initchildelementnodes ( ) { if ( childelementnodes == null ) { childelementnodes = new element [ childelementnodescount ] ; int childcount = getchildnodescount ( ) ; for ( int i = num_ ; i < childcount ; i ++ ) { node child = getchild ( i ) ; if ( child . siblingelementindex >= num_ ) { childelementnodes [ child . siblingelementindex ] = ( element ) child ; } } } }	Initializes list of child elements.
protected void initsiblingnames ( ) { if ( siblingnameindex == - num_ ) { list < node > siblings = parentnode . childnodes ; int index = num_ ; for ( int i = num_ , siblingssize = siblings . size ( ) ; i < siblingssize ; i ++ ) { node sibling = siblings . get ( i ) ; if ( sibling . siblingnameindex == - num_ && nodetype == nodetype . element && nodename . equals ( sibling . getnodename ( ) ) ) { sibling . siblingnameindex = index ++ ; } } } }	Initializes siblings elements of the same name.
protected void initchildnodes ( final node newnode ) { if ( childnodes == null ) { childnodes = new arraylist < > ( ) ; } if ( ownerdocument != null ) { if ( newnode . ownerdocument != ownerdocument ) { changeownerdocument ( newnode , ownerdocument ) ; } } }	Initializes child nodes list when needed.Also fix owner document for new node, if needed.
protected void changeownerdocument ( final node node , final document ownerdocument ) { node . ownerdocument = ownerdocument ; int childcount = node . getchildnodescount ( ) ; for ( int i = num_ ; i < childcount ; i ++ ) { node child = node . getchild ( i ) ; changeownerdocument ( child , ownerdocument ) ; } }	Changes owner document for given node and all its children.
public node getprevioussiblingname ( ) { if ( nodename == null ) { return null ; } initsiblingnames ( ) ; int index = siblingnameindex - num_ ; for ( int i = siblingindex ; i >= num_ ; i -- ) { node sibling = parentnode . childnodes . get ( i ) ; if ( ( index == sibling . siblingnameindex ) && nodename . equals ( sibling . getnodename ( ) ) ) { return sibling ; } } return null ; }	Returns this node's previous sibling element with the same name.
public string gettextcontent ( ) { stringbuilder sb = new stringbuilder ( getchildnodescount ( ) + num_ ) ; appendtextcontent ( sb ) ; return sb . tostring ( ) ; }	Returns the text content of this node and its descendants.
public string getinnerhtml ( ) { lagartodombuilderconfig lagartodombuilderconfig ; if ( ownerdocument == null ) { lagartodombuilderconfig = ( ( document ) this ) . getconfig ( ) ; } else { lagartodombuilderconfig = ownerdocument . getconfig ( ) ; } lagartohtmlrenderer lagartohtmlrenderer = lagartodombuilderconfig . getlagartohtmlrenderer ( ) ; return lagartohtmlrenderer . toinnerhtml ( this , new stringbuilder ( ) ) ; }	Generates inner HTML.
protected void visitchildren ( final nodevisitor nodevisitor ) { if ( childnodes != null ) { for ( int i = num_ , childnodessize = childnodes . size ( ) ; i < childnodessize ; i ++ ) { node childnode = childnodes . get ( i ) ; childnode . visit ( nodevisitor ) ; } } }	Visits children nodes.
public string getcsspath ( ) { stringbuilder path = new stringbuilder ( ) ; node node = this ; while ( node != null ) { string nodename = node . getnodename ( ) ; if ( nodename != null ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) . append ( nodename ) ; string id = node . getattribute ( str_ ) ; if ( id != null ) { sb . append ( str_ ) . append ( id ) ; } path . insert ( num_ , sb ) ; } node = node . getparentnode ( ) ; } if ( path . charat ( num_ ) == str_ ) { return path . substring ( num_ ) ; } return path . tostring ( ) ; }	Returns CSS path to this node from document root.
protected void ondecoratag ( final tag tag ) { string tagname = tag . getname ( ) . tostring ( ) ; if ( tag . gettype ( ) == tagtype . self_closing ) { checknesteddecoratags ( ) ; decoratagname = tagname . substring ( num_ ) ; decoratagstart = tag . gettagposition ( ) ; decoratagend = tag . gettagposition ( ) + tag . gettaglength ( ) ; definedecoratag ( ) ; return ; } if ( tag . gettype ( ) == tagtype . start ) { checknesteddecoratags ( ) ; decoratagname = tagname . substring ( num_ ) ; decoratagstart = tag . gettagposition ( ) ; decoratagdefaultvaluestart = tag . gettagposition ( ) + tag . gettaglength ( ) ; return ; }	Handle Decora tags.
protected void onidattrstart ( final tag tag ) { string id = tag . getid ( ) . tostring ( ) . substring ( num_ ) ; string tagname ; string idname ; int dashindex = id . indexof ( str_ ) ; if ( dashindex == - num_ ) { tagname = id ; idname = null ; } else { tagname = id . substring ( num_ , dashindex ) ; idname = id . substring ( dashindex + num_ ) ; } if ( tag . gettype ( ) == tagtype . self_closing ) { checknesteddecoratags ( ) ; decoratagname = tagname ; decoraidname = idname ; decoratagstart = tag . gettagposition ( ) ; decoratagend = tag . gettagposition ( ) + tag . gettaglength ( ) ; definedecoratag ( ) ; return ; } if ( tag . gettype ( ) == tagtype . start ) { checknesteddecoratags ( ) ; decoratagname = tagname ; decoraidname = idname ; decoratagstart = tag . gettagposition ( ) ; decoratagdefaultvaluestart = tag . gettagposition ( ) + tag . gettaglength ( ) ; closingtagname = tag . getname ( ) . tostring ( ) ; closingtagdeeplevel = tag . getdeeplevel ( ) ; } }	Handle open and empty ID attribute tags.
protected void definedecoratag ( ) { decoratag decoratag = decoratagdefaultvaluestart == num_ ? new decoratag ( decoratagname , decoraidname , decoratagstart , decoratagend ) : new decoratag ( decoratagname , decoraidname , decoratagstart , decoratagend , decoratagdefaultvaluestart , decoratagdefaultvalueend - decoratagdefaultvaluestart ) ; decoratags . add ( decoratag ) ; decoratagname = null ; decoraidname = null ; closingtagname = null ; decoratagdefaultvaluestart = num_ ; }	Defines Decora tag position inside decorator content.Resets current Decora tag tracking.
@ override public joyproxetta addproxyaspect ( final proxyaspect proxyaspect ) { requirenotstarted ( proxetta ) ; this . proxyaspects . add ( proxyaspect ) ; return this ; }	Adds a proxy aspect.
public void addrootpackage ( final string rootpackage , string mapping ) { if ( packages == null ) { packages = new string [ num_ ] ; } if ( mappings == null ) { mappings = new string [ num_ ] ; }	Adds root package and its path mapping.
public void addrootpackageof ( final class actionclass , final string mapping ) { addrootpackage ( actionclass . getpackage ( ) . getname ( ) , mapping ) ; }	Sets root package to package of given class.
public string findrootpackageforactionpath ( final string actionpath ) { if ( mappings == null ) { return null ; } int ndx = - num_ ; int delta = integer . max_value ; for ( int i = num_ ; i < mappings . length ; i ++ ) { string mapping = mappings [ i ] ; boolean found = bool_ ; if ( actionpath . equals ( mapping ) ) { found = bool_ ; } else { mapping += stringpool . slash ; if ( actionpath . startswith ( mapping ) ) { found = bool_ ; } } if ( found ) { int distance = actionpath . length ( ) - mapping . length ( ) ; if ( distance < delta ) { ndx = i ; delta = distance ; } } } if ( ndx == - num_ ) { return null ; } return packages [ ndx ] ; }	Finds closest root package for the given action path.
public static string resolvevalidationmessage ( final httpservletrequest request , final violation violation ) { validationconstraint vc = violation . getconstraint ( ) ; string key = vc != null ? vc . getclass ( ) . getname ( ) : violation . getname ( ) ; string msg = localizationutil . findmessage ( request , key ) ; if ( msg != null ) { return beantemplateparser . parsewithbean ( msg , violation ) ; } return null ; }	Prepares validation messages.Key is either validation constraint class name or violation name.
public beanreferences removeduplicatenames ( ) { if ( names . length < num_ ) { return this ; } int nullcount = num_ ; for ( int i = num_ ; i < names . length ; i ++ ) { string thisref = names [ i ] ; if ( thisref == null ) { nullcount ++ ; continue ; } for ( int j = num_ ; j < i ; j ++ ) { if ( names [ j ] == null ) { continue ; } if ( thisref . equals ( names [ j ] ) ) { names [ i ] = null ; break ; } } } if ( nullcount == num_ ) { return this ; } string [ ] newrefs = new string [ names . length - nullcount ] ; int ndx = num_ ; for ( string name : names ) { if ( name == null ) { continue ; } newrefs [ ndx ] = name ; ndx ++ ; } return new beanreferences ( newrefs ) ; }	Removes later duplicated references in an array.Returns new instance of BeanReferences if there was changes,otherwise returns the same instance.
@ override public joyprops addpropsfile ( final string namepattern ) { requirenotstarted ( props ) ; this . propsnamepatterns . add ( namepattern ) ; return this ; }	Adds props files or patterns.
public void foreachtarget ( final consumer < target > targetconsumer ) { for ( final target target : targets ) { targetconsumer . accept ( target ) ; } }	Iterates all targets.
public void foreachtargetandin ( final madvocscope scope , final biconsumer < target , injectionpoint > biconsumer ) { for ( final target target : targets ) { final scopedata scopedata = target . scopedata ( ) ; if ( scopedata . in ( ) == null ) { continue ; } for ( final injectionpoint in : scopedata . in ( ) ) { if ( in . scope ( ) != scope ) { continue ; } biconsumer . accept ( target , in ) ; } } }	Iterates all targets and for each target iterates all IN injection points of given scope.
public void foreachtargetandout ( final madvocscope scope , final biconsumer < target , injectionpoint > biconsumer ) { for ( final target target : targets ) { final scopedata scopedata = target . scopedata ( ) ; if ( scopedata . out ( ) == null ) { continue ; } for ( final injectionpoint out : scopedata . out ( ) ) { if ( out . scope ( ) != scope ) { continue ; } biconsumer . accept ( target , out ) ; } } }	Iterates all targets and for each target iterates all OUT injection points of given scope.
public object [ ] extractparametersvalues ( ) { final object [ ] values = new object [ targets . length - num_ ] ; for ( int i = num_ ; i < targets . length ; i ++ ) { values [ i - num_ ] = targets [ i ] . value ( ) ; } return values ; }	Collects all parameters from target into an array.
protected target [ ] maketargets ( final target actiontarget , final methodparam [ ] methodparams ) { if ( methodparams == null ) {	Joins action and parameters into one single array of Targets.
@ suppresswarnings ( { str_ , str_ } ) protected object createactionmethodargument ( final class type , final object action ) { try { if ( type . getenclosingclass ( ) == null || modifier . isstatic ( type . getmodifiers ( ) ) ) {	Creates action method arguments.
@ override public void sessioncreated ( final httpsessionevent httpsessionevent ) { httpsession session = httpsessionevent . getsession ( ) ; sessionmap . putifabsent ( session . getid ( ) , session ) ; for ( httpsessionlistener listener : listeners ) { listener . sessioncreated ( httpsessionevent ) ; } }	Stores session in map and broadcasts event to registered listeners.
@ override public void sessiondestroyed ( final httpsessionevent httpsessionevent ) { httpsession session = httpsessionevent . getsession ( ) ; sessionmap . remove ( session . getid ( ) ) ; for ( httpsessionlistener listener : listeners ) { listener . sessiondestroyed ( httpsessionevent ) ; } }	Removes session from a map and broadcasts event to registered listeners.
public jsonarray add ( object value ) { objects . requirenonnull ( value ) ; value = jsonobject . resolvevalue ( value ) ; list . add ( value ) ; return this ; }	Adds an object to the JSON array.
public jsonarray addall ( final jsonarray array ) { objects . requirenonnull ( array ) ; list . addall ( array . list ) ; return this ; }	Appends all of the elements in the specified array to the end of this JSON array.
public object remove ( final int pos ) { object removed = list . remove ( pos ) ; if ( removed instanceof map ) { return new jsonobject ( ( map ) removed ) ; } if ( removed instanceof arraylist ) { return new jsonarray ( ( list ) removed ) ; } return removed ; }	Removes the value at the specified position in the JSON array.
protected string resolvetarget ( final actionrequest actionrequest , final string resultvalue ) { string resultbasepath = actionrequest . getactionruntime ( ) . getresultbasepath ( ) ; resultpath resultpath = resultmapper . resolveresultpath ( resultbasepath , resultvalue ) ; string actionpath = resultpath . path ( ) ; string path = actionpath ; string value = resultpath . value ( ) ; if ( stringutil . isempty ( value ) ) { value = null ; } string target ; while ( bool_ ) {	Locates the target file from action path and the result value.
protected void targetnotfound ( final actionrequest actionrequest , final string actionandresultpath ) throws ioexception { final httpservletresponse response = actionrequest . gethttpservletresponse ( ) ; if ( ! response . iscommitted ( ) ) { response . senderror ( sc_not_found , str_ + actionandresultpath ) ; } }	Called when target not found.
protected string valuetostring ( final string name , final object valueobject ) { if ( ! valueobject . getclass ( ) . isarray ( ) ) { return valueobject . tostring ( ) ; }	Converts value to a string.
@ suppresswarnings ( str_ ) public < t extends actionfilter > madvocrouter filter ( final class < t > actionfilterclass ) { filtersmanager . resolve ( actionfilterclass ) ; return this ; }	Returns action filter instance for further configuration.
public string getpseudofunctionname ( ) { string name = getclass ( ) . getsimplename ( ) . tolowercase ( ) ; name = name . replace ( str_ , str_ ) ; return name ; }	Returns pseudo-function name.
public propertyinjectionpoint [ ] resolve ( class type , final boolean autowire ) { final list < propertyinjectionpoint > list = new arraylist < > ( ) ; final set < string > usedpropertynames = new hashset < > ( ) ;	Resolves all properties for given type.
private socket createsocks4proxysocket ( final string host , final int port ) { socket socket = null ; final string proxyhost = proxy . getproxyaddress ( ) ; final int proxyport = proxy . getproxyport ( ) ; final string user = proxy . getproxyusername ( ) ; try { socket = sockets . connect ( proxyhost , proxyport , connectiontimeout ) ; final inputstream in = socket . getinputstream ( ) ; final outputstream out = socket . getoutputstream ( ) ; socket . settcpnodelay ( bool_ ) ; byte [ ] buf = new byte [ num_ ] ;	Connects to the SOCKS4 proxy and returns proxified socket.
final int getattributecount ( ) { int count = num_ ; attribute attribute = this ; while ( attribute != null ) { count += num_ ; attribute = attribute . nextattribute ; } return count ; }	Returns the number of attributes of the attribute list that begins with this attribute.
public set < actionresult > getallactionresults ( ) { final set < actionresult > set = new hashset < > ( allresults . size ( ) ) ; allresults . foreachvalue ( set :: add ) ; return set ; }	Returns all action results as new set.
public static boolean equalsone ( final char c , final charsequence match ) { for ( int i = num_ ; i < match . length ( ) ; i ++ ) { char amatch = match . charat ( i ) ; if ( c == amatch ) { return bool_ ; } } return bool_ ; }	Match if one character equals to any of the given character.
public static int findfirstequal ( final charsequence source , final int index , final charsequence match ) { for ( int i = index ; i < source . length ( ) ; i ++ ) { if ( equalsone ( source . charat ( i ) , match ) ) { return i ; } } return - num_ ; }	Finds index of the first character in given charsequence the matches any from thegiven set of characters.
public static int findfirstequal ( final char [ ] source , final int index , final char match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( source [ i ] == match ) { return i ; } } return - num_ ; }	Finds index of the first character in given array the matches any from thegiven set of characters.
public commandline args ( final string ... arguments ) { if ( arguments != null && arguments . length > num_ ) { collections . addall ( cmdline , arguments ) ; } return this ; }	Adds several arguments.
public commandline env ( final string key , final string value ) { if ( env == null ) { env = new hashmap < > ( ) ; } env . put ( key , value ) ; return this ; }	Sets environment variable.
public processrunner . processresult run ( ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; out = err = baos ; try { baos . write ( stringutil . join ( cmdline , str_ ) . getbytes ( ) ) ; baos . write ( stringpool . bytes_new_line ) ; } catch ( ioexception ignore ) { } processbuilder processbuilder = new processbuilder ( ) ; processbuilder . command ( cmdline ) ; if ( cleanenvironment ) { processbuilder . environment ( ) . clear ( ) ; } if ( env != null ) { processbuilder . environment ( ) . putall ( env ) ; } processbuilder . directory ( workingdirectory ) ; process process = null ; try { process = processbuilder . start ( ) ; } catch ( ioexception ioex ) { return writeexception ( baos , ioex ) ; } streamgobbler outputgobbler = new streamgobbler ( process . getinputstream ( ) , out , outprefix ) ; streamgobbler errorgobbler = new streamgobbler ( process . geterrorstream ( ) , err , errprefix ) ; outputgobbler . start ( ) ; errorgobbler . start ( ) ; int result ; try { result = process . waitfor ( ) ; } catch ( interruptedexception iex ) { return writeexception ( baos , iex ) ; } outputgobbler . waitfor ( ) ; errorgobbler . waitfor ( ) ; return new processrunner . processresult ( result , baos . tostring ( ) ) ; }	Runs command and returns process result.
public static void invoke ( final object listener , final class listenertype ) { if ( listenertype == init . class ) { ( ( init ) listener ) . init ( ) ; return ; } if ( listenertype == start . class ) { ( ( start ) listener ) . start ( ) ; return ; } if ( listenertype == ready . class ) { ( ( ready ) listener ) . ready ( ) ; return ; } if ( listenertype == stop . class ) { ( ( stop ) listener ) . stop ( ) ; return ; } throw new madvocexception ( str_ ) ; }	Invoke the listener based on type.Not very OOP, but works.
final void copyfrom ( final frame frame ) { inputlocals = frame . inputlocals ; inputstack = frame . inputstack ; outputstackstart = num_ ; outputlocals = frame . outputlocals ; outputstack = frame . outputstack ; outputstacktop = frame . outputstacktop ; initializationcount = frame . initializationcount ; initializations = frame . initializations ; }	Sets this frame to the value of the given frame.
private static int getabstracttypefromdescriptor ( final symboltable symboltable , final string buffer , final int offset ) { string internalname ; switch ( buffer . charat ( offset ) ) { case str_ : return num_ ; case str_ : case str_ : case str_ : case str_ : case str_ : return integer ; case str_ : return float ; case str_ : return long ; case str_ : return double ; case str_ : internalname = buffer . substring ( offset + num_ , buffer . length ( ) - num_ ) ; return reference_kind | symboltable . addtype ( internalname ) ; case str_ : int elementdescriptoroffset = offset + num_ ; while ( buffer . charat ( elementdescriptoroffset ) == str_ ) { ++ elementdescriptoroffset ; } int typevalue ; switch ( buffer . charat ( elementdescriptoroffset ) ) { case str_ : typevalue = boolean ; break ; case str_ : typevalue = char ; break ; case str_ : typevalue = byte ; break ; case str_ : typevalue = short ; break ; case str_ : typevalue = integer ; break ; case str_ : typevalue = float ; break ; case str_ : typevalue = long ; break ; case str_ : typevalue = double ; break ; case str_ : internalname = buffer . substring ( elementdescriptoroffset + num_ , buffer . length ( ) - num_ ) ; typevalue = reference_kind | symboltable . addtype ( internalname ) ; break ; default : throw new illegalargumentexception ( ) ; } return ( ( elementdescriptoroffset - offset ) << dim_shift ) | typevalue ; default : throw new illegalargumentexception ( ) ; } }	Returns the abstract type corresponding to the given type descriptor.
final void setinputframefromapiformat ( final symboltable symboltable , final int numlocal , final object [ ] local , final int numstack , final object [ ] stack ) { int inputlocalindex = num_ ; for ( int i = num_ ; i < numlocal ; ++ i ) { inputlocals [ inputlocalindex ++ ] = getabstracttypefromapiformat ( symboltable , local [ i ] ) ; if ( local [ i ] == opcodes . long || local [ i ] == opcodes . double ) { inputlocals [ inputlocalindex ++ ] = top ; } } while ( inputlocalindex < inputlocals . length ) { inputlocals [ inputlocalindex ++ ] = top ; } int numstacktop = num_ ; for ( int i = num_ ; i < numstack ; ++ i ) { if ( stack [ i ] == opcodes . long || stack [ i ] == opcodes . double ) { ++ numstacktop ; } } inputstack = new int [ numstack + numstacktop ] ; int inputstackindex = num_ ; for ( int i = num_ ; i < numstack ; ++ i ) { inputstack [ inputstackindex ++ ] = getabstracttypefromapiformat ( symboltable , stack [ i ] ) ; if ( stack [ i ] == opcodes . long || stack [ i ] == opcodes . double ) { inputstack [ inputstackindex ++ ] = top ; } } outputstacktop = num_ ; initializationcount = num_ ; }	Sets the input frame from the given public API frame description.
private int getlocal ( final int localindex ) { if ( outputlocals == null || localindex >= outputlocals . length ) {	Returns the abstract type stored at the given local variable index in the output frame.
private void setlocal ( final int localindex , final int abstracttype ) {	Replaces the abstract type stored at the given local variable index in the output frame.
private void push ( final int abstracttype ) {	Pushes the given abstract type on the output frame stack.
private void push ( final symboltable symboltable , final string descriptor ) { int typedescriptoroffset = descriptor . charat ( num_ ) == str_ ? descriptor . indexof ( str_ ) + num_ : num_ ; int abstracttype = getabstracttypefromdescriptor ( symboltable , descriptor , typedescriptoroffset ) ; if ( abstracttype != num_ ) { push ( abstracttype ) ; if ( abstracttype == long || abstracttype == double ) { push ( top ) ; } } }	Pushes the abstract type corresponding to the given descriptor on the output frame stack.
private void pop ( final int elements ) { if ( outputstacktop >= elements ) { outputstacktop -= elements ; } else {	Pops the given number of abstract types from the output frame stack.
private void pop ( final string descriptor ) { char firstdescriptorchar = descriptor . charat ( num_ ) ; if ( firstdescriptorchar == str_ ) { pop ( ( type . getargumentsandreturnsizes ( descriptor ) > > num_ ) - num_ ) ; } else if ( firstdescriptorchar == str_ || firstdescriptorchar == str_ ) { pop ( num_ ) ; } else { pop ( num_ ) ; } }	Pops as many abstract types from the output frame stack as described by the given descriptor.
private void addinitializedtype ( final int abstracttype ) {	Adds an abstract type to the list of types on which a constructor is invoked in the basicblock.
private int getinitializedtype ( final symboltable symboltable , final int abstracttype ) { if ( abstracttype == uninitialized_this || ( abstracttype & ( dim_mask | kind_mask ) ) == uninitialized_kind ) { for ( int i = num_ ; i < initializationcount ; ++ i ) { int initializedtype = initializations [ i ] ; int dim = initializedtype & dim_mask ; int kind = initializedtype & kind_mask ; int value = initializedtype & value_mask ; if ( kind == local_kind ) { initializedtype = dim + inputlocals [ value ] ; } else if ( kind == stack_kind ) { initializedtype = dim + inputstack [ inputstack . length - value ] ; } if ( abstracttype == initializedtype ) { if ( abstracttype == uninitialized_this ) { return reference_kind | symboltable . addtype ( symboltable . getclassname ( ) ) ; } else { return reference_kind | symboltable . addtype ( symboltable . gettype ( abstracttype & value_mask ) . value ) ; } } } } return abstracttype ; }	Returns the "initialized" abstract type corresponding to the given abstract type.
static void putabstracttype ( final symboltable symboltable , final int abstracttype , final bytevector output ) { int arraydimensions = ( abstracttype & frame . dim_mask ) > > dim_shift ; if ( arraydimensions == num_ ) { int typevalue = abstracttype & value_mask ; switch ( abstracttype & kind_mask ) { case constant_kind : output . putbyte ( typevalue ) ; break ; case reference_kind : output . putbyte ( item_object ) . putshort ( symboltable . addconstantclass ( symboltable . gettype ( typevalue ) . value ) . index ) ; break ; case uninitialized_kind : output . putbyte ( item_uninitialized ) . putshort ( ( int ) symboltable . gettype ( typevalue ) . data ) ; break ; default : throw new assertionerror ( ) ; } } else {	Put the given abstract type in the given ByteVector, using the JVMS verification_type_infoformat used in StackMapTable attributes.
@ override protected int prunecache ( ) { int count = num_ ; iterator < cacheobject < k , v > > values = cachemap . values ( ) . iterator ( ) ; while ( values . hasnext ( ) ) { cacheobject co = values . next ( ) ; if ( co . isexpired ( ) ) { values . remove ( ) ; count ++ ; } } return count ; }	Prunes expired elements from the cache.
public modulevisitor visitmodule ( final string name , final int access , final string version ) { if ( api < opcodes . asm6 ) { throw new unsupportedoperationexception ( str_ ) ; } if ( cv != null ) { return cv . visitmodule ( name , access , version ) ; } return null ; }	Visit the module corresponding to the class.
public void visitouterclass ( final string owner , final string name , final string descriptor ) { if ( cv != null ) { cv . visitouterclass ( owner , name , descriptor ) ; } }	Visits the enclosing class of the class.
public annotationvisitor visitannotation ( final string descriptor , final boolean visible ) { if ( cv != null ) { return cv . visitannotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of the class.
public static dbthreadsession getthreadsession ( ) { dbthreadsession session = ( dbthreadsession ) threaddbsessionholder . get ( ) ; if ( session == null ) { session = new dbthreadsession ( ) ; } return session ; }	Returns existing thread session, or new one if already not exist.
public static void closethreadsession ( ) { dbthreadsession session = ( dbthreadsession ) threaddbsessionholder . get ( ) ; if ( session != null ) { session . closesession ( ) ; } }	Closes thread session.
protected actionwrapper [ ] createexecutionarray ( ) { int totalinterceptors = ( this . actionruntime . getinterceptors ( ) != null ? this . actionruntime . getinterceptors ( ) . length : num_ ) ; int totalfilters = ( this . actionruntime . getfilters ( ) != null ? this . actionruntime . getfilters ( ) . length : num_ ) ; actionwrapper [ ] executionarray = new actionwrapper [ totalfilters + num_ + totalinterceptors + num_ ] ;	Creates execution array that will invoke all filters, actions and resultsin correct order.
protected object invokeactionmethod ( ) throws exception { if ( actionruntime . isactionhandlerdefined ( ) ) { actionruntime . getactionhandler ( ) . handle ( this ) ; return null ; } final object [ ] params = targets . extractparametersvalues ( ) ; try { return actionruntime . getactionclassmethod ( ) . invoke ( action , params ) ; } catch ( invocationtargetexception itex ) { throw wraptoexception ( unwrapthrowable ( itex ) ) ; } }	Invokes action method after starting all interceptors.After method invocation, all interceptors will finish, in opposite order.
public string readrequestbody ( ) { if ( requestbody == null ) { try { requestbody = servletutil . readrequestbodyfromstream ( gethttpservletrequest ( ) ) ; } catch ( ioexception ioex ) { requestbody = stringpool . empty ; } } return requestbody ; }	Reads request body only once and returns it to user.
public static int calcfirstitemindexofpage ( int page , final int pagesize , final int total ) { if ( total == num_ ) { return num_ ; } if ( page < num_ ) { page = num_ ; } int first = ( page - num_ ) * pagesize ; if ( first >= total ) { first = ( ( total - num_ ) / pagesize ) * pagesize ;	Calculates the first item index of requested page.
public static int calcfirstitemindexofpage ( final pagerequest pagerequest , final int total ) { return calcfirstitemindexofpage ( pagerequest . getpage ( ) , pagerequest . getsize ( ) , total ) ; }	Calculates first item index of the page.
public boolean match ( final int value ) { if ( a == num_ ) { return value == b ; } if ( a > num_ ) { if ( value < b ) { return bool_ ; } return ( value - b ) % a == num_ ; } if ( value > b ) { return bool_ ; } return ( b - value ) % ( - a ) == num_ ; }	Matches expression with the value.
public static byte [ ] torawbytearray ( final char [ ] carr ) { byte [ ] barr = new byte [ carr . length << num_ ] ; for ( int i = num_ , bpos = num_ ; i < carr . length ; i ++ ) { char c = carr [ i ] ; barr [ bpos ++ ] = ( byte ) ( ( c & num_ ) > > num_ ) ; barr [ bpos ++ ] = ( byte ) ( c & num_ ) ; } return barr ; }	Converts char array into byte array by replacing each character with two bytes.
public static int findfirstdiff ( final char [ ] source , final int index , final char [ ] match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( ! equalsone ( source [ i ] , match ) ) { return i ; } } return - num_ ; }	Finds index of the first character in given array the differs from thegiven set of characters.
protected string resolvenodename ( final node node ) { switch ( tagcase ) { case default : return node . getnodename ( ) ; case raw : return node . getnoderawname ( ) ; case lowercase : return node . getnoderawname ( ) . tolowercase ( ) ; case uppercase : return node . getnoderawname ( ) . touppercase ( ) ; } return null ; }	Renders node name.
protected string resolveattributename ( final node node , final attribute attribute ) { switch ( attributecase ) { case default : return attribute . getname ( ) ; case raw : return attribute . getrawname ( ) ; case lowercase : return attribute . getrawname ( ) . tolowercase ( ) ; case uppercase : return attribute . getrawname ( ) . touppercase ( ) ; } return null ; }	Renders attribute name.
public props load ( final file file ) throws ioexception { final string extension = filenameutil . getextension ( file . getabsolutepath ( ) ) ; final string data ; if ( extension . equalsignorecase ( str_ ) ) { data = fileutil . readstring ( file , stringpool . iso_8859_1 ) ; } else { data = fileutil . readstring ( file ) ; } parse ( data ) ; return this ; }	Loads props from the file.
public props load ( final file file , final string encoding ) throws ioexception { parse ( fileutil . readstring ( file , encoding ) ) ; return this ; }	Loads properties from the file in provided encoding.
public props load ( final inputstream in ) throws ioexception { final writer out = new fastchararraywriter ( ) ; streamutil . copy ( in , out ) ; parse ( out . tostring ( ) ) ; return this ; }	Loads properties from input stream.
public props load ( final map < ? , ? > p ) { for ( final map . entry < ? , ? > entry : p . entryset ( ) ) { final string name = entry . getkey ( ) . tostring ( ) ; final object value = entry . getvalue ( ) ; if ( value == null ) { continue ; } data . putbaseproperty ( name , value . tostring ( ) , bool_ ) ; } return this ; }	Loads base properties from the provided java properties.Null values are ignored.
@ suppresswarnings ( str_ ) public props load ( final map < ? , ? > map , final string prefix ) { string realprefix = prefix ; realprefix += str_ ; for ( final map . entry entry : map . entryset ( ) ) { final string name = entry . getkey ( ) . tostring ( ) ; final object value = entry . getvalue ( ) ; if ( value == null ) { continue ; } data . putbaseproperty ( realprefix + name , value . tostring ( ) , bool_ ) ; } return this ; }	Loads base properties from java Map using provided prefix.Null values are ignored.
public props loadfromclasspath ( final string ... patterns ) { classscanner . create ( ) . registerentryconsumer ( entrydata -> { string usedencoding = joddcore . encoding ; if ( stringutil . endswithignorecase ( entrydata . name ( ) , str_ ) ) { usedencoding = stringpool . iso_8859_1 ; } final string encoding = usedencoding ; uncheckedexception . runandwrapexception ( ( ) -> load ( entrydata . openinputstream ( ) , encoding ) ) ; } ) . includeresources ( bool_ ) . ignoreexception ( bool_ ) . excludecommonjars ( ) . excludeallentries ( bool_ ) . includeentries ( patterns ) . scandefaultclasspath ( ) . start ( ) ; return this ; }	Loads props and properties from the classpath.
public string getvalueordefault ( final string key , final string defaultvalue ) { initialize ( ) ; final string value = data . lookupvalue ( key , activeprofiles ) ; if ( value == null ) { return defaultvalue ; } return value ; }	Returns value of property, using active profiles or default value if not found.
public void setvalue ( final string key , final string value , final string profile ) { if ( profile == null ) { data . putbaseproperty ( key , value , bool_ ) ; } else { data . putprofileproperty ( key , value , profile , bool_ ) ; } initialized = bool_ ; }	Sets value on some profile.
public void extractprops ( final map target ) { initialize ( ) ; data . extract ( target , activeprofiles , null , null ) ; }	Extracts props belonging to active profiles.
public void extractprops ( final map target , final string ... profiles ) { initialize ( ) ; data . extract ( target , profiles , null , null ) ; }	Extract props of given profiles.
public void extractsubprops ( final map target , final string ... wildcardpatterns ) { initialize ( ) ; data . extract ( target , activeprofiles , wildcardpatterns , null ) ; }	Extracts subset of properties that matches given wildcards.
@ suppresswarnings ( str_ ) public map < string , object > innermap ( final string prefix ) { initialize ( ) ; return data . extract ( null , activeprofiles , null , prefix ) ; }	Returns inner map from the props with given prefix.
public void addinnermap ( string prefix , final map < ? , ? > map , final string profile ) { if ( ! stringutil . endswithchar ( prefix , str_ ) ) { prefix += stringpool . dot ; } for ( map . entry < ? , ? > entry : map . entryset ( ) ) { string key = entry . getkey ( ) . tostring ( ) ; key = prefix + key ; setvalue ( key , entry . getvalue ( ) . tostring ( ) , profile ) ; } }	Adds child map to the props on given prefix.
protected void resolveactiveprofiles ( ) { if ( activeprofilesprop == null ) { activeprofiles = null ; return ; } final propsentry pv = data . getbaseproperty ( activeprofilesprop ) ; if ( pv == null ) {	Resolves active profiles from special property.This property can be only a base property!If default active property is not defined, nothing happens.Otherwise, it will replace currently active profiles.
public string [ ] getallprofiles ( ) { string [ ] profiles = new string [ data . profileproperties . size ( ) ] ; int index = num_ ; for ( string profilename : data . profileproperties . keyset ( ) ) { profiles [ index ] = profilename ; index ++ ; } return profiles ; }	Returns all profiles names.
public string [ ] getprofilesfor ( final string propkeynamewildcard ) { hashset < string > profiles = new hashset < > ( ) ; profile : for ( map . entry < string , map < string , propsentry > > entries : data . profileproperties . entryset ( ) ) { string profilename = entries . getkey ( ) ; map < string , propsentry > value = entries . getvalue ( ) ; for ( string propkeyname : value . keyset ( ) ) { if ( wildcard . equalsormatch ( propkeyname , propkeynamewildcard ) ) { profiles . add ( profilename ) ; continue profile ; } } } return profiles . toarray ( new string [ num_ ] ) ; }	Returns all the profiles that define certain prop's key name.Key name is given as a wildcard, or it can be matched fully.
protected void addpropertyinjectionpoint ( final propertyinjectionpoint pip ) { if ( properties == null ) { properties = new propertyinjectionpoint [ num_ ] ; properties [ num_ ] = pip ; } else { properties = arraysutil . append ( properties , pip ) ; } }	Adds property injection point.
protected void addsetinjectionpoint ( final setinjectionpoint sip ) { if ( sets == null ) { sets = new setinjectionpoint [ num_ ] ; sets [ num_ ] = sip ; } else { sets = arraysutil . append ( sets , sip ) ; } }	Adds set injection point.
protected void addmethodinjectionpoint ( final methodinjectionpoint mip ) { if ( methods == null ) { methods = new methodinjectionpoint [ num_ ] ; methods [ num_ ] = mip ; } else { methods = arraysutil . append ( methods , mip ) ; } }	Adds method injection point.
protected void addinitmethodpoints ( final initmethodpoint [ ] methods ) { if ( initmethods == null ) { initmethods = methods ; } else { initmethods = arraysutil . join ( initmethods , methods ) ; } }	Adds init methods.
protected void adddestroymethodpoints ( final destroymethodpoint [ ] methods ) { if ( destroymethods == null ) { destroymethods = methods ; } else { destroymethods = arraysutil . join ( destroymethods , methods ) ; } }	Adds destroy methods.
public static class resolvetargetclass ( final class proxy ) { final string name = proxy . getname ( ) ; if ( name . endswith ( proxettanames . proxyclassnamesuffix ) ) { return proxy . getsuperclass ( ) ; } if ( name . endswith ( proxettanames . wrapperclassnamesuffix ) ) { return gettargetwrappertype ( proxy ) ; } return proxy ; }	Returns target class if proxetta applied on given class.If not, returns given class as result.
public static void injecttargetintowrapper ( final object target , final object wrapper ) { injecttargetintowrapper ( target , wrapper , proxettanames . wrappertargetfieldname ) ; }	Injects target instance into proxy using default target field name.
public static class gettargetwrappertype ( final class wrapperclass ) { try { final field field = wrapperclass . getdeclaredfield ( proxettanames . wrappertargetfieldname ) ; return field . gettype ( ) ; } catch ( nosuchfieldexception nsfex ) { throw new proxettaexception ( nsfex ) ; } }	Returns wrapper target type.
protected fielddescriptor findfield ( final string fieldname ) { fielddescriptor fielddescriptor = classdescriptor . getfielddescriptor ( fieldname , bool_ ) ; if ( fielddescriptor != null ) { return fielddescriptor ; }	Locates property field. Field is being searched also in allsuperclasses of current class.
public class gettype ( ) { if ( type == null ) { if ( fielddescriptor != null ) { type = fielddescriptor . getrawtype ( ) ; } else if ( readmethoddescriptor != null ) { type = getgetter ( bool_ ) . getgetterrawtype ( ) ;	Returns property type. Raw types are detected.
public class resolvekeytype ( final boolean declared ) { class keytype = null ; getter getter = getgetter ( declared ) ; if ( getter != null ) { keytype = getter . getgetterrawkeycomponenttype ( ) ; } if ( keytype == null ) { fielddescriptor fielddescriptor = getfielddescriptor ( ) ; if ( fielddescriptor != null ) { keytype = fielddescriptor . getrawkeycomponenttype ( ) ; } } return keytype ; }	Resolves key type for given property descriptor.
public class resolvecomponenttype ( final boolean declared ) { class componenttype = null ; getter getter = getgetter ( declared ) ; if ( getter != null ) { componenttype = getter . getgetterrawcomponenttype ( ) ; } if ( componenttype == null ) { fielddescriptor fielddescriptor = getfielddescriptor ( ) ; if ( fielddescriptor != null ) { componenttype = fielddescriptor . getrawcomponenttype ( ) ; } } return componenttype ; }	Resolves component type for given property descriptor.
public static jsonresult of ( final object object ) { final string json = jsonserializer . create ( ) . deep ( bool_ ) . serialize ( object ) ; return new jsonresult ( json ) ; }	Creates JSON result from given object.
public static jsonresult of ( final exception exception ) { final hashmap < string , object > errormap = new hashmap < > ( ) ; errormap . put ( str_ , exceptionutil . message ( exception ) ) ; errormap . put ( str_ , exception . getclass ( ) . getname ( ) ) ; errormap . put ( str_ , exception . getcause ( ) != null ? exception . getcause ( ) . getclass ( ) . getname ( ) : null ) ; final arraylist < string > details = new arraylist < > ( ) ; final stacktraceelement [ ] ste = exceptionutil . getstacktrace ( exception , null , null ) ; for ( stacktraceelement stacktraceelement : ste ) { details . add ( stacktraceelement . tostring ( ) ) ; } errormap . put ( str_ , details ) ; final string json = jsonserializer . create ( ) . deep ( bool_ ) . serialize ( errormap ) ; return new jsonresult ( json ) . status ( httpstatus . error500 ( ) . internalerror ( ) ) ; }	Creates a JSON response from an exception.
protected string resolvehttpmethodfrommethodname ( final string methodname ) { int i = num_ ; while ( i < methodname . length ( ) ) { if ( charutil . isuppercasealpha ( methodname . charat ( i ) ) ) { break ; } i ++ ; } final string name = methodname . substring ( num_ , i ) . touppercase ( ) ; for ( final httpmethod httpmethod : httpmethod . values ( ) ) { if ( httpmethod . equalsname ( name ) ) { return httpmethod . name ( ) ; } } return null ; }	Resolves HTTP method name from method name.If method name or first camel-case word of a method equals toa HTTP method, it will be used as that HTTP methods.
private static boolean match ( final charsequence string , final charsequence pattern , int sndx , int pndx ) { int plen = pattern . length ( ) ; if ( plen == num_ ) { if ( pattern . charat ( num_ ) == str_ ) {	Internal matching recursive function.
protected loading resolveloading ( final boolean parentfirststrategy , final string classname ) { boolean withparent = bool_ ; boolean withloader = bool_ ; if ( parentfirststrategy ) { if ( ismatchingrules ( classname , loaderonlyrules ) ) { withparent = bool_ ; } else if ( ismatchingrules ( classname , parentonlyrules ) ) { withloader = bool_ ; } } else { if ( ismatchingrules ( classname , parentonlyrules ) ) { withloader = bool_ ; } else if ( ismatchingrules ( classname , loaderonlyrules ) ) { withparent = bool_ ; } } return new loading ( withparent , withloader ) ; }	Resolves loading rules.
@ override protected synchronized class < ? > loadclass ( final string classname , final boolean resolve ) throws classnotfoundexception {	Loads class using parent-first or parent-last strategy.
@ override public url getresource ( final string resourcename ) { url url = null ; loading loading = resolveresourceloading ( parentfirst , resourcename ) ; if ( parentfirst ) {	Returns a resource using parent-first or parent-last strategy.
public void waitfor ( ) { try { synchronized ( lock ) { if ( ! end ) { lock . wait ( ) ; } } } catch ( interruptedexception ignore ) { thread . currentthread ( ) . interrupt ( ) ; } }	Waits for gobbler to end.
public class < ? extends annotation > detectannotationtype ( final annotation [ ] annotations ) { for ( final annotation annotation : annotations ) { if ( annotation instanceof in ) { return annotation . annotationtype ( ) ; } else if ( annotation instanceof out ) { return annotation . annotationtype ( ) ; } } return null ; }	Scans annotation and returns type of Madvoc annotations.
protected injectionpoint buildinjectionpoint ( final string annotationvalue , final string propertyname , final class propertytype , final class < ? extends madvocscope > scope ) { final string value = annotationvalue . trim ( ) ; final string name , targetname ; if ( stringutil . isnotblank ( value ) ) { name = value ; targetname = propertyname ; } else { name = propertyname ; targetname = null ; } return new injectionpoint ( propertytype , name , targetname , scoperesolver . defaultorscopetype ( scope ) ) ; }	Builds injection point.
public void visit ( ) { classdescriptor classdescriptor = classintrospector . get ( ) . lookup ( type ) ; if ( classmetadataname != null ) {	Visits a type.
public static url [ ] of ( classloader classloader , class clazz ) { if ( clazz == null ) { clazz = classpathurls . class ; } if ( classloader == null ) { classloader = clazz . getclassloader ( ) ; } final set < url > urls = new linkedhashset < > ( ) ; while ( classloader != null ) { if ( classloader instanceof urlclassloader ) { final urlclassloader urlclassloader = ( urlclassloader ) classloader ; return urlclassloader . geturls ( ) ; } final url url = classmoduleurl ( classloader , clazz ) ; if ( url != null ) { urls . add ( url ) ; } classloader = classloader . getparent ( ) ; } return urls . toarray ( new url [ num_ ] ) ; }	Returns urls for the classloader.
private void setbean ( final object bean ) { this . bean = bean ; this . cd = ( bean == null ? null : introspector . lookup ( bean . getclass ( ) ) ) ; this . first = bool_ ; this . updateproperty = bool_ ; }	Sets new bean instance.
public void updatebean ( final object bean ) { this . setbean ( bean ) ; if ( this . cd != null && this . cd . issupplier ( ) ) { final object newbean = ( ( supplier ) this . bean ) . get ( ) ; setbean ( newbean ) ; } }	Updates the bean. Detects special case of suppliers.
private void loadpropertydescriptor ( ) { if ( updateproperty ) { if ( cd == null ) { propertydescriptor = null ; } else { propertydescriptor = cd . getpropertydescriptor ( name , bool_ ) ; } updateproperty = bool_ ; } }	Loads property descriptor, if property was updated.
public dboom connect ( ) { connectionprovider . init ( ) ; final dbdetector dbdetector = new dbdetector ( ) ; dbdetector . detectdatabaseandconfiguredboom ( connectionprovider , dboomconfig ) ; return this ; }	Initializes the DbOom by connecting to the database.
public void add ( final iterator < t > iterator ) { if ( alliterators . contains ( iterator ) ) { throw new illegalargumentexception ( str_ ) ; } alliterators . add ( iterator ) ; }	Adds an iterator to this composite.
private void printlogo ( ) { system . out . println ( chalk256 . chalk ( ) . yellow ( ) . on ( jodd . jodd ) ) ; }	Prints a logo.
public void stop ( ) { joyprops . stop ( ) ; try { joydb . stop ( ) ; joypetite . stop ( ) ; } catch ( exception ignore ) { } if ( log != null ) { log . info ( str_ ) ; } }	Stops the Joy.
protected socket createsocket ( final string host , final int port , final int connectiontimeout ) throws ioexception { final socketfactory socketfactory = getsocketfactory ( proxy , bool_ , bool_ , connectiontimeout ) ; if ( connectiontimeout < num_ ) { return socketfactory . createsocket ( host , port ) ; } else {	Creates a socket using socket factory.
protected sslsocket createsslsocket ( final string host , final int port , final int connectiontimeout , final boolean trustall , final boolean verifyhttpshost ) throws ioexception { final socketfactory socketfactory = getsocketfactory ( proxy , bool_ , trustall , connectiontimeout ) ; final socket socket ; if ( connectiontimeout < num_ ) { socket = socketfactory . createsocket ( host , port ) ; } else {	Creates a SSL socket.
protected sslsocketfactory getdefaultsslsocketfactory ( final boolean trustallcertificates ) throws ioexception { if ( trustallcertificates ) { try { sslcontext sc = sslcontext . getinstance ( sslprotocol ) ; sc . init ( null , trustmanagers . trust_all_certs , new java . security . securerandom ( ) ) ; return sc . getsocketfactory ( ) ; } catch ( nosuchalgorithmexception | keymanagementexception e ) { throw new ioexception ( e ) ; } } else { return ( sslsocketfactory ) sslsocketfactory . getdefault ( ) ; } }	Returns default SSL socket factory allowing setting trust managers.
protected socketfactory getsocketfactory ( final proxyinfo proxy , final boolean ssl , final boolean trustallcertificates , final int connectiontimeout ) throws ioexception { switch ( proxy . getproxytype ( ) ) { case none : if ( ssl ) { return getdefaultsslsocketfactory ( trustallcertificates ) ; } else { return socketfactory . getdefault ( ) ; } case http : return new httpproxysocketfactory ( proxy , connectiontimeout ) ; case socks4 : return new socks4proxysocketfactory ( proxy , connectiontimeout ) ; case socks5 : return new socks5proxysocketfactory ( proxy , connectiontimeout ) ; default : return null ; } }	Returns socket factory based on proxy type and SSL requirements.
public string random ( int count , final char [ ] chars ) { if ( count == num_ ) { return stringpool . empty ; } final char [ ] result = new char [ count ] ; while ( count -- > num_ ) { result [ count ] = chars [ rnd . nextint ( chars . length ) ] ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the set of characters specified.
public string random ( int count , final char start , final char end ) { if ( count == num_ ) { return stringpool . empty ; } final char [ ] result = new char [ count ] ; final int len = end - start + num_ ; while ( count -- > num_ ) { result [ count ] = ( char ) ( rnd . nextint ( len ) + start ) ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the provided range.
public string randomranges ( int count , final char ... ranges ) { if ( count == num_ ) { return stringpool . empty ; } int i = num_ ; int len = num_ ; final int [ ] lens = new int [ ranges . length ] ; while ( i < ranges . length ) { int gap = ranges [ i + num_ ] - ranges [ i ] + num_ ; len += gap ; lens [ i ] = len ; i += num_ ; } final char [ ] result = new char [ count ] ; while ( count -- > num_ ) { char c = num_ ; int r = rnd . nextint ( len ) ; for ( i = num_ ; i < ranges . length ; i += num_ ) { if ( r < lens [ i ] ) { r += ranges [ i ] ; if ( i != num_ ) { r -= lens [ i - num_ ] ; } c = ( char ) r ; break ; } } result [ count ] = c ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the multiple sets defined by range pairs.All ranges must be in acceding order.
@ suppresswarnings ( str_ ) protected collection < object > newarrayinstance ( final class targettype ) { if ( targettype == null || targettype == list . class || targettype == collection . class || targettype . isarray ( ) ) { return listsupplier . get ( ) ; } if ( targettype == set . class ) { return new hashset < > ( ) ; } try { return ( collection < object > ) targettype . getdeclaredconstructor ( ) . newinstance ( ) ; } catch ( exception e ) { throw new jsonexception ( e ) ; } }	Creates new type for JSON array objects.It returns a collection.Later, the collection will be converted into the target type.
protected void injectvalueintoobject ( final object target , final propertydescriptor pd , final object value ) { object convertedvalue = value ; if ( value != null ) { class targetclass = pd . gettype ( ) ; convertedvalue = converttype ( value , targetclass ) ; } try { setter setter = pd . getsetter ( bool_ ) ; if ( setter != null ) { setter . invokesetter ( target , convertedvalue ) ; } } catch ( exception ex ) { throw new jsonexception ( ex ) ; } }	Injects value into the targets property.
protected object converttype ( final object value , final class targettype ) { final class valueclass = value . getclass ( ) ; if ( valueclass == targettype ) { return value ; } try { return typeconvertermanager . get ( ) . converttype ( value , targettype ) ; } catch ( exception ex ) { if ( ! stricttypes ) { return null ; } throw new jsonexception ( str_ , ex ) ; } }	Converts type of the given value.
public void visitprovide ( final string service , final string ... providers ) { if ( mv != null ) { mv . visitprovide ( service , providers ) ; } }	Visit an implementation of a service.
@ suppresswarnings ( str_ ) public static < a > typecache < a > createdefault ( ) { return ( typecache < a > ) defaults . implementation . get ( ) ; }	Creates default implementation of the type cache.
public t put ( final class < ? > type , final t value ) { return map . put ( type , value ) ; }	Add values to the map.
public methoddescriptor [ ] getallmethoddescriptors ( ) { if ( allmethods == null ) { final list < methoddescriptor > allmethodslist = new arraylist < > ( ) ; for ( methoddescriptor [ ] methoddescriptors : methodsmap . values ( ) ) { collections . addall ( allmethodslist , methoddescriptors ) ; } final methoddescriptor [ ] allmethods = allmethodslist . toarray ( new methoddescriptor [ num_ ] ) ; arrays . sort ( allmethods , comparator . comparing ( md -> md . getmethod ( ) . getname ( ) ) ) ; this . allmethods = allmethods ; } return allmethods ; }	Returns all methods. Cached. Lazy.
public static string resolveipaddress ( final string hostname ) { try { inetaddress netaddress ; if ( hostname == null || hostname . equalsignorecase ( local_host ) ) { netaddress = inetaddress . getlocalhost ( ) ; } else { netaddress = inet4address . getbyname ( hostname ) ; } return netaddress . gethostaddress ( ) ; } catch ( unknownhostexception ignore ) { return null ; } }	Resolves IP address from a hostname.
public static int getipasint ( final string ipaddress ) { int ipintvalue = num_ ; string [ ] tokens = stringutil . splitc ( ipaddress , str_ ) ; for ( string token : tokens ) { if ( ipintvalue > num_ ) { ipintvalue <<= num_ ; } ipintvalue += integer . parseint ( token ) ; } return ipintvalue ; }	Returns IP address as integer.
public static boolean validateagaintipadressv4format ( final string input ) { if ( input == null ) { return bool_ ; } int hitdots = num_ ; char [ ] data = input . tochararray ( ) ; for ( int i = num_ ; i < data . length ; i ++ ) { char c = data [ i ] ; int b = num_ ; do { if ( c < str_ || c > str_ ) { return bool_ ; } b = ( b * num_ + c ) - num_ ; if ( ++ i >= data . length ) { break ; } c = data [ i ] ; } while ( c != str_ ) ; if ( b > num_ ) { return bool_ ; } hitdots ++ ; } return hitdots == num_ ; }	Checks given string against IP address v4 format.
public static string resolvehostname ( final byte [ ] ip ) { try { inetaddress address = inetaddress . getbyaddress ( ip ) ; return address . gethostname ( ) ; } catch ( unknownhostexception ignore ) { return null ; } }	Resolves host name from IP address bytes.
public static byte [ ] downloadbytes ( final string url ) throws ioexception { try ( inputstream inputstream = new url ( url ) . openstream ( ) ) { return streamutil . readbytes ( inputstream ) ; } }	Downloads resource as byte array.
public static string downloadstring ( final string url , final string encoding ) throws ioexception { try ( inputstream inputstream = new url ( url ) . openstream ( ) ) { return new string ( streamutil . readchars ( inputstream , encoding ) ) ; } }	Downloads resource as String.
public static void downloadfile ( final string url , final file file ) throws ioexception { try ( inputstream inputstream = new url ( url ) . openstream ( ) ; readablebytechannel rbc = channels . newchannel ( inputstream ) ; filechannel filechannel = filechannel . open ( file . topath ( ) , standardopenoption . create , standardopenoption . truncate_existing , standardopenoption . write ) ) { filechannel . transferfrom ( rbc , num_ , long . max_value ) ; } }	Downloads resource to a file, potentially very efficiently.
public static socket connect ( final string hostname , final int port ) throws ioexception { final socket socket = new socket ( ) ; socket . connect ( new inetsocketaddress ( hostname , port ) ) ; return socket ; }	Creates a socket.
public static socket connect ( final string hostname , final int port , final int connectiontimeout ) throws ioexception { final socket socket = new socket ( ) ; if ( connectiontimeout <= num_ ) { socket . connect ( new inetsocketaddress ( hostname , port ) ) ; } else { socket . connect ( new inetsocketaddress ( hostname , port ) , connectiontimeout ) ; } return socket ; }	Creates a socket with a timeout.
private static int getprimitiveclassnameindex ( final string classname ) { int dotindex = classname . indexof ( str_ ) ; if ( dotindex != - num_ ) { return - num_ ; } return arrays . binarysearch ( primitive_type_names , classname ) ; }	Detects if provided class name is a primitive type.Returns >= 0 number if so.
@ override public class loadclass ( final string classname , final classloader classloader ) throws classnotfoundexception { string arrayclassname = preparearrayclassnameforloading ( classname ) ; if ( ( classname . indexof ( str_ ) == - num_ ) && ( arrayclassname == null ) ) {	Loads class by name.
protected class loadarrayclassbycomponenttype ( final string classname , final classloader classloader ) throws classnotfoundexception { int ndx = classname . indexof ( str_ ) ; int multi = stringutil . count ( classname , str_ ) ; string componenttypename = classname . substring ( num_ , ndx ) ; class componenttype = loadclass ( componenttypename , classloader ) ; if ( multi == num_ ) { return array . newinstance ( componenttype , num_ ) . getclass ( ) ; } int [ ] multisizes ; if ( multi == num_ ) { multisizes = new int [ ] { num_ , num_ } ; } else if ( multi == num_ ) { multisizes = new int [ ] { num_ , num_ , num_ } ; } else { multisizes = ( int [ ] ) array . newinstance ( int . class , multi ) ; } return array . newinstance ( componenttype , multisizes ) . getclass ( ) ; }	Loads array class using component type.
@ override public void shutdown ( ) { for ( final beandata beandata : instances . values ( ) ) { beandata . calldestroymethods ( ) ; } instances . clear ( ) ; }	Iterate all beans and invokes registered destroy methods.
public static < t extends comparable > binarysearch < t > forarray ( final t [ ] array ) { return new binarysearch < t > ( ) { @ override @ suppresswarnings ( { str_ } ) protected int compare ( final int index , final t element ) { return array [ index ] . compareto ( element ) ; } @ override protected int getlastindex ( ) { return array . length - num_ ; } } ; }	Creates binary search wrapper over an array.
public static < t > binarysearch < t > forarray ( final t [ ] array , final comparator < t > comparator ) { return new binarysearch < t > ( ) { @ override @ suppresswarnings ( { str_ } ) protected int compare ( final int index , final t element ) { return comparator . compare ( array [ index ] , element ) ; } @ override protected int getlastindex ( ) { return array . length - num_ ; } } ; }	Creates binary search wrapper over an array with given comparator.
public t exclude ( final string ... excludes ) { for ( string ex : excludes ) { rules . exclude ( ex ) ; } return _this ( ) ; }	Defines excluded property names.
public t include ( final string ... includes ) { for ( string in : includes ) { rules . include ( in ) ; } return _this ( ) ; }	Defines included property names.
public t includeas ( final class template ) { blacklist = bool_ ; string [ ] properties = getallbeanpropertynames ( template , bool_ ) ; include ( properties ) ; return _this ( ) ; }	Defines included property names as public propertiesof given template class.
public void start ( final int startindex ) { this . tagstartindex = startindex ; this . name = null ; this . idndx = - num_ ; this . attributescount = num_ ; this . taglength = num_ ; this . modified = bool_ ; this . type = tagtype . start ; this . rawtag = bool_ ; }	Starts the tag with the index of first '<'.Resets all tag data.
public < t > void registercomponent ( final string name , final class < t > component , final consumer < t > consumer ) { log . debug ( ( ) -> str_ + name + str_ + component . getname ( ) ) ; madpc . removebean ( name ) ; madpc . registerpetitebean ( component , name , null , null , bool_ , consumer ) ; }	Registers Madvoc component with given name.
protected void resolvecolumndbsqltype ( final connection connection , final dbentitycolumndescriptor dec ) { if ( dec . dbsqltype != sqltype . db_sqltype_unknown ) { return ; } resultset rs = null ; dbentitydescriptor ded = dec . getdbentitydescriptor ( ) ; try { databasemetadata dmd = connection . getmetadata ( ) ; rs = dmd . getcolumns ( null , ded . getschemaname ( ) , ded . gettablename ( ) , dec . getcolumnname ( ) ) ; if ( rs . next ( ) ) { dec . dbsqltype = rs . getint ( str_ ) ; } else { dec . dbsqltype = sqltype . db_sqltype_not_available ; if ( log . iswarnenabled ( ) ) { log . warn ( str_ + ded . tostring ( ) + str_ + dec . getcolumnname ( ) ) ; } } } catch ( sqlexception sex ) { dec . dbsqltype = sqltype . db_sqltype_not_available ; if ( log . iswarnenabled ( ) ) { log . warn ( str_ + ded . tostring ( ) + str_ + dec . getcolumnname ( ) , sex ) ; } } finally { dbutil . close ( rs ) ; } }	Resolves column db sql type and populates it in column descriptor if missing.
protected string preprocesssql ( string sqlstring ) {	Pre-process SQL before using it.
protected resultsetmapper createresultsetmapper ( final resultset resultset ) { final map < string , columndata > columnaliases = sqlgen != null ? sqlgen . getcolumndata ( ) : null ; return new defaultresultsetmapper ( dboom , resultset , columnaliases , cacheentities , this ) ; }	Factory for result sets mapper.
public < t > t findgeneratedkey ( final class < t > type ) { return find ( new class [ ] { type } , bool_ , getgeneratedcolumns ( ) ) ; }	Finds generated key column of given type.
public void populategeneratedkeys ( final object entity ) { final string [ ] generatedcolumns = getgeneratedcolumnnames ( ) ; if ( generatedcolumns == null ) { return ; } dbentitydescriptor ded = dboom . entitymanager ( ) . lookuptype ( entity . getclass ( ) ) ;	Populates entity with generated column values from executed query.
@ override protected < r extends actioninterceptor > r createwrapper ( final class < r > wrapperclass ) { return petitecontainer . createbean ( wrapperclass ) ; }	Acquires interceptor from Petite container.
public q setbean ( final string beanname , final object bean ) { if ( bean == null ) { return _this ( ) ; } init ( ) ; final string beannameprefix = beanname + str_ ; query . foreachnamedparameter ( p -> { final string paramname = p . name ; if ( paramname . startswith ( beannameprefix ) ) { final string propertyname = paramname . substring ( beannameprefix . length ( ) ) ; if ( beanutil . declared . hasrootproperty ( bean , propertyname ) ) { final object value = beanutil . declared . getproperty ( bean , propertyname ) ; setobject ( paramname , value ) ; } } } ) ; return _this ( ) ; }	Sets bean parameters from bean.
public q setmap ( final map parameters ) { if ( parameters == null ) { return _this ( ) ; } init ( ) ; query . foreachnamedparameter ( p -> { final string paramname = p . name ; setobject ( paramname , parameters . get ( paramname ) ) ; } ) ; return _this ( ) ; }	Sets properties from the map.
public q setobjects ( final object ... objects ) { int index = num_ ; for ( final object object : objects ) { setobject ( index ++ , object ) ; } return _this ( ) ; }	Sets an array of objects parameters in given order.
public void insertchunkafter ( final sqlchunk previous ) { sqlchunk next = previous . nextchunk ; previous . nextchunk = this ; this . previouschunk = previous ; if ( next != null ) { next . previouschunk = this ; this . nextchunk = next ; } }	Appends chunk to previous one and maintains the double-linked list of the previous chunk.Current surrounding connections of this chunk will be cut-off.
protected dbentitydescriptor lookuptype ( final class entity ) { final dbentitydescriptor ded = dbentitymanager . lookuptype ( entity ) ; if ( ded == null ) { throw new dbsqlbuilderexception ( str_ + entity . getname ( ) ) ; } return ded ; }	Lookups for entity name and throws an exception if entity type is invalid.
protected dbentitydescriptor findcolumnref ( final string columnref ) { dbentitydescriptor ded = templatedata . findtabledescriptorbycolumnref ( columnref ) ; if ( ded == null ) { throw new dbsqlbuilderexception ( str_ + columnref + str_ ) ; } return ded ; }	Finds a table that contains given column.
protected string resolvetable ( final string tableref , final dbentitydescriptor ded ) { string tablealias = templatedata . gettablealias ( tableref ) ; if ( tablealias != null ) { return tablealias ; } return ded . gettablenameforquery ( ) ; }	Resolves table name or alias that will be used in the query.
protected static class resolveclass ( final object object ) { class type = object . getclass ( ) ; return type == class . class ? ( class ) object : type ; }	Resolves object to a class.
protected void appendmissingspace ( final stringbuilder out ) { int len = out . length ( ) ; if ( len == num_ ) { return ; } len -- ; if ( ! charutil . iswhitespace ( out . charat ( len ) ) ) { out . append ( str_ ) ; } }	Appends missing space if the output doesn't end with whitespace.
public enumeration < string > getfileparameternames ( ) { if ( mreq == null ) { return null ; } return collections . enumeration ( mreq . getfileparameternames ( ) ) ; }	Get an enumeration of the parameter names for uploaded files.
public static boolean include ( final servletrequest request , final servletresponse response , final string page ) throws ioexception , servletexception { requestdispatcher dispatcher = request . getrequestdispatcher ( page ) ; if ( dispatcher != null ) { dispatcher . include ( request , response ) ; return bool_ ; } return bool_ ; }	Include page which path is relative to the current HTTP request.
public static string geturl ( final httpservletrequest request ) { string servletpath = request . getservletpath ( ) ; string query = request . getquerystring ( ) ; if ( ( query != null ) && ( query . length ( ) != num_ ) ) { servletpath += str_ + query ; } return servletpath ; }	Returns url, without context path, convenient for request dispatcher.
public static string getrequesturi ( final httpservletrequest request ) { string result = getincluderequesturi ( request ) ; if ( result == null ) { result = request . getrequesturi ( ) ; } return result ; }	Get current request uri.
public string [ ] resolveparamnames ( final method actionclassmethod ) { methodparameter [ ] methodparameters = paramo . resolveparameters ( actionclassmethod ) ; string [ ] names = new string [ methodparameters . length ] ; for ( int i = num_ ; i < methodparameters . length ; i ++ ) { names [ i ] = methodparameters [ i ] . getname ( ) ; } return names ; }	Returns method parameter names.
@ override public void start ( ) { initlogger ( ) ; log . info ( str_ ) ; petitecontainer = createpetitecontainer ( ) ; if ( externalscache ) { petitecontainer . setexternalscache ( typecache . createdefault ( ) ) ; } log . info ( str_ + iswebapplication ) ; if ( ! iswebapplication ) {	Creates and initializes Petite container.It will be auto-magically configured by scanning the classpath.
@ override public void stop ( ) { if ( log != null ) { log . info ( str_ ) ; } if ( petitecontainer != null ) { petitecontainer . shutdown ( ) ; } petitecontainer = null ; }	Stops Petite container.
public emailfilter subject ( final string subject ) { final searchterm subjectterm = new subjectterm ( subject ) ; concat ( subjectterm ) ; return this ; }	Defines filter for SUBJECT field.
public emailfilter messageid ( final string messageid ) { final searchterm msgidterm = new messageidterm ( messageid ) ; concat ( msgidterm ) ; return this ; }	Defines filter for message id.
public emailfilter from ( final string fromaddress ) { final searchterm fromterm = new fromstringterm ( fromaddress ) ; concat ( fromterm ) ; return this ; }	Defines filter for FROM field.
public emailfilter to ( final string toaddress ) { final searchterm toterm = new recipientstringterm ( recipienttype . to , toaddress ) ; concat ( toterm ) ; return this ; }	Defines filter for TO field.
public emailfilter cc ( final string ccaddress ) { final searchterm toterm = new recipientstringterm ( recipienttype . cc , ccaddress ) ; concat ( toterm ) ; return this ; }	Defines filter for CC field.
public emailfilter bcc ( final string bccaddress ) { final searchterm toterm = new recipientstringterm ( recipienttype . bcc , bccaddress ) ; concat ( toterm ) ; return this ; }	Defines filter for BCC field.
public emailfilter flags ( final flags flags , final boolean value ) { final searchterm flagterm = new flagterm ( flags , value ) ; concat ( flagterm ) ; return this ; }	Defines filter for many flags at once.
public emailfilter flag ( final flag flag , final boolean value ) { final flags flags = new flags ( ) ; flags . add ( flag ) ; return flags ( flags , value ) ; }	Defines filter for single flag.
public emailfilter receiveddate ( final operator operator , final long milliseconds ) { final searchterm term = new receiveddateterm ( operator . value , new date ( milliseconds ) ) ; concat ( term ) ; return this ; }	Defines filter for received date.
public emailfilter sentdate ( final operator operator , final long milliseconds ) { final searchterm term = new sentdateterm ( operator . value , new date ( milliseconds ) ) ; concat ( term ) ; return this ; }	Defines filter for sent date.
public emailfilter size ( final operator comparison , final int size ) { final searchterm term = new sizeterm ( comparison . value , size ) ; concat ( term ) ; return this ; }	Defines filter for message size.
public emailfilter and ( final emailfilter ... emailfilters ) { final searchterm [ ] searchterms = new searchterm [ emailfilters . length ] ; for ( int i = num_ ; i < emailfilters . length ; i ++ ) { searchterms [ i ] = emailfilters [ i ] . searchterm ; } concat ( new andterm ( searchterms ) ) ; return this ; }	Defines AND group of filters.
public emailfilter or ( final emailfilter ... emailfilters ) { final searchterm [ ] searchterms = new searchterm [ emailfilters . length ] ; for ( int i = num_ ; i < emailfilters . length ; i ++ ) { searchterms [ i ] = emailfilters [ i ] . searchterm ; } concat ( new orterm ( searchterms ) ) ; return this ; }	Defines OR group of filters.
public emailfilter not ( final emailfilter emailfilter ) { final searchterm searchterm = new notterm ( emailfilter . searchterm ) ; concat ( searchterm ) ; return this ; }	Appends single filter as NOT.
protected void concat ( searchterm searchterm ) { if ( nextisnot ) { searchterm = new notterm ( searchterm ) ; nextisnot = bool_ ; } if ( operatorand ) { and ( searchterm ) ; } else { or ( searchterm ) ; } }	Concatenates last search term with new one.
public static string encode ( final byte [ ] bytes ) { stringbuilder base32 = new stringbuilder ( ( bytes . length * num_ + num_ ) / num_ ) ; int currbyte , digit , i = num_ ; while ( i < bytes . length ) {	Encode an array of binary bytes into a Base32 string.
protected boolean isgzipeligible ( final httpservletrequest request ) {	Determine if request is eligible for GZipping.
public list < violation > validate ( final object target ) { return validate ( validationcontext . resolvefor ( target . getclass ( ) ) , target ) ; }	Validate object using context from the annotations.
public list < violation > validate ( final validationcontext ctx , final object target , final string targetname ) { for ( map . entry < string , list < check > > entry : ctx . map . entryset ( ) ) { string name = entry . getkey ( ) ; object value = beanutil . declaredsilent . getproperty ( target , name ) ; string valuename = targetname != null ? ( targetname + str_ + name ) : name ;	Performs validation of provided validation context and appends violations.
public void useprofile ( final string profile ) { if ( profile == null ) { return ; } if ( this . enabledprofiles == null ) { this . enabledprofiles = new hashset < > ( ) ; } this . enabledprofiles . add ( profile ) ; }	Enables single profile.
public void useprofiles ( final string ... enabledprofiles ) { if ( enabledprofiles == null ) { return ; } if ( this . enabledprofiles == null ) { this . enabledprofiles = new hashset < > ( ) ; } collections . addall ( this . enabledprofiles , enabledprofiles ) ; }	Enables list of profiles.
protected boolean matchprofiles ( final string [ ] checkprofiles ) {	Determine if any of checks profiles is among enabled profiles.
protected object parserequestbody ( final string body , final class targettype ) { return jsonparser . create ( ) . parse ( body , targettype ) ; }	Parses request body into the target type.
public long tomilliseconds ( ) { double then = ( fraction - jd_1970 . fraction ) * millis_in_day ; then += ( integer - jd_1970 . integer ) * millis_in_day ; then += then > num_ ? num_ : - num_ ; return ( long ) then ; }	Converts to milliseconds.
public juliandate add ( final juliandate jds ) { int i = this . integer + jds . integer ; double f = this . fraction + jds . fraction ; return new juliandate ( i , f ) ; }	Adds a JD to current instance.
public juliandate sub ( final juliandate jds ) { int i = this . integer - jds . integer ; double f = this . fraction - jds . fraction ; return new juliandate ( i , f ) ; }	Subtracts a JD from current instance.
private void set ( final int i , double f ) { integer = i ; int fi = ( int ) f ; f -= fi ; integer += fi ; if ( f < num_ ) { f += num_ ; integer -- ; } this . fraction = f ; }	Sets integer and fractional part with normalization.Normalization means that if double is out of range,values will be correctly fixed.
protected void emitcomment ( final int from , final int to ) { if ( config . enableconditionalcomments ) {	Emits a comment. Also checks for conditional comments!.
protected void _error ( string message ) { if ( config . calculateposition ) { position currentposition = position ( ndx ) ; message = message . concat ( stringpool . space ) . concat ( currentposition . tostring ( ) ) ; } else { message = message . concat ( str_ ) . concat ( integer . tostring ( ndx ) ) . concat ( stringpool . right_sq_bracket ) ; } visitor . error ( message ) ; }	Prepares error message and reports it to the visitor.
public string createhash ( final char [ ] password ) {	Returns a salted PBKDF2 hash of the password.
private static byte [ ] pbkdf2 ( final char [ ] password , final byte [ ] salt , final int iterations , final int bytes ) { pbekeyspec spec = new pbekeyspec ( password , salt , iterations , bytes * num_ ) ; try { secretkeyfactory skf = secretkeyfactory . getinstance ( pbkdf2_algorithm ) ; return skf . generatesecret ( spec ) . getencoded ( ) ; } catch ( nosuchalgorithmexception ignore ) { return null ; } catch ( invalidkeyspecexception e ) { throw new illegalargumentexception ( e ) ; } }	Computes the PBKDF2 hash of a password.
private static byte [ ] fromhex ( final string hex ) { final byte [ ] binary = new byte [ hex . length ( ) / num_ ] ; for ( int i = num_ ; i < binary . length ; i ++ ) { binary [ i ] = ( byte ) integer . parseint ( hex . substring ( num_ * i , num_ * i + num_ ) , num_ ) ; } return binary ; }	Converts a string of hexadecimal characters into a byte array.
public providerdefinition [ ] resolveproviderdefinitions ( final class type , final string name ) { return providerresolver . resolve ( type , name ) ; }	Resolves provider definition defined in a bean.
public emailattachmentbuilder name ( final string name ) { if ( name != null && ! name . trim ( ) . isempty ( ) ) { this . name = name ; } return this ; }	Sets file name.
protected emailattachmentbuilder setcontentidfromnameifmissing ( ) { if ( contentid == null ) { if ( name != null ) { contentid ( filenameutil . getname ( name ) ) ; } else { contentid ( no_name ) ; } } return this ; }	Set content ID if it is missing.
protected string resolvecontenttype ( final string contenttype ) { if ( contenttype != null ) { return contenttype ; } if ( name == null ) { return mimetypes . mime_application_octet_stream ; } final string extension = filenameutil . getextension ( name ) ; return mimetypes . getmimetype ( extension ) ; }	Resolves content type from all data.
private static int parsetype ( final string signature , final int startoffset , final signaturevisitor signaturevisitor ) { int offset = startoffset ;	Parses a JavaTypeSignature and makes the given visitor visit it.
int computeattributessize ( ) { symboltable . addconstantutf8 ( constants . module ) ;	Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by thisModuleWriter.
void putattributes ( final bytevector output ) {	Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriterin the given ByteVector.
public static string decode ( final string source , final string encoding ) { return decode ( source , encoding , bool_ ) ; }	Decodes URL elements. This method may be used for allparts of URL, except for the query parts, since it doesnot decode the '+' character.
public static string decodequery ( final string source , final string encoding ) { return decode ( source , encoding , bool_ ) ; }	Decodes query name or value.
@ override @ suppresswarnings ( str_ ) public void start ( ) { initlogger ( ) ; if ( ! databaseenabled ) { log . info ( str_ ) ; return ; } log . info ( str_ ) ; final petitecontainer petitecontainer = joypetitesupplier . get ( ) . getpetitecontainer ( ) ;	Initializes database. First, creates connection pool.and transaction manager. Then, Jodds DbEntityManager isconfigured. It is also configured automagically, by scanningthe class path for entities.
protected void checkconnectionprovider ( ) { final connection connection = connectionprovider . getconnection ( ) ; try { final databasemetadata databasemetadata = connection . getmetadata ( ) ; string name = databasemetadata . getdatabaseproductname ( ) ; string version = databasemetadata . getdatabaseproductversion ( ) ; if ( log . isinfoenabled ( ) ) { log . info ( str_ + name + str_ + version ) ; } } catch ( sqlexception sex ) { log . error ( str_ , sex ) ; } finally { connectionprovider . closeconnection ( connection ) ; } }	Checks if connection provider can return a connection.
@ override public methodvisitor visitmethod ( final int access , final string name , final string desc , final string signature , final string [ ] exceptions ) {	Stores method signature for target method.
@ override public void visitend ( ) {	Stores signatures for all super public methods not already overridden by target class.All this methods will be accepted for proxyfication.
protected methodsignaturevisitor createmethodsignature ( final int access , final string methodname , final string description , final string signature , final string [ ] exceptions , final string classname , final map < string , string > declaredtypegenerics ) { methodsignaturevisitor v = new methodsignaturevisitor ( methodname , access , classname , description , exceptions , signature , declaredtypegenerics , this ) ; new signaturereader ( signature != null ? signature : description ) . accept ( v ) ; return v ; }	Creates method signature from method name.
public static string tocsvstring ( final object ... elements ) { stringbuilder line = new stringbuilder ( ) ; int last = elements . length - num_ ; for ( int i = num_ ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( field_separator ) ; } continue ; } string field = elements [ i ] . tostring ( ) ;	Parse fields as csv string,.
public static string [ ] tostringarray ( final string line ) { list < string > row = new arraylist < > ( ) ; boolean inquotedfield = bool_ ; int fieldstart = num_ ; final int len = line . length ( ) ; for ( int i = num_ ; i < len ; i ++ ) { char c = line . charat ( i ) ; if ( c == field_separator ) { if ( ! inquotedfield ) {	Converts CSV line to string array.
public ctorinjectionpoint resolve ( final class type , final boolean useannotation ) {	Resolves constructor injection point from type.
private classreader createadviceclassreader ( final class < ? extends proxyadvice > advice ) { inputstream inputstream = null ; try { inputstream = classloaderutil . getclassasstream ( advice ) ; return new classreader ( inputstream ) ; } catch ( ioexception ioex ) { throw new proxettaexception ( ioex ) ; } finally { streamutil . close ( inputstream ) ; } }	Creates advice's class reader.
private classreader getcachedadviceclassreader ( final class < ? extends proxyadvice > advice ) { if ( adviceclassreadercache == null ) { adviceclassreadercache = typecache . createdefault ( ) ; } classreader advicereader = adviceclassreadercache . get ( advice ) ; if ( advicereader == null ) { advicereader = createadviceclassreader ( advice ) ; adviceclassreadercache . put ( advice , advicereader ) ; } return advicereader ; }	Returns class reader for advice.
public string encrypt ( final string str ) { try { byte [ ] utf8 = stringutil . getbytes ( str ) ;	Symmetrically encrypts the string.
public string decrypt ( string str ) { try { str = stringutil . replacechar ( str , str_ , str_ ) ;	Symmetrically decrypts the string.
public static logger getlogger ( final string name ) { if ( loggers == null ) { return loggerprovider . apply ( name ) ; } return loggers . computeifabsent ( name , loggerprovider ) ; }	Returns logger for given name.
private void setname ( final string name ) { if ( name . contains ( str_ ) || name . contains ( str_ ) || name . startswith ( str_ ) ) { throw new illegalargumentexception ( str_ + name ) ; } for ( int n = num_ ; n < name . length ( ) ; n ++ ) { char c = name . charat ( n ) ; if ( c <= num_ || c >= num_ ) { throw new illegalargumentexception ( str_ + name ) ; } } this . name = name ; }	Sets the cookie name and checks for validity.
protected actionrequest createactionrequest ( final string actionpath , final string [ ] actionpathchunks , final actionruntime actionruntime , final object action , final httpservletrequest servletrequest , final httpservletresponse servletresponse ) { return new actionrequest ( this , actionpath , actionpathchunks , actionruntime , action , servletrequest , servletresponse ) ; }	Creates new action request.
@ override protected < r extends actionfilter > r createwrapper ( final class < r > wrapperclass ) { return petitecontainer . createbean ( wrapperclass ) ; }	Acquires filter from Petite container.
protected void destroybean ( final beandata beandata ) { if ( destroyablebeans == null ) { return ; } if ( ! isbeandestroyable ( beandata ) ) { return ; } if ( destroyablebeans . remove ( beandata ) ) { beandata . calldestroymethods ( ) ; } }	Removes destroyable bean from the list and calls it destroy methods.If bean is not destroyable, does nothing.
@ override public void shutdown ( ) { if ( destroyablebeans == null ) { return ; } for ( final beandata destroyablebean : destroyablebeans ) { destroyablebean . calldestroymethods ( ) ; } destroyablebeans . clear ( ) ; }	Shutdowns the scope and calls all collected destroyable beans.
public receivedemail [ ] get ( ) { if ( fromfolder != null ) { session . usefolder ( fromfolder ) ; } return session . receivemessages ( filter , flagstoset , flagstounset , envelopeonly , messages -> { if ( targetfolder != null ) { try { session . folder . copymessages ( messages , session . getfolder ( targetfolder ) ) ; } catch ( messagingexception e ) { throw new mailexception ( str_ ) ; } } } ) ; }	Receives the emails as specified by the builder.
public static void main ( final string [ ] args ) { loadpropertiesfiles ( args ) ; try ( clusteredservicecontainer container = launch ( ) ) { container . context ( ) . shutdownsignalbarrier ( ) . await ( ) ; system . out . println ( str_ ) ; } }	Launch the clustered service container and await a shutdown signal.
public void run ( ) { do { locksupport . parknanos ( parkns ) ; final long currenttotalmessages = totalmessages ; final long currenttotalbytes = totalbytes ; final long currenttimestamp = system . nanotime ( ) ; final long timespanns = currenttimestamp - lasttimestamp ; final double messagespersec = ( ( currenttotalmessages - lasttotalmessages ) * ( double ) reportintervalns ) / ( double ) timespanns ; final double bytespersec = ( ( currenttotalbytes - lasttotalbytes ) * ( double ) reportintervalns ) / ( double ) timespanns ; reportingfunc . onreport ( messagespersec , bytespersec , currenttotalmessages , currenttotalbytes ) ; lasttotalbytes = currenttotalbytes ; lasttotalmessages = currenttotalmessages ; lasttimestamp = currenttimestamp ; } while ( ! halt ) ; }	Run loop for the rate reporter.
@ suppresswarnings ( str_ ) public static void printerror ( final string channel , final int streamid , final int sessionid , final string message , final headerflyweight cause ) { system . out . println ( message ) ; }	Generic error handler that just prints message to stdout.
public static void printrate ( final double messagespersec , final double bytespersec , final long totalmessages , final long totalbytes ) { system . out . println ( string . format ( str_ , messagespersec , bytespersec , totalmessages , totalbytes / ( num_ * num_ ) ) ) ; }	Print the rates to stdout.
public static mappedbytebuffer mapexistingfilereadonly ( final file location ) { if ( ! location . exists ( ) ) { final string msg = str_ + location . getabsolutepath ( ) ; throw new illegalstateexception ( msg ) ; } mappedbytebuffer mappedbytebuffer = null ; try ( randomaccessfile file = new randomaccessfile ( location , str_ ) ; filechannel channel = file . getchannel ( ) ) { mappedbytebuffer = channel . map ( read_only , num_ , channel . size ( ) ) ; } catch ( final ioexception ex ) { langutil . rethrowunchecked ( ex ) ; } return mappedbytebuffer ; }	Map an existing file as a read only buffer.
public void close ( ) { final state state = this . state ; if ( state . closed != state ) { if ( isreplayactive ) { isreplayactive = bool_ ; archive . stopreplay ( replaysessionid ) ; } if ( state . merged != state ) { subscription . removedestination ( replaydestination ) ; } state ( state . closed ) ; } }	Close the merge and stop any active replay.
public int dowork ( ) { int workcount = num_ ; switch ( state ) { case await_initial_recording_position : workcount += awaitinitialrecordingposition ( ) ; break ; case await_replay : workcount += awaitreplay ( ) ; break ; case await_catch_up : workcount += awaitcatchup ( ) ; break ; case await_current_recording_position : workcount += awaitupdatedrecordingposition ( ) ; break ; case await_stop_replay : workcount += awaitstopreplay ( ) ; break ; } return workcount ; }	Process the operation of the merge.
public long position ( ) { if ( isclosed ) { return closed ; } final long rawtail = rawtailvolatile ( logmetadatabuffer ) ; final int termoffset = termoffset ( rawtail , termbufferlength ) ; return computeposition ( termid ( rawtail ) , termoffset , positionbitstoshift , initialtermid ) ; }	Get the current position to which the publication has advanced for this stream.
public long offer ( final directbuffervector [ ] vectors , final reservedvaluesupplier reservedvaluesupplier ) { final int length = directbuffervector . validateandcomputelength ( vectors ) ; long newposition = closed ; if ( ! isclosed ) { final long limit = positionlimit . getvolatile ( ) ; final exclusivetermappender termappender = termappenders [ activepartitionindex ] ; final long position = termbeginposition + termoffset ; if ( position < limit ) { final int result ; if ( length <= maxpayloadlength ) { result = termappender . appendunfragmentedmessage ( termid , termoffset , headerwriter , vectors , length , reservedvaluesupplier ) ; } else { checkmaxmessagelength ( length ) ; result = termappender . appendfragmentedmessage ( termid , termoffset , headerwriter , vectors , length , maxpayloadlength , reservedvaluesupplier ) ; } newposition = newposition ( result ) ; } else { newposition = backpressurestatus ( position , length ) ; } } return newposition ; }	Non-blocking publish by gathering buffer vectors into a message.
public long appendpadding ( final int length ) { checkmaxmessagelength ( length ) ; long newposition = closed ; if ( ! isclosed ) { final long limit = positionlimit . getvolatile ( ) ; final exclusivetermappender termappender = termappenders [ activepartitionindex ] ; final long position = termbeginposition + termoffset ; if ( position < limit ) { checkpositivelength ( length ) ; final int result = termappender . appendpadding ( termid , termoffset , headerwriter , length ) ; newposition = newposition ( result ) ; } else { newposition = backpressurestatus ( position , length ) ; } } return newposition ; }	Append a padding record log of a given length to make up the log to a position.
public void close ( ) { lock . lock ( ) ; try { if ( ! isclosed ) { isclosed = bool_ ; archiveproxy . closesession ( controlsessionid ) ; if ( ! context . ownsaeronclient ( ) ) { closehelper . close ( controlresponsepoller . subscription ( ) ) ; closehelper . close ( archiveproxy . publication ( ) ) ; } context . close ( ) ; } } finally { lock . unlock ( ) ; } }	Notify the archive that this control session is closed so it can promptly release resources then close thelocal resources associated with the client.
public string pollforerrorresponse ( ) { lock . lock ( ) ; try { ensureopen ( ) ; if ( controlresponsepoller . poll ( ) != num_ && controlresponsepoller . ispollcomplete ( ) ) { if ( controlresponsepoller . controlsessionid ( ) == controlsessionid && controlresponsepoller . templateid ( ) == controlresponsedecoder . template_id && controlresponsepoller . code ( ) == controlresponsecode . error ) { return controlresponsepoller . errormessage ( ) ; } } return null ; } finally { lock . unlock ( ) ; } }	Poll the response stream once for an error.
public void stopreplay ( final long replaysessionid ) { lock . lock ( ) ; try { ensureopen ( ) ; final long correlationid = aeron . nextcorrelationid ( ) ; if ( ! archiveproxy . stopreplay ( replaysessionid , correlationid , controlsessionid ) ) { throw new archiveexception ( str_ ) ; } pollforresponse ( correlationid ) ; } finally { lock . unlock ( ) ; } }	Stop a replay session.
public static void eventavailableimage ( final image image ) { final subscription subscription = image . subscription ( ) ; system . out . format ( str_ , subscription . channel ( ) , subscription . streamid ( ) , image . sessionid ( ) , image . sourceidentity ( ) ) ; }	Print the information for an available image to stdout.
public static void eventunavailableimage ( final image image ) { final subscription subscription = image . subscription ( ) ; system . out . format ( str_ , subscription . channel ( ) , subscription . streamid ( ) , image . sessionid ( ) ) ; }	This handler is called when image is unavailable.
public static statusindicatorreader sendchannelstatus ( final countersreader countersreader , final string channel ) { statusindicatorreader statusreader = null ; final mutableinteger id = new mutableinteger ( - num_ ) ; countersreader . foreach ( ( counterid , typeid , keybuffer , label ) -> { if ( typeid == sendchannelstatus . send_channel_status_type_id ) { if ( channel . startswith ( keybuffer . getstringascii ( channelendpointstatus . channel_offset ) ) ) { id . value = counterid ; } } } ) ; if ( aeron . null_value != id . value ) { statusreader = new unsafebufferstatusindicator ( countersreader . valuesbuffer ( ) , id . value ) ; } return statusreader ; }	Return the read-only status indicator for the given send channel URI.
public static statusindicatorreader receivechannelstatus ( final countersreader countersreader , final string channel ) { statusindicatorreader statusreader = null ; final mutableinteger id = new mutableinteger ( - num_ ) ; countersreader . foreach ( ( counterid , typeid , keybuffer , label ) -> { if ( typeid == receivechannelstatus . receive_channel_status_type_id ) { if ( channel . startswith ( keybuffer . getstringascii ( channelendpointstatus . channel_offset ) ) ) { id . value = counterid ; } } } ) ; if ( aeron . null_value != id . value ) { statusreader = new unsafebufferstatusindicator ( countersreader . valuesbuffer ( ) , id . value ) ; } return statusreader ; }	Return the read-only status indicator for the given receive channel URI.
public void limit ( final int limit ) { if ( limit < num_ || limit >= buffer . capacity ( ) ) { throw new illegalargumentexception ( str_ + buffer . capacity ( ) + str_ + limit ) ; } this . limit = limit ; }	Set this limit for this buffer as the position at which the next append operation will occur.
public bufferbuilder append ( final directbuffer srcbuffer , final int srcoffset , final int length ) { ensurecapacity ( length ) ; buffer . putbytes ( limit , srcbuffer , srcoffset , length ) ; limit += length ; return this ; }	Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.
public int poll ( ) { controlsessionid = - num_ ; correlationid = - num_ ; relevantid = - num_ ; templateid = - num_ ; errormessage = null ; pollcomplete = bool_ ; return subscription . controlledpoll ( fragmentassembler , fragmentlimit ) ; }	Poll for control response events.
public static mappedbytebuffer maplossreport ( final string aerondirectoryname , final int reportfilelength ) { return mapnewfile ( file ( aerondirectoryname ) , reportfilelength , bool_ ) ; }	Map a new loss report in the Aeron directory for a given length.
public map < streamcompositekey , list < streamposition > > snapshot ( ) { final map < streamcompositekey , list < streamposition > > streams = new hashmap < > ( ) ; counters . foreach ( ( counterid , typeid , keybuffer , label ) -> { if ( ( typeid >= publisher_limit_type_id && typeid <= receiver_pos_type_id ) || typeid == sender_limit_type_id || typeid == per_image_type_id || typeid == publisher_pos_type_id ) { final streamcompositekey key = new streamcompositekey ( keybuffer . getint ( session_id_offset ) , keybuffer . getint ( stream_id_offset ) , keybuffer . getstringascii ( channel_offset ) ) ; final streamposition position = new streamposition ( keybuffer . getlong ( registration_id_offset ) , counters . getcountervalue ( counterid ) , typeid ) ; streams . computeifabsent ( key , ( ignore ) -> new arraylist < > ( ) ) . add ( position ) ; } } ) ; return streams ; }	Take a snapshot of all the counters and group them by streams.
public static unsafebuffer createdefaultheader ( final int sessionid , final int streamid , final int termid ) { final unsafebuffer buffer = new unsafebuffer ( bufferutil . allocatedirectaligned ( header_length , cache_line_length ) ) ; buffer . putbyte ( version_field_offset , current_version ) ; buffer . putbyte ( flags_field_offset , ( byte ) begin_and_end_flags ) ; buffer . putshort ( type_field_offset , ( short ) hdr_type_data , little_endian ) ; buffer . putint ( session_id_field_offset , sessionid , little_endian ) ; buffer . putint ( stream_id_field_offset , streamid , little_endian ) ; buffer . putint ( term_id_field_offset , termid , little_endian ) ; buffer . putlong ( reserved_value_offset , default_reserve_value ) ; return buffer ; }	Return an initialised default Data Frame Header.
public countermessageflyweight keybuffer ( final directbuffer keybuffer , final int keyoffset , final int keylength ) { buffer . putint ( key_length_offset , keylength ) ; if ( null != keybuffer && keylength > num_ ) { buffer . putbytes ( keybufferoffset ( ) , keybuffer , keyoffset , keylength ) ; } return this ; }	Fill the key buffer.
public countermessageflyweight labelbuffer ( final directbuffer labelbuffer , final int labeloffset , final int labellength ) { buffer . putint ( labeloffset ( ) , labellength ) ; buffer . putbytes ( labelbufferoffset ( ) , labelbuffer , labeloffset , labellength ) ; return this ; }	Fill the label buffer.
public boolean connect ( final string responsechannel , final int responsestreamid , final long correlationid ) { connectrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . correlationid ( correlationid ) . responsestreamid ( responsestreamid ) . version ( aeronarchive . configuration . semantic_version ) . responsechannel ( responsechannel ) ; return offerwithtimeout ( connectrequestencoder . encodedlength ( ) , null ) ; }	Connect to an archive on its control interface providing the response stream details.
public boolean tryconnect ( final string responsechannel , final int responsestreamid , final long correlationid ) { connectrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . correlationid ( correlationid ) . responsestreamid ( responsestreamid ) . version ( aeronarchive . configuration . semantic_version ) . responsechannel ( responsechannel ) ; final int length = messageheaderencoder . encoded_length + connectrequestencoder . encodedlength ( ) ; return publication . offer ( buffer , num_ , length ) > num_ ; }	Try Connect to an archive on its control interface providing the response stream details.
public boolean closesession ( final long controlsessionid ) { closesessionrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) ; return offer ( closesessionrequestencoder . encodedlength ( ) ) ; }	Close this control session with the archive.
public boolean startrecording ( final string channel , final int streamid , final sourcelocation sourcelocation , final long correlationid , final long controlsessionid ) { startrecordingrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . streamid ( streamid ) . sourcelocation ( sourcelocation ) . channel ( channel ) ; return offer ( startrecordingrequestencoder . encodedlength ( ) ) ; }	Start recording streams for a given channel and stream id pairing.
public boolean stoprecording ( final string channel , final int streamid , final long correlationid , final long controlsessionid ) { stoprecordingrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . streamid ( streamid ) . channel ( channel ) ; return offer ( stoprecordingrequestencoder . encodedlength ( ) ) ; }	Stop an active recording.
public boolean replay ( final long recordingid , final long position , final long length , final string replaychannel , final int replaystreamid , final long correlationid , final long controlsessionid ) { replayrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . recordingid ( recordingid ) . position ( position ) . length ( length ) . replaystreamid ( replaystreamid ) . replaychannel ( replaychannel ) ; return offer ( replayrequestencoder . encodedlength ( ) ) ; }	Replay a recording from a given position.
public boolean stopreplay ( final long replaysessionid , final long correlationid , final long controlsessionid ) { stopreplayrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . replaysessionid ( replaysessionid ) ; return offer ( replayrequestencoder . encodedlength ( ) ) ; }	Stop an existing replay session.
public boolean listrecordings ( final long fromrecordingid , final int recordcount , final long correlationid , final long controlsessionid ) { listrecordingsrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . fromrecordingid ( fromrecordingid ) . recordcount ( recordcount ) ; return offer ( listrecordingsrequestencoder . encodedlength ( ) ) ; }	List a range of recording descriptors.
public boolean listrecordingsforuri ( final long fromrecordingid , final int recordcount , final string channelfragment , final int streamid , final long correlationid , final long controlsessionid ) { listrecordingsforurirequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . fromrecordingid ( fromrecordingid ) . recordcount ( recordcount ) . streamid ( streamid ) . channel ( channelfragment ) ; return offer ( listrecordingsforurirequestencoder . encodedlength ( ) ) ; }	List a range of recording descriptors which match a channel URI fragment and stream id.
public boolean listrecording ( final long recordingid , final long correlationid , final long controlsessionid ) { listrecordingrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . recordingid ( recordingid ) ; return offer ( listrecordingrequestencoder . encodedlength ( ) ) ; }	List a recording descriptor for a given recording id.
public boolean extendrecording ( final string channel , final int streamid , final sourcelocation sourcelocation , final long recordingid , final long correlationid , final long controlsessionid ) { extendrecordingrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . recordingid ( recordingid ) . streamid ( streamid ) . sourcelocation ( sourcelocation ) . channel ( channel ) ; return offer ( extendrecordingrequestencoder . encodedlength ( ) ) ; }	Extend an existing, non-active, recorded stream for a the same channel and stream id.The channel must be configured for the initial position from which it will be extended.
public boolean getrecordingposition ( final long recordingid , final long correlationid , final long controlsessionid ) { recordingpositionrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . recordingid ( recordingid ) ; return offer ( recordingpositionrequestencoder . encodedlength ( ) ) ; }	Get the recorded position of an active recording.
public boolean getstopposition ( final long recordingid , final long correlationid , final long controlsessionid ) { stoppositionrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . recordingid ( recordingid ) ; return offer ( stoppositionrequestencoder . encodedlength ( ) ) ; }	Get the stop position of a recording.
public boolean listrecordingsubscriptions ( final int pseudoindex , final int subscriptioncount , final string channelfragment , final int streamid , final boolean applystreamid , final long correlationid , final long controlsessionid ) { listrecordingsubscriptionsrequestencoder . wrapandapplyheader ( buffer , num_ , messageheaderencoder ) . controlsessionid ( controlsessionid ) . correlationid ( correlationid ) . pseudoindex ( pseudoindex ) . subscriptioncount ( subscriptioncount ) . applystreamid ( applystreamid ? booleantype . true : booleantype . false ) . streamid ( streamid ) . channel ( channelfragment ) ; return offer ( listrecordingsubscriptionsrequestencoder . encodedlength ( ) ) ; }	List registered subscriptions in the archive which have been used to record streams.
public boolean matchestag ( final udpchannel udpchannel ) { if ( ! hastag || ! udpchannel . hastag ( ) || tag != udpchannel . tag ( ) ) { return bool_ ; } if ( udpchannel . remotedata ( ) . getaddress ( ) . isanylocaladdress ( ) && udpchannel . remotedata ( ) . getport ( ) == num_ && udpchannel . localdata ( ) . getaddress ( ) . isanylocaladdress ( ) && udpchannel . localdata ( ) . getport ( ) == num_ ) { return bool_ ; } throw new illegalargumentexception ( str_ ) ; }	Does this channel have a tag match to another channel including endpoints.
public static inetsocketaddress destinationaddress ( final channeluri uri ) { try { validateconfiguration ( uri ) ; return getendpointaddress ( uri ) ; } catch ( final exception ex ) { throw new invalidchannelexception ( errorcode . invalid_channel , ex ) ; } }	Get the endpoint address from the URI.
public string description ( ) { final stringbuilder builder = new stringbuilder ( str_ ) ; if ( null != localinterface ) { builder . append ( str_ ) . append ( localinterface . getdisplayname ( ) ) . append ( str_ ) ; } builder . append ( str_ ) . append ( localdata ) . append ( str_ ) . append ( remotedata ) . append ( str_ ) . append ( multicastttl ) ; return builder . tostring ( ) ; }	Used for debugging to get a human readable description of the channel.
void adddestination ( final int transportindex , final receivedestinationudptransport transport ) { imageconnections = arrayutil . ensurecapacity ( imageconnections , transportindex + num_ ) ; if ( transport . ismulticast ( ) ) { imageconnections [ transportindex ] = new imageconnection ( cachednanoclock . nanotime ( ) , transport . udpchannel ( ) . remotecontrol ( ) ) ; } else if ( transport . hasexplicitcontrol ( ) ) { imageconnections [ transportindex ] = new imageconnection ( cachednanoclock . nanotime ( ) , transport . explicitcontroladdress ( ) ) ; } }	Add a destination to this image so it can merge streams.
int insertpacket ( final int termid , final int termoffset , final unsafebuffer buffer , final int length , final int transportindex , final inetsocketaddress srcaddress ) { final boolean isheartbeat = dataheaderflyweight . isheartbeat ( buffer , length ) ; final long packetposition = computeposition ( termid , termoffset , positionbitstoshift , initialtermid ) ; final long proposedposition = isheartbeat ? packetposition : packetposition + length ; if ( ! isflowcontrolunderrun ( packetposition ) && ! isflowcontroloverrun ( proposedposition ) ) { trackconnection ( transportindex , srcaddress , lastpackettimestampns ) ; if ( isheartbeat ) { if ( dataheaderflyweight . isendofstream ( buffer ) && ! isendofstream && alleos ( transportindex ) ) { logbufferdescriptor . endofstreamposition ( rawlog . metadata ( ) , proposedposition ) ; isendofstream = bool_ ; } heartbeatsreceived . incrementordered ( ) ; } else { final unsafebuffer termbuffer = termbuffers [ indexbyposition ( packetposition , positionbitstoshift ) ] ; termrebuilder . insert ( termbuffer , termoffset , buffer , length ) ; } lastpackettimestampns = cachednanoclock . nanotime ( ) ; hwmposition . proposemaxordered ( proposedposition ) ; } return length ; }	Insert frame into term buffer.
public static atomiccounter findcontroltoggle ( final countersreader counters ) { final atomicbuffer buffer = counters . metadatabuffer ( ) ; for ( int i = num_ , size = counters . maxcounterid ( ) ; i < size ; i ++ ) { final int recordoffset = countersreader . metadataoffset ( i ) ; if ( counters . getcounterstate ( i ) == record_allocated && buffer . getint ( recordoffset + type_id_offset ) == control_toggle_type_id ) { return new atomiccounter ( counters . valuesbuffer ( ) , i , null ) ; } } return null ; }	Find the control toggle counter or return null if not found.
public string put ( final string key , final string value ) { return params . put ( key , value ) ; }	Put a key and value pair in the map of params.
public string channeltag ( ) { return ( null != tags && tags . length > channel_tag_index ) ? tags [ channel_tag_index ] : null ; }	Get the channel tag, if it exists, that refers to an another channel.
public string entitytag ( ) { return ( null != tags && tags . length > entity_tag_index ) ? tags [ entity_tag_index ] : null ; }	Get the entity tag, if it exists, that refers to an entity such as subscription or publication.
public static string addsessionid ( final string channel , final int sessionid ) { final channeluri channeluri = channeluri . parse ( channel ) ; channeluri . put ( commoncontext . session_id_param_name , integer . tostring ( sessionid ) ) ; return channeluri . tostring ( ) ; }	Add a sessionId to a given channel.
public static long gettag ( final string paramvalue ) { return istagged ( paramvalue ) ? asciiencoding . parselongascii ( paramvalue , num_ , paramvalue . length ( ) - num_ ) : invalid_tag ; }	Get the value of the tag from a given parameter value.
public int appendpadding ( final int termid , final int termoffset , final headerwriter header , final int length ) { final int framelength = length + header_length ; final int alignedlength = align ( framelength , frame_alignment ) ; final unsafebuffer termbuffer = this . termbuffer ; final int termlength = termbuffer . capacity ( ) ; int resultingoffset = termoffset + alignedlength ; putrawtailordered ( termid , resultingoffset ) ; if ( resultingoffset > termlength ) { resultingoffset = handleendoflogcondition ( termbuffer , termoffset , header , termlength , termid ) ; } else { header . write ( termbuffer , termoffset , framelength , termid ) ; frametype ( termbuffer , termoffset , padding_frame_type ) ; framelengthordered ( termbuffer , termoffset , framelength ) ; } return resultingoffset ; }	Pad a length of the term buffer with a padding record.
final int updatepublisherlimit ( ) { int workcount = num_ ; final long senderposition = this . senderposition . getvolatile ( ) ; if ( hasreceivers || ( spiessimulateconnection && spypositions . length > num_ ) ) { long minconsumerposition = senderposition ; for ( final readableposition spyposition : spypositions ) { minconsumerposition = math . min ( minconsumerposition , spyposition . getvolatile ( ) ) ; } final long proposedpublisherlimit = minconsumerposition + termwindowlength ; if ( publisherlimit . proposemaxordered ( proposedpublisherlimit ) ) { cleanbuffer ( proposedpublisherlimit ) ; workcount = num_ ; } } else if ( publisherlimit . get ( ) > senderposition ) { publisherlimit . setordered ( senderposition ) ; } return workcount ; }	Update the publishers limit for flow control as part of the conductor duty cycle.
public static unsafebufferposition allocate ( final mutabledirectbuffer tempbuffer , final string name , final int typeid , final countersmanager countersmanager , final long registrationid , final int sessionid , final int streamid , final string channel ) { return new unsafebufferposition ( ( unsafebuffer ) countersmanager . valuesbuffer ( ) , allocatecounterid ( tempbuffer , name , typeid , countersmanager , registrationid , sessionid , streamid , channel ) , countersmanager ) ; }	Allocate a counter for tracking a position on a stream of messages.
public static string labelname ( final int typeid ) { switch ( typeid ) { case publisherlimit . publisher_limit_type_id : return publisherlimit . name ; case senderpos . sender_position_type_id : return senderpos . name ; case receiverhwm . receiver_hwm_type_id : return receiverhwm . name ; case subscriberpos . subscriber_position_type_id : return subscriberpos . name ; case receiverpos . receiver_pos_type_id : return receiverpos . name ; case senderlimit . sender_limit_type_id : return senderlimit . name ; case publisherpos . publisher_pos_type_id : return publisherpos . name ; case senderbpe . sender_bpe_type_id : return senderbpe . name ; default : return str_ ; } }	Return the label name for a counter type identifier.
public static long scanforavailability ( final unsafebuffer termbuffer , final int offset , final int maxlength ) { final int limit = math . min ( maxlength , termbuffer . capacity ( ) - offset ) ; int available = num_ ; int padding = num_ ; do { final int termoffset = offset + available ; final int framelength = framelengthvolatile ( termbuffer , termoffset ) ; if ( framelength <= num_ ) { break ; } int alignedframelength = align ( framelength , frame_alignment ) ; if ( ispaddingframe ( termbuffer , termoffset ) ) { padding = alignedframelength - header_length ; alignedframelength = header_length ; } available += alignedframelength ; if ( available > limit ) { available -= alignedframelength ; padding = num_ ; break ; } } while ( num_ == padding && available < limit ) ; return pack ( padding , available ) ; }	Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.
public channeluristringbuilder clear ( ) { prefix = null ; media = null ; endpoint = null ; networkinterface = null ; controlendpoint = null ; controlmode = null ; tags = null ; alias = null ; reliable = null ; ttl = null ; mtu = null ; termlength = null ; initialtermid = null ; termid = null ; termoffset = null ; sessionid = null ; linger = null ; sparse = null ; eos = null ; tether = null ; issessionidtagged = bool_ ; return this ; }	Clear out all the values thus setting back to the initial state.
public channeluristringbuilder validate ( ) { if ( null == media ) { throw new illegalstateexception ( str_ ) ; } if ( commoncontext . udp_media . equals ( media ) && ( null == endpoint && null == controlendpoint ) ) { throw new illegalstateexception ( str_ ) ; } int count = num_ ; count += null == initialtermid ? num_ : num_ ; count += null == termid ? num_ : num_ ; count += null == termoffset ? num_ : num_ ; if ( count > num_ ) { if ( count < num_ ) { throw new illegalstateexception ( str_ ) ; } if ( termid - initialtermid < num_ )	Validates that the collection of set parameters are valid together.
public channeluristringbuilder prefix ( final string prefix ) { if ( null != prefix && ! prefix . equals ( str_ ) && ! prefix . equals ( spy_qualifier ) ) { throw new illegalargumentexception ( str_ + prefix ) ; } this . prefix = prefix ; return this ; }	Set the prefix for taking an addition action such as spying on an outgoing publication with "aeron-spy".
public channeluristringbuilder media ( final string media ) { switch ( media ) { case commoncontext . udp_media : case commoncontext . ipc_media : break ; default : throw new illegalargumentexception ( str_ + media ) ; } this . media = media ; return this ; }	Set the media for this channel.
public channeluristringbuilder controlmode ( final string controlmode ) { if ( null != controlmode && ! controlmode . equals ( commoncontext . mdc_control_mode_manual ) && ! controlmode . equals ( commoncontext . mdc_control_mode_dynamic ) ) { throw new illegalargumentexception ( str_ + controlmode ) ; } this . controlmode = controlmode ; return this ; }	Set the control mode for multi-destination-cast.
public channeluristringbuilder termlength ( final integer termlength ) { if ( null != termlength ) { logbufferdescriptor . checktermlength ( termlength ) ; } this . termlength = termlength ; return this ; }	Set the length of buffer used for each term of the log.
public channeluristringbuilder termoffset ( final integer termoffset ) { if ( null != termoffset ) { if ( ( termoffset < num_ || termoffset > logbufferdescriptor . term_max_length ) ) { throw new illegalargumentexception ( str_ + termoffset ) ; } if ( num_ != ( termoffset & ( frame_alignment - num_ ) ) ) { throw new illegalargumentexception ( str_ + termoffset ) ; } } this . termoffset = termoffset ; return this ; }	Set the offset within a term at which a publication will start.
public channeluristringbuilder linger ( final long lingerns ) { if ( null != lingerns && lingerns < num_ ) { throw new illegalargumentexception ( str_ + lingerns ) ; } this . linger = lingerns ; return this ; }	Set the time a network publication will linger in nanoseconds after being drained.
public void close ( ) { if ( ! isclosed ) { isclosed = bool_ ; try { if ( null != selectionkey ) { selectionkey . cancel ( ) ; } if ( null != transportpoller ) { transportpoller . cancelread ( this ) ; transportpoller . selectnowwithoutprocessing ( ) ; } if ( null != senddatagramchannel ) { senddatagramchannel . close ( ) ; } if ( receivedatagramchannel != senddatagramchannel && null != receivedatagramchannel ) { receivedatagramchannel . close ( ) ; } if ( null != transportpoller ) { transportpoller . selectnowwithoutprocessing ( ) ; } } catch ( final ioexception ex ) { errorlog . record ( ex ) ; } } }	Close transport, canceling any pending read operations and closing channel.
public boolean isvalidframe ( final unsafebuffer buffer , final int length ) { boolean isframevalid = bool_ ; if ( frameversion ( buffer , num_ ) != headerflyweight . current_version ) { isframevalid = bool_ ; invalidpackets . increment ( ) ; } else if ( length < headerflyweight . min_header_length ) { isframevalid = bool_ ; invalidpackets . increment ( ) ; } return isframevalid ; }	Is the received frame valid.
public inetsocketaddress receive ( final bytebuffer buffer ) { buffer . clear ( ) ; inetsocketaddress address = null ; try { if ( receivedatagramchannel . isopen ( ) ) { address = ( inetsocketaddress ) receivedatagramchannel . receive ( buffer ) ; } } catch ( final portunreachableexception ignored ) { } catch ( final exception ex ) { langutil . rethrowunchecked ( ex ) ; } return address ; }	Receive a datagram from the media layer.
public void onnak ( final int termid , final int termoffset , final int length , final int termlength , final retransmitsender retransmitsender ) { if ( ! isinvalid ( termoffset , termlength ) ) { if ( null == activeretransmitsmap . get ( termid , termoffset ) && activeretransmitsmap . size ( ) < max_retransmits_default ) { final retransmitaction action = assignretransmitaction ( ) ; action . termid = termid ; action . termoffset = termoffset ; action . length = math . min ( length , termlength - termoffset ) ; final long delay = delaygenerator . generatedelay ( ) ; if ( num_ == delay ) { retransmitsender . resend ( termid , termoffset , action . length ) ; action . linger ( lingertimeoutgenerator . generatedelay ( ) , nanoclock . nanotime ( ) ) ; } else { action . delay ( delay , nanoclock . nanotime ( ) ) ; } activeretransmitsmap . put ( termid , termoffset , action ) ; } } }	Called on reception of a NAK to start retransmits handling.
public void processtimeouts ( final long nowns , final retransmitsender retransmitsender ) { if ( activeretransmitsmap . size ( ) > num_ ) { for ( final retransmitaction action : retransmitactionpool ) { if ( delayed == action . state && ( action . expirens - nowns < num_ ) ) { retransmitsender . resend ( action . termid , action . termoffset , action . length ) ; action . linger ( lingertimeoutgenerator . generatedelay ( ) , nanoclock . nanotime ( ) ) ; } else if ( lingering == action . state && ( action . expirens - nowns < num_ ) ) { action . cancel ( ) ; activeretransmitsmap . remove ( action . termid , action . termoffset ) ; } } } }	Called to process any outstanding timeouts.
public static string status ( final long status ) { if ( initializing == status ) { return str_ ; } if ( errored == status ) { return str_ ; } if ( active == status ) { return str_ ; } if ( closing == status ) { return str_ ; } return str_ + status ; }	String representation of the channel status.
public static atomiccounter allocate ( final mutabledirectbuffer tempbuffer , final string name , final int typeid , final countersmanager countersmanager , final string channel ) { final int keylength = tempbuffer . putstringwithoutlengthascii ( channel_offset + size_of_int , channel , num_ , max_channel_length ) ; tempbuffer . putint ( channel_offset , keylength ) ; int labellength = num_ ; labellength += tempbuffer . putstringwithoutlengthascii ( keylength + labellength , name ) ; labellength += tempbuffer . putstringwithoutlengthascii ( keylength + labellength , str_ ) ; labellength += tempbuffer . putstringwithoutlengthascii ( keylength + labellength , channel , num_ , max_label_length - labellength ) ; return countersmanager . newcounter ( typeid , tempbuffer , num_ , keylength , tempbuffer , keylength , labellength ) ; }	Allocate an indicator for tracking the status of a channel endpoint.
public directbuffervector reset ( final directbuffer buffer , final int offset , final int length ) { this . buffer = buffer ; this . offset = offset ; this . length = length ; return this ; }	Reset the values.
public directbuffervector validate ( ) { final int capacity = buffer . capacity ( ) ; if ( offset < num_ || offset >= capacity ) { throw new illegalargumentexception ( str_ + offset + str_ + capacity ) ; } if ( length < num_ || length > ( capacity - offset ) ) { throw new illegalargumentexception ( str_ + offset + str_ + capacity + str_ + length ) ; } return this ; }	Ensure the vector is valid for the buffer.
public static int validateandcomputelength ( final directbuffervector [ ] vectors ) { int messagelength = num_ ; for ( final directbuffervector vector : vectors ) { vector . validate ( ) ; messagelength += vector . length ; if ( messagelength < num_ ) { throw new illegalstateexception ( str_ + arrays . tostring ( vectors ) ) ; } } return messagelength ; }	Validate an array of vectors to make up a message and compute the total length.
public static int producerwindowlength ( final int termbufferlength , final int defaulttermwindowlength ) { int termwindowlength = termbufferlength / num_ ; if ( num_ != defaulttermwindowlength ) { termwindowlength = math . min ( defaulttermwindowlength , termwindowlength ) ; } return termwindowlength ; }	How far ahead a producer can get from a consumer position.
public static void validatesocketbufferlengths ( final mediadriver . context ctx ) { try ( datagramchannel probe = datagramchannel . open ( ) ) { final int defaultsosndbuf = probe . getoption ( standardsocketoptions . so_sndbuf ) ; probe . setoption ( standardsocketoptions . so_sndbuf , integer . max_value ) ; final int maxsosndbuf = probe . getoption ( standardsocketoptions . so_sndbuf ) ; if ( maxsosndbuf < ctx . socketsndbuflength ( ) ) { system . err . format ( str_ , socket_sndbuf_length_prop_name , ctx . socketsndbuflength ( ) , maxsosndbuf ) ; } probe . setoption ( standardsocketoptions . so_rcvbuf , integer . max_value ) ; final int maxsorcvbuf = probe . getoption ( standardsocketoptions . so_rcvbuf ) ; if ( maxsorcvbuf < ctx . socketrcvbuflength ( ) ) { system . err . format ( str_ , socket_rcvbuf_length_prop_name , ctx . socketrcvbuflength ( ) , maxsorcvbuf ) ; } final int sosndbuf = num_ == ctx . socketsndbuflength ( ) ? defaultsosndbuf : ctx . socketsndbuflength ( ) ; if ( ctx . mtulength ( ) > sosndbuf ) { throw new configurationexception ( string . format ( str_ , socket_sndbuf_length_prop_name , ctx . mtulength ( ) , sosndbuf ) ) ; } if ( ctx . initialwindowlength ( ) > maxsorcvbuf ) { throw new configurationexception ( str_ + configuration . initial_window_length_prop_name + str_ + ctx . initialwindowlength ( ) + str_ + maxsorcvbuf ) ; } } catch ( final ioexception ex ) { throw new aeronexception ( str_ + ex . tostring ( ) , ex ) ; } }	Validate that the socket buffer lengths are sufficient for the media driver configuration.
public static void validatepagesize ( final int pagesize ) { if ( pagesize < page_min_size ) { throw new configurationexception ( str_ + page_min_size + str_ + pagesize ) ; } if ( pagesize > page_max_size ) { throw new configurationexception ( str_ + page_max_size + str_ + pagesize ) ; } if ( ! bitutil . ispoweroftwo ( pagesize ) ) { throw new configurationexception ( str_ + pagesize ) ; } }	Validate that page size is valid and alignment is valid.
public static void validatesessionidrange ( final int low , final int high ) { if ( low > high ) { throw new configurationexception ( str_ + low + str_ + high ) ; } if ( math . abs ( ( long ) high - low ) > integer . max_value ) { throw new configurationexception ( str_ ) ; } }	Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.
public static void validateunblocktimeout ( final long publicationunblocktimeoutns , final long clientlivenesstimeoutns , final long timerintervalns ) { if ( publicationunblocktimeoutns <= clientlivenesstimeoutns ) { throw new configurationexception ( str_ + publicationunblocktimeoutns + str_ + clientlivenesstimeoutns ) ; } if ( clientlivenesstimeoutns <= timerintervalns ) { throw new configurationexception ( str_ + clientlivenesstimeoutns + str_ + timerintervalns ) ; } }	Validate that the timeouts for unblocking publications from a client are valid.
public errorresponseflyweight errorcode ( final errorcode code ) { buffer . putint ( offset + error_code_offset , code . value ( ) ) ; return this ; }	Set the error code for the command.
public void reset ( ) { isballotsent = bool_ ; isleader = bool_ ; hasrequestedjoin = bool_ ; hassentterminationack = bool_ ; vote = null ; candidatetermid = aeron . null_value ; leadershiptermid = aeron . null_value ; logposition = null_position ; }	Reset the state of a cluster member so it can be canvassed and reestablished.
public static string encodeasstring ( final clustermember [ ] clustermembers ) { final stringbuilder builder = new stringbuilder ( ) ; for ( int i = num_ , length = clustermembers . length ; i < length ; i ++ ) { final clustermember member = clustermembers [ i ] ; builder . append ( member . id ( ) ) . append ( str_ ) . append ( member . endpointsdetail ( ) ) ; if ( ( length - num_ ) != i ) { builder . append ( str_ ) ; } } return builder . tostring ( ) ; }	Encode member details from a cluster members array to a string.
public static void addmemberstatuspublications ( final clustermember [ ] members , final clustermember exclude , final channeluri channeluri , final int streamid , final aeron aeron ) { for ( final clustermember member : members ) { if ( member != exclude ) { channeluri . put ( endpoint_param_name , member . memberfacingendpoint ( ) ) ; member . publication = aeron . addexclusivepublication ( channeluri . tostring ( ) , streamid ) ; } } }	Add the publications for sending status messages to the other members of the cluster.
public static void closememberpublications ( final clustermember [ ] clustermembers ) { for ( final clustermember member : clustermembers ) { closehelper . close ( member . publication ) ; } }	Close the publications associated with members of the cluster.
public static boolean hasactivequorum ( final clustermember [ ] clustermembers , final long nowms , final long timeoutms ) { int threshold = quorumthreshold ( clustermembers . length ) ; for ( final clustermember member : clustermembers ) { if ( member . isleader ( ) || nowms <= ( member . timeoflastappendpositionms ( ) + timeoutms ) ) { if ( -- threshold <= num_ ) { return bool_ ; } } } return bool_ ; }	Check if the cluster leader has an active quorum of cluster followers.
public static long quorumposition ( final clustermember [ ] members , final long [ ] rankedpositions ) { final int length = rankedpositions . length ; for ( int i = num_ ; i < length ; i ++ ) { rankedpositions [ i ] = num_ ; } for ( final clustermember member : members ) { long newposition = member . logposition ; for ( int i = num_ ; i < length ; i ++ ) { final long rankedposition = rankedpositions [ i ] ; if ( newposition > rankedposition ) { rankedpositions [ i ] = newposition ; newposition = rankedposition ; } } } return rankedpositions [ length - num_ ] ; }	Calculate the position reached by a quorum of cluster members.
public static void resetlogpositions ( final clustermember [ ] clustermembers , final long logposition ) { for ( final clustermember member : clustermembers ) { member . logposition ( logposition ) ; } }	Reset the log position of all the members to the provided value.
public static boolean havevotersreachedposition ( final clustermember [ ] clustermembers , final long position , final long leadershiptermid ) { for ( final clustermember member : clustermembers ) { if ( member . vote != null && ( member . logposition < position || member . leadershiptermid != leadershiptermid ) ) { return bool_ ; } } return bool_ ; }	Has the members of the cluster the voted reached the provided position in their log.
public static boolean haswonvoteonfullcount ( final clustermember [ ] members , final long candidatetermid ) { int votes = num_ ; for ( final clustermember member : members ) { if ( null == member . vote || member . candidatetermid != candidatetermid ) { return bool_ ; } votes += member . vote ? num_ : num_ ; } return votes >= clustermember . quorumthreshold ( members . length ) ; }	Has the candidate got unanimous support of the cluster?.
public static boolean hasmajorityvote ( final clustermember [ ] clustermembers , final long candidatetermid ) { int votes = num_ ; for ( final clustermember member : clustermembers ) { if ( boolean . true . equals ( member . vote ) && member . candidatetermid == candidatetermid ) { ++ votes ; } } return votes >= clustermember . quorumthreshold ( clustermembers . length ) ; }	Has sufficient votes being counted for a majority?.
public static clustermember determinemember ( final clustermember [ ] clustermembers , final int memberid , final string memberendpoints ) { clustermember member = null_value != memberid ? clustermember . findmember ( clustermembers , memberid ) : null ; if ( ( null == clustermembers || num_ == clustermembers . length ) && null == member ) { member = clustermember . parseendpoints ( null_value , memberendpoints ) ; } else { if ( null == member ) { throw new clusterexception ( str_ + memberid + str_ ) ; } if ( ! str_ . equals ( memberendpoints ) ) { clustermember . validatememberendpoints ( member , memberendpoints ) ; } } return member ; }	Determine which member of a cluster this is and check endpoints.
public static void validatememberendpoints ( final clustermember member , final string memberendpoints ) { final clustermember endpointmember = clustermember . parseendpoints ( aeron . null_value , memberendpoints ) ; if ( ! aresameendpoints ( member , endpointmember ) ) { throw new clusterexception ( str_ + member . endpointsdetail ( ) + str_ + memberendpoints ) ; } }	Check the member with the memberEndpoints.
public static boolean aresameendpoints ( final clustermember lhs , final clustermember rhs ) { return lhs . clientfacingendpoint ( ) . equals ( rhs . clientfacingendpoint ( ) ) && lhs . memberfacingendpoint ( ) . equals ( rhs . memberfacingendpoint ( ) ) && lhs . logendpoint ( ) . equals ( rhs . logendpoint ( ) ) && lhs . transferendpoint ( ) . equals ( rhs . transferendpoint ( ) ) && lhs . archiveendpoint ( ) . equals ( rhs . archiveendpoint ( ) ) ; }	Are two cluster members using the same endpoints?.
public static boolean isunanimouscandidate ( final clustermember [ ] clustermembers , final clustermember candidate ) { for ( final clustermember member : clustermembers ) { if ( null_position == member . logposition || comparelog ( candidate , member ) < num_ ) { return bool_ ; } } return bool_ ; }	Has the member achieved a unanimous view to be a suitable candidate in an election.
public static boolean isquorumcandidate ( final clustermember [ ] clustermembers , final clustermember candidate ) { int possiblevotes = num_ ; for ( final clustermember member : clustermembers ) { if ( null_position == member . logposition || comparelog ( candidate , member ) < num_ ) { continue ; } ++ possiblevotes ; } return possiblevotes >= clustermember . quorumthreshold ( clustermembers . length ) ; }	Has the member achieved a quorum view to be a suitable candidate in an election.
public static boolean isnotduplicateendpoints ( final clustermember [ ] members , final string memberendpoints ) { for ( final clustermember member : members ) { if ( member . endpointsdetail ( ) . equals ( memberendpoints ) ) { return bool_ ; } } return bool_ ; }	Is the string of member endpoints not duplicated in the members.
public static int findmemberindex ( final clustermember [ ] clustermembers , final int memberid ) { final int length = clustermembers . length ; int index = arrayutil . unknown_index ; for ( int i = num_ ; i < length ; i ++ ) { if ( clustermembers [ i ] . id ( ) == memberid ) { index = i ; } } return index ; }	Find the index at which a member id is present.
public static clustermember [ ] removemember ( final clustermember [ ] oldmembers , final int memberid ) { return arrayutil . remove ( oldmembers , findmemberindex ( oldmembers , memberid ) ) ; }	Remove a member from an array if found, otherwise return the array unmodified.
public static int highmemberid ( final clustermember [ ] clustermembers ) { int highid = aeron . null_value ; for ( final clustermember member : clustermembers ) { highid = math . max ( highid , member . id ( ) ) ; } return highid ; }	Find the highest member id in an array of members.
public mappedbytebuffer mapexistingcncfile ( final consumer < string > logger ) { final file cncfile = new file ( aerondirectory , cncfiledescriptor . cnc_file ) ; if ( cncfile . exists ( ) && cncfile . length ( ) > num_ ) { if ( null != logger ) { logger . accept ( str_ + cncfile ) ; } return ioutil . mapexistingfile ( cncfile , cncfiledescriptor . cnc_file ) ; } return null ; }	Map the CnC file if it exists.
public static boolean isdriveractive ( final file directory , final long drivertimeoutms , final consumer < string > logger ) { final file cncfile = new file ( directory , cncfiledescriptor . cnc_file ) ; if ( cncfile . exists ( ) && cncfile . length ( ) > num_ ) { logger . accept ( str_ + cncfile ) ; final mappedbytebuffer cncbytebuffer = ioutil . mapexistingfile ( cncfile , str_ ) ; try { return isdriveractive ( drivertimeoutms , logger , cncbytebuffer ) ; } finally { ioutil . unmap ( cncbytebuffer ) ; } } return bool_ ; }	Is a media driver active in the given directory?.
public boolean isdriveractive ( final long drivertimeoutms , final consumer < string > logger ) { final mappedbytebuffer cncbytebuffer = mapexistingcncfile ( logger ) ; try { return isdriveractive ( drivertimeoutms , logger , cncbytebuffer ) ; } finally { ioutil . unmap ( cncbytebuffer ) ; } }	Is a media driver active in the current Aeron directory?.
public static boolean isdriveractive ( final long drivertimeoutms , final consumer < string > logger , final bytebuffer cncbytebuffer ) { if ( null == cncbytebuffer ) { return bool_ ; } final unsafebuffer cncmetadatabuffer = cncfiledescriptor . createmetadatabuffer ( cncbytebuffer ) ; final long starttimems = system . currenttimemillis ( ) ; int cncversion ; while ( num_ == ( cncversion = cncmetadatabuffer . getintvolatile ( cncfiledescriptor . cncversionoffset ( num_ ) ) ) ) { if ( system . currenttimemillis ( ) > ( starttimems + drivertimeoutms ) ) { throw new drivertimeoutexception ( str_ ) ; } sleep ( num_ ) ; } if ( cnc_version != cncversion ) { throw new aeronexception ( str_ + cnc_version + str_ + cncversion ) ; } final manytooneringbuffer todriverbuffer = new manytooneringbuffer ( cncfiledescriptor . createtodriverbuffer ( cncbytebuffer , cncmetadatabuffer ) ) ; final long timestamp = todriverbuffer . consumerheartbeattime ( ) ; final long now = system . currenttimemillis ( ) ; final long timestampage = now - timestamp ; logger . accept ( str_ + timestampage ) ; return timestampage <= drivertimeoutms ; }	Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait forup to the driverTimeoutMs by checking for the cncVersion being set.
public static boolean requestdrivertermination ( final file directory , final directbuffer tokenbuffer , final int tokenoffset , final int tokenlength ) { final file cncfile = new file ( directory , cncfiledescriptor . cnc_file ) ; if ( cncfile . exists ( ) && cncfile . length ( ) > num_ ) { final mappedbytebuffer cncbytebuffer = ioutil . mapexistingfile ( cncfile , str_ ) ; try { final unsafebuffer cncmetadatabuffer = cncfiledescriptor . createmetadatabuffer ( cncbytebuffer ) ; final int cncversion = cncmetadatabuffer . getintvolatile ( cncversionoffset ( num_ ) ) ; if ( cncfiledescriptor . cnc_version != cncversion ) { throw new aeronexception ( str_ + cnc_version + str_ + cncversion ) ; } final manytooneringbuffer todriverbuffer = new manytooneringbuffer ( cncfiledescriptor . createtodriverbuffer ( cncbytebuffer , cncmetadatabuffer ) ) ; final long clientid = todriverbuffer . nextcorrelationid ( ) ; final driverproxy driverproxy = new driverproxy ( todriverbuffer , clientid ) ; return driverproxy . terminatedriver ( tokenbuffer , tokenoffset , tokenlength ) ; } finally { ioutil . unmap ( cncbytebuffer ) ; } } return bool_ ; }	Request a driver to run its termination hook.
public static int framelengthvolatile ( final unsafebuffer buffer , final int termoffset ) { int framelength = buffer . getintvolatile ( termoffset ) ; if ( byteorder . nativeorder ( ) != little_endian ) { framelength = integer . reversebytes ( framelength ) ; } return framelength ; }	Get the length of a frame from the header as a volatile read.
public static void framelengthordered ( final unsafebuffer buffer , final int termoffset , final int framelength ) { int length = framelength ; if ( byteorder . nativeorder ( ) != little_endian ) { length = integer . reversebytes ( framelength ) ; } buffer . putintordered ( termoffset , length ) ; }	Write the length header for a frame in a memory ordered fashion.
public static void frametype ( final unsafebuffer buffer , final int termoffset , final int type ) { buffer . putshort ( typeoffset ( termoffset ) , ( short ) type , little_endian ) ; }	Write the type field for a frame.
public static void frameflags ( final unsafebuffer buffer , final int termoffset , final byte flags ) { buffer . putbyte ( flagsoffset ( termoffset ) , flags ) ; }	Write the flags field for a frame.
public static void frametermoffset ( final unsafebuffer buffer , final int termoffset ) { buffer . putint ( termoffsetoffset ( termoffset ) , termoffset , little_endian ) ; }	Write the term offset field for a frame.
public static void frametermid ( final unsafebuffer buffer , final int termoffset , final int termid ) { buffer . putint ( termidoffset ( termoffset ) , termid , little_endian ) ; }	Write the term id field for a frame.
public static int findcounteridbyrecording ( final countersreader countersreader , final long recordingid ) { final directbuffer buffer = countersreader . metadatabuffer ( ) ; for ( int i = num_ , size = countersreader . maxcounterid ( ) ; i < size ; i ++ ) { if ( countersreader . getcounterstate ( i ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( i ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recording_position_type_id && buffer . getlong ( recordoffset + key_offset + recording_id_offset ) == recordingid ) { return i ; } } } return null_counter_id ; }	Find the active counter id for a stream based on the recording id.
public static int findcounteridbysession ( final countersreader countersreader , final int sessionid ) { final directbuffer buffer = countersreader . metadatabuffer ( ) ; for ( int i = num_ , size = countersreader . maxcounterid ( ) ; i < size ; i ++ ) { if ( countersreader . getcounterstate ( i ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( i ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recording_position_type_id && buffer . getint ( recordoffset + key_offset + session_id_offset ) == sessionid ) { return i ; } } } return null_counter_id ; }	Find the active counter id for a stream based on the session id.
public static long getrecordingid ( final countersreader countersreader , final int counterid ) { final directbuffer buffer = countersreader . metadatabuffer ( ) ; if ( countersreader . getcounterstate ( counterid ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( counterid ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recording_position_type_id ) { return buffer . getlong ( recordoffset + key_offset + recording_id_offset ) ; } } return null_recording_id ; }	Get the recording id for a given counter id.
public static boolean isactive ( final countersreader countersreader , final int counterid , final long recordingid ) { final directbuffer buffer = countersreader . metadatabuffer ( ) ; if ( countersreader . getcounterstate ( counterid ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( counterid ) ; return buffer . getint ( recordoffset + type_id_offset ) == recording_position_type_id && buffer . getlong ( recordoffset + key_offset + recording_id_offset ) == recordingid ; } return bool_ ; }	Is the recording counter still active.
public statusmessageflyweight applicationspecificfeedback ( final byte [ ] source , final int offset , final int length ) { framelength ( header_length + length ) ; putbytes ( app_specific_feedback_field_offset , source , offset , length ) ; return this ; }	Set the Application Specific Feedback for the Status Message.
public void reload ( ) { entries . clear ( ) ; indexbyleadershiptermidmap . clear ( ) ; indexbyleadershiptermidmap . compact ( ) ; nextentryindex = num_ ; bytebuffer . clear ( ) ; try { while ( bool_ ) { final int bytes = filechannel . read ( bytebuffer ) ; if ( bytebuffer . remaining ( ) == num_ ) { bytebuffer . flip ( ) ; captureentriesfrombuffer ( bytebuffer , buffer , entries ) ; bytebuffer . clear ( ) ; } if ( - num_ == bytes ) { if ( bytebuffer . position ( ) > num_ ) { bytebuffer . flip ( ) ; captureentriesfrombuffer ( bytebuffer , buffer , entries ) ; bytebuffer . clear ( ) ; } break ; } } } catch ( final ioexception ex ) { langutil . rethrowunchecked ( ex ) ; } }	Reload the log from disk.
public entry findlastterm ( ) { for ( int i = entries . size ( ) - num_ ; i >= num_ ; i -- ) { final entry entry = entries . get ( i ) ; if ( entry_type_term == entry . type ) { return entry ; } } return null ; }	Find the last leadership term in the recording log.
public recoveryplan createrecoveryplan ( final aeronarchive archive , final int servicecount ) { final arraylist < snapshot > snapshots = new arraylist < > ( ) ; final arraylist < log > logs = new arraylist < > ( ) ; planrecovery ( snapshots , logs , entries , archive , servicecount ) ; long lastleadershiptermid = null_value ; long lasttermbaselogposition = num_ ; long committedlogposition = - num_ ; long appendedlogposition = num_ ; final int snapshotstepssize = snapshots . size ( ) ; if ( snapshotstepssize > num_ ) { final snapshot snapshot = snapshots . get ( num_ ) ; lastleadershiptermid = snapshot . leadershiptermid ; lasttermbaselogposition = snapshot . termbaselogposition ; appendedlogposition = snapshot . logposition ; committedlogposition = snapshot . logposition ; } if ( ! logs . isempty ( ) ) { final log log = logs . get ( num_ ) ; lastleadershiptermid = log . leadershiptermid ; lasttermbaselogposition = log . termbaselogposition ; appendedlogposition = log . stopposition ; committedlogposition = log . logposition ; } return new recoveryplan ( lastleadershiptermid , lasttermbaselogposition , appendedlogposition , committedlogposition , snapshots , logs ) ; }	Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to thelatest stable state.
public static recoveryplan createrecoveryplan ( final arraylist < recordinglog . snapshot > snapshots ) { long lastleadershiptermid = null_value ; long lasttermbaselogposition = num_ ; long committedlogposition = - num_ ; long appendedlogposition = num_ ; final int snapshotstepssize = snapshots . size ( ) ; if ( snapshotstepssize > num_ ) { final snapshot snapshot = snapshots . get ( num_ ) ; lastleadershiptermid = snapshot . leadershiptermid ; lasttermbaselogposition = snapshot . termbaselogposition ; appendedlogposition = snapshot . logposition ; committedlogposition = snapshot . logposition ; } return new recoveryplan ( lastleadershiptermid , lasttermbaselogposition , appendedlogposition , committedlogposition , snapshots , new arraylist < > ( ) ) ; }	Create a recovery plan that has only snapshots.
public void appendterm ( final long recordingid , final long leadershiptermid , final long termbaselogposition , final long timestamp ) { final int size = entries . size ( ) ; if ( size > num_ ) { final entry lastentry = entries . get ( size - num_ ) ; if ( lastentry . type != null_value && lastentry . leadershiptermid >= leadershiptermid ) { throw new clusterexception ( str_ + lastentry . leadershiptermid + str_ + leadershiptermid ) ; } } indexbyleadershiptermidmap . put ( leadershiptermid , nextentryindex ) ; append ( entry_type_term , recordingid , leadershiptermid , termbaselogposition , null_position , timestamp , null_value ) ; }	Append a log entry for a leadership term.
public void appendsnapshot ( final long recordingid , final long leadershiptermid , final long termbaselogposition , final long logposition , final long timestamp , final int serviceid ) { final int size = entries . size ( ) ; if ( size > num_ ) { final entry entry = entries . get ( size - num_ ) ; if ( entry . type == entry_type_term && entry . leadershiptermid != leadershiptermid ) { throw new clusterexception ( str_ + entry . leadershiptermid + str_ + leadershiptermid ) ; } } append ( entry_type_snapshot , recordingid , leadershiptermid , termbaselogposition , logposition , timestamp , serviceid ) ; }	Append a log entry for a snapshot.
public void commitlogposition ( final long leadershiptermid , final long logposition ) { final int index = getleadershiptermentryindex ( leadershiptermid ) ; commitentryvalue ( index , logposition , log_position_offset ) ; final entry entry = entries . get ( index ) ; entries . set ( index , new entry ( entry . recordingid , entry . leadershiptermid , entry . termbaselogposition , logposition , entry . timestamp , entry . serviceid , entry . type , entry . entryindex ) ) ; }	Commit the position reached in a leadership term before a clean shutdown.
public void tombstoneentry ( final long leadershiptermid , final int entryindex ) { int index = - num_ ; for ( int i = num_ , size = entries . size ( ) ; i < size ; i ++ ) { final entry entry = entries . get ( i ) ; if ( entry . leadershiptermid == leadershiptermid && entry . entryindex == entryindex ) { index = entry . entryindex ; if ( entry_type_term == entry . type ) { indexbyleadershiptermidmap . remove ( leadershiptermid ) ; } break ; } } if ( - num_ == index ) { throw new clusterexception ( str_ + entryindex ) ; } buffer . putint ( num_ , null_value , little_endian ) ; bytebuffer . limit ( size_of_int ) . position ( num_ ) ; final long fileposition = ( index * ( long ) entry_length ) + entry_type_offset ; try { if ( size_of_int != filechannel . write ( bytebuffer , fileposition ) ) { throw new clusterexception ( str_ ) ; } } catch ( final exception ex ) { langutil . rethrowunchecked ( ex ) ; } }	Tombstone an entry in the log so it is no longer valid.
public void close ( ) { if ( null != publication && publication . isconnected ( ) ) { closesession ( ) ; } if ( ! ctx . ownsaeronclient ( ) ) { closehelper . close ( subscription ) ; closehelper . close ( publication ) ; } ctx . close ( ) ; }	Close session and release associated resources.
public long offer ( final directbuffervector [ ] vectors ) { if ( headervector != vectors [ num_ ] ) { vectors [ num_ ] = headervector ; } return publication . offer ( vectors , null ) ; }	Non-blocking publish by gathering buffer vectors into a message.
public static boolean unblock ( final unsafebuffer [ ] termbuffers , final unsafebuffer logmetadatabuffer , final long blockedposition , final int termlength ) { final int positionbitstoshift = logbufferdescriptor . positionbitstoshift ( termlength ) ; final int blockedtermcount = ( int ) ( blockedposition > > positionbitstoshift ) ; final int blockedoffset = ( int ) blockedposition & ( termlength - num_ ) ; final int activetermcount = activetermcount ( logmetadatabuffer ) ; if ( activetermcount == ( blockedtermcount - num_ ) && blockedoffset == num_ ) { final int currenttermid = termid ( rawtailvolatile ( logmetadatabuffer , indexbytermcount ( activetermcount ) ) ) ; return rotatelog ( logmetadatabuffer , activetermcount , currenttermid ) ; } final int blockedindex = indexbytermcount ( blockedtermcount ) ; final long rawtail = rawtailvolatile ( logmetadatabuffer , blockedindex ) ; final int termid = termid ( rawtail ) ; final int tailoffset = termoffset ( rawtail , termlength ) ; final unsafebuffer termbuffer = termbuffers [ blockedindex ] ; switch ( termunblocker . unblock ( logmetadatabuffer , termbuffer , blockedoffset , tailoffset , termid ) ) { case unblocked_to_end : rotatelog ( logmetadatabuffer , blockedtermcount , termid ) ;	Attempt to unblock a log buffer at given position.
public string channel ( ) { final int length = buffer . getint ( offset + channel_offset ) ; lengthofchannel = size_of_int + length ; return buffer . getstringascii ( offset + channel_offset , length ) ; }	Get the channel field as ASCII.
public imagemessageflyweight channel ( final string channel ) { lengthofchannel = buffer . putstringascii ( offset + channel_offset , channel ) ; return this ; }	Set the channel field as ASCII.
public static void checktermlength ( final int termlength ) { if ( termlength < term_min_length ) { throw new illegalstateexception ( str_ + term_min_length + str_ + termlength ) ; } if ( termlength > term_max_length ) { throw new illegalstateexception ( str_ + term_max_length + str_ + termlength ) ; } if ( ! bitutil . ispoweroftwo ( termlength ) ) { throw new illegalstateexception ( str_ + termlength ) ; } }	Check that term length is valid and alignment is valid.
public static void checkpagesize ( final int pagesize ) { if ( pagesize < page_min_size ) { throw new illegalstateexception ( str_ + page_min_size + str_ + pagesize ) ; } if ( pagesize > page_max_size ) { throw new illegalstateexception ( str_ + page_max_size + str_ + pagesize ) ; } if ( ! bitutil . ispoweroftwo ( pagesize ) ) { throw new illegalstateexception ( str_ + pagesize ) ; } }	Check that page size is valid and alignment is valid.
public static boolean casactivetermcount ( final unsafebuffer metadatabuffer , final int expectedtermcount , final int updatetermcount ) { return metadatabuffer . compareandsetint ( log_active_term_count_offset , expectedtermcount , updatetermcount ) ; }	Compare and set the value of the current active term count.
public static long computeposition ( final int activetermid , final int termoffset , final int positionbitstoshift , final int initialtermid ) { final long termcount = activetermid - initialtermid ;	Compute the current position in absolute number of bytes.
public static long computeloglength ( final int termlength , final int filepagesize ) { if ( termlength < ( num_ * num_ * num_ ) ) { return align ( ( termlength * partition_count ) + log_meta_data_length , filepagesize ) ; } return ( partition_count * ( long ) termlength ) + align ( log_meta_data_length , filepagesize ) ; }	Compute the total length of a log file given the term length.Assumes {.
public static void storedefaultframeheader ( final unsafebuffer metadatabuffer , final directbuffer defaultheader ) { if ( defaultheader . capacity ( ) != header_length ) { throw new illegalargumentexception ( str_ + defaultheader . capacity ( ) ) ; } metadatabuffer . putint ( log_default_frame_header_length_offset , header_length ) ; metadatabuffer . putbytes ( log_default_frame_header_offset , defaultheader , num_ , header_length ) ; }	Store the default frame header to the log meta data buffer.
public static void applydefaultheader ( final unsafebuffer metadatabuffer , final unsafebuffer termbuffer , final int termoffset ) { termbuffer . putbytes ( termoffset , metadatabuffer , log_default_frame_header_offset , header_length ) ; }	Apply the default header for a message in a term.
public static boolean rotatelog ( final unsafebuffer metadatabuffer , final int termcount , final int termid ) { final int nexttermid = termid + num_ ; final int nexttermcount = termcount + num_ ; final int nextindex = indexbytermcount ( nexttermcount ) ; final int expectedtermid = nexttermid - partition_count ; long rawtail ; do { rawtail = rawtail ( metadatabuffer , nextindex ) ; if ( expectedtermid != termid ( rawtail ) ) { break ; } } while ( ! casrawtail ( metadatabuffer , nextindex , rawtail , packtail ( nexttermid , num_ ) ) ) ; return casactivetermcount ( metadatabuffer , termcount , nexttermcount ) ; }	Rotate the log and update the tail counter for the new term.This method is safe for concurrent use.
public static void initialisetailwithtermid ( final unsafebuffer metadatabuffer , final int partitionindex , final int termid ) { metadatabuffer . putlong ( term_tail_counters_offset + ( partitionindex * size_of_long ) , packtail ( termid , num_ ) ) ; }	Set the initial value for the termId in the upper bits of the tail counter.
public static int termoffset ( final long rawtail , final long termlength ) { final long tail = rawtail & num_ ; return ( int ) math . min ( tail , termlength ) ; }	Read the termOffset from a packed raw tail value.
public static long rawtailvolatile ( final unsafebuffer metadatabuffer ) { final int partitionindex = indexbytermcount ( activetermcount ( metadatabuffer ) ) ; return metadatabuffer . getlongvolatile ( term_tail_counters_offset + ( size_of_long * partitionindex ) ) ; }	Get the raw value of the tail for the current active partition.
public static boolean casrawtail ( final unsafebuffer metadatabuffer , final int partitionindex , final long expectedrawtail , final long updaterawtail ) { final int index = term_tail_counters_offset + ( size_of_long * partitionindex ) ; return metadatabuffer . compareandsetlong ( index , expectedrawtail , updaterawtail ) ; }	Compare and set the raw value of the tail for the given partition.
public terminatedriverflyweight tokenbuffer ( final directbuffer tokenbuffer , final int tokenoffset , final int tokenlength ) { buffer . putint ( token_length_offset , tokenlength ) ; if ( null != tokenbuffer && tokenlength > num_ ) { buffer . putbytes ( tokenbufferoffset ( ) , tokenbuffer , tokenoffset , tokenlength ) ; } return this ; }	Fill the token buffer.
public static counter allocate ( final aeron aeron , final mutabledirectbuffer tempbuffer , final long leadershiptermid , final long logposition , final long timestamp , final boolean hasreplay , final long ... snapshotrecordingids ) { tempbuffer . putlong ( leadership_term_id_offset , leadershiptermid ) ; tempbuffer . putlong ( log_position_offset , logposition ) ; tempbuffer . putlong ( timestamp_offset , timestamp ) ; tempbuffer . putint ( replay_flag_offset , hasreplay ? num_ : num_ ) ; final int servicecount = snapshotrecordingids . length ; tempbuffer . putint ( service_count_offset , servicecount ) ; final int keylength = snapshot_recording_ids_offset + ( servicecount * size_of_long ) ; if ( keylength > max_key_length ) { throw new clusterexception ( keylength + str_ + max_key_length ) ; } for ( int i = num_ ; i < servicecount ; i ++ ) { tempbuffer . putlong ( snapshot_recording_ids_offset + ( i * size_of_long ) , snapshotrecordingids [ i ] ) ; } final int labeloffset = bitutil . align ( keylength , size_of_int ) ; int labellength = num_ ; labellength += tempbuffer . putstringwithoutlengthascii ( labeloffset + labellength , name ) ; labellength += tempbuffer . putlongascii ( keylength + labellength , leadershiptermid ) ; labellength += tempbuffer . putstringwithoutlengthascii ( labeloffset + labellength , str_ ) ; labellength += tempbuffer . putlongascii ( labeloffset + labellength , logposition ) ; labellength += tempbuffer . putstringwithoutlengthascii ( labeloffset + labellength , str_ + hasreplay ) ; return aeron . addcounter ( recovery_state_type_id , tempbuffer , num_ , keylength , tempbuffer , labeloffset , labellength ) ; }	Allocate a counter to represent the snapshot services should load on start.
public static int findcounterid ( final countersreader counters ) { final directbuffer buffer = counters . metadatabuffer ( ) ; for ( int i = num_ , size = counters . maxcounterid ( ) ; i < size ; i ++ ) { if ( counters . getcounterstate ( i ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( i ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recovery_state_type_id ) { return i ; } } } return null_counter_id ; }	Find the active counter id for recovery state.
public static boolean hasreplay ( final countersreader counters , final int counterid ) { final directbuffer buffer = counters . metadatabuffer ( ) ; if ( counters . getcounterstate ( counterid ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( counterid ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recovery_state_type_id ) { return buffer . getint ( recordoffset + key_offset + replay_flag_offset ) == num_ ; } } return bool_ ; }	Has the recovery process got a log to replay?.
public static long getsnapshotrecordingid ( final countersreader counters , final int counterid , final int serviceid ) { final directbuffer buffer = counters . metadatabuffer ( ) ; if ( counters . getcounterstate ( counterid ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( counterid ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == recovery_state_type_id ) { final int servicecount = buffer . getint ( recordoffset + key_offset + service_count_offset ) ; if ( serviceid < num_ || serviceid >= servicecount ) { throw new clusterexception ( str_ + serviceid + str_ + servicecount ) ; } return buffer . getlong ( recordoffset + key_offset + snapshot_recording_ids_offset + ( serviceid * size_of_long ) ) ; } } throw new clusterexception ( str_ + counterid ) ; }	Get the recording id of the snapshot for a service.
public static char [ ] flagstochars ( final short flags ) { final char [ ] chars = new char [ ] { str_ , str_ , str_ , str_ , str_ , str_ , str_ , str_ } ; final int length = chars . length ; short mask = ( short ) ( num_ << ( length - num_ ) ) ; for ( int i = num_ ; i < length ; i ++ ) { if ( ( flags & mask ) == mask ) { chars [ i ] = str_ ; } mask >>= num_ ; } return chars ; }	Convert header flags to an array of chars to be human readable.
public publicationmessageflyweight channel ( final string channel ) { lengthofchannel = buffer . putstringascii ( offset + channel_offset , channel ) ; return this ; }	Set the channel field in ASCII.
public long offer ( final directbuffer buffer , final int offset , final int length ) { return cluster . offer ( id , responsepublication , buffer , offset , length ) ; }	Non-blocking publish of a partial buffer containing a message to a cluster.
public final void wrap ( final atomicbuffer buffer , final int offset , final int length ) { this . buffer . wrap ( buffer , offset , length ) ; }	Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.
public final void commit ( ) { int framelength = buffer . capacity ( ) ; if ( byteorder . nativeorder ( ) != little_endian ) { framelength = integer . reversebytes ( framelength ) ; } buffer . putintordered ( frame_length_field_offset , framelength ) ; }	Commit the message to the log buffer so that is it available to subscribers.
public final void abort ( ) { int framelength = buffer . capacity ( ) ; if ( byteorder . nativeorder ( ) != little_endian ) { framelength = integer . reversebytes ( framelength ) ; } buffer . putshort ( type_field_offset , ( short ) hdr_type_pad , little_endian ) ; buffer . putintordered ( frame_length_field_offset , framelength ) ; }	Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.
public static void main ( final string [ ] args ) { loadpropertiesfiles ( args ) ; final shutdownsignalbarrier barrier = new shutdownsignalbarrier ( ) ; final mediadriver . context ctx = new mediadriver . context ( ) ; ctx . terminationhook ( barrier :: signal ) ; try ( mediadriver ignore = mediadriver . launch ( ctx ) ) { barrier . await ( ) ; system . out . println ( str_ ) ; } }	Start Media Driver as a stand-alone process.
public void close ( ) { closehelper . close ( sharedrunner ) ; closehelper . close ( sharednetworkrunner ) ; closehelper . close ( receiverrunner ) ; closehelper . close ( senderrunner ) ; closehelper . close ( conductorrunner ) ; closehelper . close ( sharedinvoker ) ; if ( ctx . usewindowshighrestimer ( ) && systemutil . osname ( ) . startswith ( str_ ) ) { if ( ! washighrestimerenabled ) { highresolutiontimer . disable ( ) ; } } }	Shutdown the media driver by stopping all threads and freeing resources.
public final long position ( ) { final int resultingoffset = bitutil . align ( termoffset ( ) + framelength ( ) , frame_alignment ) ; return computeposition ( termid ( ) , resultingoffset , positionbitstoshift , initialtermid ) ; }	Get the current position to which the image has advanced on reading this message.
public static counter allocate ( final aeron aeron , final mutabledirectbuffer tempbuffer , final int serviceid ) { tempbuffer . putint ( service_id_offset , serviceid ) ; final int labeloffset = bitutil . align ( key_length , size_of_int ) ; int labellength = num_ ; labellength += tempbuffer . putstringwithoutlengthascii ( labeloffset + labellength , name ) ; labellength += tempbuffer . putintascii ( labeloffset + labellength , serviceid ) ; return aeron . addcounter ( service_heartbeat_type_id , tempbuffer , num_ , key_length , tempbuffer , labeloffset , labellength ) ; }	Allocate a counter to represent the heartbeat of a clustered service.
public static int findcounterid ( final countersreader counters , final int serviceid ) { final directbuffer buffer = counters . metadatabuffer ( ) ; for ( int i = num_ , size = counters . maxcounterid ( ) ; i < size ; i ++ ) { if ( counters . getcounterstate ( i ) == record_allocated ) { final int recordoffset = countersreader . metadataoffset ( i ) ; if ( buffer . getint ( recordoffset + type_id_offset ) == service_heartbeat_type_id && buffer . getint ( recordoffset + key_offset + service_id_offset ) == serviceid ) { return i ; } } } return null_counter_id ; }	Find the active counter id for heartbeat of a given service id.
public static atomiccounter allocate ( final mutabledirectbuffer tempbuffer , final string name , final int typeid , final countersmanager countersmanager , final long registrationid ) { return new atomiccounter ( countersmanager . valuesbuffer ( ) , allocatecounterid ( tempbuffer , name , typeid , countersmanager , registrationid ) , countersmanager ) ; }	Allocate a counter for tracking the last heartbeat of an entity.
public void close ( ) { final mappedbytebuffer cncbytebuffer = this . cncbytebuffer ; this . cncbytebuffer = null ; ioutil . unmap ( cncbytebuffer ) ; super . close ( ) ; }	Clean up all resources that the client uses to communicate with the Media Driver.
public static void dispatchdescriptor ( final recordingdescriptordecoder decoder , final recordingdescriptorconsumer consumer ) { consumer . onrecordingdescriptor ( decoder . controlsessionid ( ) , decoder . correlationid ( ) , decoder . recordingid ( ) , decoder . starttimestamp ( ) , decoder . stoptimestamp ( ) , decoder . startposition ( ) , decoder . stopposition ( ) , decoder . initialtermid ( ) , decoder . segmentfilelength ( ) , decoder . termbufferlength ( ) , decoder . mtulength ( ) , decoder . sessionid ( ) , decoder . streamid ( ) , decoder . strippedchannel ( ) , decoder . originalchannel ( ) , decoder . sourceidentity ( ) ) ; }	Dispatch a descriptor message to a consumer by reading the fields in the correct order.
private void addslab ( int minimumsize ) { int nextslabsize ; if ( bytesused == num_ ) { nextslabsize = initialslabsize ; } else if ( bytesused > maxcapacityhint / num_ ) {	the new slab is guaranteed to be at least minimumSize.
public void setbyte ( long index , byte value ) { checkargument ( index < bytesused , str_ + index + str_ + bytesused ) ; long seen = num_ ; for ( int i = num_ ; i < slabs . size ( ) ; i ++ ) { bytebuffer slab = slabs . get ( i ) ; if ( index < seen + slab . limit ( ) ) {	Replace the byte stored at position index in this stream with value.
public void add ( statistics < ? > stats ) { if ( stats . hasnonnullvalue ( ) ) { nullpages . add ( bool_ ) ; object min = stats . genericgetmin ( ) ; object max = stats . genericgetmax ( ) ; addminmax ( min , max ) ; pageindexes . add ( nextpageindex ) ; minmaxsize += sizeof ( min ) ; minmaxsize += sizeof ( max ) ; } else { nullpages . add ( bool_ ) ; } nullcounts . add ( stats . getnumnulls ( ) ) ; ++ nextpageindex ; }	Adds the data from the specified statistics to this builder.
private static grouptype convertarraytype ( final string name , final listtypeinfo typeinfo ) { final typeinfo subtype = typeinfo . getlistelementtypeinfo ( ) ; return listwrapper ( name , listtype ( ) , new grouptype ( repetition . repeated , parquethiveserde . array . tostring ( ) , converttype ( str_ , subtype ) ) ) ; }	1 anonymous element "array_element".
private static grouptype convertstructtype ( final string name , final structtypeinfo typeinfo ) { final list < string > columnnames = typeinfo . getallstructfieldnames ( ) ; final list < typeinfo > columntypes = typeinfo . getallstructfieldtypeinfos ( ) ; return new grouptype ( repetition . optional , name , converttypes ( columnnames , columntypes ) ) ; }	An optional group containing multiple elements.
private static string annotatemessage ( string message , int pos ) { stringbuilder sb = new stringbuilder ( message ) ; sb . append ( str_ ) ; for ( int i = num_ ; i < pos ; i ++ ) { sb . append ( str_ ) ; } sb . append ( str_ ) ; return sb . tostring ( ) ; }	for pretty printing which character had the error.
private void endpreviousbitpackedrun ( ) { if ( bitpackedrunheaderpointer == - num_ ) {	If we are currently writing a bit-packed-run, update thebit-packed-header and consider this run to be overdoes nothing if we're not currently writing a bit-packed run.
@ override public void readone ( tprotocol in , tprotocol out ) throws texception { readonestruct ( in , out ) ; }	reads one record from in and writes it to outexceptions are not recoverable as record might be halfway written.
@ deprecated public static list < footer > readfooters ( configuration configuration , filestatus pathstatus ) throws ioexception { return readfooters ( configuration , pathstatus , bool_ ) ; }	this always returns the row groups.
@ deprecated public static list < footer > readsummaryfile ( configuration configuration , filestatus summarystatus ) throws ioexception { final path parent = summarystatus . getpath ( ) . getparent ( ) ; parquetmetadata mergedfooters = readfooter ( configuration , summarystatus , filter ( bool_ ) ) ; return footersfromsummaryfile ( parent , mergedfooters ) ; }	Specifically reads a given summary file.
@ deprecated public static final parquetmetadata readfooter ( inputfile file , metadatafilter filter ) throws ioexception { parquetreadoptions options ; if ( file instanceof hadoopinputfile ) { options = hadoopreadoptions . builder ( ( ( hadoopinputfile ) file ) . getconfiguration ( ) ) . withmetadatafilter ( filter ) . build ( ) ; } else { options = parquetreadoptions . builder ( ) . withmetadatafilter ( filter ) . build ( ) ; } try ( seekableinputstream in = file . newstream ( ) ) { return readfooter ( file , options , in ) ; } }	Reads the meta data block in the footer of the file using provided input stream.
public pagereadstore readnextrowgroup ( ) throws ioexception { if ( currentblock == blocks . size ( ) ) { return null ; } blockmetadata block = blocks . get ( currentblock ) ; if ( block . getrowcount ( ) == num_ ) { throw new runtimeexception ( str_ ) ; } this . currentrowgroup = new columnchunkpagereadstore ( block . getrowcount ( ) ) ;	Reads all the columns requested from the row group at the current file position.
public pagereadstore readnextfilteredrowgroup ( ) throws ioexception { if ( currentblock == blocks . size ( ) ) { return null ; } if ( ! options . usecolumnindexfilter ( ) ) { return readnextrowgroup ( ) ; } blockmetadata block = blocks . get ( currentblock ) ; if ( block . getrowcount ( ) == num_ ) { throw new runtimeexception ( str_ ) ; } columnindexstore cistore = getcolumnindexstore ( currentblock ) ; rowranges rowranges = getrowranges ( currentblock ) ; long rowcount = rowranges . rowcount ( ) ; if ( rowcount == num_ ) {	Reads all the columns requested from the row group at the current file position.
dictionarypage readdictionary ( columnchunkmetadata meta ) throws ioexception { if ( ! meta . getencodings ( ) . contains ( encoding . plain_dictionary ) && ! meta . getencodings ( ) . contains ( encoding . rle_dictionary ) ) { return null ; }	Reads and decompresses a dictionary page for the given column chunk.Returns null if the given column chunk has no dictionary page.
synchronized void addwriter ( internalparquetrecordwriter writer , long allocation ) { long oldvalue = writerlist . get ( writer ) ; if ( oldvalue == null ) { writerlist . put ( writer , allocation ) ; } else { throw new illegalargumentexception ( str_ + str_ + str_ + writer ) ; } updateallocation ( ) ; }	Add a new writer and its memory allocation to the memory manager.
synchronized void removewriter ( internalparquetrecordwriter writer ) { if ( writerlist . containskey ( writer ) ) { writerlist . remove ( writer ) ; } if ( ! writerlist . isempty ( ) ) { updateallocation ( ) ; } }	Remove the given writer from the memory manager.
private void updateallocation ( ) { long totalallocations = num_ ; for ( long allocation : writerlist . values ( ) ) { totalallocations += allocation ; } if ( totalallocations <= totalmemorypool ) { scale = num_ ; } else { scale = ( double ) totalmemorypool / totalallocations ; log . warn ( string . format ( str_ + str_ , num_ * memorypoolratio , totalmemorypool , num_ * scale , writerlist . size ( ) ) ) ; for ( runnable callback : callbacks . values ( ) ) {	Update the allocated size of each writer based on the current allocations and pool size.
public void registerscalecallback ( string callbackname , runnable callback ) { preconditions . checknotnull ( callbackname , str_ ) ; preconditions . checknotnull ( callback , str_ ) ; if ( callbacks . containskey ( callbackname ) ) { throw new illegalargumentexception ( str_ + callbackname + str_ ) ; } else { callbacks . put ( callbackname , callback ) ; } }	Register callback and deduplicate it if any.
public void start ( ) throws ioexception { state = state . start ( ) ; log . debug ( str_ , out . getpos ( ) ) ; out . write ( magic ) ; }	start the file.
public void startblock ( long recordcount ) throws ioexception { state = state . startblock ( ) ; log . debug ( str_ , out . getpos ( ) ) ;	start a block.
public void startcolumn ( columndescriptor descriptor , long valuecount , compressioncodecname compressioncodecname ) throws ioexception { state = state . startcolumn ( ) ; encodingstatsbuilder . clear ( ) ; currentencodings = new hashset < encoding > ( ) ; currentchunkpath = columnpath . get ( descriptor . getpath ( ) ) ; currentchunktype = descriptor . getprimitivetype ( ) ; currentchunkcodec = compressioncodecname ; currentchunkvaluecount = valuecount ; currentchunkfirstdatapage = out . getpos ( ) ; compressedlength = num_ ; uncompressedlength = num_ ;	start a column inside a block.
public void writedictionarypage ( dictionarypage dictionarypage ) throws ioexception { state = state . write ( ) ; log . debug ( str_ , out . getpos ( ) , dictionarypage . getdictionarysize ( ) ) ; currentchunkdictionarypageoffset = out . getpos ( ) ; int uncompressedsize = dictionarypage . getuncompressedsize ( ) ; int compressedpagesize = ( int ) dictionarypage . getbytes ( ) . size ( ) ;	writes a dictionary page page.
public void writedatapage ( int valuecount , int uncompressedpagesize , bytesinput bytes , statistics statistics , long rowcount , encoding rlencoding , encoding dlencoding , encoding valuesencoding ) throws ioexception { long beforeheader = out . getpos ( ) ; innerwritedatapage ( valuecount , uncompressedpagesize , bytes , statistics , rlencoding , dlencoding , valuesencoding ) ; offsetindexbuilder . add ( ( int ) ( out . getpos ( ) - beforeheader ) , rowcount ) ; }	Writes a single page.
public void endblock ( ) throws ioexception { state = state . endblock ( ) ; log . debug ( str_ , out . getpos ( ) ) ; currentblock . setrowcount ( currentrecordcount ) ; blocks . add ( currentblock ) ; columnindexes . add ( currentcolumnindexes ) ; offsetindexes . add ( currentoffsetindexes ) ; currentcolumnindexes = null ; currentoffsetindexes = null ; currentblock = null ; }	ends a block once all column chunks have been written.
private static void copy ( seekableinputstream from , positionoutputstream to , long start , long length ) throws ioexception { log . debug ( str_ , length , start , to . getpos ( ) ) ; from . seek ( start ) ; long bytescopied = num_ ; byte [ ] buffer = copy_buffer . get ( ) ; while ( bytescopied < length ) { long bytesleft = length - bytescopied ; int bytesread = from . read ( buffer , num_ , ( buffer . length < bytesleft ? buffer . length : ( int ) bytesleft ) ) ; if ( bytesread < num_ ) { throw new illegalargumentexception ( str_ + start + bytescopied ) ; } to . write ( buffer , num_ , bytesread ) ; bytescopied += bytesread ; } }	Copy from a FS input stream to an output stream. Thread-safe.
public void end ( map < string , string > extrametadata ) throws ioexception { state = state . end ( ) ; serializecolumnindexes ( columnindexes , blocks , out ) ; serializeoffsetindexes ( offsetindexes , blocks , out ) ; log . debug ( str_ , out . getpos ( ) ) ; this . footer = new parquetmetadata ( new filemetadata ( schema , extrametadata , version . full_version ) , blocks ) ; serializefooter ( footer , out ) ; out . close ( ) ; }	ends a file once all blocks have been written.closes the file.
@ deprecated public static parquetmetadata mergemetadatafiles ( list < path > files , configuration conf ) throws ioexception { preconditions . checkargument ( ! files . isempty ( ) , str_ ) ; globalmetadata globalmetadata = null ; list < blockmetadata > blocks = new arraylist < blockmetadata > ( ) ; for ( path p : files ) { parquetmetadata pmd = parquetfilereader . readfooter ( conf , p , parquetmetadataconverter . no_filter ) ; filemetadata fmd = pmd . getfilemetadata ( ) ; globalmetadata = mergeinto ( fmd , globalmetadata , bool_ ) ; blocks . addall ( pmd . getblocks ( ) ) ; }	Given a list of metadata files, merge them into a single ParquetMetadataRequires that the schemas be compatible, and the extraMetadata be exactly equal.
@ deprecated public static void writemergedmetadatafile ( list < path > files , path outputpath , configuration conf ) throws ioexception { parquetmetadata merged = mergemetadatafiles ( files , conf ) ; writemetadatafile ( outputpath , merged , outputpath . getfilesystem ( conf ) ) ; }	Given a list of metadata files, merge them into a single metadata file.Requires that the schemas be compatible, and the extraMetaData be exactly equal.This is useful when merging 2 directories of parquet files into a single directory, as longas both directories were written with compatible schemas and equal extraMetaData.
@ deprecated public static void writemetadatafile ( configuration configuration , path outputpath , list < footer > footers ) throws ioexception { writemetadatafile ( configuration , outputpath , footers , jobsummarylevel . all ) ; }	writes a _metadata and _common_metadata file.
static globalmetadata mergeinto ( filemetadata tomerge , globalmetadata mergedmetadata ) { return mergeinto ( tomerge , mergedmetadata , bool_ ) ; }	Will return the result of merging toMerge into mergedMetadata.
public void readvalue ( ) { try { if ( ! valueread ) { binding . read ( ) ; valueread = bool_ ; } } catch ( runtimeexception e ) { if ( corruptdeltabytearrays . requiressequentialreads ( writerversion , currentencoding ) && e instanceof arrayindexoutofboundsexception ) {	Reads the value into the binding.
public static boolean nullok ( schema schema ) { if ( schema . type . null == schema . gettype ( ) ) { return bool_ ; } else if ( schema . type . union == schema . gettype ( ) ) { for ( schema possible : schema . gettypes ( ) ) { if ( nullok ( possible ) ) { return bool_ ; } } } return bool_ ; }	Returns whether null is allowed by the schema.
@ safevarargs private static < e > e coalesce ( e ... objects ) { for ( e object : objects ) { if ( object != null ) { return object ; } } return null ; }	Returns the first non-null object that is passed in.
private static object makevalue ( string string , schema schema ) { if ( string == null ) { return null ; } try { switch ( schema . gettype ( ) ) { case boolean : return boolean . valueof ( string ) ; case string : return string ; case float : return float . valueof ( string ) ; case double : return double . valueof ( string ) ; case int : return integer . valueof ( string ) ; case long : return long . valueof ( string ) ; case enum :	Returns a the value as the first matching schema type or null.Note that if the value may be null even if the schema does not allow thevalue to be null.
public static thriftmetadata fromextrametadata ( map < string , string > extrametadata ) { final string thriftclassname = extrametadata . get ( thrift_class ) ; final string thriftdescriptorstring = extrametadata . get ( thrift_descriptor ) ; if ( thriftclassname == null || thriftdescriptorstring == null ) { return null ; } final structtype descriptor = parsedescriptor ( thriftdescriptorstring ) ; return new thriftmetadata ( thriftclassname , descriptor ) ; }	Reads ThriftMetadata from the parquet file footer.
@ suppresswarnings ( str_ ) public static thriftmetadata fromthriftclass ( class < ? > thriftclass ) { if ( thriftclass != null && tbase . class . isassignablefrom ( thriftclass ) ) { class < ? extends tbase < ? , ? > > tclass = ( class < ? extends tbase < ? , ? > > ) thriftclass ; structtype descriptor = new thriftschemaconverter ( ) . tostructtype ( tclass ) ; return new thriftmetadata ( thriftclass . getname ( ) , descriptor ) ; } return null ; }	Creates ThriftMetaData from a Thrift-generated class.
public map < string , string > toextrametadata ( ) { final map < string , string > map = new hashmap < string , string > ( ) ; map . put ( thrift_class , getthriftclass ( ) . getname ( ) ) ; map . put ( thrift_descriptor , descriptor . tojson ( ) ) ; return map ; }	generates a map of key values to store in the footer.
@ override public void writenull ( int repetitionlevel , int definitionlevel ) { if ( debug ) log ( null , repetitionlevel , definitionlevel ) ; repetitionlevel ( repetitionlevel ) ; definitionlevel ( definitionlevel ) ; statistics . incrementnumnulls ( ) ; ++ valuecount ; }	Writes the current null value.
void writepage ( ) { if ( valuecount == num_ ) { throw new parquetencodingexception ( str_ ) ; } this . rowswrittensofar += pagerowcount ; if ( debug ) log . debug ( str_ ) ; try { writepage ( pagerowcount , valuecount , statistics , repetitionlevelcolumn , definitionlevelcolumn , datacolumn ) ; } catch ( ioexception e ) { throw new parquetencodingexception ( str_ + path , e ) ; } repetitionlevelcolumn . reset ( ) ; definitionlevelcolumn . reset ( ) ; datacolumn . reset ( ) ; valuecount = num_ ; resetstatistics ( ) ; pagerowcount = num_ ; }	Writes the current data to a new page in the page store.
@ override public void initfrompage ( int valuecount , bytebufferinputstream stream ) throws ioexception { this . in = stream ; long startpos = in . position ( ) ; this . config = deltabinarypackingconfig . readconfig ( in ) ; this . totalvaluecount = bytesutils . readunsignedvarint ( in ) ; allocatevaluesbuffer ( ) ; bitwidths = new int [ config . miniblocknuminablock ] ;	eagerly loads all the data into memory.
private void allocatevaluesbuffer ( ) { int totalminiblockcount = ( int ) math . ceil ( ( double ) totalvaluecount / config . miniblocksizeinvalues ) ;	the value buffer is allocated so that the size of it is multiple of mini blockbecause when writing, data is flushed on a mini block basis.
private void checkenum ( thrifttype expectedtype , int i ) { if ( expectedtype . gettype ( ) == thrifttypeid . enum ) { thrifttype . enumtype expectedenumtype = ( thrifttype . enumtype ) expectedtype ; if ( expectedenumtype . getenumvaluebyid ( i ) == null ) { throw new decodingschemamismatchexception ( str_ + i + str_ + expectedtype ) ; } } }	In thrift enum values are written as ints, this method checks if the enum index is defined.
private void calculatebitwidthsfordeltablockbuffer ( int miniblockstoflush ) { for ( int miniblockindex = num_ ; miniblockindex < miniblockstoflush ; miniblockindex ++ ) { int mask = num_ ; int ministart = miniblockindex * config . miniblocksizeinvalues ;	iterate through values in each mini block and calculate the bitWidths of max values.
public static < e extends exception > void throwifinstance ( throwable t , class < e > excclass ) throws e { if ( excclass . isassignablefrom ( t . getclass ( ) ) ) {	If the given throwable is an instance of E, throw it as an E.
@ deprecated public static statistics getstatsbasedontype ( primitivetypename type ) { switch ( type ) { case int32 : return new intstatistics ( ) ; case int64 : return new longstatistics ( ) ; case float : return new floatstatistics ( ) ; case double : return new doublestatistics ( ) ; case boolean : return new booleanstatistics ( ) ; case binary : return new binarystatistics ( ) ; case int96 : return new binarystatistics ( ) ; case fixed_len_byte_array : return new binarystatistics ( ) ; default : throw new unknowncolumntypeexception ( type ) ; } }	Returns the typed statistics object based on the passed type parameter.
public static builder getbuilderforreading ( primitivetype type ) { switch ( type . getprimitivetypename ( ) ) { case float : return new floatbuilder ( type ) ; case double : return new doublebuilder ( type ) ; default : return new builder ( type ) ; } }	Returns a builder to create new statistics object.
public void mergestatistics ( statistics stats ) { if ( stats . isempty ( ) ) return ;	Method to merge this statistics object with the object passedas parameter.
public static schema getnonnull ( schema schema ) { if ( schema . gettype ( ) . equals ( schema . type . union ) ) { list < schema > schemas = schema . gettypes ( ) ; if ( schemas . size ( ) == num_ ) { if ( schemas . get ( num_ ) . gettype ( ) . equals ( schema . type . null ) ) { return schemas . get ( num_ ) ; } else if ( schemas . get ( num_ ) . gettype ( ) . equals ( schema . type . null ) ) { return schemas . get ( num_ ) ; } else { return schema ; } } else { return schema ; } } else { return schema ; } }	Given a schema, check to see if it is a union of a null type and a regular schema,and then return the non-null sub-schema.
public static taskattemptcontext newtaskattemptcontext ( configuration conf , taskattemptid taskattemptid ) { try { return ( taskattemptcontext ) task_context_constructor . newinstance ( conf , taskattemptid ) ; } catch ( instantiationexception e ) { throw new illegalargumentexception ( str_ , e ) ; } catch ( illegalaccessexception e ) { throw new illegalargumentexception ( str_ , e ) ; } catch ( invocationtargetexception e ) { throw new illegalargumentexception ( str_ , e ) ; } }	Creates TaskAttemptContext from a JobConf and jobId using the correctconstructor for based on Hadoop version.
private static object invoke ( method method , object obj , object ... args ) { try { return method . invoke ( obj , args ) ; } catch ( illegalaccessexception e ) { throw new illegalargumentexception ( str_ + method . getname ( ) , e ) ; } catch ( invocationtargetexception e ) { throw new illegalargumentexception ( str_ + method . getname ( ) , e ) ; } }	Invokes a method and rethrows any exception as runtime exceptions.
void membersdisplaystring ( stringbuilder sb , string indent ) { for ( type field : fields ) { field . writetostringbuilder ( sb , indent ) ; if ( field . isprimitive ( ) ) { sb . append ( str_ ) ; } sb . append ( str_ ) ; } }	appends a display string for of the members of this group to sb.
list < type > mergefields ( grouptype tomerge , boolean strict ) { list < type > newfields = new arraylist < type > ( ) ;	produces the list of fields resulting from merging toMerge into the fields of this.
public static void initcounterfromreporter ( reporter reporter , configuration configuration ) { counterloader = new mapredcounterloader ( reporter , configuration ) ; loadcounters ( ) ; }	Init counters in hadoop's mapred API, which is used by cascading and Hive.
public static filter getfilter ( configuration conf ) { return filtercompat . get ( getfilterpredicate ( conf ) , getunboundrecordfilterinstance ( conf ) ) ; }	Returns a non-null Filter, which is a wrapper around either aFilterPredicate, an UnboundRecordFilter, or a no-op filter.
public list < footer > getfooters ( configuration configuration , collection < filestatus > statuses ) throws ioexception { log . debug ( str_ , statuses . size ( ) ) ; boolean tasksidemetadata = istasksidemetadata ( configuration ) ; return parquetfilereader . readallfootersinparallelusingsummaryfiles ( configuration , statuses , tasksidemetadata ) ; }	the footers for the files.
static < t > list < parquetinputsplit > generatesplits ( list < blockmetadata > rowgroupblocks , blocklocation [ ] hdfsblocksarray , filestatus filestatus , string requestedschema , map < string , string > readsupportmetadata , long minsplitsize , long maxsplitsize ) throws ioexception { list < splitinfo > splitrowgroups = generatesplitinfo ( rowgroupblocks , hdfsblocksarray , minsplitsize , maxsplitsize ) ;	groups together all the data blocks for the same HDFS block.
@ override public void write ( t record ) { recordconsumer . startmessage ( ) ; try { messagewriter . writetoplevelmessage ( record ) ; } catch ( runtimeexception e ) { message m = ( record instanceof message . builder ) ? ( ( message . builder ) record ) . build ( ) : ( message ) record ; log . error ( str_ + e . getmessage ( ) + str_ + m ) ; throw e ; } recordconsumer . endmessage ( ) ; }	Writes Protocol buffer to parquet file.
private void validatedmapping ( descriptor descriptor , grouptype parquetschema ) { list < fielddescriptor > allfields = descriptor . getfields ( ) ; for ( fielddescriptor fielddescriptor : allfields ) { string fieldname = fielddescriptor . getname ( ) ; int fieldindex = fielddescriptor . getindex ( ) ; int parquetindex = parquetschema . getfieldindex ( fieldname ) ; if ( fieldindex != parquetindex ) { string message = str_ + fieldname + str_ + fieldindex + str_ + parquetindex ; throw new incompatibleschemamodificationexception ( message ) ; } } }	validates mapping between protobuffer fields and parquet fields.
private string serializedescriptor ( class < ? extends message > protoclass ) { descriptor descriptor = protobufs . getmessagedescriptor ( protoclass ) ; descriptorprotos . descriptorproto asproto = descriptor . toproto ( ) ; return textformat . printtostring ( asproto ) ; }	Returns message descriptor as JSON String.
public list < tprotocol > amendmissingrequiredfields ( structtype recordthrifttype ) throws texception { iterator < tprotocol > protocoliter = rootevents . iterator ( ) ; checkstruct ( protocoliter , recordthrifttype ) ; return fixedevents ; }	Given a thrift definition, protocols events, it checks all the required fields,and create default value if a required field is missing.
private void checkset ( iterator < tprotocol > eventiter , thriftfield setfielddefinition ) throws texception { tset thriftset = acceptprotocol ( eventiter . next ( ) ) . readsetbegin ( ) ; thriftfield elementfielddefinition = ( ( thrifttype . settype ) setfielddefinition . gettype ( ) ) . getvalues ( ) ; int setsize = thriftset . size ; for ( int i = num_ ; i < setsize ; i ++ ) { checkfield ( thriftset . elemtype , eventiter , elementfielddefinition ) ; } acceptprotocol ( eventiter . next ( ) ) . readsetend ( ) ; }	check each element of the Set, make sure all the element contain required fields.
public static filemetadata readfilemetadata ( inputstream from , boolean skiprowgroups ) throws ioexception { filemetadata md = new filemetadata ( ) ; if ( skiprowgroups ) { readfilemetadata ( from , new defaultfilemetadataconsumer ( md ) , skiprowgroups ) ; } else { read ( from , md ) ; } return md ; }	reads the meta data from the stream.
@ override public void close ( ) throws ioexception { try { recordwriter . close ( taskattemptcontext ) ; } catch ( interruptedexception e ) { thread . interrupted ( ) ; throw new ioexception ( str_ , e ) ; } }	close the file.
public static void setschema ( job job , messagetype schema ) { groupwritesupport . setschema ( schema , contextutil . getconfiguration ( job ) ) ; }	set the schema being written to the job conf.
private static void add ( class < ? > c , primitivetypename p ) { set < primitivetypename > descriptors = classtoparquettype . get ( c ) ; if ( descriptors == null ) { descriptors = new hashset < primitivetypename > ( ) ; classtoparquettype . put ( c , descriptors ) ; } descriptors . add ( p ) ; set < class < ? > > classes = parquettypetoclass . get ( p ) ; if ( classes == null ) { classes = new hashset < class < ? > > ( ) ; parquettypetoclass . put ( p , classes ) ; } classes . add ( c ) ; }	set up the mapping in both directions.
public static < t extends comparable < t > > void asserttypevalid ( column < t > foundcolumn , primitivetypename primitivetype ) { class < t > foundcolumntype = foundcolumn . getcolumntype ( ) ; columnpath columnpath = foundcolumn . getcolumnpath ( ) ; set < primitivetypename > validtypedescriptors = classtoparquettype . get ( foundcolumntype ) ; if ( validtypedescriptors == null ) { stringbuilder message = new stringbuilder ( ) ; message . append ( str_ ) . append ( columnpath . todotstring ( ) ) . append ( str_ ) . append ( foundcolumntype . getname ( ) ) . append ( str_ ) ; set < class < ? > > supportedtypes = parquettypetoclass . get ( primitivetype ) ; if ( supportedtypes != null ) { message . append ( str_ ) . append ( supportedtypes ) ; } else { message . append ( str_ + primitivetype ) ; } throw new illegalargumentexception ( message . tostring ( ) ) ; } if ( ! validtypedescriptors . contains ( primitivetype ) ) { stringbuilder message = new stringbuilder ( ) ; message . append ( str_ ) . append ( columnpath . todotstring ( ) ) . append ( str_ ) . append ( foundcolumntype . getname ( ) ) . append ( str_ ) . append ( columnpath . todotstring ( ) ) . append ( str_ ) . append ( primitivetype ) . append ( str_ ) . append ( parquettypetoclass . get ( primitivetype ) ) ; throw new illegalargumentexception ( message . tostring ( ) ) ; } }	Asserts that foundColumn was declared as a type that is compatible with the type for this column foundin the schema of the parquet file.
public static int checkedcast ( long value ) { int valuei = ( int ) value ; if ( valuei != value ) { throw new illegalargumentexception ( string . format ( str_ , value ) ) ; } return valuei ; }	Cast value to a an int, or throw an exceptionif there is an overflow.
public schemamapping fromarrow ( schema arrowschema ) { list < field > fields = arrowschema . getfields ( ) ; list < typemapping > parquetfields = fromarrow ( fields ) ; messagetype parquettype = addtobuilder ( parquetfields , types . buildmessage ( ) ) . named ( str_ ) ; return new schemamapping ( arrowschema , parquettype , parquetfields ) ; }	Creates a Parquet Schema from an Arrow one and returns the mapping.
public schemamapping fromparquet ( messagetype parquetschema ) { list < type > fields = parquetschema . getfields ( ) ; list < typemapping > mappings = fromparquet ( fields ) ; list < field > arrowfields = fields ( mappings ) ; return new schemamapping ( new schema ( arrowfields ) , parquetschema , mappings ) ; }	Creates an Arrow Schema from an Parquet one and returns the mapping.
public schemamapping map ( schema arrowschema , messagetype parquetschema ) { list < typemapping > children = map ( arrowschema . getfields ( ) , parquetschema . getfields ( ) ) ; return new schemamapping ( arrowschema , parquetschema , children ) ; }	Maps a Parquet and Arrow SchemaFor now does not validate primitive type compatibility.
@ deprecated public void writedatapagev2header ( int uncompressedsize , int compressedsize , int valuecount , int nullcount , int rowcount , org . apache . parquet . column . statistics . statistics statistics , org . apache . parquet . column . encoding dataencoding , int rlbytelength , int dlbytelength , outputstream to ) throws ioexception { writepageheader ( newdatapagev2header ( uncompressedsize , compressedsize , valuecount , nullcount , rowcount , dataencoding , rlbytelength , dlbytelength ) , to ) ; }	Statistics are no longer saved in page headers.
private void skiptomatch ( ) { while ( recordsread < recordcount && ! recordfilter . ismatch ( ) ) { state currentstate = getstate ( num_ ) ; do { columnreader columnreader = currentstate . column ;	Skips forwards until the filter finds the first match.
public static void writeobjecttoconfasbase64 ( string key , object obj , configuration conf ) throws ioexception { try ( bytearrayoutputstream baos = new bytearrayoutputstream ( ) ) { try ( gzipoutputstream gos = new gzipoutputstream ( baos ) ; objectoutputstream oos = new objectoutputstream ( gos ) ) { oos . writeobject ( obj ) ; } conf . set ( key , new string ( base64 . encodebase64 ( baos . tobytearray ( ) ) , standardcharsets . utf_8 ) ) ; } }	Writes an object to a configuration.
public v remove ( final k key ) { v oldvalue = cachemap . remove ( key ) ; if ( oldvalue != null ) { log . debug ( str_ , key ) ; } return oldvalue ; }	Removes the mapping for the specified key from this cache if present.
public void put ( final k key , final v newvalue ) { if ( newvalue == null || ! newvalue . iscurrent ( key ) ) { if ( log . iswarnenabled ( ) ) { log . warn ( str_ , key , ( newvalue == null ? str_ : str_ ) ) ; } return ; } v oldvalue = cachemap . get ( key ) ; if ( oldvalue != null && oldvalue . isnewerthan ( newvalue ) ) { if ( log . iswarnenabled ( ) ) { log . warn ( str_ + str_ , key ) ; } return ; }	Associates the specified value with the specified key in this cache.
public v getcurrentvalue ( final k key ) { v value = cachemap . get ( key ) ; log . debug ( str_ , key , ( value == null ? str_ : str_ ) ) ; if ( value != null && ! value . iscurrent ( key ) ) {	Returns the value to which the specified key is mapped, or null if 1) thevalue is not current or 2) this cache contains no mapping for the key.
private void writevalue ( type type , schema avroschema , object value ) { schema nonnullavroschema = avroschemaconverter . getnonnull ( avroschema ) ; logicaltype logicaltype = nonnullavroschema . getlogicaltype ( ) ; if ( logicaltype != null ) { conversion < ? > conversion = model . getconversionbyclass ( value . getclass ( ) , logicaltype ) ; writevaluewithoutconversion ( type , nonnullavroschema , convert ( nonnullavroschema , logicaltype , conversion , value ) ) ; } else { writevaluewithoutconversion ( type , nonnullavroschema , value ) ; } }	Calls an appropriate write method based on the value.Value MUST not be null.
public void set ( string glob ) { stringbuilder regex = new stringbuilder ( ) ; int setopen = num_ ; int curlyopen = num_ ; int len = glob . length ( ) ; haswildcard = bool_ ; for ( int i = num_ ; i < len ; i ++ ) { char c = glob . charat ( i ) ; switch ( c ) { case backslash : if ( ++ i >= len ) { error ( str_ , glob , i ) ; } regex . append ( c ) . append ( glob . charat ( i ) ) ; continue ; case str_ : case str_ : case str_ : case str_ : case str_ : case str_ :	Set and compile a glob pattern.
public void output ( string content , logger console , string filename ) throws ioexception { if ( filename == null || str_ . equals ( filename ) ) { console . info ( content ) ; } else { fsdataoutputstream outgoing = create ( filename ) ; try { outgoing . write ( content . getbytes ( standardcharsets . utf_8 ) ) ; } finally { outgoing . close ( ) ; } } }	Output content to the console or a file.This will not produce checksum files.
public inputstream open ( string filename ) throws ioexception { if ( stdin_as_source . equals ( filename ) ) { return system . in ; } uri uri = qualifieduri ( filename ) ; if ( resource_uri_scheme . equals ( uri . getscheme ( ) ) ) { return resources . getresource ( uri . getrawschemespecificpart ( ) ) . openstream ( ) ; } else { path filepath = new path ( uri ) ;	Opens an existing file or resource.If the file does not have a file system scheme, this uses the default FS.
public static final unboundrecordfilter column ( final string columnpath , final columnpredicates . predicate predicate ) { checknotnull ( columnpath , str_ ) ; checknotnull ( predicate , str_ ) ; return new unboundrecordfilter ( ) { final string [ ] filterpath = columnpath . split ( str_ ) ; @ override public recordfilter bind ( iterable < columnreader > readers ) { for ( columnreader reader : readers ) { if ( arrays . equals ( reader . getdescriptor ( ) . getpath ( ) , filterpath ) ) { return new columnrecordfilter ( reader , predicate ) ; } } throw new illegalargumentexception ( str_ + columnpath + str_ ) ; } } ; }	Factory method for record filter which applies the supplied predicate to the specified column.Note that if searching for a repeated sub-attribute it will only ever match against thefirst instance of it in the object.
public messagetype convert ( structtype struct ) { messagetype messagetype = thriftschemaconvertvisitor . convert ( struct , fieldprojectionfilter , bool_ ) ; fieldprojectionfilter . assertnounmatchedpatterns ( ) ; return messagetype ; }	struct is assumed to contain valid structOrUnionType metadata when used with this method.This method may throw if structOrUnionType is unknown.Use convertWithoutProjection below to convert a StructType to MessageType.
private static grouptype listwrapper ( repetition repetition , string alias , logicaltypeannotation logicaltypeannotation , type nested ) { if ( ! nested . isrepetition ( repetition . repeated ) ) { throw new illegalargumentexception ( str_ + nested ) ; } return new grouptype ( repetition , alias , logicaltypeannotation , nested ) ; }	to preserve the difference between empty list and null when optional.
public static grouptype listofelements ( repetition listrepetition , string name , type elementtype ) { preconditions . checkargument ( elementtype . getname ( ) . equals ( element_name ) , str_ ) ; return listwrapper ( listrepetition , name , logicaltypeannotation . listtype ( ) , new grouptype ( repetition . repeated , str_ , elementtype ) ) ; }	Creates a 3-level list structure annotated with LIST with elements of thegiven elementType.
@ deprecated public map < string , string > getmergedkeyvaluemetadata ( ) { if ( mergedkeyvaluemetadata == null ) { map < string , string > mergedkeyvalues = new hashmap < string , string > ( ) ; for ( entry < string , set < string > > entry : keyvaluemetadata . entryset ( ) ) { if ( entry . getvalue ( ) . size ( ) > num_ ) { throw new runtimeexception ( str_ + entry . getkey ( ) + str_ + entry . getvalue ( ) ) ; } mergedkeyvalues . put ( entry . getkey ( ) , entry . getvalue ( ) . iterator ( ) . next ( ) ) ; } mergedkeyvaluemetadata = mergedkeyvalues ; } return mergedkeyvaluemetadata ; }	If there is a conflicting value when reading from multiple files,an exception will be thrown.
protected parquetinputsplit getsplit ( final inputsplit oldsplit , final jobconf conf ) throws ioexception { if ( oldsplit instanceof filesplit ) { filesplit filesplit = ( filesplit ) oldsplit ; final long splitstart = filesplit . getstart ( ) ; final long splitlength = filesplit . getlength ( ) ; final path finalpath = filesplit . getpath ( ) ; final jobconf clonejob = hivebinding . pushprojectionsandfilters ( conf , finalpath . getparent ( ) ) ; final parquetmetadata parquetmetadata = parquetfilereader . readfooter ( clonejob , finalpath , skip_row_groups ) ; final filemetadata filemetadata = parquetmetadata . getfilemetadata ( ) ; final readcontext readcontext = new datawritablereadsupport ( ) . init ( clonejob , filemetadata . getkeyvaluemetadata ( ) , filemetadata . getschema ( ) ) ; schemasize = messagetypeparser . parsemessagetype ( readcontext . getreadsupportmetadata ( ) . get ( datawritablereadsupport . hive_schema_key ) ) . getfieldcount ( ) ; return new parquetinputsplit ( finalpath , splitstart , splitstart + splitlength , splitlength , filesplit . getlocations ( ) , null ) ; } else { throw new illegalargumentexception ( str_ + oldsplit ) ; } }	gets a ParquetInputSplit corresponding to a split given by Hive.
private static map < string , class < ? > > getfieldsbyname ( class < ? > recordclass , boolean excludejava ) { map < string , class < ? > > fields = new linkedhashmap < string , class < ? > > ( ) ; if ( recordclass != null ) { class < ? > current = recordclass ; do { if ( excludejava && current . getpackage ( ) != null && current . getpackage ( ) . getname ( ) . startswith ( str_ ) ) { break ;	this was taken from Avro's ReflectData.
private messagetype resolveschemaaccess ( messagetype requestedschema , messagetype fileschema , configuration configuration ) { if ( configuration . getboolean ( parquet_column_index_access , bool_ ) ) { final list < string > listcolumns = getcolumns ( configuration . get ( ioconstants . columns ) ) ; list < type > requestedtypes = new arraylist < type > ( ) ; for ( type t : requestedschema . getfields ( ) ) { int index = listcolumns . indexof ( t . getname ( ) ) ; requestedtypes . add ( fileschema . gettype ( index ) ) ; } requestedschema = new messagetype ( requestedschema . getname ( ) , requestedtypes ) ; } return requestedschema ; }	Determine the file column names based on the position within the requested columns anduse that as the requested schema.
private list < path > getinputfiles ( list < string > input ) throws ioexception { list < path > inputfiles = null ; if ( input . size ( ) == num_ ) { path p = new path ( input . get ( num_ ) ) ; filesystem fs = p . getfilesystem ( conf ) ; filestatus status = fs . getfilestatus ( p ) ; if ( status . isdir ( ) ) { inputfiles = getinputfilesfromdirectory ( status ) ; } } else { inputfiles = parseinputfiles ( input ) ; } checkparquetfiles ( inputfiles ) ; return inputfiles ; }	Get all input files.
private void checkparquetfiles ( list < path > inputfiles ) throws ioexception { if ( inputfiles == null || inputfiles . size ( ) <= num_ ) { throw new illegalargumentexception ( str_ ) ; } for ( path inputfile : inputfiles ) { filesystem fs = inputfile . getfilesystem ( conf ) ; filestatus status = fs . getfilestatus ( inputfile ) ; if ( status . isdir ( ) ) { throw new illegalargumentexception ( str_ + inputfile . touri ( ) ) ; } } }	Check input files basically.ParquetFileReader will throw exception when reading an illegal parquet file.
private list < path > getinputfilesfromdirectory ( filestatus partitiondir ) throws ioexception { filesystem fs = partitiondir . getpath ( ) . getfilesystem ( conf ) ; filestatus [ ] inputfiles = fs . liststatus ( partitiondir . getpath ( ) , hiddenfilefilter . instance ) ; list < path > input = new arraylist < path > ( ) ; for ( filestatus f : inputfiles ) { input . add ( f . getpath ( ) ) ; } return input ; }	Get all parquet files under partition directory.
public static final unboundrecordfilter page ( final long startpos , final long pagesize ) { return new unboundrecordfilter ( ) { @ override public recordfilter bind ( iterable < columnreader > readers ) { return new pagedrecordfilter ( startpos , pagesize ) ; } } ; }	Returns builder for creating a paged query.
public static < t extends tbase < t , ? extends tfieldidenum > > listconsumer listof ( class < t > c , final consumer < list < t > > consumer ) { class listconsumer implements consumer < t > { list < t > list ; @ override public void consume ( t t ) { list . add ( t ) ; } } final listconsumer co = new listconsumer ( ) ; return new delegatinglistelementsconsumer ( struct ( c , co ) ) { @ override public void consumelist ( tprotocol protocol , eventbasedthriftreader reader , tlist tlist ) throws texception { co . list = new arraylist < t > ( ) ; super . consumelist ( protocol , reader , tlist ) ; consumer . consume ( co . list ) ; } } ; }	To consume a list of elements.
private void init ( final jobconf job ) { final string plan = hiveconf . getvar ( job , hiveconf . confvars . plan ) ; if ( mrwork == null && plan != null && plan . length ( ) > num_ ) { mrwork = utilities . getmapredwork ( job ) ; pathtopartitioninfo . clear ( ) ; for ( final map . entry < string , partitiondesc > entry : mrwork . getpathtopartitioninfo ( ) . entryset ( ) ) { pathtopartitioninfo . put ( new path ( entry . getkey ( ) ) . touri ( ) . getpath ( ) . tostring ( ) , entry . getvalue ( ) ) ; } } }	Initialize the mrwork variable in order to get all the partition and start to update the jobconf.
private static tuplesummarydata merge ( tuple t ) throws ioexception { tuplesummarydata summarydata = new tuplesummarydata ( ) ; databag bag = ( databag ) t . get ( num_ ) ; for ( tuple tuple : bag ) { summarydata . merge ( getdata ( tuple ) ) ; } return summarydata ; }	the input tuple contains a bag of string representations of TupleSummaryData.
private static tuplesummarydata sumup ( schema schema , tuple t ) throws execexception { tuplesummarydata summarydata = new tuplesummarydata ( ) ; databag bag = ( databag ) t . get ( num_ ) ; for ( tuple tuple : bag ) { summarydata . addtuple ( schema , tuple ) ; } return summarydata ; }	The input tuple contains a bag of Tuples to sum up.
public void readstruct ( fieldconsumer c ) throws texception { protocol . readstructbegin ( ) ; readstructcontent ( c ) ; protocol . readstructend ( ) ; }	reads a Struct from the underlying protocol and passes the field events to the FieldConsumer.
public void readmapentry ( byte keytype , typedconsumer keyconsumer , byte valuetype , typedconsumer valueconsumer ) throws texception { keyconsumer . read ( protocol , this , keytype ) ; valueconsumer . read ( protocol , this , valuetype ) ; }	reads a key-value pair.
public void writeint ( int value ) throws ioexception { input [ inputsize ] = value ; ++ inputsize ; if ( inputsize == values_written_at_a_time ) { pack ( ) ; if ( packedposition == slabsize ) { slabs . add ( bytesinput . from ( packed ) ) ; totalfullslabsize += slabsize ; if ( slabsize < bitwidth * max_slab_size_mult ) { slabsize *= num_ ; } initpackedslab ( ) ; } } }	writes an int using the requested number of bits.accepts only values less than 2^bitWidth.
public static int readintlittleendian ( bytebuffer in , int offset ) throws ioexception { int ch4 = in . get ( offset ) & num_ ; int ch3 = in . get ( offset + num_ ) & num_ ; int ch2 = in . get ( offset + num_ ) & num_ ; int ch1 = in . get ( offset + num_ ) & num_ ; return ( ( ch1 << num_ ) + ( ch2 << num_ ) + ( ch3 << num_ ) + ( ch4 << num_ ) ) ; }	reads an int in little endian at the given position.
public static void setschema ( job job , schema schema ) { avrowritesupport . setschema ( contextutil . getconfiguration ( job ) , schema ) ; }	Set the Avro schema to use for writing.
@ override public void createtopicifnotexists ( string topic , map < string , object > kafkaclientconfigs , string metadatabrokerlist ) throws stageexception {	Should be called only by MapR Streams Producer.
public pipelinestagebeans duplicatepipelinestagebeans ( stagelibrarytask stagelib , pipelinestagebeans pipelinestagebeans , interceptorcreatorcontextbuilder interceptorcreatorcontextbuilder , map < string , object > constants , list < issue > errors ) { list < stagebean > stagebeans = new arraylist < > ( pipelinestagebeans . size ( ) ) ; for ( stagebean original : pipelinestagebeans . getstages ( ) ) {	Creates additional PipelineStageBeans for additional runners.
public list < interceptorbean > createinterceptors ( stagelibrarytask stagelib , stageconfiguration stageconfiguration , stagedefinition stagedefinition , interceptorcreatorcontextbuilder contextbuilder , interceptorcreator . interceptortype interceptortype , list < issue > issues ) { list < interceptorbean > beans = new arraylist < > ( ) ; if ( contextbuilder == null ) { return beans ; } for ( interceptordefinition definition : stagelib . getinterceptordefinitions ( ) ) { interceptorbean bean = createinterceptor ( stagelib , definition , stageconfiguration , stagedefinition , contextbuilder , interceptortype , issues ) ; if ( bean != null ) { beans . add ( bean ) ; } } return beans ; }	Create interceptors for given stage.
public interceptorbean createinterceptor ( stagelibrarytask stagelib , interceptordefinition definition , stageconfiguration stageconfiguration , stagedefinition stagedefinition , interceptorcreatorcontextbuilder contextbuilder , interceptorcreator . interceptortype interceptortype , list < issue > issues ) { classloader classloader = thread . currentthread ( ) . getcontextclassloader ( ) ; interceptorcreator . context context = contextbuilder . buildfor ( definition . getlibrarydefinition ( ) . getname ( ) , definition . getklass ( ) . getname ( ) , stageconfiguration , stagedefinition , interceptortype ) ; try { thread . currentthread ( ) . setcontextclassloader ( definition . getstageclassloader ( ) ) ; interceptorcreator creator = definition . getdefaultcreator ( ) . newinstance ( ) ; interceptor interceptor = creator . create ( context ) ; if ( interceptor == null ) { return null ; } return new interceptorbean ( definition , interceptor , stagelib ) ; } catch ( illegalaccessexception | instantiationexception e ) { log . debug ( str_ , e . tostring ( ) , e ) ; issuecreator issuecreator = issuecreator . getstage ( stagedefinition . getname ( ) ) ; issues . add ( issuecreator . create ( creationerror . creation_000 , str_ , definition . getklass ( ) . getname ( ) , e . tostring ( ) ) ) ; } finally { thread . currentthread ( ) . setcontextclassloader ( classloader ) ; } return null ; }	Create a default interceptor for given InterceptorDefinition.
public static schema parseschema ( string schema ) { schema . parser parser = new schema . parser ( ) ; parser . setvalidate ( bool_ ) ;	Parse JSON representation of Avro schema to Avro's Schema JAVA object.
private static int millistodays ( long millislocal ) {	Return number of days since the unix epoch.This function has been copied from Apache Hive project.
public static string getavroschemafromheader ( record record , string headername ) throws datageneratorexception { string jsonschema = record . getheader ( ) . getattribute ( headername ) ; if ( jsonschema == null || jsonschema . isempty ( ) ) { throw new datageneratorexception ( errors . avro_generator_03 , record . getheader ( ) . getsourceid ( ) ) ; } return jsonschema ; }	Retrieves avro schema from given header.
private void upgradev1tov2 ( list < config > configs , context context ) { list < config > dataformatconfigs = configs . stream ( ) . filter ( c -> c . getname ( ) . startswith ( str_ ) ) . collect ( collectors . tolist ( ) ) ;	Migrating to service for data format library.
private void copyblobstore ( list < string > blobstoreresources , file rootdatadir , file pipelinedir ) throws ioexception { if ( blobstoreresources == null ) { return ; } file blobstoredir = new file ( runtimeinfo . getdatadir ( ) , blobstore_base_dir ) ; file stagingblobstoredir = new file ( rootdatadir , blobstore_base_dir ) ; if ( ! stagingblobstoredir . exists ( ) ) { if ( ! stagingblobstoredir . mkdirs ( ) ) { throw new runtimeexception ( str_ + pipelinedir . getpath ( ) ) ; } } for ( string blobstorefile : blobstoreresources ) { file srcfile = new file ( blobstoredir , blobstorefile ) ; if ( srcfile . exists ( ) ) { final file dstfile = new file ( stagingblobstoredir , srcfile . getname ( ) ) ; if ( srcfile . canread ( ) ) {	Copy BlobStore resources to data directory.
public void reset ( ) { columns . clear ( ) ; this . columnsexpected = null ; columnnames = null ; table = null ; schema = null ; insidestatement = bool_ ; }	Reset the listener to use with the next statement.
public boolean reporthealth ( string threadname , int scheduleddelay , long timestamp ) { threadhealthreport threadhealthreport = new threadhealthreport ( threadname , scheduleddelay , timestamp ) ; if ( threadtogaugemap . containskey ( threadname ) ) { threadtogaugemap . get ( threadname ) . setthreadhealthreport ( threadhealthreport ) ; return bool_ ; } return bool_ ; }	Updates gauge for the registered thread with the given details.Note that the value of the threadName argument must match the one used to register.
public boolean register ( string threadname ) { if ( threadtogaugemap . containskey ( threadname ) ) { return bool_ ; } threadhealthreportgauge threadhealthreportgauge = new threadhealthreportgauge ( ) ; metricsconfigurator . creategauge ( metrics , gethealthgaugename ( threadname ) , threadhealthreportgauge , name , rev ) ; threadtogaugemap . put ( threadname , threadhealthreportgauge ) ; return bool_ ; }	Creates and registers a Gauge with the given thread name.The same name must be used to report health.
public static void storecontrolhubconfigs ( runtimeinfo runtimeinfo , map < string , string > newconfigs ) throws ioexception { file configfile = new file ( runtimeinfo . getdatadir ( ) , sch_conf_override ) ; properties properties = new properties ( ) ;	Store configuration from control hub in persistent manner inside data directory.
protected boolean credentiallogin ( object webcredential ) throws loginexception { boolean credresult = getcurrentuser ( ) . checkcredential ( webcredential ) ; setauthenticated ( credresult ) ; if ( ! credresult ) { log . warn ( str_ ) ; } return isauthenticated ( ) ; }	password supplied authentication check.
public pipelineconfiguration upgradeifnecessary ( stagelibrarytask library , pipelineconfiguration pipelineconf , list < issue > issues ) { preconditions . checkargument ( issues . isempty ( ) , str_ ) ; boolean upgrade ;	Upgrade whole pipeline at once and return updated variant.
static stageconfiguration upgradeifneeded ( stagelibrarytask library , stageconfiguration conf , list < issue > issues ) { return upgradeifneeded ( library , library . getstage ( conf . getlibrary ( ) , conf . getstagename ( ) , bool_ ) , conf , issues ) ; }	Upgrade whole Stage configuration, including all services if needed.
static stageconfiguration upgradeifneeded ( stagelibrarytask library , stagedefinition def , stageconfiguration conf , list < issue > issues ) { issuecreator issuecreator = issuecreator . getstage ( conf . getinstancename ( ) ) ; int fromversion = conf . getstageversion ( ) ; int toversion = def . getversion ( ) ; try {	Upgrade whole Stage configuration, including all services if needed.This method is idempotent.
private static serviceconfiguration upgradeservicesifneeded ( stagelibrarytask library , stageconfiguration stageconf , serviceconfiguration conf , issuecreator issuecreator , list < issue > issues ) { servicedefinition def = library . getservicedefinition ( conf . getservice ( ) , bool_ ) ; if ( def == null ) { issues . add ( issuecreator . create ( containererror . container_0903 , conf . getservice ( ) . getname ( ) ) ) ; } int fromversion = conf . getserviceversion ( ) ; int toversion = def . getversion ( ) ;	Internal method that will upgrade service configuration if needed.This method is idempotent.
static private void upgradestageifneeded ( stagedefinition def , stageconfiguration conf , issuecreator issuecreator , list < issue > issues ) { int fromversion = conf . getstageversion ( ) ; int toversion = def . getversion ( ) ;	Internal method that will upgrade only Stage configuration - not the associated services - and only if needed.This method is idempotent.
private list < string > getfieldstonull ( list < nullreplacerconditionalconfig > nullreplacerconditionalconfigs , set < string > fieldsthatdonotexist , set < string > fieldpaths , record record ) throws onrecorderrorexception {	should be replaced by null.
private static boolean issystemclass ( string name , list < string > packagelist ) { boolean result = bool_ ; if ( packagelist != null ) { string canonicalname = classloaderutil . canonicalizeclassorresource ( name ) ; for ( string c : packagelist ) { boolean shouldinclude = bool_ ; if ( c . startswith ( str_ ) ) { c = c . substring ( num_ ) ; shouldinclude = bool_ ; } if ( canonicalname . startswith ( c ) ) { if ( c . endswith ( str_ )	Checks if a class should be included as a system class.A class is a system class if and only if it matches one of the positivepatterns and none of the negative ones.
@ override public boolean add ( e e ) { checknotnull ( e ) ;	Adds the given element to this queue.
public e addandgetevicted ( e e ) { checknotnull ( e ) ;	Adds the given element to this queue.
private optional < value > valueordefault ( key key , optional < value > value ) {	Internal method to ensure that we return and not cache the default value if needed.
private list < stageoutput > addreportederrorsifneeded ( list < stageoutput > snapshotsofallstagesoutput ) { synchronized ( this . reportederrors ) { if ( reportederrors . isempty ( ) ) { return snapshotsofallstagesoutput ; } try { return snapshotsofallstagesoutput . stream ( ) . map ( so -> new stageoutput ( so . getinstancename ( ) , so . getoutput ( ) , so . geterrorrecords ( ) , reportederrors . get ( so . getinstancename ( ) ) , so . geteventrecords ( ) ) ) . collect ( collectors . tolist ( ) ) ; } finally { reportederrors . clear ( ) ; } } }	Preview only returns data associated with batches, however errors are reported outside of batch context formulti-threaded pipelines.
public static descriptors . descriptor getdescriptor ( protoconfigurableentity . context context , string protodescriptorfile , string messagetype , map < string , set < descriptors . fielddescriptor > > messagetypetoextensionmap , map < string , object > defaultvaluemap ) throws stageexception { file descriptorfilehandle = new file ( context . getresourcesdirectory ( ) , protodescriptorfile ) ; try ( fileinputstream fin = new fileinputstream ( descriptorfilehandle ) ; ) { descriptorprotos . filedescriptorset set = descriptorprotos . filedescriptorset . parsefrom ( fin ) ;	Returns a protobuf descriptor instance from the provided descriptor file.
public static void getallfiledescriptors ( descriptorprotos . filedescriptorset set , map < string , set < descriptors . filedescriptor > > dependenciesmap , map < string , descriptors . filedescriptor > filedescriptormap ) throws stageexception { list < descriptorprotos . filedescriptorproto > filelist = set . getfilelist ( ) ; try { for ( descriptorprotos . filedescriptorproto fdp : filelist ) { if ( ! filedescriptormap . containskey ( fdp . getname ( ) ) ) { set < descriptors . filedescriptor > dependencies = dependenciesmap . get ( fdp . getname ( ) ) ; if ( dependencies == null ) { dependencies = new linkedhashset < > ( ) ; dependenciesmap . put ( fdp . getname ( ) , dependencies ) ; dependencies . addall ( getdependencies ( dependenciesmap , filedescriptormap , fdp , set ) ) ; } descriptors . filedescriptor filedescriptor = descriptors . filedescriptor . buildfrom ( fdp , dependencies . toarray ( new descriptors . filedescriptor [ dependencies . size ( ) ] ) ) ; filedescriptormap . put ( fdp . getname ( ) , filedescriptor ) ; } } } catch ( descriptors . descriptorvalidationexception e ) { throw new stageexception ( errors . protobuf_07 , e . getdescription ( ) , e ) ; } }	Loads a Protobuf file descriptor set into an ubermap of file descriptors.
public static void populatedefaultsandextensions ( map < string , descriptors . filedescriptor > filedescriptormap , map < string , set < descriptors . fielddescriptor > > typetoextensionmap , map < string , object > defaultvaluemap ) { for ( descriptors . filedescriptor f : filedescriptormap . values ( ) ) {	Populates a map of protobuf extensions and map with the default values foreach message field from a map of file descriptors.
public static descriptors . descriptor getdescriptor ( descriptorprotos . filedescriptorset set , map < string , descriptors . filedescriptor > filedescriptormap , string descriptorfile , string qualifiedmessagetype ) throws stageexception {	Generates a protobuf descriptor instance from a FileDescriptor set.
public static field protobuftosdcfield ( record record , string fieldpath , descriptors . descriptor descriptor , map < string , set < descriptors . fielddescriptor > > messagetypetoextensionmap , object message ) throws dataparserexception { linkedhashmap < string , field > sdcrecordmapfieldvalue = new linkedhashmap < > ( ) ;	Converts a protobuf message to an SDC Record Field.
public static dynamicmessage sdcfieldtoprotobufmsg ( record record , descriptors . descriptor desc , map < string , set < descriptors . fielddescriptor > > messagetypetoextensionmap , map < string , object > defaultvaluemap ) throws datageneratorexception { return sdcfieldtoprotobufmsg ( record , record . get ( ) , str_ , desc , messagetypetoextensionmap , defaultvaluemap ) ; }	Serializes a record to a protobuf message using the specified descriptor.
private static dynamicmessage sdcfieldtoprotobufmsg ( record record , field field , string fieldpath , descriptors . descriptor desc , map < string , set < descriptors . fielddescriptor > > messagetypetoextensionmap , map < string , object > defaultvaluemap ) throws datageneratorexception { if ( field == null ) { return null ; }	Serializes a field path in a record to a protobuf message using the specified descriptor.
public static void upgradetojerseyconfigbean ( list < config > configs ) { list < config > configstoadd = new arraylist < > ( ) ; list < config > configstoremove = new arraylist < > ( ) ; list < string > movedconfigs = immutablelist . of ( str_ , str_ , str_ , str_ , str_ , str_ , str_ , str_ ) ; for ( config config : configs ) { if ( hasprefixin ( movedconfigs , config . getname ( ) ) ) { configstoremove . add ( config ) ; configstoadd . add ( new config ( config . getname ( ) . replace ( str_ , str_ ) , config . getvalue ( ) ) ) ; } } configstoadd . add ( new config ( str_ , requestentityprocessing . chunked ) ) ; configs . removeall ( configstoremove ) ; configs . addall ( configstoadd ) ; }	Helper method to upgrade both HTTP stages to the JerseyConfigBean.
public static void checkconnection ( asynckuduclient kuduclient , context context , string kudu_master , final list < stage . configissue > issues ) { try { kuduclient . gettableslist ( ) . join ( ) ; } catch ( exception ex ) { issues . add ( context . createconfigissue ( groups . kudu . name ( ) , kudulookupconfig . conf_prefix + kudu_master , errors . kudu_00 , ex . tostring ( ) , ex ) ) ; } }	Check network connection to the kudu master.
public static field . type convertfromkudutype ( type kudutype ) { switch ( kudutype ) { case binary : return field . type . byte_array ; case bool : return field . type . boolean ; case double : return field . type . double ; case float : return field . type . float ; case int8 : return field . type . byte ; case int16 : return field . type . short ; case int32 : return field . type . integer ; case int64 : return field . type . long ; case string : return field . type . string ; case unixtime_micros : return field . type . datetime ; default : if ( str_ . equals ( kudutype . name ( ) ) ) { return field . type . decimal ; } throw new unsupportedoperationexception ( str_ + kudutype . getname ( ) ) ; } }	Convert from Kudu type to SDC Field type.
public static field createfield ( rowresult result , string fieldname , type type ) throws stageexception { switch ( type ) { case int8 : return field . create ( field . type . byte , result . getbyte ( fieldname ) ) ; case int16 : return field . create ( field . type . short , result . getshort ( fieldname ) ) ; case int32 : return field . create ( field . type . integer , result . getint ( fieldname ) ) ; case int64 : return field . create ( field . type . long , result . getlong ( fieldname ) ) ; case binary : try { return field . create ( field . type . byte_array , result . getbinary ( fieldname ) ) ; } catch ( illegalargumentexception ex ) { throw new onrecorderrorexception ( errors . kudu_35 , fieldname ) ; } case string : return field . create ( field . type . string , result . getstring ( fieldname ) ) ; case bool : return field . create ( field . type . boolean , result . getboolean ( fieldname ) ) ; case float : return field . create ( field . type . float , result . getfloat ( fieldname ) ) ; case double : return field . create ( field . type . double , result . getdouble ( fieldname ) ) ; case unixtime_micros :	Create a field and assign a value off of RowResult.
private list < record > intercept ( list < record > records , list < ? extends interceptor > interceptors ) throws stageexception { for ( interceptor interceptor : interceptors ) { records = interceptor . intercept ( records ) ; } return records ; }	Intercept given records with all the interceptors.We're not cloning records during interception as we aim at changing their original form.
public string gettext ( ) { if ( line == null ) { line = new string ( buffer , offsetinchunk , length , charset ) ; } return line ; }	Returns the text of the line.
public static void addmissingconfigstostage ( stagelibrarytask stagelibrary , stageconfiguration stageconf ) { stagedefinition stagedef = stagelibrary . getstage ( stageconf . getlibrary ( ) , stageconf . getstagename ( ) , bool_ ) ; if ( stagedef != null ) { for ( configdefinition configdef : stagedef . getconfigdefinitions ( ) ) { string configname = configdef . getname ( ) ; config config = stageconf . getconfig ( configname ) ; if ( config == null ) { object defaultvalue = configdef . getdefaultvalue ( ) ; log . warn ( str_ , stageconf . getinstancename ( ) , configname , defaultvalue ) ; config = new config ( configname , defaultvalue ) ; stageconf . addconfig ( config ) ; } } } }	Add any missing configs to the stage configuration.
private record parseresponse ( inputstream response ) throws stageexception { record record = null ; if ( conf . httpmethod == httpmethod . head ) {	Parses the HTTP response text from a request into SDC Records.
private void addresponseheaders ( record record , response response ) throws stageexception { if ( conf . headeroutputlocation == headeroutputlocation . none ) { return ; } record . header header = record . getheader ( ) ; if ( conf . headeroutputlocation == headeroutputlocation . field ) { writeresponseheadertofield ( record , response ) ; } else if ( conf . headeroutputlocation == headeroutputlocation . header ) { writeresponseheadertorecordheader ( response , header ) ; } }	Populates HTTP response headers to the configured location.
private void writeresponseheadertofield ( record record , response response ) throws stageexception { if ( record . has ( conf . headeroutputfield ) ) { throw new stageexception ( errors . http_11 , conf . headeroutputfield ) ; } map < string , field > headers = new hashmap < > ( response . getstringheaders ( ) . size ( ) ) ; for ( map . entry < string , list < string > > entry : response . getstringheaders ( ) . entryset ( ) ) { if ( ! entry . getvalue ( ) . isempty ( ) ) { string firstvalue = entry . getvalue ( ) . get ( num_ ) ; headers . put ( entry . getkey ( ) , field . create ( firstvalue ) ) ; } } record . set ( conf . headeroutputfield , field . create ( headers ) ) ; }	Writes HTTP response headers to the SDC Record at the configured field path.
private void writeresponseheadertorecordheader ( response response , record . header header ) { for ( map . entry < string , list < string > > entry : response . getstringheaders ( ) . entryset ( ) ) { if ( ! entry . getvalue ( ) . isempty ( ) ) { string firstvalue = entry . getvalue ( ) . get ( num_ ) ; header . setattribute ( conf . headerattributeprefix + entry . getkey ( ) , firstvalue ) ; } } }	Writes HTTP response headers to the SDC Record header with the configured optional prefix.
synchronized private void savemetadata ( ) throws stageexception {	Commit metadata content to a file to disk.This method does three-phased commit:1) New content is written into a new temporary file.2) Old metadata is dropped3) Rename from new to old is done.
private void configureclient ( list < configissue > issues ) throws stageexception { clientcommon . init ( issues , getcontext ( ) ) ; if ( issues . isempty ( ) ) { client = clientcommon . getclient ( ) ; parserfactory = conf . dataformatconfig . getparserfactory ( ) ; } }	Helper method to apply Jersey client configuration properties.
string parseheadersonly ( batchmaker batchmaker ) throws stageexception { httpsourceoffset sourceoffset = new httpsourceoffset ( getresolvedurl ( ) , currentparameterhash , system . currenttimemillis ( ) , getcurrentpage ( ) ) ; record record = getcontext ( ) . createrecord ( sourceoffset + str_ ) ; addresponseheaders ( record . getheader ( ) ) ; record . set ( field . create ( new hashmap ( ) ) ) ; batchmaker . addrecord ( record ) ; recordcount ++ ; incrementsourceoffset ( sourceoffset , num_ ) ; lastrequestcompletedtime = system . currenttimemillis ( ) ; return sourceoffset . tostring ( ) ; }	Used only for HEAD requests.
private void incrementsourceoffset ( httpsourceoffset sourceoffset , int increment ) { if ( conf . pagination . mode == paginationmode . by_page ) { sourceoffset . incrementstartat ( num_ ) ; } else if ( conf . pagination . mode == paginationmode . by_offset ) { sourceoffset . incrementstartat ( increment ) ; } }	Increments the current source offset's startAt portion by the specified amount.This is the number of records parsed when paging BY_OFFSET or 1 if incrementingBY_PAGE.
private int parsepaginatedresult ( batchmaker batchmaker , string sourceoffset , record record ) throws stageexception { int numsubrecords = num_ ; if ( ! record . has ( conf . pagination . resultfieldpath ) ) { final stageexception stageexception = new stageexception ( errors . http_12 , conf . pagination . resultfieldpath ) ; log . error ( stageexception . getmessage ( ) ) ; throw stageexception ; } field resultfield = record . get ( conf . pagination . resultfieldpath ) ; if ( resultfield . gettype ( ) != field . type . list ) { final stageexception stageexception = new stageexception ( errors . http_08 , resultfield . gettype ( ) ) ; log . error ( stageexception . getmessage ( ) ) ; throw stageexception ; } list < field > results = resultfield . getvalueaslist ( ) ; int subrecordidx = num_ ; for ( field result : results ) { record r = getcontext ( ) . createrecord ( sourceoffset + str_ + subrecordidx ++ ) ; if ( conf . pagination . keepallfields ) { r . set ( record . get ( ) . clone ( ) ) ; r . set ( conf . pagination . resultfieldpath , result ) ; } else { r . set ( result ) ; } addresponseheaders ( r . getheader ( ) ) ; batchmaker . addrecord ( r ) ; ++ numsubrecords ; } if ( conf . pagination . mode != paginationmode . link_field ) { havemorepages = numsubrecords > num_ ; } return numsubrecords ; }	Parses a paginated result from the configured field.
private void addresponseheaders ( record . header header ) { final multivaluedmap < string , string > headers = getresponse ( ) . getstringheaders ( ) ; if ( headers == null ) { return ; } for ( map . entry < string , list < string > > entry : headers . entryset ( ) ) { if ( ! entry . getvalue ( ) . isempty ( ) ) { string firstvalue = entry . getvalue ( ) . get ( num_ ) ; header . setattribute ( entry . getkey ( ) , firstvalue ) ; } } }	Adds the HTTP response headers to the record header.
private multivaluedmap < string , object > resolveheaders ( ) throws stageexception { multivaluedmap < string , object > requestheaders = new multivaluedhashmap < > ( ) ; for ( map . entry < string , string > entry : conf . headers . entryset ( ) ) { list < object > header = new arraylist < > ( num_ ) ; object resolvedvalue = headereval . eval ( headervars , entry . getvalue ( ) , string . class ) ; header . add ( resolvedvalue ) ; requestheaders . put ( entry . getkey ( ) , header ) ; hasher . putstring ( entry . getkey ( ) , charset . forname ( conf . dataformatconfig . charset ) ) ; hasher . putstring ( entry . getvalue ( ) , charset . forname ( conf . dataformatconfig . charset ) ) ; } return requestheaders ; }	Resolves any expressions in the Header value entries of the request.
private optional < string > processresponse ( long start , int maxrecords , batchmaker batchmaker ) throws stageexception { optional < string > newsourceoffset = optional . empty ( ) ; if ( getresponse ( ) == null ) { return newsourceoffset ; }	Verifies that the response was a successful one and has data and continues to parse the response.
protected boolean propertydefined ( configuration conf , string propertyname ) { string prop = conf . get ( propertyname ) ;	Return true if and only if given property is defined with non empty non default value.
public static dataparserexception convert ( com . streamsets . pipeline . lib . parser . dataparserexception original ) { if ( original instanceof com . streamsets . pipeline . lib . parser . recoverabledataparserexception ) { return new recoverabledataparserexception ( ( ( com . streamsets . pipeline . lib . parser . recoverabledataparserexception ) original ) . getunparsedrecord ( ) , original . geterrorcode ( ) , original . getparams ( ) ) ; } return new dataparserexception ( original . geterrorcode ( ) , original . getparams ( ) ) ; }	Change package name for DataParserException.
public static datageneratorexception convert ( com . streamsets . pipeline . lib . generator . datageneratorexception original ) { return new datageneratorexception ( original . geterrorcode ( ) , original . getparams ( ) ) ; }	Change package name for DataGeneratorException.
private credentials getcredentials ( stage . context context , list < stage . configissue > issues ) { credentials credentials = null ; file credentialsfile ; if ( paths . get ( path ) . isabsolute ( ) ) { credentialsfile = new file ( path ) ; } else { credentialsfile = new file ( context . getresourcesdirectory ( ) , path ) ; } if ( ! credentialsfile . exists ( ) || ! credentialsfile . isfile ( ) ) { log . error ( google_01 . getmessage ( ) , credentialsfile . getpath ( ) ) ; issues . add ( context . createconfigissue ( groups . credentials . name ( ) , conf_credentials_credentials_provider , google_01 , credentialsfile . getpath ( ) ) ) ; return null ; } try ( inputstream in = new fileinputstream ( credentialsfile ) ) { credentials = serviceaccountcredentials . fromstream ( in ) ; } catch ( ioexception | illegalargumentexception e ) { log . error ( google_02 . getmessage ( ) , e ) ; issues . add ( context . createconfigissue ( groups . credentials . name ( ) , conf_credentials_credentials_provider , google_02 ) ) ; } return credentials ; }	Reads a JSON credentials file for a service account from and returns any errors.
public previewinfojson previewwithoverride ( string pipelineid , list < stageoutputjson > stageoutputstooverridejson , string rev , integer batchsize , integer batches , boolean skiptargets , string endstage , long timeout ) throws apiexception { object postbody = stageoutputstooverridejson ; byte [ ] postbinarybody = null ;	Run Pipeline preview.
protected int copytobuffer ( stringbuilder s , int initiallen , int startchar , int currentchar ) { int overrun = num_ ; int currentsize = s . length ( ) - initiallen ; int readsize = currentchar - startchar ; if ( maxline > - num_ && currentsize + readsize > maxline ) { int adjustedreadsize = maxline - currentsize ; if ( adjustedreadsize > num_ ) { s . append ( cb , startchar , adjustedreadsize ) ; overrun = readsize - adjustedreadsize ; } else { overrun = readsize ; } } else { s . append ( cb , startchar , readsize ) ; } return overrun ; }	we use this to trim the output in case of overruns.
static void removelogicalduplicates ( sortedset < string > packages ) { iterator < string > iterator = packages . iterator ( ) ; if ( ! iterator . hasnext ( ) ) { return ; } string last = iterator . next ( ) ; while ( iterator . hasnext ( ) ) { string current = iterator . next ( ) ; if ( current . startswith ( last ) ) { iterator . remove ( ) ; } else { last = current ; } } }	Traverses sorted list of packages and removes logical duplicates.
int findnextmainline ( livefilechunk chunk , int startidx ) { list < fileline > lines = chunk . getlines ( ) ; int found = - num_ ; for ( int i = startidx ; found == - num_ && i < lines . size ( ) ; i ++ ) { if ( pattern . matcher ( lines . get ( i ) . gettext ( ) . trim ( ) ) . matches ( ) ) { found = i ; } } return found ; }	finds the first main line in the chunk from the specified index position onwards.
livefilechunk resolvechunk ( livefilechunk chunk ) { list < fileline > completelines = new arraylist < > ( ) ; list < fileline > chunklines = chunk . getlines ( ) ; if ( incompletemultiline . length ( ) == num_ ) { incompletemultilineoffset = chunk . getoffset ( ) ; incompletemultilinetruncated = chunk . istruncated ( ) ; } incompletemultilinetruncated |= chunk . istruncated ( ) ; int pos = num_ ; int idx = findnextmainline ( chunk , pos ) ;	it there is an incomplete multiline from a previous chunk it starts from it.
public void closeconnection ( ) { logger . debug ( str_ ) ; connection connectiontoremove = threadlocalconnection . get ( ) ; jdbcutil . closequietly ( connectiontoremove ) ; if ( connectiontoremove != null ) { synchronized ( this ) { connectionstocloseduringdestroy . remove ( connectiontoremove ) ; } } threadlocalconnection . set ( null ) ; }	Close the current thread's connection.
private static string escapequotedsubstring ( string input ) { string [ ] parts = input . split ( str_ ) ; stringbuilder output = new stringbuilder ( input . length ( ) * num_ ) ; for ( int i = num_ ; i < parts . length ; i ++ ) { if ( ( i % num_ ) == num_ ) { output . append ( str_ ) . append ( parts [ i ] . replace ( str_ , str_ ) ) . append ( str_ ) ; } else { output . append ( parts [ i ] ) ; } } return output . tostring ( ) ; }	Add backslash to escape the | character within quoted sections of theinput string.
private flowcontrolsettings getflowcontrolsettings ( ) { return flowcontrolsettings . newbuilder ( ) . setlimitexceededbehavior ( flowcontroller . limitexceededbehavior . block ) . setmaxoutstandingelementcount ( ( long ) conf . basic . maxbatchsize * conf . maxthreads / conf . advanced . numsubscribers ) . build ( ) ; }	Returns a flow control setting such that a subscriber will block if it has buffered more messages than can beprocessed in a single batch times the number of record processors.
private instantiatinggrpcchannelprovider getchannelprovider ( ) { return subscriptionadminsettings . defaultgrpctransportproviderbuilder ( ) . setmaxinboundmessagesize ( max_inbound_message_size ) . setendpoint ( strings . isnullorempty ( conf . advanced . customendpoint ) ? subscriptionadminsettings . getdefaultendpoint ( ) : conf . advanced . customendpoint ) . build ( ) ; }	Creates a channel provider shared by each subscriber.
public object put ( offsetandresult < map . entry > batch ) { if ( consumererror != null ) { throw new runtimeexception ( utils . format ( str_ , consumererror ) , consumererror ) ; } if ( producererror != null ) { throw new runtimeexception ( utils . format ( str_ , producererror ) , producererror ) ; } try { object expectedoffset = str_ ; if ( ! batch . getresult ( ) . isempty ( ) ) { expectedoffset = batch . getresult ( ) . get ( batch . getresult ( ) . size ( ) - num_ ) . getkey ( ) ;	Queues the batch for the consumer and waits until the consumersuccessfully commits the batch.
public grok compileexpression ( final string expression ) { throwerrorifdictionaryisnotready ( ) ; final string digestedexpression = digestexpressionaux ( expression ) ; logger . debug ( str_ + expression + str_ + digestedexpression + str_ ) ; return new grok ( pattern . compile ( digestedexpression ) ) ; }	Compiles the expression into a patternThis uses the internal dictionary of named regular expressions.
private string digestexpressionaux ( string originalexpression ) { final string pattern_start = str_ ; final string pattern_stop = str_ ; final char pattern_delimiter = str_ ; while ( bool_ ) { int pattern_start_index = originalexpression . indexof ( pattern_start ) ; int pattern_stop_index = originalexpression . indexof ( pattern_stop , pattern_start_index + pattern_start . length ( ) ) ;	Digests the original expression into a pure named regex.
public void adddictionary ( final inputstream inputstream ) { try { adddictionaryaux ( new inputstreamreader ( inputstream , str_ ) ) ; } catch ( ioexception e ) { throw new grokcompilationexception ( e ) ; } }	Loads dictionary from an input streamThis can be used to load dictionaries available in the class path .
public void adddictionary ( reader reader ) { try { adddictionaryaux ( reader ) ; } catch ( ioexception e ) { throw new grokcompilationexception ( e ) ; } finally { ioutils . closequietly ( reader ) ; } }	Adds a dictionary entry via a Reader object.
public map < aggregator , aggregatordata > stop ( ) { utils . checkstate ( started , str_ ) ; utils . checkstate ( ! stopped , str_ ) ; stopped = bool_ ; long currenttimemillis = system . currenttimemillis ( ) ; for ( map . entry < aggregator , aggregatordata > e : data . entryset ( ) ) { e . getvalue ( ) . settime ( currenttimemillis ) ; } map < aggregator , aggregatordata > result = data ; result = aggregatedatawindows ( result ) ; return result ; }	Stops the AggregatorDataProvider instance.
public map < aggregator , aggregatordata > roll ( long newdatawindowendtimemillis ) { utils . checkstate ( started , str_ ) ; utils . checkstate ( ! stopped , str_ ) ; map < aggregator , aggregatordata > result = data ; map < aggregator , aggregatordata > newdata = new concurrenthashmap < > ( ) ; for ( aggregator aggregator : aggregators ) { newdata . put ( aggregator , aggregator . createaggregatordata ( newdatawindowendtimemillis ) ) ; } data = newdata ; map < aggregator , aggregatordata > olddata = result ;	Atomically rolls the DataWindow of all aggregators associated with the AggregatorDataProvider.
public string serialize ( object obj ) throws apiexception { try { if ( obj != null ) return mapper . writevalueasstring ( obj ) ; else return null ; } catch ( exception e ) { throw new apiexception ( num_ , e . getmessage ( ) ) ; } }	Serialize the given Java object into JSON string.
public < t > t deserialize ( string body , typeref returntype ) throws apiexception { javatype javatype = mapper . constructtype ( returntype . gettype ( ) ) ; try { return mapper . readvalue ( body , javatype ) ; } catch ( ioexception e ) { if ( returntype . gettype ( ) . equals ( string . class ) ) return ( t ) body ; else throw new apiexception ( num_ , e . getmessage ( ) , null , body ) ; } }	Deserialize the given JSON string to Java object.
public < t > t deserialize ( file file , typeref returntype ) throws apiexception { javatype javatype = mapper . constructtype ( returntype . gettype ( ) ) ; try { return mapper . readvalue ( file , javatype ) ; } catch ( ioexception e ) { throw new apiexception ( num_ , e . getmessage ( ) , null , str_ ) ; } }	Deserialize the given File to Java object.
private void write ( record record ) throws onrecorderrorexception {	Writes a single record to the destination.
public static string resolveel ( eleval eleval , elvars variables , string val ) throws elevalexception { return eleval . eval ( variables , val , string . class ) ; }	Resolve expression from record.
private static < t > field generateinnerfieldfromthelist ( linkedhashmap < string , t > original , string innerpairfirstfieldname , string innerpairsecondfieldname , boolean issecondfieldhivetype ) throws hivestagecheckedexception { list < field > columnlist = new linkedlist < > ( ) ; for ( map . entry < string , t > pair : original . entryset ( ) ) { linkedhashmap < string , field > entry = new linkedhashmap < > ( ) ; entry . put ( innerpairfirstfieldname , field . create ( pair . getkey ( ) ) ) ; if ( issecondfieldhivetype ) { hivetypeinfo hivetypeinfo = ( hivetypeinfo ) pair . getvalue ( ) ; entry . put ( innerpairsecondfieldname , hivetypeinfo . gethivetype ( ) . getsupport ( ) . generatehivetypeinfofieldformetadatarecord ( hivetypeinfo ) ) ; } else { entry . put ( innerpairsecondfieldname , field . create ( pair . getvalue ( ) . tostring ( ) ) ) ;	Opposite operation of extractInnerMapFromTheList.It takes LinkedHashMap and generate a Field that contains the list.This is to send metadata record to HMS target.This function is called to for partition type list and partition value list.
public static string gettablename ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . has ( sep + table_field ) ) { return metadatarecord . get ( sep + table_field ) . getvalueasstring ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , table_field , metadatarecord ) ; }	Get Table Name from the metadata record.
public static string getdatabasename ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . has ( sep + database_field ) ) { string dbname = metadatarecord . get ( sep + database_field ) . getvalueasstring ( ) ; return dbname . isempty ( ) ? default_dbname : dbname ; } throw new hivestagecheckedexception ( errors . hive_17 , database_field , metadatarecord ) ; }	Get Database Name from the metadata record.
public static boolean getinternalfield ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . has ( sep + internal_field ) ) { return metadatarecord . get ( sep + internal_field ) . getvalueasboolean ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , internal_field , metadatarecord ) ; }	Get internal field from the metadata record.
public static string getlocation ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . has ( sep + location_field ) ) { return metadatarecord . get ( sep + location_field ) . getvalueasstring ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , location_field , metadatarecord ) ; }	Get Location from the metadata record.
public static boolean getcustomlocation ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . get ( sep + version ) . getvalueasinteger ( ) < num_ ) { return default_custom_location ; } if ( metadatarecord . has ( sep + custom_location ) ) { return metadatarecord . get ( sep + custom_location ) . getvalueasboolean ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , custom_location , metadatarecord ) ; }	Get the customLocation flag from the metadata record.
public static string getavroschema ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . has ( sep + avro_schema ) ) { return metadatarecord . get ( sep + avro_schema ) . getvalueasstring ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , avro_schema , metadatarecord ) ; }	Get Avro Schema from Metadata Record.
public static string getdataformat ( record metadatarecord ) throws hivestagecheckedexception { if ( metadatarecord . get ( sep + version ) . getvalueasinteger ( ) == num_ ) { return default_data_format ; } if ( metadatarecord . has ( sep + data_format ) ) { return metadatarecord . get ( sep + data_format ) . getvalueasstring ( ) ; } throw new hivestagecheckedexception ( errors . hive_17 , data_format , metadatarecord ) ; }	Get DataFormat from Metadata Record.
public static field newschemametadatafieldbuilder ( string database , string tablename , linkedhashmap < string , hivetypeinfo > columnlist , linkedhashmap < string , hivetypeinfo > partitiontypelist , boolean internal , string location , string avroschema , hmpdataformat dataformat ) throws hivestagecheckedexception { linkedhashmap < string , field > metadata = new linkedhashmap < > ( ) ; metadata . put ( version , field . create ( schema_change_metadata_record_version ) ) ; metadata . put ( metadata_record_type , field . create ( metadatarecordtype . table . name ( ) ) ) ; metadata . put ( database_field , field . create ( database ) ) ; metadata . put ( table_field , field . create ( tablename ) ) ; metadata . put ( location_field , field . create ( location ) ) ; metadata . put ( data_format , field . create ( dataformat . name ( ) ) ) ;	Fill in metadata to Record.
public static void validatepartitioninformation ( typeinfocachesupport . typeinfo typeinfo , linkedhashmap < string , string > partitionvalmap , string qualifiedtablename ) throws hivestagecheckedexception { set < string > partitionnamesinhive = typeinfo . getpartitiontypeinfo ( ) . keyset ( ) ; set < string > partitionnames = partitionvalmap . keyset ( ) ; if ( ! ( partitionnamesinhive . size ( ) == partitionnames . size ( ) && partitionnamesinhive . containsall ( partitionnames ) ) ) { log . error ( utils . format ( str_ , partitionnamesinhive . size ( ) , partitionnames . size ( ) ) ) ; throw new hivestagecheckedexception ( errors . hive_27 , qualifiedtablename ) ; } }	Checks whether the number of partition columns and names match w.r.t hive.
public static string generatepartitionpath ( linkedhashmap < string , string > partitions ) { stringbuilder builder = new stringbuilder ( ) ; for ( map . entry < string , string > pair : partitions . entryset ( ) ) { builder . append ( string . format ( partition_path , pair . getkey ( ) , pair . getvalue ( ) ) ) ; } return builder . tostring ( ) ; }	Build a partition path for the external table.
public static string serializeschematohdfs ( usergroupinformation loginugi , final filesystem fs , final string location , final string schemafolder , final string databasename , final string tablename , final string schemajson ) throws stageexception { string folderlocation ; if ( schemafolder . startswith ( sep ) ) { folderlocation = schemafolder ; } else { folderlocation = location + sep + schemafolder ; } final path schemasfolderpath = new path ( folderlocation ) ; final string path = folderlocation + sep + string . format ( avro_schema_file_format , databasename , tablename , uuid . randomuuid ( ) . tostring ( ) ) ; try { loginugi . doas ( new privilegedexceptionaction < void > ( ) { @ override public void run ( ) throws exception { if ( ! fs . exists ( schemasfolderpath ) ) { fs . mkdirs ( schemasfolderpath ) ; } path schemafilepath = new path ( path ) ;	Returns the hdfs paths where the avro schema is stored after serializing.Path is appended with current time so as to have an ordering.
@ visiblefortesting @ suppresswarnings ( str_ ) int setparameters ( int opcode , sortedmap < string , string > columnstoparameters , final record record , final connection connection , preparedstatement statement ) throws onrecorderrorexception { int paramidx = num_ ;	Set parameters and primary keys in query.
public map < string , object > getconfiguration ( ) throws apiexception { object postbody = null ; byte [ ] postbinarybody = null ;	Returns ALL SDC Configuration.
public static long parserfc3164time ( string ts ) throws onrecorderrorexception { localdatetime now = localdatetime . now ( ) ; int year = now . getyear ( ) ; ts = two_spaces . matcher ( ts ) . replacefirst ( str_ ) ; localdatetime date ; try { monthday monthday = monthday . parse ( ts , rfc3164format ) ; localtime time = localtime . parse ( ts , rfc3164format ) ;	Parse the RFC3164 date format.
public static string format ( string template , object ... args ) { string [ ] templatearr = templates . get ( template ) ; if ( templatearr == null ) {	no escaping is supported, no array content printing either.
@ override public final batchcontext startbatch ( ) { return ( batchcontext ) accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { try { thread . currentthread ( ) . setcontextclassloader ( mainclassloader ) ; return pushsourcecontextdelegate . startbatch ( ) ; } finally { thread . currentthread ( ) . setcontextclassloader ( getdefinition ( ) . getstageclassloader ( ) ) ; } } } ) ; }	For all PushSource callbacks we have to make sure that we get back to a security contextof SDC container module, otherwise we won't be able to update state files with new offsetsand other stuff.
private boolean checkrecordcontainssolrfields ( map < string , field > recordfieldmap , record record , list < string > solrfieldsmap , errors errortothrow ) throws stageexception {	Checks whether the record contains solr fields in solrFieldsMap or not.
private list < string > filterautogeneratedfieldnames ( list < string > fieldnames ) { list < string > result = new arraylist < > ( ) ; fieldnames . foreach ( name -> { if ( ! autogeneratedfieldnamesmap . contains ( name ) ) { result . add ( name ) ; } } ) ; return result ; }	Filter auto-generated fields from the list passed as argument.
private void sendonrecorderrorexceptiontohandler ( record record , errors error , stageexception ex ) throws stageexception { errorrecordhandler . onerror ( new onrecorderrorexception ( record , error , record . getheader ( ) . getsourceid ( ) , ex . tostring ( ) , ex ) ) ; }	Send exception ex to errorRecordHandler in order to let the handler process it.
public static optional < dependency > parsejarname ( string sourcename , string jarname ) { if ( special_cases . containskey ( jarname ) ) { dependency specialcase = special_cases . get ( jarname ) ; return optional . of ( new dependency ( sourcename , specialcase . getname ( ) , specialcase . getversion ( ) ) ) ; }	Generate dependency from a jar file name.
public static optional < dependency > parseurl ( url url ) { return parsejarname ( url . tostring ( ) , paths . get ( url . getpath ( ) ) . getfilename ( ) . tostring ( ) ) ; }	Generate dependency from a URL.
public static synchronized couchbaseconnector getinstance ( basecouchbaseconfig config , list < stage . configissue > issues , stage . context context ) { map < string , object > runnersharedmap = context . getstagerunnersharedmap ( ) ; if ( runnersharedmap . containskey ( instance ) ) { log . debug ( str_ ) ; } else { log . debug ( str_ ) ; validateconfig ( config , issues , context ) ; if ( issues . isempty ( ) ) { runnersharedmap . put ( instance , new couchbaseconnector ( config , issues , context ) ) ; } } return ( couchbaseconnector ) runnersharedmap . get ( instance ) ; }	Maintains a singleton instance of the CouchbaseConnector object per pipeline.
public synchronized void close ( ) { if ( ! isclosed ) { if ( bucket != null ) { log . debug ( str_ ) ; bucket . close ( ) ; } if ( cluster != null ) { log . debug ( str_ ) ; cluster . disconnect ( ) ; } if ( env != null ) { log . debug ( str_ ) ; env . shutdown ( ) ; }	Disconnects from Couchbase and releases all resources.
public static string getlabelfromstringcode ( string code ) throws numberformatexception { try { int intcode = integer . parseint ( code ) ; return getlabelfromintcode ( intcode ) ; } catch ( numberformatexception ex ) { throw new numberformatexception ( string . format ( str_ , str_ , code ) ) ; } }	Convert from code in String type to label.
private void verifydependencyexists ( map < string , configdefinition > definitionsmap , configdefinition def , string dependsonkey , object contextmsg ) { preconditions . checkstate ( definitionsmap . containskey ( dependsonkey ) , utils . format ( str_ , contextmsg , def . getname ( ) , dependsonkey ) ) ; }	Verify that the config definition's dependency actually maps to a valid config definition.
private writeoperationtype getoperationfromheader ( record record , string key ) { string op = record . getheader ( ) . getattribute ( operationtype . sdc_operation_type ) ; if ( op == null || op . isempty ( ) ) { return config . defaultwriteoperation ; } int opcode ; try { opcode = integer . parseint ( op ) ; } catch ( numberformatexception e ) { log . debug ( str_ ) ; handleerror ( record , errors . couchbase_08 , e ) ; return null ; } switch ( opcode ) { case operationtype . insert_code : return writeoperationtype . insert ; case operationtype . update_code : return writeoperationtype . replace ; case operationtype . upsert_code : return writeoperationtype . upsert ; case operationtype . delete_code : return writeoperationtype . delete ; default : switch ( config . unsupportedoperation ) { case discard : log . debug ( str_ , key ) ; return null ; case toerror : log . debug ( str_ , key ) ; handleerror ( record , errors . couchbase_09 , new runtimeexception ( ) ) ; return null ; default : log . debug ( str_ , key ) ; return config . defaultwriteoperation ; } } }	Evaluates the sdc.operation.type header for a record and returns the equivalent Couchbase write operation type.
private observable < documentfragment < mutation > > buildsubdocmutation ( asyncmutateinbuilder mutation , int ttl , long cas , boolean upsertdoc ) { return mutation . upsertdocument ( upsertdoc ) . withexpiry ( ttl ) . withcas ( cas ) . withdurability ( config . persistto , config . replicateto ) . execute ( ) . timeout ( config . couchbase . kvtimeout , timeunit . milliseconds ) ; }	Applies standard options to sub-document mutations.
@ override protected string makealtertablesqlstring ( string schema , string tablename , linkedhashmap < string , jdbctypeinfo > columndiff ) { string tableschema = ( schema == null ) ? getdefaultschema ( ) : schema ; stringbuilder sqlstring = new stringbuilder ( ) ; boolean first = bool_ ; for ( map . entry < string , jdbctypeinfo > entry : columndiff . entryset ( ) ) { if ( first ) { first = bool_ ; } else { sqlstring . append ( str_ ) ; } sqlstring . append ( alter_table ) . append ( str_ ) ; if ( tableschema != null ) { sqlstring . append ( tableschema ) ; sqlstring . append ( str_ ) ; } sqlstring . append ( tablename ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( entry . getkey ( ) ) . append ( str_ ) . append ( entry . getvalue ( ) . tostring ( ) ) . append ( str_ ) ; } return sqlstring . tostring ( ) ; }	H2 wants an ALTER TABLE command per column.
public void configure ( map < string , ? > configs , final string logincontextname ) { super . configure ( configs , logincontextname ) ; this . logincontextname = logincontextname ; this . ticketrenewwindowfactor = ( double ) configs . get ( saslconfigs . sasl_kerberos_ticket_renew_window_factor ) ; this . ticketrenewjitter = ( double ) configs . get ( saslconfigs . sasl_kerberos_ticket_renew_jitter ) ; this . mintimebeforerelogin = ( long ) configs . get ( saslconfigs . sasl_kerberos_min_time_before_relogin ) ; this . kinitcmd = ( string ) configs . get ( saslconfigs . sasl_kerberos_kinit_cmd ) ; this . servicename = getservicename ( configs , logincontextname ) ; }	Login constructor. The constructor starts the thread usedto periodically re-login to the Kerberos Ticket Granting Server.
public offsetandresult < map . entry > take ( ) { if ( producererror != null ) { throw new runtimeexception ( utils . format ( str_ , producererror ) , producererror ) ; } if ( consumererror != null ) { throw new runtimeexception ( utils . format ( str_ , consumererror ) , consumererror ) ; } try { utils . checkstate ( batchcommitted , str_ ) ; while ( running ) { for ( controlchannel . message controlmessage : controlchannel . getconsumermessages ( ) ) { switch ( controlmessage . gettype ( ) ) { case producer_complete :	Consumes messages off the queue.
public void commit ( string offset ) { batchcommitted = bool_ ; log . trace ( str_ , lastcommittedoffset , offset ) ; utils . checkstate ( null != lastcommittedoffset , str_ ) ; controlchannel . consumercommit ( offset ) ; lastcommittedoffset = offset ; }	Commit the offset. Required after take has returned a non-null value.
public void error ( throwable throwable ) { if ( consumererror == null ) { consumererror = throwable ; controlchannel . consumererror ( throwable ) ; } }	Send a control message indicating the consumer has encountered an error.
public void injectstage ( object stage , stagedefinition stagedef , stageconfiguration stageconf , map < string , object > constants , list < issue > issues ) { injectconfigstoobject ( stage , new stageinjectorcontext ( stagedef , stageconf , constants , issues ) ) ; }	Inject config values to given Stage.
public definitionsjson getdefinitions ( hidestage . type hidestage ) throws apiexception { object postbody = null ; byte [ ] postbinarybody = null ;	Returns pipeline &amp; stage configuration definitionsThis will fetch defintions based on the hideStage filter.
private lineagepublisherdefinition getdefinition ( string name ) { string defconfig = lineagepublisherconstants . configdef ( name ) ; string publisherdefinition = configuration . get ( defconfig , null ) ; if ( stringutils . isempty ( publisherdefinition ) ) { throw new illegalargumentexception ( utils . format ( str_ , defconfig ) ) ; } string [ ] lineageplugindefs = publisherdefinition . split ( str_ ) ; if ( lineageplugindefs . length != num_ ) { throw new illegalstateexception ( utils . format ( str_ , publisherdefinition ) ) ; } lineagepublisherdefinition def = stagelibrarytask . getlineagepublisherdefinition ( lineageplugindefs [ num_ ] ,	Parse given configuration declaration of lineage plugin and return appropriate definition.This method will throw exceptions on all error paths.
private static string formatname ( string columnname , boolean casesensitive ) { string returnvalue = format ( columnname ) ; if ( casesensitive ) { return returnvalue ; } return returnvalue . touppercase ( ) ; }	Format column names based on whether they are case-sensitive.
private static string formatvalue ( string value ) {	Unescapes strings and returns them.
public pipelineconfigurationjson getpipelineinfo ( string pipelineid , string rev , string get , boolean attachment ) throws apiexception { object postbody = null ; byte [ ] postbinarybody = null ;	Find Pipeline Configuration by name and revision.
public pipelinefragmentenvelopejson createdraftpipelinefragment ( string fragmentid , string description , list < stageconfigurationjson > stageinstances ) throws apiexception { object postbody = stageinstances ; byte [ ] postbinarybody = null ;	Add a new Pipeline Fragment Configuration to the store.
public list < pipelineinfojson > getpipelines ( string filtertext , string label , int offset , int len , pipelineorderbyfields orderby , order order , boolean includestatus ) throws apiexception { object postbody = null ; byte [ ] postbinarybody = null ;	Returns all Pipeline Configuration Info.
public pipelinefragmentenvelopejson importpipelinefragment ( string fragmentid , boolean draft , boolean includelibrarydefinitions , pipelinefragmentenvelopejson fragmentenvelope ) throws apiexception { object postbody = fragmentenvelope ; byte [ ] postbinarybody = null ;	Import Pipeline Fragment Configuration & Rules.
public string getfilepath ( string dirpathtemplate , record record , date recordtime ) throws stageexception { string dirpath ;	Returns the temp file path to write records to.
int getoperationfromrecord ( record record , int defaultopcode , unsupportedoperationaction unsupportedaction , list < onrecorderrorexception > errorrecords ) { string op = record . getheader ( ) . getattribute ( operationtype . sdc_operation_type ) ; int opcode = - num_ ;	Get the numeric operation code from record header.
string getfieldpath ( string columnname , map < string , string > columnstofield , int op ) { return columnstofield . get ( columnname ) ; }	This function simply returns field path in record for the corresponding column name.This is needed because records generated by CDC origins store data in different locationfor different operation.
public enrichedevent poll ( long timeout , timeunit unit ) throws stageexception { try { return queue . poll ( timeout , unit ) ; } catch ( interruptedexception e ) { log . error ( errors . mysql_001 . getmessage ( ) , e . tostring ( ) , e ) ; thread . currentthread ( ) . interrupt ( ) ; throw new stageexception ( errors . mysql_001 , e . tostring ( ) , e ) ; } }	Read next event from buffer with respect to maximum timeout.
public t getrunner ( ) throws pipelineruntimeexception { validatenotdestroyed ( ) ; try { return queue . take ( ) . runner ; } catch ( interruptedexception e ) { throw new pipelineruntimeexception ( containererror . container_0801 , e ) ; } finally { runtimestats . setavailablerunners ( queue . size ( ) ) ; histogram . update ( queue . size ( ) ) ; } }	Get exclusive runner for use.
public t getidlerunner ( long idletime ) {	Return a runner that haven't been used at least for the configured number of milliseconds.
public void returnrunner ( t runner ) throws pipelineruntimeexception { validatenotdestroyed ( ) ; queue . add ( new queueitem < > ( runner ) ) ; runtimestats . setavailablerunners ( queue . size ( ) ) ; histogram . update ( queue . size ( ) ) ; }	Return given runner back to the pool.
public void destroy ( ) throws pipelineruntimeexception {	Destroy only the pool itself - not the individual pipe runners.This method will also validate that all runners were properly returned to the pool.
private void validatenotdestroyed ( ) throws pipelineruntimeexception { if ( destroyed . get ( ) ) { throw new pipelineruntimeexception ( containererror . container_0803 , queue . size ( ) , runtimestats . gettotalrunners ( ) ) ; } }	Throw an exception if the runner was already destroyed.
public static long checkstreamexists ( clientconfiguration awsclientconfig , kinesisconfigbean conf , string streamname , list < stage . configissue > issues , stage . context context ) { long numshards = num_ ; try { numshards = getshardcount ( awsclientconfig , conf , streamname ) ; } catch ( amazonclientexception | stageexception e ) { log . error ( errors . kinesis_01 . getmessage ( ) , e . tostring ( ) , e ) ; issues . add ( context . createconfigissue ( groups . kinesis . name ( ) , kinesis_config_bean + str_ , errors . kinesis_01 , e . tostring ( ) ) ) ; } return numshards ; }	Checks for existence of the requested stream and addsany configuration issues to the list.
public static string getlastshardid ( clientconfiguration awsclientconfig , kinesisconfigbean conf , string streamname ) throws stageexception { amazonkinesis kinesisclient = getkinesisclient ( awsclientconfig , conf ) ; string lastshardid = null ; try { streamdescription description ; do { if ( lastshardid == null ) { description = kinesisclient . describestream ( streamname ) . getstreamdescription ( ) ; } else { description = kinesisclient . describestream ( streamname , lastshardid ) . getstreamdescription ( ) ; } int pagesize = description . getshards ( ) . size ( ) ; lastshardid = description . getshards ( ) . get ( pagesize - num_ ) . getshardid ( ) ; } while ( description . gethasmoreshards ( ) ) ; return lastshardid ; } finally { kinesisclient . shutdown ( ) ; } }	Get the last shard Id in the given streamIn preview mode, kinesis source uses the last Shard Id to get records from kinesis.
private void processqueue ( linkedlist < record > queue , list < onrecorderrorexception > errorrecords , connection connection , int maxrowsperbatch , int opcode ) throws stageexception { if ( queue . isempty ( ) ) { return ; } int rowcount = num_ ;	Process all records in queue.
private void handlesqlexception ( sqlexception exception , list < record > inputrecords , list < onrecorderrorexception > errors ) throws stageexception { if ( jdbcutil . isdataerror ( getcustomdatasqlstatecodes ( ) , getconnectionstring ( ) , exception ) ) { string formattederror = jdbcutil . formatsqlexception ( exception ) ; log . error ( jdbcerrors . jdbc_89 . getmessage ( ) , formattederror ) ; for ( record inputrecord : inputrecords ) { errors . add ( new onrecorderrorexception ( inputrecord , jdbcerrors . jdbc_89 , formattederror ) ) ; } return ; } super . handlesqlexception ( exception ) ; }	Handle SQLException in a smart way, detecting if the exception is data oriented or not.
private hashcode getcolumnhash ( record record , int op ) throws onrecorderrorexception { map < string , string > parameters = getcolumnstoparameters ( ) ; sortedmap < string , string > columnstoparameters = recordreader . getcolumnstoparameters ( record , op , parameters , getcolumnstofields ( ) ) ; return columnhashfunction . newhasher ( ) . putobject ( columnstoparameters , stringmapfunnel ) . hash ( ) ; }	Generates a hash for the fields present in a record and their mappings.A specific implementation of the hash function is not guaranteed.
public static boolean comparefiles ( wrappedfilesystem fs , wrappedfile f1 , wrappedfile f2 ) { if ( ! fs . exists ( f2 ) ) { return bool_ ; } try { long mtime1 = fs . getlastmodifiedtime ( f1 ) ; long mtime2 = fs . getlastmodifiedtime ( f2 ) ; long ctime1 = fs . getchangedtime ( f1 ) ; long ctime2 = fs . getchangedtime ( f2 ) ; long time1 = math . max ( mtime1 , ctime1 ) ; long time2 = math . max ( mtime2 , ctime2 ) ; int compares = long . compare ( time1 , time2 ) ; if ( compares != num_ ) { return compares > num_ ; } } catch ( ioexception ex ) { log . error ( str_ , f1 . getfilename ( ) , ex ) ; return bool_ ; } return f1 . getabsolutepath ( ) . compareto ( f2 . getabsolutepath ( ) ) > num_ ; }	True if f1 is "newer" than f2.
private static int retrievepidiffeasible ( process process ) { if ( unixprocessclass == null ) { return undetermined_pid ; } if ( ! unixprocessclass . isinstance ( process ) ) { log . debug ( str_ , process . getclass ( ) . getname ( ) ) ; return undetermined_pid ; } try { return ( int ) pidfield . get ( process ) ; } catch ( illegalaccessexception e ) { log . debug ( str_ , e ) ; return undetermined_pid ; } }	Attempts to retrieve PID from internal JVM classes.
private set < string > validateandextractfieldstohash ( record record , set < string > fieldsdontexist , set < string > fieldswithlistormaptype , set < string > fieldswithnull , collection < string > matchingfieldspath ) { set < string > validfieldstohashforthisconfig = new hashset < string > ( ) ; for ( string matchingfieldpath : matchingfieldspath ) { if ( record . has ( matchingfieldpath ) ) { field field = record . get ( matchingfieldpath ) ; if ( unsupported_field_types . contains ( field . gettype ( ) ) ) { fieldswithlistormaptype . add ( matchingfieldpath ) ; } else if ( field . getvalue ( ) == null ) { fieldswithnull . add ( matchingfieldpath ) ; } else { validfieldstohashforthisconfig . add ( matchingfieldpath ) ; } } else { fieldsdontexist . add ( matchingfieldpath ) ; } } return validfieldstohashforthisconfig ; }	Basically throw out map, list map, list and null values fields.
public static usergroupinformation getproxyuser ( string user ,	Return UGI object that should be used for any remote operation.This object will be impersonate according to the configuration.
public activestats roll ( ) { long now = system . currenttimemillis ( ) ; setendtime ( now ) ; activestats statsbean = new activestats ( ) . setstarttime ( now ) . setdatacollectorversion ( getdatacollectorversion ( ) ) . setdpmenabled ( isdpmenabled ( ) ) . setuptime ( getuptime ( ) . roll ( ) ) ; statsbean . setpipelines ( getpipelines ( ) . stream ( ) . map ( usagetimer :: roll ) . collect ( collectors . tolist ( ) ) ) ; statsbean . setstages ( getstages ( ) . stream ( ) . filter ( timer -> timer . getmultiplier ( ) > num_ ) . map ( usagetimer :: roll ) . collect ( collectors . tolist ( ) ) ) ; return statsbean ; }	returns fresh bean with same UsageTimers just reset to zero accumulated time to be used as the new live stats.
public activestats snapshot ( ) { activestats snapshot = new activestats ( ) . setstarttime ( getstarttime ( ) ) . setdatacollectorversion ( getdatacollectorversion ( ) ) . setdpmenabled ( isdpmenabled ( ) ) . setuptime ( getuptime ( ) . snapshot ( ) ) . setrecordcount ( getrecordcount ( ) ) ; snapshot . setpipelines ( getpipelines ( ) . stream ( ) . map ( usagetimer :: snapshot ) . collect ( collectors . tolist ( ) ) ) ; snapshot . setstages ( getstages ( ) . stream ( ) . map ( usagetimer :: snapshot ) . collect ( collectors . tolist ( ) ) ) ; return snapshot ; }	returns a snapshot for persistency.
private void ensuredirectoryexists ( filesystem fs , path path ) throws ioexception { if ( ! fs . exists ( path ) ) { log . debug ( str_ , path ) ; if ( ! fs . mkdirs ( path ) ) { throw new ioexception ( str_ + path ) ; } } }	Ensure that given directory exists.Creates the directory if it doesn't exists.
public void write ( batch batch , schematableclassifier schematableclassifier , loadingcache < schemaandtable , jdbcrecordwriter > recordwriters , errorrecordhandler errorrecordhandler , boolean perrecord ) throws stageexception { multimap < schemaandtable , record > partitions = schematableclassifier . classify ( batch ) ; for ( schemaandtable key : partitions . keyset ( ) ) { iterator < record > recorditerator = partitions . get ( key ) . iterator ( ) ; write ( recorditerator , key , recordwriters , errorrecordhandler , perrecord ) ; } }	Write records to potentially different schemas and tables using EL expressions, and handle errors.
public void write ( batch batch , eleval tablenameeval , elvars tablenamevars , string tablenametemplate , loadingcache < string , jdbcrecordwriter > recordwriters , errorrecordhandler errorrecordhandler , boolean perrecord ) throws stageexception { multimap < string , record > partitions = elutils . partitionbatchbyexpression ( tablenameeval , tablenamevars , tablenametemplate , batch ) ; for ( string tablename : partitions . keyset ( ) ) { iterator < record > recorditerator = partitions . get ( tablename ) . iterator ( ) ; write ( recorditerator , tablename , recordwriters , errorrecordhandler , perrecord ) ; } }	Write records to the evaluated tables and handle errors.
public < t > void write ( iterator < record > recorditerator , t key , loadingcache < t , jdbcrecordwriter > recordwriters , errorrecordhandler errorrecordhandler , boolean perrecord ) throws stageexception { final jdbcrecordwriter jdbcrecordwriter ; try { jdbcrecordwriter = recordwriters . getunchecked ( key ) ; } catch ( uncheckedexecutionexception ex ) { final throwable throwable = ex . getcause ( ) ; final errorcode errorcode ; final object [ ] messageparams ; if ( throwable instanceof stageexception ) { stageexception stageex = ( stageexception ) ex . getcause ( ) ; errorcode = stageex . geterrorcode ( ) ; messageparams = stageex . getparams ( ) ; } else { errorcode = jdbcerrors . jdbc_301 ; messageparams = new object [ ] { ex . getmessage ( ) , ex . getcause ( ) } ; }	Write records to a JDBC destination using the recordWriter specified by key, and handle errors.
public void generatenomoredataevent ( pushsource . context context ) { log . info ( str_ ) ; batchcontext batchcontext = context . startbatch ( ) ; commonevents . no_more_data . create ( context , batchcontext ) . createandsend ( ) ; context . processbatch ( batchcontext ) ; }	Generates the no-more-data event.
private map < partitioninfocachesupport . partitionvalues , string > detectnewpartition ( partitioninfocachesupport . partitionvalues partitionvalues , partitioninfocachesupport . partitioninfo pcache , string location ) throws stageexception { map < partitioninfocachesupport . partitionvalues , string > partitioninfodiff = new hashmap < > ( ) ; partitioninfodiff . put ( partitionvalues , location ) ; partitioninfodiff = ( pcache != null ) ? pcache . getdiff ( partitioninfodiff ) : partitioninfodiff ; if ( pcache == null || ! partitioninfodiff . isempty ( ) ) { return partitioninfodiff ; } return null ; }	Using partition name and value that were obtained from record, compare themwith cached partition.
@ visiblefortesting static void updaterecordforhdfs ( record record , boolean roll , string avroschema , string location ) { if ( roll ) { record . getheader ( ) . setattribute ( hdfs_header_roll , str_ ) ; } record . getheader ( ) . setattribute ( hdfs_header_avroschema , avroschema ) ; record . getheader ( ) . setattribute ( hdfs_header_target_directory , location ) ; log . trace ( str_ , record . getheader ( ) . getsourceid ( ) , location , roll , avroschema ) ; }	Add header information to send to HDFS.
public void process ( string group , t value ) { getdata ( ) . process ( immutablemap . of ( group , value ) ) ; }	Processes the given value into the corresponding group-by element of the aggregator.
public static boolean issameversion ( class < ? extends stage > a , class < ? extends stage > b ) { stagedef adef = a . getannotation ( stagedef . class ) ; stagedef bdef = b . getannotation ( stagedef . class ) ; return adef . version ( ) == bdef . version ( ) ; }	Returns if and only if both stage classes have defined the same version.
public static void main ( string [ ] args ) throws exception { bootstrapcluster . printsystempropsenvvariables ( ) ; string mesosdir = system . getenv ( str_ ) ; if ( mesosdir == null ) { throw new illegalstateexception ( str_ ) ; } file mesoshomedir = new file ( mesosdir ) ; string sparkdir = system . getenv ( str_ ) ; if ( sparkdir == null ) { throw new illegalstateexception ( str_ ) ; } file sparkhomedir = new file ( sparkdir ) ; int processexitvalue = bootstrapcluster . findandextractjar ( mesoshomedir , sparkhomedir ) ; if ( processexitvalue != num_ ) { throw new illegalstateexception ( str_ ) ; } system . setproperty ( str_ , new file ( mesoshomedir , bootstrapcluster . sdc_mesos_base_dir ) . getabsolutepath ( ) ) ; final class < ? > clazz = class . forname ( str_ ) ; final method method = clazz . getmethod ( str_ , string [ ] . class ) ; method . invoke ( null , new object [ ] { args } ) ; }	Bootstrapping the Driver which starts a Spark job on Mesos.
private void configureauthandbuildclient ( clientbuilder clientbuilder , list < stage . configissue > issues ) { if ( jerseyclientconfig . authtype == authenticationtype . oauth ) { string consumerkey = jerseyclientconfig . oauth . resolveconsumerkey ( context , str_ , str_ , issues ) ; string consumersecret = jerseyclientconfig . oauth . resolveconsumersecret ( context , str_ , str_ , issues ) ; string token = jerseyclientconfig . oauth . resolvetoken ( context , str_ , str_ , issues ) ; string tokensecret = jerseyclientconfig . oauth . resolvetokensecret ( context , str_ , str_ , issues ) ; if ( issues . isempty ( ) ) { authtoken = jerseyclientutil . configureoauth1 ( consumerkey , consumersecret , token , tokensecret , clientbuilder ) ; } } else if ( jerseyclientconfig . authtype . isoneof ( authenticationtype . digest , authenticationtype . basic , authenticationtype . universal ) ) { string username = jerseyclientconfig . basicauth . resolveusername ( context , str_ , str_ , issues ) ; string password = jerseyclientconfig . basicauth . resolvepassword ( context , str_ , str_ , issues ) ; if ( issues . isempty ( ) ) { jerseyclientutil . configurepasswordauth ( jerseyclientconfig . authtype , username , password , clientbuilder ) ; } } try { buildnewauthenticatedclient ( issues , bool_ ) ; clientinitialized = bool_ ; } catch ( stageexception e ) {	Helper to apply authentication properties to Jersey client.
public multivaluedmap < string , object > resolveheaders ( map < string , string > headers , record record ) throws stageexception { recordel . setrecordincontext ( headervars , record ) ; multivaluedmap < string , object > requestheaders = new multivaluedhashmap < > ( ) ; for ( map . entry < string , string > entry : headers . entryset ( ) ) { list < object > header = new arraylist < > ( num_ ) ; object resolvedvalue = headereval . eval ( headervars , entry . getvalue ( ) , string . class ) ; header . add ( resolvedvalue ) ; requestheaders . put ( entry . getkey ( ) , header ) ; } return requestheaders ; }	Evaluates any EL expressions in the headers section of the stage configuration.
public httpmethod gethttpmethod ( httpmethod httpmethod , string methodexpression , record record ) throws elevalexception { if ( httpmethod != httpmethod . expression ) { return httpmethod ; } recordel . setrecordincontext ( methodvars , record ) ; return httpmethod . valueof ( methodeval . eval ( methodvars , methodexpression , string . class ) ) ; }	Determines the HTTP method to use for the next request.
public static void fillnulltypes ( simplebindings bindings ) { bindings . put ( str_ , null_boolean ) ; bindings . put ( str_ , null_char ) ; bindings . put ( str_ , null_byte ) ; bindings . put ( str_ , null_short ) ; bindings . put ( str_ , null_integer ) ; bindings . put ( str_ , null_long ) ; bindings . put ( str_ , null_float ) ; bindings . put ( str_ , null_double ) ; bindings . put ( str_ , null_date ) ; bindings . put ( str_ , null_datetime ) ; bindings . put ( str_ , null_time ) ; bindings . put ( str_ , null_decimal ) ; bindings . put ( str_ , null_byte_array ) ; bindings . put ( str_ , null_string ) ; bindings . put ( str_ , null_list ) ; bindings . put ( str_ , null_map ) ; }	Add each object of typed null to SimpleBindings, so that script languagescan use constants such as "NULL_INTEGER", "NULL_LONG" without importingother files.
public static object getfieldnull ( record record , string fieldpath ) { field f = record . get ( fieldpath ) ; if ( f != null ) { return f . getvalue ( ) == null ? gettypednullfromfield ( f ) : f . getvalue ( ) ; } return null ; }	Receive record and fieldPath from scripting processor.It resolves type of the field, and if value is null, it returnsone of the NULL_XXX objects defined in this class.If field value is not null, it returns the value stored in the field.
public schema loadfromregistry ( string subject , int schemaid ) throws schemaregistryexception { try { if ( isempty ( subject ) ) { return loadfromregistry ( schemaid ) ; } else { return loadfromregistry ( subject ) ; } } catch ( schemaregistryexception e ) { throw new schemaregistryexception ( e ) ; } }	Parses and returns an Avro schema loaded from the schema registry using the provided schema IDif available, or the latest version of a schema for the specified subject.
public int registerschema ( schema schema , string subject ) throws schemaregistryexception { try { return schemaidcache . get ( subject + schema . hashcode ( ) , ( ) -> registryclient . register ( subject , schema ) ) ; } catch ( executionexception e ) { throw new schemaregistryexception ( e ) ; } }	Registers a parsed schema with the schema registry under the specified subject.
public schema loadfromregistry ( string subject ) throws schemaregistryexception { try { schemametadata metadata = registryclient . getlatestschemametadata ( subject ) ; return registryclient . getbyid ( metadata . getid ( ) ) ; } catch ( ioexception | restclientexception e ) { throw new schemaregistryexception ( e ) ; } }	Loads and parses a schema for the specified subject from the schema registry.
public int getschemaidfromsubject ( string subject ) throws schemaregistryexception { try { schemametadata metadata = registryclient . getlatestschemametadata ( subject ) ; return metadata . getid ( ) ; } catch ( ioexception | restclientexception e ) { throw new schemaregistryexception ( e ) ; } }	Looks up schema id for the specified subject from the schema registry.
public schema loadfromregistry ( int id ) throws schemaregistryexception { try { return registryclient . getbyid ( id ) ; } catch ( ioexception | restclientexception e ) { throw new schemaregistryexception ( e ) ; } }	Loads and parses a schema for the specified schema ID from the schema registry.
public int writeschemaid ( outputstream os , int schemaid ) throws ioexception { if ( schemaid > num_ ) { os . write ( magic_byte ) ; os . write ( bytebuffer . allocate ( id_size ) . putint ( schemaid ) . array ( ) ) ; } return schemaid ; }	Writes the magic byte and schema ID to an output stream, replicating the functionalityof the Confluent Kafka Avro Serializer.
public optional < integer > detectschemaid ( byte [ ] data ) { if ( data . length < num_ ) { return optional . empty ( ) ; } bytebuffer wrapped = bytebuffer . wrap ( data ) ;	Checks for a magic byte in the data and if present extracts the schemaId.
public static map < string , object > getdefaultvalues ( schema schema ) throws schemaregistryexception { map < string , object > defaultvalues = new hashmap < > ( ) ; try { defaultvalues . putall ( avrotypeutil . getdefaultvaluesfromschema ( schema , new hashset < string > ( ) ) ) ; } catch ( ioexception e ) { throw new schemaregistryexception ( e ) ; } return defaultvalues ; }	Helper method to extract default values from a Schema.
public static list < record > parseall ( stage . context stagecontext , toerrorcontext toerrorcontext , boolean producesinglerecordpermessage , string messageid , byte [ ] payload ) throws stageexception { list < record > records = new arraylist < > ( ) ; try ( dataparser parser = stagecontext . getservice ( dataformatparserservice . class ) . getparser ( messageid , payload ) ) { record record = null ; do { try { record = parser . parse ( ) ; } catch ( recoverabledataparserexception e ) { handleexception ( stagecontext , toerrorcontext , messageid , e , e . getunparsedrecord ( ) ) ;	Convenience method to parse all available records in given payload.
public void logdetails ( ) { if ( isvalid ( ) ) { return ; } log . warn ( str_ , name ) ; if ( ! unparseablepaths . isempty ( ) ) { log . warn ( str_ ) ; for ( string path : unparseablepaths ) { log . warn ( str_ , path ) ; } } if ( ! versioncollisions . isempty ( ) ) { log . warn ( str_ ) ; for ( map . entry < string , map < string , list < dependency > > > entry : versioncollisions . entryset ( ) ) { log . warn ( str_ , entry . getkey ( ) , stringutils . join ( entry . getvalue ( ) . keyset ( ) , str_ ) ) ; for ( map . entry < string , list < dependency > > versionentry : entry . getvalue ( ) . entryset ( ) ) { log . warn ( str_ , versionentry . getkey ( ) ) ; for ( dependency dependency : versionentry . getvalue ( ) ) { log . warn ( str_ , dependency . getsourcename ( ) ) ; } } } } }	Generate small report into log.
private list < record > getbadrecords ( errorsink errorsink ) { list < record > badrecords = new arraylist < > ( ) ; for ( map . entry < string , list < record > > entry : errorsink . geterrorrecords ( ) . entryset ( ) ) { for ( record record : entry . getvalue ( ) ) { recordimpl errorrecord ; switch ( errorrecordpolicy ) { case original_record : errorrecord = ( recordimpl ) ( ( recordimpl ) record ) . getheader ( ) . getsourcerecord ( ) ; errorrecord . getheader ( ) . copyerrorfrom ( record ) ; break ; case stage_record : errorrecord = ( recordimpl ) record ; break ; default : throw new illegalargumentexception ( str_ + errorrecordpolicy ) ; } errorrecord . getheader ( ) . seterrorcontext ( runtimeinfo . getid ( ) , pipelinename ) ; badrecords . add ( errorrecord ) ; } } return badrecords ; }	Generate list of error records from the error sink.
public list < stage . configissue > init ( schemageneratorconfig config , stage . context context ) { this . config = config ; return collections . emptylist ( ) ; }	Initialize the schema generator.
public collection < v > getoutwardedgevertices ( v vertex ) { collection < v > outwardedgeverticesforvertex = outwardedgevertices . get ( vertex ) ; return outwardedgeverticesforvertex != null ? outwardedgeverticesforvertex : collections . < v > emptyset ( ) ; }	Returns the outward flowing edge vertices.
public collection < v > getinwardedgevertices ( v vertex ) { collection < v > inwardedgeverticesforvertex = inwardedgesvertices . get ( vertex ) ; return inwardedgeverticesforvertex != null ? inwardedgeverticesforvertex : collections . < v > emptyset ( ) ; }	Returns the inward flowing edge vertices.
public static string serializeoffsetmap ( map < string , string > offsetmap ) throws ioexception { return json_mapper . writevalueasstring ( offsetmap ) ; }	Serialize the Map of table to offset to a String.
@ suppresswarnings ( str_ ) public static map < string , string > deserializeoffsetmap ( string lastsourceoffset ) throws ioexception { map < string , string > offsetmap ; if ( lastsourceoffset == null || lastsourceoffset . isempty ( ) ) { offsetmap = new hashmap < > ( ) ; } else { offsetmap = json_mapper . readvalue ( lastsourceoffset , map . class ) ; } return offsetmap ; }	Deserialize String offset to Map of table to offset.
public int queuereport ( ) throws ioexception , interruptedexception , executionexception , timeoutexception , stageexception { final asyncinvoker asyncinvoker = queueresource . request ( ) . header ( wsse_header , omnitureauthutil . getheader ( username . get ( ) , sharedsecret . get ( ) ) ) . async ( ) ; log . debug ( str_ , queueresource . geturi ( ) . tourl ( ) . tostring ( ) , reportdescription ) ; final future < response > responsefuture = asyncinvoker . post ( entity . json ( reportdescription ) ) ; response response = responsefuture . get ( responsetimeoutmillis , timeunit . milliseconds ) ; if ( response == null ) { log . error ( str_ , queueresource . geturi ( ) . tourl ( ) . tostring ( ) ) ; throw new stageexception ( errors . omniture_01 , str_ ) ; } log . debug ( str_ , response . getstatus ( ) ) ; objectmapper mapper = new objectmapper ( ) ; string json = response . readentity ( string . class ) ; log . trace ( str_ , json ) ; jsonnode root = mapper . readtree ( json ) ; if ( root == null ) { log . error ( str_ , json ) ; throw new stageexception ( errors . omniture_01 , json ) ; } if ( root . has ( str_ ) ) { throw new stageexception ( errors . omniture_01 , root . get ( str_ ) . astext ( ) ) ; } log . info ( str_ ) ; return root . get ( str_ ) . asint ( ) ; }	Queue a report using the Report.Queue method.
public void getreport ( int reportid ) throws interruptedexception , executionexception , timeoutexception , ioexception , stageexception { int waittime = num_ ; response response = null ; while ( ! stop ) { final asyncinvoker asyncinvoker = getresource . request ( ) . header ( wsse_header , omnitureauthutil . getheader ( username . get ( ) , sharedsecret . get ( ) ) ) . async ( ) ; log . debug ( str_ , getresource . geturi ( ) . tourl ( ) . tostring ( ) , reportid ) ; final future < response > responsefuture = asyncinvoker . post ( entity . json ( str_ + reportid + str_ ) ) ; response = responsefuture . get ( responsetimeoutmillis , timeunit . milliseconds ) ; string input = response . readentity ( string . class ) ; objectmapper mapper = new objectmapper ( ) ; jsonnode root = mapper . readtree ( input ) ;	Posts a request to the Omniture API to get a report back.
public boolean issdccheckpointing ( ) { try { return fs . exists ( checkpointfilepath ) || fs . exists ( backupcheckpointfilepath ) ; } catch ( ioexception ex ) { log . error ( str_ , ex ) ; throw new runtimeexception ( utils . format ( str_ , checkpointfilepath . tostring ( ) , ex . tostring ( ) ) , ex ) ; } }	This tell us SDC is check pointing.
private void writeoffsetstomainoffsetfile ( map < integer , long > partitiontooffsetmap ) throws ioexception { log . info ( str_ , partitiontooffsetmap , checkpointfilepath ) ;	Or if the file is corrupted, we want to update the right offsets to the main offset file.
private void delete ( blobid blobid ) { log . debug ( str_ , string . format ( blob_path_template , blobid . getbucket ( ) , blobid . getname ( ) ) ) ; boolean deleted = storage . delete ( blobid ) ; if ( ! deleted ) { log . error ( str_ , string . format ( blob_path_template , blobid . getbucket ( ) , blobid . getname ( ) ) ) ; } }	Delete a blob for gcs.
void handleerror ( blobid blobid ) { switch ( gcsoriginerrorconfig . errorhandlingoption ) { case none : break ; case archive : handlearchive ( blobid ) ; break ; case delete : delete ( blobid ) ; break ; } }	Handle error Blob.
private void handlearchive ( blobid blobid ) { string destinationpath = getdestinationpath ( blobid , gcsoriginerrorconfig . errorprefix ) ; switch ( gcsoriginerrorconfig . archivingoption ) { case copy_to_bucket : copy ( blobid , gcsoriginerrorconfig . errorbucket , destinationpath , bool_ ) ; break ; case move_to_bucket : copy ( blobid , gcsoriginerrorconfig . errorbucket , destinationpath , bool_ ) ; break ; case copy_to_prefix : copy ( blobid , blobid . getbucket ( ) , destinationpath , bool_ ) ; break ; case move_to_prefix : copy ( blobid , blobid . getbucket ( ) , destinationpath , bool_ ) ; break ; } }	Archive the blob.
public livefilereader getreader ( ) throws ioexception { utils . checkstate ( open , str_ ) ; if ( reader == null ) { currentfile = getstartingcurrentfilename ( ) ; long fileoffset = getstartingoffset ( ) ; boolean needstoscan = currentfile == null || fileoffset == long . max_value ; if ( needstoscan ) { if ( currentfile != null ) {	prepares and gets the reader if available before a read.
public void releasereader ( boolean inerrordiscardreader ) throws ioexception { utils . checkstate ( open , str_ ) ;	updates reader and offsets after a read.
public apiclient setdpmbaseurl ( string dpmbaseurl ) { if ( dpmbaseurl != null && authentication != null ) { authentication . setdpmbaseurl ( dpmbaseurl ) ; } return this ; }	Helper method to set dpmBaseURL for the first HTTP DPM authentication.
public apiclient adddefaultheader ( string key , string value ) { defaultheadermap . put ( key , value ) ; return this ; }	Add a default header.
public date parsedate ( string str ) { try { return dateformat . parse ( str ) ; } catch ( java . text . parseexception e ) { throw new runtimeexception ( e ) ; } }	Parse the given string into Date object.
public string escapestring ( string str ) { try { return urlencoder . encode ( str , str_ ) . replaceall ( str_ , str_ ) ; } catch ( unsupportedencodingexception e ) { return str ; } }	Escape the given string to be used as URL query value.
private client getclient ( ) { if ( ! hostmap . containskey ( basepath ) ) { clientconfig config = new clientconfig ( ) ; config . property ( clientproperties . suppress_http_compliance_validation , bool_ ) ; client client = clientbuilder . newclient ( config ) ; client . register ( new csrfprotectionfilter ( str_ ) ) ; hostmap . put ( basepath , client ) ; } return hostmap . get ( basepath ) ; }	Get an existing client or create a new client to handle HTTP request.
private gpudb initconnection ( kineticaconfigbean conf ) throws gpudbexception , stageexception { kineticaconnectionutils kineticaconnectionutils = new kineticaconnectionutils ( ) ; return kineticaconnectionutils . getgpudb ( conf ) ; }	Connect to the database.
private void gettablemetadata ( gpudb gpudb , string tablename ) throws gpudbexception { kineticatableutils kineticatableutils = new kineticatableutils ( gpudb , tablename ) ; type = kineticatableutils . gettype ( ) ; }	Get metadata for the table.
public eventbuilder create ( stage . context context , toeventcontext toevent ) { return new eventbuilder ( context , toevent ) ; }	Create new event record according for this stage context and event context.
public static schema buildschema ( map < string , schema > fields , object ... levels ) { list < schema . field > recordfields = new arraylist < > ( fields . size ( ) ) ; for ( map . entry < string , schema > entry : fields . entryset ( ) ) { recordfields . add ( new schema . field ( entry . getkey ( ) , entry . getvalue ( ) , null ,	Build a schema with type "record". This will be the top level schema and contains fields.
public static int convertfromoracletosdccode ( string code ) { try { int intcode = integer . parseint ( code ) ; switch ( intcode ) { case insert_code : return operationtype . insert_code ; case delete_code : return operationtype . delete_code ; case update_code : case select_for_update_code : return operationtype . update_code ; default :	This is called when JDBC target didn't find sdc.operation.code in record headerbut found oracle.cdc.operation.
public static void addjarstojob ( configuration conf , class ... klasses ) {	Add jars containing the following classes to the job's classpath.
private boolean checkfieldorderbylist ( soqlparser . fieldorderbylistcontext fieldorderbylist , string fieldname ) { return fieldorderbylist . fieldorderbyelement ( num_ ) . fieldelement ( ) . gettext ( ) . equalsignorecase ( fieldname ) ; }	Returns true if the first ORDER BY field matches fieldName.
private boolean checkconditionexpressions ( soqlparser . conditionexpressionscontext conditionexpressions , string fieldname ) { for ( soqlparser . conditionexpressioncontext ce : conditionexpressions . conditionexpression ( ) ) { if ( ( ce . conditionexpressions ( ) != null && checkconditionexpressions ( ce . conditionexpressions ( ) , fieldname ) ) || ( ce . fieldexpression ( ) != null && ce . fieldexpression ( ) . fieldelement ( ) . gettext ( ) . equalsignorecase ( fieldname ) ) ) { return bool_ ; } } return bool_ ; }	Returns true if any of the nested conditions contains fieldName.
public static long getoffsetlagforfile ( string fileoffsetstring ) throws ioexception { long offset = filecontextproviderutil . getlongoffsetfromfileoffset ( fileoffsetstring ) ;	If passed a valid fileOffsetString, it will return what is the offset lag in the file.
public static void premain ( string args , instrumentation instrumentation ) { if ( bootstrapmain . instrumentation == null ) { bootstrapmain . instrumentation = instrumentation ; } else { throw new illegalstateexception ( str_ + bootstrapmain . instrumentation + str_ ) ; } }	Visible due to JVM requirements only.
public int getparallelism ( ) throws stageexception { if ( originparallelism == num_ ) {	This API is being used by ClusterKafkaSource.
public tableresult runquery ( queryjobconfiguration queryconfig , long timeout , long pagesize ) throws stageexception { checkargument ( timeout >= num_ , str_ ) ; instant maxtime = instant . now ( ) . plusmillis ( timeout ) ;	Executes a query request and returns the results.
private list < string > gettabledescription ( ) throws gpudbexception { list < list < string > > descriptions = showtableresponse . gettabledescriptions ( ) ; if ( descriptions == null || descriptions . size ( ) != num_ ) { throw new gpudbexception ( str_ + tablename ) ; } return descriptions . get ( num_ ) ; }	Get the table description from the ShowTableResponse.
private void validatetableacceptsinserts ( ) throws gpudbexception { for ( string s : tabledescription ) { if ( s . equalsignorecase ( str_ ) ) { throw new gpudbexception ( str_ + tablename + str_ ) ; } else if ( s . equalsignorecase ( str_ ) ) { throw new gpudbexception ( str_ + tablename + str_ ) ; } else if ( s . equalsignorecase ( str_ ) ) { throw new gpudbexception ( str_ + tablename + str_ ) ; } else if ( s . equalsignorecase ( str_ ) ) { throw new gpudbexception ( str_ + tablename + str_ ) ; } } }	if it is not.
private class < ? > getcolumntype ( jsonobject field ) throws gpudbexception { class < ? > columntype = null ;	Get the Class for the column type.
private boolean typeisnullable ( jsonobject field ) throws gpudbexception { if ( field . get ( str_ ) instanceof jsonarray ) { jsonarray columntypes = field . getjsonarray ( str_ ) ; for ( int j = num_ ; j < columntypes . length ( ) ; j ++ ) { string ct = ( string ) columntypes . get ( j ) ; if ( ct . equals ( str_ ) ) { return bool_ ; } } } return bool_ ; }	the Avro "type" field).
private jsonobject gettableschema ( string tablename , showtableresponse showtableresponse ) throws gpudbexception { list < string > schemas = showtableresponse . gettypeschemas ( ) ; if ( schemas == null || schemas . size ( ) != num_ ) { throw new gpudbexception ( str_ + tablename ) ; } return new jsonobject ( schemas . get ( num_ ) ) ; }	Get the table's schema as a JSON Object.
private map < string , list < string > > getcolumnproperties ( string tablename , showtableresponse showtableresponse ) throws gpudbexception { list < map < string , list < string > > > columnpropertieslist = showtableresponse . getproperties ( ) ; if ( columnpropertieslist == null || columnpropertieslist . size ( ) != num_ ) { throw new gpudbexception ( str_ + tablename ) ; } return columnpropertieslist . get ( num_ ) ; }	Get the table's extended column properties.
private class < ? > getclassfortype ( string typename ) throws gpudbexception { typename = typename . replace ( str_ , str_ ) ; if ( typename . equalsignorecase ( string_type_name ) ) { return string . class ; } else if ( typename . equalsignorecase ( long_type_name ) ) { return long . class ; } else if ( typename . equalsignorecase ( integer_type_name ) ) { return integer . class ; } else if ( typename . equalsignorecase ( float_type_name ) ) { return float . class ; } else if ( typename . equalsignorecase ( double_type_name ) ) { return double . class ; } else if ( typename . equalsignorecase ( bytes_type_name ) ) { return bytebuffer . class ; } else { throw new gpudbexception ( str_ + typename + str_ ) ; } }	Get the Java type for a type name.
public void init ( target . context context , list < target . configissue > issues ) { list < host > hosts = getaerospikehosts ( issues , connectionstring , groups . aerospike . getlabel ( ) , str_ , context ) ; clientpolicy cp = new clientpolicy ( ) ; try { client = new aerospikeclient ( cp , hosts . toarray ( new host [ hosts . size ( ) ] ) ) ; int retries = num_ ; while ( ! client . isconnected ( ) && retries <= maxretries ) { if ( retries > maxretries ) { issues . add ( context . createconfigissue ( groups . aerospike . getlabel ( ) , str_ , aerospikeerrors . aerospike_03 , connectionstring ) ) ; return ; } retries ++ ; try { thread . sleep ( num_ ) ; } catch ( interruptedexception ignored ) { } } } catch ( aerospikeexception ex ) { issues . add ( context . createconfigissue ( groups . aerospike . getlabel ( ) , str_ , aerospikeerrors . aerospike_03 , connectionstring ) ) ; } }	initialize and validate configuration options.
string gettopic ( record record ) throws stageexception { string result = publisherconf . topic ; if ( publisherconf . runtimetopicresolution ) { recordel . setrecordincontext ( topicvars , record ) ; try { result = topiceval . eval ( topicvars , publisherconf . topicexpression , string . class ) ; if ( isempty ( result ) ) { throw new stageexception ( errors . mqtt_08 , publisherconf . topicexpression , record . getheader ( ) . getsourceid ( ) ) ; } if ( ! allowedtopics . contains ( result ) && ! allowalltopics ) { throw new stageexception ( errors . mqtt_09 , result , record . getheader ( ) . getsourceid ( ) ) ; } } catch ( elevalexception e ) { throw new stageexception ( errors . mqtt_10 , publisherconf . topicexpression , record . getheader ( ) . getsourceid ( ) , e . tostring ( ) ) ; } } return result ; }	Returns the topic given the record.Returns the configured topic or statically evaluated topic in case runtime resolution is not required.If runtime resolution is required then the following is done:1.
public inputstream getinputstream ( ) throws ioexception { acquirelock ( ) ; try { isclosed = bool_ ; forwrite = bool_ ; log . trace ( str_ , file ) ; verifyandrecover ( ) ; inputstream is = new proxyinputstream ( new fileinputstream ( file . tofile ( ) ) ) { @ override public void close ( ) throws ioexception { if ( isclosed ) { return ; } try { super . close ( ) ; } finally { release ( ) ; isclosed = bool_ ; stream = null ; } log . trace ( str_ , file ) ; } } ; stream = is ; return is ; } catch ( exception ex ) { release ( ) ; throw ex ; } }	Returns an input stream for the requested file.After completing the read the stream must be closed.
public outputstream getoutputstream ( ) throws ioexception { acquirelock ( ) ; try { isclosed = bool_ ; forwrite = bool_ ; log . trace ( str_ , file ) ; verifyandrecover ( ) ; if ( files . exists ( file ) ) { files . move ( file , fileold ) ; log . trace ( str_ , file , fileold ) ; } outputstream os = new proxyoutputstream ( new fileoutputstream ( filetmp . tofile ( ) ) ) { @ override public void close ( ) throws ioexception { if ( isclosed ) { return ; } try { super . close ( ) ; } finally { isclosed = bool_ ; stream = null ; } log . trace ( str_ , file ) ; } } ; stream = os ; return os ; } catch ( exception ex ) { release ( ) ; throw ex ; } }	Returns an output stream for the requested file.After completing the write the contents must be committed using the {.
public boolean exists ( ) throws ioexception { acquirelock ( ) ; try { verifyandrecover ( ) ; return files . exists ( file ) && files . size ( file ) > num_ ; } finally { release ( ) ; } }	Check if the DataStore exists and contains data.This method will check for the presence of the set of files that can be used to read data from the store.
public static fspermission parsefspermission ( string permissions ) throws illegalargumentexception { try {	Parse String representation of permissions into HDFS FsPermission class.This method accepts the following formats:* Octal like '777' or '770'* HDFS style changes like 'a-rwx'* Unix style write up with 9 characters like 'rwxrwx---'.
private void validateallservicesavailable ( ) {	Validate service dependencies.Any error is considered fatal and RuntimeException() will be thrown that will terminate the SDC start up procedure.
@ suppresswarnings ( str_ ) public < a extends simpleaggregator > a createsimple ( string name , class < ? extends aggregator > klass ) { utils . checkstate ( ! started , str_ ) ; try { a aggregator = ( a ) constructors . get ( klass ) . newinstance ( name ) ; dataprovider . addaggregator ( aggregator ) ; aggregator . setdataprovider ( dataprovider ) ; return aggregator ; } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } }	Creates a simple Aggregator.
< a extends simpleaggregator , t > class < ? extends number > getaggregatorunit ( class < a > klass ) { try { a aggregator = ( a ) constructors . get ( klass ) . newinstance ( str_ ) ; return aggregator . getvaluetype ( ) ; } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } }	Returns the unit type of an aggregator value.
< a extends simpleaggregator , t > aggregatordata < a , t > createaggregatordata ( class < a > klass , string name , long timewindowmillis ) { try { a aggregator = ( a ) constructors . get ( klass ) . newinstance ( name ) ; return aggregator . createaggregatordata ( timewindowmillis ) ; } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } }	Creates an AggregatorData.
@ suppresswarnings ( str_ ) public < a extends simpleaggregator , n extends number > groupbyaggregator < a , n > creategroupby ( string name , class < ? extends aggregator > aklass ) { utils . checkstate ( ! started , str_ ) ; groupbyaggregator < a , n > aggregator = new groupbyaggregator ( name , aklass , this ) ; dataprovider . addaggregator ( aggregator ) ; aggregator . setdataprovider ( dataprovider ) ; return aggregator ; }	Creates a group-by Agregator.
public void start ( long newdatawindowendtimemillis ) { utils . checkstate ( ! started , str_ ) ; utils . checkstate ( ! stopped , str_ ) ; dataprovider . start ( newdatawindowendtimemillis ) ; started = bool_ ; }	Starts the Aggregators instance.
public map < aggregator , aggregatordata > stop ( ) { utils . checkstate ( started , str_ ) ; utils . checkstate ( ! stopped , str_ ) ; map < aggregator , aggregatordata > aggregatordatamap = dataprovider . stop ( ) ; stopped = bool_ ; return aggregatordatamap ; }	Stops the Aggregators instance.
public map < aggregator , aggregatordata > roll ( long newdatawindowendtimemillis ) { utils . checkstate ( started , str_ ) ; utils . checkstate ( ! stopped , str_ ) ; return dataprovider . roll ( newdatawindowendtimemillis ) ; }	Atomically rolls the DataWindow of all aggregators associated with the Aggregators instance.
public void release ( ) { synchronized ( loginmanager . class ) { if ( refcount == num_ ) throw new illegalstateexception ( str_ ) ; else if ( refcount == num_ ) { cached_instances . remove ( logintype ) ; login . shutdown ( ) ; } -- refcount ; } }	Decrease the reference count for this instance and release resources if it reaches 0.
private static string globtoregex ( string glob ) { if ( glob . charat ( num_ ) == str_ || glob . contains ( str_ ) || glob . contains ( str_ ) ) { throw new illegalargumentexception ( str_ ) ; }	Convert a limited file glob into a simple regex.
static list < s3objectsummary > listobjectslexicographically ( amazons3 s3client , s3configbean s3configbean , antpathmatcher pathmatcher , s3offset s3offset , int fetchsize ) {	Lists objects from AmazonS3 in lexicographical order.
public void stop ( ) throws pipelineexception { this . stop = bool_ ; if ( batchestocapture > num_ ) { cancelsnapshot ( this . snapshotname ) ; snapshotstore . deletesnapshot ( pipelinename , revision , snapshotname ) ; } }	Stops execution of the pipeline after the current batch completes.
public int produceemptybatchesforidlerunners ( long idletime ) throws pipelineexception , stageexception { log . debug ( str_ ) ;	This method should be called periodically from a scheduler if the pipeline should not allow runners to be "idle"for more then idleTime.
private void createfailurebatch ( fullpipebatch pipebatch ) { if ( ! pipelineconfigbean . shouldcreatefailuresnapshot ) { return ; } try { for ( snapshotinfo info : snapshotstore . getsummaryforpipeline ( pipelinename , revision ) ) {	Create special batch by salvaging memory structures when pipelines gets into un-recoverable error.
@ suppresswarnings ( str_ ) private boundstatement recordtoboundstatement ( record record ) throws stageexception { immutablelist . builder < object > values = new immutablelist . builder < > ( ) ; sortedset < string > columnspresent = sets . newtreeset ( columnmappings . keyset ( ) ) ; for ( map . entry < string , string > mapping : columnmappings . entryset ( ) ) { string columnname = mapping . getkey ( ) ; string fieldpath = mapping . getvalue ( ) ;	Convert a Record into a fully-bound statement.
public void set ( map < string , string > newconfiguration ) { for ( map . entry < string , string > entry : newconfiguration . entryset ( ) ) { if ( entry . getvalue ( ) == null ) { this . unset ( entry . getkey ( ) ) ; } else { this . set ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } }	Set multiple configs at once.If a value of given config is 'null', then this config key will be un-set.
private kudulookupkey generatelookupkey ( final record record , final string tablename ) throws onrecorderrorexception { map < string , field > keylist = new hashmap < > ( ) ; for ( map . entry < string , string > key : columntofield . entryset ( ) ) { string fieldname = key . getvalue ( ) ; if ( ! record . has ( fieldname ) ) { throw new onrecorderrorexception ( record , errors . kudu_32 , fieldname ) ; } keylist . put ( key . getkey ( ) , record . get ( fieldname ) ) ; } return new kudulookupkey ( tablename , keylist ) ; }	Create a map of keyColumn - value to lookup in cache.
int readline ( stringbuilder sb ) throws ioexception { int c = reader . read ( ) ; int count = ( c == - num_ ) ? - num_ : num_ ; while ( c > - num_ && ! isovermaxobjectlen ( count ) && ! checkeolandadjust ( c ) ) { count ++ ; sb . append ( ( char ) c ) ; c = reader . read ( ) ; } if ( isovermaxobjectlen ( count ) ) { sb . setlength ( sb . length ( ) - num_ ) ; while ( c > - num_ && c != str_ && c != str_ ) { count ++ ; c = reader . read ( ) ; } checkeolandadjust ( c ) ; } return count ; }	returns the reader line length, the StringBuilder has up to maxObjectLen chars.
public usagetimer roll ( ) { int multiplier ; synchronized ( this ) { multiplier = getmultiplier ( ) ; changemultiplier ( - multiplier ) ;	returns fresh UsageTimer just reset to zero accumulated time.
public static void enabledpm ( dpminfojson dpminfo , context context ) throws ioexception { utils . checknotnull ( dpminfo , str_ ) ; string dpmbaseurl = normalizedpmbaseurl ( dpminfo . getbaseurl ( ) ) ;	Enable Control Hub on this Data Collector.
public static void disabledpm ( string username , string password , string organizationid , context context ) throws ioexception { string dpmbaseurl = normalizedpmbaseurl ( context . configuration . get ( remotessoservice . dpm_base_url_config , str_ ) ) ; string usertoken = retrieveusertoken ( dpmbaseurl , username , password ) ; try { disabledpm ( usertoken , organizationid , context ) ; } finally { logout ( dpmbaseurl , usertoken ) ; } }	Disable Control Hub on this Data Collector - with explicit login.
private static string normalizedpmbaseurl ( string url ) { if ( url . endswith ( str_ ) ) { url = url . substring ( num_ , url . length ( ) - num_ ) ; } return url ; }	Normalize Control Hub URL - primarily drop training slash.
private static string retrieveusertoken ( string url , string username , string password ) { response response = null ; try { map < string , string > loginjson = new hashmap < > ( ) ; loginjson . put ( str_ , username ) ; loginjson . put ( str_ , password ) ; response = clientbuilder . newclient ( ) . target ( url + str_ ) . register ( new csrfprotectionfilter ( str_ ) ) . request ( ) . post ( entity . json ( loginjson ) ) ; if ( response . getstatus ( ) != response . status . ok . getstatuscode ( ) ) { throw new runtimeexception ( utils . format ( str_ , response . getstatus ( ) , response . readentity ( string . class ) ) ) ; } } finally { if ( response != null ) { response . close ( ) ; } } return response . getheaderstring ( ssoconstants . x_user_auth_token ) ; }	Login user and retrieve authentication token.
private static void logout ( string dpmbaseurl , string userauthtoken ) { response response = null ; try { response = clientbuilder . newclient ( ) . target ( dpmbaseurl + str_ ) . register ( new csrfprotectionfilter ( str_ ) ) . request ( ) . header ( ssoconstants . x_user_auth_token , userauthtoken ) . cookie ( ssoconstants . authentication_cookie_prefix + str_ , userauthtoken ) . get ( ) ; } finally { if ( response != null ) { response . close ( ) ; } } }	Logout given token.
private static void updatetokenfile ( context context , string appauthtoken ) throws ioexception { file tokenfile = context . tokenfilepath == null ? new file ( context . runtimeinfo . getconfigdir ( ) , app_token_file ) : new file ( context . tokenfilepath ) ; datastore datastore = new datastore ( tokenfile ) ; try ( outputstream os = datastore . getoutputstream ( ) ) { ioutils . write ( appauthtoken , os ) ; datastore . commit ( os ) ; } finally { datastore . release ( ) ; } }	Update token file with the SDC access token.
private static void updatedpmproperties ( context context , string dpmbaseurl , list < string > labels , boolean enablesch ) { if ( context . skipupdatingdpmproperties ) { return ; } try { filebasedconfigurationbuilder < propertiesconfiguration > builder = new filebasedconfigurationbuilder < > ( propertiesconfiguration . class ) . configure ( new parameters ( ) . properties ( ) . setfilename ( context . runtimeinfo . getconfigdir ( ) + str_ ) . setthrowexceptiononmissing ( bool_ ) . setlistdelimiterhandler ( new defaultlistdelimiterhandler ( str_ ) ) . setincludesallowed ( bool_ ) ) ; propertiesconfiguration config = null ; config = builder . getconfiguration ( ) ; config . setproperty ( remotessoservice . dpm_enabled , boolean . tostring ( enablesch ) ) ; config . setproperty ( remotessoservice . dpm_base_url_config , dpmbaseurl ) ; config . setproperty ( remotessoservice . security_service_app_auth_token_config , app_token_file_prop_val ) ; if ( labels != null && labels . size ( ) > num_ ) { config . setproperty ( remoteeventhandlertask . remote_job_labels , stringutils . join ( labels , str_ ) ) ; } else { config . setproperty ( remoteeventhandlertask . remote_job_labels , str_ ) ; } builder . save ( ) ; } catch ( configurationexception e ) { throw new runtimeexception ( utils . format ( str_ , e . getmessage ( ) ) , e ) ; } }	Update dpm.properties file with new configuration.
private schema . field schemafieldfortype ( string fieldpath , record record , string fieldname , field field ) throws onrecorderrorexception { schema simpleschema = simpleschemafortype ( fieldpath , record , field ) ; schema finalschema = simpleschema ;	Generate schema for given field and optionally wrap it in union with null if configured.
private schema complexschemafortype ( string fieldpath , record record , field field ) throws onrecorderrorexception { schema simpleschema = simpleschemafortype ( fieldpath , record , field ) ; schema finalschema = simpleschema ; if ( getconfig ( ) . avronullablefields ) { finalschema = schema . createunion ( immutablelist . of ( schema . create ( schema . type . null ) , simpleschema ) ) ; } jsonnode defaultvalue = getdefaultvalue ( simpleschema ) ; if ( defaultvalue != null ) { finalschema . addprop ( str_ , defaultvalue ) ; } return finalschema ; }	Generates complex schema for given field that will include optional union with null and potentially default valueas well.
private int getdecimalscaleorprecision ( record record , field field , string attributename , int defaultvalue , int minallowed ) throws onrecorderrorexception { int finalvalue = - num_ ;	Resolve parameters of decimal type.
private jsonnode getdefaultvalue ( schema schema ) { if ( getconfig ( ) . avronullablefields && getconfig ( ) . avrodefaultnullable ) { return nullnode . getinstance ( ) ; } if ( ! getconfig ( ) . avronullablefields && defaultvaluesfortypes . containskey ( schema . gettype ( ) ) ) { return defaultvaluesfortypes . get ( schema . gettype ( ) ) ; } return null ; }	Returns default value for given field or null if no default value should be used.
@ suppresswarnings ( str_ ) public static synchronized void initmetricsifneeded ( protoconfigurableentity . context context ) { gauge < map < string , object > > gauge = context . getgauge ( filestatisticgaugename ( context ) ) ; if ( gauge == null ) { gauge = context . creategauge ( filestatisticgaugename ( context ) , comparator . comparing ( gauge_map_ordering :: get ) ) ; map < string , object > gaugestatistics = gauge . getvalue ( ) ;	Creates a gauge if it is already not. This is done only once for the stage.
public int compare ( wrappedfile path1 , wrappedfile path2 , boolean uselastmodified ) {	This method is a simple wrapper that lets us find the NoSuchFileException if that was the cause.
public int indexof ( string groupname , int index ) { int idx = - num_ ; if ( groupinfo . containskey ( groupname ) ) { list < groupinfo > list = groupinfo . get ( groupname ) ; idx = list . get ( index ) . groupindex ( ) ; } return idx ; }	Gets the group index of a named capture group at thespecified index.
public list < string > groupnames ( ) { if ( groupnames == null ) { groupnames = new arraylist < string > ( groupinfo . keyset ( ) ) ; } return groupnames ; }	Gets the names of all capture groups.
static private boolean isescapedchar ( string s , int pos ) { return isslashescapedchar ( s , pos ) || isquoteescapedchar ( s , pos ) ; }	Determines if the character at the specified positionof a string is escaped.
static private boolean isslashescapedchar ( string s , int pos ) {	Determines if the character at the specified positionof a string is escaped with a backslash.
static private boolean isinsidecharclass ( string s , int pos ) { boolean openbracketfound = bool_ ; boolean closebracketfound = bool_ ;	Determines if a string's character is within a regex character class.
static private int countopenparens ( string s , int pos ) { java . util . regex . pattern p = java . util . regex . pattern . compile ( str_ ) ; java . util . regex . matcher m = p . matcher ( s . subsequence ( num_ , pos ) ) ; int numparens = num_ ; while ( m . find ( ) ) {	Counts the open-parentheses to the left of a string position,excluding escaped parentheses.
static public map < string , list < groupinfo > > extractgroupinfo ( string namedpattern ) { map < string , list < groupinfo > > groupinfo = new linkedhashmap < string , list < groupinfo > > ( ) ; java . util . regex . matcher matcher = named_group_pattern . matcher ( namedpattern ) ; while ( matcher . find ( ) ) { int pos = matcher . start ( ) ;	Parses info on named capture groups from a pattern.
static private stringbuilder replace ( stringbuilder input , java . util . regex . pattern pattern , string replacement ) { java . util . regex . matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( isescapedchar ( input . tostring ( ) , m . start ( ) ) ) { continue ; }	Replaces strings matching a pattern with another string.
@ override public void doget ( httpservletrequest request , httpservletresponse response ) { try { jsongenerator jg = null ; string jsonpcb = null ; printwriter writer = null ; try { writer = response . getwriter ( ) ;	Process a GET request for the specified resource.
private boolean refreshschema ( bigdecimal scndecimal , schemaandtable schemaandtable ) throws sqlexception { try { if ( ! tableschemalastupdate . containskey ( schemaandtable ) || scndecimal . compareto ( tableschemalastupdate . get ( schemaandtable ) ) > num_ ) { if ( containerized ) { try ( statement switchtopdb = connection . createstatement ( ) ) { switchtopdb . execute ( str_ + configbean . pdb ) ; } } tableschemas . put ( schemaandtable , gettableschema ( schemaandtable ) ) ; tableschemalastupdate . put ( schemaandtable , scndecimal ) ; return bool_ ; } return bool_ ; } finally { altersession ( ) ; } }	Refresh the schema for the table if the last update of this table was before the given SCN.Returns true if it was updated, else returns false.
private boolean expired ( map . entry < transactionidkey , hashqueue < recordsequence > > entry , localdatetime starttime ) { return starttime != null &&	An element is "expired" if the transaction started before the current window being processedand if no records have actually been sent to the pipeline.
@ override public long getoffset ( ) { utils . checkstate ( open , utils . formatl ( str_ , currentfile ) ) ; return ( truncatemode ) ? - offset : offset ; }	offset will be negative if we are in truncate mode.
private boolean fastforward ( ) throws ioexception { try { boolean stilltruncate ; buffer . clear ( ) ; if ( channel . read ( buffer ) > - num_ || iseof ( ) ) {	returns true if still in truncate mode, false otherwise.
private static object convertstringtoappropriatenumber ( string value ) { if ( value . contains ( str_ ) ) { return double . valueof ( value ) ; } else { return long . valueof ( value ) ; } }	We need to support Strings as some information that user might need to deal with is inherently stored in Stringvariables - for example header values or CSV files.The way we're processing strings is - if it contains dot, then it's assumed to be a double otherwise long.
private int parsepart ( int startoffset , bytebuf buf , map < string , field > fields ) throws onrecorderrorexception { int offset = startoffset ; int type = buf . getunsignedshort ( offset ) ;	Parses a collectd packet "part".
private int parsevalues ( int startoffset , bytebuf buf ) throws onrecorderrorexception { int offset = startoffset ;	Parses the value part of the packet where metrics are located.
void lookupprimarykeys ( ) throws stageexception { connection connection = null ; try { connection = datasource . getconnection ( ) ; primarykeycolumns = jdbcutil . getprimarykeys ( connection , schema , tablename ) ; } catch ( sqlexception e ) { string formattederror = jdbcutil . formatsqlexception ( e ) ; log . error ( formattederror , e ) ; throw new stageexception ( jdbcerrors . jdbc_17 , tablename , formattederror ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( sqlexception e ) { string formattederror = jdbcutil . formatsqlexception ( e ) ; log . error ( formattederror , e ) ; } } } }	Access the database, obtain a list of primary key columns, and store them in primaryKeyColumns.If table has no primary keys, primaryKeyColumns stays empty.
private void createcustomfieldmappings ( ) { for ( jdbcfieldcolumnparammapping mapping : custommappings ) { log . debug ( str_ , mapping . field , mapping . columnname ) ; if ( columnstofields . containskey ( mapping . columnname ) ) { log . debug ( str_ , mapping . field , mapping . columnname ) ; columnstofields . put ( mapping . columnname , mapping . field ) ; columnstoparameters . put ( mapping . columnname , mapping . paramvalue ) ; } } }	Use "Field to Column Mapping" option obtained from configuration and updatecolumnsToFields and columnsToParameters.
static string getsqltypename ( field . type type ) throws onrecorderrorexception { switch ( type ) { case boolean : return str_ ; case char : return str_ ; case byte : return str_ ; case short : return str_ ; case integer : return str_ ; case long : return str_ ; case float : return str_ ; case double : return str_ ; case date : return str_ ; case time : return str_ ; case datetime : return str_ ; case decimal : return str_ ; case string : return str_ ; case byte_array : return str_ ; case list_map : case map : throw new onrecorderrorexception ( jdbcerrors . jdbc_05 , str_ ) ; case list : return str_ ; default : throw new onrecorderrorexception ( jdbcerrors . jdbc_05 , str_ + type . name ( ) ) ; } }	spec requires a string name for a data type, rather than just an enum.
protected string gettablename ( ) { if ( ! strings . isnullorempty ( schema ) ) { if ( casesensitive ) { return str_ + schema + str_ + str_ + tablename + str_ ; } else { return schema + str_ + tablename ; } } if ( casesensitive ) { return str_ + tablename + str_ ; } return tablename ; }	Table this writer will write to.
int setprimarykeys ( int index , final record record , preparedstatement statement , int opcode ) throws onrecorderrorexception { for ( string key : getprimarykeycolumns ( ) ) { field field = record . get ( recordreader . getfieldpath ( key , getcolumnstofields ( ) , opcode ) ) ; if ( field == null ) { log . error ( str_ , key ) ; throw new onrecorderrorexception ( record , jdbcerrors . jdbc_19 , key ) ; } object value = field . getvalue ( ) ; try { statement . setobject ( index , value , getcolumntype ( key ) ) ; } catch ( sqlexception ex ) { log . error ( str_ , ex . getmessage ( ) ) ; throw new onrecorderrorexception ( record , jdbcerrors . jdbc_19 , key , ex ) ; } ++ index ; } return index ; }	Set primary key values to query.
void handlesqlexception ( sqlexception e ) throws stageexception { string formattederror = jdbcutil . formatsqlexception ( e ) ; log . error ( formattederror , e ) ; throw new stageexception ( jdbcerrors . jdbc_14 , e . getsqlstate ( ) , e . geterrorcode ( ) , e . getmessage ( ) , formattederror , e ) ; }	This is an error that is not due to bad input record and should throw a StageExceptiononce we format the error.
public void process ( map < string , string > offsets , int batchsize , reporterrordelegate reporterrordelegate ) throws stageexception , pipelineruntimeexception { this . reporterrordelegate = reporterrordelegate ; getstage ( ) . setreporterrordelegate ( this ) ; try { mdc . put ( logconstants . stage , getstage ( ) . getinfo ( ) . getinstancename ( ) ) ; getstage ( ) . execute ( offsets , batchsize ) ; } finally { mdc . put ( logconstants . stage , str_ ) ; } }	Process method for Push source that will give control of the execution to the origin.
public void preparebatchcontext ( batchcontextimpl batchcontext ) { pipebatch pipebatch = batchcontext . getpipebatch ( ) ;	Called by PipelineRunner when push origin started a new batch to prepare context for it.
public map < string , object > finishbatchcontext ( batchcontextimpl batchcontext ) throws stageexception { return finishbatchandcalculatemetrics ( batchcontext . getstarttime ( ) , batchcontext . getpipebatch ( ) , ( batchmakerimpl ) batchcontext . getbatchmaker ( ) , batchcontext . getpipebatch ( ) . getbatch ( this ) , batchcontext . getpipebatch ( ) . geterrorsink ( ) , batchcontext . getpipebatch ( ) . geteventsink ( ) , null ) ; }	Finish batch from the origin's perspective.
private map < string , field > flattenentirerecord ( field rootfield ) { map < string , field > ret = new linkedhashmap < > ( ) ; switch ( rootfield . gettype ( ) ) { case map : case list_map : flattenmap ( str_ , rootfield . getvalueasmap ( ) , ret ) ; break ; case list : flattenlist ( str_ , rootfield . getvalueaslist ( ) , ret ) ; break ; default : break ; } return ret ; }	Flatten the entire record to one giant map.
public static < t > detachedstageruntime < ? extends t > create ( stagebean bean , stage . info info , stage . context context , class < t > klass ) { switch ( bean . getdefinition ( ) . gettype ( ) ) { case processor : return new detachedstageruntime . detachedprocessor ( bean , info , context ) ; case target : case executor : return new detachedstageruntime . detachedtarget ( bean , info , context ) ; default : throw new runtimeexception ( str_ + bean . getdefinition ( ) . gettype ( ) ) ; } }	Create new instance of detached stage runtime.
private void execute ( record record ) throws onrecorderrorexception {	Executes an action for given record.
@ override public sortedmap < string , string > getcolumnstoparameters ( final record record , int op , map < string , string > parameters , map < string , string > columnstofields ) { sortedmap < string , string > columnstoparameters = new treemap < > ( ) ; for ( map . entry < string , string > entry : columnstofields . entryset ( ) ) { string columnname = entry . getkey ( ) ; string fieldpath = entry . getvalue ( ) ; if ( op == operationtype . delete_code ) { fieldpath = fieldpath . replace ( data_field , old_data_field ) ; } if ( record . has ( fieldpath ) ) { columnstoparameters . put ( columnname , parameters . get ( columnname ) ) ; } } return columnstoparameters ; }	Records from MySQL BinLog origin have a bit unique structure.Records for Insert and update operations have a field path "/Data", which is a mapof all column names as key and values stored in DB as value.Record for Delete operation don't have /Data field.
private static string getconditionforpartitioncolumn ( string partitioncolumn , offsetcomparison comparison , list < string > preconditions , string quotechar ) { string conditiontemplate = comparison . getquerycondition ( ) ; list < string > finalconditions = new arraylist < > ( preconditions ) ; finalconditions . add ( string . format ( conditiontemplate , string . format ( quoted_name , quotechar , partitioncolumn , quotechar ) , prepared_statement_positional_parameter ) ) ; return and_joiner . join ( finalconditions ) ; }	Builds parts of the query in the where clause for the the partitition column.
public static map < string , string > validatestoredandspecifiedoffset ( tablecontext tablecontext , string offset ) throws stageexception { set < string > expectedcolumns = sets . newhashset ( tablecontext . getoffsetcolumns ( ) ) ; final map < string , string > actualoffsets = getcolumnstooffsetmapfromoffsetformat ( offset ) ;	Validates whether offset names match in the stored offset with respect to table configuration.
private list < bundlecontentgeneratordefinition > getrequesteddefinitions ( list < string > generators ) { stream < bundlecontentgeneratordefinition > stream = definitions . stream ( ) ; if ( generators == null || generators . isempty ( ) ) {	Orchestrate what definitions should be used for this bundle.Either get all definitions that should be used by default or only those specified in the generators argument.
private string [ ] getnonemptyargs ( list < string > appargs ) { list < string > nonempty = new arraylist < > ( ) ; appargs . foreach ( ( string val ) -> { if ( ! stringutils . isempty ( val ) ) { nonempty . add ( val ) ; } } ) ; return nonempty . toarray ( new string [ nonempty . size ( ) ] ) ; }	If there is a RecordEL, then an arg could eval to empty string.
protected operation getoperation ( kudutable table , int op ) throws unsupportedoperationexception { operation operation = null ; switch ( op ) { case operationtype . insert_code : operation = table . newinsert ( ) ; break ; case operationtype . upsert_code : operation = table . newupsert ( ) ; break ; case operationtype . update_code : operation = table . newupdate ( ) ; break ; case operationtype . delete_code : operation = table . newdelete ( ) ; break ; default : log . error ( str_ , op ) ; throw new unsupportedoperationexception ( string . format ( str_ , op ) ) ; } return operation ; }	Return Operation based on the operation code.
static string convertbytestodisplayformat ( double bytes ) { int unitidx = num_ ; double unitchangedbytes = bytes ; while ( unitidx < units . length - num_ && math . floor ( unitchangedbytes / num_ ) > num_ ) { unitchangedbytes = unitchangedbytes / num_ ; unitidx ++ ; } return df . format ( unitchangedbytes ) + str_ + units [ unitidx ] ; }	Convert the bytes to a human readable format upto 2 decimal placesThe maximum unit is TB, so anything exceeding 1024 TB will be shownwith TB unit.
public livefile scan ( livefile current ) throws ioexception { try { return scaninternal ( current ) ; } catch ( nosuchfileexception ex ) {	Scans the directory of for the next file.
public long getpendingfiles ( livefile current ) throws ioexception {	Scans the directory for number of files yet to be processed.
public static boolean iswhitelisted ( string name , properties specificwhitelist , map < string , list < dependency > > dependencies ) { if ( specificwhitelist != null && specificwhitelist . containskey ( name ) ) { return versionsmatch ( specificwhitelist . getproperty ( name ) , dependencies . keyset ( ) ) ; }	Return true if this dependency and given set of versions is whitelisted.This class have several rules for whitelisting - some of them are harcoded (known whitelist for all libraries),whereas the optional Properties argument allows specific exceptions for this particular classpath.
private static boolean versionsmatch ( string expectedversions , set < string > versions ) { set < string > expectedset = sets . newhashset ( expectedversions . split ( str_ ) ) ; return sets . symmetricdifference ( expectedset , versions ) . isempty ( ) ; }	Compare expected versions with given versions to see if they are the same or not.
public static void main ( string [ ] args ) throws exception { sparkstreamingbinding binding = null ; try { binding = sparkstreamingbindingfactory . build ( bootstrapcluster . getproperties ( ) ) ; binding . init ( ) ; bootstrapcluster . createtransformers ( binding . getstreamingcontext ( ) . sparkcontext ( ) , binding . getsparksession ( ) ) ; binding . startcontext ( ) ; binding . awaittermination ( ) ; } catch ( throwable error ) { string msg = str_ + error ; system . err . println ( new date ( ) + str_ + msg ) ; error . printstacktrace ( system . err ) ;	Bootstrapping the Driver which starts a Spark job on cluster.
private void propagateruntimeconfiguration ( ) {	We have special type of a ConfigDef called RUNTIME.
private void validatereportdescription ( list < configissue > issues ) { if ( ! jsonmapper . isvalidjson ( this . reportdescription ) ) { issues . add ( getcontext ( ) . createconfigissue ( groups . report . name ( ) , str_ , errors . omniture_03 ) ) ; } }	Validate Ominture Report Description.
private void upgradev1tov2 ( list < config > configs ) { configs . removeif ( config -> ( config . getname ( ) . equals ( implicit_field_mapping_config ) || config . getname ( ) . equals ( big_query_implicit_field_mapping_config ) ) ) ; configs . add ( new config ( max_cache_size , - num_ ) ) ; }	Remove implicit field mapping.
public map < string , string > extractnamedgroups ( final charsequence rawdata ) { matcher matcher = compiledpattern . matcher ( rawdata ) ; if ( matcher . find ( ) ) { matchresult r = matcher . tomatchresult ( ) ; if ( r != null && r . namedgroups ( ) != null ) { return r . namedgroups ( ) ; } } return null ; }	Extracts named groups from the raw data.
public void consumercommit ( string offset ) { object offsetvalue = offset ; if ( offsetvalue == null ) { offsetvalue = new nulloffset ( ) ; } log . trace ( str_ , offsetvalue ) ; try { producerqueue . put ( new message ( messagetype . consumer_commit , offsetvalue ) ) ; } catch ( interruptedexception e ) { log . info ( str_ , messagetype . consumer_commit . name ( ) , offsetvalue ) ; thread . currentthread ( ) . interrupt ( ) ; } }	If a null value is passed to this method, it's replaced witha dummy due to the fact the payload for each message is wrappedin an Optional.
@ suppresswarnings ( str_ ) protected embeddedsdc create ( ) throws exception { utils . checkstate ( open , str_ ) ; final embeddedsdc embeddedsdc = new embeddedsdc ( ) ; object source ;	Creates an instance of SDC and adds to pool.
private void setfieldsinrecord ( record record , map < string , field > fields ) { record . set ( configbean . resultfield , field . createlistmap ( new linkedhashmap < > ( fields ) ) ) ; }	Set the lookup reuslt in the result field.
@ override public list < pipelineandvalidationstatus > getremotepipelineswithchanges ( ) throws pipelineexception { list < pipelineandvalidationstatus > pipelineandvalidationstatuses = new arraylist < > ( ) ; for ( pair < pipelinestate , map < string , string > > pipelinestateandoffset : stateeventlistener . getpipelinestateevents ( ) ) { pipelinestate pipelinestate = pipelinestateandoffset . getleft ( ) ; map < string , string > offset = pipelinestateandoffset . getright ( ) ; string name = pipelinestate . getpipelineid ( ) ; string rev = pipelinestate . getrev ( ) ; boolean isclustermode = ( pipelinestate . getexecutionmode ( ) != executionmode . standalone ) ? bool_ : bool_ ; list < workerinfo > workerinfos = new arraylist < > ( ) ; string title ; int runnercount = num_ ; if ( pipelinestore . haspipeline ( name ) ) { title = pipelinestore . getinfo ( name ) . gettitle ( ) ; runner runner = manager . getrunner ( name , rev ) ; if ( isclustermode ) { workerinfos = getworkers ( runner . getslavecallbacklist ( callbackobjecttype . metrics ) ) ; } runnercount = runner . getrunnercount ( ) ; } else { title = null ; } pipelineandvalidationstatuses . add ( new pipelineandvalidationstatus ( getschgeneratedpipelinename ( name , rev ) , title , rev , pipelinestate . gettimestamp ( ) , bool_ , pipelinestate . getstatus ( ) , pipelinestate . getmessage ( ) , workerinfos , isclustermode , getsourceoffset ( name , offset ) , null , runnercount ) ) ; } return pipelineandvalidationstatuses ; }	Returns info about remote pipelines that have changed since the last sending of events.
public static remotedatacollectorresult futureack ( future < ackevent > futureresult ) { return new remotedatacollectorresult ( futureresult , null , bool_ , null ) ; }	Creates a future ack result from the given parameter.
public static gauge < map < string , object > > creategauge ( metricregistry metrics , string name , gauge gauge , final string pipelinename , final string pipelinerev ) { return create ( metrics , gauge , metricname ( name , gauge_suffix ) , pipelinename , pipelinerev ) ; }	Kept for backward compatibility with runtime stats, to be removed in future.
@ override public sortedmap < string , string > getcolumnstoparameters ( final record record , int op , map < string , string > parameters , map < string , string > columnstofields ) { sortedmap < string , string > columnstoparameters = new treemap < > ( ) ; for ( map . entry < string , string > entry : columnstofields . entryset ( ) ) { string columnname = entry . getkey ( ) ; string fieldpath = getfieldpath ( columnname , columnstofields , op ) ; if ( record . has ( fieldpath ) ) { columnstoparameters . put ( columnname , parameters . get ( columnname ) ) ; } else { log . trace ( str_ , columnname , op ) ; } } return columnstoparameters ; }	Records from MongoDB Oplog origin have a bit unique structure.Records for Insert have all data in the field "o", which is a map and contains all data for columnsRecords for Delete have objectId in the field "o", which is a map and contains only objectId.Records for Update have a field "o2", which is a map and contains only objectId,and a field "o" where it stores data for updating columns and values.
private map < string , object > generateheaderattrs ( path file ) throws stageexception { try { map < string , object > recordheaderattr = new hashmap < > ( ) ; recordheaderattr . put ( headerattributeconstants . file , file . toabsolutepath ( ) ) ; recordheaderattr . put ( headerattributeconstants . file_name , file . getfilename ( ) ) ; recordheaderattr . put ( headerattributeconstants . size , files . size ( file ) ) ; recordheaderattr . put ( headerattributeconstants . last_modified_time , files . getlastmodifiedtime ( file ) ) ; return recordheaderattr ; } catch ( ioexception e ) { throw new transformerstagecheckedexception ( errors . convert_09 , e . tostring ( ) , e ) ; } }	Generate the Header attributes.
private void validaterecord ( record record ) throws stageexception { try { filerefutil . validatewholefilerecord ( record ) ; } catch ( illegalargumentexception e ) { throw new transformerstagecheckedexception ( errors . convert_01 , e . tostring ( ) , e ) ; } }	Validate the record is a whole file record.
private void handleoldtempfiles ( path tempparquetfile ) throws ioexception { if ( tempparquetfile == null ) { log . warn ( str_ ) ; return ; } files . deleteifexists ( tempparquetfile ) ; }	Delete temporary parquet file.
private inputstream getavroinputstream ( record record ) throws stageexception { try { fileref fileref = record . get ( filerefutil . file_ref_field_path ) . getvalueasfileref ( ) ;	Return the Avro file input stream.
private datafilestream < genericrecord > getfilereader ( inputstream is , string sourcefilename ) throws stageexception { try { datumreader < genericrecord > reader = new genericdatumreader < > ( ) ; datafilestream < genericrecord > filereader = new datafilestream < > ( is , reader ) ; return filereader ; } catch ( ioexception ex ) { throw new transformerstagecheckedexception ( errors . convert_11 , sourcefilename , ex ) ; } }	Return the Avro file reader.
private void writeparquet ( string sourcefilename , datafilestream < genericrecord > filereader , path tempparquetfile ) throws stageexception { long recordcount = num_ ; genericrecord avrorecord ; schema schema = filereader . getschema ( ) ; log . debug ( str_ , sourcefilename ) ; try {	Convert Avro record to Parquet.
public optional < field > checkinputencrypt ( record record , field field ) { if ( unsupported_types . contains ( field . gettype ( ) ) ) { getcontext ( ) . toerror ( record , crypto_03 , field . gettype ( ) ) ; return optional . empty ( ) ; } return optional . of ( field ) ; }	Checks that the encryption input is a supported type, otherwise sends therecord to error.
public optional < field > checkinputencrypt ( field field ) throws stageexception { if ( unsupported_types . contains ( field . gettype ( ) ) ) { throw new stageexception ( crypto_03 , field . gettype ( ) ) ; } return optional . of ( field ) ; }	Checks that the encryption input is a supported type, otherwise sends therecord to StageException.
public optional < field > checkinputdecrypt ( record record , field field ) { if ( field . gettype ( ) != field . type . byte_array ) { getcontext ( ) . toerror ( record , crypto_02 , field . gettype ( ) ) ; return optional . empty ( ) ; } return optional . of ( field ) ; }	Checks that the decryption input is a valid type, otherwise sends therecord to error.
public optional < field > checkinputdecrypt ( field field ) throws stageexception { if ( field . gettype ( ) != field . type . byte_array ) { throw new stageexception ( crypto_02 , field . gettype ( ) ) ; } return optional . of ( field ) ; }	Checks that the decryption input is a valid type, otherwise sends therecord to StageException.
public byte [ ] prepareencrypt ( field field , map < string , string > context ) { context . put ( sdc_field_type , field . gettype ( ) . name ( ) ) ; if ( field . gettype ( ) == field . type . byte_array ) { return field . getvalueasbytearray ( ) ; } else {	Does data type conversions in preparation for encryption.
public matcher usepattern ( pattern newpattern ) { if ( newpattern == null ) { throw new illegalargumentexception ( str_ ) ; } this . parentpattern = newpattern ; matcher . usepattern ( newpattern . pattern ( ) ) ; return this ; }	Changes the Pattern that this Matcher uses to find matches with.
public matcher appendreplacement ( stringbuffer sb , string replacement ) { matcher . appendreplacement ( sb , parentpattern . replaceproperties ( replacement ) ) ; return this ; }	Implements a non-terminal append-and-replace step.
@ override public map < string , string > namedgroups ( ) { map < string , string > result = new linkedhashmap < string , string > ( ) ; if ( matcher . find ( num_ ) ) { for ( string groupname : parentpattern . groupnames ( ) ) { string groupvalue = matcher . group ( groupindex ( groupname ) ) ; result . put ( groupname , groupvalue ) ; } } return result ; }	Finds all named groups that exist in the input string.
public string replaceall ( string replacement ) { string r = parentpattern . replaceproperties ( replacement ) ; return matcher . replaceall ( r ) ; }	Replaces every subsequence of the input sequence that matches the patternwith the given replacement string.
public static string getglobalvariable ( datasource datasource , string variable ) throws sqlexception { try ( connection conn = datasource . getconnection ( ) ) { try ( statement stmt = conn . createstatement ( ) ; resultset rs = stmt . executequery ( string . format ( str_ , variable ) ) ; ) { if ( rs . next ( ) ) { return rs . getstring ( num_ ) ; } else { return str_ ; } } } }	Get global variable value.
private record createstartevent ( ) { preconditions . checkstate ( starteventstage != null , str_ ) ; eventrecord eventrecord = new eventrecordimpl ( str_ , num_ , starteventstage . getinfo ( ) . getinstancename ( ) , str_ , null , null ) ; map < string , field > rootfield = new linkedhashmap < > ( ) ; rootfield . put ( str_ , field . create ( field . type . string , usercontext . getuser ( ) ) ) ; rootfield . put ( str_ , field . create ( field . type . string , name ) ) ; rootfield . put ( str_ , field . create ( field . type . string , pipelineconf . gettitle ( ) ) ) ;	Create pipeline start event.
private record createstopevent ( pipelinestopreason stopreason ) { preconditions . checkstate ( stopeventstage != null , str_ ) ; eventrecord eventrecord = new eventrecordimpl ( str_ , num_ , stopeventstage . getinfo ( ) . getinstancename ( ) , str_ , null , null ) ; map < string , field > rootfield = new linkedhashmap < > ( ) ; rootfield . put ( str_ , field . create ( field . type . string , stopreason . name ( ) ) ) ; rootfield . put ( str_ , field . create ( field . type . string , name ) ) ; rootfield . put ( str_ , field . create ( field . type . string , pipelineconf . gettitle ( ) ) ) ; eventrecord . set ( field . create ( rootfield ) ) ; return eventrecord ; }	Create pipeline stop event.
protected string fixoffset ( string offsetcolumn , string offset ) { com . sforce . soap . partner . field sfdcfield = getfieldmetadata ( sobjecttype , offsetcolumn ) ; if ( sobjectrecordcreator . decimal_types . contains ( sfdcfield . gettype ( ) . tostring ( ) ) && offset . contains ( str_ ) ) { bigdecimal val = new bigdecimal ( offset ) ; offset = val . toplainstring ( ) ; if ( val . compareto ( max_offset_int ) > num_ && ! offset . contains ( str_ ) ) {	since Salesforce doesn't like scientific notation in queries.
private object extractasruntime ( field field , string valuestr ) { if ( field . gettype ( ) == byte . type || field . gettype ( ) == byte . class || field . gettype ( ) == short . type || field . gettype ( ) == short . class || field . gettype ( ) == integer . type || field . gettype ( ) == integer . class || field . gettype ( ) == long . type || field . gettype ( ) == long . class || field . gettype ( ) == float . type || field . gettype ( ) == float . class || field . gettype ( ) == double . type || field . gettype ( ) == double . class ) { return extractasnumber ( field , valuestr ) ; } else if ( string . class . isassignablefrom ( field . gettype ( ) ) ) { return valuestr ; } throw new illegalargumentexception ( utils . format ( str_ , field . gettype ( ) ) ) ; }	RUNTIME supports only Numeric types and String at the moment.
public void executealtertableaddpartitionquery ( string qualifiedtablename , linkedhashmap < string , string > partitionnamevaluemap , map < string , hivetypeinfo > partitiontypemap , string partitionpath ) throws stageexception { string sql = buildpartitionadditionquery ( qualifiedtablename , partitionnamevaluemap , partitiontypemap , partitionpath ) ; execute ( sql ) ; }	Add a new partition to the given table, with optional custom location.
public void executealtertablesettblpropertiesquery ( string qualifiedtablename , string partitionpath ) throws stageexception { string sql = buildsettablepropertiesquery ( qualifiedtablename , partitionpath ) ; execute ( sql ) ; }	Execute Alter Table set Table Properties.
public string executedescribedatabase ( string dbname ) throws stageexception { string sql = builddescribedatabase ( dbname ) ; return executequery ( sql , rs -> { if ( ! rs . next ( ) ) { throw new hivestagecheckedexception ( errors . hive_35 , str_ ) ; } return hivemetastoreutil . striphdfshostandport ( rs . getstring ( result_set_location ) ) ; } ) ; }	Returns location for given database.
private void execute ( string query ) throws stageexception { log . debug ( str_ , query ) ; timer . context t = updatetimer . time ( ) ; try ( statement statement = hiveconfigbean . gethiveconnection ( ) . createstatement ( ) ) { statement . execute ( query ) ; } catch ( exception e ) { log . error ( str_ , query , e ) ; throw new hivestagecheckedexception ( errors . hive_20 , query , e . getmessage ( ) ) ; } finally { long time = t . stop ( ) ; log . debug ( str_ , query , time ) ; updatemeter . mark ( ) ; } }	Execute given query.With all required side effects such as catching exceptions, updating metrics, ...
private < t > t executequery ( string query , withresultset < t > execution ) throws stageexception { log . debug ( str_ , query ) ; timer . context t = selecttimer . time ( ) ; try ( statement statement = hiveconfigbean . gethiveconnection ( ) . createstatement ( ) ; resultset rs = statement . executequery ( query ) ; ) {	Execute given query and process it's result set.With all required side effects such as catching exceptions, updating metrics, ...
public void executebatch ( string offsetkey , string offsetvalue , long batchstarttime , throwingconsumer < pipe > consumer ) throws pipelineruntimeexception , stageexception { mdc . put ( logconstants . runner , string . valueof ( runnerid ) ) ;	Run batch with given consumer for each pipe.This method will also set the logger appropriately and calculate the runner specific metrics.
public void foreach ( throwingconsumer < pipe > consumer ) { try { mdc . put ( logconstants . runner , string . valueof ( runnerid ) ) ; try { for ( pipe p : pipes ) { mdc . put ( logconstants . stage , p . getstage ( ) . getinfo ( ) . getinstancename ( ) ) ; acceptconsumer ( consumer , p ) ; } } finally { mdc . put ( logconstants . runner , str_ ) ; mdc . put ( logconstants . stage , str_ ) ; } } catch ( pipelineexception | stageexception e ) { throw new runtimeexception ( e ) ; } }	Execute given consumer for each pipe, rethrowing usual exceptions as RuntimeException.Suitable for consumer that is not suppose to throw PipelineException and StageException.
public offsetcommittrigger getoffsetcommittrigger ( ) { for ( pipe pipe : pipes ) { stage stage = pipe . getstage ( ) . getstage ( ) ; if ( stage instanceof target && stage instanceof offsetcommittrigger ) { return ( offsetcommittrigger ) stage ; } } return null ; }	Retrieve OffsetCommitTrigger pipe.If it exists, null otherwise.
public boolean onrecorderrorstoppipeline ( ) { for ( pipe pipe : pipes ) { stagecontext stagecontext = pipe . getstage ( ) . getcontext ( ) ; if ( stagecontext . getonerrorrecord ( ) == onrecorderror . stop_pipeline ) { return bool_ ; } } return bool_ ; }	Return true if at least one stage is configured with STOP_PIPELINE for OnRecordError policy.
private void acceptconsumer ( throwingconsumer < pipe > consumer , pipe p ) throws pipelineruntimeexception , stageexception { try {	Accept given consumer and proper log context of any exception.
private string getinsertidforrecord ( elvars elvars , record record ) throws onrecorderrorexception { string recordid = null ; recordel . setrecordincontext ( elvars , record ) ; try { if ( ! ( stringutils . isempty ( conf . rowidexpression ) ) ) { recordid = rowideleval . eval ( elvars , conf . rowidexpression , string . class ) ; if ( stringutils . isempty ( recordid ) ) { throw new onrecorderrorexception ( record , errors . bigquery_15 ) ; } } } catch ( elevalexception e ) { log . error ( str_ , e ) ; throw new onrecorderrorexception ( record , errors . bigquery_10 , e ) ; } return recordid ; }	Evaluate and obtain the row id if the expression is present or return null.
private object getvaluefromfield ( string fieldpath , field field ) { log . trace ( str_ , fieldpath , field . gettype ( ) ) ; switch ( field . gettype ( ) ) { case list :	Convert the sdc Field to an object for row content.
private observable < record > setfragmentinrecord ( record record , documentfragment < lookup > frag ) { if ( frag . content ( num_ ) == null ) { log . debug ( str_ ) ; return handleerror ( record , errors . couchbase_25 , bool_ ) ; } for ( subdocmappingconfig subdocmapping : config . subdocmappingconfigs ) { object fragjson = frag . content ( subdocmapping . subdocpath ) ; if ( fragjson == null ) { return handleerror ( record , errors . couchbase_25 , bool_ ) ; } try { record . set ( subdocmapping . sdcfield , jsontofield ( fragjson ) ) ; record . getheader ( ) . setattribute ( config . cas_header_attribute , string . valueof ( frag . cas ( ) ) ) ; } catch ( ioexception e ) { try { record . set ( subdocmapping . sdcfield , jsontofield ( jsonobject . fromjson ( fragjson . tostring ( ) ) . tomap ( ) ) ) ; record . getheader ( ) . setattribute ( config . cas_header_attribute , string . valueof ( frag . cas ( ) ) ) ; } catch ( ioexception ex ) { return handleerror ( record , errors . couchbase_19 , ex , bool_ ) ; } } } return observable . just ( record ) ; }	Writes sub-document lookup values to the record.
private observable < record > setdocumentinrecord ( record record , jsondocument doc ) { if ( doc . content ( ) == null ) { log . debug ( str_ , doc . id ( ) ) ; return handleerror ( record , errors . couchbase_26 , bool_ ) ; } try { record . set ( config . outputfield , jsontofield ( doc . content ( ) . tomap ( ) ) ) ; record . getheader ( ) . setattribute ( config . cas_header_attribute , string . valueof ( doc . cas ( ) ) ) ; return observable . just ( record ) ; } catch ( ioexception e ) { log . debug ( str_ , doc . id ( ) ) ; return handleerror ( record , errors . couchbase_19 , e , bool_ ) ; } }	Writes full document lookup values to the record.
private observable < record > setn1qlrowinrecord ( record record , asyncn1qlqueryrow row ) { for ( n1qlmappingconfig n1qlmapping : config . n1qlmappingconfigs ) { if ( config . multiplevalueoperation == multiplevaluetype . first && record . get ( n1qlmapping . sdcfield ) != null ) { log . debug ( str_ ) ; return observable . empty ( ) ; } object property = row . value ( ) . get ( n1qlmapping . property ) ; if ( property == null ) { log . debug ( str_ , n1qlmapping . property ) ; return handleerror ( record , errors . couchbase_27 , bool_ ) ; } try { record . set ( n1qlmapping . sdcfield , jsontofield ( property ) ) ; } catch ( ioexception e ) { try { record . set ( n1qlmapping . sdcfield , jsontofield ( jsonobject . fromjson ( property . tostring ( ) ) . tomap ( ) ) ) ; } catch ( ioexception ex ) { log . debug ( str_ ) ; return handleerror ( record , errors . couchbase_19 , ex , bool_ ) ; } } } return observable . just ( record ) ; }	Writes N1QL query result rows to the record.
private void handlewholefiledataformat ( s3objectsummary s3objectsummary , string recordid ) throws stageexception { s3object partials3objectformetadata ;	as the record is just the metadata along with file ref.
public boolean incompletetransactionscontain ( string gtid , long seqno ) { long s = incompletetransactions . get ( gtid ) ; return s != null && s >= seqno ; }	Check if given gtid + seqNo pair is contained in this incomplete transactions.
private static < t > t withclassloaderinternal ( classloader classloader , exceptionsupplier < t > supplier ) throws exception { classloader previousclassloader = thread . currentthread ( ) . getcontextclassloader ( ) ; try { thread . currentthread ( ) . setcontextclassloader ( classloader ) ; return supplier . get ( ) ; } finally { thread . currentthread ( ) . setcontextclassloader ( previousclassloader ) ; } }	Internal version of the wrapping function that will simply propagate all exceptions up.
public synchronized void logout ( ) { if ( subject != null ) { log . debug ( str_ , securityconfiguration . iskerberosenabled ( ) , subject . getprincipals ( ) ) ; if ( logincontext != null ) { try { logincontext . logout ( ) ; } catch ( loginexception ex ) { log . warn ( str_ , ex . tostring ( ) , ex ) ; } finally { logincontext = null ; } } subject = null ; } }	Logs out. If Keberos is enabled it logs out from the KDC, otherwise is a NOP.
private void setexceptions ( configuration configuration ) { this . exceptions . clear ( ) ; this . stagelibexceptions . clear ( ) ;	This method should be called only once and before any stages are loaded.
private string replacevariables ( string path ) { return path . replace ( str_ , datadir ) . replace ( str_ , configdir ) . replace ( str_ , resourcesdir ) ; }	Replace variables to internal SDC directories so that users don't have to be entering FQDN.
private void ensureproperpermissions ( string path ) { classloader cl = thread . currentthread ( ) . getcontextclassloader ( ) ;	Make sure that the active code have proper rights to access the file inside protected directory.
public static void main ( string [ ] args ) throws exception { emrbinding binding = null ; try { binding = new emrbinding ( args ) ; binding . init ( ) ; binding . awaittermination ( ) ;	Bootstrapping the Driver which starts a EMR job on cluster.
string getdirpath ( date date , record record ) throws stageexception { if ( dirpathtemplateinheader ) {	Returns directory path for given record and date.
path renametofinalname ( filesystem fs , path temppath ) throws ioexception , stageexception { return fshelper . renameandgetpath ( fs , temppath ) ; }	This method should be called every time we finish writing into a file and consider it "done".
public boolean shouldroll ( recordwriter writer , record record ) { if ( rollifheader && record . getheader ( ) . getattribute ( rollheadername ) != null ) { log . debug ( str_ , writer . getpath ( ) , rollheadername , record . getheader ( ) . getattribute ( rollheadername ) , record . getheader ( ) . getsourceid ( ) ) ; return bool_ ; } return bool_ ; }	Return true if this record should be written into a new file regardless whether we have a file for the recordcurrently opened or not.
private boolean matchstrings ( string pattern , string str , map < string , string > uritemplatevariables ) { return getstringmatcher ( pattern ) . matchstrings ( str , uritemplatevariables ) ; }	Test whether or not a string matches against a pattern.
public map < string , string > getoffsets ( ) throws ioexception { utils . checkstate ( open , str_ ) ; return filecontextprovider . getoffsets ( ) ; }	Returns the current file offsets.
private long getremainingwaittime ( long starttime , long maxwaittimemillis ) { long remaining = maxwaittimemillis - ( system . currenttimemillis ( ) - starttime ) ; return ( remaining > num_ ) ? remaining : num_ ; }	remaining time till timeout, return zero if already in timeout.
public map < string , long > getoffsetslag ( map < string , string > offsetmap ) throws ioexception { return filecontextprovider . getoffsetslag ( offsetmap ) ; }	Determines the offset lag for each active file being read.
public stagelibrarydelegate create ( stagelibrarytask stagelib , string stagelibraryname , class exportedinterface ) { stagelibrarydelegatedefinitition def = stagelib . getstagelibrarydelegatedefinition ( stagelibraryname , exportedinterface ) ; if ( def == null ) { return null ; } return createinstance ( def ) ; }	Create new instance of the delegator from given stage library.
private stagelibrarydelegate createinstance ( stagelibrarydelegatedefinitition def ) { stagelibrarydelegate instance = null ; classloader classloader = thread . currentthread ( ) . getcontextclassloader ( ) ; try { thread . currentthread ( ) . setcontextclassloader ( def . getclassloader ( ) ) ; instance = def . getklass ( ) . newinstance ( ) ; } catch ( instantiationexception | illegalaccessexception ex ) { log . error ( str_ + ex . tostring ( ) , ex ) ; } finally { thread . currentthread ( ) . setcontextclassloader ( classloader ) ; } return instance ; }	Create actual instance of delegator.
public static object getmetricvalue ( metricregistry metrics , string metricid , metrictype metrictype , metricelement metricelement ) throws observerexception {	Get metric value for given rule evaluation.
private int findheaderend ( final byte [ ] buf , int rlen ) { int splitbyte = num_ ; while ( splitbyte + num_ < rlen ) {	Find byte index separating header from body.
public long getbodysize ( ) { if ( this . headers . containskey ( str_ ) ) { return long . parselong ( this . headers . get ( str_ ) ) ; } else if ( this . splitbyte < this . rlen ) { return this . rlen - this . splitbyte ; } return num_ ; }	Deduce body length in bytes.
private string savetmpfile ( bytebuffer b , int offset , int len , string filename_hint ) { string path = str_ ; if ( len > num_ ) { fileoutputstream fileoutputstream = null ; try { itempfile tempfile = this . tempfilemanager . createtempfile ( filename_hint ) ; bytebuffer src = b . duplicate ( ) ; fileoutputstream = new fileoutputstream ( tempfile . getname ( ) ) ; filechannel dest = fileoutputstream . getchannel ( ) ; src . position ( offset ) . limit ( offset + len ) ; dest . write ( src . slice ( ) ) ; path = tempfile . getname ( ) ; } catch ( exception e ) {	Retrieves the content of a sent file and saves it to a temporary file.The full path to the saved file is returned.
public static sslserversocketfactory makesslsocketfactory ( string keyandtruststoreclasspathpath , char [ ] passphrase ) throws ioexception { try { keystore keystore = keystore . getinstance ( keystore . getdefaulttype ( ) ) ; inputstream keystorestream = nanohttpd . class . getresourceasstream ( keyandtruststoreclasspathpath ) ; if ( keystorestream == null ) { throw new ioexception ( str_ + keyandtruststoreclasspathpath ) ; } keystore . load ( keystorestream , passphrase ) ; keymanagerfactory keymanagerfactory = keymanagerfactory . getinstance ( keymanagerfactory . getdefaultalgorithm ( ) ) ; keymanagerfactory . init ( keystore , passphrase ) ; return makesslsocketfactory ( keystore , keymanagerfactory ) ; } catch ( exception e ) { throw new ioexception ( e . getmessage ( ) ) ; } }	Creates an SSLSocketFactory for HTTPS. Pass a KeyStore resource with yourcertificate and passphrase.
public static string getmimetypeforfile ( string uri ) { int dot = uri . lastindexof ( str_ ) ; string mime = null ; if ( dot >= num_ ) { mime = mimetypes ( ) . get ( uri . substring ( dot + num_ ) . tolowercase ( ) ) ; } return mime == null ? str_ : mime ; }	Get MIME type from file name extension, if possible.
public response handle ( ihttpsession session ) { for ( ihandler < ihttpsession , response > interceptor : interceptors ) { response response = interceptor . handle ( session ) ; if ( response != null ) return response ; } return httphandler . handle ( session ) ; }	This is the "master" method that delegates requests to handlers and makessure there is a response to every request.
public void stop ( ) { try { safeclose ( this . myserversocket ) ; this . asyncrunner . closeall ( ) ; if ( this . mythread != null ) { this . mythread . join ( ) ; } } catch ( exception e ) { nanohttpd . log . log ( level . severe , str_ , e ) ; } }	Stop the server.
public void addmappings ( ) { router . setnotimplemented ( notimplementedhandler . class ) ; router . setnotfoundhandler ( error404urihandler . class ) ; router . addroute ( str_ , integer . max_value / num_ , indexhandler . class ) ; router . addroute ( str_ , integer . max_value / num_ , indexhandler . class ) ; }	default routings, they are over writable.
private void sendbody ( outputstream outputstream , long pending ) throws ioexception { long buffer_size = num_ * num_ ; byte [ ] buff = new byte [ ( int ) buffer_size ] ; boolean sendeverything = pending == - num_ ; while ( pending > num_ || sendeverything ) { long bytestoread = sendeverything ? buffer_size : math . min ( pending , buffer_size ) ; int read = this . data . read ( buff , num_ , ( int ) bytestoread ) ; if ( read <= num_ ) { break ; } try { outputstream . write ( buff , num_ , read ) ; } catch ( exception e ) { if ( this . data != null ) { this . data . close ( ) ; } } if ( ! sendeverything ) { pending -= read ; } } }	Sends the body to the specified OutputStream.
public static response newfixedlengthresponse ( istatus status , string mimetype , inputstream data , long totalbytes ) { return new response ( status , mimetype , data , totalbytes ) ; }	Create a response with known length.
public boolean usegzipwhenaccepted ( ) { if ( gzipusage == gzipusage . default ) return getmimetype ( ) != null && ( getmimetype ( ) . tolowercase ( ) . contains ( str_ ) || getmimetype ( ) . tolowercase ( ) . contains ( str_ ) ) ; else return gzipusage == gzipusage . always ; }	Else decide whether or not to use Gzip.
public void set ( string name , string value , int expires ) { this . queue . add ( new cookie ( name , value , cookie . gethttptime ( expires ) ) ) ; }	Sets a cookie.
public void unloadqueue ( response response ) { for ( cookie cookie : this . queue ) { response . addcookieheader ( cookie . gethttpheader ( ) ) ; } }	Internally used by the webserver to add all queued cookies into theResponse's HTTP Headers.
private string base64decode ( string base64value ) { try { byte [ ] decodedcookiebytes = base64 . getdecoder ( ) . decode ( base64value ) ; return new string ( decodedcookiebytes ) ; } catch ( exception ex ) { logger . debug ( str_ + base64value ) ; return null ; } }	Decode the value using Base64.
private string base64encode ( string value ) { byte [ ] encodedcookiebytes = base64 . getencoder ( ) . encode ( value . getbytes ( ) ) ; return new string ( encodedcookiebytes ) ; }	Encode the value using Base64.
public void settablename ( string tablename ) { assert . hastext ( tablename , str_ ) ; this . tablename = tablename . trim ( ) ; preparequeries ( ) ; }	Set the name of database table used to store sessions.
protected string name ( object principal ) { if ( principal instanceof userdetails ) { return ( ( userdetails ) principal ) . getusername ( ) ; } if ( principal instanceof principal ) { return ( ( principal ) principal ) . getname ( ) ; } return principal . tostring ( ) ; }	Derives a String name for the given principal.
private void insertsessionrepositoryfilter ( servletcontext servletcontext ) { string filtername = default_filter_name ; delegatingfilterproxy springsessionrepositoryfilter = new delegatingfilterproxy ( filtername ) ; string contextattribute = getwebapplicationcontextattribute ( ) ; if ( contextattribute != null ) { springsessionrepositoryfilter . setcontextattribute ( contextattribute ) ; } registerfilter ( servletcontext , bool_ , filtername , springsessionrepositoryfilter ) ; }	Registers the springSessionRepositoryFilter.
private static string resolveprincipal ( session session ) { string principalname = session . getattribute ( findbyindexnamesessionrepository . principal_name_index_name ) ; if ( principalname != null ) { return principalname ; } securitycontext securitycontext = session . getattribute ( spring_security_context ) ; if ( securitycontext != null && securitycontext . getauthentication ( ) != null ) { return securitycontext . getauthentication ( ) . getname ( ) ; } return str_ ; }	Tries to determine the principal's name from the given Session.
private redissession getsession ( string id , boolean allowexpired ) { map < object , object > entries = getsessionboundhashoperations ( id ) . entries ( ) ; if ( entries . isempty ( ) ) { return null ; } mapsession loaded = loadsession ( id , entries ) ; if ( ! allowexpired && loaded . isexpired ( ) ) { return null ; } redissession result = new redissession ( loaded ) ; result . originallastaccesstime = loaded . getlastaccessedtime ( ) ; return result ; }	Gets the session.
static string getjndiname ( final modelnode modelnode , operationcontext context ) throws operationfailedexception { final string rawjndiname = mailsessiondefinition . jndi_name . resolvemodelattribute ( context , modelnode ) . asstring ( ) ; return getjndiname ( rawjndiname ) ; }	Extracts the raw JNDI_NAME value from the given model node, and depending on the value andthe value of any USE_JAVA_CONTEXT child node, converts the raw name into a compliant jndi name.
public static string [ ] getcanonicalparametertypes ( method viewmethod ) { class < ? > [ ] parametertypes = viewmethod . getparametertypes ( ) ; if ( parametertypes == null ) { return no_strings ; } string [ ] canonicalnames = new string [ parametertypes . length ] ; for ( int i = num_ ; i < parametertypes . length ; i ++ ) { canonicalnames [ i ] = parametertypes [ i ] . getcanonicalname ( ) ; } return canonicalnames ; }	This method returns the class names of the parameters of the given methodin canonical form.
public void registerinterposedsynchronization ( synchronization synchronization ) throws illegalstateexception , systemexception { int status = contexttransactionsynchronizationregistry . getinstance ( ) . gettransactionstatus ( ) ; switch ( status ) { case javax . transaction . status . status_active : case javax . transaction . status . status_preparing : break ; case status . status_marked_rollback :	This is only allowed at various points of the transaction lifecycle.
@ override public void beforecompletion ( ) {	Exceptions from Synchronizations that are registered with this TSR are not trapped for before completion.
public static transaction getcurrenttransaction ( ) { transaction tx = null ; if ( picurrent != null ) {	Returns the transaction associated with the transaction propagationcontext that arrived in the current IIOP request.
@ override public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit unit = phasecontext . getdeploymentunit ( ) ; final list < kerneldeploymentxmldescriptor > kdxmldescriptors = unit . getattachment ( kerneldeploymentxmldescriptor . attachment_key ) ; if ( kdxmldescriptors == null || kdxmldescriptors . isempty ( ) ) return ; for ( kerneldeploymentxmldescriptor kdxd : kdxmldescriptors ) { if ( kdxd . getbeanfactoriescount ( ) > num_ ) { final modulespecification modulespecification = unit . getattachment ( attachments . module_specification ) ; final moduleloader moduleloader = module . getbootmoduleloader ( ) ; moduledependency dependency = new moduledependency ( moduleloader , pojo_module , bool_ , bool_ , bool_ , bool_ ) ; pathfilter filter = pathfilters . ischildof ( basebeanfactory . class . getpackage ( ) . getname ( ) ) ; dependency . addimportfilter ( filter , bool_ ) ; dependency . addimportfilter ( pathfilters . rejectall ( ) , bool_ ) ; modulespecification . addsystemdependency ( dependency ) ; return ; } } }	Add POJO module if we have any bean factories.
@ override public boolean doesscopedpersistenceunitnameidentifycacheregionname ( persistenceunitmetadata pu ) { string cacheregionprefix = pu . getproperties ( ) . getproperty ( availablesettings . cache_region_prefix ) ; return cacheregionprefix == null || cacheregionprefix . equals ( pu . getscopedpersistenceunitname ( ) ) ; }	determine if management console can display the second level cache entries.
private static list < servicename > getserverconfigdependencies ( operationcontext context , boolean appclient ) { final list < servicename > servicenames = new arraylist < servicename > ( ) ; final resource subsystemresource = context . readresourcefromroot ( pathaddress . pathaddress ( wsextension . subsystem_path ) , bool_ ) ; readconfigservicenames ( servicenames , subsystemresource , constants . client_config ) ; readconfigservicenames ( servicenames , subsystemresource , constants . endpoint_config ) ; if ( ! appclient ) { servicenames . add ( commonwebserver . service_name ) ; } return servicenames ; }	Process the model to figure out the name of the services the server config service has to depend on.
private void decreadlockcount ( ) { integer current = readlockcount . get ( ) ; int next ; assert current != null : str_ ; next = current . intvalue ( ) - num_ ; if ( next == num_ ) readlockcount . remove ( ) ; else readlockcount . set ( new integer ( next ) ) ; }	Decrements the read lock count held by the thread.
private void increadlockcount ( ) { integer current = readlockcount . get ( ) ; int next ; if ( current == null ) next = num_ ; else next = current . intvalue ( ) + num_ ; readlockcount . set ( new integer ( next ) ) ; }	Increments the read lock count held by the thread.
public synchronized < s extends service > void addservice ( class < s > clazz , s service ) { for ( beandeploymentarchiveimpl bda : beandeploymentarchives ) { bda . getservices ( ) . add ( clazz , service ) ; } }	Adds a service to all bean deployment archives in the module.
public void handlerestorationcalculation ( ) { if ( nextexpiration == null ) { return ; }	Makes sure that the timer is only run once after being restored.
public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final modulespecification modulespecification = deploymentunit . getattachment ( attachments . module_specification ) ; final moduleloader moduleloader = module . getbootmoduleloader ( ) ; if ( jpadeploymentmarker . isjpadeployment ( deploymentunit ) ) { addsearchdependency ( modulespecification , moduleloader , deploymentunit ) ; } }	if set to `auto`, will behave like not having set the property.
private void maketoplevelbdasvisiblefromstaticmodules ( ) { for ( beandeploymentarchiveimpl bda : beandeploymentarchives ) { if ( bda . getbeanarchivetype ( ) . equals ( beandeploymentarchiveimpl . beanarchivetype . external ) || bda . getbeanarchivetype ( ) . equals ( beandeploymentarchiveimpl . beanarchivetype . synthetic ) ) { for ( beandeploymentarchiveimpl toplevelbda : rootbeandeploymentmodule . getbeandeploymentarchives ( ) ) { bda . addbeandeploymentarchive ( toplevelbda ) ; } } } }	Adds additional edges to the accessibility graph that allow static CDI-enabled modules to inject beans from top-level deployment units.
jsearchivemetadata create ( final deployment dep ) { if ( wslogger . root_logger . istraceenabled ( ) ) { wslogger . root_logger . tracef ( str_ , dep . getsimplename ( ) ) ; } final jbosswebmetadata jbosswebmd = wshelper . getrequiredattachment ( dep , jbosswebmetadata . class ) ; final deploymentunit unit = wshelper . getrequiredattachment ( dep , deploymentunit . class ) ; final list < pojoendpoint > pojoendpoints = getpojoendpoints ( unit ) ; final jsearchivemetadata . builder builder = new jsearchivemetadata . builder ( ) ;	Builds universal JSE meta data model that is AS agnostic.
private void setconfignameandfile ( final jsearchivemetadata . builder builder , final jbosswebmetadata jbosswebmd , final jbosswebservicesmetadata jbosswebservicesmd ) { if ( jbosswebservicesmd != null ) { if ( jbosswebservicesmd . getconfigname ( ) != null ) { final string configname = jbosswebservicesmd . getconfigname ( ) ; builder . setconfigname ( configname ) ; wslogger . root_logger . tracef ( str_ , configname ) ; final string configfile = jbosswebservicesmd . getconfigfile ( ) ; builder . setconfigfile ( configfile ) ; wslogger . root_logger . tracef ( str_ , configfile ) ;	Sets config name and config file.
private list < jsesecuritymetadata > getsecuritymetadata ( final list < securityconstraintmetadata > securityconstraintsmd ) { final list < jsesecuritymetadata > jsesecuritymds = new linkedlist < jsesecuritymetadata > ( ) ; if ( securityconstraintsmd != null ) { for ( final securityconstraintmetadata securityconstraintmd : securityconstraintsmd ) { final jsesecuritymetadata . builder jsesecuritymdbuilder = new jsesecuritymetadata . builder ( ) ;	Builds security meta data.
private map < string , string > getservleturlpatternsmappings ( final jbosswebmetadata jbosswebmd , final list < pojoendpoint > pojoendpoints ) { final map < string , string > mappings = new hashmap < string , string > ( ) ; final list < servletmappingmetadata > servletmappings = webmetadatahelper . getservletmappings ( jbosswebmd ) ; for ( final pojoendpoint pojoendpoint : pojoendpoints ) { mappings . put ( pojoendpoint . getname ( ) , pojoendpoint . geturlpattern ( ) ) ; if ( ! pojoendpoint . isdeclared ( ) ) { final string endpointname = pojoendpoint . getname ( ) ; final list < string > urlpatterns = webmetadatahelper . geturlpatterns ( pojoendpoint . geturlpattern ( ) ) ; webmetadatahelper . newservletmapping ( endpointname , urlpatterns , servletmappings ) ; } } return mappings ; }	Returns servlet name to url pattern mappings.
private map < string , string > getservletclassmappings ( final jbosswebmetadata jbosswebmd , final list < pojoendpoint > pojoendpoints ) { final map < string , string > mappings = new hashmap < string , string > ( ) ; final jbossservletsmetadata servlets = webmetadatahelper . getservlets ( jbosswebmd ) ; for ( final pojoendpoint pojoendpoint : pojoendpoints ) { final string pojoname = pojoendpoint . getname ( ) ; final string pojoclassname = pojoendpoint . getclassname ( ) ; mappings . put ( pojoname , pojoclassname ) ; if ( ! pojoendpoint . isdeclared ( ) ) { final string endpointname = pojoendpoint . getname ( ) ; final string endpointclassname = pojoendpoint . getclassname ( ) ; webmetadatahelper . newservlet ( endpointname , endpointclassname , servlets ) ; } } return mappings ; }	Returns servlet name to servlet class mappings.
private void resolve ( ) { if ( ! resolved ) { synchronized ( this ) { if ( ! resolved ) { final set < viewdescription > views = getviews ( ) ; final set < ejbviewdescription > ejbsforviewname = new hashset < ejbviewdescription > ( ) ; for ( final viewdescription view : views ) { if ( view instanceof ejbviewdescription ) { final methodintf viewtype = ( ( ejbviewdescription ) view ) . getmethodintf ( ) ;	Checks if this ejb injection has been resolved yet, and if not resolves it.
private static set < string > getavailableconnectors ( final operationcontext context , final modelnode operation ) throws operationfailedexception { pathaddress address = pathaddress . pathaddress ( operation . get ( modeldescriptionconstants . op_addr ) ) ; pathaddress active = messagingservices . getactivemqserverpathaddress ( address ) ; set < string > availableconnectors = new hashset < string > ( ) ; resource subsystemresource = context . readresourcefromroot ( active . getparent ( ) , bool_ ) ; availableconnectors . addall ( subsystemresource . getchildrennames ( commonattributes . remote_connector ) ) ; resource activemqserverresource = context . readresourcefromroot ( active , bool_ ) ; availableconnectors . addall ( activemqserverresource . getchildrennames ( commonattributes . http_connector ) ) ; availableconnectors . addall ( activemqserverresource . getchildrennames ( commonattributes . in_vm_connector ) ) ; availableconnectors . addall ( activemqserverresource . getchildrennames ( commonattributes . remote_connector ) ) ; availableconnectors . addall ( activemqserverresource . getchildrennames ( commonattributes . connector ) ) ; return availableconnectors ; }	FIXME use capabilities & requirements.
static void parsecoreenvironmentelement ( final xmlextendedstreamreader reader , final modelnode operation ) throws xmlstreamexception { final int count = reader . getattributecount ( ) ; for ( int i = num_ ; i < count ; i ++ ) { requirenonamespaceattribute ( reader , i ) ; final string value = reader . getattributevalue ( i ) ; final attribute attribute = attribute . forname ( reader . getattributelocalname ( i ) ) ; switch ( attribute ) { case node_identifier : transactionsubsystemrootresourcedefinition . node_identifier . parseandsetparameter ( value , operation , reader ) ; break ; case path : case relative_to : throw transactionlogger . root_logger . unsupportedattribute ( attribute . getlocalname ( ) , reader . getlocation ( ) ) ; default : throw unexpectedattribute ( reader , i ) ; } }	Handle the core-environment element and children.
static void parseprocessidenvironmentelement ( xmlextendedstreamreader reader , modelnode coreenvironmentadd ) throws xmlstreamexception {	Handle the process-id child elements.
public static pathaddress getpathaddress ( modelnode operation ) { return pathaddress . pathaddress ( operation . require ( modeldescriptionconstants . op_addr ) ) ; }	Returns the address of the specified operation.
public static void setpathaddress ( modelnode operation , pathaddress address ) { operation . get ( modeldescriptionconstants . op_addr ) . set ( address . tomodelnode ( ) ) ; }	Sets the address of the specified operation.
public static modelnode getattributevalue ( modelnode operation ) { return operation . hasdefined ( modeldescriptionconstants . value ) ? operation . get ( modeldescriptionconstants . value ) : new modelnode ( ) ; }	Returns the attribute value of the specified operation.
public static boolean isincludedefaults ( modelnode operation ) { return operation . hasdefined ( modeldescriptionconstants . include_defaults ) ? operation . get ( modeldescriptionconstants . include_defaults ) . asboolean ( ) : bool_ ; }	Indicates whether or not this operation expects to include default values.
public static modelnode createcompositeoperation ( list < modelnode > operations ) { modelnode operation = util . createoperation ( modeldescriptionconstants . composite , pathaddress . empty_address ) ; modelnode steps = operation . get ( modeldescriptionconstants . steps ) ; for ( modelnode step : operations ) { steps . add ( step ) ; } return operation ; }	Creates a composite operation using the specified operation steps.
public static modelnode createaddoperation ( pathaddress address , map < attribute , modelnode > parameters ) { modelnode operation = util . createaddoperation ( address ) ; for ( map . entry < attribute , modelnode > entry : parameters . entryset ( ) ) { operation . get ( entry . getkey ( ) . getname ( ) ) . set ( entry . getvalue ( ) ) ; } return operation ; }	Creates an add operation using the specified address and parameters.
public static modelnode createaddoperation ( pathaddress address , int index ) { return createaddoperation ( address , index , collections . emptymap ( ) ) ; }	Creates an indexed add operation using the specified address and index.
public static modelnode createreadattributeoperation ( pathaddress address , attribute attribute ) { return createattributeoperation ( modeldescriptionconstants . read_attribute_operation , address , attribute ) ; }	Creates a read-attribute operation using the specified address and name.
public static modelnode createwriteattributeoperation ( pathaddress address , attribute attribute , modelnode value ) { modelnode operation = createattributeoperation ( modeldescriptionconstants . write_attribute_operation , address , attribute ) ; operation . get ( modeldescriptionconstants . value ) . set ( value ) ; return operation ; }	Creates a write-attribute operation using the specified address, name and value.
public static modelnode createundefineattributeoperation ( pathaddress address , attribute attribute ) { return createattributeoperation ( modeldescriptionconstants . undefine_attribute_operation , address , attribute ) ; }	Creates an undefine-attribute operation using the specified address and name.
public t getvalue ( ) throws illegalstateexception { final context context = contextvalue . getvalue ( ) ; try { return ( t ) context . lookup ( contextname ) ; } catch ( namingexception e ) { throw naminglogger . root_logger . entrynotregistered ( e , contextname , context ) ; } }	Lookup the value from the naming context.
public static synchronized void addurlcontextfactory ( final string scheme , objectfactory factory ) { map < string , objectfactory > factories = new hashmap < string , objectfactory > ( urlcontextfactories ) ; factories . put ( scheme , factory ) ; urlcontextfactories = collections . unmodifiablemap ( factories ) ; }	Add an ObjectFactory to handle requests for a specific URL scheme.
public static synchronized void removeurlcontextfactory ( final string scheme , objectfactory factory ) { map < string , objectfactory > factories = new hashmap < string , objectfactory > ( urlcontextfactories ) ; objectfactory f = factories . get ( scheme ) ; if ( f == factory ) { factories . remove ( scheme ) ; urlcontextfactories = collections . unmodifiablemap ( factories ) ; return ; } else { throw new illegalargumentexception ( ) ; } }	Remove an ObjectFactory from the map of registered ones.
private list < validationprovider < ? > > loadproviders ( classloader classloader ) { @ suppresswarnings ( str_ ) iterator < validationprovider > provideriterator = serviceloader . load ( validationprovider . class , classloader ) . iterator ( ) ; linkedlist < validationprovider < ? > > providers = new linkedlist < validationprovider < ? > > ( ) ; while ( provideriterator . hasnext ( ) ) { try { validationprovider < ? > provider = provideriterator . next ( ) ;	Retrieves the providers from the given loader, using the service loader mechanism.
void modify ( final deployment dep ) { final jbosswebmetadata jbosswebmd = wshelper . getoptionalattachment ( dep , jbosswebmetadata . class ) ; if ( jbosswebmd != null ) { this . configureendpoints ( dep , jbosswebmd ) ; this . modifycontextroot ( dep , jbosswebmd ) ; } }	Modifies web meta data to configure webservice stack transport and properties.
private void configureendpoints ( final deployment dep , final jbosswebmetadata jbosswebmd ) { final string transportclassname = this . gettransportclassname ( dep ) ; wslogger . root_logger . trace ( str_ ) ;	Configures transport servlet class for every found webservice endpoint.
private void modifycontextroot ( final deployment dep , final jbosswebmetadata jbosswebmd ) { final string contextroot = dep . getservice ( ) . getcontextroot ( ) ; if ( wslogger . root_logger . istraceenabled ( ) ) { wslogger . root_logger . tracef ( str_ , contextroot , dep . getsimplename ( ) ) ; } jbosswebmd . setcontextroot ( contextroot ) ; }	Modifies context root.
private string gettransportclassname ( final deployment dep ) { string transportclassname = ( string ) dep . getproperty ( wsconstants . stack_transport_class ) ; if ( transportclassname == null ) throw wslogger . root_logger . missingdeploymentproperty ( wsconstants . stack_transport_class ) ; return transportclassname ; }	Returns stack specific transport class name.
static runas setrunasidentity ( final runas principal , final securitycontext sc ) { if ( wildflysecuritymanager . ischecking ( ) ) { return wildflysecuritymanager . dounchecked ( new privilegedaction < runas > ( ) { @ override public runas run ( ) { if ( sc == null ) { throw undertowlogger . root_logger . nosecuritycontext ( ) ; } runas old = sc . getoutgoingrunas ( ) ; sc . setoutgoingrunas ( principal ) ; return old ; } } ) ; } else { if ( sc == null ) { throw undertowlogger . root_logger . nosecuritycontext ( ) ; } runas old = sc . getoutgoingrunas ( ) ; sc . setoutgoingrunas ( principal ) ; return old ; } }	Sets the run as identity.
static runas poprunasidentity ( final securitycontext sc ) { if ( wildflysecuritymanager . ischecking ( ) ) { return accesscontroller . doprivileged ( new privilegedaction < runas > ( ) { @ override public runas run ( ) { if ( sc == null ) { throw undertowlogger . root_logger . nosecuritycontext ( ) ; } runas principal = sc . getoutgoingrunas ( ) ; sc . setoutgoingrunas ( null ) ; return principal ; } } ) ; } else { if ( sc == null ) { throw undertowlogger . root_logger . nosecuritycontext ( ) ; } runas principal = sc . getoutgoingrunas ( ) ; sc . setoutgoingrunas ( null ) ; return principal ; } }	Removes the run as identity.
void processmanagement ( final deploymentunit unit , jbosswebmetadata metadata ) { final deploymentresourcesupport deploymentresourcesupport = unit . getattachment ( attachments . deployment_resource_support ) ; for ( final jbossservletmetadata servlet : metadata . getservlets ( ) ) { try { final string name = servlet . getname ( ) ; final modelnode node = deploymentresourcesupport . getdeploymentsubmodel ( undertowextension . subsystem_name , pathelement . pathelement ( str_ , name ) ) ; node . get ( str_ ) . set ( servlet . getservletclass ( ) ) ; node . get ( str_ ) . set ( servlet . getservletname ( ) ) ; } catch ( exception e ) {	todo move to UndertowDeploymentService and use all registered servlets from Deployment instead of just one found by metadata.
@ suppresswarnings ( str_ ) public void inject ( object object , string propertyname , object propertyvalue ) throws nosuchmethodexception , illegalaccessexception , invocationtargetexception { inject ( object , propertyname , propertyvalue , null , bool_ ) ; }	Inject a value into an object property.
private boolean argumentmatches ( string classtype , string propertytype ) { return ( classtype . equals ( propertytype ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) || ( classtype . equals ( str_ ) && propertytype . equals ( str_ ) ) ; }	Compare the type of a class with the actual value.
protected method findmethod ( class < ? > clz , string methodname , string propertytype ) { while ( ! clz . equals ( object . class ) ) { list < method > hits = null ; method [ ] methods = securityactions . getdeclaredmethods ( clz ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { final method method = methods [ i ] ; if ( methodname . equals ( method . getname ( ) ) && method . getparametertypes ( ) . length == num_ ) { if ( propertytype == null || argumentmatches ( propertytype , method . getparametertypes ( ) [ num_ ] . getname ( ) ) ) { if ( hits == null ) hits = new arraylist < method > ( num_ ) ; securityactions . setaccessible ( method ) ; hits . add ( method ) ; } } } if ( hits != null ) { if ( hits . size ( ) == num_ ) { return hits . get ( num_ ) ; } else { collections . sort ( hits , new methodsorter ( ) ) ; if ( propertytype != null ) { for ( method m : hits ) { if ( propertytype . equals ( m . getparametertypes ( ) [ num_ ] . getname ( ) ) ) return m ; } } return hits . get ( num_ ) ; } } clz = clz . getsuperclass ( ) ; } return null ; }	Find a method.
protected field findfield ( class < ? > clz , string fieldname , string fieldtype ) { while ( ! clz . equals ( object . class ) ) { list < field > hits = null ; field [ ] fields = securityactions . getdeclaredfields ( clz ) ; for ( int i = num_ ; i < fields . length ; i ++ ) { final field field = fields [ i ] ; if ( fieldname . equals ( field . getname ( ) ) ) { if ( fieldtype == null || argumentmatches ( fieldtype , field . gettype ( ) . getname ( ) ) ) { if ( hits == null ) hits = new arraylist < field > ( num_ ) ; securityactions . setaccessible ( field ) ; hits . add ( field ) ; } } } if ( hits != null ) { if ( hits . size ( ) == num_ ) { return hits . get ( num_ ) ; } else { collections . sort ( hits , new fieldsorter ( ) ) ; if ( fieldtype != null ) { for ( field f : hits ) { if ( fieldtype . equals ( f . gettype ( ) . getname ( ) ) ) return f ; } } return hits . get ( num_ ) ; } } clz = clz . getsuperclass ( ) ; } return null ; }	Find a field.
private static string deriveusefulinfo ( httpservletrequest httprequest ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) . append ( httprequest . getcontextpath ( ) ) ; sb . append ( str_ ) . append ( arrays . tostring ( httprequest . getcookies ( ) ) ) . append ( str_ ) ;	Obtain debug information from the servlet request object.
public jdrreport standalonecollect ( cli cli , string protocol , string host , int port ) throws operationfailedexception { return new jdrrunner ( cli , protocol , host , port , null , null ) . collect ( ) ; }	Collect a JDR report when run outside the Application Server.
public jdrreport collect ( ) throws operationfailedexception { jdrrunner runner = new jdrrunner ( bool_ ) ; serverenvironment = serverenvironmentvalue . getvalue ( ) ; runner . setjbosshomedir ( serverenvironment . gethomedir ( ) . getabsolutepath ( ) ) ; runner . setreportlocationdir ( serverenvironment . getservertempdir ( ) . getabsolutepath ( ) ) ; runner . setcontrollerclient ( controllerclient ) ; runner . sethostcontrollername ( serverenvironment . gethostcontrollername ( ) ) ; runner . setservername ( serverenvironment . getservername ( ) ) ; return runner . collect ( ) ; }	Collect a JDR report.
public void registerresourceadapterdeployment ( resourceadapterdeployment deployment ) { if ( deployment == null ) throw new illegalargumentexception ( connectorlogger . root_logger . nullvar ( str_ ) ) ; deployment_connector_registry_logger . tracef ( str_ , deployment ) ; deployments . add ( deployment ) ; }	Register a resource adapter deployment.
public void unregisterresourceadapterdeployment ( resourceadapterdeployment deployment ) { if ( deployment == null ) throw new illegalargumentexception ( connectorlogger . root_logger . nullvar ( str_ ) ) ; deployment_connector_registry_logger . tracef ( str_ , deployment ) ; deployments . remove ( deployment ) ; }	Unregister a resource adapter deployment.
protected static void registertransformers ( final subsystemregistration subsystem ) { chainedtransformationdescriptionbuilder chained = resourcetransformationdescriptionbuilder . factory . createchainedsubysteminstance ( current_model_version ) ; modelversion model_version_eap64 = modelversion . create ( num_ , num_ , num_ ) ; modelversion model_version_eap63 = modelversion . create ( num_ , num_ , num_ ) ;	Register the transformers for the 1.3.0 version.
public void writeparams ( outputstream out , object [ ] params ) { int len = params . length ; if ( len != paramwriters . length ) { throw iioplogger . root_logger . errormashalingparams ( ) ; } for ( int i = num_ ; i < len ; i ++ ) { object param = params [ i ] ; if ( param instanceof portableremoteobject ) { try { param = portableremoteobject . tostub ( ( remote ) param ) ; } catch ( nosuchobjectexception e ) { throw new runtimeexception ( e ) ; } } paramwriters [ i ] . write ( out , remoteobjectsubstitutionmanager . writereplaceremote ( param ) ) ; } }	Marshals the sequence of method parameters into an output stream.
public exception readexception ( string id , inputstream in ) { exceptionreader exceptionreader = ( exceptionreader ) exceptionmap . get ( id ) ; if ( exceptionreader == null ) { return new unexpectedexception ( id ) ; } else { return exceptionreader . read ( in ) ; } }	Unmarshals from an input stream an exception thrown by the method.
private static object getlockowner ( final transactionsynchronizationregistry transactionsynchronizationregistry ) { object owner = transactionsynchronizationregistry . gettransactionkey ( ) ; return owner != null ? owner : thread . currentthread ( ) ; }	Use either the active transaction or the current thread as the lock owner.
static void releaselock ( final statefulsessioncomponentinstance instance ) { instance . getlock ( ) . unlock ( getlockowner ( instance . getcomponent ( ) . gettransactionsynchronizationregistry ( ) ) ) ; root_logger . tracef ( str_ , instance . getlock ( ) ) ; }	Releases the lock, held by this thread, on the stateful component instance.
public void addlog ( string content , string logname ) throws exception { string name = str_ + logname ; this . add ( new bytearrayinputstream ( content . getbytes ( standardcharsets . utf_8 ) ) , name ) ; }	Adds content to the zipfile in a file named logNamepath is prepended with the directory reserved for JDR log files.
private void addcdiflag ( warmetadata warmetadata , deploymentunit deploymentunit ) { jbosswebmetadata webmetadata = warmetadata . getmergedjbosswebmetadata ( ) ; if ( webmetadata == null ) { webmetadata = new jbosswebmetadata ( ) ; warmetadata . setmergedjbosswebmetadata ( webmetadata ) ; } list < paramvaluemetadata > contextparams = webmetadata . getcontextparams ( ) ; if ( contextparams == null ) { contextparams = new arraylist < paramvaluemetadata > ( ) ; } boolean iscdi = bool_ ; final capabilityservicesupport support = deploymentunit . getattachment ( attachments . capability_service_support ) ; if ( support . hascapability ( weld_capability_name ) ) { iscdi = support . getoptionalcapabilityruntimeapi ( weld_capability_name , weldcapability . class ) . get ( ) . ispartofwelddeployment ( deploymentunit ) ; } paramvaluemetadata param = new paramvaluemetadata ( ) ; param . setparamname ( is_cdi_param ) ; param . setparamvalue ( boolean . tostring ( iscdi ) ) ; contextparams . add ( param ) ; webmetadata . setcontextparams ( contextparams ) ; }	a CDI ViewHandler.
protected componentview getcomponentview ( ) { componentview cv = componentview ;	Gets endpoint container lazily.
public void invoke ( final endpoint endpoint , final invocation wsinvocation ) throws exception { try { if ( ! endpointstate . started . equals ( endpoint . getstate ( ) ) ) { throw wslogger . root_logger . endpointalreadystopped ( endpoint . getshortname ( ) ) ; } securitydomaincontext securitydomaincontext = endpoint . getsecuritydomaincontext ( ) ; securitydomaincontext . runas ( ( callable < void > ) ( ) -> { invokeinternal ( endpoint , wsinvocation ) ; return null ; } ) ; } catch ( throwable t ) { handleinvocationexception ( t ) ; } finally { onafterinvocation ( wsinvocation ) ; } }	Invokes WS endpoint.
protected method getcomponentviewmethod ( final method seimethod , final collection < method > viewmethods ) { for ( final method viewmethod : viewmethods ) { if ( matches ( seimethod , viewmethod ) ) { return viewmethod ; } } throw new illegalstateexception ( ) ; }	Translates SEI method to component view method.
private boolean matches ( final method seimethod , final method viewmethod ) { if ( ! seimethod . getname ( ) . equals ( viewmethod . getname ( ) ) ) return bool_ ; final class < ? > [ ] sourceparams = seimethod . getparametertypes ( ) ; final class < ? > [ ] targetparams = viewmethod . getparametertypes ( ) ; if ( sourceparams . length != targetparams . length ) return bool_ ; for ( int i = num_ ; i < sourceparams . length ; i ++ ) { if ( ! sourceparams [ i ] . equals ( targetparams [ i ] ) ) return bool_ ; } return bool_ ; }	Compares two methods if they are identical.
private ejbsecuritymetadata getejbsecuritymetadata ( final endpoint endpoint ) { final string ejbname = endpoint . getshortname ( ) ; final deployment dep = endpoint . getservice ( ) . getdeployment ( ) ; final ejbarchivemetadata ejbarchivemd = wshelper . getoptionalattachment ( dep , ejbarchivemetadata . class ) ; final ejbmetadata ejbmd = ejbarchivemd != null ? ejbarchivemd . getbeanbyejbname ( ejbname ) : null ; return ejbmd != null ? ejbmd . getsecuritymetadata ( ) : null ; }	Gets EJB security meta data if associated with EJB endpoint.
private string getdomain ( final string oldsecuritydomain , final string nextsecuritydomain ) { if ( nextsecuritydomain == null ) { return oldsecuritydomain ; } if ( oldsecuritydomain == null ) { return nextsecuritydomain ; } ensuresamedomains ( oldsecuritydomain , nextsecuritydomain ) ; return oldsecuritydomain ; }	Returns security domain value.
private void ensuresamedomains ( final string oldsecuritydomain , final string newsecuritydomain ) { final boolean domainsdiffer = ! oldsecuritydomain . equals ( newsecuritydomain ) ; if ( domainsdiffer ) throw wslogger . root_logger . multiplesecuritydomainsdetected ( oldsecuritydomain , newsecuritydomain ) ; }	This method ensures both passed domains contain the same value.
void setidlname ( string idlname ) { super . setidlname ( idlname ) ;	Set my unqualified IDL name.This also sets the names of the associated operations.
public string getabsolutename ( ) { final stringbuilder absolute = new stringbuilder ( ) ; if ( parent != null ) { absolute . append ( parent ) . append ( entry_separator ) ; } absolute . append ( local ) ; return absolute . tostring ( ) ; }	Get the absolute JNDI name as a string.
public static jndiname of ( final string name ) { if ( name == null || name . isempty ( ) ) throw naminglogger . root_logger . invalidjndiname ( name ) ; final string [ ] parts = name . split ( entry_separator ) ; jndiname current = null ; for ( string part : parts ) { current = new jndiname ( current , part ) ; } return current ; }	Create a new instance of the JndiName by breaking the provided string format into a JndiName parts.
@ override public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final resourceroot resourceroot = deploymentunit . getattachment ( attachments . deployment_root ) ; final virtualfile deploymentroot = resourceroot . getroot ( ) ; final boolean resolveproperties = util . shouldresolvejboss ( deploymentunit ) ; ironjacamarxmldescriptor xmldescriptor = process ( deploymentroot , resolveproperties ) ; if ( xmldescriptor != null ) { deploymentunit . putattachment ( ironjacamarxmldescriptor . attachment_key , xmldescriptor ) ; } }	Process a deployment for iron-jacamar.xml files.
@ override public void handlerequest ( httpserverexchange exchange ) throws exception { runningcount . increment ( ) ; exchange . addexchangecompletelistener ( new exchangecompletionlistener ( ) { @ override public void exchangeevent ( httpserverexchange exchange , nextlistener nextlistener ) { runningcount . decrement ( ) ;	Increments the counter and registers a listener to decrement the counter upon exchange complete event.
private boolean isintransaction ( ) { transactionsynchronizationregistry tsr = gettransactionsynchronizationregistry ( ) ; boolean intx = tsr . gettransactionstatus ( ) == status . status_active ; return intx ; }	check whether there is an active transaction.
private transactionsynchronizationregistry gettransactionsynchronizationregistry ( ) { transactionsynchronizationregistry cachedtsr = transactionsynchronizationregistry ; if ( cachedtsr == null ) { cachedtsr = ( transactionsynchronizationregistry ) lookup ( transaction_synchronization_registry_lookup ) ; transactionsynchronizationregistry = cachedtsr ; } return cachedtsr ; }	lookup the transactionSynchronizationRegistry and cache it.
private connectionfactory getconnectionfactory ( ) { connectionfactory cachedcf = connectionfactory ; if ( cachedcf == null ) { cachedcf = ( connectionfactory ) lookup ( info . getconnectionfactorylookup ( ) ) ; connectionfactory = cachedcf ; } return cachedcf ; }	lookup the connectionFactory and cache it.
public static string getlastcomponent ( final name name ) { if ( name . size ( ) > num_ ) return name . get ( name . size ( ) - num_ ) ; return str_ ; }	Get the last component of a name.
public static boolean isempty ( final name name ) { return name . isempty ( ) || ( name . size ( ) == num_ && str_ . equals ( name . get ( num_ ) ) ) ; }	Determine if a name is empty, or if ot contains only one component which is the empty string.
public static namenotfoundexception namenotfoundexception ( final string name , final name contextname ) { return naminglogger . root_logger . namenotfoundincontext ( name , contextname ) ; }	Create a name-not-found exception.
public static namingexception namingexception ( final string message , final throwable cause ) { final namingexception exception = new namingexception ( message ) ; if ( cause != null ) exception . initcause ( cause ) ; return exception ; }	Return a general naming exception with a root cause.
public static namingexception namingexception ( final string message , final throwable cause , final name remainingname ) { final namingexception exception = namingexception ( message , cause ) ; exception . setremainingname ( remainingname ) ; return exception ; }	Return a general naming exception with a root cause and a remaining name field.
public static cannotproceedexception cannotproceedexception ( final object resolvedobject , final name remainingname ) { final cannotproceedexception cpe = new cannotproceedexception ( ) ; cpe . setresolvedobj ( resolvedobject ) ; cpe . setremainingname ( remainingname ) ; return cpe ; }	Return a cannot-proceed exception.
public static < t > namingenumeration < t > namingenumeration ( final collection < t > collection ) { final iterator < t > iterator = collection . iterator ( ) ; return new namingenumeration < t > ( ) { public t next ( ) { return nextelement ( ) ; } public boolean hasmore ( ) { return hasmoreelements ( ) ; } public void close ( ) { } public boolean hasmoreelements ( ) { return iterator . hasnext ( ) ; } public t nextelement ( ) { return iterator . next ( ) ; } } ; }	Return a naming enumeration over a collection.
public static void rebind ( final context ctx , final string name , final object value ) throws namingexception { final name n = ctx . getnameparser ( str_ ) . parse ( name ) ; rebind ( ctx , n , value ) ; }	Rebind val to name in ctx, and make sure that all intermediate contexts exist.
protected final t getactivemqcomponentcontrol ( final operationcontext context , final modelnode operation , final boolean forwrite ) throws operationfailedexception { final servicename artemisservicename = messagingservices . getactivemqservicename ( pathaddress . pathaddress ( operation . get ( modeldescriptionconstants . op_addr ) ) ) ; servicecontroller < ? > artemisservice = context . getserviceregistry ( forwrite ) . getservice ( artemisservicename ) ; activemqserver server = activemqserver . class . cast ( artemisservice . getvalue ( ) ) ; pathaddress address = pathaddress . pathaddress ( operation . require ( op_addr ) ) ; t control = getactivemqcomponentcontrol ( server , address ) ; if ( control == null ) { throw controllerlogger . root_logger . managementresourcenotfound ( address ) ; } return control ; }	Gets the runtime ActiveMQ control object that can help service this request.
public componentinstance createinstance ( object instance ) { basiccomponentinstance obj = constructcomponentinstance ( new immediatemanagedreference ( instance ) , bool_ ) ; obj . constructionfinished ( ) ; return obj ; }	Wraps an existing object instance in a ComponentInstance, and run the post construct interceptor chain on it.
protected synchronized virtualfile getresteasyspringvirtualfile ( ) throws deploymentunitprocessingexception { if ( resourceroot != null ) { return resourceroot ; } try { module module = module . getbootmoduleloader ( ) . loadmodule ( module ) ; url fileurl = module . getclassloader ( ) . getresource ( jar_location ) ; if ( fileurl == null ) { throw jaxrslogger . jaxrs_logger . nospringintegrationjar ( ) ; } file dir = new file ( fileurl . touri ( ) ) ; file file = null ; for ( string jar : dir . list ( ) ) { if ( jar . endswith ( str_ ) ) { file = new file ( dir , jar ) ; break ; } } if ( file == null ) { throw jaxrslogger . jaxrs_logger . nospringintegrationjar ( ) ; } virtualfile vf = vfs . getchild ( file . touri ( ) ) ; final closeable mounthandle = vfs . mountzip ( file , vf , tempfileproviderservice . provider ( ) ) ; service < closeable > mounthandleservice = new service < closeable > ( ) { public void start ( startcontext startcontext ) throws startexception { } public void stop ( stopcontext stopcontext ) { vfsutils . safeclose ( mounthandle ) ; } public closeable getvalue ( ) throws illegalstateexception , illegalargumentexception { return mounthandle ; } } ; servicebuilder < closeable > builder = servicetarget . addservice ( servicename . jboss . append ( service_name ) , mounthandleservice ) ; builder . setinitialmode ( servicecontroller . mode . active ) . install ( ) ; resourceroot = vf ; return resourceroot ; } catch ( exception e ) { throw new deploymentunitprocessingexception ( e ) ; } }	Lookup Seam integration resource loader.
protected static string resolveruntimename ( final operationcontext context , final pathelement address ) { final modelnode runtimename = context . readresourcefromroot ( pathaddress . pathaddress ( address ) , bool_ ) . getmodel ( ) . get ( modeldescriptionconstants . runtime_name ) ; return runtimename . asstring ( ) ; }	Resolves runtime name of model resource.
private static persistentresourcexmldescription . persistentresourcexmlbuilder listenerbuilder ( persistentresourcedefinition resource ) { return builder ( resource . getpathelement ( ) )	Registers attributes common across listener types.
public static primitiveanalysis getprimitiveanalysis ( final class cls ) { if ( cls == null ) throw iioplogger . root_logger . cannotanalyzenullclass ( ) ; if ( cls == void . type ) return voidanalysis ; if ( cls == boolean . type ) return booleananalysis ; if ( cls == character . type ) return charanalysis ; if ( cls == byte . type ) return byteanalysis ; if ( cls == short . type ) return shortanalysis ; if ( cls == integer . type ) return intanalysis ; if ( cls == long . type ) return longanalysis ; if ( cls == float . type ) return floatanalysis ; if ( cls == double . type ) return doubleanalysis ; throw iioplogger . root_logger . notaprimitive ( cls . getname ( ) ) ; }	Get a singleton instance representing one of the primitive types.
public void shutdown ( ) { int value ; int oldvalue ;	Upon calling this method the EJB will be set to a shutdown state, and no further invocations will be allowed.It will then wait for all active invocation to finish and then return.
public static list < string > geturlpatterns ( final string urlpattern ) { final list < string > linkedlist = new linkedlist < string > ( ) ; linkedlist . add ( urlpattern ) ; return linkedlist ; }	Creates URL pattern list from passed string.
public static jbossservletsmetadata getservlets ( final jbosswebmetadata jbosswebmd ) { jbossservletsmetadata servletsmd = jbosswebmd . getservlets ( ) ; if ( servletsmd == null ) { servletsmd = new jbossservletsmetadata ( ) ; jbosswebmd . setservlets ( servletsmd ) ; } return servletsmd ; }	Gets servlets meta data from jboss web meta data.
public static list < servletmappingmetadata > getservletmappings ( final jbosswebmetadata jbosswebmd ) { list < servletmappingmetadata > servletmappingsmd = jbosswebmd . getservletmappings ( ) ; if ( servletmappingsmd == null ) { servletmappingsmd = new linkedlist < servletmappingmetadata > ( ) ; jbosswebmd . setservletmappings ( servletmappingsmd ) ; } return servletmappingsmd ; }	Gets servlet mappings meta data from jboss web meta data.
public static list < securityconstraintmetadata > getsecurityconstraints ( final jbosswebmetadata jbosswebmd ) { list < securityconstraintmetadata > securityconstraintsmd = jbosswebmd . getsecurityconstraints ( ) ; if ( securityconstraintsmd == null ) { securityconstraintsmd = new linkedlist < securityconstraintmetadata > ( ) ; jbosswebmd . setsecurityconstraints ( securityconstraintsmd ) ; } return securityconstraintsmd ; }	Gets security constraints meta data from jboss web meta data.
public static loginconfigmetadata getloginconfig ( final jbosswebmetadata jbosswebmd ) { loginconfigmetadata loginconfigmd = jbosswebmd . getloginconfig ( ) ; if ( loginconfigmd == null ) { loginconfigmd = new loginconfigmetadata ( ) ; jbosswebmd . setloginconfig ( loginconfigmd ) ; } return loginconfigmd ; }	Gets login config meta data from jboss web meta data.
public static list < paramvaluemetadata > getcontextparams ( final jbosswebmetadata jbosswebmd ) { list < paramvaluemetadata > contextparamsmd = jbosswebmd . getcontextparams ( ) ; if ( contextparamsmd == null ) { contextparamsmd = new linkedlist < paramvaluemetadata > ( ) ; jbosswebmd . setcontextparams ( contextparamsmd ) ; } return contextparamsmd ; }	Gets context parameters meta data from jboss web meta data.
public static webresourcecollectionsmetadata getwebresourcecollections ( final securityconstraintmetadata securityconstraintmd ) { webresourcecollectionsmetadata webresourcecollectionsmd = securityconstraintmd . getresourcecollections ( ) ; if ( webresourcecollectionsmd == null ) { webresourcecollectionsmd = new webresourcecollectionsmetadata ( ) ; securityconstraintmd . setresourcecollections ( webresourcecollectionsmd ) ; } return webresourcecollectionsmd ; }	Gets web resource collections meta data from security constraint meta data.
public static list < paramvaluemetadata > getservletinitparams ( final servletmetadata servletmd ) { list < paramvaluemetadata > initparamsmd = servletmd . getinitparam ( ) ; if ( initparamsmd == null ) { initparamsmd = new linkedlist < paramvaluemetadata > ( ) ; servletmd . setinitparam ( initparamsmd ) ; } return initparamsmd ; }	Gets init parameters meta data from servlet meta data.
public static securityconstraintmetadata newsecurityconstraint ( final list < securityconstraintmetadata > securityconstraintsmd ) { final securityconstraintmetadata securityconstraintmd = new securityconstraintmetadata ( ) ; securityconstraintsmd . add ( securityconstraintmd ) ; return securityconstraintmd ; }	Creates new security constraint meta data and associates them with security constraints meta data.
public static webresourcecollectionmetadata newwebresourcecollection ( final string servletname , final string urlpattern , final boolean securedwsdl , final webresourcecollectionsmetadata webresourcecollectionsmd ) { final webresourcecollectionmetadata webresourcecollectionmd = new webresourcecollectionmetadata ( ) ; webresourcecollectionmd . setwebresourcename ( servletname ) ; webresourcecollectionmd . seturlpatterns ( webmetadatahelper . geturlpatterns ( urlpattern ) ) ; webresourcecollectionmd . sethttpmethods ( webmetadatahelper . gethttpmethods ( securedwsdl ) ) ; webresourcecollectionsmd . add ( webresourcecollectionmd ) ; return webresourcecollectionmd ; }	Creates new web resource collection meta data and associates them with web resource collections meta data.
public static jbossservletmetadata newservlet ( final string servletname , final string servletclass , final jbossservletsmetadata servletsmd ) { final jbossservletmetadata servletmd = new jbossservletmetadata ( ) ; servletmd . setservletname ( servletname ) ; servletmd . setservletclass ( servletclass ) ; servletsmd . add ( servletmd ) ; return servletmd ; }	Creates new servlet meta data and associates them with servlets meta data.
public static servletmappingmetadata newservletmapping ( final string servletname , final list < string > urlpatterns , final list < servletmappingmetadata > servletmappingsmd ) { final servletmappingmetadata servletmappingmd = new servletmappingmetadata ( ) ; servletmappingmd . setservletname ( servletname ) ; servletmappingmd . seturlpatterns ( urlpatterns ) ; servletmappingsmd . add ( servletmappingmd ) ; return servletmappingmd ; }	Creates new servlet mapping meta data and associates them with servlet mappings meta data.
public static authconstraintmetadata newauthconstraint ( final list < string > rolenames , final securityconstraintmetadata securityconstraintmd ) { final authconstraintmetadata authconstraintmd = new authconstraintmetadata ( ) ; authconstraintmd . setrolenames ( rolenames ) ; securityconstraintmd . setauthconstraint ( authconstraintmd ) ; return authconstraintmd ; }	Creates new authentication constraint and associates it with security constraint meta data.
public static userdataconstraintmetadata newuserdataconstraint ( final string transportguarantee , final securityconstraintmetadata securityconstraintmd ) { final userdataconstraintmetadata userdataconstraintmd = new userdataconstraintmetadata ( ) ; final transportguaranteetype transportguaranteevalue = transportguaranteetype . valueof ( transportguarantee ) ; userdataconstraintmd . settransportguarantee ( transportguaranteevalue ) ; securityconstraintmd . setuserdataconstraint ( userdataconstraintmd ) ; return userdataconstraintmd ; }	Creates new user constraint meta data and associates it with security constraint meta data.
public static paramvaluemetadata newparamvalue ( final string key , final string value , final list < paramvaluemetadata > paramsmd ) { final paramvaluemetadata paramvaluemd = webmetadatahelper . newparamvalue ( key , value ) ; paramsmd . add ( paramvaluemd ) ; return paramvaluemd ; }	Creates new parameter meta data and associates it with parameters meta data.
private static paramvaluemetadata newparamvalue ( final string key , final string value ) { final paramvaluemetadata parammd = new paramvaluemetadata ( ) ; parammd . setparamname ( key ) ; parammd . setparamvalue ( value ) ; return parammd ; }	Creates new parameter with specified key and value.
private void registersessionbeaninterceptors ( sessionbeancomponentdescription componentdescription , final deploymentunit deploymentunit ) {	Register our listeners on SFSB that will be created.
@ override public void stop ( final stopcontext context ) { final weldbootstrapservice bootstrapservice = bootstrapsupplier . get ( ) ; if ( ! bootstrapservice . isstarted ( ) ) { throw weldlogger . root_logger . notstarted ( str_ ) ; } weldlogger . deployment_logger . stoppingweldservice ( bootstrapservice . getdeploymentname ( ) ) ; classloader oldtccl = wildflysecuritymanager . getcurrentcontextclassloaderprivileged ( ) ; try { wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( bootstrapservice . getdeployment ( ) . getmodule ( ) . getclassloader ( ) ) ; weldprovider . containershutdown ( container . instance ( bootstrapservice . getdeploymentname ( ) ) ) ; bootstrapservice . getbootstrap ( ) . shutdown ( ) ; } finally { wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( oldtccl ) ; modulegroupsingletonprovider . removeclassloader ( bootstrapservice . getdeployment ( ) . getmodule ( ) . getclassloader ( ) ) ; } bootstrapservice . setstarted ( bool_ ) ; }	Stops the containerExecuted in WeldStartService to shutdown the runtime before NamingService is closed.
public static string getjndiname ( final operationcontext context , final modelnode modelnode ) throws operationfailedexception { final string rawjndiname = jndi_name . resolvemodelattribute ( context , modelnode ) . asstring ( ) ; return cleanjndiname ( rawjndiname , modelnode . hasdefined ( use_java_context . getname ( ) ) && modelnode . get ( use_java_context . getname ( ) ) . asboolean ( ) ) ; }	Extracts the raw JNDINAME value from the given model node, and depending on the value andthe value of any USE_JAVA_CONTEXT child node, converts the raw name into a compliant jndi name.
private string resolveattribute ( simpleattributedefinition attr , operationcontext context , modelnode model ) throws operationfailedexception { final modelnode node = attr . resolvemodelattribute ( context , model ) ; return node . isdefined ( ) ? node . asstring ( ) : null ; }	Return null if the resolved attribute is not defined.
static int getpatterntype ( string urlpattern ) { int type = exact ; if ( urlpattern . startswith ( str_ ) ) type = extension ; else if ( urlpattern . startswith ( str_ ) && urlpattern . endswith ( str_ ) ) type = prefix ; else if ( urlpattern . equals ( str_ ) ) type = default ; return type ; }	Determine the url-pattern type.
static boolean targetspooledconnectionfactory ( string server , string resourceadapter , serviceregistry serviceregistry ) {	Return whether the definition targets an existing pooled connection factory or use a JCA-based ConnectionFactory.Checks the service registry for a PooledConnectionFactoryService with the ServiceNamecreated by the {.
static boolean targetsexternalpooledconnectionfactory ( string resourceadapter , serviceregistry serviceregistry ) {	Return whether the definition targets an existing external pooled connection factory.Checks the service registry for a PooledConnectionFactoryService with the ServiceNamecreated by the {.
static string getactivemqservername ( map < string , string > properties ) { return properties . getordefault ( server , default ) ; }	The JMS connection factory can specify another server to deploy its destinationsby passing a property server=&lt;name of the server>.
private static string defaultpersistenceunitname ( string persistenceunitname , persistenceunitmetadataholder holder ) { if ( ( persistenceunitname == null || persistenceunitname . length ( ) == num_ ) ) { for ( persistenceunitmetadata persistenceunit : holder . getpersistenceunits ( ) ) { string defaultpu = persistenceunit . getproperties ( ) . getproperty ( configuration . jpa_default_persistence_unit ) ; if ( boolean . true . tostring ( ) . equals ( defaultpu ) ) { persistenceunitname = persistenceunit . getpersistenceunitname ( ) ; } } } return persistenceunitname ; }	if no persistence unit name is specified, return name of default persistence unit.
public void start ( startcontext context ) { final suspendcontroller suspendcontroller = suspendcontrollerinjectedvalue . getvalue ( ) ; suspendcontroller . registeractivity ( this ) ; final localtransactioncontext localtransactioncontext = localtransactioncontextinjectedvalue . getvalue ( ) ; localtransactioncontext . registercreationlistener ( this ) ; }	Starts the service. Registers server activity, sets transaction listener on local transaction context, and creates andinstalls deployment controller service.
public void stop ( stopcontext context ) { final suspendcontroller suspendcontroller = suspendcontrollerinjectedvalue . getvalue ( ) ; suspendcontroller . unregisteractivity ( this ) ; final localtransactioncontext localtransactioncontext = localtransactioncontextinjectedvalue . getvalue ( ) ; localtransactioncontext . removecreationlistener ( this ) ; }	Stops the service. Unregisters service activity and clears transaction listener.
@ override public void suspended ( serveractivitycallback listener ) { this . suspended = bool_ ; listenerupdater . set ( this , listener ) ; localtransactioncontextinjectedvalue . getvalue ( ) . suspendrequests ( ) ; final int activeinvocationcount = activeinvocationcountupdater . get ( this ) ; if ( activeinvocationcount == num_ ) { if ( gracefultxnshutdown ) { if ( activetransactioncountupdater . get ( this ) == num_ ) { this . donesuspended ( ) ; } else { ejblogger . root_logger . suspensionwaitingactivetransactions ( activeinvocationcount ) ; } } else { this . donesuspended ( ) ; } } }	Notifies local transaction context that server is suspended, and only completes suspension ifthere are no active invocations nor transactions.
@ override public void resume ( ) { this . suspended = bool_ ; localtransactioncontextinjectedvalue . getvalue ( ) . resumerequests ( ) ; serveractivitycallback listener = listenerupdater . get ( this ) ; if ( listener != null ) { listenerupdater . compareandset ( this , listener , null ) ; } deploymentrepositoryinjectedvalue . getvalue ( ) . resume ( ) ; }	Notifies local transaction context that server is resumed, and restarts deployment controller.
public void invocationcomplete ( ) { int activeinvocations = activeinvocationcountupdater . decrementandget ( this ) ; if ( suspended && activeinvocations == num_ && ( ! gracefultxnshutdown || ( activetransactioncountupdater . get ( this ) == num_ ) ) ) { donesuspended ( ) ; } }	Notifies handler that an active invocation is complete.
@ override public void transactioncreated ( abstracttransaction transaction , createdby createdby ) { activetransactioncountupdater . incrementandget ( this ) ; try { transaction . registersynchronization ( this ) ; } catch ( rollbackexception | illegalstateexception e ) {	Notifies handler that a new transaction has been created.
public void start ( startcontext context ) throws startexception { final servicebasednamingstore namingstore = namingstorevalue . getvalue ( ) ; controller = context . getcontroller ( ) ; namingstore . add ( controller . getname ( ) ) ; root_logger . tracef ( str_ , name , namingstore , controller . getname ( ) ) ; }	Bind the entry into the injected context.
public void stop ( stopcontext context ) { final servicebasednamingstore namingstore = namingstorevalue . getvalue ( ) ; namingstore . remove ( controller . getname ( ) ) ; root_logger . tracef ( str_ , name , namingstore , context . getcontroller ( ) . getname ( ) ) ; }	Unbind the entry from the injected context.
public static servicename getcapabilityservicename ( string capabilitybasename , string ... dynamicparts ) { if ( capabilityservicesupport == null ) { throw new illegalstateexception ( ) ; } if ( dynamicparts == null || dynamicparts . length == num_ ) { return capabilityservicesupport . getcapabilityservicename ( capabilitybasename ) ; } return capabilityservicesupport . getcapabilityservicename ( capabilitybasename , dynamicparts ) ; }	Determines a ServiceName from a capability name.
private list < resourceroot > createresourceroots ( final virtualfile deploymentroot , final deploymentunit deploymentunit ) throws ioexception , deploymentunitprocessingexception { final list < resourceroot > entries = new arraylist < resourceroot > ( ) ;	Create the resource roots for a .war deployment.
private static set < classloader > alldeploymentmoduleclassloaders ( deploymentunit deploymentunit ) { set < classloader > deploymentclassloaders = new hashset < classloader > ( ) ; final deploymentunit topdeploymentunit = deploymentutils . gettopdeploymentunit ( deploymentunit ) ; final module toplevelmodule = topdeploymentunit . getattachment ( attachments . module ) ; if ( toplevelmodule != null ) { deploymentclassloaders . add ( toplevelmodule . getclassloader ( ) ) ; final list < deploymentunit > subdeployments = topdeploymentunit . getattachmentlist ( attachments . sub_deployments ) ; for ( deploymentunit subdeploymentunit : subdeployments ) { final module subdeploymentmodule = subdeploymentunit . getattachment ( attachments . module ) ; if ( subdeploymentmodule != null ) { deploymentclassloaders . add ( subdeploymentmodule . getclassloader ( ) ) ; } } } return deploymentclassloaders ; }	returns the toplevel deployment module classloader and all subdeployment classloaders.
public static boolean needclassfiletransformer ( persistenceunitmetadata pu ) { boolean result = bool_ ; string provider = pu . getpersistenceproviderclassname ( ) ; if ( pu . getproperties ( ) . containskey ( configuration . jpa_container_class_transformer ) ) { result = boolean . parseboolean ( pu . getproperties ( ) . getproperty ( configuration . jpa_container_class_transformer ) ) ; } else if ( ishibernateprovider ( provider ) ) { result = ( boolean . true . tostring ( ) . equals ( pu . getproperties ( ) . getproperty ( hibernate_use_class_enhancer ) ) || boolean . true . tostring ( ) . equals ( pu . getproperties ( ) . getproperty ( hibernate_enable_dirty_tracking ) ) || boolean . true . tostring ( ) . equals ( pu . getproperties ( ) . getproperty ( hibernate_enable_lazy_initialization ) ) || boolean . true . tostring ( ) . equals ( pu . getproperties ( ) . getproperty ( hibernate_enable_association_management ) ) ) ; } return result ; }	Determine if class file transformer is needed for the specified persistence unitif the persistence provider is Hibernate and use_class_enhancer is not true, don't need a class transformer.for other persistence providers, the transformer is assumed to be needed.
public static boolean allowtwophasebootstrap ( persistenceunitmetadata pu ) { boolean result = bool_ ; if ( ee_default_datasource . equals ( pu . getjtadatasourcename ( ) ) ) { result = bool_ ; } if ( pu . getproperties ( ) . containskey ( configuration . jpa_allow_two_phase_bootstrap ) ) { result = boolean . parseboolean ( pu . getproperties ( ) . getproperty ( configuration . jpa_allow_two_phase_bootstrap ) ) ; } return result ; }	Determine if two phase persistence unit start is allowed.
public static boolean allowdefaultdatasourceuse ( persistenceunitmetadata pu ) { boolean result = bool_ ; if ( pu . getproperties ( ) . containskey ( configuration . jpa_allow_default_data_source_use ) ) { result = boolean . parseboolean ( pu . getproperties ( ) . getproperty ( configuration . jpa_allow_default_data_source_use ) ) ; } return result ; }	Determine if the default data-source should be used.
public static boolean skipmixedsynchronizationtypecheck ( entitymanagerfactory emf , map targetentitymanagerproperties ) { boolean result = bool_ ;	Allow the mixed synchronization checking to be skipped for backward compatibility with WildFly 10.1.0.
public static orb getorb ( string server , int port , hashtable env ) {	Get ORB using given server and port number, and properties from environment.
private static orb initappletorb ( object applet , properties orbprop ) { try { class < ? > appletclass = class . forname ( str_ , bool_ , null ) ; if ( ! appletclass . isinstance ( applet ) ) { throw new classcastexception ( applet . getclass ( ) . getname ( ) ) ; }	This method returns a new ORB instance for the given appletwithout creating a static dependency on java.applet.
private static void initmethodhandles ( ) throws classnotfoundexception {	Initializes reflection method handles for RMI-IIOP.
public static void setactivenamingstore ( final namingstore namingstore ) { if ( wildflysecuritymanager . ischecking ( ) ) { system . getsecuritymanager ( ) . checkpermission ( set_active_naming_store ) ; } active_naming_store = namingstore ; }	Set the active naming store.
private void validatedefaultvalues ( list < paramdetail > detaillist , hashmap < string , list < validator > > paramconvertermap ) throws deploymentunitprocessingexception { for ( paramdetail detail : detaillist ) {	Process all parameter DefaulValue objects.
private class checkparamtype ( type genparamtype , final method method , final int parampos , final classloader classloader ) { class paramclazz = null ; if ( genparamtype instanceof parameterizedtype ) { parameterizedtype ptype = ( parameterizedtype ) genparamtype ; type [ ] actualtypeargs = ptype . getactualtypearguments ( ) ;	Take steps to properly identify the parameter's data type.
private defaultvalue lookupdefaultvalueann ( annotation [ ] annotationarr ) { for ( annotation ann : annotationarr ) { if ( ann instanceof defaultvalue ) { return ( defaultvalue ) ann ; } } return null ; }	Extract a DefaultValue annotation from the list of parameter annotations.
private void validatebasetype ( method method , string defaultvalue , paramdetail detail ) throws deploymentunitprocessingexception { if ( defaultvalue != null ) { try { method . invoke ( method . getdeclaringclass ( ) , defaultvalue ) ; } catch ( exception e ) { jaxrs_logger . basetypemethodfailed ( defaultvalue , detail . parameter . getsimplename ( ) , detail . method . tostring ( ) , method . tostring ( ) , e . getclass ( ) . getname ( ) , e . getmessage ( ) ) ; } } }	Confirm the method can handle the default value without throwingand exception.
public static extendedentitymanager [ ] getdeferredentitymanagers ( ) { list < extendedentitymanager > store = defertopostconstruct . get ( ) ; try { if ( store . isempty ( ) ) { return empty ; } else { return store . toarray ( new extendedentitymanager [ store . size ( ) ] ) ; } } finally { store . clear ( ) ; } }	Called by postconstruct interceptor.
public static string statusasstring ( int status ) { if ( status >= status . status_active && status <= status . status_rolling_back ) { return txstatusstrings [ status ] ; } else { return str_ + status + str_ ; } }	Converts a tx Status index to a String.
public static void addcachedependencies ( classification cachetype , properties properties ) { for ( eventlistener eventlistener : eventlisteners ) { eventlistener . addcachedependencies ( cachetype , properties ) ; } }	add cache dependencies.
private void extractdialects ( ) { for ( object prop : sql . keyset ( ) ) { int dot = ( ( string ) prop ) . indexof ( str_ ) ; if ( dot > num_ ) { databasedialects . add ( ( ( string ) prop ) . substring ( dot + num_ ) ) ; } } }	Read the properties from the timer-sql and extract the database dialects.
private void investigatedialect ( ) { connection connection = null ; if ( database == null ) {	Check the connection MetaData and driver name to guess which database dialectto use.
private string identifydialect ( string name ) { string unified = null ; if ( name != null ) { if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) || name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } else if ( name . tolowercase ( ) . contains ( str_ ) ) { unified = str_ ; } } ejblogger . ejb3_timer_logger . debugf ( str_ , name , unified ) ; return unified ; }	Use the given name and check for different database types to have a unified identifier for the dialect.
private void checkdatabase ( ) { string loadtimer = sql ( load_timer ) ; connection connection = null ; statement statement = null ; preparedstatement preparedstatement = null ; resultset resultset = null ; try {	Checks whether the database transaction configuration is appropriateand create the timer table if necessary.
private date stringasschedulerdate ( final string date , final string timerid ) { if ( date == null ) { return null ; } try { return new simpledateformat ( scheduler_date_format ) . parse ( date ) ; } catch ( parseexception e ) { ejblogger . ejb3_timer_logger . scheduleexpressiondatefromtimerpersistenceinvalid ( timerid , e . getmessage ( ) ) ; return null ; } }	Convert the stored date-string from database back to Date.
private void setnodename ( final timerstate timerstate , preparedstatement statement , int paramindex ) throws sqlexception { if ( timerstate == timerstate . in_timeout || timerstate == timerstate . retry_timeout ) { statement . setstring ( paramindex , nodename ) ; } else { statement . setnull ( paramindex , types . varchar ) ; } }	Set the node name for persistence if the state is IN_TIMEOUT or RETRY_TIMEOUT to show which node is current active for the timer.
public static void mark ( deploymentunit unit ) { unit . putattachment ( marker , boolean . true ) ; if ( unit . getparent ( ) != null ) { mark ( unit . getparent ( ) ) ; } }	Mark this deployment and the top level deployment as being a weld deployment.
public object [ ] readparams ( inputstream in ) { int len = paramreaders . length ; object [ ] params = new object [ len ] ; for ( int i = num_ ; i < len ; i ++ ) { params [ i ] = paramreaders [ i ] . read ( in ) ; } return params ; }	Unmarshals the sequence of method parameters from an input stream.
public void writeretval ( outputstream out , object retval ) { retvalwriter . write ( out , remoteobjectsubstitutionmanager . writereplaceremote ( retval ) ) ; }	Marshals into an output stream the return value of the method.
public void writeexception ( outputstream out , throwable e ) { int len = excepwriters . length ; for ( int i = num_ ; i < len ; i ++ ) { if ( excepwriters [ i ] . getexceptionclass ( ) . isinstance ( e ) ) { excepwriters [ i ] . write ( out , e ) ; return ; } } throw new unknownexception ( e ) ; }	Marshals into an output stream an exception thrown by the method.
protected < u > u lookup ( lookup < u > lookup , int start , int depth ) { int size ; synchronized ( indexes ) { size = indexes . size ( ) ; for ( int i = start ; i < depth && i < size ; i ++ ) { u result = lookup . lookup ( indexes . get ( i ) ) ; if ( result != null ) return result ; } } if ( currentclass == null ) return null ; synchronized ( indexes ) { classreflectionindex cri = index . getclassindex ( currentclass ) ; indexes . add ( cri ) ; currentclass = currentclass . getsuperclass ( ) ; } return lookup ( lookup , size , depth ) ; }	Do lazy lookup.
public static void beginsfsbcreation ( ) { sfsbcallstackthreaddata data = current . get ( ) ; int no = data . creationbeannestinglevel ; if ( no == num_ ) { data . creationtimexpcregistration = new hashmap < string , extendedentitymanager > ( ) ;	called from SFSBPreCreateInterceptor, before bean creation.
public static void endsfsbcreation ( ) { sfsbcallstackthreaddata data = current . get ( ) ; int no = data . creationbeannestinglevel ; no -- ; data . creationbeannestinglevel = no ; if ( no == num_ ) {	called from SFSBPreCreateInterceptor, after bean creation.
public static map < string , extendedentitymanager > currentsfsbcallstackinvocation ( ) { arraylist < map < string , extendedentitymanager > > stack = current . get ( ) . invocationstack ; if ( stack != null && stack . size ( ) > num_ ) { return stack . get ( stack . size ( ) - num_ ) ; } return null ; }	return for just the current entity manager invocation.
public static void pushcall ( map < string , extendedentitymanager > entitymanagers ) { currentsfsbcallstack ( ) . add ( entitymanagers ) ; if ( entitymanagers != null ) { for ( extendedentitymanager extendedentitymanager : entitymanagers . values ( ) ) { extendedentitymanager . internalassociatewithjtatx ( ) ; } } }	Push the passed SFSB context handle onto the invocation call stack.
public static map < string , extendedentitymanager > popcall ( ) { arraylist < map < string , extendedentitymanager > > stack = currentsfsbcallstack ( ) ; map < string , extendedentitymanager > result = stack . remove ( stack . size ( ) - num_ ) ; stack . trimtosize ( ) ; return result ; }	Pops the current SFSB invocation off the invocation call stack.
static map < string , extendedentitymanager > getcurrentcall ( ) { arraylist < map < string , extendedentitymanager > > stack = currentsfsbcallstack ( ) ; map < string , extendedentitymanager > result = null ; if ( stack != null ) { result = stack . get ( stack . size ( ) - num_ ) ; } return result ; }	gets the current SFSB invocation off the invocation call stack.
public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final modulespecification modulespecification = deploymentunit . getattachment ( attachments . module_specification ) ; final moduleloader moduleloader = module . getbootmoduleloader ( ) ; adddependency ( modulespecification , moduleloader , javax_enterprise_api ) ; adddependency ( modulespecification , moduleloader , javax_inject_api ) ; if ( ! welddeploymentmarker . ispartofwelddeployment ( deploymentunit ) ) { return ;	Add dependencies for modules required for weld deployments, if managed weld configurations are attached to the deployment.
public static string gettypeidlname ( class cls ) throws rmiiiopviolationexception { if ( cls . isprimitive ( ) ) return primitiveanalysis . getprimitiveanalysis ( cls ) . getidlname ( ) ; if ( cls . isarray ( ) ) {	Return the IDL type name for the given class.Here we use the mapping for parameter types and return values.
public static void insertanyprimitive ( any any , object primitive ) { class type = primitive . getclass ( ) ; if ( type == boolean . class ) any . insert_boolean ( ( ( boolean ) primitive ) . booleanvalue ( ) ) ; else if ( type == character . class ) any . insert_wchar ( ( ( character ) primitive ) . charvalue ( ) ) ; else if ( type == byte . class ) any . insert_octet ( ( ( byte ) primitive ) . bytevalue ( ) ) ; else if ( type == short . class ) any . insert_short ( ( ( short ) primitive ) . shortvalue ( ) ) ; else if ( type == integer . class ) any . insert_long ( ( ( integer ) primitive ) . intvalue ( ) ) ; else if ( type == long . class ) any . insert_longlong ( ( ( long ) primitive ) . longvalue ( ) ) ; else if ( type == float . class ) any . insert_float ( ( ( float ) primitive ) . floatvalue ( ) ) ; else if ( type == double . class ) any . insert_double ( ( ( double ) primitive ) . doublevalue ( ) ) ; else throw iioplogger . root_logger . notaprimitive ( type . getname ( ) ) ; }	Insert a java primitive into an Any.The primitive is assumed to be wrapped in one of the primitivewrapper classes.
public static string javatoidlname ( string name ) { if ( name == null || str_ . equals ( name ) || name . indexof ( str_ ) != - num_ ) throw iioplogger . root_logger . namecannotbenullemptyorqualified ( ) ; stringbuffer res = new stringbuffer ( name . length ( ) ) ; if ( name . charat ( num_ ) == str_ ) res . append ( str_ ) ;	Map Java name to IDL name, as per sections 1.3.2.3, 1.3.2.4 and1.3.2.2.This only works for a single name component, without a qualifyingdot.
private static boolean isreservedidlkeyword ( string s ) {	Determine if the argument is a reserved IDL keyword.
private static string getsignature ( class cls ) { if ( cls . isarray ( ) ) return str_ + cls . getcomponenttype ( ) ; if ( cls . isprimitive ( ) ) { if ( cls == byte . type ) return str_ ; if ( cls == character . type ) return str_ ; if ( cls == double . type ) return str_ ; if ( cls == float . type ) return str_ ; if ( cls == integer . type ) return str_ ; if ( cls == long . type ) return str_ ; if ( cls == short . type ) return str_ ; if ( cls == boolean . type ) return str_ ; throw iioplogger . root_logger . unknownprimitivetype ( cls . getname ( ) ) ; } return str_ + cls . getname ( ) . replace ( str_ , str_ ) + str_ ; }	Calculate the signature of a class, according to the Java VMspecification, section 4.3.2.
private static string getsignature ( method method ) { stringbuffer b = new stringbuffer ( str_ ) ; class [ ] parametertypes = method . getparametertypes ( ) ; for ( int i = num_ ; i < parametertypes . length ; ++ i ) b . append ( getsignature ( parametertypes [ i ] ) ) ; b . append ( str_ ) . append ( getsignature ( method . getreturntype ( ) ) ) ; return b . tostring ( ) ; }	Calculate the signature of a method, according to the Java VMspecification, section 4.3.3.
static string primitivetypeidlname ( class type ) { if ( type == void . type ) return str_ ; if ( type == boolean . type ) return str_ ; if ( type == character . type ) return str_ ; if ( type == byte . type ) return str_ ; if ( type == short . type ) return str_ ; if ( type == integer . type ) return str_ ; if ( type == long . type ) return str_ ; if ( type == float . type ) return str_ ; if ( type == double . type ) return str_ ; throw iioplogger . root_logger . notaprimitive ( type . getname ( ) ) ; }	Handle mappings for primitive types, as per section 1.3.3.
public static batchpermission forname ( final string name ) { assert . checknotnullparam ( str_ , name ) ; return str_ . equals ( name ) ? allpermission : mapping . getitembystring ( name ) ; }	Get the permission with the given name.
private entitymanager getorcreatetransactionscopedentitymanager ( final entitymanagerfactory emf , final string scopedpuname , final map properties , final synchronizationtype synchronizationtype ) { entitymanager entitymanager = transactionutil . gettransactionscopedentitymanager ( puscopedname , transactionsynchronizationregistry ) ; if ( entitymanager == null ) { entitymanager = createentitymanager ( emf , properties , synchronizationtype ) ; if ( root_logger . isdebugenabled ( ) ) { root_logger . debugf ( str_ , transactionutil . getentitymanagerdetails ( entitymanager , scopedpuname ) , transactionutil . gettransaction ( transactionmanager ) . tostring ( ) ) ; } transactionutil . registersynchronization ( entitymanager , scopedpuname , transactionsynchronizationregistry , transactionmanager ) ; transactionutil . putentitymanagerintransactionregistry ( scopedpuname , entitymanager , transactionsynchronizationregistry ) ; } else { testformixedsynchronizationtypes ( emf , entitymanager , puscopedname , synchronizationtype , properties ) ; if ( root_logger . isdebugenabled ( ) ) { root_logger . debugf ( str_ , transactionutil . getentitymanagerdetails ( entitymanager , scopedpuname ) , transactionutil . gettransaction ( transactionmanager ) . tostring ( ) ) ; } } return entitymanager ; }	get or create a Transactional entity manager.Only call while a transaction is active in the current thread.
public v put ( k key , v value ) { if ( value == null ) throw new nullpointerexception ( ) ; int hash = hashof ( key ) ; return segmentfor ( hash ) . put ( key , hash , value , bool_ ) ; }	Maps the specified key to the specified value in this table.Neither the key nor the value can be null.
static modelnode convertsecurityrole ( final modelnode camelcase ) { final modelnode result = new modelnode ( ) ; result . setemptylist ( ) ; if ( camelcase . isdefined ( ) ) { for ( modelnode role : camelcase . aslist ( ) ) { final modelnode rolenode = result . add ( ) ; for ( property prop : role . aspropertylist ( ) ) { string key = prop . getname ( ) ; if ( str_ . equals ( key ) ) { key = securityroledefinition . create_durable_queue . getname ( ) ; } else if ( str_ . equals ( key ) ) { key = securityroledefinition . delete_durable_queue . getname ( ) ; } else if ( str_ . equals ( key ) ) { key = securityroledefinition . create_non_durable_queue . getname ( ) ; } else if ( str_ . equals ( key ) ) { key = securityroledefinition . delete_non_durable_queue . getname ( ) ; } rolenode . get ( key ) . set ( prop . getvalue ( ) ) ; } } } return result ; }	Utility for converting camel case based ActiveMQ formats to WildFly standards.
private timerimpl mostrecententityversion ( final timerimpl timerimpl ) { try { final int status = contexttransactionmanager . getinstance ( ) . getstatus ( ) ; if ( status == status . status_unknown || status == status . status_no_transaction ) { return timerimpl ; } final string key = timertransactionkey ( timerimpl ) ; timerimpl existing = ( timerimpl ) transactionsynchronizationregistry . getvalue ( ) . getresource ( key ) ; return existing != null ? existing : timerimpl ; } catch ( systemexception e ) { throw new runtimeexception ( e ) ; } }	Returns either the loaded entity or the most recent version of the entity that hasbeen persisted in this transaction.
private map < string , timerimpl > gettimers ( final string timedobjectid , final timerserviceimpl timerservice ) { return loadtimersfromfile ( timedobjectid , timerservice ) ; }	Gets the timer map, loading from the persistent store if necessary. Should be called under lock.
private string getdirectory ( string timedobjectid ) { string dirname = directories . get ( timedobjectid ) ; if ( dirname == null ) { dirname = basedir . getabsolutepath ( ) + file . separator + timedobjectid . replace ( file . separator , str_ ) ; file file = new file ( dirname ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { ejb3_timer_logger . failtocreatedirectoryforpersisttimers ( file ) ; } } directories . put ( timedobjectid , dirname ) ; } return dirname ; }	Gets the directory for a given timed object, making sure it exists.
synchronized void addlistener ( final string target , final int scope , final naminglistener naminglistener ) { final targetscope targetscope = new targetscope ( target , scope ) ;	Add a listener to the coordinator with a given target name and event scope.
synchronized void removelistener ( final naminglistener naminglistener ) {	Remove a listener. Will remove it from all target mappings. Once this method returns, the listener will no longerreceive any events.
void fireevent ( final eventcontext context , final name name , final binding existingbinding , final binding newbinding , int type , final string changeinfo , final integer ... scopes ) { final string target = name . tostring ( ) ; final set < integer > scopeset = new hashset < integer > ( arrays . aslist ( scopes ) ) ; final namingevent event = new namingevent ( context , type , newbinding , existingbinding , changeinfo ) ; final set < listenerholder > holderstofire = new hashset < listenerholder > ( ) ;	Fire a naming event.
public static < t extends autocloseable > consumer < t > close ( ) { return value -> { try { value . close ( ) ; } catch ( throwable e ) { clusteringlogger . root_logger . failedtoclose ( e , value ) ; } } ; }	Returns a consumer that closes its input.
private void addprivatecredential ( final subject subject , final object credential ) { if ( ! wildflysecuritymanager . ischecking ( ) ) { subject . getprivatecredentials ( ) . add ( credential ) ; } else { accesscontroller . doprivileged ( ( privilegedaction < void > ) ( ) -> { subject . getprivatecredentials ( ) . add ( credential ) ; return null ; } ) ; } }	Add the specified credential to the subject's private credentials set.
public object getobjectinstance ( final object ref , final name name , final context namectx , final hashtable < ? , ? > environment ) throws exception { final classloader classloader = wildflysecuritymanager . getcurrentcontextclassloaderprivileged ( ) ; if ( classloader == null ) { return ref ; } final string factoriesprop = ( string ) environment . get ( context . object_factories ) ; if ( factoriesprop != null ) { final string [ ] classes = factoriesprop . split ( str_ ) ; for ( string classname : classes ) { try { final class < ? > factoryclass = classloader . loadclass ( classname ) ; final objectfactory objectfactory = objectfactory . class . cast ( factoryclass . newinstance ( ) ) ; final object result = objectfactory . getobjectinstance ( ref , name , namectx , environment ) ; if ( result != null ) { return result ; } } catch ( throwable ignored ) { } } } return ref ; }	Create an object instance.
protected static void addtxmanagementinterceptorforview ( viewdescription view ) {	Sets up the transaction management interceptor for all methods of the passed view.
private static void subst ( final stringbuilder stringbuilder , final string from , final string to ) { int begin = num_ , end = num_ ; while ( ( end = stringbuilder . indexof ( from , end ) ) != - num_ ) { stringbuilder . delete ( end , end + from . length ( ) ) ; stringbuilder . insert ( end , to ) ;	Substitute sub-strings inside of a string.
private transportconfiguration createinvmtransportconfiguration ( operationcontext context ) throws operationfailedexception { final resource serverresource = context . readresource ( empty_address , bool_ ) ; set < resource . resourceentry > invmconnectors = serverresource . getchildren ( commonattributes . in_vm_connector ) ; if ( invmconnectors . isempty ( ) ) { throw messaginglogger . root_logger . noinvmconnector ( ) ; } resource . resourceentry connectorentry = invmconnectors . iterator ( ) . next ( ) ; resource connectorresource = context . readresource ( pathaddress . pathaddress ( connectorentry . getpathelement ( ) ) , bool_ ) ; modelnode model = connectorresource . getmodel ( ) ; map < string , object > params = new hashmap < > ( commonattributes . params . unwrap ( context , model ) ) ; params . put ( invmtransportdefinition . server_id . getname ( ) , invmtransportdefinition . server_id . resolvemodelattribute ( context , model ) . asint ( ) ) ; transportconfiguration transportconfiguration = new transportconfiguration ( invmconnectorfactory . class . getname ( ) , params ) ; return transportconfiguration ; }	The XmlDataImporter requires a connector to connect to the artemis broker.We require to use a in-vm one so that importing a journal is not subject to any network connection problem.
private string addearprefixifrelativename ( final string configuredname , final deploymentunit deploymentunit , final class < ? > componentclass ) throws deploymentunitprocessingexception { if ( ! configuredname . startswith ( str_ ) ) { return configuredname ; } final deploymentunit parent = deploymentunit . getparent ( ) ; if ( parent == null ) { throw ejblogger . root_logger . relativeresourceadapternameinstandalonemodule ( deploymentunit . getname ( ) , componentclass . getname ( ) , configuredname ) ; } return new stringbuilder ( ) . append ( parent . getname ( ) ) . append ( configuredname ) . tostring ( ) ; }	adds ear prefix to configured adapter name if it is specified in relative form.
public static deploymentunit getrootdeploymentunit ( deploymentunit deploymentunit ) { if ( deploymentunit . getparent ( ) == null ) { return deploymentunit ; } return deploymentunit . getparent ( ) ; }	Returns the parent of the given deployment unit if such a parent exists.
public servicename getservicename ( ) {	Get the service name for this view.
public viewconfiguration createviewconfiguration ( final class < ? > viewclass , final componentconfiguration componentconfiguration , final proxyfactory < ? > proxyfactory ) { return new viewconfiguration ( viewclass , componentconfiguration , getservicename ( ) , proxyfactory ) ; }	Creates view configuration. Allows for extensibility in EE sub components.
protected injectionsource createinjectionsource ( final servicename servicename , value < classloader > viewclassloader , boolean appclient ) { return new viewbindinginjectionsource ( servicename ) ; }	Create the injection source.
public list < interceptorfactory > getviewinterceptors ( method method ) { ordereditemcontainer < interceptorfactory > container = viewinterceptors . get ( method ) ; if ( container == null ) { return collections . emptylist ( ) ; } return container . getsorteditems ( ) ; }	Get the view interceptors for a method.
public void addviewinterceptor ( interceptorfactory interceptorfactory , int priority ) { for ( method method : proxyfactory . getcachedmethods ( ) ) { addviewinterceptor ( method , interceptorfactory , priority ) ; } }	Adds an interceptor factory to all methods of a view.
public void addviewinterceptor ( method method , interceptorfactory interceptorfactory , int priority ) { ordereditemcontainer < interceptorfactory > container = viewinterceptors . get ( method ) ; if ( container == null ) { viewinterceptors . put ( method , container = new ordereditemcontainer < interceptorfactory > ( ) ) ; } container . add ( interceptorfactory , priority ) ; }	Adds a view interceptor to the given method.
public list < interceptorfactory > getclientinterceptors ( method method ) { ordereditemcontainer < interceptorfactory > container = clientinterceptors . get ( method ) ; if ( container == null ) { return collections . emptylist ( ) ; } return container . getsorteditems ( ) ; }	Get the client interceptors for a method.
public void addclientinterceptor ( interceptorfactory interceptorfactory , int priority ) { for ( method method : proxyfactory . getcachedmethods ( ) ) { addclientinterceptor ( method , interceptorfactory , priority ) ; } }	Adds a client interceptor factory to all methods of a view.
public void addclientinterceptor ( method method , interceptorfactory interceptorfactory , int priority ) { ordereditemcontainer < interceptorfactory > container = clientinterceptors . get ( method ) ; if ( container == null ) { clientinterceptors . put ( method , container = new ordereditemcontainer < interceptorfactory > ( ) ) ; } container . add ( interceptorfactory , priority ) ; }	Adds a client interceptor to the given method.
public < t > void putprivatedata ( final class < t > type , t data ) { privatedata . put ( type , data ) ; }	Attaches arbitrary private data to this view instance.
protected static void unexpectedelement ( final xmlextendedstreamreader reader ) throws xmlstreamexception { throw eelogger . root_logger . unexpectedelement ( reader . getname ( ) , reader . getlocation ( ) ) ; }	Throws a XMLStreamException for the unexpected element that was encountered during the parse.
public static list < ejbendpoint > getjaxwsejbs ( final deploymentunit unit ) { final jaxwsdeployment jaxwsdeployment = getoptionalattachment ( unit , wsattachmentkeys . jaxws_endpoints_key ) ; return jaxwsdeployment != null ? jaxwsdeployment . getejbendpoints ( ) : collections . < ejbendpoint > emptylist ( ) ; }	Gets list of JAXWS EJBs meta data.
public static list < pojoendpoint > getjaxwspojos ( final deploymentunit unit ) { final jaxwsdeployment jaxwsdeployment = unit . getattachment ( wsattachmentkeys . jaxws_endpoints_key ) ; return jaxwsdeployment != null ? jaxwsdeployment . getpojoendpoints ( ) : collections . < pojoendpoint > emptylist ( ) ; }	Gets list of JAXWS POJOs meta data.
public static string getendpointname ( final servletmetadata servletmd ) { final string endpointname = servletmd . getname ( ) ; return endpointname != null ? endpointname . trim ( ) : null ; }	Returns endpoint name.
public static string getendpointclassname ( final servletmetadata servletmd ) { final string endpointclass = servletmd . getservletclass ( ) ; return endpointclass != null ? endpointclass . trim ( ) : null ; }	Returns endpoint class name.
public static servletmetadata getservletforname ( final jbosswebmetadata jbosswebmd , final string servletname ) { for ( jbossservletmetadata servlet : jbosswebmd . getservlets ( ) ) { if ( servlet . getname ( ) . equals ( servletname ) ) { return servlet ; } } return null ; }	Returns servlet meta data for requested servlet name.
public static < a > a getrequiredattachment ( final deploymentunit unit , final attachmentkey < a > key ) { final a value = unit . getattachment ( key ) ; if ( value == null ) { throw new illegalstateexception ( ) ; } return value ; }	Returns required attachment value from deployment unit.
public static < a > a getoptionalattachment ( final deploymentunit unit , final attachmentkey < a > key ) { return unit . getattachment ( key ) ; }	Returns optional attachment value from deployment unit or null if not bound.
public static jbosswebmetadata getjbosswebmetadata ( final deploymentunit unit ) { final warmetadata warmetadata = getoptionalattachment ( unit , warmetadata . attachment_key ) ; jbosswebmetadata result = null ; if ( warmetadata != null ) { result = warmetadata . getmergedjbosswebmetadata ( ) ; if ( result == null ) { result = warmetadata . getjbosswebmetadata ( ) ; } } else { result = getoptionalattachment ( unit , wsattachmentkeys . jbossweb_metadata_key ) ; } return result ; }	Gets the JBossWebMetaData from the WarMetaData attached to the provided deployment unit, if any.
public static jbossportcomponentmetadata getjbosswebservicemetadataportcomponent ( final deploymentunit unit , final string name ) { if ( name != null ) { final jbosswebservicesmetadata jbosswebservicemetadata = unit . getattachment ( jboss_webservices_metadata_key ) ; if ( jbosswebservicemetadata != null ) { jbossportcomponentmetadata [ ] portcomponent = jbosswebservicemetadata . getportcomponents ( ) ; if ( portcomponent != null ) { for ( jbossportcomponentmetadata component : portcomponent ) { if ( name . equals ( component . getejbname ( ) ) ) { return component ; } } } } } return null ; }	Return a named port-component from the jboss-webservices.xml.
public static ejbendpoint getwebservicemetadataejbendpoint ( final jaxwsdeployment jaxwsdeployment , final string classname ) { java . util . list < ejbendpoint > ejbendpointlist = jaxwsdeployment . getejbendpoints ( ) ; for ( ejbendpoint ejbendpoint : ejbendpointlist ) { if ( classname . equals ( ejbendpoint . getclassname ( ) ) ) { return ejbendpoint ; } } return null ; }	Returns an EJBEndpoint based upon fully qualified classname.
public static string getcontextroot ( final deployment dep , final jbosswebmetadata jbosswebmd ) { final deploymentunit unit = wshelper . getrequiredattachment ( dep , deploymentunit . class ) ; final jbossappmetadata jbossappmd = unit . getparent ( ) == null ? null : ashelper . getoptionalattachment ( unit . getparent ( ) , wsattachmentkeys . jboss_app_metadata_key ) ; string contextroot = null ;	Returns context root associated with webservice deployment.If there's application.xml descriptor provided defining nested web module, then context root defined there will bereturned.
@ override public class < ? > classforname ( string name ) { try { if ( classes . containskey ( name ) ) { return classes . get ( name ) ; } final class < ? > clazz = module . getclassloader ( ) . loadclass ( name ) ; classes . put ( name , clazz ) ; return clazz ; } catch ( classnotfoundexception | linkageerror e ) { throw new resourceloadingexception ( e ) ; } }	If the class name is found in additionalClasses then return it.Otherwise the class will be loaded from the module ClassLoader.
@ override public url getresource ( string name ) { try { return module . getclassloader ( ) . getresource ( name ) ; } catch ( exception e ) { throw new resourceloadingexception ( e ) ; } }	Loads a resource from the module class loader.
@ override public collection < url > getresources ( string name ) { try { final hashset < url > resources = new hashset < url > ( ) ; enumeration < url > urls = module . getclassloader ( ) . getresources ( name ) ; while ( urls . hasmoreelements ( ) ) { resources . add ( urls . nextelement ( ) ) ; } return resources ; } catch ( exception e ) { throw new resourceloadingexception ( e ) ; } }	Loads resources from the module class loader.
public list < resource > list ( string path ) { try { final list < resource > ret = new arraylist < > ( ) ; resource res = deploymentresourcemanager . getresource ( path ) ; if ( res != null ) { for ( resource child : res . list ( ) ) { ret . add ( new servletresource ( this , child ) ) ; } } string p = path ; if ( p . startswith ( str_ ) ) { p = p . substring ( num_ ) ; } if ( overlays != null ) { for ( virtualfile overlay : overlays ) { virtualfile child = overlay . getchild ( p ) ; if ( child . exists ( ) ) { virtualfileresource vfsresource = new virtualfileresource ( overlay . getphysicalfile ( ) , child , path ) ; for ( resource c : vfsresource . list ( ) ) { ret . add ( new servletresource ( this , c ) ) ; } } } } return ret ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ;	Lists all children of a particular path, taking overlays into account.
public static void popcall ( ) { map < string , entitymanager > emstack = nontxstack . pop ( ) ; if ( emstack != null ) { for ( entitymanager entitymanager : emstack . values ( ) ) { try { if ( entitymanager . isopen ( ) ) { entitymanager . close ( ) ; } } catch ( runtimeexception safetoignore ) { if ( root_logger . istraceenabled ( ) ) { root_logger . trace ( str_ + str_ + str_ , safetoignore ) ; } } } } }	current session bean invocation is ending, close any transactional entity managers created without a JTAtransaction.
public static entitymanager get ( string puscopedname ) { map < string , entitymanager > map = nontxstack . peek ( ) ; if ( map != null ) { return map . get ( puscopedname ) ; } return null ; }	Return the transactional entity manager for the specified scoped persistence unit name.
void registercleanuplistener ( transactionsynchronizationregistry transactionsynchronizationregistry , jmscontext contextinstance ) {	Closing of transaction scoped JMSContext is executed through Synchronization listener.This method registers listener, which takes care of closing JMSContext.
public void deploy ( final deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; if ( ! deploymenttypemarker . istype ( deploymenttype . war , deploymentunit ) ) { return ;	Process web annotations.
public static boolean isallfieldspublic ( class c ) { try { final field [ ] list = c . getfields ( ) ; for ( int i = num_ ; i < list . length ; i ++ ) if ( ! modifier . ispublic ( list [ i ] . getmodifiers ( ) ) ) return bool_ ; } catch ( exception e ) { return bool_ ; } return bool_ ; }	Checks whether all the fields in the class are declared as public.
protected final endpoint newhttpendpoint ( final string endpointclass , final string endpointname , final deployment dep ) { if ( endpointname == null ) throw wslogger . root_logger . nullendpointname ( ) ; if ( endpointclass == null ) throw wslogger . root_logger . nullendpointclass ( ) ; final endpoint endpoint = this . deploymentmodelfactory . newhttpendpoint ( endpointclass ) ; endpoint . setshortname ( endpointname ) ; endpoint . settype ( endpointtype ) ; dep . getservice ( ) . addendpoint ( endpoint ) ; return endpoint ; }	Creates new Http Web Service endpoint.
private archivedeployment newdeployment ( final deploymentunit unit ) { wslogger . root_logger . tracef ( str_ , unit ) ; final resourceroot deploymentroot = unit . getattachment ( attachments . deployment_root ) ; final virtualfile root = deploymentroot != null ? deploymentroot . getroot ( ) : null ; final classloader classloader ; final module module = unit . getattachment ( attachments . module ) ; if ( module == null ) { classloader = unit . getattachment ( classloader_key ) ; if ( classloader == null ) { throw wslogger . root_logger . classloaderresolutionfailed ( unit ) ; } } else { classloader = module . getclassloader ( ) ; } archivedeployment parentdep = null ; if ( unit . getparent ( ) != null ) { final module parentmodule = unit . getparent ( ) . getattachment ( attachments . module ) ; if ( parentmodule == null ) { throw wslogger . root_logger . classloaderresolutionfailed ( deploymentroot ) ; } wslogger . root_logger . tracef ( str_ , unit . getparent ( ) ) ; parentdep = this . newdeployment ( null , unit . getparent ( ) . getname ( ) , parentmodule . getclassloader ( ) , null ) ; } final unifiedvirtualfile uvf = root != null ? new virtualfileadaptor ( root ) : new resourceloaderadapter ( classloader ) ; final archivedeployment dep = this . newdeployment ( parentdep , unit . getname ( ) , classloader , uvf ) ;	Creates new Web Service deployment.
public static boolean isjaxrsdeployment ( deploymentunit deploymentunit ) { deploymentunit deployment = deploymentunit . getparent ( ) == null ? deploymentunit : deploymentunit . getparent ( ) ; boolean val = deployment . getattachment ( attachment_key ) ; return val != null && val ; }	JAX-RS annotations are found in the deployment, especially if it's an EAR one).
public void setnexttimeout ( date next ) { if ( next == null ) { settimerstate ( timerstate . expired , null ) ; } this . nextexpiration = next ; }	Sets the next timeout of this timer.
protected void settimerstate ( timerstate state , thread thread ) { assert ( ( state == timerstate . in_timeout || state == timerstate . retry_timeout ) && thread != null ) || thread == null : str_ + state + str_ + thread ; this . timerstate = state ; this . executingthread = thread ; }	Sets the state and timer task executing thread of this timer.
public void merge ( final list < resteasydeploymentdata > deploymentdata ) throws deploymentunitprocessingexception { for ( resteasydeploymentdata data : deploymentdata ) { scannedapplicationclasses . addall ( data . getscannedapplicationclasses ( ) ) ; if ( scanresources ) { scannedresourceclasses . addall ( data . getscannedresourceclasses ( ) ) ; scannedjndicomponentresources . addall ( data . getscannedjndicomponentresources ( ) ) ; } if ( scanproviders ) { scannedproviderclasses . addall ( data . getscannedproviderclasses ( ) ) ; } } }	Merges a list of additional JAX-RS deployment data with this lot of deployment data.
public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final modulespecification modulespecification = deploymentunit . getattachment ( attachments . module_specification ) ; final moduleloader moduleloader = module . getbootmoduleloader ( ) ;	Add the EE APIs as a dependency to all deployments.
protected void addremotetransactionsdependency ( ) { this . getconfigurators ( ) . add ( new componentconfigurator ( ) { @ override public void configure ( deploymentphasecontext context , componentdescription description , componentconfiguration componentconfiguration ) throws deploymentunitprocessingexception { if ( this . hasremoteview ( ( ejbcomponentdescription ) description ) ) {	Adds a dependency for the ComponentConfiguration on the remote transaction service if the EJB exposes at least one remote view.
public set < interceptordescription > getallcontainerinterceptors ( ) { if ( this . allcontainerinterceptors == null ) { this . allcontainerinterceptors = new hashset < interceptordescription > ( ) ; this . allcontainerinterceptors . addall ( this . classlevelcontainerinterceptors ) ; if ( ! this . excludedefaultcontainerinterceptors ) { this . allcontainerinterceptors . addall ( this . defaultcontainerinterceptors ) ; } for ( list < interceptordescription > interceptors : this . methodlevelcontainerinterceptors . values ( ) ) { this . allcontainerinterceptors . addall ( interceptors ) ; } } return this . allcontainerinterceptors ; }	Returns a combined map of class and method level container interceptors.
public boolean ismethodlevel ( methodintf methodintf , method method , methodintf defaultmethodintf ) { assert methodintf != null : str_ ; assert method != null : str_ ; method classmethod = resolverealmethod ( method ) ; string [ ] methodparams = methodinfohelper . getcanonicalparametertypes ( classmethod ) ; final string methodname = classmethod . getname ( ) ; final string classname = classmethod . getdeclaringclass ( ) . getname ( ) ; arraykey methodparamskey = new arraykey ( ( object [ ] ) methodparams ) ; t attr = get ( get ( get ( perviewstyle3 , methodintf ) , methodname ) , methodparamskey ) ; if ( attr != null ) return bool_ ; attr = get ( get ( perviewstyle2 , methodintf ) , methodname ) ; if ( attr != null ) return bool_ ; attr = get ( perviewstyle1 , methodintf ) ; if ( attr != null ) return bool_ ; attr = get ( get ( get ( style3 , classname ) , methodname ) , methodparamskey ) ; if ( attr != null ) return bool_ ; attr = get ( style2 , methodname ) ; if ( attr != null ) return bool_ ; attr = get ( style1 , classname ) ; if ( attr != null ) return bool_ ; if ( defaultmethodintf == null ) { return bool_ ; } else { return ismethodlevel ( defaultmethodintf , method , null ) ; } }	Returns true if the given transaction specification was expliitly specified at a method level, returnsfalse if it was inherited from the default.
protected static void checkonlyoneofelements ( xmlextendedstreamreader reader , set < element > seen , element element1 , element element2 ) throws xmlstreamexception { if ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) { throw new xmlstreamexception ( messaginglogger . root_logger . required ( element1 . getlocalname ( ) , element2 . getlocalname ( ) ) , reader . getlocation ( ) ) ; } if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new xmlstreamexception ( messaginglogger . root_logger . onlyonerequired ( element1 . getlocalname ( ) , element2 . getlocalname ( ) ) , reader . getlocation ( ) ) ; } }	Check one and only one of the 2 elements has been defined.
protected static class < ? > gettype ( configvisitor visitor , string classname ) { if ( classname != null ) { try { return visitor . getmodule ( ) . getclassloader ( ) . loadclass ( classname ) ; } catch ( exception e ) { throw new illegalargumentexception ( e ) ; } } return null ; }	Load class.
static type getcomponenttype ( parameterizedtype type , int index ) { type [ ] tp = type . getactualtypearguments ( ) ; if ( index + num_ > tp . length ) return null ; return tp [ index ] ; }	Get component type.
public name parse ( string name ) throws namingexception { vector comps = insstringtostringifiedcomps ( name ) ; return new cncompoundname ( comps . elements ( ) ) ; }	Returns a CompoundName given a string in INS syntax.
private static vector insstringtostringifiedcomps ( string str ) throws invalidnameexception { int len = str . length ( ) ; vector components = new vector ( num_ ) ; char [ ] id = new char [ len ] ; char [ ] kind = new char [ len ] ; int idcount , kindcount ; boolean idmode ; for ( int i = num_ ; i < len ; ) { idcount = kindcount = num_ ;	Converts an INS-syntax string name into a Vector in whicheach element of the vector contains a stringified form ofa NameComponent.
private static namecomponent parsecomponent ( string compstr ) throws invalidnameexception { namecomponent comp = new namecomponent ( ) ; int kindsep = - num_ ; int len = compstr . length ( ) ; int j = num_ ; char [ ] newstr = new char [ len ] ; boolean escaped = bool_ ;	Return a NameComponent given its stringified form.
public void shutdown ( ) { poa poa = getpoa ( ) ; try { poa . deactivate_object ( poa . reference_to_id ( getreference ( ) ) ) ; } catch ( userexception ex ) { iioplogger . root_logger . warncouldnotdeactivateirobject ( ex ) ; } }	Unexport this object.
protected org . omg . corba . object servanttoreference ( servant servant ) { byte [ ] id = getobjectid ( ) ; try { repository . poa . activate_object_with_id ( id , servant ) ; org . omg . corba . object ref = repository . poa . id_to_reference ( id ) ; return ref ; } catch ( wrongpolicy ex ) { iioplogger . root_logger . debug ( str_ , ex ) ; } catch ( servantalreadyactive ex ) { iioplogger . root_logger . debug ( str_ , ex ) ; } catch ( objectalreadyactive ex ) { iioplogger . root_logger . debug ( str_ , ex ) ; } catch ( objectnotactive ex ) { iioplogger . root_logger . debug ( str_ , ex ) ; } return null ; }	Convert a servant to a reference.
private securityidentity authenticate ( final string username , final string password ) { serverauthenticationcontext context = this . securitydomain . createnewauthenticationcontext ( ) ; passwordguessevidence evidence = null ; try { if ( password == null ) { if ( username == null ) { if ( context . authorizeanonymous ( ) ) { context . succeed ( ) ; return context . getauthorizedidentity ( ) ; } else { context . fail ( ) ; return null ; } } else {	Attempt to authenticate and authorize an username with the specified password evidence.
private static boolean istypematched ( class < ? > clz ) { if ( clz . equals ( string . class ) ) { return bool_ ; } else if ( clz . equals ( byte . class ) || clz . equals ( byte . class ) ) { return bool_ ; } else if ( clz . equals ( short . class ) || clz . equals ( short . class ) ) { return bool_ ; } else if ( clz . equals ( int . class ) || clz . equals ( integer . class ) ) { return bool_ ; } else if ( clz . equals ( long . class ) || clz . equals ( long . class ) ) { return bool_ ; } else if ( clz . equals ( float . class ) || clz . equals ( float . class ) ) { return bool_ ; } else if ( clz . equals ( double . class ) || clz . equals ( double . class ) ) { return bool_ ; } else if ( clz . equals ( boolean . class ) || clz . equals ( boolean . class ) ) { return bool_ ; } else if ( clz . equals ( char . class ) || clz . equals ( character . class ) ) { return bool_ ; } else if ( clz . equals ( inetaddress . class ) ) { return bool_ ; } else if ( clz . equals ( class . class ) ) { return bool_ ; } else if ( clz . equals ( properties . class ) ) { return bool_ ; } return bool_ ; }	Check whether the types that JCA Injection knows.
@ override public object lookup ( string name ) { final contextnames . bindinfo bindinfo = contextnames . bindinfofor ( name ) ; servicecontroller < ? > bindingservice = container . getservice ( bindinfo . getbinderservicename ( ) ) ; if ( bindingservice == null ) { return null ; } managedreferencefactory managedreferencefactory = managedreferencefactory . class . cast ( bindingservice . getvalue ( ) ) ; return managedreferencefactory . getreference ( ) . getinstance ( ) ; }	SPI contract for this method.
@ override public void unbind ( string name ) { if ( name == null || name . isempty ( ) ) { throw messaginglogger . root_logger . cannotunbindjndiname ( ) ; } final contextnames . bindinfo bindinfo = contextnames . bindinfofor ( name ) ; servicecontroller < ? > bindingservice = container . getservice ( bindinfo . getbinderservicename ( ) ) ; if ( bindingservice == null ) { root_logger . debugf ( str_ , name ) ; return ; }	Unbind the resource and wait until the corresponding binding service is effectively removed.
public static object instantiatebean ( beanmetadataconfig beanconfig , beaninfo beaninfo , deploymentreflectionindex index , module module ) throws throwable { joinpoint instantiatejoinpoint = null ; valueconfig [ ] parameters = new valueconfig [ num_ ] ; string [ ] types = configurator . no_params_types ; constructorconfig ctorconfig = beanconfig . getconstructor ( ) ; if ( ctorconfig != null ) { parameters = ctorconfig . getparameters ( ) ; types = configurator . gettypes ( parameters ) ; string factoryclass = ctorconfig . getfactoryclass ( ) ; factoryconfig factory = ctorconfig . getfactory ( ) ; if ( factoryclass != null || factory != null ) { string factorymethod = ctorconfig . getfactorymethod ( ) ; if ( factorymethod == null ) throw pojologger . root_logger . missingfactorymethod ( beanconfig ) ; if ( factoryclass != null ) {	Instantiate bean.
public static void configure ( beanmetadataconfig beanconfig , beaninfo beaninfo , module module , object bean , boolean nullify ) throws throwable { set < propertyconfig > properties = beanconfig . getproperties ( ) ; if ( properties != null ) { list < propertyconfig > used = new arraylist < propertyconfig > ( ) ; for ( propertyconfig pc : properties ) { try { configure ( beaninfo , module , bean , pc , nullify ) ; used . add ( pc ) ; } catch ( throwable t ) { if ( nullify == bool_ ) { for ( propertyconfig upc : used ) { try { configure ( beaninfo , module , bean , upc , bool_ ) ; } catch ( throwable ignored ) { } } throw new startexception ( t ) ; } } } } }	Configure bean.
public static void dispatchlifecyclejoinpoint ( beaninfo beaninfo , object bean , lifecycleconfig config , string defaultmethod ) throws throwable { if ( config != null && config . isignored ( ) ) return ; joinpoint joinpoint = createjoinpoint ( beaninfo , bean , config , defaultmethod ) ; if ( joinpoint != null ) joinpoint . dispatch ( ) ; }	Dispatch lifecycle joinpoint.
public static namespacecontextselector getcurrentselector ( ) { namespacecontextselector selector = currentselector . peek ( ) ; if ( selector != null ) { return selector ; } return defaultselector ; }	Get the current context selector for the current thread.
public static servicename tobeanname ( string name , beanstate state ) { if ( state == null ) state = beanstate . installed ; return jboss_pojo . append ( name ) . append ( state . name ( ) ) ; }	Get MC bean name.
public static servicename toinstancesname ( class < ? > clazz , beanstate state ) { string clname ; classloader classloader = clazz . getclassloader ( ) ; if ( classloader != null ) clname = classloader . tostring ( ) ; else clname = str_ ; if ( state == null ) state = beanstate . installed ; return jboss_pojo . append ( clname , clazz . getname ( ) , state . name ( ) ) ; }	To instances name.
public eemoduleclassdescription getclassbyname ( string name ) { for ( eemoduledescription module : availablemodules ) { final eemoduleclassdescription desc = module . getclassdescription ( name ) ; if ( desc != null ) { return desc ; } } return null ; }	Look for a class description in all available modules.
@ override protected void processannotations ( final deploymentunit deploymentunit , final compositeindex compositeindex ) throws deploymentunitprocessingexception { if ( metadatacompletemarker . ismetadatacomplete ( deploymentunit ) ) { return ; }	Process annotations and merge any available metadata at the same time.
private void postparsesteps ( final virtualfile persistence_xml , final persistenceunitmetadataholder puholder , final deploymentunit deploymentunit ) { for ( persistenceunitmetadata pu : puholder . getpersistenceunits ( ) ) {	Some of this might need to move to the install phase.
public static string validatedescriptor ( string descriptor ) { if ( descriptor . length ( ) == num_ ) { throw eelogger . root_logger . cannotbeempty ( str_ ) ; } if ( descriptor . length ( ) > num_ ) { if ( descriptor . startswith ( str_ ) ) { if ( ! descriptor . endswith ( str_ ) ) { throw eelogger . root_logger . invaliddescriptor ( descriptor ) ; } } else if ( descriptor . startswith ( str_ ) ) { } else { throw eelogger . root_logger . invaliddescriptor ( descriptor ) ; } } else { char type = descriptor . charat ( num_ ) ; switch ( type ) { case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : break ; default : throw eelogger . root_logger . invaliddescriptor ( descriptor ) ; } } return descriptor ; }	performs basic validation on a descriptor.
void create ( final deployment dep ) { final deploymentunit unit = wshelper . getrequiredattachment ( dep , deploymentunit . class ) ; warmetadata warmd = ashelper . getoptionalattachment ( unit , warmetadata . attachment_key ) ; jbosswebmetadata jbosswebmd = warmd != null ? warmd . getmergedjbosswebmetadata ( ) : null ; if ( warmd == null ) { warmd = new warmetadata ( ) ; } if ( jbosswebmd == null ) { jbosswebmd = new jbosswebmetadata ( ) ; warmd . setmergedjbosswebmetadata ( jbosswebmd ) ; unit . putattachment ( warmetadata . attachment_key , warmd ) ; } createwebappdescriptor ( dep , jbosswebmd ) ; createjbosswebappdescriptor ( dep , jbosswebmd ) ; dep . addattachment ( jbosswebmetadata . class , jbosswebmd ) ; }	Creates web meta data for EJB deployments.
private void createwebappdescriptor ( final deployment dep , final jbosswebmetadata jbosswebmd ) { wslogger . root_logger . trace ( str_ ) ; createservlets ( dep , jbosswebmd ) ; createservletmappings ( dep , jbosswebmd ) ; createsecurityconstraints ( dep , jbosswebmd ) ; createloginconfig ( dep , jbosswebmd ) ; createsecurityroles ( dep , jbosswebmd ) ; }	Creates web.xml descriptor meta data.
private string getauthmethod ( final deployment dep ) { for ( final endpoint ejbendpoint : dep . getservice ( ) . getendpoints ( ) ) { final string beanauthmethod = ejb3securityaccessor . getauthmethod ( ejbendpoint ) ; final boolean hasbeanauthmethod = beanauthmethod != null ; if ( hasbeanauthmethod ) {	Returns deployment authentication method.
public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final virtualfile deploymentroot = phasecontext . getdeploymentunit ( ) . getattachment ( attachments . deployment_root ) . getroot ( ) ; if ( deploymentroot == null || ! deploymentroot . exists ( ) ) return ; virtualfile servicexmlfile = null ; if ( deploymentroot . isdirectory ( ) ) { servicexmlfile = deploymentroot . getchild ( service_descriptor_path ) ; } else if ( deploymentroot . getname ( ) . tolowercase ( locale . english ) . endswith ( service_descriptor_suffix ) ) { servicexmlfile = deploymentroot ; } if ( servicexmlfile == null || ! servicexmlfile . exists ( ) ) return ; final xmlmapper xmlmapper = xmlmapper . factory . create ( ) ; final jbossservicexmldescriptorparser jbossservicexmldescriptorparser = new jbossservicexmldescriptorparser ( jbossdescriptorpropertyreplacement . propertyreplacer ( phasecontext . getdeploymentunit ( ) ) ) ; xmlmapper . registerrootelement ( new qname ( str_ , str_ ) , jbossservicexmldescriptorparser ) ; xmlmapper . registerrootelement ( new qname ( null , str_ ) , jbossservicexmldescriptorparser ) ; inputstream xmlstream = null ; try { xmlstream = servicexmlfile . openstream ( ) ; final xmlstreamreader reader = inputfactory . createxmlstreamreader ( xmlstream ) ; final parseresult < jbossservicexmldescriptor > result = new parseresult < jbossservicexmldescriptor > ( ) ; xmlmapper . parsedocument ( result , reader ) ; final jbossservicexmldescriptor xmldescriptor = result . getresult ( ) ; if ( xmldescriptor != null ) phasecontext . getdeploymentunit ( ) . putattachment ( jbossservicexmldescriptor . attachment_key , xmldescriptor ) ; else throw sarlogger . root_logger . failedxmlparsing ( servicexmlfile ) ; } catch ( exception e ) { throw sarlogger . root_logger . failedxmlparsing ( e , servicexmlfile ) ; } finally { vfsutils . safeclose ( xmlstream ) ; } }	Process a deployment for jboss-service.xml files.
private void handlestatelesssessionbean ( final ejbcomponentdescription component , final module module , final deploymentreflectionindex reflectionindex ) throws classnotfoundexception , deploymentunitprocessingexception { final class < ? > componentclass = classloadingutils . loadclass ( component . getcomponentclassname ( ) , module ) ; final methodidentifier ejbcreateid = methodidentifier . getidentifier ( void . class , str_ ) ; final method ejbcreate = classreflectionindexutil . findmethod ( reflectionindex , componentclass , ejbcreateid ) ; if ( ejbcreate != null ) { final interceptorclassdescription . builder builder = interceptorclassdescription . builder ( ) ; builder . setpostconstruct ( ejbcreateid ) ; component . addinterceptormethodoverride ( ejbcreate . getdeclaringclass ( ) . getname ( ) , builder . build ( ) ) ; } final methodidentifier ejbremoveid = methodidentifier . getidentifier ( void . class , str_ ) ; final method ejbremove = classreflectionindexutil . findmethod ( reflectionindex , componentclass , ejbremoveid ) ; if ( ejbremove != null ) { final interceptorclassdescription . builder builder = interceptorclassdescription . builder ( ) ; builder . setpredestroy ( ejbremoveid ) ; component . addinterceptormethodoverride ( ejbremove . getdeclaringclass ( ) . getname ( ) , builder . build ( ) ) ; } }	Handles setting up the ejbCreate and ejbRemove methods for stateless session beans and MDB's.
public static class < ? > makestubclass ( final class < ? > myclass ) { final string stubclassname = myclass + str_ ; classloader cl = wildflysecuritymanager . getcurrentcontextclassloaderprivileged ( ) ; if ( cl == null ) { cl = myclass . getclassloader ( ) ; } if ( cl == null ) { throw ejblogger . root_logger . couldnotfindclassloaderforstub ( stubclassname ) ; } class < ? > theclass ; try { theclass = cl . loadclass ( stubclassname ) ; } catch ( classnotfoundexception e ) { try { final classfile clazz = iiopstubcompiler . compile ( myclass , stubclassname ) ; theclass = clazz . define ( cl , myclass . getprotectiondomain ( ) ) ; } catch ( throwable ex ) {	Makes a dynamic stub class, if it does not already exist.
protected byte [ ] getanonymousobjectid ( long n ) { string s = anonoidprefix + long . tostring ( n ) ; return s . getbytes ( standardcharsets . utf_8 ) ; }	Generate the ID of the n-th "anonymous" object created in this IR.
@ override public list < persistenceprovider > getpersistenceproviders ( ) { list < persistenceprovider > providerscopy = new arraylist < > ( providers . size ( ) ) ; synchronized ( persistenceproviderperclassloader ) { if ( persistenceproviderperclassloader . size ( ) > num_ ) {	Return a new instance of each persistence provider class.
public void clearcacheddeploymentspecificproviders ( set < classloader > deploymentclassloaders ) { synchronized ( persistenceproviderperclassloader ) { for ( classloader deploymentclassloader : deploymentclassloaders ) { persistenceproviderperclassloader . remove ( deploymentclassloader ) ; } } }	Cleared at application undeployment time to remove any persistence providers that were deployed with the application.
public void adddeploymentspecificpersistenceprovider ( persistenceprovider persistenceprovider , set < classloader > deploymentclassloaders ) { synchronized ( persistenceproviderperclassloader ) { for ( classloader deploymentclassloader : deploymentclassloaders ) { list < class < ? extends persistenceprovider > > list = persistenceproviderperclassloader . get ( deploymentclassloader ) ; root_logger . tracef ( str_ , list , deploymentclassloader ) ; if ( list == null ) { list = new arraylist < > ( ) ; persistenceproviderperclassloader . put ( deploymentclassloader , list ) ; root_logger . tracef ( str_ , list , deploymentclassloader ) ; } list . add ( persistenceprovider . getclass ( ) ) ; root_logger . tracef ( str_ , persistenceprovider . getclass ( ) . getname ( ) , list ) ; } } }	Set at application deployment time to the persistence providers packaged in the application.
private classloader findparentmodulecl ( classloader classloader ) { classloader c = classloader ; while ( c != null && ! ( c instanceof moduleclassloader ) ) { c = c . getparent ( ) ; } return c ; }	If a custom CL is in use we want to get the module CL it delegates to.
public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final modulespecification modulespecification = deploymentunit . getattachment ( attachments . module_specification ) ; final jbossservicexmldescriptor servicexmldescriptor = deploymentunit . getattachment ( jbossservicexmldescriptor . attachment_key ) ; if ( servicexmldescriptor == null ) { return ;	Add dependencies for modules required for manged bean deployments, if managed bean configurations are attachedto the deployment.
private static void addpuservice ( final deploymentphasecontext phasecontext , final arraylist < persistenceunitmetadataholder > pulist , final boolean startearly , final platform platform ) throws deploymentunitprocessingexception { if ( pulist . size ( ) > num_ ) { final deploymentunit deploymentunit = phasecontext . getdeploymentunit ( ) ; final module module = deploymentunit . getattachment ( attachments . module ) ; final eemoduledescription eemoduledescription = deploymentunit . getattachment ( org . jboss . as . ee . component . attachments . ee_module_description ) ; final servicetarget servicetarget = phasecontext . getservicetarget ( ) ; final moduleclassloader classloader = module . getclassloader ( ) ; for ( persistenceunitmetadataholder holder : pulist ) { setannotationindexes ( holder , deploymentunit ) ; for ( persistenceunitmetadata pu : holder . getpersistenceunits ( ) ) {	Add one PU service per top level deployment that represents.
private static void setannotationindexes ( final persistenceunitmetadataholder puholder , deploymentunit deploymentunit ) { final map < url , index > annotationindexes = new hashmap < > ( ) ; do { for ( resourceroot root : deploymentutils . allresourceroots ( deploymentunit ) ) { final index index = root . getattachment ( attachments . annotation_index ) ; if ( index != null ) { try { root_logger . tracef ( str_ , root . getroot ( ) . tourl ( ) ) ; annotationindexes . put ( root . getroot ( ) . tourl ( ) , index ) ; } catch ( malformedurlexception e ) { throw new runtimeexception ( e ) ; } } } deploymentunit = deploymentunit . getparent ( ) ;	Setup the annotation index map.
private static persistenceprovideradaptor getpersistenceprovideradaptor ( final persistenceunitmetadata pu , final persistenceproviderdeploymentholder persistenceproviderdeploymentholder , final deploymentunit deploymentunit , final persistenceprovider provider , final platform platform ) throws deploymentunitprocessingexception { string adapterclass = pu . getproperties ( ) . getproperty ( configuration . adapter_class ) ; if ( persistenceproviderdeploymentholder != null && adapterclass != null ) { list < persistenceprovideradaptor > persistenceprovideradaptors = persistenceproviderdeploymentholder . getadapters ( ) ; for ( persistenceprovideradaptor persistenceprovideradaptor : persistenceprovideradaptors ) { if ( adapterclass . equals ( persistenceprovideradaptor . getclass ( ) . getname ( ) ) ) { return persistenceprovideradaptor ; } } } string adaptormodule = pu . getproperties ( ) . getproperty ( configuration . adapter_module ) ; persistenceprovideradaptor adaptor ; adaptor = getperdeploymentsharedpersistenceprovideradaptor ( deploymentunit , adaptormodule , provider ) ; if ( adaptor == null ) { try {	Get the persistence provider adaptor.
private static persistenceprovideradaptor saveperdeploymentsharedpersistenceprovideradaptor ( deploymentunit deploymentunit , string adaptormodule , persistenceprovideradaptor adaptor , persistenceprovider provider ) { if ( deploymentunit . getparent ( ) != null ) { deploymentunit = deploymentunit . getparent ( ) ; } synchronized ( deploymentunit ) { map < string , persistenceprovideradaptor > map = deploymentunit . getattachment ( provideradaptormapkey ) ; string key ; if ( adaptormodule != null ) { key = adaptormodule ;	Will save the PersistenceProviderAdaptor at the top level application deployment unit level for sharing with other persistence units.
private static persistenceprovider lookupprovider ( persistenceunitmetadata pu , persistenceproviderdeploymentholder persistenceproviderdeploymentholder , deploymentunit deploymentunit ) throws deploymentunitprocessingexception { map < string , persistenceprovider > providermap = persistenceproviderdeploymentholder != null ? persistenceproviderdeploymentholder . getproviders ( ) : null ; if ( providermap != null ) { synchronized ( providermap ) { if ( providermap . containskey ( pu . getpersistenceproviderclassname ( ) ) ) { root_logger . tracef ( str_ , deploymentunit . getname ( ) , pu . getpersistenceproviderclassname ( ) ) ; return providermap . get ( pu . getpersistenceproviderclassname ( ) ) ; } } } string configuredpersistenceprovidermodule = pu . getproperties ( ) . getproperty ( configuration . provider_module ) ; string persistenceproviderclassname = pu . getpersistenceproviderclassname ( ) ; if ( persistenceproviderclassname == null ) { persistenceproviderclassname = configuration . provider_class_default ; } if ( configuredpersistenceprovidermodule != null ) { list < persistenceprovider > providers ; if ( configuration . provider_module_application_supplied . equals ( configuredpersistenceprovidermodule ) ) { try {	Look up the persistence provider.
@ override public map < class < ? extends annotation > , set < class < ? > > > getannotatedclasses ( final set uris ) { return annotations ;	use a plain Set and it should work for both versions.
final ejbarchivemetadata create ( final deployment dep ) { if ( wslogger . root_logger . istraceenabled ( ) ) { wslogger . root_logger . tracef ( str_ , dep . getsimplename ( ) ) ; } final ejbarchivemetadata . builder ejbarchivemdbuilder = new ejbarchivemetadata . builder ( ) ; this . buildenterprisebeansmetadata ( dep , ejbarchivemdbuilder ) ; this . buildwebservicesmetadata ( dep , ejbarchivemdbuilder ) ; return ejbarchivemdbuilder . build ( ) ; }	Builds universal EJB meta data model that is AS agnostic.
protected void buildenterprisebeanmetadata ( final list < ejbmetadata > wsejbsmd , final ejbendpoint ejbendpoint , final jbosswebservicesmetadata jbosswebservicesmd ) { final slsbmetadata . builder wsejbmdbuilder = new slsbmetadata . builder ( ) ;	Builds JBoss agnostic EJB meta data.
void refreshparticipant ( operationcontext context ) { context . addstep ( refreshhandler , operationcontext . stage . model , bool_ ) ; }	refresh the attributes of this participant (the status attribute should have changed to PREPARED.
containeranalysis getanalysis ( final class cls ) throws rmiiiopviolationexception { containeranalysis ret = null ; boolean created = bool_ ; try { synchronized ( this ) { ret = lookupdone ( cls ) ; if ( ret != null ) { return ret ; }	Returns an analysis.If the calling thread is currently doing an analysis of thisclass, an unfinished analysis is returned.
private containeranalysis lookupdone ( class cls ) { softreference ref = ( softreference ) workdone . get ( cls ) ; if ( ref == null ) return null ; containeranalysis ret = ( containeranalysis ) ref . get ( ) ; if ( ret == null ) workdone . remove ( cls ) ;	Lookup an analysis in the fully done map.
private containeranalysis createworkinprogress ( final class cls ) { final containeranalysis analysis ; try { analysis = ( containeranalysis ) constructor . newinstance ( cls ) ; } catch ( instantiationexception ex ) { throw new runtimeexception ( ex . tostring ( ) ) ; } catch ( illegalaccessexception ex ) { throw new runtimeexception ( ex . tostring ( ) ) ; } catch ( invocationtargetexception ex ) { throw new runtimeexception ( ex . tostring ( ) ) ; } workinprogress . put ( new inprogresskey ( cls , thread . currentthread ( ) ) , analysis ) ; return analysis ; }	Create new work-in-progress.
public string getidlmodulename ( ) { if ( idlmodulename == null ) { string pkgname = cls . getpackage ( ) . getname ( ) ; stringbuffer b = new stringbuffer ( ) ; while ( ! str_ . equals ( pkgname ) ) { int idx = pkgname . indexof ( str_ ) ; string n = ( idx == - num_ ) ? pkgname : pkgname . substring ( num_ , idx ) ; b . append ( str_ ) . append ( util . javatoidlname ( n ) ) ; pkgname = ( idx == - num_ ) ? str_ : pkgname . substring ( idx + num_ ) ; } idlmodulename = b . tostring ( ) ; } return idlmodulename ; }	Return the fully qualified IDL module name that thisanalysis should be placed in.
protected string tohexstring ( int i ) { string s = integer . tohexstring ( i ) . touppercase ( locale . english ) ; if ( s . length ( ) < num_ ) return str_ . substring ( num_ , num_ - s . length ( ) ) + s ; else return s ; }	Convert an integer to a 16-digit hex string.
protected string tohexstring ( long l ) { string s = long . tohexstring ( l ) . touppercase ( locale . english ) ; if ( s . length ( ) < num_ ) return str_ . substring ( num_ , num_ - s . length ( ) ) + s ; else return s ; }	Convert a long to a 16-digit hex string.
protected boolean isaccessor ( method m ) { class returntype = m . getreturntype ( ) ;	Check if a method is an accessor.
protected boolean ismutator ( method m ) {	Check if a method is a mutator.
protected boolean hasnonappexceptions ( method m ) { class [ ] ex = m . getexceptiontypes ( ) ; for ( int i = num_ ; i < ex . length ; ++ i ) if ( ! java . rmi . remoteexception . class . isassignablefrom ( ex [ i ] ) ) return bool_ ; return bool_ ; }	Check if a method throws anything checked other thanjava.rmi.RemoteException and its subclasses.
protected string attributereadname ( string name ) { if ( name . startswith ( str_ ) ) name = name . substring ( num_ ) ; else if ( name . startswith ( str_ ) ) name = name . substring ( num_ ) ; else throw iioplogger . root_logger . notanaccessor ( name ) ; return name ; }	Convert an attribute read method name in Java format toan attribute name in Java format.
protected string attributewritename ( string name ) { if ( name . startswith ( str_ ) ) name = name . substring ( num_ ) ; else throw iioplogger . root_logger . notanaccessor ( name ) ; return name ; }	Convert an attribute write method name in Java format toan attribute name in Java format.
protected void fixupoverloadedoperationnames ( ) throws rmiiiopviolationexception { for ( int i = num_ ; i < methods . length ; ++ i ) { if ( ( m_flags [ i ] & m_overloaded ) == num_ ) continue ;	Fixup overloaded operation names.As specified in section 1.3.2.6.
protected void fixupcasenames ( ) throws rmiiiopviolationexception { arraylist entries = getcontainedentries ( ) ; boolean [ ] clash = new boolean [ entries . size ( ) ] ; string [ ] uppernames = new string [ entries . size ( ) ] ; for ( int i = num_ ; i < entries . size ( ) ; ++ i ) { abstractanalysis aa = ( abstractanalysis ) entries . get ( i ) ; clash [ i ] = bool_ ; uppernames [ i ] = aa . getidlname ( ) . touppercase ( locale . english ) ; for ( int j = num_ ; j < i ; ++ j ) { if ( uppernames [ i ] . equals ( uppernames [ j ] ) ) { clash [ i ] = bool_ ; clash [ j ] = bool_ ; } } } for ( int i = num_ ; i < entries . size ( ) ; ++ i ) { if ( ! clash [ i ] ) continue ; abstractanalysis aa = ( abstractanalysis ) entries . get ( i ) ; boolean noupper = bool_ ; string name = aa . getidlname ( ) ; stringbuffer b = new stringbuffer ( name ) ; b . append ( str_ ) ; for ( int j = num_ ; j < name . length ( ) ; ++ j ) { if ( ! character . isuppercase ( name . charat ( j ) ) ) continue ; if ( noupper ) noupper = bool_ ; else b . append ( str_ ) ; b . append ( j ) ; } aa . setidlname ( b . tostring ( ) ) ; } }	Fixup names differing only in case.As specified in section 1.3.2.7.
protected string escapeirname ( string name ) { stringbuffer b = new stringbuffer ( ) ; for ( int i = num_ ; i < name . length ( ) ; ++ i ) { char c = name . charat ( i ) ; if ( c < num_ ) b . append ( c ) ; else b . append ( str_ ) . append ( tohexstring ( ( int ) c ) ) ; } return b . tostring ( ) ; }	Escape non-ISO characters for an IR name.
private void parsextsenvironmentelement ( xmlextendedstreamreader reader , modelnode subsystem ) throws xmlstreamexception { processattributes ( reader , ( index , attribute ) -> { final string value = reader . getattributevalue ( index ) ; switch ( attribute ) { case url : environment_url . parseandsetparameter ( value , subsystem , reader ) ; break ; default : throw parseutils . unexpectedattribute ( reader , index ) ; } } ) ;	Handle the xts-environment element.
private void parsedefaultcontextpropagationelement ( xmlextendedstreamreader reader , modelnode subsystem ) throws xmlstreamexception { processattributes ( reader , ( index , attribute ) -> { final string value = reader . getattributevalue ( index ) ; switch ( attribute ) { case enabled : if ( value == null || ( ! value . tolowercase ( ) . equals ( str_ ) && ! value . tolowercase ( ) . equals ( str_ ) ) ) { throw parseutils . invalidattributevalue ( reader , index ) ; } default_context_propagation . parseandsetparameter ( value , subsystem , reader ) ; break ; default : throw parseutils . unexpectedattribute ( reader , index ) ; } } ) ;	Handle the enable-client-handler element.
private void processattributes ( final xmlextendedstreamreader reader , attributeprocessor < integer , attribute > attributeprocessorcallback ) throws xmlstreamexception { final int count = reader . getattributecount ( ) ; for ( int i = num_ ; i < count ; i ++ ) { parseutils . requirenonamespaceattribute ( reader , i ) ;	Iterating over all attributes got from the reader parameter.
public static list < persistenceprovider > loadprovidermodulebyname ( string modulename ) throws moduleloadexception { final moduleloader moduleloader = module . getbootmoduleloader ( ) ; module module = moduleloader . loadmodule ( moduleidentifier . fromstring ( modulename ) ) ; final serviceloader < persistenceprovider > serviceloader = module . loadservice ( persistenceprovider . class ) ; list < persistenceprovider > result = new arraylist < > ( ) ; if ( serviceloader != null ) { for ( persistenceprovider provider1 : serviceloader ) {	Loads the specified JPA persistence provider module.
static abstractaddstephandler createaddoperation ( final string childtype , final boolean allowsibling , collection < ? extends attributedefinition > attributes ) { return new activemqreloadrequiredhandlers . addstephandler ( attributes ) { @ override public void execute ( operationcontext context , modelnode operation ) throws operationfailedexception { super . execute ( context , operation ) ; if ( ! allowsibling ) { context . addstep ( checknoothersibling ( childtype ) , model ) ; } } } ; }	Create an ADD operation that can check that there is no other sibling when the resource is added.
@ override public void deploy ( deploymentphasecontext phasecontext ) throws deploymentunitprocessingexception {	Adds Java EE module as a dependency to any deployment unit which is an EJB deployment.
private boolean writeattribute ( xmlextendedstreamwriter writer , simpleattributedefinition attribute , modelnode node , boolean startwriten , string origin ) throws xmlstreamexception { if ( attribute . ismarshallable ( node , bool_ ) ) { if ( ! startwriten ) { startwriten = bool_ ; writer . writestartelement ( origin ) ; } attribute . marshallasattribute ( node , bool_ , writer ) ; } return startwriten ; }	todo, attribute.marshallAsAttribute should return boolean.
public sessionid createsessionremote ( ) { controlpoint controlpoint = getcontrolpoint ( ) ; if ( controlpoint == null ) { return createsession ( ) ; } else { try { runresult result = controlpoint . beginrequest ( ) ; if ( result == runresult . rejected ) { throw ejblogger . root_logger . containersuspended ( ) ; } try { return createsession ( ) ; } finally { controlpoint . requestcomplete ( ) ; } } catch ( ejbcomponentunavailableexception | componentisstoppedexception e ) { throw e ; } catch ( exception e ) { throw new ejbexception ( e ) ; } } }	creates a session using the global request controller.This should only be used by callers that service remote requests (i.e.
private string inferdestinationname ( string address ) { if ( address . startswith ( jms_queue_prefix ) ) { return address . substring ( jms_queue_prefix . length ( ) ) ; } else if ( address . startswith ( jms_topic_prefix ) ) { return address . substring ( jms_topic_prefix . length ( ) ) ; } else { return address ; } }	Infer the name of the JMS destination based on the queue's address.
public void registerendpointhandlers ( final string endpointclass , final set < string > endpointhandlers ) { if ( ( endpointclass == null ) || ( endpointhandlers == null ) ) { throw new illegalargumentexception ( ) ; } endpointhandlersmap . put ( endpointclass , collections . unmodifiableset ( endpointhandlers ) ) ; }	Registers endpoint and its associated WS handlers.
set < string > getjobxmlnames ( final string jobname ) { if ( jobnames . containskey ( jobname ) ) { return collections . unmodifiableset ( jobnames . get ( jobname ) ) ; } return collections . emptyset ( ) ; }	Returns the job XML file names which contain the job name.
private void init ( final classloader classloader ) {	Initializes the state of an instance.
protected string requesturi ( httpserverexchange request ) { string uri = request . getrelativepath ( ) ; if ( uri == null || uri . equals ( str_ ) ) { uri = str_ ; } return uri ; }	Get the canonical request URI from the request mapping data requestPath.
public static resolveresult createusingurl ( string url , hashtable env ) throws namingexception { cnctx ctx = new cnctx ( ) ; if ( env != null ) { env = ( hashtable ) env . clone ( ) ; } ctx . _env = env ; string rest = ctx . initusingurl ( env != null ? ( org . omg . corba . orb ) env . get ( str_ ) : null , url , env ) ;	This method is used by the iiop and iiopname URL Context factories.
public java . lang . object lookup ( string name ) throws namingexception { return lookup ( new compositename ( name ) ) ; }	Converts the "String" name into a CompositeNamereturns the object resolved by the COS Naming api,resolve.
public void bind ( string name , java . lang . object obj ) throws namingexception { bind ( new compositename ( name ) , obj ) ; }	Converts the "String" name into a CompositeName object andperforms the bind operation.
private void callunbind ( namecomponent [ ] path ) throws namingexception { if ( _nc == null ) throw iioplogger . root_logger . notanamingcontext ( path . tostring ( ) ) ; try { _nc . unbind ( path ) ; } catch ( notfound e ) {	Calls the unbind api of COS Naming and uses the exception mapperclass to map the exceptions.
public namingenumeration listbindings ( name name ) throws namingexception { if ( _nc == null ) throw iioplogger . root_logger . notanamingcontext ( name . tostring ( ) ) ; if ( name . size ( ) > num_ ) { try { java . lang . object obj = lookup ( name ) ; if ( obj instanceof cnctx ) { return new org . wildfly . iiop . openjdk . naming . jndi . cnbindingenumeration ( ( cnctx ) obj , bool_ , _env ) ; } else { throw new notcontextexception ( name . tostring ( ) ) ; } } catch ( namingexception ne ) { throw ne ; } catch ( bad_param e ) { namingexception ne = new notcontextexception ( name . tostring ( ) ) ; ne . setrootcause ( e ) ; throw ne ; } } return new org . wildfly . iiop . openjdk . naming . jndi . cnbindingenumeration ( this , bool_ , _env ) ; }	Returns a BindingEnumeration object which has a list of nameclass pairs.
private void calldestroy ( namingcontext nc ) throws namingexception { if ( _nc == null ) throw iioplogger . root_logger . notanamingcontext ( nc . tostring ( ) ) ; try { nc . destroy ( ) ; } catch ( exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . exceptionmapper . mapexception ( e , this , null ) ; } }	Calls the destroy on the COS Naming Server.
public void destroysubcontext ( name name ) throws namingexception { if ( _nc == null ) throw iioplogger . root_logger . notanamingcontext ( name . tostring ( ) ) ; namingcontext the_nc = _nc ; namecomponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . cnnameparser . nametocosname ( name ) ; if ( name . size ( ) > num_ ) { try { javax . naming . context ctx = ( javax . naming . context ) callresolve ( path ) ; cnctx cnc = ( cnctx ) ctx ; the_nc = cnc . _nc ; cnc . close ( ) ;	Uses the callDestroy function to destroy the context.
private javax . naming . context callbindnewcontext ( namecomponent [ ] path ) throws namingexception { if ( _nc == null ) throw iioplogger . root_logger . notanamingcontext ( path . tostring ( ) ) ; try { namingcontext nctx = _nc . bind_new_context ( path ) ; return new cnctx ( _orb , nctx , _env , makefullname ( path ) ) ; } catch ( exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . exceptionmapper . mapexception ( e , this , path ) ; } }	Calls the bind_new_context COS naming api to create a new subcontext.
public javax . naming . context createsubcontext ( string name ) throws namingexception { return createsubcontext ( new compositename ( name ) ) ; }	Uses the callBindNewContext convenience function to create a newcontext.
public java . lang . object lookuplink ( string name ) throws namingexception { return lookuplink ( new compositename ( name ) ) ; }	Is mapped to resolve in the COS Naming api.
public java . lang . object addtoenvironment ( string propname , java . lang . object propvalue ) throws namingexception { if ( _env == null ) { _env = new hashtable ( num_ , num_ ) ; } else {	Adds to the environment for the current context.Record change but do not reinitialize ORB.
public java . lang . object removefromenvironment ( string propname ) throws namingexception { if ( _env != null && _env . get ( propname ) != null ) {	Record change but do not reinitialize ORB.
@ suppresswarnings ( str_ ) static void addtransformations ( modelversion version , resourcetransformationdescriptionbuilder builder ) { if ( jgroupsmodel . version_5_0_0 . requirestransformation ( version ) ) { builder . getattributebuilder ( ) . setdiscard ( discardattributechecker . undefined , attribute . statistics_enabled . getdefinition ( ) ) . addrejectcheck ( rejectattributechecker . defined , attribute . statistics_enabled . getdefinition ( ) ) . end ( ) ; } if ( jgroupsmodel . version_3_0_0 . requirestransformation ( version ) ) { attributeconverter typeconverter = new attributeconverter . defaultattributeconverter ( ) { @ override protected void convertattribute ( pathaddress address , string name , modelnode value , transformationcontext context ) { if ( ! value . isdefined ( ) ) { value . set ( address . getlastelement ( ) . getvalue ( ) ) ; } } } ; builder . getattributebuilder ( ) . setdiscard ( new discardattributechecker . discardattributevaluechecker ( attribute . module . getdefinition ( ) . getdefaultvalue ( ) ) , attribute . module . getdefinition ( ) ) . addrejectcheck ( rejectattributechecker . defined , attribute . module . getdefinition ( ) ) . setvalueconverter ( typeconverter , deprecatedattribute . type . getdefinition ( ) ) . end ( ) ; builder . addrawoperationtransformationoverride ( mapoperations . map_get_definition . getname ( ) , new simpleoperationtransformer ( new legacypropertymapgetoperationtransformer ( ) ) ) ; for ( string opname : operations . getallwriteattributeoperationnames ( ) ) { builder . addoperationtransformationoverride ( opname ) . inheritresourceattributedefinitions ( ) . setcustomoperationtransformer ( new legacypropertywriteoperationtransformer ( ) ) ; } } propertyresourcedefinition . buildtransformation ( version , builder ) ; }	Builds transformations common to both stack protocols and transport.
public void removesecuritydomain ( string securitydomain ) { securitymgrmap . remove ( securitydomain ) ; auditmgrmap . remove ( securitydomain ) ; authmgrmap . remove ( securitydomain ) ; authzmgrmap . remove ( securitydomain ) ; idmmgrmap . remove ( securitydomain ) ; mappingmgrmap . remove ( securitydomain ) ; jssemap . remove ( securitydomain ) ; }	Removes one security domain from the maps.
private object lookupjndi ( string contextname ) { object result = null ; try { context ctx = new initialcontext ( ) ; if ( contextname . startswith ( securityconstants . jaas_context_root ) ) result = ctx . lookup ( contextname ) ; else result = ctx . lookup ( securityconstants . jaas_context_root + contextname ) ; } catch ( exception e ) { securitylogger . root_logger . tracef ( str_ , contextname , e . getlocalizedmessage ( ) ) ; return null ; } return result ; }	Lookup a context in JNDI.
public static modularreference create ( final class < ? > type , final class < ? > factoryclass ) { return create ( type . getname ( ) , factoryclass ) ; }	Create a ModuleReference from a target type and factory class.
public static modularreference create ( final string classname , final class < ? > factoryclass ) { return new modularreference ( classname , factoryclass . getname ( ) , module . forclass ( factoryclass ) . getidentifier ( ) ) ; }	Create a ModuleReference from a target class name and factory class.
public static modularreference create ( final class < ? > type , final refaddr addr , final class < ? > factoryclass ) { return create ( type . getname ( ) , addr , factoryclass ) ; }	Create a ModuleReference from a target type, reference address and factory class.
static localidltype getidltype ( typecode typecode , repositoryimpl repository ) { tckind tckind = typecode . kind ( ) ; if ( primitivedefimpl . isprimitivetckind ( tckind ) ) return new primitivedefimpl ( typecode , repository ) ; if ( tckind == tckind . tk_sequence ) return repository . getsequenceimpl ( typecode ) ; if ( tckind == tckind . tk_value || tckind == tckind . tk_value_box || tckind == tckind . tk_alias || tckind == tckind . tk_struct || tckind == tckind . tk_union || tckind == tckind . tk_enum || tckind == tckind . tk_objref ) { try { return ( localidltype ) repository . _lookup_id ( typecode . id ( ) ) ; } catch ( badkind ex ) { throw iioplogger . root_logger . badkindfortypecode ( tckind . value ( ) ) ; } } throw iioplogger . root_logger . badkindfortypecode ( tckind . value ( ) ) ; }	Return the LocalIDLType for the given TypeCode.
private static void waitforservice ( final servicecontroller < ? > controller ) throws operationfailedexception { if ( controller . getstate ( ) == servicecontroller . state . up ) return ; final stabilitymonitor monitor = new stabilitymonitor ( ) ; monitor . addcontroller ( controller ) ; try { monitor . awaitstability ( num_ , milliseconds ) ; } catch ( final interruptedexception e ) { thread . currentthread ( ) . interrupt ( ) ; throw securitylogger . root_logger . interruptedwaitingforsecuritydomain ( controller . getname ( ) . getsimplename ( ) ) ; } finally { monitor . removecontroller ( controller ) ; } if ( controller . getstate ( ) != servicecontroller . state . up ) { throw securitylogger . root_logger . requiredsecuritydomainservicenotavailable ( controller . getname ( ) . getsimplename ( ) ) ; } }	Wait for the required service to start up and fail otherwise.
private string computemaskedpassword ( ) throws exception {	Method to compute masked password based on class attributes.
private void initsecurityvault ( ) throws exception { try { this . vault = securityvaultfactory . get ( ) ; this . vault . init ( getvaultoptionsmap ( ) ) ; handshake ( ) ; } catch ( securityvaultexception e ) { throw securitylogger . root_logger . securityvaultexception ( e ) ; } }	Initialize the underlying vault.
public void startvaultsession ( string vaultalias ) throws exception { if ( vaultalias == null ) { throw securitylogger . root_logger . vaultaliasnotspecified ( ) ; } this . keystoremaskedpassword = ( org . jboss . security . util . ispasswordcommand ( keystorepassword ) ) ? keystorepassword : computemaskedpassword ( ) ; this . vaultalias = vaultalias ; initsecurityvault ( ) ; }	Start the vault with given alias.
private void attributecreateddisplay ( string vaultblock , string attributename ) { system . out . println ( securitylogger . root_logger . vaultattributecreatedisplay ( vaultblock , attributename , securedattributeconfigurationstring ( vaultblock , attributename ) ) ) ; }	Display info about stored secured attribute.
public void vaultconfigurationdisplay ( ) { final string configuration = vaultconfiguration ( ) ; system . out . println ( securitylogger . root_logger . vaultconfigurationtitle ( ) ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( configuration ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ + configuration ) ; system . out . println ( str_ ) ; }	Display info about vault itself in form of AS7 configuration file.
public string vaultconfiguration ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) ; sb . append ( str_ ) . append ( keystoreurl ) . append ( str_ ) . append ( str_ ) ; sb . append ( str_ ) . append ( keystoremaskedpassword ) . append ( str_ ) . append ( str_ ) ; sb . append ( str_ ) . append ( vaultalias ) . append ( str_ ) . append ( str_ ) ; sb . append ( str_ ) . append ( salt ) . append ( str_ ) . append ( str_ ) ; sb . append ( str_ ) . append ( iterationcount ) . append ( str_ ) . append ( str_ ) ; sb . append ( str_ ) . append ( encryptiondirectory ) . append ( str_ ) ; sb . append ( str_ ) ; return sb . tostring ( ) ; }	Returns vault configuration string in user readable form.
public static < t > t notnull ( t value ) { if ( value == null ) throw connectorlogger . root_logger . servicenotstarted ( ) ; return value ; }	convenient method to check notNull of value.
public static synchronized servicename getdeploymentservicename ( final string raname , final activation raxml ) { if ( raname == null ) throw connectorlogger . root_logger . undefinedvar ( str_ ) ; servicename servicename = null ; modifiableresourceadapter ra = ( modifiableresourceadapter ) raxml ; if ( ra != null && ra . getid ( ) != null ) { servicename = getdeploymentservicename ( raname , ra . getid ( ) ) ; } else { servicename = getdeploymentservicename ( raname , ( string ) null ) ; } root_logger . tracef ( str_ , raname , raxml , servicename ) ; return servicename ; }	resource-adapter DMR resource.
public void insertvalue ( any any ) { if ( type == string . class ) any . insert_wstring ( ( string ) value ) ;	Insert the constant value into the argument Any.
public boolean implies ( final jndipermission permission ) { return permission != null && ( ( actionbits & permission . actionbits ) == permission . actionbits ) && impliespath ( permission . getname ( ) ) ; }	Determine if this permission implies the other permission.
public string getactions ( ) { final string actionstring = this . actionstring ; if ( actionstring != null ) { return actionstring ; } int actionbits = this . actionbits ; if ( actionbits == action_all ) { return this . actionstring = str_ ; } int m = integer . lowestonebit ( actionbits ) ; if ( m != num_ ) { stringbuilder b = new stringbuilder ( ) ; b . append ( getaction ( m ) ) ; actionbits &= ~ m ; while ( actionbits != num_ ) { m = integer . lowestonebit ( actionbits ) ; b . append ( str_ ) . append ( getaction ( m ) ) ; actionbits &= ~ m ; } return this . actionstring = b . tostring ( ) ; } else { return this . actionstring = str_ ; } }	Get the actions string.
public string getname ( ) { final string s = log . getname ( ) ; final int i = s . lastindexof ( str_ ) ; return i != - num_ ? s . substring ( i + num_ , s . length ( ) ) : s ; }	Use the short class name as the default for the service name.
private void sendstatechangenotification ( int oldstate , int newstate , string msg , throwable t ) { long now = system . currenttimemillis ( ) ; attributechangenotification statechangenotification = new attributechangenotification ( this , getnextnotificationsequencenumber ( ) , now , msg , str_ , str_ , new integer ( oldstate ) , new integer ( newstate ) ) ; statechangenotification . setuserdata ( t ) ; sendnotification ( statechangenotification ) ; }	Helper for sending out state change notifications.
public object getvalue ( type type ) { if ( type == null || ( type instanceof class ) ) { return getclassvalue ( ( class ) type ) ; } else if ( type instanceof parameterizedtype ) { parameterizedtype pt = ( parameterizedtype ) type ; return getptvalue ( pt ) ; } else { throw pojologger . root_logger . unknowntype ( type ) ; } }	Get value.
public servicename getcontextservicename ( ) { if ( contextservicename != null ) return contextservicename ; if ( getnamingmode ( ) == componentnamingmode . create ) { return contextnames . contextservicenameofcomponent ( getapplicationname ( ) , getmodulename ( ) , getcomponentname ( ) ) ; } else if ( getnamingmode ( ) == componentnamingmode . use_module ) { return contextnames . contextservicenameofmodule ( getapplicationname ( ) , getmodulename ( ) ) ; } else { throw new illegalstateexception ( ) ; } }	Get the context service name.
public set < interceptordescription > getallinterceptors ( ) { if ( allinterceptors == null ) { allinterceptors = new hashset < interceptordescription > ( ) ; allinterceptors . addall ( classinterceptors ) ; if ( ! excludedefaultinterceptors ) { allinterceptors . addall ( defaultinterceptors ) ; } for ( list < interceptordescription > interceptors : methodinterceptors . values ( ) ) { allinterceptors . addall ( interceptors ) ; } } return allinterceptors ; }	Returns a combined map of class and method level interceptors.
public void addmethodinterceptor ( methodidentifier method , interceptordescription description ) {	Add a method interceptor class name.
public void adddependency ( servicename servicename ) { if ( servicename == null ) { throw eelogger . root_logger . nullvar ( str_ , str_ , componentname ) ; } dependencies . add ( servicename ) ; }	Add a dependency to this component.
public list < interceptorfactory > getcomponentinterceptors ( method method ) { map < method , ordereditemcontainer < list < interceptorfactory > > > map = componentinterceptors ; ordereditemcontainer < list < interceptorfactory > > interceptors = map . get ( method ) ; if ( interceptors == null ) { return collections . emptylist ( ) ; } list < list < interceptorfactory > > sorteditems = interceptors . getsorteditems ( ) ; list < interceptorfactory > ret = new arraylist < > ( ) ; for ( list < interceptorfactory > item : sorteditems ) { ret . addall ( item ) ; } return ret ; }	Gets the interceptor list for a given method.
public list < interceptorfactory > getaroundtimeoutinterceptors ( method method ) { map < method , ordereditemcontainer < interceptorfactory > > map = timeoutinterceptors ; ordereditemcontainer < interceptorfactory > interceptors = map . get ( method ) ; if ( interceptors == null ) { return collections . emptylist ( ) ; } return interceptors . getsorteditems ( ) ; }	Gets the around timeout interceptor list for a given method.
public void addtimeoutviewinterceptor ( final method method , interceptorfactory factory , int priority ) { ordereditemcontainer < interceptorfactory > interceptors = timeoutinterceptors . get ( method ) ; if ( interceptors == null ) { timeoutinterceptors . put ( method , interceptors = new ordereditemcontainer < interceptorfactory > ( ) ) ; } interceptors . add ( factory , priority ) ; }	Adds a timeout interceptor factory to every method on the component.
public void addaroundconstructinterceptor ( interceptorfactory interceptorfactory , int priority ) { aroundconstructinterceptors . add ( collections . singletonlist ( interceptorfactory ) , priority ) ; }	Adds an around-construct interceptor.
public void addpostconstructinterceptor ( interceptorfactory interceptorfactory , int priority ) { postconstructinterceptors . add ( collections . singletonlist ( interceptorfactory ) , priority ) ; }	Adds a post construct interceptor.
public void addpredestroyinterceptor ( interceptorfactory interceptorfactory , int priority ) { predestroyinterceptors . add ( collections . singletonlist ( interceptorfactory ) , priority ) ; }	Adds a pre destroy interceptor.
public void addprepassivateinterceptor ( interceptorfactory interceptorfactory , int priority ) { prepassivateinterceptors . add ( collections . singletonlist ( interceptorfactory ) , priority ) ; }	Adds a pre passivate interceptor.
public void addpostactivateinterceptor ( interceptorfactory interceptorfactory , int priority ) { postactivateinterceptors . add ( collections . singletonlist ( interceptorfactory ) , priority ) ; }	Adds a post activate interceptor.
public void setcomponentcreateservicefactory ( final componentcreateservicefactory componentcreateservicefactory ) { if ( componentcreateservicefactory == null ) { throw eelogger . root_logger . nullvar ( str_ , str_ , getcomponentname ( ) ) ; } this . componentcreateservicefactory = componentcreateservicefactory ; }	Set the component create service factory for this component.
protected void removejndialiases ( operationcontext context , list < modelnode > entries ) { if ( entries . size ( ) > num_ ) { for ( int i = num_ ; i < entries . size ( ) ; i ++ ) { contextnames . bindinfo aliasbindinfo = contextnames . bindinfofor ( entries . get ( i ) . asstring ( ) ) ; context . removeservice ( aliasbindinfo . getbinderservicename ( ) ) ; } } }	Remove JNDI alias' binder services.The 1st JNDI entry is not removed by this method as it is already handled when removingthe pooled-connection-factory service.
public void accept ( final ejbclientcontext . builder builder ) { final ejbtransportprovider remotetransportprovider = this . remotetransportprovider ; if ( remotetransportprovider != null ) { builder . addtransportprovider ( remotetransportprovider ) ; builder . addtransportprovider ( remotehttptransportprovider ) ; } }	Perform the configuration of the transport provider.
public static servicename contextservicenameofcomponent ( string app , string module , string comp ) { return component_context_service_name . append ( app , module , comp ) ; }	Get the base service name of a component's JNDI namespace.
public static servicename contextservicenameofmodule ( string app , string module ) { return module_context_service_name . append ( app , module ) ; }	Get the base service name of a module's JNDI namespace.
public static bindinfo bindinfoforenventry ( string app , string module , string comp , boolean usecompnamespace , final string enventryname ) { if ( enventryname . startswith ( str_ ) ) { if ( usecompnamespace ) { return bindinfofor ( app , module , comp , enventryname ) ; } else { if ( enventryname . startswith ( str_ ) ) { return bindinfofor ( app , module , module , str_ + enventryname . substring ( str_ . length ( ) ) ) ; } else { return bindinfofor ( app , module , module , enventryname ) ; } } } else { if ( usecompnamespace ) { return bindinfofor ( app , module , comp , str_ + enventryname ) ; } else { return bindinfofor ( app , module , module , str_ + enventryname ) ; } } }	Get the service name of an environment entry.
public static bindinfo bindinfofor ( final string jndiname ) {	Get the service name of a NamingStore.
public concurrentmap < principal , domaininfo > getcache ( ) { return new lrucache < > ( num_ , ( key , value ) -> { if ( value != null ) { value . logout ( ) ; } } ) ; }	Returns a default cache implementation.
private valuemember [ ] getvaluemembers ( ) { if ( valuemembers != null ) return valuemembers ; localcontained [ ] c = _contents ( definitionkind . dk_valuemember , bool_ ) ; valuemembers = new valuemember [ c . length ] ; for ( int i = num_ ; i < c . length ; ++ i ) { valuememberdefimpl vmdi = ( valuememberdefimpl ) c [ i ] ; valuemembers [ i ] = new valuemember ( vmdi . name ( ) , vmdi . id ( ) , ( ( localcontained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; } return valuemembers ; }	Create the valueMembers array, and return it.
private valuemember [ ] getvaluemembersfortypecode ( ) { localcontained [ ] c = _contents ( definitionkind . dk_valuemember , bool_ ) ; valuemember [ ] vms = new valuemember [ c . length ] ; for ( int i = num_ ; i < c . length ; ++ i ) { valuememberdefimpl vmdi = ( valuememberdefimpl ) c [ i ] ; vms [ i ] = new valuemember ( vmdi . name ( ) , null ,	Create a valueMembers array for TypeCode creation only, and return it.
private modelnode createsubsystemroot ( ) { modelnode subsystemaddress = new modelnode ( ) ; subsystemaddress . add ( modeldescriptionconstants . subsystem , federationextension . subsystem_name ) ; subsystemaddress . protect ( ) ; return util . getemptyoperation ( add , subsystemaddress ) ; }	Creates the root subsystem's root address.
protected modelnode parseconfig ( xmlextendedstreamreader reader , modelelement xmlelement , string key , modelnode lastnode , list < simpleattributedefinition > attributes , list < modelnode > addoperations ) throws xmlstreamexception { if ( ! reader . getlocalname ( ) . equals ( xmlelement . getname ( ) ) ) { return null ; } modelnode modelnode = util . getemptyoperation ( add , null ) ; int attributecount = reader . getattributecount ( ) ; for ( int i = num_ ; i < attributecount ; i ++ ) { string attributelocalname = reader . getattributelocalname ( i ) ; if ( modelelement . forname ( attributelocalname ) == null ) { throw unexpectedattribute ( reader , i ) ; } } for ( simpleattributedefinition simpleattributedefinition : attributes ) { string attributevalue = reader . getattributevalue ( str_ , simpleattributedefinition . getxmlname ( ) ) ; simpleattributedefinition . parseandsetparameter ( attributevalue , modelnode , reader ) ; } string name = xmlelement . getname ( ) ; if ( key != null ) { name = key ; if ( modelnode . hasdefined ( key ) ) { name = modelnode . get ( key ) . asstring ( ) ; } else { string attributevalue = reader . getattributevalue ( str_ , key ) ; if ( attributevalue != null ) { name = attributevalue ; } } } modelnode . get ( modeldescriptionconstants . op_addr ) . set ( lastnode . clone ( ) . get ( op_addr ) . add ( xmlelement . getname ( ) , name ) ) ; addoperations . add ( modelnode ) ; return modelnode ; }	Reads a element from the stream considering the parameters.
public void start ( startcontext context ) throws startexception { root_logger . startingservice ( ) ; try { namingcontext . setactivenamingstore ( namingstore . getvalue ( ) ) ; } catch ( throwable t ) { throw new startexception ( naminglogger . root_logger . failedtostart ( str_ ) , t ) ; } }	Creates a new NamingServer and sets the naming context to use the naming server.
public static servicename joboperatorservicename ( final string deploymentruntimename , final string subdeploymentname ) { return services . deploymentunitname ( deploymentruntimename , subdeploymentname ) . append ( str_ ) . append ( str_ ) ; }	Creates the service name used for the job operator registered for the deployment.
public void addcomponent ( final componentdescription description , final virtualfile deploymentroot ) { for ( final viewdescription viewdescription : description . getviews ( ) ) { list < viewinformation > viewcomponents = componentsbyviewname . get ( viewdescription . getviewclassname ( ) ) ; if ( viewcomponents == null ) { viewcomponents = new arraylist < viewinformation > ( num_ ) ; componentsbyviewname . put ( viewdescription . getviewclassname ( ) , viewcomponents ) ; } viewcomponents . add ( new viewinformation ( viewdescription , deploymentroot , description . getcomponentname ( ) ) ) ; } list < description > components = componentsbyname . get ( description . getcomponentname ( ) ) ; if ( components == null ) { componentsbyname . put ( description . getcomponentname ( ) , components = new arraylist < description > ( num_ ) ) ; } components . add ( new description ( description , deploymentroot ) ) ; }	Add a component to this application.
public void addmessagedestination ( final string name , final string resolvedname , final virtualfile deploymentroot ) { list < messagedestinationmapping > components = messagedestinationjndimapping . get ( name ) ; if ( components == null ) { messagedestinationjndimapping . put ( name , components = new arraylist < messagedestinationmapping > ( num_ ) ) ; } components . add ( new messagedestinationmapping ( resolvedname , deploymentroot ) ) ; }	Add a message destination to the application.
public set < viewdescription > getcomponentsforviewname ( final string viewtype , final virtualfile deploymentroot ) { final list < viewinformation > info = componentsbyviewname . get ( viewtype ) ; if ( info == null ) { return collections . < viewdescription > emptyset ( ) ; } final set < viewdescription > ret = new hashset < viewdescription > ( ) ; final set < viewdescription > currentdep = new hashset < viewdescription > ( ) ; for ( viewinformation i : info ) { if ( deploymentroot . equals ( i . deploymentroot ) ) { currentdep . add ( i . viewdescription ) ; } ret . add ( i . viewdescription ) ; } if ( ! currentdep . isempty ( ) ) { return currentdep ; } return ret ; }	Get all views that have the given type in the application.
public set < componentdescription > getcomponents ( final string componentname , final virtualfile deploymentroot ) { if ( componentname . contains ( str_ ) ) { final string [ ] parts = componentname . split ( str_ ) ; string path = parts [ num_ ] ; if ( ! path . startswith ( str_ ) ) { path = str_ + path ; } final virtualfile virtualpath = deploymentroot . getchild ( path ) ; final string name = parts [ num_ ] ; final list < description > info = componentsbyname . get ( name ) ; if ( info == null ) { return collections . emptyset ( ) ; } final set < componentdescription > ret = new hashset < componentdescription > ( ) ; for ( description i : info ) {	Get all components in the application that have the given name.
public set < viewdescription > getcomponents ( final string componentname , final string viewname , final virtualfile deploymentroot ) { final list < viewinformation > info = componentsbyviewname . get ( viewname ) ; if ( info == null ) { return collections . < viewdescription > emptyset ( ) ; } if ( componentname . contains ( str_ ) ) { final string [ ] parts = componentname . split ( str_ ) ; string path = parts [ num_ ] ; if ( ! path . startswith ( str_ ) ) { path = str_ + path ; } final virtualfile virtualpath = deploymentroot . getchild ( path ) ; final string name = parts [ num_ ] ; final set < viewdescription > ret = new hashset < viewdescription > ( ) ; for ( viewinformation i : info ) { if ( i . beanname . equals ( name ) ) {	Get all views in the application that have the given name and view type.
public set < string > resolvemessagedestination ( final string messagedestname , final virtualfile deploymentroot ) { if ( messagedestname . contains ( str_ ) ) { final string [ ] parts = messagedestname . split ( str_ ) ; string path = parts [ num_ ] ; if ( ! path . startswith ( str_ ) ) { path = str_ + path ; } final virtualfile virtualpath = deploymentroot . getchild ( path ) ; final string name = parts [ num_ ] ; final set < string > ret = new hashset < string > ( ) ; final list < messagedestinationmapping > data = messagedestinationjndimapping . get ( name ) ; if ( data != null ) { for ( final messagedestinationmapping i : data ) {	Resolves a message destination name into a JNDI name.
private static void buildtransformers2_1_0 ( resourcetransformationdescriptionbuilder builder ) { resourcetransformationdescriptionbuilder hornetqserver = builder . addchildresource ( pathelement ( hornetq_server ) ) ; resourcetransformationdescriptionbuilder addresssetting = hornetqserver . addchildresource ( addresssettingdefinition . path ) ; rejectdefinedattributewithdefaultvalue ( addresssetting , max_redelivery_delay , redelivery_multiplier ) ; resourcetransformationdescriptionbuilder bridge = hornetqserver . addchildresource ( bridgedefinition . path ) ; bridge . getattributebuilder ( ) . setvalueconverter ( new doubletobigdecimalconverter ( ) , retry_interval_multiplier ) ; resourcetransformationdescriptionbuilder clusterconnection = hornetqserver . addchildresource ( clusterconnectiondefinition . path ) ; clusterconnection . getattributebuilder ( ) . setvalueconverter ( new doubletobigdecimalconverter ( ) , retry_interval_multiplier ) ; resourcetransformationdescriptionbuilder connectionfactory = hornetqserver . addchildresource ( connectionfactorydefinition . path ) ; connectionfactory . getattributebuilder ( ) . setvalueconverter ( new doubletobigdecimalconverter ( ) , retry_interval_multiplier ) ; resourcetransformationdescriptionbuilder pooledconnectionfactory = hornetqserver . addchildresource ( pooledconnectionfactorydefinition . path ) ; pooledconnectionfactory . getattributebuilder ( ) . setvalueconverter ( new doubletobigdecimalconverter ( ) , retry_interval_multiplier ) ; }	Transformation for WildFly 8.1.0.Final.
private static void rejectdefinedattributewithdefaultvalue ( resourcetransformationdescriptionbuilder builder , attributedefinition ... attrs ) { for ( attributedefinition attr : attrs ) { builder . getattributebuilder ( ) . setdiscard ( new discardattributevaluechecker ( attr . getdefaultvalue ( ) ) , attr ) . addrejectcheck ( defined , attr ) ; } }	Reject the attributes if they are defined or discard them if they are undefined or set to their default value.
public static void popidentity ( final contextstatecache statecache ) { remotingcontext . setconnection ( statecache . getconnection ( ) ) ; securitycontextassociation . setsecuritycontext ( statecache . getsecuritycontext ( ) ) ; }	Pop the identity previously associated and restore internal state to it's previous value.
private void loadidsmanually ( ) { implids . put ( str_ , moduleidentifier . create ( impl_module ) ) ; apiids . put ( str_ , moduleidentifier . create ( api_module ) ) ; injectionids . put ( str_ , moduleidentifier . create ( injection_module ) ) ; allversions . add ( str_ ) ; activeversions . add ( str_ ) ; }	just provide the default implementations.
private void checkversionintegrity ( ) { activeversions . addall ( allversions ) ; for ( string version : allversions ) { if ( ! apiids . containskey ( version ) ) { jsflogger . root_logger . missingjsfmodule ( version , api_module ) ; activeversions . remove ( version ) ; } if ( ! implids . containskey ( version ) ) { jsflogger . root_logger . missingjsfmodule ( version , impl_module ) ; activeversions . remove ( version ) ; } if ( ! injectionids . containskey ( version ) ) { jsflogger . root_logger . missingjsfmodule ( version , injection_module ) ; activeversions . remove ( version ) ; } } }	make sure that each version has api, impl, and injection.
string computeslot ( string jsfversion ) { if ( jsfversion == null ) return defaultslot ; if ( jsfversionmarker . jsf_2_0 . equals ( jsfversion ) ) return defaultslot ; return jsfversion ; }	If needed, convert old JSFVersionMarker values to slot values.
private typecode getconstanttypecode ( class cls ) throws irconstructionexception { if ( cls == null ) throw iioplogger . root_logger . invalidnullclass ( ) ; typecode ret = constanttypecodemap . get ( cls ) ; if ( ret == null ) throw iioplogger . root_logger . badclassforconstant ( cls . getname ( ) ) ; return ret ; }	Returns the TypeCode suitable for an IDL constant.
private void addtypecode ( class cls , typecode typecode ) throws irconstructionexception { if ( cls == null ) throw iioplogger . root_logger . invalidnullclass ( ) ; typecode tc = ( typecode ) typecodemap . get ( cls ) ; if ( tc != null ) throw iioplogger . root_logger . duplicatetypecodeforclass ( cls . getname ( ) ) ; typecodemap . put ( cls , typecode ) ; }	Add a new IDL TypeCode for a mapped class.
private moduledefimpl ensurepackageexists ( localcontainer c , string previous , string remainder ) throws irconstructionexception { if ( str_ . equals ( remainder ) ) return ( moduledefimpl ) c ;	Ensure that a package exists in the IR.This will create modules in the IR as needed.
private string [ ] addinterfaces ( containeranalysis ca ) throws rmiiiopviolationexception , irconstructionexception { interfaceanalysis [ ] interfaces = ca . getinterfaces ( ) ; list base_interfaces = new arraylist ( ) ; for ( int i = num_ ; i < interfaces . length ; ++ i ) { interfacedefimpl idi = addinterface ( interfaces [ i ] ) ; base_interfaces . add ( idi . id ( ) ) ; } string [ ] strarr = new string [ base_interfaces . size ( ) ] ; return ( string [ ] ) base_interfaces . toarray ( strarr ) ; }	Add a set of interfaces to the IR.
private string [ ] addabstractbasevaluetypes ( containeranalysis ca ) throws rmiiiopviolationexception , irconstructionexception { valueanalysis [ ] abstractvaluetypes = ca . getabstractbasevaluetypes ( ) ; list abstract_base_valuetypes = new arraylist ( ) ; for ( int i = num_ ; i < abstractvaluetypes . length ; ++ i ) { valuedefimpl vdi = addvalue ( abstractvaluetypes [ i ] ) ; abstract_base_valuetypes . add ( vdi . id ( ) ) ; } string [ ] strarr = new string [ abstract_base_valuetypes . size ( ) ] ; return ( string [ ] ) abstract_base_valuetypes . toarray ( strarr ) ; }	Add a set of abstract valuetypes to the IR.
private void addclass ( class cls ) throws rmiiiopviolationexception , irconstructionexception { if ( cls . isprimitive ( ) ) return ;	Map the class and add its IIOP mapping to the repository.
private interfacedefimpl addinterface ( interfaceanalysis ia ) throws rmiiiopviolationexception , irconstructionexception { interfacedefimpl idef ; class cls = ia . getcls ( ) ;	Add an interface.
private valuedefimpl addvalue ( valueanalysis va ) throws rmiiiopviolationexception , irconstructionexception { valuedefimpl vdef ; class cls = va . getcls ( ) ;	Add a value type.
private exceptiondefimpl addexception ( exceptionanalysis ea ) throws rmiiiopviolationexception , irconstructionexception { exceptiondefimpl edef ; class cls = ea . getcls ( ) ;	Add an exception type.
private string getclasslevelinjectiontype ( final annotationinstance annotation ) { boolean ispc = annotation . name ( ) . local ( ) . equals ( str_ ) ; return ispc ? entity_manager_class : entity_managerfactory_class ; }	Based on the the annotation type, its either entitymanager or entitymanagerfactory.
public void start ( final startcontext context ) throws startexception { if ( store == null ) { final serviceregistry serviceregistry = context . getcontroller ( ) . getservicecontainer ( ) ; final servicename servicenamebase = context . getcontroller ( ) . getname ( ) ; final servicetarget servicetarget = context . getchildtarget ( ) ; store = readonly ? new servicebasednamingstore ( serviceregistry , servicenamebase ) : new writableservicebasednamingstore ( serviceregistry , servicenamebase , servicetarget ) ; } }	Creates the naming store if not provided by the constructor.
public void stop ( stopcontext context ) { if ( store != null ) { try { store . close ( ) ; store = null ; } catch ( namingexception e ) { throw naminglogger . root_logger . failedtodestroyrootcontext ( e ) ; } } }	Destroys the naming store.
public static void checkallowed ( final methodtype methodtype ) { final interceptorcontext context = currentinvocationcontext . get ( ) ; if ( context == null ) { return ; } final component component = context . getprivatedata ( component . class ) ; if ( ! ( component instanceof ejbcomponent ) ) { return ; } final invocationtype invocationtype = context . getprivatedata ( invocationtype . class ) ; ( ( ejbcomponent ) component ) . getallowedmethodsinformation ( ) . realcheckpermission ( methodtype , invocationtype ) ; }	Checks that the current method.
private void checktransactionsync ( methodtype methodtype ) {	transaction sync is not affected by the current invocation, as multiple ejb methods may be invoked from afterCompletion.
private set < string > getallcomponentclasses ( deploymentunit deploymentunit , compositeindex index , warmetadata metadata , tldsmetadata tldsmetadata ) { final set < string > classes = new hashset < string > ( ) ; getallcomponentclasses ( metadata . getmergedjbosswebmetadata ( ) , classes ) ; if ( tldsmetadata == null ) return classes ; if ( tldsmetadata . getsharedtlds ( deploymentunit ) != null ) for ( tldmetadata tldmetadata : tldsmetadata . getsharedtlds ( deploymentunit ) ) { getallcomponentclasses ( tldmetadata , classes ) ; } if ( tldsmetadata . gettlds ( ) != null ) for ( map . entry < string , tldmetadata > tldmetadata : tldsmetadata . gettlds ( ) . entryset ( ) ) { getallcomponentclasses ( tldmetadata . getvalue ( ) , classes ) ; } getallasynclistenerclasses ( index , classes ) ; return classes ; }	Gets all classes that are eligible for injection etc.
private map < string , timerimpl > getwaitingontxcompletiontimers ( ) { map < string , timerimpl > timers = null ; if ( gettransaction ( ) != null ) { timers = ( map < string , timerimpl > ) tsr . getresource ( waitingontxcompletionkey ) ; } return timers == null ? collections . < string , timerimpl > emptymap ( ) : timers ; }	Returns an unmodifiable view of timers in the current transaction that are waiting for the transactionto finish.
private static map < string , object > getextraparameters ( final set < string > allowedkeys , final map < string , object > parameters ) { map < string , object > extraparameters = new hashmap < > ( ) ; for ( map . entry < string , object > parameter : parameters . entryset ( ) ) { if ( ! allowedkeys . contains ( parameter . getkey ( ) ) ) { extraparameters . put ( parameter . getkey ( ) , parameter . getvalue ( ) ) ; } } for ( string extraparam : extraparameters . keyset ( ) ) { parameters . remove ( extraparam ) ; } return extraparameters ; }	Extract extra parameters from the map of parameters.
public static map < string , object > getparameters ( final operationcontext context , final modelnode config , final map < string , string > mapping ) throws operationfailedexception { map < string , string > frommodel = commonattributes . params . unwrap ( context , config ) ; map < string , object > parameters = new hashmap < > ( ) ; for ( map . entry < string , string > entry : frommodel . entryset ( ) ) { parameters . put ( mapping . getordefault ( entry . getkey ( ) , entry . getkey ( ) ) , entry . getvalue ( ) ) ; } return parameters ; }	Get the parameters.
public static class < ? > toclass ( type type ) { if ( type instanceof class ) { return ( class ) type ; } else if ( type instanceof parameterizedtype ) { parameterizedtype pt = ( parameterizedtype ) type ; return toclass ( pt . getrawtype ( ) ) ; } else { throw pojologger . root_logger . unknowntype ( type ) ; } }	Turn type into class.
@ suppresswarnings ( str_ ) public static object convertvalue ( class < ? > clazz , object value , boolean replaceproperties , boolean trim ) throws throwable { if ( clazz == null ) return value ; if ( value == null ) return null ; class < ? > valueclass = value . getclass ( ) ;	Convert a value.
public static string [ ] gettypes ( valueconfig [ ] values ) { if ( values == null || values . length == num_ ) return no_params_types ; string [ ] types = new string [ values . length ] ; for ( int i = num_ ; i < types . length ; i ++ ) types [ i ] = values [ i ] . gettype ( ) ; return types ; }	Get types from values.
protected static boolean simplecheck ( string [ ] typenames , class < ? > [ ] typeinfos ) { return typenames != null && typeinfos != null && typenames . length == typeinfos . length ; }	A simple null and length check.
public java . lang . object next ( ) throws namingexception { if ( more && counter >= _bindinglist . value . length ) { getmore ( ) ; } if ( more && counter < _bindinglist . value . length ) { org . omg . cosnaming . binding bndg = _bindinglist . value [ counter ] ; counter ++ ; return mapbinding ( bndg ) ; } else { throw new nosuchelementexception ( ) ; } }	Returns the next binding in the list.
private boolean getmore ( ) throws namingexception { try { more = _bindingiter . next_n ( batchsize , _bindinglist ) ; counter = num_ ;	Get the next batch using _bindingIter.
private javax . naming . binding mapbinding ( org . omg . cosnaming . binding bndg ) throws namingexception { java . lang . object obj = _ctx . callresolve ( bndg . binding_name ) ; name cname = org . wildfly . iiop . openjdk . naming . jndi . cnnameparser . cosnametoname ( bndg . binding_name ) ; try { obj = namingmanager . getobjectinstance ( obj , cname , _ctx , _env ) ; } catch ( namingexception e ) { throw e ; } catch ( exception e ) { namingexception ne = iioplogger . root_logger . errorgeneratingobjectviafactory ( ) ; ne . setrootcause ( e ) ; throw ne ; }	Constructs a JNDI Binding object from the COS Naming bindingobject.
public void observeresources ( @ observes @ withannotations ( { health . class } ) processannotatedtype < ? extends healthcheck > event ) { annotatedtype < ? extends healthcheck > annotatedtype = event . getannotatedtype ( ) ; class < ? extends healthcheck > javaclass = annotatedtype . getjavaclass ( ) ; microprofilehealthlogger . logger . infof ( str_ , javaclass ) ; delegates . add ( annotatedtype ) ; }	Discover all classes that implements HealthCheckProcedure.
public void close ( @ observes final beforeshutdown bs ) { healthcheckinstances . foreach ( healthcheck -> { healthreporter . removehealthcheck ( healthcheck . get ( ) ) ; healthcheck . predestroy ( ) . dispose ( ) ; } ) ; healthcheckinstances . clear ( ) ; }	Called when the deployment is undeployed.Remove all the instances of {.
public object handleforlocator ( final ejblocator < ? > locator ) { final org . omg . corba . object reference = referenceforlocator ( locator ) ; if ( locator instanceof ejbhomelocator ) { return new homehandleimpliiop ( orb . getvalue ( ) . object_to_string ( reference ) ) ; } return new handleimpliiop ( orb . getvalue ( ) . object_to_string ( reference ) ) ; }	Gets a handle for the given ejb locator.
public static < e extends enum < e > > e asenum ( modelnode value , class < e > targetclass ) { return enum . valueof ( targetclass , value . asstring ( ) ) ; }	Returns the value of the node as an Enum value.
public static void skip ( inputstream is , long amount ) throws ioexception { long lefttoskip = amount ; long amountskipped = num_ ; while ( lefttoskip > num_ && amountskipped >= num_ ) { amountskipped = is . skip ( lefttoskip ) ; lefttoskip -= amountskipped ; } }	Ensure InputStream actually skips ahead the required number of bytes.
protected static void checknotbothelements ( xmlextendedstreamreader reader , set < element > seen , element element1 , element element2 ) throws xmlstreamexception { if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new xmlstreamexception ( messaginglogger . root_logger . onlyonerequired ( element1 . getlocalname ( ) , element2 . getlocalname ( ) ) , reader . getlocation ( ) ) ; } }	Check that not both elements have been defined.
public void addcomponent ( componentdescription description ) { final string componentname = description . getcomponentname ( ) ; final string componentclassname = description . getcomponentclassname ( ) ; if ( componentname == null ) { throw eelogger . root_logger . nullvar ( str_ , str_ , modulename ) ; } if ( componentclassname == null ) { throw eelogger . root_logger . nullvar ( str_ , str_ , modulename ) ; } if ( componentsbyname . containskey ( componentname ) ) { throw eelogger . root_logger . componentalreadydefined ( componentname ) ; } componentsbyname . put ( componentname , description ) ; list < componentdescription > list = componentsbyclassname . get ( componentclassname ) ; if ( list == null ) { componentsbyclassname . put ( componentclassname , list = new arraylist < componentdescription > ( num_ ) ) ; } list . add ( description ) ; }	Add a component to this module.
public static void addclassloaders ( classloader toplevel , set < classloader > allclassloaders ) { deploymentclassloaders . put ( toplevel , allclassloaders ) ; }	Maps a top level class loader to all CL's in the deployment.
public void unbind ( final name name ) throws namingexception { if ( islastcomponentempty ( name ) ) { throw emptynameexception ( ) ; } writelock . lock ( ) ; try { root . accept ( new unbindvisitor ( name ) ) ; } finally { writelock . unlock ( ) ; } }	Unbind the entry in the provided location.
public object lookup ( final name name ) throws namingexception { if ( isempty ( name ) ) { final name emptyname = new compositename ( str_ ) ; return new namingcontext ( emptyname , this , new hashtable < string , object > ( ) ) ; } return root . accept ( new lookupvisitor ( name ) ) ; }	Lookup the object value of a binding node in the tree.
public list < nameclasspair > list ( final name name ) throws namingexception { final name nodename = name . isempty ( ) ? new compositename ( str_ ) : name ; return root . accept ( new listvisitor ( nodename ) ) ; }	List all NameClassPair instances at a given location in the tree.
public list < binding > listbindings ( final name name ) throws namingexception { final name nodename = name . isempty ( ) ? new compositename ( str_ ) : name ; return root . accept ( new listbindingsvisitor ( nodename ) ) ; }	List all the Binding instances at a given location in the tree.
public synchronized void addfactory ( contexthandlefactory factory ) { final string factoryname = factory . getname ( ) ; if ( factorymap . containskey ( factoryname ) ) { throw eelogger . root_logger . factoryalreadyexists ( this , factoryname ) ; } factorymap . put ( factoryname , factory ) ; final comparator < contexthandlefactory > comparator = new comparator < contexthandlefactory > ( ) { @ override public int compare ( contexthandlefactory o1 , contexthandlefactory o2 ) { return integer . compare ( o1 . getchainpriority ( ) , o2 . getchainpriority ( ) ) ; } } ; sortedset < contexthandlefactory > sortedset = new treeset < > ( comparator ) ; sortedset . addall ( factorymap . values ( ) ) ; factoryorderedlist = new arraylist < > ( sortedset ) ; }	Adds a new factory.
public setupcontexthandle savecontext ( contextservice contextservice , map < string , string > contextobjectproperties ) { final list < setupcontexthandle > handles = new arraylist < > ( factoryorderedlist . size ( ) ) ; for ( contexthandlefactory factory : factoryorderedlist ) { handles . add ( factory . savecontext ( contextservice , contextobjectproperties ) ) ; } return new chainedsetupcontexthandle ( this , handles ) ; }	Saves the current invocation context on a chained context handle.
private void createiosubsystem ( operationcontext context , map < pathaddress , modelnode > migrationoperations , pathaddress baseaddress ) { resource root = context . readresourcefromroot ( baseaddress , bool_ ) ; if ( root . getchildrennames ( subsystem ) . contains ( ioextension . subsystem_name ) ) {	We need to create the IO subsystem, if it does not already exist.
private void createwelcomecontenthandler ( map < pathaddress , modelnode > migrationoperations ) { pathaddress address = pathaddress ( pathelement ( subsystem , undertowextension . subsystem_name ) , pathelement ( constants . configuration , constants . handler ) ) ; migrationoperations . put ( address , createaddoperation ( address ) ) ; address = pathaddress ( pathelement ( subsystem , undertowextension . subsystem_name ) , pathelement ( constants . configuration , constants . handler ) , pathelement ( constants . file , str_ ) ) ; final modelnode add = createaddoperation ( address ) ; add . get ( constants . path ) . set ( new modelnode ( new valueexpression ( str_ ) ) ) ; migrationoperations . put ( address , add ) ; }	create a handler for serving welcome content.
public t get ( ) { try { boolean acquired = semaphore . tryacquire ( timeout , timeunit ) ; if ( ! acquired ) throw ejblogger . root_logger . failedtoacquirepermit ( timeout , timeunit ) ; } catch ( interruptedexception e ) { throw ejblogger . root_logger . acquiresemaphoreinterrupted ( ) ; } t bean = pool . poll ( ) ; if ( bean != null ) {	Get an instance without identity.Can be used by finders,create-methods, and activation.
protected void calculateoperationanalysismap ( ) { operationanalysismap = new hashmap ( ) ; operationanalysis oa ;	Calculate the map that maps IDL operation names to operation analyses.Besides mapped operations, this map also contains the attributeaccessor and mutator operations.
public metricregistration collectresourcemetrics ( final resource resource , immutablemanagementresourceregistration managementresourceregistration , function < pathaddress , pathaddress > resourceaddressresolver ) { metricregistration registration = new metricregistration ( ) ; collectresourcemetrics0 ( resource , managementresourceregistration , empty_address , resourceaddressresolver , registration ) ; return registration ; }	collect metrics from the resources.
protected deploymentunit doprepare ( string context , classloader loader , map < string , string > urlpatterntoclassnamemap , jbosswebmetadata jbwmd , webservicesmetadata metadata , jbosswebservicesmetadata jbwsmetadata ) { classloader origclassloader = wildflysecuritymanager . getcurrentcontextclassloaderprivileged ( ) ; wsendpointdeploymentunit unit = new wsendpointdeploymentunit ( loader , context , urlpatterntoclassnamemap , jbwmd , metadata , jbwsmetadata ) ; try { wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( classloaderprovider . getdefaultprovider ( ) . getserverintegrationclassloader ( ) ) ; wsdeploymentbuilder . getinstance ( ) . build ( unit ) ; return unit ; } finally { wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( origclassloader ) ; } }	Prepare the ws Deployment and return a DeploymentUnit containing it.
protected void dodeploy ( servicetarget target , deploymentunit unit ) { list < deploymentaspect > aspects = getdeploymentaspects ( ) ; classloader origclassloader = wildflysecuritymanager . getcurrentcontextclassloaderprivileged ( ) ; deployment dep = null ; try { wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( classloaderprovider . getdefaultprovider ( ) . getserverintegrationclassloader ( ) ) ; dep = unit . getattachment ( wsattachmentkeys . deployment_key ) ; dep . addattachment ( servicetarget . class , target ) ; deploymentaspectmanager dam = new deploymentaspectmanagerimpl ( ) ; dam . setdeploymentaspects ( aspects ) ; dam . deploy ( dep ) ; } finally { if ( dep != null ) { dep . removeattachment ( servicetarget . class ) ; } wildflysecuritymanager . setcurrentcontextclassloaderprivileged ( origclassloader ) ; } }	Triggers the WS deployment aspects, which process the deployment andinstall the endpoint services.
protected context dopublish ( servicetarget target , deploymentunit unit ) throws exception { deployment deployment = unit . getattachment ( wsattachmentkeys . deployment_key ) ; list < endpoint > endpoints = deployment . getservice ( ) . getendpoints ( ) ;	Publish the webapp for the WS deployment unit.
protected void stopwebapp ( deployment deployment ) throws exception { webdeploymentcontroller context ; try { context = deployment . getattachment ( webdeploymentcontroller . class ) ; context . stop ( ) ; } catch ( exception e ) { throw wslogger . root_logger . stopcontextphasefailed ( e ) ; } try { context . destroy ( ) ; } catch ( exception e ) { throw wslogger . root_logger . destroycontextphasefailed ( e ) ; } }	Stops the webapp serving the provided ws deployment.
public synchronized void start ( final startcontext context ) { if ( started ) { throw weldlogger . root_logger . alreadyrunning ( str_ ) ; } started = bool_ ; weldlogger . deployment_logger . startingweldservice ( deploymentname ) ;	Starts the weld container.
public void registerendpointconfig ( final string endpointclass , final endpointconfig config ) { if ( ( endpointclass == null ) || ( config == null ) ) { throw new illegalargumentexception ( ) ; } endpointconfigmap . put ( endpointclass , config ) ; }	Registers endpoint and its config.
protected void retrytimeout ( timerimpl timer ) throws exception { boolean calltimeout = bool_ ; timer . lock ( ) ; try { if ( timer . isactive ( ) ) { ejb3_timer_logger . retryingtimeout ( timer ) ; timer . settimerstate ( timerstate . retry_timeout , thread . currentthread ( ) ) ; timerservice . persisttimer ( timer , bool_ ) ; calltimeout = bool_ ; } else { ejb3_timer_logger . timernotactive ( timer ) ; } } finally { timer . unlock ( ) ; } if ( calltimeout ) { this . calltimeout ( timer ) ; } }	After a timeout failed the timer need to retried.The method must lock the timer for state check and update but not during callTimeout run.
protected void posttimeoutprocessing ( timerimpl timer ) throws interruptedexception { timer . lock ( ) ; try { timerstate timerstate = timer . getstate ( ) ; if ( timerstate != timerstate . canceled && timerstate != timerstate . expired ) { if ( timer . getinterval ( ) == num_ ) { timerservice . expiretimer ( timer ) ; } else { timer . settimerstate ( timerstate . active , null ) ; } timerservice . persisttimer ( timer , bool_ ) ; } } finally { timer . unlock ( ) ; } }	After running the timer calculate the new state or expire the timer and persist it if changed.The method must lock the timer for state check and updates if overridden.
static method [ ] getdeclaredmethods ( final class < ? > c ) { if ( system . getsecuritymanager ( ) == null ) return c . getdeclaredmethods ( ) ; return accesscontroller . doprivileged ( new privilegedaction < method [ ] > ( ) { public method [ ] run ( ) { return c . getdeclaredmethods ( ) ; } } ) ; }	Get the declared methods.
static field [ ] getdeclaredfields ( final class < ? > c ) { if ( system . getsecuritymanager ( ) == null ) return c . getdeclaredfields ( ) ; return accesscontroller . doprivileged ( new privilegedaction < field [ ] > ( ) { public field [ ] run ( ) { return c . getdeclaredfields ( ) ; } } ) ; }	Get the declared fields.
static constructor < ? > getconstructor ( final class < ? > c , final class < ? > ... params ) throws nosuchmethodexception { if ( system . getsecuritymanager ( ) == null ) return c . getconstructor ( params ) ; constructor < ? > result = accesscontroller . doprivileged ( new privilegedaction < constructor < ? > > ( ) { public constructor < ? > run ( ) { try { return c . getconstructor ( params ) ; } catch ( nosuchmethodexception e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new nosuchmethodexception ( ) ; }	Get the constructor.
static method getmethod ( final class < ? > c , final string name , final class < ? > ... params ) throws nosuchmethodexception { if ( system . getsecuritymanager ( ) == null ) return c . getmethod ( name , params ) ; method result = accesscontroller . doprivileged ( new privilegedaction < method > ( ) { public method run ( ) { try { return c . getmethod ( name , params ) ; } catch ( nosuchmethodexception e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new nosuchmethodexception ( ) ; }	Get the method.
private void addmessagingactivemqextension ( operationcontext context , map < pathaddress , modelnode > migrationoperations , boolean describe ) { resource root = context . readresourcefromroot ( pathaddress . empty_address , bool_ ) ; if ( root . getchildrennames ( extension ) . contains ( messaging_activemq_extension ) ) {	It's possible that the extension is already present.
private boolean parameterisallowed ( string name , string resourcetype ) { switch ( resourcetype ) { case remote_acceptor : case http_acceptor : case remote_connector : case http_connector :	Check if the name of the parameter is allowed for the given resourceType.
private void migrategenerictransport ( modelnode addoperation ) { string factoryclass = addoperation . get ( factory_class . getname ( ) ) . asstring ( ) ; final string newfactoryclass ; switch ( factoryclass ) { case hornetq_netty_acceptor_factory : newfactoryclass = artemis_netty_acceptor_factory ; break ; case hornetq_netty_connector_factory : newfactoryclass = artemis_netty_connector_factory ; break ; default : newfactoryclass = factoryclass ; } addoperation . get ( factory_class . getname ( ) ) . set ( newfactoryclass ) ; }	For generic acceptor and connectors, migrate their factory-class attributeif they are using the default Netty ones.
public boolean cancel ( boolean setflag ) { final atomicinteger stateref = this . stateref ; int oldval , newval ; do { oldval = stateref . get ( ) ; if ( oldval == st_waiting ) { newval = st_cancelled ; } else if ( oldval == st_cancelled ) { if ( ! setflag ) { return bool_ ; } newval = st_cancelled_flag_set ; } else if ( oldval == st_cancelled_flag_set ) {	Attempt to cancel the corresponding invocation.
public boolean runifnotcancelled ( ) { final atomicinteger stateref = this . stateref ; int oldval ; do { oldval = stateref . get ( ) ; if ( oldval == st_cancelled || oldval == st_cancelled_flag_set ) { return bool_ ; } else if ( oldval != st_waiting ) { throw assert . unreachablecode ( ) ; } } while ( ! stateref . compareandset ( oldval , st_started ) ) ; return bool_ ; }	Attempt to determine whether the invocation should proceed or whether it should be cancelled.
protected void settypeinternal ( final otype itype ) { getdatabase ( ) . checksecurity ( orule . resourcegeneric . schema , orole . permission_update ) ; acquireschemawritelock ( ) ; try { if ( itype == globalref . gettype ( ) )	Change the type. It checks for compatibility between the change of type.
public boolean canexecuteindexedfunctionwithoutindex ( ofromclause target , ocommandcontext context , obinarycompareoperator operator , object right ) { if ( this . identifier == null ) { return bool_ ; } return identifier . canexecuteindexedfunctionwithoutindex ( target , context , operator , right ) ; }	tests if current expression is an indexed funciton AND that function can also be executed without using the index.
private static list < class < ? > > findclasses ( final file idirectory , string ipackagename , classloader iclassloader ) throws classnotfoundexception { final list < class < ? > > classes = new arraylist < class < ? > > ( ) ; if ( ! idirectory . exists ( ) ) return classes ; ipackagename += str_ + idirectory . getname ( ) ; string classname ; final file [ ] files = idirectory . listfiles ( ) ; if ( files != null ) for ( file file : files ) { if ( file . isdirectory ( ) ) { if ( file . getname ( ) . contains ( str_ ) ) continue ; classes . addall ( findclasses ( file , ipackagename , iclassloader ) ) ; } else if ( file . getname ( ) . endswith ( class_extension ) ) { classname = file . getname ( ) . substring ( num_ , file . getname ( ) . length ( ) - class_extension . length ( ) ) ; classes . add ( class . forname ( ipackagename + str_ + classname , bool_ , iclassloader ) ) ; } } return classes ; }	Recursive method used to find all classes in a given directory and subdirs.
public static list < class < ? > > getclassessofinterface ( string thepackage , class < ? > theinterface , final classloader iclassloader ) { list < class < ? > > classlist = new arraylist < class < ? > > ( ) ; try { for ( class < ? > discovered : getclassesfor ( thepackage , iclassloader ) ) { if ( arrays . aslist ( discovered . getinterfaces ( ) ) . contains ( theinterface ) ) { classlist . add ( discovered ) ; } } } catch ( classnotfoundexception ex ) { ologmanager . instance ( ) . error ( null , str_ , ex ) ; } return classlist ; }	Filters discovered classes to see if they implement a given interface.
public static class < ? > getgenericmultivaluetype ( final field p ) { if ( p . gettype ( ) instanceof class < ? > ) { final type generictype = p . getgenerictype ( ) ; if ( generictype != null && generictype instanceof parameterizedtype ) { final parameterizedtype pt = ( parameterizedtype ) generictype ; if ( pt . getactualtypearguments ( ) != null && pt . getactualtypearguments ( ) . length > num_ ) { if ( ( ( class < ? > ) pt . getrawtype ( ) ) . isassignablefrom ( map . class ) ) { if ( pt . getactualtypearguments ( ) [ num_ ] instanceof class < ? > ) { return ( class < ? > ) pt . getactualtypearguments ( ) [ num_ ] ; } else if ( pt . getactualtypearguments ( ) [ num_ ] instanceof parameterizedtype ) return ( class < ? > ) ( ( parameterizedtype ) pt . getactualtypearguments ( ) [ num_ ] ) . getrawtype ( ) ; } else if ( pt . getactualtypearguments ( ) [ num_ ] instanceof class < ? > ) { return ( class < ? > ) pt . getactualtypearguments ( ) [ num_ ] ; } else if ( pt . getactualtypearguments ( ) [ num_ ] instanceof parameterizedtype ) return ( class < ? > ) ( ( parameterizedtype ) pt . getactualtypearguments ( ) [ num_ ] ) . getrawtype ( ) ; } } else if ( p . gettype ( ) . isarray ( ) ) return p . gettype ( ) . getcomponenttype ( ) ; } return null ; }	Returns the generic class of multi-value objects.
@ override public object evaluaterecord ( final oidentifiable irecord , odocument icurrentresult , final osqlfiltercondition icondition , final object ileft , final object iright , ocommandcontext icontext , final odocumentserializer serializer ) { if ( ileft == null || iright == null ) return bool_ ; return ileft . tostring ( ) . indexof ( iright . tostring ( ) ) > - num_ ; }	This is executed on non-indexed fields.
protected otype derivefieldtype ( odocument irecord , string fieldname , otype requestedfieldtype ) {	Derives the type of a field in a document.
public void updaterecord ( final orecord record ) { if ( record . getidentity ( ) . getclusterid ( ) != excludedcluster && record . getidentity ( ) . isvalid ( ) && ! record . isdirty ( ) && ! orecordversionhelper . istombstone ( record . getversion ( ) ) ) { if ( underlying . get ( record . getidentity ( ) ) != record ) underlying . put ( record ) ; } }	Pushes record to cache. Identifier of record used as access key.
public orecord findrecord ( final orid rid ) { orecord record ; record = underlying . get ( rid ) ; if ( record != null ) orient . instance ( ) . getprofiler ( ) . updatecounter ( cache_hit , str_ , num_ , str_ ) ; else orient . instance ( ) . getprofiler ( ) . updatecounter ( cache_miss , str_ , num_ , str_ ) ; return record ; }	Looks up for record in cache by it's identifier. Optionally look up in secondary cache and update primary with found record.
private map < string , set < string > > getminimalsetofnodesforshardedquery ( string localnode , map < string , set < string > > clustermap , set < string > queryclusters ) {	given a cluster map and a set of clusters involved in a query, tries to calculate the minimum number of nodes that will have tobe involved in the query execution, with clusters involved for each node.
private static list < oandblock > moveflattededequalitiesleft ( list < oandblock > flattenedwhereclause ) { if ( flattenedwhereclause == null ) { return null ; } list < oandblock > result = new arraylist < > ( ) ; for ( oandblock block : flattenedwhereclause ) { list < obooleanexpression > equalityexpressions = new arraylist < > ( ) ; list < obooleanexpression > nonequalityexpressions = new arraylist < > ( ) ; oandblock newblock = block . copy ( ) ; for ( obooleanexpression exp : newblock . getsubblocks ( ) ) { if ( exp instanceof obinarycondition ) { if ( ( ( obinarycondition ) exp ) . getoperator ( ) instanceof oequalscompareoperator ) { equalityexpressions . add ( exp ) ; } else { nonequalityexpressions . add ( exp ) ; } } else { nonequalityexpressions . add ( exp ) ; } } oandblock newand = new oandblock ( - num_ ) ; newand . getsubblocks ( ) . addall ( equalityexpressions ) ; newand . getsubblocks ( ) . addall ( nonequalityexpressions ) ; result . add ( newand ) ; } return result ; }	re-writes a list of flat AND conditions, moving left all the equality operations.
private static void addorderbyprojections ( queryplanninginfo info ) { if ( info . orderapplied || info . expand || info . unwind != null || info . orderby == null || info . orderby . getitems ( ) . size ( ) == num_ || info . projection == null || info . projection . getitems ( ) == null || ( info . projection . getitems ( ) . size ( ) == num_ && info . projection . getitems ( ) . get ( num_ ) . isall ( ) ) ) { return ; } oorderby neworderby = info . orderby == null ? null : info . orderby . copy ( ) ; list < oprojectionitem > additionalorderbyprojections = calculateadditionalorderbyprojections ( info . projection . getallaliases ( ) , neworderby ) ; if ( additionalorderbyprojections . size ( ) > num_ ) { info . orderby = neworderby ;	creates additional projections for ORDER BY.
private static void extractsubqueries ( queryplanninginfo info ) { subquerycollector collector = new subquerycollector ( ) ; if ( info . perrecordletclause != null ) { info . perrecordletclause . extractsubqueries ( collector ) ; } int i = num_ ; int j = num_ ; for ( map . entry < oidentifier , ostatement > entry : collector . getsubqueries ( ) . entryset ( ) ) { oidentifier alias = entry . getkey ( ) ; ostatement query = entry . getvalue ( ) ; if ( query . referstoparent ( ) ) { addrecordlevellet ( info , alias , query , j ++ ) ; } else { addgloballet ( info , alias , query , i ++ ) ; } } collector . reset ( ) ; if ( info . whereclause != null ) { info . whereclause . extractsubqueries ( collector ) ; } if ( info . projection != null ) { info . projection . extractsubqueries ( collector ) ; } if ( info . orderby != null ) { info . orderby . extractsubqueries ( collector ) ; } if ( info . groupby != null ) { info . groupby . extractsubqueries ( collector ) ; } for ( map . entry < oidentifier , ostatement > entry : collector . getsubqueries ( ) . entryset ( ) ) { oidentifier alias = entry . getkey ( ) ; ostatement query = entry . getvalue ( ) ; if ( query . referstoparent ( ) ) { addrecordlevellet ( info , alias , query ) ; } else { addgloballet ( info , alias , query ) ; } } }	translates subqueries to LET statements.
private boolean isfromclusters ( orid rid , set < string > filterclusters , odatabase database ) { if ( filterclusters == null ) { throw new illegalargumentexception ( ) ; } string clustername = database . getclusternamebyid ( rid . getcluster ( ) . getvalue ( ) . intvalue ( ) ) ; return filterclusters . contains ( clustername ) ; }	checks if this RID is from one of these clusters.
private boolean handleclasswithindexforsortonly ( oselectexecutionplan plan , oidentifier querytarget , set < string > filterclusters , queryplanninginfo info , ocommandcontext ctx , boolean profilingenabled ) { oschema schema = getschemafromcontext ( ctx ) ; oclass clazz = schema . getclass ( querytarget . getstringvalue ( ) ) ; if ( clazz == null ) { clazz = schema . getview ( querytarget . getstringvalue ( ) ) ; if ( clazz == null ) { throw new ocommandexecutionexception ( str_ + querytarget ) ; } } for ( oindex idx : clazz . getindexes ( ) . stream ( ) . filter ( i -> i . supportsorderediterations ( ) ) . filter ( i -> i . getdefinition ( ) != null ) . collect ( collectors . tolist ( ) ) ) { list < string > indexfields = idx . getdefinition ( ) . getfields ( ) ; if ( indexfields . size ( ) < info . orderby . getitems ( ) . size ( ) ) { continue ; } boolean indexfound = bool_ ; string ordertype = null ; for ( int i = num_ ; i < info . orderby . getitems ( ) . size ( ) ; i ++ ) { oorderbyitem orderitem = info . orderby . getitems ( ) . get ( i ) ; if ( orderitem . getcollate ( ) != null ) { return bool_ ; } string indexfield = indexfields . get ( i ) ; if ( i == num_ ) { ordertype = orderitem . gettype ( ) ; } else { if ( ordertype == null || ! ordertype . equals ( orderitem . gettype ( ) ) ) { indexfound = bool_ ; break ;	tries to use an index for sorting only. Also adds the fetch step to the execution plan.
private boolean isdiamondhierarchy ( oclass clazz ) { set < oclass > traversed = new hashset < > ( ) ; list < oclass > stack = new arraylist < > ( ) ; stack . add ( clazz ) ; while ( ! stack . isempty ( ) ) { oclass current = stack . remove ( num_ ) ; traversed . add ( current ) ; for ( oclass sub : current . getsubclasses ( ) ) { if ( traversed . contains ( sub ) ) { return bool_ ; } stack . add ( sub ) ; traversed . add ( sub ) ; } } return bool_ ; }	checks if a class is the top of a diamond hierarchy.
private boolean getorderdirection ( queryplanninginfo info ) { if ( info . orderby == null ) { return null ; } string result = null ; for ( oorderbyitem item : info . orderby . getitems ( ) ) { if ( result == null ) { result = item . gettype ( ) == null ? oorderbyitem . asc : item . gettype ( ) ; } else { string newtype = item . gettype ( ) == null ? oorderbyitem . asc : item . gettype ( ) ; if ( ! newtype . equals ( result ) ) { return null ; } } } return result == null || result . equals ( oorderbyitem . asc ) ; }	returns TRUE if all the order clauses are ASC, FALSE if all are DESC, null otherwise.
private boolean requiresmultipleindexlookups ( oandblock keycondition ) { for ( obooleanexpression obooleanexpression : keycondition . getsubblocks ( ) ) { if ( ! ( obooleanexpression instanceof obinarycondition ) ) { return bool_ ; } } return bool_ ; }	checks whether the condition has CONTAINSANY or similar expressions, that require multiple index evaluations.
private indexsearchdescriptor findbestindexfor ( ocommandcontext ctx , set < oindex < ? > > indexes , oandblock block , oclass clazz ) {	given a flat AND block and a set of indexes, returns the best index to be used to process it, with the complete description onhow to use it.
private list < indexsearchdescriptor > commonfactor ( list < indexsearchdescriptor > indexsearchdescriptors ) {	aggregates multiple index conditions that refer to the same key search.
public odocumentfieldhandlingstrategy create ( int strategy ) { optional < odocumentfieldhandlingstrategy > registered = odocumentfieldhandlingstrategyregistry . getinstance ( ) . getstrategy ( strategy ) ; if ( registered . ispresent ( ) ) { return registered . get ( ) ; } map < otype , odocumentfieldotypehandlingstrategy > typehandlingstrategies = new hashmap < otype , odocumentfieldotypehandlingstrategy > ( ) ; switch ( strategy ) { case single_orecord_bytes : typehandlingstrategies . put ( otype . binary , new odocumentsinglerecordbytesotypehandlingstrategy ( ) ) ; break ; case split_orecord_bytes : typehandlingstrategies . put ( otype . binary , new odocumentsplitrecordbytesotypehandlingstrategy ( ) ) ; break ; case simple : default : break ; } odocumentsmartfieldhandlingstrategy strategyinstance = new odocumentsmartfieldhandlingstrategy ( typehandlingstrategies ) ; odocumentfieldhandlingstrategyregistry . getinstance ( ) . registerstrategy ( strategy , strategyinstance ) ; return strategyinstance ; }	Creates a new instance of the requested strategy.
public orole allow ( final orule . resourcegeneric resourcegeneric , string resourcespecific , final int ioperation ) { if ( roles == null || roles . isempty ( ) ) { if ( document . field ( str_ ) != null && ! ( ( collection < oidentifiable > ) document . field ( str_ ) ) . isempty ( ) ) { final odocument doc = document ; document = null ; fromstream ( doc ) ; } else throw new osecurityaccessexception ( document . getdatabase ( ) . getname ( ) , str_ + document . field ( str_ ) + str_ ) ; } final orole role = checkifallowed ( resourcegeneric , resourcespecific , ioperation ) ; if ( role == null ) throw new osecurityaccessexception ( document . getdatabase ( ) . getname ( ) , str_ + document . field ( str_ ) + str_ + orole . permissiontostring ( ioperation ) + str_ + resourcegeneric + str_ + resourcespecific ) ; return role ; }	Checks if the user has the permission to access to the requested resource for the requested operation.
public boolean isruledefined ( final orule . resourcegeneric resourcegeneric , string resourcespecific ) { for ( orole r : roles ) if ( r == null ) ologmanager . instance ( ) . warn ( this , str_ , getname ( ) ) ; else if ( r . hasrule ( resourcegeneric , resourcespecific ) ) return bool_ ; return bool_ ; }	Checks if a rule was defined for the user.
public static string getcompactserverstatus ( final odistributedservermanager manager , final odocument distribcfg ) { final stringbuilder buffer = new stringbuilder ( ) ; final collection < odocument > members = distribcfg . field ( str_ ) ; if ( members != null ) { buffer . append ( members . size ( ) ) ; buffer . append ( str_ ) ; int membercount = num_ ; for ( odocument m : members ) { if ( m == null ) continue ; if ( membercount ++ > num_ ) buffer . append ( str_ ) ; final string servername = m . field ( str_ ) ; buffer . append ( servername ) ; buffer . append ( ( object ) m . field ( str_ ) ) ; final collection < string > databases = m . field ( str_ ) ; if ( databases != null ) { buffer . append ( str_ ) ; int dbcount = num_ ; for ( string dbname : databases ) { final odistributedconfiguration dbcfg = manager . getdatabaseconfiguration ( dbname , bool_ ) ; if ( dbcfg == null ) continue ; if ( dbcount ++ > num_ ) buffer . append ( str_ ) ; buffer . append ( dbname ) ; buffer . append ( str_ ) ; buffer . append ( manager . getdatabasestatus ( servername , dbname ) ) ; buffer . append ( str_ ) ; buffer . append ( dbcfg . getserverrole ( servername ) ) ; buffer . append ( str_ ) ; } buffer . append ( str_ ) ; } } buffer . append ( str_ ) ; } return buffer . tostring ( ) ; }	Create a compact string with all the relevant information.
protected void initsystemdatabase ( ) { final odocument defaultcfg = getstorage ( osystemdatabase . system_db_name ) . loaddatabaseconfiguration ( getdefaultdatabaseconfigfile ( ) ) ; defaultcfg . field ( str_ , bool_ ) ; final omodifiabledistributedconfiguration syscfg = new omodifiabledistributedconfiguration ( defaultcfg ) ; syscfg . removeserver ( str_ ) ; messageservice . registerdatabase ( osystemdatabase . system_db_name , syscfg ) ; syscfg . addnewnodeinserverlist ( getlocalnodename ( ) ) ; }	Protecte system database from being replicated.
protected void loadlocaldatabases ( ) { final list < string > dbs = new arraylist < string > ( serverinstance . getavailablestoragenames ( ) . keyset ( ) ) ; collections . sort ( dbs ) ; for ( final string databasename : dbs ) { if ( messageservice . getdatabase ( databasename ) == null ) { odistributedserverlog . info ( this , nodename , null , direction . none , str_ , databasename ) ;	Initializes all the available server's databases as distributed.
@ override public void memberremoved ( final membershipevent ievent ) { try { updatelastclusterchange ( ) ; if ( ievent . getmember ( ) == null ) return ; final string nodeleftname = getnodename ( ievent . getmember ( ) ) ; if ( nodeleftname == null ) return ; removeserver ( nodeleftname , bool_ ) ; } catch ( hazelcastinstancenotactiveexception | retryablehazelcastexception e ) { ologmanager . instance ( ) . error ( this , str_ , e ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ , e , getnodename ( ievent . getmember ( ) ) ) ; } }	Removes the node map entry.
@ override public string electnewlockmanager ( ) { if ( hazelcastinstance == null ) throw new hazelcastinstancenotactiveexception ( ) ; final ilock lock = hazelcastinstance . getlock ( str_ ) ; lock . lock ( ) ; try {	Elects a new server as coordinator.
private void assignlockmanagerfromcluster ( ) { string lockmanagerserver = null ; while ( lockmanagerserver == null ) { if ( activenodes . size ( ) == num_ ) {	ASSIGN THE LOCK MANAGER AT STARTUP.
public void commit ( ) { if ( ! active ) throw error ( str_ ) ; if ( level < num_ ) throw error ( str_ + level ) ; -- level ; if ( level == num_ ) { active = bool_ ; docommit ( ) ; } }	Commits the micro-transaction if it's a top-level micro-transaction.
public void rollback ( ) { if ( ! active ) throw error ( str_ ) ; if ( level < num_ ) throw error ( str_ + level ) ; -- level ; if ( level == num_ ) { active = bool_ ; dorollback ( ) ; } }	Rollbacks the micro-transaction if it's a top-level micro-transaction.
public void updateidentityafterrecordcommit ( final orid oldrid , final orid newrid ) { if ( oldrid . equals ( newrid ) ) return ;	Updates the record identity after its successful commit.
public void updaterecordcacheafterrollback ( ) { final olocalrecordcache databaselocalcache = database . getlocalcache ( ) ; for ( orecordoperation recordoperation : recordoperations . values ( ) ) databaselocalcache . deleterecord ( recordoperation . getrecord ( ) . getidentity ( ) ) ; }	Updates the record cache after unsuccessful micro-transaction commit.
public static void prepareforfilecreationorreplacement ( path path , object requester , string operation ) throws ioexception { if ( files . deleteifexists ( path ) ) ologmanager . instance ( ) . warn ( requester , str_ , path , operation ) ; final path parent = path . getparent ( ) ; if ( parent != null ) files . createdirectories ( parent ) ; }	Prepares the path for a file creation or replacement.
public static void atomicmovewithfallback ( path source , path target , object requester ) throws ioexception { try { files . move ( source , target , standardcopyoption . atomic_move ) ; } catch ( atomicmovenotsupportedexception ignore ) { ologmanager . instance ( ) . warn ( requester , str_ , source , target ) ; files . move ( source , target ) ; } }	Tries to move a file from the source to the target atomically.
public list < pattern > getdisjointpatterns ( ) { map < patternnode , string > reversemap = new identityhashmap < > ( ) ; reversemap . putall ( this . aliastonode . entryset ( ) . stream ( ) . collect ( collectors . tomap ( x -> x . getvalue ( ) , x -> x . getkey ( ) ) ) ) ; list < pattern > result = new arraylist < > ( ) ; while ( ! reversemap . isempty ( ) ) { pattern pattern = new pattern ( ) ; result . add ( pattern ) ; map . entry < patternnode , string > nextnode = reversemap . entryset ( ) . iterator ( ) . next ( ) ; set < patternnode > tovisit = new hashset < > ( ) ; tovisit . add ( nextnode . getkey ( ) ) ; while ( tovisit . size ( ) > num_ ) { patternnode currentnode = tovisit . iterator ( ) . next ( ) ; tovisit . remove ( currentnode ) ; if ( reversemap . containskey ( currentnode ) ) { pattern . aliastonode . put ( reversemap . get ( currentnode ) , currentnode ) ; reversemap . remove ( currentnode ) ; for ( patternedge x : currentnode . out ) { tovisit . add ( x . in ) ; } for ( patternedge x : currentnode . in ) { tovisit . add ( x . out ) ; } } } pattern . recalculatenumofedges ( ) ; } return result ; }	splits this pattern into multiple.
protected boolean executeonlylocally ( final string localnodename , final odistributedconfiguration dbcfg , final ocommandexecutor exec , final collection < string > involvedclusters , final collection < string > nodes ) { boolean executelocally = bool_ ; if ( exec . isidempotent ( ) ) { final int availablenodes = nodes . size ( ) ;	Only idempotent commands that don't involve any other node can be executed locally.
@ override public void characters ( char [ ] ch , int start , int length ) throws saxexception { builder . append ( ch , start , length ) ; }	Collect up the characters, as element's characters may be split across multiple calls.
public boolean isconnected ( ) { final socket s = socket ; return s != null && ! s . isclosed ( ) && s . isconnected ( ) && ! s . isinputshutdown ( ) && ! s . isoutputshutdown ( ) ; }	Tells if the channel is connected.
public static short mergeshortfrombuffers ( final bytebuffer buffer , final bytebuffer buffer1 ) { short result = num_ ; result = ( short ) ( result | ( buffer . get ( ) & mask ) ) ; result = ( short ) ( result << size_of_byte_in_bits ) ; result = ( short ) ( result | ( buffer1 . get ( ) & mask ) ) ; return result ; }	Merge short value from two byte buffer.
public static void splitshorttobuffers ( final bytebuffer buffer , final bytebuffer buffer1 , final short ivalue ) { buffer . put ( ( byte ) ( mask & ( ivalue > > > size_of_byte_in_bits ) ) ) ; buffer1 . put ( ( byte ) ( mask & ivalue ) ) ; }	Split short value into two byte buffer.
public object execute ( final map < object , object > iargs ) { if ( type == null ) throw new ocommandexecutionexception ( str_ ) ; final odatabasedocument database = getdatabase ( ) ; final oclassembedded sourceclass = ( oclassembedded ) database . getmetadata ( ) . getschema ( ) . getclass ( classname ) ; if ( sourceclass == null ) throw new ocommandexecutionexception ( str_ + classname + str_ ) ; opropertyimpl prop = ( opropertyimpl ) sourceclass . getproperty ( fieldname ) ; if ( prop != null ) { if ( ifnotexists ) { return sourceclass . properties ( ) . size ( ) ; } throw new ocommandexecutionexception ( str_ + classname + str_ + fieldname + str_ ) ; }	Execute the CREATE PROPERTY.
@ override public oindexfulltext put ( object key , final oidentifiable singlevalue ) { if ( key == null ) { return this ; } key = getcollatingvalue ( key ) ; final set < string > words = splitintowords ( key . tostring ( ) ) ;	Indexes a value and save the index.
@ override public boolean remove ( object key , final oidentifiable value ) { if ( key == null ) { return bool_ ; } key = getcollatingvalue ( key ) ; final set < string > words = splitintowords ( key . tostring ( ) ) ; final omodifiableboolean removed = new omodifiableboolean ( bool_ ) ; for ( final string word : words ) { acquiresharedlock ( ) ; try { if ( apiversion == num_ ) { removev0 ( value , removed , word ) ; } else if ( apiversion == num_ ) { removev1 ( value , removed , word ) ; } else { throw new illegalstateexception ( str_ + apiversion ) ; } } finally { releasesharedlock ( ) ; } } return removed . getvalue ( ) ; }	Splits passed in key on several words and remove records with keys equals to any item of split result and values equals topassed in value.
@ suppresswarnings ( str_ ) public list < t > run ( final object ... iargs ) { final odatabasedocumentinternal database = odatabaserecordthreadlocal . instance ( ) . get ( ) ; if ( database == null ) throw new oqueryparsingexception ( str_ ) ; ( ( ometadatainternal ) database . getmetadata ( ) ) . makethreadlocalschemasnapshot ( ) ; try { setparameters ( iargs ) ; object o = database . getstorage ( ) . command ( this ) ; if ( o instanceof list ) { return ( list < t > ) o ; } else { return ( list < t > ) collections . singletonlist ( o ) ; } } finally { ( ( ometadatainternal ) database . getmetadata ( ) ) . clearthreadlocalschemasnapshot ( ) ; } }	Delegates to the OQueryExecutor the query execution.
public t runfirst ( final object ... iargs ) { setlimit ( num_ ) ; final list < t > result = execute ( iargs ) ; return result != null && ! result . isempty ( ) ? result . get ( num_ ) : null ; }	Returns only the first record if any.
public void create ( ) throws ioexception { acquirewritelock ( ) ; try { acquireexclusiveaccess ( ) ; openchannel ( ) ; init ( ) ; setversion ( ofileclassic . current_version ) ; version = ofileclassic . current_version ; initallocationmode ( ) ; } finally { releasewritelock ( ) ; } }	Creates the file.
private long checkregions ( final long ioffset , final long ilength ) { acquirereadlock ( ) ; try { if ( ioffset < num_ || ioffset + ilength > size ) { throw new oioexception ( str_ + size + str_ + ioffset + str_ + ( ioffset + ilength ) + str_ + this ) ; } return ioffset + header_size ; } finally { releasereadlock ( ) ; } }	ALWAYS ADD THE HEADER SIZE BECAUSE ON THIS TYPE IS ALWAYS NEEDED.
public void replacecontentwith ( final path newcontentfile ) throws ioexception { acquirewritelock ( ) ; try { close ( ) ; files . copy ( newcontentfile , osfile , standardcopyoption . replace_existing ) ; open ( ) ; } finally { releasewritelock ( ) ; } }	Replaces the file content with the content of the provided file.
public object command ( final ocommandrequesttext icommand ) { final boolean live = icommand instanceof olivequery ; final odatabasedocumentinternal database = odatabaserecordthreadlocal . instance ( ) . get ( ) ; final boolean asynch = icommand instanceof ocommandrequestasynch && ( ( ocommandrequestasynch ) icommand ) . isasynchronous ( ) ; ocommandrequest request = new ocommandrequest ( database , asynch , icommand , live ) ; ocommandresponse response = networkoperation ( request , str_ + icommand ) ; return response . getresult ( ) ; }	Execute the command remotely and get the results back.
public void endrequest ( final ochannelbinaryasynchclient inetwork ) throws ioexception { if ( inetwork == null ) return ; inetwork . flush ( ) ; inetwork . releasewritelock ( ) ; }	Ends the request and unlock the write lock.
protected string addhost ( string host ) { if ( host . startswith ( localhost ) ) host = local_ip + host . substring ( str_ . length ( ) ) ; if ( host . contains ( str_ ) ) host = host . substring ( num_ , host . indexof ( str_ ) ) ;	Registers the remote server with port.
public ochannelbinaryasynchclient beginrequest ( final ochannelbinaryasynchclient network , final byte icommand , ostorageremotesession session ) throws ioexception { network . beginrequest ( icommand , session ) ; return network ; }	Acquire a network channel from the pool.
protected static oobjectdatabasetx getdatabase ( ) { odatabaseinternal < ? > databaseowner = odatabaserecordthreadlocal . instance ( ) . get ( ) . getdatabaseowner ( ) ; if ( databaseowner instanceof oobjectdatabasetx ) { return ( oobjectdatabasetx ) databaseowner ; } else if ( databaseowner instanceof odatabasedocumentinternal ) { return new oobjectdatabasetx ( ( odatabasedocumentinternal ) databaseowner ) ; } throw new illegalstateexception ( str_ ) ; }	Gets the current thread database as a ODatabasePojoAbstract, wrapping it where necessary.
public oclientconnection getconnection ( final int ichannelid , onetworkprotocol protocol ) {	Retrieves the connection by id.
public void kill ( final oclientconnection connection ) { if ( connection != null ) { final onetworkprotocol protocol = connection . getprotocol ( ) ; try {	Disconnects and kill the associated network manager.
public void interrupt ( final int ichannelid ) { final oclientconnection connection = connections . get ( ichannelid ) ; if ( connection != null ) { final onetworkprotocol protocol = connection . getprotocol ( ) ; if ( protocol != null )	Interrupt the associated network manager.
public boolean disconnect ( final int ichannelid ) { ologmanager . instance ( ) . debug ( this , str_ , ichannelid ) ; final oclientconnection connection = connections . remove ( ichannelid ) ; if ( connection != null ) { oserverpluginhelper . invokehandlercallbackonclientdisconnection ( server , connection ) ; connection . close ( ) ; removeconnectionfromsession ( connection ) ;	Disconnects a client connections.
public void pushdistribcfg2clients ( final odocument iconfig ) { if ( iconfig == null ) return ; final set < string > pushed = new hashset < string > ( ) ; for ( oclientconnection c : connections . values ( ) ) { if ( ! c . getdata ( ) . supportslegacypushmessages ) continue ; try { final string remoteaddress = c . getremoteaddress ( ) ; if ( pushed . contains ( remoteaddress ) )	Pushes the distributed configuration to all the connected clients.
public boolean swap ( int index , oidentifiable newvalue ) { entriesiterator iter = ( entriesiterator ) rawiterator ( ) ; int currindex = num_ ; while ( iter . hasnext ( ) ) { iter . next ( ) ; if ( index == currindex ) { iter . swapvalueoncurrent ( newvalue ) ; return bool_ ; } currindex ++ ; } return bool_ ; }	for internal use only.
@ override public void close ( ) { for ( map . entry < orid , lockedrecordmetadata > lock : locks . entryset ( ) ) { try { final lockedrecordmetadata lockedrecordmetadata = lock . getvalue ( ) ; if ( lockedrecordmetadata . strategy . equals ( ostorage . locking_strategy . exclusive_lock ) ) { ( ( oabstractpaginatedstorage ) getdatabase ( ) . getstorage ( ) . getunderlying ( ) ) . releasewritelock ( lock . getkey ( ) ) ; } else if ( lockedrecordmetadata . strategy . equals ( ostorage . locking_strategy . shared_lock ) ) { ( ( oabstractpaginatedstorage ) getdatabase ( ) . getstorage ( ) . getunderlying ( ) ) . releasereadlock ( lock . getkey ( ) ) ; } } catch ( exception e ) { ologmanager . instance ( ) . debug ( this , str_ + lock . getkey ( ) , e ) ; } } locks . clear ( ) ; }	Closes the transaction and releases all the acquired locks.
public synchronized void synchronizeschema ( ) { oobjectdatabasetx database = ( ( oobjectdatabasetx ) odatabaserecordthreadlocal . instance ( ) . get ( ) . getdatabaseowner ( ) ) ; collection < class < ? > > registeredentities = database . getentitymanager ( ) . getregisteredentities ( ) ; boolean automaticschemageneration = database . isautomaticschemageneration ( ) ; boolean reloadschema = bool_ ; for ( class < ? > iclass : registeredentities ) { if ( proxy . class . isassignablefrom ( iclass ) || iclass . isenum ( ) || oreflectionhelper . isjavatype ( iclass ) || iclass . isanonymousclass ( ) ) return ; if ( ! database . getmetadata ( ) . getschema ( ) . existsclass ( iclass . getsimplename ( ) ) ) { database . getmetadata ( ) . getschema ( ) . createclass ( iclass . getsimplename ( ) ) ; reloadschema = bool_ ; } for ( class < ? > currentclass = iclass ; currentclass != object . class ; ) { if ( automaticschemageneration && ! currentclass . equals ( object . class ) && ! currentclass . equals ( odocument . class ) ) { ( ( oschemaproxyobject ) database . getmetadata ( ) . getschema ( ) ) . generateschema ( currentclass , database . getunderlying ( ) ) ; } string iclassname = currentclass . getsimplename ( ) ; currentclass = currentclass . getsuperclass ( ) ; if ( currentclass == null || currentclass . equals ( odocument . class ) )	Checks if all registered entities has schema generated, if not it generates it.
protected void updatemetadata ( final string iname , final string idescription , final metric_type itype ) { if ( idescription != null && dictionary . putifabsent ( iname , idescription ) == null ) types . put ( iname , itype ) ; }	Updates the metric metadata.
@ override public orecorditeratorclusters < rec > last ( ) { if ( clusterids . length == num_ ) return this ; browsedrecords = num_ ; currentclusteridx = clusterids . length - num_ ; updateclusterrange ( ) ; current . setclusterid ( clusterids [ currentclusteridx ] ) ; resetcurrentposition ( ) ; prevposition ( ) ; final orecord record = getrecord ( ) ; currentrecord = readcurrentrecord ( record , num_ ) ; if ( currentrecord != null && ! include ( currentrecord ) ) { currentrecord = null ; hasprevious ( ) ; } return this ; }	Move the iterator to the end of the range.
public int nextchar ( ) throws ioexception { if ( missedchar != null ) {	Returns the next character from the input stream.
public object execute ( final map < object , object > iargs ) { if ( recordids . isempty ( ) && subquery == null ) throw new ocommandexecutionexception ( str_ ) ; if ( subquery != null ) { final list < oidentifiable > result = new ocommandsql ( subquery . tostring ( ) ) . execute ( ) ; for ( oidentifiable id : result ) recordids . add ( id . getidentity ( ) ) ; } return ofindreferencehelper . findreferences ( recordids , classlist ) ; }	Execute the FIND REFERENCES.
@ override public ocommandrequestabstract onasyncreplicationerror ( final oasyncreplicationerror icallback ) { if ( icallback != null ) { onasyncreplicationerror = new oasyncreplicationerror ( ) { int retry = num_ ; @ override public action onasyncreplicationerror ( throwable iexception , final int iretry ) { switch ( icallback . onasyncreplicationerror ( iexception , ++ retry ) ) { case retry : execute ( ) ; break ; case ignore : } return action . ignore ; } } ; } else onasyncreplicationerror = null ; return this ; }	Defines a callback to call in case of error during the asynchronous replication.
public void register ( final class < ? extends ocompression > compression ) { try { final ocompression tempinstance = compression . newinstance ( ) ; final string name = tempinstance . name ( ) ; if ( compressions . containskey ( name ) ) throw new illegalargumentexception ( str_ + name + str_ ) ; if ( compressionclasses . containskey ( tempinstance . name ( ) ) ) throw new illegalargumentexception ( str_ + name + str_ ) ; compressionclasses . put ( name , compression ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ , e , compression ) ; } }	Registers a stateless implementations, the same instance will be shared on all the storages.
public int getopenfileslimit ( boolean verbose , int recommended , int deflimit ) { if ( platform . islinux ( ) ) { final oclibrary . rlimit rlimit = new oclibrary . rlimit ( ) ; final int result = c_library . getrlimit ( oclibrary . rlimit_nofile , rlimit ) ; if ( result == num_ && rlimit . rlim_cur > num_ ) { if ( verbose ) { ologmanager . instance ( ) . infonodb ( this , str_ + str_ , rlimit . rlim_cur , rlimit . rlim_cur / num_ - num_ ) ; } if ( rlimit . rlim_cur < recommended ) { ologmanager . instance ( ) . warnnodb ( this , str_ , recommended ) ; } return ( int ) rlimit . rlim_cur / num_ - num_ ; } else { if ( verbose ) { ologmanager . instance ( ) . infonodb ( this , str_ ) ; } } } else if ( platform . iswindows ( ) ) { if ( verbose ) { ologmanager . instance ( ) . infonodb ( this , str_ , recommended ) ; } return recommended ; } if ( verbose ) { ologmanager . instance ( ) . infonodb ( this , str_ , deflimit ) ; } return deflimit ; }	Detects limit of limit of open files.
public boolean allowsindexedfunctionexecutionontarget ( ofromclause target , ocommandcontext context , obinarycompareoperator operator , object right ) { if ( this . childexpressions . size ( ) != num_ ) { return bool_ ; } return this . childexpressions . get ( num_ ) . allowsindexedfunctionexecutionontarget ( target , context , operator , right ) ; }	tests if current expression is an indexed function AND that function can be used on this target.
public void move ( final int ifrom , final int iposition ) { if ( iposition == num_ ) return ; final int to = ifrom + iposition ; final int size = iposition > num_ ? buffer . length - to : buffer . length - ifrom ; system . arraycopy ( buffer , ifrom , buffer , to , size ) ; }	Move bytes left or right of an offset.
public void fill ( final int ilength , final byte ifiller ) { assurespacefor ( ilength ) ; arrays . fill ( buffer , position , position + ilength , ifiller ) ; position += ilength ; }	Fills the stream from current position writing iLength times the iFiller byte.
public oexecutionstepinternal executeuntilreturn ( ) { if ( steps . size ( ) > num_ ) { laststep = steps . get ( steps . size ( ) - num_ ) ; } for ( int i = num_ ; i < steps . size ( ) - num_ ; i ++ ) { scriptlinestep step = steps . get ( i ) ; if ( step . containsreturn ( ) ) { oexecutionstepinternal returnstep = step . executeuntilreturn ( ctx ) ; if ( returnstep != null ) { laststep = returnstep ; return laststep ; } } oresultset lastresult = step . syncpull ( ctx , num_ ) ; while ( lastresult . hasnext ( ) ) { while ( lastresult . hasnext ( ) ) { lastresult . next ( ) ; } lastresult = step . syncpull ( ctx , num_ ) ; } } this . laststep = steps . get ( steps . size ( ) - num_ ) ; return laststep ; }	executes all the script and returns last statement execution step, so that it can be executed from outside.
public oexecutionstepinternal executefull ( ) { for ( int i = num_ ; i < steps . size ( ) ; i ++ ) { scriptlinestep step = steps . get ( i ) ; if ( step . containsreturn ( ) ) { oexecutionstepinternal returnstep = step . executeuntilreturn ( ctx ) ; if ( returnstep != null ) { return returnstep ; } } oresultset lastresult = step . syncpull ( ctx , num_ ) ; while ( lastresult . hasnext ( ) ) { while ( lastresult . hasnext ( ) ) { lastresult . next ( ) ; } lastresult = step . syncpull ( ctx , num_ ) ; } } return null ; }	executes the whole script and returns last statement ONLY if it's a RETURN, otherwise it returns null;.
@ override public object evaluaterecord ( final oidentifiable irecord , odocument icurrentresult , final osqlfiltercondition icondition , final object ileft , final object iright , ocommandcontext icontext , final odocumentserializer serializer ) { return bool_ ; }	At run-time the evaluation per record must return always true since the recordset are filtered at the beginning unless anoperator can work in both modes.
public object execute ( final map < object , object > iargs ) { odatabasedocumentinternal db = getdatabase ( ) ; db . begin ( ) ; if ( classname == null && clustername == null ) throw new ocommandexecutionexception ( str_ ) ; omodifiableboolean shutdowngraph = new omodifiableboolean ( ) ; final boolean txalreadybegun = getdatabase ( ) . gettransaction ( ) . isactive ( ) ; try { final set < oidentifiable > sourcerids = osqlengine . getinstance ( ) . parseridtarget ( db , source , context , iargs ) ;	Executes the command and return the ODocument object created.
public ostorageconfigurationimpl load ( final ocontextconfiguration configuration ) throws oserializationexception { lock . acquirewritelock ( ) ; try { initconfiguration ( configuration ) ; final byte [ ] record = storage . readrecord ( config_rid , null , bool_ , bool_ , null ) . getresult ( ) . buffer ; if ( record == null ) throw new ostorageexception ( str_ ) ; fromstream ( record , num_ , record . length , streamcharset ) ; } finally { lock . releasewritelock ( ) ; } return this ; }	This method load the record information by the internal cluster segment.
@ override public < ret extends ocommandexecutor > ret parse ( ocommandrequest irequest ) { final ocommandrequesttext textrequest = ( ocommandrequesttext ) irequest ; if ( irequest instanceof osqlsynchquery ) { request = ( osqlsynchquery < odocument > ) irequest ; } else if ( irequest instanceof osqlasynchquery ) { request = ( osqlasynchquery < odocument > ) irequest ; } else {	this method parses the statement.
@ override public object execute ( map < object , object > iargs ) { this . context . setinputparameters ( iargs ) ; return execute ( this . request , this . context , this . progresslistener ) ; }	this method works statefully, using request and context variables from current Match statement. This method will be deprecatedin next releases.
private void updateschedulestartingat ( patternnode startnode , set < patternnode > visitednodes , set < patternedge > visitededges , map < string , set < string > > remainingdependencies , list < edgetraversal > resultingschedule ) {	Start a depth-first traversal from the starting node, adding all viable unscheduled edges and vertices.
public void addindex ( final oindexdefinition indexdefinition ) { indexdefinitions . add ( indexdefinition ) ; if ( indexdefinition instanceof oindexdefinitionmultivalue ) { if ( multivaluedefinitionindex == - num_ ) multivaluedefinitionindex = indexdefinitions . size ( ) - num_ ; else throw new oindexexception ( str_ ) ; } collate . addcollate ( indexdefinition . getcollate ( ) ) ; }	Add new indexDefinition in current composite.
public oprojectionitem splitforaggregation ( aggregateprojectionsplit aggregatesplit , ocommandcontext ctx ) { if ( isaggregate ( ) ) { oprojectionitem result = new oprojectionitem ( - num_ ) ; result . alias = getprojectionalias ( ) ; result . expression = expression . splitforaggregation ( aggregatesplit , ctx ) ; result . nestedprojection = nestedprojection ; return result ; } else { return this ; } }	INTERNAL USE ONLY this has to be invoked ONLY if the item is aggregate!!!.
public object toobjectdeterminetype ( oresult source , ocommandcontext ctx ) { string classname = getclassnamefordocument ( ctx ) ; string type = gettypefordocument ( ctx ) ; if ( classname != null || ( type != null && str_ . equalsignorecase ( type ) ) ) { return todocument ( source , ctx , classname ) ; } else { return tomap ( source , ctx ) ; } }	choosing return type is based on existence of .
public ocollate getcollate ( object doc ) { if ( collate != null || operationschain == null || ! isfieldchain ( ) ) { return collate ; } if ( ! ( doc instanceof oidentifiable ) ) { return null ; } fieldchain chain = getfieldchain ( ) ; odocument lastdoc = ( ( oidentifiable ) doc ) . getrecord ( ) ; for ( int i = num_ ; i < chain . getitemcount ( ) - num_ ; i ++ ) { if ( lastdoc == null ) { return null ; } object nextdoc = lastdoc . field ( chain . getitemname ( i ) ) ; if ( nextdoc == null || ! ( nextdoc instanceof oidentifiable ) ) { return null ; } lastdoc = ( ( oidentifiable ) nextdoc ) . getrecord ( ) ; } if ( lastdoc == null ) { return null ; } oclass schemaclass = lastdoc . getschemaclass ( ) ; if ( schemaclass == null ) { return null ; } oproperty property = schemaclass . getproperty ( chain . getitemname ( chain . getitemcount ( ) - num_ ) ) ; if ( property == null ) { return null ; } return property . getcollate ( ) ; }	get the collate of this expression, based on the fully evaluated field chain starting from the passed object.
public string getstringvalue ( ) { if ( value == null ) { return null ; } if ( value . contains ( str_ ) ) { return value . replaceall ( str_ , str_ ) ; } return value ; }	returns the plain string representation of this identifier, with quoting removed from back-ticks.
private int advanceprobe ( int probe ) { probe ^= probe << num_ ;	Pseudo-randomly advances and records the given probe value for the given thread.
public object execute ( final map < object , object > iargs ) { if ( clustername == null ) throw new ocommandexecutionexception ( str_ ) ; final odatabasedocumentinternal database = getdatabase ( ) ;	Execute the DROP CLUSTER.
public static odocument buildjsonfromfile ( string filepath ) throws ioexception { if ( filepath == null ) { return null ; } file jsonfile = new file ( filepath ) ; if ( ! jsonfile . exists ( ) ) { return null ; } fileinputstream is = new fileinputstream ( jsonfile ) ; bufferedreader rd = new bufferedreader ( new inputstreamreader ( is , charset . forname ( str_ ) ) ) ; odocument json = new odocument ( ) ; string jsontext = ofilemanager . readalltextfile ( rd ) ; json . fromjson ( jsontext , str_ ) ; return json ; }	It returns a ODocument starting from a json file.
public boolean checkpassword ( final string ipassword , final string ihash ) { if ( ihash . startswith ( hash_algorithm_prefix ) ) { final string s = ihash . substring ( hash_algorithm_prefix . length ( ) ) ; return createsha256 ( ipassword ) . equals ( s ) ; } else if ( ihash . startswith ( pbkdf2_algorithm_prefix ) ) { final string s = ihash . substring ( pbkdf2_algorithm_prefix . length ( ) ) ; return checkpasswordwithsalt ( ipassword , s , pbkdf2_algorithm ) ; } else if ( ihash . startswith ( pbkdf2_sha256_algorithm_prefix ) ) { final string s = ihash . substring ( pbkdf2_sha256_algorithm_prefix . length ( ) ) ; return checkpasswordwithsalt ( ipassword , s , pbkdf2_sha256_algorithm ) ; }	Checks if an hash string matches a password, based on the algorithm found on hash string.
public string createhash ( final string iinput , final string ialgorithm , final boolean iincludealgorithm ) { if ( iinput == null ) throw new illegalargumentexception ( str_ ) ; if ( ialgorithm == null ) throw new illegalargumentexception ( str_ ) ; final stringbuilder buffer = new stringbuilder ( num_ ) ; final string algorithm = validatealgorithm ( ialgorithm ) ; if ( iincludealgorithm ) { buffer . append ( str_ ) ; buffer . append ( algorithm ) ; buffer . append ( str_ ) ; } final string transformed ; if ( hash_algorithm . equalsignorecase ( algorithm ) ) { transformed = createsha256 ( iinput ) ; } else if ( pbkdf2_algorithm . equalsignorecase ( algorithm ) ) { transformed = createhashwithsalt ( iinput , oglobalconfiguration . security_user_password_salt_iterations . getvalueasinteger ( ) , algorithm ) ; } else if ( pbkdf2_sha256_algorithm . equalsignorecase ( algorithm ) ) { transformed = createhashwithsalt ( iinput , oglobalconfiguration . security_user_password_salt_iterations . getvalueasinteger ( ) , algorithm ) ; } else throw new illegalargumentexception ( str_ + algorithm + str_ ) ; buffer . append ( transformed ) ; return buffer . tostring ( ) ; }	Hashes the input string.
private static boolean isalgorithmsupported ( final string algorithm ) {	Returns true if the algorithm is supported by the current version of Java.
public oindexinternal < ? > create ( final oindexdefinition indexdefinition , final string clusterindexname , final set < string > clusterstoindex , boolean rebuild , final oprogresslistener progresslistener , final obinaryserializer valueserializer ) { acquireexclusivelock ( ) ; try { configuration = indexconfigurationinstance ( new odocument ( ) . settrackingchanges ( bool_ ) ) ; this . indexdefinition = indexdefinition ; if ( clusterstoindex != null ) this . clusterstoindex = new hashset < > ( clusterstoindex ) ; else this . clusterstoindex = new hashset < > ( ) ;	Creates the index.
@ override public iterable < vertex > vertices ( ) { if ( limit == num_ ) return collections . emptylist ( ) ; otransaction transaction = ( ( orientbasegraph ) graph ) . getrawgraph ( ) . gettransaction ( ) ; if ( transaction . isactive ( ) && transaction . getentrycount ( ) > num_ || hascustompredicate ( ) ) {	Returns the result set of the query as iterable vertices.
@ override public iterable < edge > edges ( ) { if ( limit == num_ ) return collections . emptylist ( ) ; if ( ( ( orientbasegraph ) graph ) . getrawgraph ( ) . gettransaction ( ) . isactive ( ) || hascustompredicate ( ) )	Returns the result set of the query as iterable edges.
@ override public int [ ] getpartitionkey ( ) { if ( tasks . size ( ) == num_ )	Return the partition keys of all the sub-tasks.
@ override public long getdistributedtimeout ( ) { final long to = oglobalconfiguration . distributed_crud_task_synch_timeout . getvalueaslong ( ) ; return to + ( ( to / num_ ) * tasks . size ( ) ) ; }	Computes the timeout according to the transaction size.
public features getfeatures ( ) { makeactive ( ) ; if ( ! featuresinitialized ) { features . supportsduplicateedges = bool_ ; features . supportsselfloops = bool_ ; features . ispersistent = bool_ ; features . supportsvertexiteration = bool_ ; features . supportsvertexindex = bool_ ; features . ignoressuppliedids = bool_ ; features . supportstransactions = bool_ ; features . supportsvertexkeyindex = bool_ ; features . supportskeyindices = bool_ ; features . iswrapper = bool_ ; features . supportsindices = bool_ ; features . supportsvertexproperties = bool_ ; features . supportsedgeproperties = bool_ ;	Returns the current Graph settings.
private static boolean checkchangesfilledupto ( final filechanges changescontainer , final long pageindex ) { if ( changescontainer == null ) { return bool_ ; } else if ( changescontainer . isnew || changescontainer . maxnewpageindex > - num_ ) { return pageindex < changescontainer . maxnewpageindex + num_ ; } else return ! changescontainer . truncate ; }	This check if a file was trimmed or trunked in the current atomic operation.
protected boolean parsetimeout ( final string w ) throws ocommandsqlparsingexception { if ( ! w . equals ( keyword_timeout ) ) return bool_ ; string word = parsernextword ( bool_ ) ; try { timeoutms = long . parselong ( word ) ; } catch ( numberformatexception ignore ) { throwparsingexception ( str_ + keyword_timeout + str_ + word + str_ + keyword_timeout + str_ ) ; } if ( timeoutms < num_ ) throwparsingexception ( str_ + keyword_timeout + str_ + keyword_timeout + str_ ) ; word = parsernextword ( bool_ ) ; if ( word != null ) if ( word . equals ( timeout_strategy . exception . tostring ( ) ) ) timeoutstrategy = timeout_strategy . exception ; else if ( word . equals ( timeout_strategy . return . tostring ( ) ) ) timeoutstrategy = timeout_strategy . return ; else parsergoback ( ) ; return bool_ ; }	Parses the timeout keyword if found.
protected string parselock ( ) throws ocommandsqlparsingexception { final string lockstrategy = parsernextword ( bool_ ) ; if ( ! lockstrategy . equalsignorecase ( str_ ) && ! lockstrategy . equalsignorecase ( str_ ) && ! lockstrategy . equalsignorecase ( str_ ) ) throwparsingexception ( str_ + keyword_lock + str_ + lockstrategy + str_ + keyword_lock + str_ ) ; return lockstrategy ; }	Parses the lock keyword if found.
public void createcluster ( final string classname , final string clustername ) { final odatabasedocumentinternal currentdb = odatabaserecordthreadlocal . instance ( ) . getifdefined ( ) ; try { final odatabasedocumentinternal sysdb = opensystemdatabase ( ) ; try { if ( ! sysdb . existscluster ( clustername ) ) { oschema schema = sysdb . getmetadata ( ) . getschema ( ) ; oclass cls = schema . getclass ( classname ) ; if ( cls != null ) { cls . addcluster ( clustername ) ; } else { ologmanager . instance ( ) . error ( this , str_ , null , classname ) ; } } } finally { sysdb . close ( ) ; } } finally { if ( currentdb != null ) odatabaserecordthreadlocal . instance ( ) . set ( currentdb ) ; else odatabaserecordthreadlocal . instance ( ) . remove ( ) ; } }	Adds the specified cluster to the class, if it doesn't already exist.
public void freecluster ( final int cid ) { final set < orid > toremove = new hashset < orid > ( underlying . size ( ) / num_ ) ; final set < orid > keys = new hashset < orid > ( underlying . keys ( ) ) ; for ( final orid id : keys ) if ( id . getclusterid ( ) == cid ) toremove . add ( id ) ; for ( final orid ridtoremove : toremove ) underlying . remove ( ridtoremove ) ; }	Remove all records belonging to specified cluster.
public void startup ( ) { underlying . startup ( ) ; orient . instance ( ) . getprofiler ( ) . registerhookvalue ( profilerprefix + str_ , str_ , metric_type . size , new oprofilerhookvalue ( ) { public object getvalue ( ) { return getsize ( ) ; } } , profilermetadataprefix + str_ ) ; }	All operations running at cache initialization stage.
public void shutdown ( ) { underlying . shutdown ( ) ; if ( orient . instance ( ) . getprofiler ( ) != null ) { orient . instance ( ) . getprofiler ( ) . unregisterhookvalue ( profilerprefix + str_ ) ; orient . instance ( ) . getprofiler ( ) . unregisterhookvalue ( profilerprefix + str_ ) ; orient . instance ( ) . getprofiler ( ) . unregisterhookvalue ( profilerprefix + str_ ) ; } }	All operations running at cache destruction stage.
public static oscriptresultset singleton ( object entity , oscripttransformer transformer ) { return new oscriptresultset ( collections . singletonlist ( entity ) . iterator ( ) , transformer ) ; }	Result set with a single result;.
public orole grant ( final orule . resourcegeneric resourcegeneric , string resourcespecific , final int ioperation ) { orule rule = rules . get ( resourcegeneric ) ; if ( rule == null ) { rule = new orule ( resourcegeneric , null , null ) ; rules . put ( resourcegeneric , rule ) ; } rule . grantaccess ( resourcespecific , ioperation ) ; rules . put ( resourcegeneric , rule ) ; updaterolesdocumentcontent ( ) ; return this ; }	Grant a permission to the resource.
public orole revoke ( final orule . resourcegeneric resourcegeneric , string resourcespecific , final int ioperation ) { if ( ioperation == permission_none ) return this ; orule rule = rules . get ( resourcegeneric ) ; if ( rule == null ) { rule = new orule ( resourcegeneric , null , null ) ; rules . put ( resourcegeneric , rule ) ; } rule . revokeaccess ( resourcespecific , ioperation ) ; rules . put ( resourcegeneric , rule ) ; updaterolesdocumentcontent ( ) ; return this ; }	Revoke a permission to the resource.
public boolean result ( final object irecord ) { final orecordabstract record = ( ( oidentifiable ) irecord ) . getrecord ( ) ; if ( record instanceof odocument && compiledfilter != null && ! boolean . true . equals ( this . compiledfilter . evaluate ( record , ( odocument ) record , getcontext ( ) ) ) ) { return bool_ ; } try { if ( record . getidentity ( ) . isvalid ( ) ) { if ( returning . equalsignorecase ( str_ ) ) alldeletedrecords . add ( record ) ;	Deletes the current record.
private void reset ( ) { int count = num_ ; for ( int i = num_ ; i < table . length ; i ++ ) { count += long . bitcount ( table [ i ] & one_mask ) ; table [ i ] = ( table [ i ] > > > num_ ) & reset_mask ; } size = ( size > > > num_ ) - ( count > > > num_ ) ; }	Reduces every counter by half of its original value.
private int indexof ( final int item , final int i ) { long hash = seed [ i ] * item ; hash += hash > > num_ ; return ( ( int ) hash ) & tablemask ; }	Returns the table index for the counter at the specified depth.
private int spread ( int x ) { x = ( ( x > > > num_ ) ^ x ) * num_ ; x = ( ( x > > > num_ ) ^ x ) * randomseed ; return ( x > > > num_ ) ^ x ; }	Applies a supplemental hash function to a given hashCode, which defends against poor qualityhash functions.
public oindex < ? > createindex ( final string itype ) { acquireschemareadlock ( ) ; try { return owner . createindex ( getfullname ( ) , itype , globalref . getname ( ) ) ; } finally { releaseschemareadlock ( ) ; } }	Creates an index on this property.
@ deprecated public opropertyimpl dropindexes ( ) { getdatabase ( ) . checksecurity ( orule . resourcegeneric . schema , orole . permission_delete ) ; acquireschemareadlock ( ) ; try { final oindexmanager indexmanager = getdatabase ( ) . getmetadata ( ) . getindexmanager ( ) ; final arraylist < oindex < ? > > relatedindexes = new arraylist < oindex < ? > > ( ) ; for ( final oindex < ? > index : indexmanager . getclassindexes ( owner . getname ( ) ) ) { final oindexdefinition definition = index . getdefinition ( ) ; if ( ocollections . indexof ( definition . getfields ( ) , globalref . getname ( ) , new ocaseinsentivecomparator ( ) ) > - num_ ) { if ( definition instanceof opropertyindexdefinition ) { relatedindexes . add ( index ) ; } else { throw new illegalargumentexception ( str_ + index . getname ( ) + str_ + index . getdefinition ( ) ) ; } } } for ( final oindex < ? > index : relatedindexes ) getdatabase ( ) . getmetadata ( ) . getindexmanager ( ) . dropindex ( index . getname ( ) ) ; return this ; } finally { releaseschemareadlock ( ) ; } }	Remove the index on property.
@ deprecated public oindex < ? > getindex ( ) { acquireschemareadlock ( ) ; try { set < oindex < ? > > indexes = owner . getinvolvedindexes ( globalref . getname ( ) ) ; if ( indexes != null && ! indexes . isempty ( ) ) return indexes . iterator ( ) . next ( ) ; return null ; } finally { releaseschemareadlock ( ) ; } }	Returns the first index defined for the property.
public oclass getlinkedclass ( ) { acquireschemareadlock ( ) ; try { if ( linkedclass == null && linkedclassname != null ) linkedclass = owner . owner . getclass ( linkedclassname ) ; return linkedclass ; } finally { releaseschemareadlock ( ) ; } }	Returns the linked class in lazy mode because while unmarshalling the class could be not loaded yet.
@ override public odocument tostream ( ) { internalacquireexclusivelock ( ) ; try { document . setinternalstatus ( orecordelement . status . unmarshalling ) ; try { final otrackedset < odocument > indexes = new otrackedset < > ( document ) ; for ( final oindex < ? > i : this . indexes . values ( ) ) { indexes . add ( ( ( oindexinternal < ? > ) i ) . updateconfiguration ( ) ) ; } document . field ( config_indexes , indexes , otype . embeddedset ) ; } finally { document . setinternalstatus ( orecordelement . status . loaded ) ; } document . setdirty ( ) ; return document ; } finally { internalreleaseexclusivelock ( ) ; } }	Binds POJO to ODocument.
protected void removelistener ( final orecordlistener listener ) { if ( _listeners != null ) { _listeners . remove ( listener ) ; if ( _listeners . isempty ( ) ) _listeners = null ; } }	Remove the current event listener.
public odistributeddatabaseimpl registerdatabase ( final string idatabasename , odistributedconfiguration cfg ) { final odistributeddatabaseimpl ddb = databases . get ( idatabasename ) ; if ( ddb != null ) return ddb ; return new odistributeddatabaseimpl ( manager , this , idatabasename , cfg , manager . getserverinstance ( ) ) ; }	Creates a distributed database instance if not defined yet.
public void timeoutrequest ( final long msgid ) { final odistributedresponsemanager asynchmgr = responsesbyrequestids . remove ( msgid ) ; if ( asynchmgr != null ) asynchmgr . timeout ( ) ; }	Removes a response manager because in timeout.
public odatabasedocumentinternal copy ( ) { odatabasedocumentembedded database = new odatabasedocumentembedded ( getsharedcontext ( ) . getstorage ( ) ) ; database . init ( config , this . sharedcontext ) ; string user ; if ( getuser ( ) != null ) { user = getuser ( ) . getname ( ) ; } else { user = null ; } database . internalopen ( user , null , bool_ ) ; database . callonopenlisteners ( ) ; this . activateoncurrentthread ( ) ; return database ; }	Returns a copy of current database if it's open.
public boolean trymerge ( final oridbag othervalue , boolean imergesingleitemsofmultivaluefields ) { if ( ! isembedded ( ) && ! othervalue . isembedded ( ) ) { final osbtreeridbag thistree = ( osbtreeridbag ) delegate ; final osbtreeridbag othertree = ( osbtreeridbag ) othervalue . delegate ; if ( thistree . getcollectionpointer ( ) . equals ( othertree . getcollectionpointer ( ) ) ) { thistree . mergechanges ( othertree ) ; uuid = othervalue . uuid ; return bool_ ; } } else if ( imergesingleitemsofmultivaluefields ) { final iterator < oidentifiable > iter = othervalue . rawiterator ( ) ; while ( iter . hasnext ( ) ) { final oidentifiable value = iter . next ( ) ; if ( value != null ) { final iterator < oidentifiable > localiter = rawiterator ( ) ; boolean found = bool_ ; while ( localiter . hasnext ( ) ) { final oidentifiable v = localiter . next ( ) ; if ( value . equals ( v ) ) { found = bool_ ; break ; } } if ( ! found ) add ( value ) ; } } return bool_ ; } return bool_ ; }	IMPORTANT! Only for internal usage.
private void replacewithsbtree ( obonsaicollectionpointer pointer ) { delegate . requestdelete ( ) ; final osbtreeridbag treebag = new osbtreeridbag ( ) ; treebag . setcollectionpointer ( pointer ) ; treebag . setowner ( delegate . getowner ( ) ) ; for ( omultivaluechangelistener < oidentifiable , oidentifiable > listener : delegate . getchangelisteners ( ) ) treebag . addchangelistener ( listener ) ; delegate = treebag ; }	Silently replace delegate by tree implementation.
public static object transformresult ( object result ) { if ( java8methodisarray == null || ! ( result instanceof map ) ) { return result ; }	Manages cross compiler compatibility issues.
public object execute ( final map < object , object > iargs ) { if ( clustername == null ) throw new ocommandexecutionexception ( str_ ) ; final odatabasedocument database = getdatabase ( ) ; final int clusterid = database . getclusteridbyname ( clustername ) ; if ( clusterid > - num_ ) throw new ocommandsqlparsingexception ( str_ + clustername + str_ ) ; if ( blob ) { if ( requestedid == - num_ ) { return database . addblobcluster ( clustername ) ; } else { throw new ocommandexecutionexception ( str_ ) ; } } else { if ( requestedid == - num_ ) { return database . addcluster ( clustername ) ; } else { return database . addcluster ( clustername , requestedid , null ) ; } } }	Execute the CREATE CLUSTER.
public void close ( ) { lock ( ) ; try { if ( this . evictiontask != null ) { this . evictiontask . cancel ( ) ; } for ( entry < string , oreentrantresourcepool < string , db > > pool : pools . entryset ( ) ) { for ( db db : pool . getvalue ( ) . getresources ( ) ) { pool . getvalue ( ) . close ( ) ; try { ologmanager . instance ( ) . debug ( this , str_ , db . getname ( ) ) ; ( ( odatabasepooled ) db ) . forceclose ( ) ; ologmanager . instance ( ) . debug ( this , str_ , db . getname ( ) ) ; } catch ( exception e ) { ologmanager . instance ( ) . debug ( this , str_ , e . tostring ( ) ) ; } } } } finally { unlock ( ) ; } }	Closes all the databases.
public void onstorageunregistered ( final ostorage istorage ) { final string storageurl = istorage . geturl ( ) ; lock ( ) ; try { set < string > pooltoclose = null ; for ( entry < string , oreentrantresourcepool < string , db > > e : pools . entryset ( ) ) { final int pos = e . getkey ( ) . indexof ( str_ ) ; final string dbname = e . getkey ( ) . substring ( pos + num_ ) ; if ( storageurl . equals ( dbname ) ) { if ( pooltoclose == null ) pooltoclose = new hashset < string > ( ) ; pooltoclose . add ( e . getkey ( ) ) ; } } if ( pooltoclose != null ) for ( string pool : pooltoclose ) remove ( pool ) ; } finally { unlock ( ) ; } }	Removes from memory the pool associated to the closed storage.
public static set < string > getfunctionnames ( ) { final set < string > types = new hashset < string > ( ) ; final iterator < osqlfunctionfactory > ite = getfunctionfactories ( ) ; while ( ite . hasnext ( ) ) { types . addall ( ite . next ( ) . getfunctionnames ( ) ) ; } return types ; }	Iterates on all factories and append all function names.
public static set < string > getcollatenames ( ) { final set < string > types = new hashset < string > ( ) ; final iterator < ocollatefactory > ite = getcollatefactories ( ) ; while ( ite . hasnext ( ) ) { types . addall ( ite . next ( ) . getnames ( ) ) ; } return types ; }	Iterates on all factories and append all collate names.
public static set < string > getcommandnames ( ) { final set < string > types = new hashset < string > ( ) ; final iterator < ocommandexecutorsqlfactory > ite = getcommandfactories ( ) ; while ( ite . hasnext ( ) ) { types . addall ( ite . next ( ) . getcommandnames ( ) ) ; } return types ; }	Iterates on all factories and append all command names.
private tuple < integer , otype > getfieldsizeandtypefromcurrentposition ( bytescontainer bytes ) { int fieldsize = ovarintserializer . readasinteger ( bytes ) ; otype type = readotype ( bytes , bool_ ) ; return new tuple < > ( fieldsize , type ) ; }	use only for named fields.
public ohttpresponsewrapper writestatus ( final int ihttpcode , final string ireason ) throws ioexception { response . writestatus ( ihttpcode , ireason ) ; return this ; }	Sets the response's status as HTTP code and reason.
public ohttpresponsewrapper writeheaders ( final string icontenttype , final boolean ikeepalive ) throws ioexception { response . writeheaders ( icontenttype , ikeepalive ) ; return this ; }	Sets the response's headers specifying when using the keep-alive or not.
public ohttpresponsewrapper writerecords ( final object irecords , final string ifetchplan ) throws ioexception { response . writerecords ( irecords , ifetchplan ) ; return this ; }	Writes records as response specifying a fetch-plan to serialize nested records.
public ohttpresponsewrapper writerecord ( final orecord irecord , final string ifetchplan ) throws ioexception { response . writerecord ( irecord , ifetchplan , null ) ; return this ; }	Writes a record as response.
public ohttpresponsewrapper send ( final int icode , final string ireason , final string icontenttype , final object icontent ) throws ioexception { response . send ( icode , ireason , icontenttype , icontent , null ) ; return this ; }	Sends the complete HTTP response in one call.
public ohttpresponsewrapper sendstream ( final int icode , final string ireason , final string icontenttype , final inputstream icontent , final long isize ) throws ioexception { response . sendstream ( icode , ireason , icontenttype , icontent , isize ) ; return this ; }	Sends the complete HTTP response in one call specifying a stream as content.
public odatabaseobject open ( string name , string user , string password ) { return new oobjectdatabasetx ( ( odatabasedocumentinternal ) orientdb . open ( name , user , password ) ) ; }	Open a database specified by name using the username and password if needed.
@ override public void close ( ) { if ( isclosed ( ) ) return ; checkopenness ( ) ; if ( ownerpool != null && ownerpool . getconnectionsincurrentthread ( geturl ( ) , username ) > num_ ) { ownerpool . release ( this ) ; return ; } try { commit ( bool_ ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ , e , getname ( ) ) ; } try { calloncloselisteners ( ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ , e , getname ( ) ) ; } getlocalcache ( ) . clear ( ) ; if ( ownerpool != null ) { final odatabasedocumentpool localcopy = ownerpool ; ownerpool = null ; localcopy . release ( this ) ; } odatabaserecordthreadlocal . instance ( ) . remove ( ) ; }	Avoid to close it but rather release itself to the owner pool.
@ override public uuid listenforchanges ( oridbag collection ) { uuid owneruuid = collection . gettemporaryid ( ) ; if ( owneruuid != null ) { final obonsaicollectionpointer pointer = collection . getpointer ( ) ; map < uuid , obonsaicollectionpointer > changedpointers = collectionpointerchanges . get ( ) ; if ( pointer != null && pointer . isvalid ( ) ) { changedpointers . put ( owneruuid , pointer ) ; } } return null ; }	Change UUID to null to prevent its serialization to disk.
public void completecomponentoperation ( ) { final component currentcomponent = componentsstack . peek ( ) ; if ( currentcomponent == null ) return ; currentcomponent . operationcount -- ; if ( currentcomponent . operationcount == num_ ) { final string componentname = currentcomponent . name ; performancecountersholder cholder = countersbycomponent . computeifabsent ( componentname , k -> currentcomponent . type . newcountersholder ( ) ) ; cholder . operationscount ++ ; componentsstack . pop ( ) ; makesnapshotifneeded ( - num_ ) ; } }	Indicates that the most earliest component in stack of components has completed it's operation, so performance data for thiscomponent is stopped to be gathered.
public void pushcomponentcounters ( map < string , performancecountersholder > counters ) { if ( snapshot == null ) return ; for ( map . entry < string , performancecountersholder > entry : snapshot . countersbycomponent . entryset ( ) ) { final string componentname = entry . getkey ( ) ; performancecountersholder holder = counters . computeifabsent ( componentname , k -> entry . getvalue ( ) . newinstance ( ) ) ; entry . getvalue ( ) . pushdata ( holder ) ; } }	Takes performance data are split by components from last snapshot and aggregates them with data passed inside method asparameter.
public writcachecountersholder pushwritecachecounters ( writcachecountersholder holder ) { if ( snapshot == null ) return holder ; if ( snapshot . writcachecountersholder == null ) return holder ; if ( holder == null ) holder = new writcachecountersholder ( ) ; snapshot . writcachecountersholder . pushdata ( holder ) ; return holder ; }	Takes write cache performance data from last snapshot and aggregates them with data passed inside method as parameter.
public storagecountersholder pushstoragecounters ( storagecountersholder holder ) { if ( snapshot == null ) return holder ; if ( snapshot . storagecountersholder == null ) return holder ; if ( holder == null ) holder = new storagecountersholder ( ) ; snapshot . storagecountersholder . pushdata ( holder ) ; return holder ; }	Takes storage performance data from last snapshot and aggregates them with data passed inside method as parameter.
public walcountersholder pushwalcounters ( walcountersholder holder ) { if ( snapshot == null ) return holder ; if ( snapshot . walcountersholder == null ) return holder ; if ( holder == null ) holder = new walcountersholder ( ) ; snapshot . walcountersholder . pushdata ( holder ) ; return holder ; }	Takes write ahead log data from last snapshot and aggregates them with data passed inside method as parameter.
public void pushcomponentcounters ( string name , performancecountersholder holder ) { if ( snapshot == null ) return ; final performancecountersholder countersholder = snapshot . countersbycomponent . get ( name ) ; if ( countersholder != null ) { countersholder . pushdata ( holder ) ; } }	Takes performance data for component from last snapshot and aggregates them with data passed inside method as parameter.
public void stopwritecacheflushtimer ( int pagesflushed ) {	Stops and records results of timer which counts how much time was spent on operation of flush pages in write cache.
public void stopfuzzycheckpointtimer ( ) { if ( writcachecountersholder == null ) writcachecountersholder = new writcachecountersholder ( ) ; final long endts = nanotimer . getnano ( ) ; final long timediff = ( endts - timestamps . pop ( ) ) ; writcachecountersholder . fuzzycheckpointcount ++ ; writcachecountersholder . fuzzycheckpointtime += timediff ; makesnapshotifneeded ( endts ) ; }	Stops and records results of timer which counts how much time was spent on fuzzy checkpoint operation.
public void stopfullcheckpointtimer ( ) { final long endts = nanotimer . getnano ( ) ; final long timediff = ( endts - timestamps . pop ( ) ) ; if ( storagecountersholder == null ) storagecountersholder = new storagecountersholder ( ) ; storagecountersholder . fullcheckpointoperationscount ++ ; storagecountersholder . fullcheckpointoperationstime += timediff ; makesnapshotifneeded ( endts ) ; }	Stops and records results of timer which counts how much time was spent on full checkpoint operation.
public void stopcommittimer ( ) { final long endts = nanotimer . getnano ( ) ; final long timediff = ( endts - timestamps . pop ( ) ) ; performancecountersholder . committime += timediff ; performancecountersholder . commitcount ++ ; makesnapshotifneeded ( endts ) ; }	Stops and records results of timer which counts how much time was spent on atomic operation commit.
public void stopwalrecordtimer ( boolean isstartrecord , boolean isstoprecord ) { final long endts = nanotimer . getnano ( ) ; final long timediff = ( endts - timestamps . pop ( ) ) ; if ( walcountersholder == null ) walcountersholder = new walcountersholder ( ) ; walcountersholder . logrecordcount ++ ; walcountersholder . logrecordtime += timediff ; if ( isstartrecord ) { walcountersholder . startrecordcount ++ ; walcountersholder . startrecordtime += timediff ; } else if ( isstoprecord ) { walcountersholder . stoprecordcount ++ ; walcountersholder . stoprecordtime += timediff ; } makesnapshotifneeded ( endts ) ; }	Stops and records results of timer which counts how much time was spent on logging of single write ahead log record.
public void stopwalflushtimer ( ) { final long endts = nanotimer . getnano ( ) ; final long timediff = ( endts - timestamps . pop ( ) ) ; if ( walcountersholder == null ) walcountersholder = new walcountersholder ( ) ; walcountersholder . flushcount ++ ; walcountersholder . flushtime += timediff ; makesnapshotifneeded ( endts ) ; }	Stops timer and records how much time was spent on flushing of data from write ahead log cache.
protected static ostatement parse ( string statement ) throws ocommandsqlparsingexception { try { odatabasedocumentinternal db = odatabaserecordthreadlocal . instance ( ) . getifdefined ( ) ; inputstream is ; if ( db == null ) { is = new bytearrayinputstream ( statement . getbytes ( ) ) ; } else { try { is = new bytearrayinputstream ( statement . getbytes ( db . getstorage ( ) . getconfiguration ( ) . getcharset ( ) ) ) ; } catch ( unsupportedencodingexception e2 ) { ologmanager . instance ( ) . warn ( null , str_ + db + str_ + db . getstorage ( ) . getconfiguration ( ) . getcharset ( ) ) ; is = new bytearrayinputstream ( statement . getbytes ( ) ) ; } } orientsql osql = null ; if ( db == null ) { osql = new orientsql ( is ) ; } else { try { osql = new orientsql ( is , db . getstorage ( ) . getconfiguration ( ) . getcharset ( ) ) ; } catch ( unsupportedencodingexception e2 ) { ologmanager . instance ( ) . warn ( null , str_ + db + str_ + db . getstorage ( ) . getconfiguration ( ) . getcharset ( ) ) ; osql = new orientsql ( is ) ; } } ostatement result = osql . parse ( ) ; result . originalstatement = statement ; return result ; } catch ( parseexception e ) { throwparsingexception ( e , statement ) ; } catch ( tokenmgrerror e2 ) { throwparsingexception ( e2 , statement ) ; } return null ; }	parses an SQL statement and returns the corresponding executor.
protected void initreceivemessages ( ) throws ioexception { messagethread = new thread ( ( ) -> { while ( ! thread . interrupted ( ) ) { receivemessages ( ) ; } } ) ; messagethread . setname ( str_ ) ; messagethread . setdaemon ( bool_ ) ; messagethread . start ( ) ; }	inits the procedure that listens to pings from other servers, eg. that discovers other nodes in the network.
protected void initcheckdisconnect ( ) { disconnecttimer = new timertask ( ) { public void run ( ) { try { checkifknownserversarealive ( ) ; if ( running ) { initcheckdisconnect ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } } ; taskscheduler . scheduleonce ( disconnecttimer , discoverypingintervalmillis ) ; }	inits the procedure that checks if a server is no longer available, ie. if he did not ping for a long time.
void removerecord ( ) { checkifattached ( ) ; final orientbasegraph graph = getgraph ( ) ; graph . setcurrentgraphinthreadlocal ( ) ; graph . autostarttransaction ( ) ; if ( checkdeletedintx ( ) ) graph . throwrecordnotfoundexception ( getidentity ( ) , str_ + getidentity ( ) + str_ ) ; try { getrecord ( ) . load ( ) ; } catch ( orecordnotfoundexception e ) { graph . throwrecordnotfoundexception ( getidentity ( ) , e . getmessage ( ) ) ; } getrecord ( ) . delete ( ) ; }	Removes the Element from the Graph.
@ override public void setproperty ( final string key , final object value ) { if ( checkdeletedintx ( ) ) graph . throwrecordnotfoundexception ( getidentity ( ) , str_ + getidentity ( ) + str_ ) ; validateproperty ( this , key , value ) ; final orientbasegraph graph = getgraph ( ) ; if ( graph != null ) graph . autostarttransaction ( ) ; getrecord ( ) . field ( key , value ) ; if ( graph != null ) save ( ) ; }	Sets a Property value.
@ override public < t > t removeproperty ( final string key ) { if ( checkdeletedintx ( ) ) throw new illegalstateexception ( str_ + getidentity ( ) + str_ ) ; final orientbasegraph graph = getgraph ( ) ; if ( graph != null ) graph . autostarttransaction ( ) ; final object oldvalue = getrecord ( ) . removefield ( key ) ; if ( graph != null ) save ( ) ; return ( t ) oldvalue ; }	Removes a Property.
protected string checkforclassinschema ( final string classname ) { if ( classname == null ) return null ; orientbasegraph graph = getgraph ( ) ; if ( graph == null ) return classname ; final oschema schema = graph . getrawgraph ( ) . getmetadata ( ) . getschema ( ) ; if ( ! schema . existsclass ( classname ) ) {	Check if a class already exists, otherwise create it at the fly.
public static oindexcursor wrap ( oindex < ? > source , oindexcursor cursor , long indexrebuildversion ) { if ( cursor instanceof oindexchangeswrapper ) return cursor ; if ( cursor instanceof osizeable ) { return new oindexchangessizeable ( source , cursor , indexrebuildversion ) ; } return new oindexchangeswrapper ( source , cursor , indexrebuildversion ) ; }	Wraps courser only if it is not already wrapped.
public ographmlreader definevertexattributestrategy ( final string iattributename , final ographmlimportstrategy istrategy ) { vertexpropsstrategy . put ( iattributename , istrategy ) ; return this ; }	Define custom strategy to use for vertex attribute.
public ographmlreader defineedgeattributestrategy ( final string iattributename , final ographmlimportstrategy istrategy ) { edgepropsstrategy . put ( iattributename , istrategy ) ; return this ; }	Define custom strategy to use for edge attribute.
public list < orecordoperation > getnewrecordentriesbyclass ( final oclass iclass , final boolean ipolymorphic ) { final list < orecordoperation > result = new arraylist < orecordoperation > ( ) ; if ( iclass == null )	Called by class iterator.
public list < orecordoperation > getnewrecordentriesbyclusterids ( final int [ ] iids ) { final list < orecordoperation > result = new arraylist < orecordoperation > ( ) ; if ( iids == null )	Called by cluster iterator.
public void addindexentry ( final oindex < ? > delegate , final string iindexname , final otransactionindexchanges . operation ioperation , final object key , final oidentifiable ivalue , boolean clienttrackonly ) { otransactionindexchanges indexentry = indexentries . get ( iindexname ) ; if ( indexentry == null ) { indexentry = new otransactionindexchanges ( ) ; indexentries . put ( iindexname , indexentry ) ; } if ( ioperation == operation . clear ) indexentry . setcleared ( ) ; else { otransactionindexchangesperkey changes = indexentry . getchangesperkey ( key ) ; changes . clienttrackonly = clienttrackonly ; changes . add ( ivalue , ioperation ) ; if ( ivalue == null ) return ; list < otransactionrecordindexoperation > transactionindexoperations = recordindexoperations . get ( ivalue . getidentity ( ) ) ; if ( transactionindexoperations == null ) { transactionindexoperations = new arraylist < otransactionrecordindexoperation > ( ) ; recordindexoperations . put ( ivalue . getidentity ( ) . copy ( ) , transactionindexoperations ) ; } transactionindexoperations . add ( new otransactionrecordindexoperation ( iindexname , key , ioperation ) ) ; } }	Bufferizes index changes to be flushed at commit time.
private static set < orecord > mergeset ( set < orecord > target , set < orecord > source ) { if ( source != null ) { if ( target == null ) { return source ; } else { if ( target . size ( ) > source . size ( ) ) { target . addall ( source ) ; return target ; } else { source . addall ( target ) ; return source ; } } } else { return target ; } }	Merge the two set try to use the optimum case.
@ suppresswarnings ( str_ ) public boolean result ( final object irecord ) { final odocument record = ( ( oidentifiable ) irecord ) . getrecord ( ) ; if ( isupdateedge ( ) && ! isrecordinstanceof ( irecord , str_ ) ) { throw new ocommandexecutionexception ( str_ ) ; } if ( compiledfilter != null ) {	Update current record.
public boolean canexecuteindexedfunctionwithoutindex ( ofromclause target , ocommandcontext context , obinarycompareoperator operator , object right ) { osqlfunction function = osqlengine . getinstance ( ) . getfunction ( name . getstringvalue ( ) ) ; if ( function instanceof oindexablesqlfunction ) { return ( ( oindexablesqlfunction ) function ) . canexecuteinline ( target , operator , right , context , this . getparams ( ) . toarray ( new oexpression [ ] { } ) ) ; } return bool_ ; }	tests if current function is an indexed function AND that function can also be executed without using the index.
private set < comparable > preparekeys ( oindex < ? > index , object keys ) { final oindexdefinition indexdefinition = index . getdefinition ( ) ; if ( keys instanceof collection ) { final set < comparable > newkeys = new treeset < comparable > ( ) ; for ( object o : ( ( collection ) keys ) ) { newkeys . add ( ( comparable ) indexdefinition . createvalue ( o ) ) ; } return newkeys ; } else { return collections . singleton ( ( comparable ) indexdefinition . createvalue ( keys ) ) ; } }	Make type conversion of keys for specific index.
void writepage ( bytebuffer page , long pageindex ) throws ioexception { synchronized ( lockobject ) { lastaccesstime = system . nanotime ( ) ; if ( pageindex >= firstcachedpage && pageindex <= firstcachedpage + pagecache . size ( ) ) { if ( pageindex < firstcachedpage + pagecache . size ( ) ) { pagecache . set ( ( int ) ( pageindex - firstcachedpage ) , page ) ; } else { pagecache . add ( page ) ; } } else if ( pagecache . isempty ( ) ) { pagecache . add ( page ) ; firstcachedpage = pageindex ; } lastwrittenpage = page ; lastwrittenpageindex = pageindex ; if ( pagecache . size ( ) * owalpage . page_size >= buffersize + owalpage . page_size ) { flushallbufferpagesexceptlastone ( ) ; } } }	Writes page with given page index to the cache and eventually writes it to the file.
byte [ ] readpage ( long pageindex ) throws ioexception { synchronized ( lockobject ) { lastaccesstime = system . nanotime ( ) ; if ( pageindex == lastwrittenpageindex ) { return lastwrittenpage . array ( ) ; } if ( pageindex >= firstcachedpage && pageindex < firstcachedpage + pagecache . size ( ) ) { final bytebuffer buffer = pagecache . get ( ( int ) ( pageindex - firstcachedpage ) ) ; return buffer . array ( ) ; } final bytebuffer buffer = bytebuffer . allocate ( owalpage . page_size ) . order ( byteorder . nativeorder ( ) ) ; initfile ( ) ; segchannel . position ( pageindex * owalpage . page_size ) ; readbytebuffer ( buffer , segchannel ) ; return buffer . array ( ) ; } }	Read page content with given index from cache or file.
void truncate ( long pageindex ) throws ioexception { synchronized ( lockobject ) { lastaccesstime = system . nanotime ( ) ; flushbuffer ( ) ; lastwrittenpageindex = - num_ ; lastwrittenpage = null ; segchannel . truncate ( pageindex * owalpage . page_size ) ; } }	Flushes all buffered pages and truncates file till passed in page index.
public void open ( ) throws ioexception { synchronized ( lockobject ) { lastaccesstime = system . nanotime ( ) ; initfile ( ) ; long pagescount = segchannel . size ( ) / owalpage . page_size ; if ( segchannel . size ( ) % owalpage . page_size > num_ ) { ologmanager . instance ( ) . error ( this , str_ , null ) ; segchannel . truncate ( owalpage . page_size * pagescount ) ; } firstcachedpage = - num_ ; pagecache . clear ( ) ; lastwrittenpage = null ; lastwrittenpageindex = - num_ ; } }	Initializes cache and opens underlying file.
public boolean isreplicationactive ( final string iclustername , final string ilocalnode ) { final collection < string > servers = getclusterconfiguration ( iclustername ) . field ( servers ) ; if ( servers != null && ! servers . isempty ( ) ) { return bool_ ; } return bool_ ; }	Returns true if the replication is active, otherwise false.
public new_node_strategies getnewnodestrategy ( ) { final string value = configuration . field ( new_node_strategy ) ; if ( value != null ) return new_node_strategies . valueof ( value . touppercase ( locale . english ) ) ; return new_node_strategies . static ; }	Returns the new node strategy between "dynamic" and "static".
public boolean isexecutionmodesynchronous ( final string iclustername ) { object value = getclusterconfiguration ( iclustername ) . field ( execution_mode ) ; if ( value == null ) { value = configuration . field ( execution_mode ) ; if ( value == null ) return null ; } if ( value . tostring ( ) . equalsignorecase ( str_ ) ) return null ; return value . tostring ( ) . equalsignorecase ( execution_mode_synchronous ) ; }	Returns the execution mode if synchronous.
public boolean isreadyourwrites ( final string iclustername ) { object value = getclusterconfiguration ( iclustername ) . field ( read_your_writes ) ; if ( value == null ) { value = configuration . field ( read_your_writes ) ; if ( value == null ) { ologmanager . instance ( ) . warn ( this , str_ , read_your_writes , iclustername ) ; return bool_ ; } } return ( boolean ) value ; }	Reads your writes.
public map < string , collection < string > > getserverclustermap ( collection < string > iclusternames , final string ilocalnode , final boolean optimizeforlocalonly ) { if ( iclusternames == null || iclusternames . isempty ( ) ) iclusternames = default_cluster_name ; final map < string , collection < string > > servers = new hashmap < string , collection < string > > ( iclusternames . size ( ) ) ;	Returns the list of servers that can manage a list of clusters.
public set < string > getservers ( collection < string > iclusternames ) { if ( iclusternames == null || iclusternames . isempty ( ) ) return getallconfiguredservers ( ) ; final set < string > partitions = new hashset < string > ( iclusternames . size ( ) ) ; for ( string p : iclusternames ) { final list < string > serverlist = getclusterconfiguration ( p ) . field ( servers ) ; if ( serverlist != null ) { for ( string s : serverlist ) if ( ! s . equals ( new_node_tag ) ) partitions . add ( s ) ; } } return partitions ; }	Returns the set of server names involved on the passed cluster collection.
public boolean isservercontainingallclusters ( final string server , collection < string > clusters ) { if ( clusters == null || clusters . isempty ( ) ) clusters = default_cluster_name ; for ( string cluster : clusters ) { final list < string > serverlist = getclusterconfiguration ( cluster ) . field ( servers ) ; if ( serverlist != null ) { if ( ! serverlist . contains ( server ) ) return bool_ ; } } return bool_ ; }	Returns true if the local server has all the requested clusters.
public boolean isservercontainingcluster ( final string server , string cluster ) { if ( cluster == null ) cluster = all_wildcard ; final list < string > serverlist = getclusterconfiguration ( cluster ) . field ( servers ) ; if ( serverlist != null ) { return serverlist . contains ( server ) ; } return bool_ ; }	Returns true if the local server has the requested cluster.
public list < string > getmasterservers ( ) { final list < string > serverlist = getclusterconfiguration ( null ) . field ( servers ) ; if ( serverlist != null ) {	Returns an ordered list of master server.
public set < string > getallconfiguredservers ( ) { final set < string > servers = new hashset < string > ( ) ; for ( string p : getclusternames ( ) ) { final list < string > serverlist = getclusterconfiguration ( p ) . field ( servers ) ; if ( serverlist != null ) { for ( string s : serverlist ) if ( ! s . equals ( new_node_tag ) ) servers . add ( s ) ; } } return servers ; }	Returns the complete list of servers found in configuration.
public set < string > getclustersonserver ( final string inodename ) { final set < string > clusters = new hashset < string > ( ) ; for ( string cl : getclusternames ( ) ) { final list < string > servers = getservers ( cl , null ) ; if ( servers . contains ( inodename ) ) clusters . add ( cl ) ; } return clusters ; }	Returns the set of clusters managed by a server.
public set < string > getclustersownedbyserver ( final string inodename ) { final set < string > clusters = new hashset < string > ( ) ; for ( string cl : getclusternames ( ) ) { if ( inodename . equals ( getclusterowner ( cl ) ) ) clusters . add ( cl ) ; } return clusters ; }	Returns the set of clusters where server is the owner.
public string getclusterowner ( final string iclustername ) { string owner ; final odocument clusters = getconfiguredclusters ( ) ;	Returns the owner server for the given cluster excluding the passed node.
public string getconfiguredclusterowner ( final string iclustername ) { string owner = null ; final odocument clusters = getconfiguredclusters ( ) ;	Returns the static owner server for the given cluster.
public list < string > getconfiguredservers ( final string iclustername ) { final collection < ? extends string > list = ( collection < ? extends string > ) getclusterconfiguration ( iclustername ) . field ( servers ) ; return list != null ? new arraylist < string > ( list ) : null ; }	Returns the configured server list for the requested cluster.
public set < string > getregisteredservers ( ) { final odocument servers = configuration . field ( servers ) ; final set < string > result = new hashset < string > ( ) ; if ( servers != null ) for ( string s : servers . fieldnames ( ) ) result . add ( s ) ; return result ; }	Returns the registered servers.
public set < string > getdatacenters ( ) { final odocument dcs = configuration . field ( dcs ) ; if ( dcs == null ) return collections . empty_set ; final set < string > result = new hashset < string > ( ) ; for ( string dc : dcs . fieldnames ( ) ) { result . add ( dc ) ; } return result ; }	Returns all the configured data centers' names, if any.
public int getdatacenterwritequorum ( final string datacenter ) { final odocument dc = getdatacenterconfiguration ( datacenter ) ; object wq = dc . field ( write_quorum ) ; if ( wq instanceof string ) { if ( wq . tostring ( ) . equalsignorecase ( odistributedconfiguration . quorum_majority ) ) { final list < string > servers = dc . field ( servers ) ; wq = servers . size ( ) / num_ + num_ ; } else if ( wq . tostring ( ) . equalsignorecase ( odistributedconfiguration . quorum_all ) ) { final list < string > servers = dc . field ( servers ) ; wq = servers . size ( ) ; } } return ( integer ) wq ; }	Returns the data center write quorum.
public boolean issharded ( ) { final odocument allcluster = getclusterconfiguration ( all_wildcard ) ; if ( allcluster != null ) { final list < string > allservers = allcluster . field ( servers ) ; if ( allservers != null && ! allservers . isempty ( ) ) { for ( string cl : getclusternames ( ) ) { final list < string > servers = getservers ( cl , null ) ; if ( servers != null && ! servers . isempty ( ) && ! allservers . containsall ( servers ) ) return bool_ ; } } } return bool_ ; }	Returns true if the database is sharded across servers.
public list < string > getdatacenterservers ( final string datacenter ) { final odocument dc = getdatacenterconfiguration ( datacenter ) ; final list < string > servers = dc . field ( servers ) ; if ( servers == null || servers . isempty ( ) ) throw new oconfigurationexception ( str_ + datacenter + str_ ) ; return new arraylist < string > ( servers ) ; }	Returns the list of servers in a data center.
public string getdatacenterofserver ( final string server ) { final odocument dcs = configuration . field ( dcs ) ; if ( dcs != null ) { for ( string dc : dcs . fieldnames ( ) ) { final odocument dcconfig = dcs . field ( dc ) ; if ( dcconfig != null ) { final list < string > dcservers = dcconfig . field ( str_ ) ; if ( dcservers != null && ! dcservers . isempty ( ) ) { if ( dcservers . contains ( server ) )	Returns the data center where the server belongs.
public object getglobalreadquorum ( final string iclustername ) { object value = getclusterconfiguration ( iclustername ) . field ( read_quorum ) ; if ( value == null ) value = configuration . field ( read_quorum ) ; return value ; }	Returns the global read quorum.
public int getwritequorum ( final string clustername , final int totalconfiguredmasterservers , final string server ) { integer overwrite = overwritewritequorum . get ( ) ; if ( overwrite != null ) return overwrite . intvalue ( ) ; else return getquorum ( str_ , clustername , totalconfiguredmasterservers , default_write_quorum , server ) ; }	Returns the write quorum.
protected odocument getclusterconfiguration ( string iclustername ) { final odocument clusters = getconfiguredclusters ( ) ; if ( iclustername == null ) iclustername = all_wildcard ; final odocument cfg ; if ( ! clusters . containsfield ( iclustername ) )	Gets the document representing the cluster configuration.
private odocument getdatacenterconfiguration ( final string datacenter ) { final odocument dcs = configuration . field ( dcs ) ; if ( dcs != null ) return dcs . field ( datacenter ) ; throw new oconfigurationexception ( str_ + datacenter + str_ ) ; }	Gets the document representing the dc configuration.
public static void clearinitstack ( ) { final threadlocal < deque < orientbasegraph > > is = initializationstack ; if ( is != null ) is . get ( ) . clear ( ) ; final threadlocal < orientbasegraph > ag = activegraph ; if ( ag != null ) ag . remove ( ) ; }	Internal use only.
@ suppresswarnings ( str_ ) @ override public < t extends element > index < t > getindex ( final string indexname , final class < t > indexclass ) { makeactive ( ) ; final oindexmanager indexmanager = getdatabase ( ) . getmetadata ( ) . getindexmanager ( ) ; final oindex idx = indexmanager . getindex ( indexname ) ; if ( idx == null || ! hasindexclass ( idx ) ) return null ; final index < ? extends element > index = new orientindex ( this , idx ) ; if ( indexclass . isassignablefrom ( index . getindexclass ( ) ) ) return ( index < t > ) index ; else throw exceptionfactory . indexdoesnotsupportclass ( indexname , indexclass ) ; }	Returns an index by name and class.
public void dropindex ( final string indexname ) { makeactive ( ) ; executeoutsidetx ( new ocallable < object , orientbasegraph > ( ) { @ override public object call ( orientbasegraph g ) { try { final oindexmanager indexmanager = getrawgraph ( ) . getmetadata ( ) . getindexmanager ( ) ; final oindex index = indexmanager . getindex ( indexname ) ; odocument metadata = index . getconfiguration ( ) . field ( str_ ) ; string recordmapindexname = null ; if ( metadata != null ) { recordmapindexname = metadata . field ( orientindex . config_record_map_name ) ; } indexmanager . dropindex ( indexname ) ; if ( recordmapindexname != null ) getrawgraph ( ) . getmetadata ( ) . getindexmanager ( ) . dropindex ( recordmapindexname ) ; saveindexconfiguration ( ) ; return null ; } catch ( exception e ) { g . rollback ( ) ; throw new runtimeexception ( e . getmessage ( ) , e ) ; } } } , str_ , indexname , str_ ) ; }	Drops an index by name.
@ override public orientvertex addvertex ( final object id ) { makeactive ( ) ; return addvertex ( id , ( object [ ] ) null ) ; }	Creates a new unconnected vertex with no fields in the Graph.
@ override public orientedge addedge ( final object id , vertex outvertex , vertex invertex , final string label ) { makeactive ( ) ; string classname = null ; string clustername = null ; if ( id != null ) { if ( id instanceof string ) {	Creates an edge between a source Vertex and a destination Vertex setting label as Edge's label.
public orientvertex getvertex ( final object id ) { makeactive ( ) ; if ( null == id ) throw exceptionfactory . vertexidcannotbenull ( ) ; if ( id instanceof orientvertex ) return ( orientvertex ) id ; else if ( id instanceof odocument ) return getvertexinstance ( ( oidentifiable ) id ) ; setcurrentgraphinthreadlocal ( ) ; orid rid ; if ( id instanceof oidentifiable ) rid = ( ( oidentifiable ) id ) . getidentity ( ) ; else { try { rid = new orecordid ( id . tostring ( ) ) ; } catch ( illegalargumentexception iae ) {	Returns a vertex by an ID.
public iterable < vertex > getverticesofclass ( final string iclassname , final boolean ipolymorphic ) { makeactive ( ) ; final oclass cls = getrawgraph ( ) . getmetadata ( ) . getschema ( ) . getclass ( iclassname ) ; if ( cls == null ) throw new illegalargumentexception ( str_ + iclassname + str_ ) ; if ( ! cls . issubclassof ( orientvertextype . class_name ) ) throw new illegalargumentexception ( str_ + iclassname + str_ ) ; return new orientelementscaniterable < vertex > ( this , iclassname , ipolymorphic ) ; }	Get all the Vertices in Graph of a specific vertex class and all sub-classes only if iPolymorphic is true.
public iterable < edge > getedgesofclass ( final string iclassname , final boolean ipolymorphic ) { makeactive ( ) ; final oclass cls = getrawgraph ( ) . getmetadata ( ) . getschema ( ) . getclass ( iclassname ) ; if ( cls == null ) throw new illegalargumentexception ( str_ + iclassname + str_ ) ; if ( ! cls . issubclassof ( orientedgetype . class_name ) ) throw new illegalargumentexception ( str_ + iclassname + str_ ) ; return new orientelementscaniterable < edge > ( this , iclassname , ipolymorphic ) ; }	Get all the Edges in Graph of a specific edges class and all sub-classes only if iPolymorphic is true.
public orientedge getedge ( final object id ) { makeactive ( ) ; if ( null == id ) throw exceptionfactory . edgeidcannotbenull ( ) ; if ( id instanceof orientedge ) return ( orientedge ) id ; else if ( id instanceof odocument ) return new orientedge ( this , ( oidentifiable ) id ) ; final oidentifiable rec ; if ( id instanceof oidentifiable ) rec = ( oidentifiable ) id ; else { final string str = id . tostring ( ) ; int pos = str . indexof ( str_ ) ; if ( pos > - num_ ) {	Returns a edge by an ID.
public orientbasegraph reuse ( final odatabasedocumentinternal idatabase ) { odatabaserecordthreadlocal . instance ( ) . set ( idatabase ) ; this . url = idatabase . geturl ( ) ; database = idatabase ; makeactive ( ) ; return this ; }	Reuses the underlying database avoiding to create and open it every time.
public void shutdown ( boolean closedb , boolean committx ) { makeactive ( ) ; try { if ( ! isclosed ( ) ) { if ( committx ) { final ostorage storage = getdatabase ( ) . getstorage ( ) . getunderlying ( ) ; if ( storage instanceof oabstractpaginatedstorage ) { if ( ( ( oabstractpaginatedstorage ) storage ) . getwalinstance ( ) != null ) getdatabase ( ) . commit ( ) ; } else { getdatabase ( ) . commit ( ) ; } } else if ( closedb ) { getdatabase ( ) . rollback ( ) ; } } } catch ( oneedretryexception e ) { throw e ; } catch ( runtimeexception e ) { ologmanager . instance ( ) . error ( this , str_ + url , e ) ; throw e ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ + url , e ) ; throw oexception . wrapexception ( new odatabaseexception ( str_ + url ) , e ) ; } finally { try { if ( closedb ) { getdatabase ( ) . close ( ) ; if ( getdatabase ( ) . ispooled ( ) ) { database = null ; } } pollgraphfromstack ( closedb ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ + url , e ) ; } } url = null ; username = null ; password = null ; if ( ! closedb ) getdatabase ( ) . activateoncurrentthread ( ) ; }	Closes the Graph. After closing the Graph cannot be used.
public orientvertextype getvertexbasetype ( ) { makeactive ( ) ; return new orientvertextype ( this , getrawgraph ( ) . getmetadata ( ) . getschema ( ) . getclass ( orientvertextype . class_name ) ) ; }	Returns the V persistent class as OrientVertexType instance.
public orientvertextype getvertextype ( final string itypename ) { makeactive ( ) ; final oclass cls = getrawgraph ( ) . getmetadata ( ) . getschema ( ) . getclass ( itypename ) ; if ( cls == null ) return null ; orientvertextype . checktype ( cls ) ; return new orientvertextype ( this , cls ) ; }	Returns the persistent class for type iTypeName as OrientVertexType instance.
public orientvertextype createvertextype ( final string iclassname , final int clusters ) { makeactive ( ) ; return createvertextype ( iclassname , ( string ) null , clusters ) ; }	Creates a new Vertex persistent class.
public void dropvertextype ( final string itypename ) { makeactive ( ) ; if ( getdatabase ( ) . countclass ( itypename ) > num_ ) throw new ocommandexecutionexception ( str_ + itypename + str_ ) ; executeoutsidetx ( new ocallable < oclass , orientbasegraph > ( ) { @ override public oclass call ( final orientbasegraph g ) { odatabasedocument rawgraph = getrawgraph ( ) ; rawgraph . getmetadata ( ) . getschema ( ) . dropclass ( itypename ) ; return null ; } } , str_ , itypename , str_ ) ; }	Drop a vertex class.
public orientedgetype getedgetype ( final string itypename ) { makeactive ( ) ; final oclass cls = getrawgraph ( ) . getmetadata ( ) . getschema ( ) . getclass ( itypename ) ; if ( cls == null ) return null ; orientedgetype . checktype ( cls ) ; return new orientedgetype ( this , cls ) ; }	Returns the persistent class for type iTypeName as OrientEdgeType instance.
public orientedgetype createedgetype ( final string iclassname , final int clusters ) { makeactive ( ) ; return createedgetype ( iclassname , ( string ) null , clusters ) ; }	Creates a new Edge persistent class.
public orientelement getelement ( final object id ) { makeactive ( ) ; if ( null == id ) throw new illegalargumentexception ( str_ ) ; if ( id instanceof orientelement ) return ( orientelement ) id ; oidentifiable rec ; if ( id instanceof oidentifiable ) rec = ( oidentifiable ) id ; else try { rec = new orecordid ( id . tostring ( ) ) ; } catch ( illegalargumentexception iae ) {	Returns a graph element, vertex or edge, starting from an ID.
public < t extends element > void dropkeyindex ( final string key , final class < t > elementclass ) { makeactive ( ) ; if ( elementclass == null ) throw exceptionfactory . classforelementcannotbenull ( ) ; executeoutsidetx ( new ocallable < oclass , orientbasegraph > ( ) { @ override public oclass call ( final orientbasegraph g ) { final string classname = getclassname ( elementclass ) ; getrawgraph ( ) . getmetadata ( ) . getindexmanager ( ) . dropindex ( classname + str_ + key ) ; return null ; } } , str_ , elementclass . getsimplename ( ) , str_ , key , str_ ) ; }	Drops the index against a field name.
@ override public void removebackgroundexceptionlistener ( final obackgroundexceptionlistener listener ) { final list < weakreference < obackgroundexceptionlistener > > itemstoremove = new arraylist < > ( num_ ) ; for ( final weakreference < obackgroundexceptionlistener > ref : backgroundexceptionlisteners ) { final obackgroundexceptionlistener l = ref . get ( ) ; if ( l != null && l . equals ( listener ) ) { itemstoremove . add ( ref ) ; } } backgroundexceptionlisteners . removeall ( itemstoremove ) ; }	Removes listener which is triggered if exception is cast inside background flush data thread.
private void firebackgrounddataflushexceptionevent ( final throwable e ) { for ( final weakreference < obackgroundexceptionlistener > ref : backgroundexceptionlisteners ) { final obackgroundexceptionlistener listener = ref . get ( ) ; if ( listener != null ) { listener . onexception ( e ) ; } } }	Fires event about exception is thrown in data flush thread.
public void stopmonitoring ( ) { switchlock . acquirewritelock ( ) ; try { enabled = bool_ ; final performancecountersholder countersholder = componenttype . general . newcountersholder ( ) ; final map < string , performancecountersholder > componentcountersholder = new hashmap < > ( ) ; writcachecountersholder writcachecountersholder = deadthreadsstatistic . writcachecountersholder ; storagecountersholder storagecountersholder = deadthreadsstatistic . storagecountersholder ; walcountersholder walcountersholder = deadthreadsstatistic . walcountersholder ; deadthreadsstatistic . countersholder . pushdata ( countersholder ) ; componentcountersholder . putall ( deadthreadsstatistic . countersbycomponents ) ; deadthreadsstatistic = null ; for ( osessionstorageperformancestatistic statistic : statistics . values ( ) ) { statistic . pushsystemcounters ( countersholder ) ; statistic . pushcomponentcounters ( componentcountersholder ) ; writcachecountersholder = statistic . pushwritecachecounters ( writcachecountersholder ) ; storagecountersholder = statistic . pushstoragecounters ( storagecountersholder ) ; walcountersholder = statistic . pushwalcounters ( walcountersholder ) ; } statistics . clear ( ) ; postmeasurementstatistic = new immutablestatistic ( countersholder , componentcountersholder , writcachecountersholder , storagecountersholder , walcountersholder ) ; } finally { switchlock . releasewritelock ( ) ; } }	Stops monitoring of performance statistic for whole system.
public void registermbean ( string storagename , int storageid ) { if ( mbeanisregistered . compareandset ( bool_ , bool_ ) ) { try { final mbeanserver server = managementfactory . getplatformmbeanserver ( ) ; final objectname mbeanname = new objectname ( getmbeanname ( storagename , storageid ) ) ; if ( ! server . isregistered ( mbeanname ) ) { server . registermbean ( new operformancestatisticmanagermbean ( this ) , mbeanname ) ; } else { mbeanisregistered . set ( bool_ ) ; ologmanager . instance ( ) . warn ( this , str_ + str_ , mbeanname . getcanonicalname ( ) ) ; } } catch ( malformedobjectnameexception | instancealreadyexistsexception | notcompliantmbeanexception | mbeanregistrationexception e ) { throw oexception . wrapexception ( new ostorageexception ( str_ ) , e ) ; } } }	Registers JMX bean for current manager.
public void unregistermbean ( string storagename , int storageid ) { if ( storagename == null ) { ologmanager . instance ( ) . warnnodb ( this , str_ ) ; } if ( mbeanisregistered . compareandset ( bool_ , bool_ ) ) { try { final mbeanserver server = managementfactory . getplatformmbeanserver ( ) ; final objectname mbeanname = new objectname ( getmbeanname ( storagename , storageid ) ) ; server . unregistermbean ( mbeanname ) ; } catch ( malformedobjectnameexception | instancenotfoundexception | mbeanregistrationexception e ) { throw oexception . wrapexception ( new ostorageexception ( str_ ) , e ) ; } } }	Deregisters JMX bean for current manager.
private writcachecountersholder fetchwritecachecounters ( ) {	Iterates over all live threads and accumulates write performance statics gathered form threads,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
private void fetchsystemcounters ( performancecountersholder countersholder ) {	Iterates over all live threads and accumulates performance statics gathered form threads on system level,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
private void fetchcomponentcounters ( string componentname , performancecountersholder componentcountersholder ) {	Iterates over all live threads and accumulates performance statics gathered form threads for provided component,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
public string getproperty ( final string iname , final string idefaultvalue ) { if ( properties == null ) return null ; for ( oserverentryconfiguration p : properties ) { if ( p . name . equals ( iname ) ) return p . value ; } return null ; }	Returns the property value configured, if any.
public < ret > ret detach ( final object ipojo , boolean returnnonproxiedinstance ) { return ( ret ) oobjectentityserializer . detach ( ipojo , this , returnnonproxiedinstance ) ; }	Method that detaches all fields contained in the document to the given object.
public int getversion ( final object ipojo ) { checkopenness ( ) ; final odocument record = getrecordbyuserobject ( ipojo , bool_ ) ; if ( record != null ) return record . getversion ( ) ; return oobjectserializerhelper . getobjectversion ( ipojo ) ; }	Returns the version number of the object.
public < ret extends ocommandrequest > ret command ( final ocommandrequest icommand ) { return ( ret ) new ocommandsqlpojowrapper ( this , underlying . command ( icommand ) ) ; }	Returns a wrapped OCommandRequest instance to catch the result-set by converting it before to return to the user application.
public void setdirty ( final object ipojo ) { if ( ipojo == null ) return ; final odocument record = getrecordbyuserobject ( ipojo , bool_ ) ; if ( record == null ) throw new oobjectnotmanagedexception ( str_ + ipojo + str_ ) ; record . setdirty ( ) ; }	Sets as dirty a POJO.
public void unsetdirty ( final object ipojo ) { if ( ipojo == null ) return ; final odocument record = getrecordbyuserobject ( ipojo , bool_ ) ; if ( record == null ) return ; orecordinternal . unsetdirty ( record ) ; }	Sets as not dirty a POJO.
private static set < string > getindextypes ( ) { final set < string > types = new hashset < > ( ) ; final iterator < oindexfactory > ite = getallfactories ( ) ; while ( ite . hasnext ( ) ) { types . addall ( ite . next ( ) . gettypes ( ) ) ; } return types ; }	Iterates on all factories and append all index types.
public static set < string > getindexengines ( ) { final set < string > engines = new hashset < > ( ) ; final iterator < oindexfactory > ite = getallfactories ( ) ; while ( ite . hasnext ( ) ) { engines . addall ( ite . next ( ) . getalgorithms ( ) ) ; } return engines ; }	Iterates on all factories and append all index engines.
public list < string > getmissingnodes ( ) { synchronousresponseslock . lock ( ) ; try { final list < string > missingnodes = new arraylist < string > ( ) ; for ( map . entry < string , object > entry : responses . entryset ( ) ) if ( entry . getvalue ( ) == no_response ) missingnodes . add ( entry . getkey ( ) ) ; return missingnodes ; } finally { synchronousresponseslock . unlock ( ) ; } }	Returns the list of node names that didn't provide a response.
protected list < odistributedresponse > getconflictresponses ( ) { final list < odistributedresponse > servers = new arraylist < odistributedresponse > ( ) ; int bestgroupsofar = getbestresponsesgroup ( ) ; for ( int i = num_ ; i < responsegroups . size ( ) ; ++ i ) { if ( i != bestgroupsofar ) { for ( odistributedresponse r : responsegroups . get ( i ) ) servers . add ( r ) ; } } return servers ; }	Returns all the responses in conflict.
protected int getbestresponsesgroup ( ) { int maxcoherentresponses = num_ ; int bestgroupsofar = num_ ; for ( int i = num_ ; i < responsegroups . size ( ) ; ++ i ) { final int currentgroupsize = responsegroups . get ( i ) . size ( ) ; if ( currentgroupsize > maxcoherentresponses ) { maxcoherentresponses = currentgroupsize ; bestgroupsofar = i ; } } return bestgroupsofar ; }	Returns the biggest response group.
private boolean computequorumresponse ( boolean reachedtimeout ) { if ( quorumresponse != null )	Computes the quorum response if possible by returning true and setting the field quorumResponse with the ODistributedResponse.
protected list < odistributedresponse > getreceivedresponses ( ) { final list < odistributedresponse > parsed = new arraylist < odistributedresponse > ( ) ; for ( object r : responses . values ( ) ) if ( r != no_response ) parsed . add ( ( odistributedresponse ) r ) ; return parsed ; }	Returns the received response objects.
public static oexecutionplan get ( string statement , ocommandcontext ctx , odatabasedocumentinternal db ) { if ( db == null ) { throw new illegalargumentexception ( str_ ) ; } if ( statement == null ) { return null ; } oexecutionplancache resource = db . getsharedcontext ( ) . getexecutionplancache ( ) ; oexecutionplan result = resource . getinternal ( statement , ctx , db ) ; return result ; }	returns an already prepared SQL execution plan, taking it from the cache if it exists or creating a new one if it doesn't.
public boolean allowsindexedfunctionexecutionontarget ( ofromclause target , ocommandcontext context ) { return left . allowsindexedfunctionexecutionontarget ( target , context , operator , right . execute ( ( oresult ) null , context ) ) ; }	tests if current expression involves an indexed function AND that function can be used on this target.
public string getlibrary ( final odatabase < ? > db , final string ilanguage ) { if ( db == null )	Formats the library of functions for a language.
public void releasedatabaseengine ( final string ilanguage , final string idatabasename , final opartitionedobjectpool . poolentry < scriptengine > poolentry ) { final odatabasescriptmanager dbmanager = dbmanagers . get ( idatabasename ) ;	Acquires a database engine from the pool. Once finished using it, the instance MUST be returned in the pool by calling themethod.
long getnextposition ( final oatomicoperation atomicoperation ) throws ioexception { final long filledupto = getfilledupto ( atomicoperation , fileid ) ; final long pageindex = filledupto - num_ ; final ocacheentry cacheentry = loadpageforread ( atomicoperation , fileid , pageindex , bool_ , num_ ) ; try { final oclusterpositionmapbucket bucket = new oclusterpositionmapbucket ( cacheentry , bool_ ) ; final int bucketsize = bucket . getsize ( ) ; return pageindex * oclusterpositionmapbucket . max_entries + bucketsize ; } finally { releasepagefromread ( atomicoperation , cacheentry ) ; } }	Returns the next position available.
private int updatesize ( ) { int size = num_ ; if ( collectionpointer != null ) { final osbtreebonsai < oidentifiable , integer > tree = loadtree ( ) ; if ( tree == null ) { throw new illegalstateexception ( str_ ) ; } try { size = tree . getrealbagsize ( changes ) ; } finally { releasetree ( ) ; } } else { for ( change change : changes . values ( ) ) { size += change . applyto ( num_ ) ; } } for ( omodifiableinteger diff : newentries . values ( ) ) { size += diff . getvalue ( ) ; } this . size = size ; return size ; }	Recalculates real bag size.
public v getvalue ( int index ) { int entryposition = getintvalue ( positions_array_offset + index * ointegerserializer . int_size ) ;	Obtains the value stored under the given index in this bucket.
boolean canbeusedbyorderbyafterfilter ( oindex < ? > index , list < string > equalsfilterfields , list < opair < string , string > > orderedfields ) { if ( orderedfields . isempty ( ) ) return bool_ ; if ( ! index . supportsorderediterations ( ) ) return bool_ ; final oindexdefinition definition = index . getdefinition ( ) ; final list < string > indexfields = definition . getfields ( ) ; int endindex = math . min ( indexfields . size ( ) , equalsfilterfields . size ( ) ) ; final string firstorder = orderedfields . get ( num_ ) . getvalue ( ) ;	checks if, given a list of "=" conditions and a set of ORDER BY fields.
public static int indexofoutsidestrings ( final string itext , final char itofind , int ifrom , int ito ) { if ( ito == - num_ ) ito = itext . length ( ) - num_ ; if ( ifrom == - num_ ) ifrom = itext . length ( ) - num_ ; char c ; char stringchar = str_ ; boolean escape = bool_ ; final stringbuilder buffer = new stringbuilder ( num_ ) ; int i = ifrom ; while ( bool_ ) { c = itext . charat ( i ) ; if ( ! escape && c == str_ && ( ( i + num_ ) < itext . length ( ) ) ) { if ( itext . charat ( i + num_ ) == str_ ) { i = readunicode ( itext , i + num_ , buffer ) ; } else escape = bool_ ; } else { if ( c == str_ || c == str_ ) {	Finds a character inside a string specyfing the limits and direction.
public static int jumpwhitespaces ( final charsequence itext , final int icurrentposition , final int imaxposition ) { return jump ( itext , icurrentposition , imaxposition , common_jump ) ; }	Jump white spaces.
public static int jump ( final charsequence itext , int icurrentposition , final int imaxposition , final string ijumpchars ) { if ( icurrentposition < num_ ) return - num_ ; final int size = imaxposition > - num_ ? math . min ( imaxposition , itext . length ( ) ) : itext . length ( ) ; final int jumpcharsize = ijumpchars . length ( ) ; boolean found = bool_ ; char c ; for ( ; icurrentposition < size ; ++ icurrentposition ) { found = bool_ ; c = itext . charat ( icurrentposition ) ; for ( int jumpindex = num_ ; jumpindex < jumpcharsize ; ++ jumpindex ) { if ( ijumpchars . charat ( jumpindex ) == c ) { found = bool_ ; break ; } } if ( ! found ) break ; } return icurrentposition >= size ? - num_ : icurrentposition ; }	Jump some characters reading from an offset of a String.
public oqueryabstract setfetchplan ( final string fetchplan ) { ofetchhelper . checkfetchplanvalid ( fetchplan ) ; if ( fetchplan != null && fetchplan . length ( ) == num_ ) this . fetchplan = null ; else this . fetchplan = fetchplan ; return this ; }	Sets the fetch plan to use.
@ override public void enqueuerepairrecord ( final orecordid rid ) { if ( ! active ) return ; if ( rid == null || ! rid . ispersistent ( ) ) return ; if ( rid . getclusterposition ( ) < - num_ )	Adds the record to repair int the map of records and cluster.
@ override public void cancelrepairrecord ( final orecordid rid ) { if ( ! active ) return ; if ( rid . getclusterposition ( ) < - num_ )	Cancel the repair against a record because the update succeed.
@ override public void enqueuerepaircluster ( final int clusterid ) { if ( ! active ) return ; if ( clusterid < - num_ )	Enqueues the request to repair a cluster.
private map < string , set < string > > getdependencies ( pattern pattern ) { map < string , set < string > > result = new hashmap < string , set < string > > ( ) ; for ( patternnode node : pattern . aliastonode . values ( ) ) { set < string > currentdependencies = new hashset < string > ( ) ; owhereclause filter = aliasfilters . get ( node . alias ) ; if ( filter != null && filter . getbaseexpression ( ) != null ) { list < string > involvedaliases = filter . getbaseexpression ( ) . getmatchpatterninvolvedaliases ( ) ; if ( involvedaliases != null ) { currentdependencies . addall ( involvedaliases ) ; } } result . put ( node . alias , currentdependencies ) ; } return result ; }	Calculate the set of dependency aliases for each alias in the pattern.
public synchronized object createpojo ( final string iclassname ) throws oconfigurationexception { if ( iclassname == null ) throw new illegalargumentexception ( str_ ) ; final class < ? > entityclass = classhandler . getentityclass ( iclassname ) ; try { if ( entityclass != null ) return createinstance ( entityclass ) ; } catch ( exception e ) { throw oexception . wrapexception ( new oconfigurationexception ( str_ + iclassname + str_ ) , e ) ; } try {	Create a POJO by its class name.
public synchronized void registerentityclasses ( final collection < string > iclassnames , final classloader iclassloader ) { ologmanager . instance ( ) . debug ( this , str_ , iclassnames ) ; try { registerentityclasses ( oreflectionhelper . getclassesfor ( iclassnames , iclassloader ) ) ; } catch ( classnotfoundexception e ) { throw oexception . wrapexception ( new odatabaseexception ( str_ ) , e ) ; } }	Registers provided classes.
public synchronized void registerentityclasses ( class < ? > aclass , boolean recursive ) { if ( recursive ) { classhandler . registerentityclass ( aclass ) ; field [ ] declaredfields = aclass . getdeclaredfields ( ) ; for ( field declaredfield : declaredfields ) { class < ? > declaredfieldtype = declaredfield . gettype ( ) ; if ( ! classhandler . containsentityclass ( declaredfieldtype ) ) { registerentityclasses ( declaredfieldtype , recursive ) ; } } } else { classhandler . registerentityclass ( aclass ) ; } }	Scans all classes accessible from the context class loader which belong to the given class and all it's attributes - classes.
public synchronized void setclasshandler ( final oentitymanagerclasshandler iclasshandler ) { iterator < entry < string , class < ? > > > iterator = classhandler . getclassesentryset ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { entry < string , class < ? > > entry = iterator . next ( ) ; boolean forceschemareload = ! iterator . hasnext ( ) ; iclasshandler . registerentityclass ( entry . getvalue ( ) , forceschemareload ) ; } this . classhandler = iclasshandler ; }	Sets the received handler as default and merges the classes all together.
public db acquire ( final string iname , final string iusername , final string iuserpassword ) { setup ( ) ; return dbpool . acquire ( iname , iusername , iuserpassword ) ; }	Acquires a connection from the pool.
public int getavailableconnections ( final string name , final string username ) { setup ( ) ; return dbpool . getavailableconnections ( name , username ) ; }	Returns amount of available connections which you can acquire for given source and user name.
public db acquire ( final string iname , final string iusername , final string iuserpassword , final map < string , object > ioptionalparams ) { setup ( ) ; return dbpool . acquire ( iname , iusername , iuserpassword , ioptionalparams ) ; }	Acquires a connection from the pool specifying options.
public object execute ( final map < object , object > iargs ) { final odatabasedocumentinternal database = getdatabase ( ) ; database . checksecurity ( orule . resourcegeneric . cluster , str_ , orole . permission_update ) ; if ( ! ( database instanceof odatabasedocumentdistributed ) ) { throw new ocommandexecutionexception ( str_ ) ; } final ohazelcastplugin dmanager = ( ohazelcastplugin ) ( ( odatabasedocumentdistributed ) database ) . getdistributedmanager ( ) ; if ( dmanager == null || ! dmanager . isenabled ( ) ) throw new ocommandexecutionexception ( str_ ) ; final string databasename = database . getname ( ) ; try { if ( this . parsedstatement . modefull ) { return replacecluster ( dmanager , database , dmanager . getserverinstance ( ) , databasename , this . parsedstatement . clustername . getstringvalue ( ) ) ; }	Execute the SYNC CLUSTER.
public static synchronized < t extends object > iterator < t > lookupproviderwithorientclassloader ( class < t > clazz ) { return lookupproviderwithorientclassloader ( clazz , oclassloaderhelper . class . getclassloader ( ) ) ; }	Switch to the OrientDb classloader before lookups on ServiceRegistry for implementation of the given Class. Useful under OSGIand generally under applications where jars are loaded by another class loader.
public static void checkcachememoryconfiguration ( ) { final long maxheapsize = runtime . getruntime ( ) . maxmemory ( ) ; final long maxcachesize = getmaxcachememorysize ( ) ; final onative . memorylimitresult physicalmemory = onative . instance ( ) . getmemorylimit ( bool_ ) ; if ( maxheapsize != long . max_value && physicalmemory != null && maxheapsize + maxcachesize > physicalmemory . memorylimit ) ologmanager . instance ( ) . warnnodb ( omemory . class , str_ + maxheapsize + str_ + str_ + maxcachesize + str_ + str_ + physicalmemory + str_ + str_ + str_ ) ; }	Checks the OrientDB cache memory configuration and emits a warning if configuration is invalid.
public static vertex vertexfromjson ( final jsonobject json , final elementfactory factory , final graphsonmode mode , final set < string > propertykeys ) throws ioexception { final ographsonutility graphson = new ographsonutility ( mode , factory , propertykeys , null ) ; return graphson . vertexfromjson ( json ) ; }	Reads an individual Vertex from JSON.
public static edge edgefromjson ( final jsonobject json , final vertex out , final vertex in , final elementfactory factory , final graphsonmode mode , final set < string > propertykeys ) throws ioexception { final ographsonutility graphson = new ographsonutility ( mode , factory , null , propertykeys ) ; return graphson . edgefromjson ( json , out , in ) ; }	Reads an individual Edge from JSON.
public static jsonobject jsonfromelement ( final element element , final set < string > propertykeys , final graphsonmode mode ) throws jsonexception { final ographsonutility graphson = element instanceof edge ? new ographsonutility ( mode , null , null , propertykeys ) : new ographsonutility ( mode , null , propertykeys , null ) ; return graphson . jsonfromelement ( element ) ; }	Creates a Jettison JSONObject from a graph element.
public static objectnode objectnodefromelement ( final element element , final set < string > propertykeys , final graphsonmode mode ) { final ographsonutility graphson = element instanceof edge ? new ographsonutility ( mode , null , null , propertykeys ) : new ographsonutility ( mode , null , propertykeys , null ) ; return graphson . objectnodefromelement ( element ) ; }	Creates a Jackson ObjectNode from a graph element.
public void executeimport ( odocument cfg , oserver server ) { oetljob job = new oetljob ( cfg , server , new oetllistener ( ) { @ override public void onend ( oetljob etljob ) { currentjob = null ; } } ) ; job . validate ( ) ; currentjob = job ; pool . execute ( job ) ; }	Executes import with configuration;.
public odocument status ( ) { odocument status = new odocument ( ) ; collection < odocument > jobs = new arraylist < odocument > ( ) ; if ( currentjob != null ) { jobs . add ( currentjob . status ( ) ) ; } status . field ( str_ , jobs ) ; return status ; }	Status of the Running Jobs.
public map < string , set < string > > getactivedatacentermap ( ) { map < string , set < string > > result = new hashmap < > ( ) ; odistributedconfiguration cfg = getdistributedconfiguration ( ) ; set < string > servers = cfg . getregisteredservers ( ) ; for ( string server : servers ) { string dc = cfg . getdatacenterofserver ( server ) ; set < string > dcconfig = result . get ( dc ) ; if ( dcconfig == null ) { dcconfig = new hashset < > ( ) ; result . put ( dc , dcconfig ) ; } dcconfig . add ( server ) ; } return result ; }	returns the data center map for current deploy. The keys are data center names, the values are node names per data center.
protected static string separatealgorithm ( final string ciphertransform ) { string [ ] array = ciphertransform . split ( str_ ) ; if ( array . length > num_ ) return array [ num_ ] ; return null ; }	Returns the secret key algorithm portion of the cipher transformation.
public static osymmetrickey fromconfig ( final osymmetrickeyconfig keyconfig ) { if ( keyconfig . useskeystring ( ) ) { return fromstring ( keyconfig . getkeyalgorithm ( ) , keyconfig . getkeystring ( ) ) ; } else if ( keyconfig . useskeyfile ( ) ) { return fromfile ( keyconfig . getkeyalgorithm ( ) , keyconfig . getkeyfile ( ) ) ; } else if ( keyconfig . useskeystore ( ) ) { return fromkeystore ( keyconfig . getkeystorefile ( ) , keyconfig . getkeystorepassword ( ) , keyconfig . getkeystorekeyalias ( ) , keyconfig . getkeystorekeypassword ( ) ) ; } else { throw new osecurityexception ( str_ ) ; } }	Creates an OSymmetricKey from an OSymmetricKeyConfig interface.
public static osymmetrickey fromfile ( final string algorithm , final string path ) { string base64key = null ; try { java . io . fileinputstream fis = null ; try { fis = new java . io . fileinputstream ( osystemvariableresolver . resolvesystemvariables ( path ) ) ; return fromstream ( algorithm , fis ) ; } finally { if ( fis != null ) fis . close ( ) ; } } catch ( exception ex ) { throw oexception . wrapexception ( new osecurityexception ( str_ + ex . getmessage ( ) ) , ex ) ; } }	Creates an OSymmetricKey from a file containing a Base64 key.
public static osymmetrickey fromstream ( final string algorithm , final inputstream is ) { string base64key = null ; try { base64key = oioutils . readstreamasstring ( is ) ; } catch ( exception ex ) { throw oexception . wrapexception ( new osecurityexception ( str_ + ex . getmessage ( ) ) , ex ) ; } return new osymmetrickey ( algorithm , base64key ) ; }	Creates an OSymmetricKey from an InputStream containing a Base64 key.
public string encrypt ( final string transform , final byte [ ] bytes ) { string encodedjson = null ; if ( secretkey == null ) throw new osecurityexception ( str_ ) ; if ( transform == null ) throw new osecurityexception ( str_ ) ; try {	This method encrypts an array of bytes.
public void savetostream ( final outputstream os ) { if ( os == null ) throw new osecurityexception ( str_ ) ; try { final outputstreamwriter osw = new outputstreamwriter ( os ) ; try { final bufferedwriter writer = new bufferedwriter ( osw ) ; try { writer . write ( getbase64key ( ) ) ; } finally { writer . close ( ) ; } } finally { os . close ( ) ; } } catch ( exception ex ) { throw oexception . wrapexception ( new osecurityexception ( str_ + ex . getmessage ( ) ) , ex ) ; } }	Saves the internal SecretKey to the specified OutputStream as a Base64 String.
public void savetokeystore ( final outputstream os , final string kspasswd , final string keyalias , final string keypasswd ) { if ( os == null ) throw new osecurityexception ( str_ ) ; if ( kspasswd == null ) throw new osecurityexception ( str_ ) ; if ( keyalias == null ) throw new osecurityexception ( str_ ) ; if ( keypasswd == null ) throw new osecurityexception ( str_ ) ; try { keystore ks = keystore . getinstance ( str_ ) ; char [ ] kspasswdca = kspasswd . tochararray ( ) ; char [ ] keypasswdca = keypasswd . tochararray ( ) ;	Saves the internal SecretKey as a KeyStore.
public ocommandcontext setchild ( final ocommandcontext icontext ) { if ( icontext == null ) { if ( child != null ) {	Set the inherited context avoiding to copy all the values every time.
public synchronized boolean addtouniqueresult ( object o ) { object toadd = o ; if ( o instanceof odocument && ( ( odocument ) o ) . getidentity ( ) . isnew ( ) ) { toadd = new odocumentequalitywrapper ( ( odocument ) o ) ; } return this . uniqueresult . add ( toadd ) ; }	adds an item to the unique result set.
private object getvalueasobjectormap ( odocument irecord , string ifieldvalue , otype itype , otype ilinkedtype , map < string , character > ifieldtypes , boolean inomap , string ioptions ) { final string [ ] fields = ostringparser . getwords ( ifieldvalue . substring ( num_ , ifieldvalue . length ( ) - num_ ) , str_ , bool_ ) ; if ( fields == null || fields . length == num_ ) if ( inomap ) { odocument res = new odocument ( ) ; odocumentinternal . addowner ( res , irecord ) ; return res ; } else return new hashmap < string , object > ( ) ; if ( inomap || hastypefield ( fields ) ) { return getvalueasrecord ( irecord , ifieldvalue , itype , ioptions , fields ) ; } else { return getvalueasmap ( irecord , ifieldvalue , ilinkedtype , ifieldtypes , bool_ , ioptions , fields ) ; } }	OBJECT OR MAP. CHECK THE TYPE ATTRIBUTE TO KNOW IT.
protected string authenticate ( final string username , final string password , final string idatabasename ) throws ioexception { odatabasedocument db = null ; string userrid = null ; try { db = ( odatabasedocument ) server . opendatabase ( idatabasename , username , password ) ; userrid = ( db . getuser ( ) == null ? str_ : db . getuser ( ) . getdocument ( ) . getidentity ( ) . tostring ( ) ) ; } catch ( osecurityaccessexception e ) {	null is returned in all other cases and means authentication was unsuccessful.
@ suppresswarnings ( str_ ) public static object getmapentry ( final map < string , ? > imap , final object ikey ) { if ( imap == null || ikey == null ) return null ; if ( ikey instanceof string ) { string iname = ( string ) ikey ; int pos = iname . indexof ( str_ ) ; if ( pos > - num_ ) iname = iname . substring ( num_ , pos ) ; final object value = imap . get ( iname ) ; if ( value == null ) return null ; if ( pos > - num_ ) { final string restfieldname = iname . substring ( pos + num_ ) ; if ( value instanceof odocument ) return getfieldvalue ( value , restfieldname ) ; else if ( value instanceof map < ? , ? > ) return getmapentry ( ( map < string , ? > ) value , restfieldname ) ; } return value ; } else return imap . get ( ikey ) ; }	Retrieves the value crossing the map with the dotted notation.
protected orecord getrecord ( ) { final orecord record ; if ( reusedrecord != null ) {	Return the record to use for the operation.
protected orecord readcurrentrecord ( orecord irecord , final int imovement ) { if ( limit > - num_ && browsedrecords >= limit )	Read the current record and increment the counter if the record was found.
public orientgraph gettx ( ) { final orientgraph g ; if ( pool == null ) { g = ( orientgraph ) gettxgraphimplfactory ( ) . getgraph ( getdatabase ( ) , user , password , settings ) ; } else {	Gets transactional graph with the database from pool if pool is configured.
public orientgraphnotx getnotx ( ) { final orientgraphnotx g ; if ( pool == null ) { g = ( orientgraphnotx ) getnotxgraphimplfactory ( ) . getgraph ( getdatabase ( ) , user , password , settings ) ; } else {	Gets non transactional graph with the database from pool if pool is configured.
public orientgraphfactory setuppool ( final int imin , final int imax ) { if ( pool != null ) { pool . close ( ) ; } pool = new opartitioneddatabasepool ( url , user , password , num_ , imax ) . setautocreate ( bool_ ) ; properties . entryset ( ) . foreach ( p -> pool . setproperty ( p . getkey ( ) , p . getvalue ( ) ) ) ; return this ; }	Setting up the factory to use database pool instead of creation a new instance of database connection each time.
public object getproperty ( final string iname ) { return properties . get ( iname . tolowercase ( locale . english ) ) ; }	Gets the property value.
@ suppresswarnings ( str_ ) @ override public void stoptransaction ( final conclusion conclusion ) { makeactive ( ) ; if ( getdatabase ( ) . isclosed ( ) || getdatabase ( ) . gettransaction ( ) instanceof otransactionnotx || getdatabase ( ) . gettransaction ( ) . getstatus ( ) != txstatus . begun ) return ; if ( conclusion . success == conclusion ) commit ( ) ; else rollback ( ) ; }	Closes a transaction.
final public token getnexttoken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getnexttoken ( ) ; jj_ntk = - num_ ; jj_gen ++ ; return token ; }	Get the next Token.
final public token gettoken ( int index ) { token t = token ; for ( int i = num_ ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getnexttoken ( ) ; } return t ; }	Get the specific Token.
@ override public iterable < vertex > getvertices ( final direction idirection , final string ... ilabels ) { setcurrentgraphinthreadlocal ( ) ; orientbasegraph . getedgeclassnames ( getgraph ( ) , ilabels ) ; orientbasegraph . encodeclassnames ( ilabels ) ; final odocument doc = getrecord ( ) ; final omulticollectioniterator < vertex > iterable = new omulticollectioniterator < vertex > ( ) ; for ( otriple < string , direction , string > connectionfield : getconnectionfields ( idirection , ilabels ) ) { string fieldname = connectionfield . getkey ( ) ; opair < direction , string > connection = connectionfield . getvalue ( ) ; final object fieldvalue = doc . rawfield ( fieldname ) ; if ( fieldvalue != null ) if ( fieldvalue instanceof oidentifiable ) { addsinglevertex ( doc , iterable , fieldname , connection , fieldvalue , ilabels ) ; } else if ( fieldvalue instanceof collection < ? > ) { collection < ? > coll = ( collection < ? > ) fieldvalue ; if ( coll . size ( ) == num_ ) {	Returns a lazy iterable instance against vertices.
@ override public void remove ( ) { checkclass ( ) ; final orientbasegraph graph = checkifattached ( ) ; graph . setcurrentgraphinthreadlocal ( ) ; graph . autostarttransaction ( ) ; final odocument doc = getrecord ( ) ; if ( doc == null ) throw exceptionfactory . vertexwithiddoesnotexist ( this . getid ( ) ) ; map < string , list < odocument > > treeridbagedgestoremove = new hashmap < string , list < odocument > > ( ) ; if ( ! graph . getrawgraph ( ) . gettransaction ( ) . isactive ( ) ) { for ( string fieldname : doc . fieldnames ( ) ) { final opair < direction , string > connection = getconnection ( direction . both , fieldname ) ; if ( connection == null )	Removes the current Vertex from the Graph.
@ override public edge addedge ( final string label , vertex invertex ) { if ( invertex instanceof partitionvertex )	Creates an edge between current Vertex and a target Vertex setting label as Edge's label.
public orientedge addedge ( final string label , final orientvertex invertex , final string iclassname ) { return addedge ( label , invertex , iclassname , null , ( object [ ] ) null ) ; }	Creates an edge between current Vertex and a target Vertex setting label as Edge's label.
public string getconnectionclass ( final direction idirection , final string ifieldname ) { if ( idirection == direction . out ) { if ( ifieldname . length ( ) > connection_out_prefix . length ( ) ) return ifieldname . substring ( connection_out_prefix . length ( ) ) ; } else if ( idirection == direction . in ) { if ( ifieldname . length ( ) > connection_in_prefix . length ( ) ) return ifieldname . substring ( connection_in_prefix . length ( ) ) ; } return orientedgetype . class_name ; }	Used to extract the class name from the vertex's field.
protected opair < direction , string > getconnection ( final direction idirection , final string ifieldname , string ... iclassnames ) { if ( iclassnames != null && iclassnames . length == num_ && iclassnames [ num_ ] . equalsignorecase ( str_ ) )	Determines if a field is a connections or not.
private void processbrokenrids ( set < orid > brokenrids ) throws ioexception , parseexception { if ( exporterversion >= num_ ) { listener . onmessage ( str_ ) ; jsonreader . readnext ( ojsonreader . begin_collection ) ; while ( bool_ ) { jsonreader . readnext ( ojsonreader . next_in_array ) ; final orecordid recordid = new orecordid ( jsonreader . getvalue ( ) ) ; brokenrids . add ( recordid ) ; if ( jsonreader . lastchar ( ) == str_ ) break ; } } if ( migratelinks ) { if ( exporterversion >= num_ ) listener . onmessage ( brokenrids . size ( ) + str_ + str_ ) ; migratelinksinimporteddocuments ( brokenrids ) ; } }	just read collection so import process can continue.
protected map < method , object > getconsolemethods ( ) { if ( methods != null ) return methods ;	Returns a map of all console method and the object they can be called on.
@ override public object executeonlocalnode ( final odistributedrequestid reqid , final oremotetask task , final odatabasedocumentinternal database ) { if ( database != null && ! ( database . getstorage ( ) instanceof odistributedstorage ) ) throw new odistributedexception ( str_ + database . getname ( ) + str_ + database . getstorage ( ) . getclass ( ) . getname ( ) ) ; final odistributedabstractplugin manager = this ; return oscenariothreadlocal . executeasdistributed ( new callable < object > ( ) { @ override public object call ( ) throws exception { try { final object result = task . execute ( reqid , serverinstance , manager , database ) ; if ( result instanceof throwable && ! ( result instanceof oexception ) )	Executes the request on local node. In case of error returns the Exception itself.
@ override public int getnodeswithstatus ( final collection < string > inodes , final string databasename , final db_status ... statuses ) { for ( iterator < string > it = inodes . iterator ( ) ; it . hasnext ( ) ; ) { final string node = it . next ( ) ; if ( ! isnodestatusequalsto ( node , databasename , statuses ) ) it . remove ( ) ; } return inodes . size ( ) ; }	Returns the nodes with the requested status.
protected void waitfornextretry ( ) { try { thread . sleep ( new random ( ) . nextint ( max_delay - num_ ) + num_ ) ; } catch ( interruptedexception e ) { ologmanager . instance ( ) . error ( this , str_ , e ) ; } }	Wait before to retry.
public string getargument ( final int iposition ) { return args != null && args . length > iposition ? args [ iposition ] : null ; }	Returns the argument by position.
public int hasparameters ( final string ... inames ) { int found = num_ ; if ( inames != null && request . parameters != null ) for ( string name : inames ) found += request . parameters . containskey ( name ) ? num_ : num_ ; return found ; }	Checks how many parameters have been received.
@ deprecated public synchronized oserveradmin connect ( final string iusername , final string iuserpassword ) throws ioexception { final string username ; final string password ; ocredentialinterceptor ci = osecuritymanager . instance ( ) . newcredentialinterceptor ( ) ; if ( ci != null ) { ci . intercept ( storage . geturl ( ) , iusername , iuserpassword ) ; username = ci . getusername ( ) ; password = ci . getpassword ( ) ; } else { username = iusername ; password = iuserpassword ; } oconnect37request request = new oconnect37request ( username , password ) ; networkadminoperation ( ( network , session ) -> { ostorageremotenodesession nodesession = session . getorcreateserversession ( network . getserverurl ( ) ) ; try { network . beginrequest ( request . getcommand ( ) , session ) ; request . write ( network , session ) ; } finally { network . endrequest ( ) ; } oconnectresponse response = request . createresponse ( ) ; try { network . beginresponse ( nodesession . getsessionid ( ) , bool_ ) ; response . read ( network , session ) ; } finally { storage . endresponse ( network ) ; } return null ; } , str_ + storage . geturl ( ) + str_ ) ; return this ; }	Connects to a remote server.
@ deprecated public synchronized map < string , string > listdatabases ( ) throws ioexception { olistdatabasesrequest request = new olistdatabasesrequest ( ) ; olistdatabasesresponse response = networkadminoperation ( request , str_ ) ; return response . getdatabases ( ) ; }	Returns the list of databases on the connected remote server.
@ deprecated public synchronized odocument getserverinfo ( ) throws ioexception { oserverinforequest request = new oserverinforequest ( ) ; oserverinforesponse response = networkadminoperation ( request , str_ ) ; odocument res = new odocument ( ) ; res . fromjson ( response . getresult ( ) ) ; return res ; }	Returns the server information in form of document.
public synchronized boolean existsdatabase ( final string idatabasename , final string storagetype ) throws ioexception { oexistsdatabaserequest request = new oexistsdatabaserequest ( idatabasename , storagetype ) ; oexistsdatabaseresponse response = networkadminoperation ( request , str_ + storage . getname ( ) ) ; return response . isexists ( ) ; }	Checks if a database exists in the remote server.
public synchronized oserveradmin dropdatabase ( final string idatabasename , final string storagetype ) throws ioexception { odropdatabaserequest request = new odropdatabaserequest ( idatabasename , storagetype ) ; odropdatabaseresponse response = networkadminoperation ( request , str_ + storage . getname ( ) ) ; ourlconnection connection = ourlhelper . parse ( geturl ( ) ) ; orientdbremote remote = ( orientdbremote ) odatabasedocumenttxinternal . getorcreateremotefactory ( connection . getpath ( ) ) ; remote . forcedatabaseclose ( idatabasename ) ; odatabaserecordthreadlocal . instance ( ) . remove ( ) ; return this ; }	Drops a database from a remote server instance.
public synchronized oserveradmin freezedatabase ( final string storagetype ) throws ioexception { ofreezedatabaserequest request = new ofreezedatabaserequest ( storage . getname ( ) , storagetype ) ; ofreezedatabaseresponse response = networkadminoperation ( request , str_ + storage . getname ( ) ) ; return this ; }	Freezes the database by locking it in exclusive mode.
public synchronized oserveradmin releasedatabase ( final string storagetype ) throws ioexception { oreleasedatabaserequest request = new oreleasedatabaserequest ( storage . getname ( ) , storagetype ) ; oreleasedatabaseresponse response = networkadminoperation ( request , str_ + storage . getname ( ) ) ; return this ; }	Releases a frozen database.
public odocument clusterstatus ( ) { odistributedstatusrequest request = new odistributedstatusrequest ( ) ; odistributedstatusresponse response = storage . networkoperation ( request , str_ ) ; ologmanager . instance ( ) . debug ( this , str_ , response . getclusterconfig ( ) . tojson ( str_ ) ) ; return response . getclusterconfig ( ) ; }	Gets the cluster status.
public static orientgraph getgraph ( final boolean autostarttx , omodifiableboolean shouldbeshutdown ) { final odatabasedocumentinternal database = odatabaserecordthreadlocal . instance ( ) . get ( ) ; final orientbasegraph result = orientbasegraph . getactivegraph ( ) ; if ( result != null && ( result instanceof orientgraph ) ) { final odatabasedocumentinternal graphdb = result . getrawgraph ( ) ;	Returns a Transactional OrientGraph implementation from the current database in thread local.
protected void parseretry ( ) throws ocommandsqlparsingexception { retry = integer . parseint ( parsernextword ( bool_ ) ) ; string temp = parseoptionalword ( bool_ ) ; if ( temp . equals ( str_ ) ) { wait = integer . parseint ( parsernextword ( bool_ ) ) ; } else parsergoback ( ) ; }	Parses the RETRY number of times.
public orecord saverecord ( final orecord irecord , final string iclustername , final operation_mode imode , boolean iforcecreate , final orecordcallback < ? extends number > irecordcreatedcallback , orecordcallback < integer > irecordupdatedcallback ) { try { return database . saveall ( irecord , iclustername , imode , iforcecreate , irecordcreatedcallback , irecordupdatedcallback ) ; } catch ( exception e ) {	Update the record.
public void deleterecord ( final orecord irecord , final operation_mode imode ) { if ( ! irecord . getidentity ( ) . ispersistent ( ) ) return ; try { database . executedeleterecord ( irecord , irecord . getversion ( ) , bool_ , imode , bool_ ) ; } catch ( exception e ) {	Deletes the record.
public string getauthenticationheader ( string databasename ) { string header ;	databaseName may be null.
public string authenticate ( final string username , final string password ) { string principal = null ; try { if ( getserver ( ) != null ) {	This will authenticate username using the system database.
public boolean isauthorized ( final string username , final string resource ) { if ( username == null || resource == null ) return bool_ ; try { if ( getserver ( ) != null ) { ouser user = getserver ( ) . getsecurity ( ) . getsystemuser ( username , null ) ; if ( user != null && user . getaccountstatus ( ) == osecurityuser . statuses . active ) { orole role = null ; orule . resourcegeneric rg = orule . maplegacyresourcetogenericresource ( resource ) ; if ( rg != null ) { string specificresource = orule . maplegacyresourcetospecificresource ( resource ) ; if ( specificresource == null || specificresource . equals ( str_ ) ) { specificresource = null ; } role = user . checkifallowed ( rg , specificresource , orole . permission_execute ) ; } return role != null ; } } } catch ( exception ex ) { ologmanager . instance ( ) . error ( this , str_ , ex ) ; } return bool_ ; }	Checks to see if a.
@ override public void run ( ) { if ( server != null ) if ( ! server . shutdown ( ) ) {	Catch the JVM exit and assure to shutdown the Orient Server.
public void adjustbeginlinecolumn ( int newline , int newcol ) { int start = tokenbegin ; int len ; if ( bufpos >= tokenbegin ) { len = bufpos - tokenbegin + inbuf + num_ ; } else { len = bufsize - tokenbegin + bufpos + num_ + inbuf ; } int i = num_ , j = num_ , k = num_ ; int nextcoldiff = num_ , columndiff = num_ ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newline ; nextcoldiff = columndiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newcol + columndiff ; columndiff = nextcoldiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newline ++ ; bufcolumn [ j ] = newcol + columndiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newline ++ ; else bufline [ j ] = newline ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; }	Method to adjust line and column numbers for the start of a token.
protected void setbucketpointer ( int pageoffset , obonsaibucketpointer value ) throws ioexception { setlongvalue ( pageoffset , value . getpageindex ( ) ) ; setintvalue ( pageoffset + olongserializer . long_size , value . getpageoffset ( ) ) ; }	Write a bucket pointer to specific location.
protected obonsaibucketpointer getbucketpointer ( int offset ) { final long pageindex = getlongvalue ( offset ) ; final int pageoffset = getintvalue ( offset + olongserializer . long_size ) ; return new obonsaibucketpointer ( pageindex , pageoffset ) ; }	Read bucket pointer from page.
public ologsequencenumber endatomicoperation ( boolean rollback ) throws ioexception { final oatomicoperation operation = currentoperation . get ( ) ; if ( operation == null ) { ologmanager . instance ( ) . error ( this , str_ , null ) ; throw new odatabaseexception ( str_ ) ; } int counter = operation . getcounter ( ) ; operation . decrementcounter ( ) ; assert counter > num_ ; final ologsequencenumber lsn ; try { if ( rollback ) { operation . rollback ( ) ; } if ( counter == num_ ) { try { final boolean usewal = usewal ( ) ; if ( ! operation . isrollback ( ) ) { lsn = operation . commitchanges ( usewal ? writeaheadlog : null ) ; } else { lsn = null ; } if ( trackatomicoperations ) { activeatomicoperations . remove ( operation . getoperationunitid ( ) ) ; } } finally { final iterator < string > lockedobjectiterator = operation . lockedobjects ( ) . iterator ( ) ; while ( lockedobjectiterator . hasnext ( ) ) { final string lockedobject = lockedobjectiterator . next ( ) ; lockedobjectiterator . remove ( ) ; lockmanager . releaselock ( this , lockedobject , ooneentryperkeylockmanager . lock . exclusive ) ; } currentoperation . set ( null ) ; } } else { lsn = null ; } } catch ( error e ) { final oabstractpaginatedstorage st = storage ; if ( st != null ) { st . handlejvmerror ( e ) ; } counter = num_ ; throw e ; } finally { if ( counter == num_ ) { atomicoperationscount . decrement ( ) ; } } return lsn ; }	Ends the current atomic operation on this manager.
public void acquireexclusivelocktilloperationcomplete ( oatomicoperation operation , string lockname ) { if ( operation . containsinlockedobjects ( lockname ) ) { return ; } lockmanager . acquirelock ( lockname , ooneentryperkeylockmanager . lock . exclusive ) ; operation . addlockedobject ( lockname ) ; }	Acquires exclusive lock with the given lock name in the given atomic operation.
public void changemaximumamountofmemory ( final long readcachemaxmemory ) throws illegalstateexception { memorydata memorydata ; memorydata newmemorydata ; final int newmemorysize = normalizememory ( readcachemaxmemory , pagesize ) ; do { memorydata = memorydatacontainer . get ( ) ; if ( memorydata . maxsize == newmemorysize ) { return ; } if ( ( num_ * memorydata . pinnedpages / newmemorysize ) > percentofpinnedpages ) { throw new illegalstateexception ( str_ + str_ + percentofpinnedpages ) ; } newmemorydata = new memorydata ( newmemorysize , memorydata . pinnedpages ) ; } while ( ! memorydatacontainer . compareandset ( memorydata , newmemorydata ) ) ;	Changes amount of memory which may be used by given cache.
private void listen ( final string ihostname , final string ihostportrange , final string iprotocolname , class < ? extends onetworkprotocol > protocolclass ) { for ( int port : getports ( ihostportrange ) ) { inboundaddr = new inetsocketaddress ( ihostname , port ) ; try { serversocket = socketfactory . createserversocket ( port , num_ , inetaddress . getbyname ( ihostname ) ) ; if ( serversocket . isbound ( ) ) { ologmanager . instance ( ) . info ( this , str_ + iprotocolname + str_ + inboundaddr . getaddress ( ) . gethostaddress ( ) + str_ + inboundaddr . getport ( ) + str_ + protocolversion + str_ + socketfactory . getname ( ) + str_ ) ; return ; } } catch ( bindexception be ) { ologmanager . instance ( ) . warn ( this , str_ , ihostname , port ) ; } catch ( socketexception se ) { ologmanager . instance ( ) . error ( this , str_ , se ) ; throw new runtimeexception ( se ) ; } catch ( ioexception ioe ) { ologmanager . instance ( ) . error ( this , str_ , ioe ) ; system . err . println ( str_ ) ; throw new runtimeexception ( ioe ) ; } } ologmanager . instance ( ) . error ( this , str_ , null , ihostportrange , ihostname ) ; throw new osystemexception ( str_ ) ; }	Initialize a server socket for communicating with the client.
private void readparameters ( final ocontextconfiguration iserverconfig , final oserverparameterconfiguration [ ] iparameters ) { configuration = new ocontextconfiguration ( iserverconfig ) ;	Initializes connection parameters by the reading XML configuration.
public void shutdown ( ) { if ( shutdownflag . compareandset ( bool_ , bool_ ) ) { try { if ( logmanager . getlogmanager ( ) instanceof shutdownlogmanager ) ( ( shutdownlogmanager ) logmanager . getlogmanager ( ) ) . shutdown ( ) ; } catch ( noclassdeffounderror ignore ) {	Shutdowns this log manager.
public void add ( k key , v item ) throws interruptedexception { if ( ! item . isopen ( ) ) throw new illegalargumentexception ( str_ ) ; checkopenfileslimit ( ) ; final oclosableentry < k , v > closableentry = new oclosableentry < k , v > ( item ) ; final oclosableentry < k , v > oldentry = data . putifabsent ( key , closableentry ) ; if ( oldentry != null ) { throw new illegalstateexception ( str_ + key + str_ ) ; } logadd ( closableentry ) ; }	Adds item to the container.Item should be in open state.
public v remove ( k key ) { final oclosableentry < k , v > removed = data . remove ( key ) ; if ( removed != null ) { long prestatus = removed . makeretired ( ) ; if ( oclosableentry . isopen ( prestatus ) ) { countclosedfiles ( ) ; } logremoved ( removed ) ; return removed . get ( ) ; } return null ; }	Removes item associated with passed in key.
public oclosableentry < k , v > acquire ( k key ) throws interruptedexception { checkopenfileslimit ( ) ; final oclosableentry < k , v > entry = data . get ( key ) ; if ( entry == null ) return null ; boolean logopen = bool_ ; entry . acquirestatelock ( ) ; try { if ( entry . isretired ( ) || entry . isdead ( ) ) { return null ; } else if ( entry . isclosed ( ) ) { entry . makeacquiredfromclosed ( entry . get ( ) ) ; logopen = bool_ ; } else if ( entry . isopen ( ) ) { entry . makeacquiredfromopen ( ) ; } else { entry . incrementacquired ( ) ; } } finally { entry . releasestatelock ( ) ; } if ( logopen ) { logopen ( entry ) ; } else { logacquire ( entry ) ; } assert entry . get ( ) . isopen ( ) ; return entry ; }	Acquires item associated with passed in key in container.It is guarantied that item will not be closed if limit of open items will be exceeded and container will close rarely useditems.
public v get ( k key ) { final oclosableentry < k , v > entry = data . get ( key ) ; if ( entry != null ) return entry . get ( ) ; return null ; }	Returns item without acquiring it.
public void clear ( ) { lrulock . lock ( ) ; try { data . clear ( ) ; openfiles . set ( num_ ) ; for ( int n = num_ ; n < number_of_read_buffers ; n ++ ) { final atomicreference < oclosableentry < k , v > > [ ] buffer = readbuffers [ n ] ; for ( int i = num_ ; i < read_buffer_size ; i ++ ) { buffer [ i ] . set ( null ) ; } readbufferreadcount [ n ] = num_ ; readbufferwritecount [ n ] . set ( num_ ) ; readbufferdrainatwritecount [ n ] . set ( num_ ) ; } statebuffer . clear ( ) ; while ( lrulist . poll ( ) != null ) ; } finally { lrulock . unlock ( ) ; } }	Clears all content.
public boolean close ( k key ) { emptybuffers ( ) ; final oclosableentry < k , v > entry = data . get ( key ) ; if ( entry == null ) return bool_ ; if ( entry . makeclosed ( ) ) { countclosedfiles ( ) ; return bool_ ; } return bool_ ; }	Closes item related to passed in key.Item will be closed if it exists and is not acquired.
private void emptyreadbuffers ( ) { for ( int n = num_ ; n < number_of_read_buffers ; n ++ ) { atomicreference < oclosableentry < k , v > > [ ] buffer = readbuffers [ n ] ; long writecount = readbufferdrainatwritecount [ n ] . get ( ) ; long counter = readbufferreadcount [ n ] ; while ( bool_ ) { final int bufferindex = ( int ) ( counter & read_buffer_index_mask ) ; final atomicreference < oclosableentry < k , v > > eref = buffer [ bufferindex ] ; final oclosableentry < k , v > entry = eref . get ( ) ; if ( entry == null ) break ; applyread ( entry ) ; counter ++ ; eref . lazyset ( null ) ; } readbufferreadcount [ n ] = counter ; readbufferdrainatwritecount [ n ] . lazyset ( writecount ) ; } }	Read content of all read buffers and reorder elements inside of LRU list to update internal statistic.Method has to be wrapped by LRU lock.
private void afterwrite ( runnable task ) { statebuffer . add ( task ) ; drainstatus . lazyset ( drainstatus . required ) ; trytodrainbuffers ( ) ; }	Method is used to log operations which change content of the container.Such changes should be flushed immediately to update content of LRU list.
private void afterread ( oclosableentry < k , v > entry ) { final int bufferindex = readbufferindex ( ) ; final long writecount = putentryinreadbuffer ( entry , bufferindex ) ; drainreadbuffersifneeded ( bufferindex , writecount ) ; }	Method is used to log operations which do not change LRU list content but affect order of items inside of LRU list.Such changes may be delayed till buffer will be full.
private long putentryinreadbuffer ( oclosableentry < k , v > entry , int bufferindex ) {	Adds entry to the read buffer with selected index and returns amount of writes to this buffer since creation of this container.
private static int closestpoweroftwo ( int value ) { int n = value - num_ ; n |= n > > > num_ ; n |= n > > > num_ ; n |= n > > > num_ ; n |= n > > > num_ ; n |= n > > > num_ ; return ( n < num_ ) ? num_ : ( n >= ( num_ << num_ ) ) ? num_ << num_ : n + num_ ; }	Finds closest power of two for given integer value.
public boolean onevent ( olivequerypushrequest pushrequest ) { odatabasedocumentinternal old = odatabaserecordthreadlocal . instance ( ) . getifdefined ( ) ; try { database . activateoncurrentthread ( ) ; if ( pushrequest . getstatus ( ) == olivequerypushrequest . error ) { onerror ( pushrequest . geterrorcode ( ) . newexception ( pushrequest . geterrormessage ( ) , null ) ) ; return bool_ ; } else { for ( olivequeryresult result : pushrequest . getevents ( ) ) { switch ( result . geteventtype ( ) ) { case olivequeryresult . create_event : listener . oncreate ( database , result . getcurrentvalue ( ) ) ; break ; case olivequeryresult . update_event : listener . onupdate ( database , result . getoldvalue ( ) , result . getcurrentvalue ( ) ) ; break ; case olivequeryresult . delete_event : listener . ondelete ( database , result . getcurrentvalue ( ) ) ; break ; } } if ( pushrequest . getstatus ( ) == olivequerypushrequest . end ) { onend ( ) ; return bool_ ; } } return bool_ ; } finally { odatabaserecordthreadlocal . instance ( ) . set ( old ) ; } }	Return true if the push request require an unregister.
private void convert ( final object ikey ) { if ( converted ) return ; if ( super . containskey ( ikey ) ) return ; object o = underlying . get ( string . valueof ( ikey ) ) ; if ( o instanceof number ) super . put ( ikey , enumclass . getenumconstants ( ) [ ( ( number ) o ) . intvalue ( ) ] ) ; else super . put ( ikey , enum . valueof ( enumclass , o . tostring ( ) ) ) ; }	Assure that the requested key is converted.
protected void convertall ( ) { if ( converted ) return ; for ( java . util . map . entry < object , object > e : underlying . entryset ( ) ) { if ( e . getvalue ( ) instanceof number ) super . put ( e . getkey ( ) , enumclass . getenumconstants ( ) [ ( ( number ) e . getvalue ( ) ) . intvalue ( ) ] ) ; else super . put ( e . getkey ( ) , enum . valueof ( enumclass , e . getvalue ( ) . tostring ( ) ) ) ; } converted = bool_ ; }	Converts all the items.
@ suppresswarnings ( str_ ) public < t > obinaryserializer < t > getobjectserializer ( final otype type ) { return ( obinaryserializer < t > ) serializertypemap . get ( type ) ; }	Obtain OBinarySerializer realization for the OType.
private void initshutdownqueue ( ) { addshutdownhandler ( new oshutdownworkershandler ( ) ) ; addshutdownhandler ( new oshutdownorientdbinstanceshandler ( ) ) ; addshutdownhandler ( new oshutdownpendingthreadshandler ( ) ) ; addshutdownhandler ( new oshutdownprofilerhandler ( ) ) ; addshutdownhandler ( new oshutdowncalllistenershandler ( ) ) ; }	Adds shutdown handlers in order which will be used during execution of shutdown.
public oengine getengine ( final string enginename ) { enginelock . readlock ( ) . lock ( ) ; try { return engines . get ( enginename ) ; } finally { enginelock . readlock ( ) . unlock ( ) ; } }	Returns the engine by its name.
private readersentry addstate ( ) { final atomicinteger state = new atomicinteger ( srwl_state_not_reading ) ; final readersentry newentry = new readersentry ( state ) ; entry . set ( newentry ) ; readersstatelist . add ( state ) ; readersstatearrayref . set ( null ) ; return newentry ; }	Creates a new ReadersEntry instance for the current thread andits associated AtomicInteger to store the state of the Reader.
public ouser authenticate ( final otoken authtoken ) { final string dbname = getdatabase ( ) . getname ( ) ; if ( authtoken . getisvalid ( ) != bool_ ) { throw new osecurityaccessexception ( dbname , str_ ) ; } ouser user = authtoken . getuser ( getdatabase ( ) ) ; if ( user == null && authtoken . getusername ( ) != null ) {	Token MUST be validated before being passed to this method.
public ouser createmetadata ( ) { final odatabasedocument database = getdatabase ( ) ; oclass identityclass = database . getmetadata ( ) . getschema ( ) . getclass ( oidentity . class_name ) ;	Repairs the security structure if broken by creating the ADMIN role and user with default password.
public boolean tryacquirereadlock ( long timeout ) { final omodifiableinteger lholds = lockholds . get ( ) ; final int holds = lholds . intvalue ( ) ; if ( holds > num_ ) {	Tries to acquire lock during provided interval of time and returns either if provided time interval was passed orif lock was acquired.
@ override public orientvertex getvertex ( final direction direction ) { final orientbasegraph graph = setcurrentgraphinthreadlocal ( ) ; if ( direction . equals ( direction . out ) ) return graph . getvertex ( getoutvertex ( ) ) ; else if ( direction . equals ( direction . in ) ) return graph . getvertex ( getinvertex ( ) ) ; else throw exceptionfactory . bothisnotsupported ( ) ; }	Returns the connected incoming or outgoing vertex.
@ override public object getid ( ) { if ( rawelement == null )	Returns the Edge Id assuring to save it if it's transient yet.
@ override public void setproperty ( final string key , final object value ) { setcurrentgraphinthreadlocal ( ) ; if ( rawelement == null )	Set a Property value.
@ override public < t > t removeproperty ( string key ) { setcurrentgraphinthreadlocal ( ) ; if ( rawelement != null )	Removed a Property.
@ override public void clear ( ) throws ioexception { boolean rollback = bool_ ; final oatomicoperation atomicoperation = startatomicoperation ( bool_ ) ; try { final lock lock = file_lock_manager . acquireexclusivelock ( fileid ) ; try { final queue < obonsaibucketpointer > subtreestodelete = new linkedlist < > ( ) ; final ocacheentry cacheentry = loadpageforwrite ( atomicoperation , fileid , rootbucketpointer . getpageindex ( ) , bool_ , bool_ ) ; try { osbtreebonsaibucket < k , v > rootbucket = new osbtreebonsaibucket < > ( cacheentry , rootbucketpointer . getpageoffset ( ) , keyserializer , valueserializer , this ) ; addchildrentoqueue ( subtreestodelete , rootbucket ) ; rootbucket . shrink ( num_ ) ; rootbucket = new osbtreebonsaibucket < > ( cacheentry , rootbucketpointer . getpageoffset ( ) , bool_ , keyserializer , valueserializer , this ) ; rootbucket . settreesize ( num_ ) ; } finally { releasepagefromwrite ( atomicoperation , cacheentry ) ; } recyclesubtrees ( subtreestodelete , atomicoperation ) ; } finally { lock . unlock ( ) ; } } catch ( final exception e ) { rollback = bool_ ; throw e ; } finally { endatomicoperation ( rollback ) ; } }	Removes all entries from bonsai tree.
@ override public void delete ( ) throws ioexception { boolean rollback = bool_ ; final oatomicoperation atomicoperation = startatomicoperation ( bool_ ) ; try { final lock lock = file_lock_manager . acquireexclusivelock ( fileid ) ; try { final queue < obonsaibucketpointer > subtreestodelete = new linkedlist < > ( ) ; subtreestodelete . add ( rootbucketpointer ) ; recyclesubtrees ( subtreestodelete , atomicoperation ) ; } finally { lock . unlock ( ) ; } } catch ( final exception e ) { rollback = bool_ ; throw e ; } finally { endatomicoperation ( rollback ) ; } }	Deletes a whole tree.
public void end ( ) { final oclass vclass = db . getmetadata ( ) . getschema ( ) . getclass ( vertexclass ) ; try { runningthreads = new atomicinteger ( parallel ) ; for ( int i = num_ ; i < parallel - num_ ; i ++ ) { thread t = new batchimporterjob ( i , vclass ) ; t . start ( ) ; } thread t = new batchimporterjob ( parallel - num_ , vclass ) ; t . run ( ) ; if ( runningthreads . get ( ) > num_ ) { synchronized ( runningthreads ) { while ( runningthreads . get ( ) > num_ ) { try { runningthreads . wait ( ) ; } catch ( interruptedexception e ) { } } } } } finally { db . activateoncurrentthread ( ) ; db . declareintent ( null ) ; db . close ( ) ; if ( walactive ) oglobalconfiguration . use_wal . setvalue ( bool_ ) ; } }	Flushes data to db and closes the db.
public void createvertex ( final long v ) { last = last < v ? v : last ; final list < long > outlist = out . get ( v ) ; if ( outlist == null ) { out . put ( v , new arraylist < long > ( averageedgenumberpernode <= num_ ? num_ : averageedgenumberpernode ) ) ; } }	Creates a new vertex.
protected boolean parsestrategy ( final string w ) throws ocommandsqlparsingexception { if ( ! w . equals ( keyword_strategy ) ) return bool_ ; final string strategyword = parsernextword ( bool_ ) ; try { traverse . setstrategy ( otraverse . strategy . valueof ( strategyword . touppercase ( locale . english ) ) ) ; } catch ( illegalargumentexception ignore ) { throwparsingexception ( str_ + keyword_strategy + str_ + arrays . tostring ( otraverse . strategy . values ( ) ) ) ; } return bool_ ; }	Parses the strategy keyword if found.
private list < recordinfo > getpositionsfromembeddedcollection ( final bytescontainer bytes , int serializerversion ) { list < recordinfo > retlist = new arraylist < > ( ) ; int numberofelements = ovarintserializer . readasinteger ( bytes ) ;	returns begin position and length for each value in embedded collection.
public object execute ( final map < object , object > iargs ) { if ( newrecords == null && content == null && subquery == null ) throw new ocommandexecutionexception ( str_ ) ; final ocommandparameters commandparameters = new ocommandparameters ( iargs ) ; if ( indexname != null ) { if ( newrecords == null ) throw new ocommandexecutionexception ( str_ ) ; final oindex < ? > index = getdatabase ( ) . getmetadata ( ) . getindexmanager ( ) . getindex ( indexname ) ; if ( index == null ) throw new ocommandexecutionexception ( str_ + indexname + str_ ) ;	Execute the INSERT and return the ODocument object created.
protected boolean fixlink ( final object fieldvalue ) { if ( fieldvalue instanceof oidentifiable ) { final orid id = ( ( oidentifiable ) fieldvalue ) . getidentity ( ) ; if ( id . getclusterid ( ) == num_ && id . getclusterposition ( ) == num_ ) return bool_ ; if ( id . isvalid ( ) ) if ( id . ispersistent ( ) ) { final orecord connected = ( ( oidentifiable ) fieldvalue ) . getrecord ( ) ; if ( connected == null ) return bool_ ; } else return bool_ ; } return bool_ ; }	Checks if the link must be fixed.
public static orecordabstract fill ( final orecord record , final orid irid , final int iversion , final byte [ ] ibuffer , final boolean idirty ) { final orecordabstract rec = ( orecordabstract ) record ; rec . fill ( irid , iversion , ibuffer , idirty ) ; return rec ; }	Internal only. Fills in one shot the record.
public static void setversion ( final orecord record , final int iversion ) { final orecordabstract rec = ( orecordabstract ) record ; rec . setversion ( iversion ) ; }	Internal only. Sets the version.
public static byte getrecordtype ( final orecord record ) { if ( record instanceof orecordabstract ) { return ( ( orecordabstract ) record ) . getrecordtype ( ) ; } final orecordabstract rec = ( orecordabstract ) record . getrecord ( ) ; return rec . getrecordtype ( ) ; }	Internal only. Return the record type.
public void initdatabaseinstance ( ) { if ( database == null ) { for ( int retry = num_ ; retry < num_ ; ++ retry ) { try { database = distributed . getdatabaseinstance ( ) ;	Opens the database.
public string printexceptionstacktrace ( exception e , string level ) {	Builds the exception stack trace and prints it according to a level passed as argument.
private void convertlink2record ( final object ikey ) { if ( status == multivalue_content_type . all_records ) return ; final object value ; if ( ikey instanceof orid ) value = ikey ; else value = super . get ( ikey ) ; if ( value != null && value instanceof orid ) { final orid rid = ( orid ) value ; marshalling = bool_ ; try { try {	Convert the item with the received key to a record.
public void registercommand ( final oservercommand iservercommandinstance ) { for ( string name : iservercommandinstance . getnames ( ) ) if ( ostringserializerhelper . contains ( name , str_ ) ) { restcommands . put ( name , iservercommandinstance ) ; } else if ( ostringserializerhelper . contains ( name , str_ ) ) wildcardcommands . put ( name , iservercommandinstance ) ; else exactcommands . put ( name , iservercommandinstance ) ; iservercommandinstance . configure ( server ) ; }	Register all the names for the same instance.
protected oserveruserconfiguration createserveruser ( final odocument userdoc ) { oserveruserconfiguration usercfg = null ; if ( userdoc . containsfield ( str_ ) && userdoc . containsfield ( str_ ) ) { final string user = userdoc . field ( str_ ) ; final string resources = userdoc . field ( str_ ) ; string password = userdoc . field ( str_ ) ; if ( password == null ) password = str_ ; usercfg = new oserveruserconfiguration ( user , password , resources ) ; } return usercfg ; }	Derived implementations can override this method to provide new server user implementations.
public list < oindexsearchresult > analyzecondition ( osqlfiltercondition condition , final oclass schemaclass , ocommandcontext context ) { final list < oindexsearchresult > indexsearchresults = new arraylist < oindexsearchresult > ( ) ; oindexsearchresult lastcondition = analyzefilterbranch ( schemaclass , condition , indexsearchresults , context ) ; if ( indexsearchresults . isempty ( ) && lastcondition != null ) { indexsearchresults . add ( lastcondition ) ; } collections . sort ( indexsearchresults , new comparator < oindexsearchresult > ( ) { public int compare ( final oindexsearchresult searchresultone , final oindexsearchresult searchresulttwo ) { return searchresulttwo . getfieldcount ( ) - searchresultone . getfieldcount ( ) ; } } ) ; return indexsearchresults ; }	Analyzes a query filter for a possible indexation options.
private oindexsearchresult createindexedproperty ( final osqlfiltercondition icondition , final object iitem , ocommandcontext ctx ) { if ( iitem == null || ! ( iitem instanceof osqlfilteritemfield ) ) { return null ; } if ( icondition . getleft ( ) instanceof osqlfilteritemfield && icondition . getright ( ) instanceof osqlfilteritemfield ) { return null ; } final osqlfilteritemfield item = ( osqlfilteritemfield ) iitem ; if ( item . haschainoperators ( ) && ! item . isfieldchain ( ) ) { return null ; } boolean inverted = icondition . getright ( ) == iitem ; final object origvalue = inverted ? icondition . getleft ( ) : icondition . getright ( ) ; oqueryoperator operator = icondition . getoperator ( ) ; if ( inverted ) { if ( operator instanceof oqueryoperatorin ) { operator = new oqueryoperatorcontains ( ) ; } else if ( operator instanceof oqueryoperatorcontains ) { operator = new oqueryoperatorin ( ) ; } else if ( operator instanceof oqueryoperatormajor ) { operator = new oqueryoperatorminor ( ) ; } else if ( operator instanceof oqueryoperatorminor ) { operator = new oqueryoperatormajor ( ) ; } else if ( operator instanceof oqueryoperatormajorequals ) { operator = new oqueryoperatorminorequals ( ) ; } else if ( operator instanceof oqueryoperatorminorequals ) { operator = new oqueryoperatormajorequals ( ) ; } } if ( icondition . getoperator ( ) instanceof oqueryoperatorbetween || operator instanceof oqueryoperatorin ) { return new oindexsearchresult ( operator , item . getfieldchain ( ) , origvalue ) ; } final object value = osqlhelper . getvalue ( origvalue , null , ctx ) ; return new oindexsearchresult ( operator , item . getfieldchain ( ) , value ) ; }	Add SQL filter field to the search candidate list.
public void attach ( final object self ) throws illegalargumentexception , illegalaccessexception , nosuchmethodexception , invocationtargetexception { for ( class < ? > currentclass = self . getclass ( ) ; currentclass != object . class ; ) { if ( proxy . class . isassignablefrom ( currentclass ) ) { currentclass = currentclass . getsuperclass ( ) ; continue ; } for ( field f : currentclass . getdeclaredfields ( ) ) { final string fieldname = f . getname ( ) ; final class < ? > declaringclass = f . getdeclaringclass ( ) ; if ( oobjectentityserializer . istransientfield ( declaringclass , fieldname ) || oobjectentityserializer . isversionfield ( declaringclass , fieldname ) || oobjectentityserializer . isidfield ( declaringclass , fieldname ) ) continue ; object value = oobjectentityserializer . getfieldvalue ( f , self ) ; value = setvalue ( self , fieldname , value ) ; oobjectentityserializer . setfieldvalue ( f , self , value ) ; } currentclass = currentclass . getsuperclass ( ) ; if ( currentclass == null || currentclass . equals ( odocument . class ) )	Method that attaches all data contained in the object to the associated document.
private oclass getindexclass ( ocommandcontext ctx ) { if ( classname == null ) { return null ; } oclass result = ctx . getdatabase ( ) . getmetadata ( ) . getschema ( ) . getclass ( classname . getstringvalue ( ) ) ; if ( result == null ) { throw new ocommandexecutionexception ( str_ + classname ) ; } return result ; }	calculates the indexed class based on the class name.
protected long nextwithnewcurrentvalue ( long currentvalue , boolean executeviadistributed ) throws osequencelimitreachedexception , odatabaseexception { if ( ! executeviadistributed ) {	first set new current value then call next.
public void truncate ( ) throws ioexception { odatabasedocumentinternal db = getdatabase ( ) ; db . checksecurity ( orule . resourcegeneric . class , orole . permission_update ) ; if ( issubclassof ( osecurityshared . restricted_classname ) ) { throw new osecurityexception ( str_ + getname ( ) + str_ + osecurityshared . restricted_classname + str_ ) ; } final ostorage storage = db . getstorage ( ) ; acquireschemareadlock ( ) ; try { for ( int id : clusterids ) { ocluster cl = storage . getclusterbyid ( id ) ; db . checkforclusterpermissions ( cl . getname ( ) ) ; cl . truncate ( ) ; } for ( oindex < ? > index : getclassindexes ( ) ) index . clear ( ) ; set < oindex < ? > > superclassindexes = new hashset < oindex < ? > > ( ) ; superclassindexes . addall ( getindexes ( ) ) ; superclassindexes . removeall ( getclassindexes ( ) ) ; for ( oindex index : superclassindexes ) { index . rebuild ( ) ; } } finally { releaseschemareadlock ( ) ; } }	Truncates all the clusters the class uses.
protected oclass addbaseclass ( final oclassimpl ibaseclass ) { checkrecursion ( ibaseclass ) ; if ( subclasses == null ) subclasses = new arraylist < oclass > ( ) ; if ( subclasses . contains ( ibaseclass ) ) return this ; subclasses . add ( ibaseclass ) ; addpolymorphicclusteridswithinheritance ( ibaseclass ) ; return this ; }	Adds a base class to the current one.
protected void addpolymorphicclusterids ( final oclassimpl ibaseclass ) { set < integer > clusters = new treeset < integer > ( ) ; for ( int clusterid : polymorphicclusterids ) { clusters . add ( clusterid ) ; } for ( int clusterid : ibaseclass . polymorphicclusterids ) { if ( clusters . add ( clusterid ) ) { try { addclusteridtoindexes ( clusterid ) ; } catch ( runtimeexception e ) { ologmanager . instance ( ) . warn ( this , str_ , e , clusterid , getname ( ) ) ; clusters . remove ( clusterid ) ; } } } polymorphicclusterids = new int [ clusters . size ( ) ] ; int i = num_ ; for ( integer cluster : clusters ) { polymorphicclusterids [ i ] = cluster ; i ++ ; } }	Add different cluster id to the "polymorphic cluster ids" array.
private static oidentifiable linktostream ( final stringbuilder buffer , final odocument iparentrecord , object ilinked ) { if ( ilinked == null )	Serialize the link.
public final void release ( opointer pointer ) { if ( track ) { pointermapping . remove ( pointer ) ; } long poolsize = pointerspoolsize . incrementandget ( ) ; if ( poolsize > this . poolsize ) { pointerspoolsize . decrementandget ( ) ; allocator . deallocate ( pointer ) ; } else { pointerspool . add ( pointer ) ; } }	Put buffer which is not used any more back to the pool or frees direct memory if pool is full.
public void checkmemoryleaks ( ) { boolean detected = bool_ ; if ( track ) { for ( map . entry < opointer , pointertracker > entry : pointermapping . entryset ( ) ) { ologmanager . instance ( ) . errornodb ( this , str_ , entry . getvalue ( ) . allocation , system . identityhashcode ( entry . getkey ( ) ) ) ; detected = bool_ ; } } assert ! detected ; }	Checks whether there are not released buffers in the pool.
public void clear ( ) { for ( opointer pointer : pointerspool ) { allocator . deallocate ( pointer ) ; } pointerspool . clear ( ) ; pointerspoolsize . set ( num_ ) ; for ( opointer pointer : pointermapping . keyset ( ) ) { allocator . deallocate ( pointer ) ; } pointermapping . clear ( ) ; }	Clears pool and dealocates memory.
public static int bytes2int ( final byte [ ] b , final int offset ) { return ( b [ offset ] ) << num_ | ( num_ & b [ offset + num_ ] ) << num_ | ( num_ & b [ offset + num_ ] ) << num_ | ( ( num_ & b [ offset + num_ ] ) ) ; }	Convert the byte array to an int starting from the given offset.
@ override public void onopen ( final odatabaseinternal idatabase ) { if ( ! isrelatedtolocalserver ( idatabase ) ) return ; if ( isoffline ( ) && status != node_status . starting ) return ; final odatabasedocumentinternal currdb = odatabaserecordthreadlocal . instance ( ) . getifdefined ( ) ; try { final string dbname = idatabase . getname ( ) ; final odistributedconfiguration cfg = getdatabaseconfiguration ( dbname ) ; if ( cfg == null ) return ; } catch ( hazelcastexception e ) { throw oexception . wrapexception ( new oofflinenodeexception ( str_ ) , e ) ; } catch ( hazelcastinstancenotactiveexception e ) { throw oexception . wrapexception ( new oofflinenodeexception ( str_ ) , e ) ; } finally {	Auto register myself as hook.
public boolean installclustersofclass ( final odatabaseinternal idatabase , final oclass iclass , omodifiabledistributedconfiguration cfg ) { final string databasename = idatabase . getname ( ) ; if ( iclass . isabstract ( ) ) return bool_ ;	Guarantees that each class has own master cluster.
protected void dumpserversstatus ( ) { final odocument cfg = getclusterconfiguration ( ) ; final string compactstatus = odistributedoutput . getcompactserverstatus ( this , cfg ) ; if ( ! lastserverdump . equals ( compactstatus ) ) { lastserverdump = compactstatus ; odistributedserverlog . info ( this , getlocalnodename ( ) , null , direction . none , str_ , getlockmanagerserver ( ) , odistributedoutput . formatserverstatus ( this , cfg ) ) ; } }	Avoids to dump the same configuration twice if it's unchanged since the last time.
public static int indexof ( final object [ ] array , final comparable object ) { for ( int i = num_ ; i < array . length ; ++ i ) { if ( object . compareto ( array [ i ] ) == num_ )	This method is used to find an item in an array.
public static int indexof ( final int [ ] array , final int object ) { for ( int i = num_ ; i < array . length ; ++ i ) { if ( array [ i ] == object )	This method is used to find a number in an array.
@ override public set < string > getinvolvedclusters ( ) { final set < string > clusters = new hashset < string > ( ) ; if ( parsedtarget != null ) { final odatabasedocument db = getdatabase ( ) ; if ( parsedtarget . gettargetquery ( ) != null && parsedtarget . gettargetrecords ( ) instanceof ocommandexecutorsqlresultsetdelegate ) {	Determine clusters that are used in select operation.
@ override protected boolean handleresult ( final oidentifiable irecord , final ocommandcontext icontext ) { lastrecord = irecord ; if ( ( orderedfields . isempty ( ) || fullysortedbyindex || isridonlysort ( ) ) && skip > num_ && this . unwindfields == null && this . expandtarget == null ) { lastrecord = null ; skip -- ; return bool_ ; } if ( ! addresult ( lastrecord , icontext ) ) { return bool_ ; } return continuesearching ( ) ; }	Handles the record in result.
public int gettemporaryridcounter ( final ocommandcontext icontext ) { final otemporaryridgenerator parentquery = ( otemporaryridgenerator ) icontext . getvariable ( str_ ) ; return parentquery != null && parentquery != this ? parentquery . gettemporaryridcounter ( icontext ) : serialtemprid . getandincrement ( ) ; }	Returns the temporary RID counter assuring it's unique per query tree.
protected void reporttip ( final string imessage ) { orient . instance ( ) . getprofiler ( ) . reporttip ( imessage ) ; list < string > tips = ( list < string > ) context . getvariable ( str_ ) ; if ( tips == null ) { tips = new arraylist < string > ( num_ ) ; context . setvariable ( str_ , tips ) ; } tips . add ( imessage ) ; }	Report the tip to the profiler and collect it in context to be reported by tools like Studio.
protected boolean parsefetchplan ( final string w ) throws ocommandsqlparsingexception { if ( ! w . equals ( keyword_fetchplan ) ) { return bool_ ; } parserskipwhitespaces ( ) ; int start = parsergetcurrentposition ( ) ; parsernextword ( bool_ ) ; int end = parsergetcurrentposition ( ) ; parserskipwhitespaces ( ) ; int position = parsergetcurrentposition ( ) ; while ( ! parserisended ( ) ) { final string word = oioutils . getstringcontent ( parsernextword ( bool_ ) ) ; if ( ! opatternconst . pattern_fetch_plan . matcher ( word ) . matches ( ) ) { break ; } end = parsergetcurrentposition ( ) ; parserskipwhitespaces ( ) ; position = parsergetcurrentposition ( ) ; } parsersetcurrentposition ( position ) ; if ( end < num_ ) { fetchplan = oioutils . getstringcontent ( parsertext . substring ( start ) ) ; } else { fetchplan = oioutils . getstringcontent ( parsertext . substring ( start , end ) ) ; } request . setfetchplan ( fetchplan ) ; return bool_ ; }	Parses the fetchplan keyword if found.
protected boolean parsenocache ( final string w ) throws ocommandsqlparsingexception { if ( ! w . equals ( keyword_nocache ) ) return bool_ ; nocache = bool_ ; return bool_ ; }	Parses the NOCACHE keyword if found.
private boolean optimizesort ( oclass ischemaclass ) { oindexcursor cursor = getoptimizedsortcursor ( ischemaclass ) ; if ( cursor != null ) { fetchvaluesfromindexcursor ( cursor ) ; return bool_ ; } return bool_ ; }	Use index to order documents by provided fields.
public odocument status ( ) { synchronized ( listener ) { odocument status = new odocument ( ) ; status . field ( str_ , cfg ) ; status . field ( str_ , this . status ) ; string lastbatchlog = str_ ; if ( this . messagehandler != null ) { lastbatchlog = extractbatchlog ( ) ; } status . field ( str_ , lastbatchlog ) ; if ( this . status == status . finished ) { listener . notifyall ( ) ; } return status ; } }	Single Job Status.
@ suppresswarnings ( str_ ) public < ret > ret execute ( final object ... iargs ) { setparameters ( iargs ) ; oexecutionthreadlocal . instance . get ( ) . onasyncreplicationok = onasyncreplicationok ; oexecutionthreadlocal . instance . get ( ) . onasyncreplicationerror = onasyncreplicationerror ; return ( ret ) odatabaserecordthreadlocal . instance ( ) . get ( ) . getstorage ( ) . command ( this ) ; }	Delegates the execution to the configured command executor.
public final void handlejvmerror ( final error e ) { if ( jvmerror . compareandset ( null , e ) ) { ologmanager . instance ( ) . errornodb ( this , str_ , e ) ; } }	That is internal method which is called once we encounter any error inside of JVM.
@ suppresswarnings ( str_ ) public boolean validatedputindexvalue ( int indexid , final object key , final orid value , final obaseindexengine . validator < object , orid > validator ) throws oinvalidindexengineidexception { indexid = extractinternalid ( indexid ) ; try { if ( transaction . get ( ) != null ) { return dovalidatedputindexvalue ( indexid , key , value , validator ) ; } checkopenness ( ) ; statelock . acquirereadlock ( ) ; try { checkopenness ( ) ; checklowdiskspacerequestsandreadonlyconditions ( ) ; return dovalidatedputindexvalue ( indexid , key , value , validator ) ; } finally { statelock . releasereadlock ( ) ; } } catch ( final oinvalidindexengineidexception ie ) { throw logandprepareforrethrow ( ie ) ; } catch ( final runtimeexception ee ) { throw logandprepareforrethrow ( ee ) ; } catch ( final error ee ) { throw logandprepareforrethrow ( ee ) ; } catch ( final throwable t ) { throw logandprepareforrethrow ( t ) ; } }	Puts the given value under the given key into this storage for the index with the given index id.
public void rollback ( final omicrotransaction microtransaction ) { try { checkopenness ( ) ; statelock . acquirereadlock ( ) ; try { try { checkopenness ( ) ; if ( transaction . get ( ) == null ) { return ; } if ( transaction . get ( ) . getmicrotransaction ( ) . getid ( ) != microtransaction . getid ( ) ) { throw new ostorageexception ( str_ + str_ ) ; } makestoragedirty ( ) ; rollbackstoragetx ( ) ; microtransaction . updaterecordcacheafterrollback ( ) ; txrollback . incrementandget ( ) ; } catch ( final ioexception e ) { throw oexception . wrapexception ( new ostorageexception ( str_ ) , e ) ; } finally { transaction . set ( null ) ; } } finally { statelock . releasereadlock ( ) ; } } catch ( final runtimeexception ee ) { throw logandprepareforrethrow ( ee ) ; } catch ( final error ee ) { throw logandprepareforrethrow ( ee ) ; } catch ( final throwable t ) { throw logandprepareforrethrow ( t ) ; } }	Rollbacks the given micro-transaction.
@ override public final object command ( final ocommandrequesttext icommand ) { try { while ( bool_ ) { try { final ocommandexecutor executor = ocommandmanager . instance ( ) . getexecutor ( icommand ) ;	Executes the command request and return the result back.
private int registercluster ( final ocluster cluster ) { final int id ; if ( cluster != null ) {	Register the cluster internally.
public object setproperty ( final string iname , final object ivalue ) { if ( ivalue != null ) { return properties . put ( iname . tolowercase ( locale . english ) , ivalue ) ; } else { return properties . remove ( iname . tolowercase ( locale . english ) ) ; } }	Sets a property value.
public object execute ( final map < object , object > iargs ) { if ( classname == null ) throw new ocommandexecutionexception ( str_ ) ; final odatabasedocument database = getdatabase ( ) ; boolean alreadyexists = database . getmetadata ( ) . getschema ( ) . existsclass ( classname ) ; if ( ! alreadyexists || ! ifnotexists ) { if ( clusters != null ) database . getmetadata ( ) . getschema ( ) . createclass ( classname , clusters , superclasses . toarray ( new oclass [ num_ ] ) ) ; else database . getmetadata ( ) . getschema ( ) . createclass ( classname , clusterids , superclasses . toarray ( new oclass [ num_ ] ) ) ; } return database . getmetadata ( ) . getschema ( ) . getclasses ( ) . size ( ) ; }	Execute the CREATE CLASS.
public object execute ( final map < object , object > iargs ) { final odatabasedocumentinternal database = getdatabase ( ) ; database . checksecurity ( orule . resourcegeneric . database , str_ , orole . permission_update ) ; final ostorage stg = database . getstorage ( ) ; if ( ! ( stg instanceof odistributedstorage ) ) throw new odistributedexception ( str_ ) ; final odistributedstorage dstg = ( odistributedstorage ) stg ; final ohazelcastplugin dmanager = ( ohazelcastplugin ) dstg . getdistributedmanager ( ) ; if ( dmanager == null || ! dmanager . isenabled ( ) ) throw new ocommandexecutionexception ( str_ ) ; final string databasename = database . getname ( ) ; return dmanager . installdatabase ( bool_ , databasename , parsedstatement . isforce ( ) , ! parsedstatement . isfull ( ) ) ; }	Execute the SYNC DATABASE.
public odatabase < orecord > delete ( final orid irecord , final int iversion ) { orecord record = load ( irecord ) ; orecordinternal . setversion ( record , iversion ) ; delete ( record ) ; return this ; }	Deletes the record checking the version.
public orecordhook . result callbackhooks ( final orecordhook . type type , final oidentifiable id ) { if ( id == null || hooks . isempty ( ) || id . getidentity ( ) . getclusterid ( ) == num_ ) return orecordhook . result . record_not_changed ; final orecordhook . scope scope = orecordhook . scope . typetoscope ( type ) ; final int scopeordinal = scope . ordinal ( ) ; final orid identity = id . getidentity ( ) . copy ( ) ; if ( ! pushinhook ( identity ) ) return orecordhook . result . record_not_changed ; try { final orecord rec = id . getrecord ( ) ; if ( rec == null ) return orecordhook . result . record_not_changed ; final oscenariothreadlocal . run_mode runmode = oscenariothreadlocal . instance . getrunmode ( ) ; boolean recordchanged = bool_ ; for ( orecordhook hook : hooksbyscope [ scopeordinal ] ) { switch ( runmode ) { case default :	Callback the registered hooks if any.
public odatabasedocument delete ( final orid irecord ) { checkopenness ( ) ; checkifactive ( ) ; final orecord rec = load ( irecord ) ; if ( rec != null ) delete ( rec ) ; return this ; }	Deletes the record without checking the version.
public long countview ( final string viewname ) { final oview cls = getmetadata ( ) . getimmutableschemasnapshot ( ) . getview ( viewname ) ; if ( cls == null ) throw new illegalargumentexception ( str_ + cls + str_ ) ; return countclass ( cls , bool_ ) ; }	Returns the number of the records of the class iClassName.
public long countclass ( final string iclassname , final boolean ipolymorphic ) { final oclass cls = getmetadata ( ) . getimmutableschemasnapshot ( ) . getclass ( iclassname ) ; if ( cls == null ) throw new illegalargumentexception ( str_ + cls + str_ ) ; return countclass ( cls , ipolymorphic ) ; }	Returns the number of the records of the class iClassName considering also sub classes if polymorphic is true.
@ override public odatabasedocumentabstract activateoncurrentthread ( ) { final odatabaserecordthreadlocal tl = odatabaserecordthreadlocal . instance ( ) ; if ( tl != null ) tl . set ( this ) ; return this ; }	Activates current database instance on current thread.
public void register ( final oencryption iencryption ) { try { final string name = iencryption . name ( ) ; if ( instances . containskey ( name ) ) throw new illegalargumentexception ( str_ + name + str_ ) ; if ( classes . containskey ( name ) ) throw new illegalargumentexception ( str_ + name + str_ ) ; instances . put ( name , iencryption ) ; } catch ( exception e ) { ologmanager . instance ( ) . error ( this , str_ , e , iencryption ) ; } }	Registers a stateful implementations, a new instance will be created for each storage.
private int getrelativeindex ( long pos ) { int currentsize = num_ ; currentchunkindex = num_ ;	Calculates the index within a binary chunk corresponding to the given absolute position within this BLOB.
protected string parseroptionalword ( final boolean iuppercase ) { parserpreviouspos = parsercurrentpos ; parsernextword ( iuppercase ) ; if ( parserlastword . length ( ) == num_ ) return null ; return parserlastword . tostring ( ) ; }	Parses the next word.
protected string parserrequiredword ( final boolean iuppercase , final string icustommessage , string iseparators ) { if ( iseparators == null ) iseparators = str_ ; parsernextword ( iuppercase , iseparators ) ; if ( parserlastword . length ( ) == num_ ) throwsyntaxerrorexception ( icustommessage ) ; if ( parserlastword . charat ( num_ ) == str_ && parserlastword . charat ( parserlastword . length ( ) - num_ ) == str_ ) { return parserlastword . substring ( num_ , parserlastword . length ( ) - num_ ) ; } return parserlastword . tostring ( ) ; }	Parses the next word.
protected int parsernextchars ( final boolean iuppercase , final boolean imandatory , final string ... icandidatewords ) { parserpreviouspos = parsercurrentpos ; parserskipwhitespaces ( ) ; parserescapesequencecount = num_ ; parserlastword . setlength ( num_ ) ; final string [ ] processedwords = arrays . copyof ( icandidatewords , icandidatewords . length ) ;	Parses the next sequence of chars.
protected boolean parseroptionalkeyword ( final string ... iwords ) { parsernextword ( bool_ , str_ ) ; if ( parserlastword . length ( ) == num_ ) return bool_ ;	Parses optional keywords between the iWords.
private boolean parsercheckseparator ( final char c , final string iseparatorchars ) { for ( int sepindex = num_ ; sepindex < iseparatorchars . length ( ) ; ++ sepindex ) { if ( iseparatorchars . charat ( sepindex ) == c ) { parserlastseparator = c ; return bool_ ; } } return bool_ ; }	Check for a separator.
public object execute ( final map < object , object > iargs ) { if ( classname == null ) { throw new ocommandexecutionexception ( str_ ) ; } final odatabasedocument database = getdatabase ( ) ; if ( ifexists && ! database . getmetadata ( ) . getschema ( ) . existsclass ( classname ) ) { return bool_ ; } final oclass cls = database . getmetadata ( ) . getschema ( ) . getclass ( classname ) ; if ( cls == null ) { return null ; } final long records = cls . count ( bool_ ) ; if ( records > num_ && ! unsafe ) {	Execute the DROP CLASS.
private void clearconfigurationfiles ( ) throws ioexception { final path file = storagepath . resolve ( name ) ; files . deleteifexists ( file ) ; final path backupfile = storagepath . resolve ( backup_name ) ; files . deleteifexists ( backupfile ) ; }	Remove both backup and primary configuration files on delete.
public int getasbytearrayoffset ( ) { if ( position >= length ) return - num_ ; final int begin = position ; final int size = obinaryprotocol . bytes2int ( buffer , position ) ; position += obinaryprotocol . size_int + size ; return begin ; }	Browse the stream but just return the begin of the byte array.
protected string extract ( string tokentype ) { oauth2accesstoken accesstoken = gettoken ( ) ; return string . format ( str_ , tokentype , accesstoken . getvalue ( ) ) ; }	Extracts the token extract id the access token exists or returning an empty extractif there is no one on the context it may occasionally causes Unauthorized responsesince the token extract is empty.
protected oauth2accesstoken acquireaccesstoken ( ) throws userredirectrequiredexception { accesstokenrequest tokenrequest = oauth2clientcontext . getaccesstokenrequest ( ) ; if ( tokenrequest == null ) { throw new accesstokenrequiredexception ( str_ + resource . getid ( ) + str_ , resource ) ; } string statekey = tokenrequest . getstatekey ( ) ; if ( statekey != null ) { tokenrequest . setpreservedstate ( oauth2clientcontext . removepreservedstate ( statekey ) ) ; } oauth2accesstoken existingtoken = oauth2clientcontext . getaccesstoken ( ) ; if ( existingtoken != null ) { oauth2clientcontext . setaccesstoken ( existingtoken ) ; } oauth2accesstoken obtainableaccesstoken ; obtainableaccesstoken = accesstokenprovider . obtainaccesstoken ( resource , tokenrequest ) ; if ( obtainableaccesstoken == null || obtainableaccesstoken . getvalue ( ) == null ) { throw new illegalstateexception ( str_ ) ; } oauth2clientcontext . setaccesstoken ( obtainableaccesstoken ) ; return obtainableaccesstoken ; }	Try to acquire the token using a access token provider.
public boolean copytoken ( ) { if ( context . getaccesstoken ( ) == null ) { authentication authentication = securitycontextholder . getcontext ( ) . getauthentication ( ) ; if ( authentication != null ) { object details = authentication . getdetails ( ) ; if ( details instanceof oauth2authenticationdetails ) { oauth2authenticationdetails holder = ( oauth2authenticationdetails ) details ; string token = holder . gettokenvalue ( ) ; defaultoauth2accesstoken accesstoken = new defaultoauth2accesstoken ( token ) ; string tokentype = holder . gettokentype ( ) ; if ( tokentype != null ) { accesstoken . settokentype ( tokentype ) ; } context . setaccesstoken ( accesstoken ) ; return bool_ ; } } } return bool_ ; }	Attempt to copy an access token from the security context into the oauth2 context.
protected boolean nomorecharacters ( ) throws ioexception { if ( avail == num_ ) { avail = is . read ( buffer ) ; if ( avail <= num_ ) { avail = num_ ; return bool_ ; } pos = num_ ; } return bool_ ; }	Checks whether no more bytes will be returned.
public int readline ( final byte [ ] array , final enumset < lineterminator > terminators ) throws ioexception { return readline ( array , num_ , array . length , terminators ) ; }	Reads a line into the given byte array.
private long skipbyreading ( final long n ) throws ioexception { long toskip = n ; int len ; while ( toskip > num_ ) { len = is . read ( buffer , num_ , ( int ) math . min ( buffer . length , toskip ) ) ; if ( len > num_ ) toskip -= len ; else break ; } return n - toskip ; }	Skips the given amount of bytes by repeated reads.
public static void ensureoffsetlength ( final int arraylength , final int offset , final int length ) { if ( offset < num_ ) throw new arrayindexoutofboundsexception ( str_ + offset + str_ ) ; if ( length < num_ ) throw new illegalargumentexception ( str_ + length + str_ ) ; if ( offset + length > arraylength ) throw new arrayindexoutofboundsexception ( str_ + ( offset + length ) + str_ + arraylength + str_ ) ; }	Ensures that a range given by an offset and a length fits an array of given length.
protected static void swap ( final swapper swapper , int a , int b , final int n ) { for ( int i = num_ ; i < n ; i ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; }	Swaps two sequences of elements using a provided swapper.
public static int murmurhash3 ( int x ) { x ^= x > > > num_ ; x *= num_ ; x ^= x > > > num_ ; x *= num_ ; x ^= x > > > num_ ; return x ; }	Avalanches the bits of an integer by applying the finalisation step of MurmurHash3.
public static long murmurhash3 ( long x ) { x ^= x > > > num_ ; x *= num_ ; x ^= x > > > num_ ; x *= num_ ; x ^= x > > > num_ ; return x ; }	Avalanches the bits of a long integer by applying the finalisation step of MurmurHash3.
@ override public int write ( final bytebuffer bytebuffer ) throws ioexception { ensureopen ( ) ; final int remaining = bytebuffer . remaining ( ) ; if ( inspectable < buffer . length ) {	Appends the content of a specified buffer to the end of the currently represented stream.
public void truncate ( final long size ) throws filenotfoundexception , ioexception { filechannel . truncate ( math . max ( size , writeposition ) ) ; }	Truncates the overflow file to a given size if possible.
@ override public void position ( final long newposition ) throws ioexception { flush ( ) ; if ( repositionablestream != null ) repositionablestream . position ( newposition ) ; else if ( filechannel != null ) filechannel . position ( newposition ) ; else throw new unsupportedoperationexception ( str_ ) ; }	Repositions the stream. Note that this method performs a {.
private final void nofailrefreshendmetricsreporting ( consumerrefreshmetrics refreshmetrics ) { try { refreshendmetricsreporting ( refreshmetrics ) ; } catch ( exception e ) {	Metrics reporting implementation is provided by the extending subclass.
public void awaitsuccessfulcompletionofcurrenttasks ( ) throws interruptedexception , executionexception { for ( future < ? > f : futures ) { f . get ( ) ; } futures . clear ( ) ; }	Await successful completion of all previously submitted tasks.
public stream < s > findmatches ( q query ) { object [ ] queryarray = matchfields . stream ( ) . map ( mf -> mf . extract ( query ) ) . toarray ( ) ; hollowhashindexresult matches = hhi . findmatches ( queryarray ) ; if ( matches == null ) { return stream . empty ( ) ; } return matches . stream ( ) . maptoobj ( i -> selectfield . extract ( api , i ) ) ; }	Finds matches for a given query.
private set < string > findcompactiontargets ( ) { list < hollowschema > schemas = hollowschemasorter . dependencyorderedschemalist ( readengine . getschemas ( ) ) ; set < string > typestocompact = new hashset < string > ( ) ; for ( hollowschema schema : schemas ) { if ( iscompactioncandidate ( schema . getname ( ) ) ) { if ( ! candidateisdependentonanytargetedtype ( schema . getname ( ) , typestocompact ) ) typestocompact . add ( schema . getname ( ) ) ; } } return typestocompact ; }	Find candidate types for compaction.
@ override public void cleansnapshots ( ) { file [ ] files = getfilesbytype ( hollowproducer . blob . type . snapshot . prefix ) ; if ( files == null || files . length <= numofsnapshotstokeep ) { return ; } sortbylastmodified ( files ) ; for ( int i = numofsnapshotstokeep ; i < files . length ; i ++ ) { file file = files [ i ] ; boolean deleted = file . delete ( ) ; if ( ! deleted ) { log . warning ( str_ + file . getpath ( ) ) ; } } }	Cleans snapshot to keep the last 'n' snapshots.
public static int fieldhashcode ( hollowobjecttypedataaccess typeaccess , int ordinal , int fieldposition ) { hollowobjectschema schema = typeaccess . getschema ( ) ; switch ( schema . getfieldtype ( fieldposition ) ) { case boolean : boolean bool = typeaccess . readboolean ( ordinal , fieldposition ) ; return booleanhashcode ( bool ) ; case bytes : case string : return typeaccess . findvarlengthfieldhashcode ( ordinal , fieldposition ) ; case double : double d = typeaccess . readdouble ( ordinal , fieldposition ) ; return doublehashcode ( d ) ; case float : float f = typeaccess . readfloat ( ordinal , fieldposition ) ; return floathashcode ( f ) ; case int : return inthashcode ( typeaccess . readint ( ordinal , fieldposition ) ) ; case long : long l = typeaccess . readlong ( ordinal , fieldposition ) ; return longhashcode ( l ) ; case reference : return typeaccess . readordinal ( ordinal , fieldposition ) ; } throw new illegalstateexception ( str_ + schema . getfieldtype ( fieldposition ) ) ; }	Hash a field in an OBJECT record.
public static void removereferencedoutsideclosure ( hollowreadstateengine stateengine , map < string , bitset > matches ) { list < hollowschema > orderedschemas = hollowschemasorter . dependencyorderedschemalist ( stateengine ) ; collections . reverse ( orderedschemas ) ; for ( hollowschema referencedschema : orderedschemas ) { if ( matches . containskey ( referencedschema . getname ( ) ) ) { for ( hollowschema referencerschema : orderedschemas ) { if ( referencerschema == referencedschema ) break ; if ( matches . containskey ( referencedschema . getname ( ) ) && matches . get ( referencedschema . getname ( ) ) . cardinality ( ) > num_ ) traversereferencesoutsideclosure ( stateengine , referencerschema . getname ( ) , referencedschema . getname ( ) , matches , remove_referenced_outside_closure ) ; } } } }	Remove any records from the given selection which are referenced by other records not in the selection.
@ override public void onannouncementcomplete ( com . netflix . hollow . api . producer . status status , hollowproducer . readstate readstate , long version , duration elapsed ) { boolean isannouncementsuccess = bool_ ; long datasizebytes = num_ ; if ( status . gettype ( ) == com . netflix . hollow . api . producer . status . statustype . success ) { isannouncementsuccess = bool_ ; lastannouncementsuccesstimenanooptional = optionallong . of ( system . nanotime ( ) ) ; } hollowreadstateengine stateengine = readstate . getstateengine ( ) ; datasizebytes = stateengine . calcapproxdatasize ( ) ; announcementmetricsbuilder . setdatasizebytes ( datasizebytes ) . setisannouncementsuccess ( isannouncementsuccess ) . setannouncementdurationmillis ( elapsed . tomillis ( ) ) ; lastannouncementsuccesstimenanooptional . ifpresent ( announcementmetricsbuilder :: setlastannouncementsuccesstimenano ) ; announcementmetricsreporting ( announcementmetricsbuilder . build ( ) ) ; }	Reports announcement-related metrics.
@ override public void oncyclecomplete ( com . netflix . hollow . api . producer . status status , hollowproducer . readstate readstate , long version , duration elapsed ) { boolean iscyclesuccess ; long cycleendtimenano = system . nanotime ( ) ; if ( status . gettype ( ) == com . netflix . hollow . api . producer . status . statustype . success ) { iscyclesuccess = bool_ ; consecutivefailures = num_ ; lastcyclesuccesstimenanooptional = optionallong . of ( cycleendtimenano ) ; } else { iscyclesuccess = bool_ ; consecutivefailures ++ ; } cyclemetricsbuilder . setconsecutivefailures ( consecutivefailures ) . setcycledurationmillis ( elapsed . tomillis ( ) ) . setiscyclesuccess ( iscyclesuccess ) ; lastcyclesuccesstimenanooptional . ifpresent ( cyclemetricsbuilder :: setlastcyclesuccesstimenano ) ; cyclemetricsreporting ( cyclemetricsbuilder . build ( ) ) ; }	On cycle completion this method reports cycle metrics.
private map < string , string > readheadertags ( datainputstream dis ) throws ioexception { int numheadertags = dis . readshort ( ) ; map < string , string > headertags = new hashmap < string , string > ( ) ; for ( int i = num_ ; i < numheadertags ; i ++ ) { headertags . put ( dis . readutf ( ) , dis . readutf ( ) ) ; } return headertags ; }	Map of string header tags reading.
public recordprimarykey extractprimarykey ( object o ) { hollowobjecttypemapper typemapper = ( hollowobjecttypemapper ) gettypemapper ( o . getclass ( ) , null , null ) ; return new recordprimarykey ( typemapper . gettypename ( ) , typemapper . extractprimarykey ( o ) ) ; }	Extracts the primary key from the specified POJO.
public void clearall ( ) { threadsafebitsetsegments segments = this . segments . get ( ) ; for ( int i = num_ ; i < segments . numsegments ( ) ; i ++ ) { atomiclongarray segment = segments . getsegment ( i ) ; for ( int j = num_ ; j < segment . length ( ) ; j ++ ) { segment . set ( j , num_ ) ; } } }	Clear all bits to 0.
public static void readordinals ( datainputstream dis , hollowtypestatelistener [ ] listeners ) throws ioexception { int numlongs = dis . readint ( ) ; int currentordinal = num_ ; for ( int i = num_ ; i < numlongs ; i ++ ) { long l = dis . readlong ( ) ; notifypopulatedordinals ( l , currentordinal , listeners ) ; currentordinal += num_ ; } }	Read populated ordinals as a bit set from a stream, and notify a listener for each populated ordinal.
public long size ( ) { sparsebitset current ; long size ; do { current = sparsebitsetvolatile ; size = current . estimatebitsused ( ) ; } while ( current != sparsebitsetvolatile ) ; return size ; }	Estimate the total number of bits used to represent the integer set.
private static string getfieldvalue ( hollowdiffviewrow row , boolean usefrom ) { field field = usefrom ? row . getfieldpair ( ) . getfrom ( ) : row . getfieldpair ( ) . getto ( ) ; if ( row . getfieldpair ( ) . isleafnode ( ) ) { return field . getvalue ( ) == null ? str_ : field . getvalue ( ) . tostring ( ) . replace ( str_ , str_ ) ; } else { string suffix = field . getvalue ( ) == null ? str_ : str_ ; return str_ + field . gettypename ( ) + str_ + suffix ; } }	Returns a String representation of the provided row's field value.
public void copy ( bytedata src , long srcpos , long destpos , long length ) { for ( long i = num_ ; i < length ; i ++ ) { set ( destpos ++ , src . get ( srcpos ++ ) ) ; } }	Copy bytes from another ByteData to this array.
public int copy ( long srcpos , byte [ ] data , int destpos , int length ) { int segmentsize = num_ << log2ofsegmentsize ; int remainingbytesinsegment = ( int ) ( segmentsize - ( srcpos & bitmask ) ) ; int dataposition = destpos ; while ( length > num_ ) { byte [ ] segment = segments [ ( int ) ( srcpos > > > log2ofsegmentsize ) ] ; int bytestocopyfromsegment = math . min ( remainingbytesinsegment , length ) ; system . arraycopy ( segment , ( int ) ( srcpos & bitmask ) , data , dataposition , bytestocopyfromsegment ) ; dataposition += bytestocopyfromsegment ; srcpos += bytestocopyfromsegment ; remainingbytesinsegment = segmentsize - ( int ) ( srcpos & bitmask ) ; length -= bytestocopyfromsegment ; } return dataposition - destpos ; }	copies exactly data.length bytes from this SegmentedByteArray into the provided byte array.
public boolean rangeequals ( long rangestart , segmentedbytearray compareto , long cmpstart , int length ) { for ( int i = num_ ; i < length ; i ++ ) if ( get ( rangestart + i ) != compareto . get ( cmpstart + i ) ) return bool_ ; return bool_ ; }	checks equality for a specified range of bytes in two arrays.
public void orderedcopy ( segmentedbytearray src , long srcpos , long destpos , long length ) { int segmentlength = num_ << log2ofsegmentsize ; int currentsegment = ( int ) ( destpos > > > log2ofsegmentsize ) ; int segmentstartpos = ( int ) ( destpos & bitmask ) ; int remainingbytesinsegment = segmentlength - segmentstartpos ; while ( length > num_ ) { int bytestocopyfromsegment = ( int ) math . min ( remainingbytesinsegment , length ) ; ensurecapacity ( currentsegment ) ; int copiedbytes = src . orderedcopy ( srcpos , segments [ currentsegment ] , segmentstartpos , bytestocopyfromsegment ) ; srcpos += copiedbytes ; length -= copiedbytes ; segmentstartpos = num_ ; remainingbytesinsegment = segmentlength ; currentsegment ++ ; } }	Copies the data from the provided source array into this array, guaranteeing thatif the update is seen by another thread, then all other writes prior to this callare also visible to that thread.
public int orderedcopy ( long srcpos , byte [ ] data , int destpos , int length ) { int segmentsize = num_ << log2ofsegmentsize ; int remainingbytesinsegment = ( int ) ( segmentsize - ( srcpos & bitmask ) ) ; int dataposition = destpos ; while ( length > num_ ) { byte [ ] segment = segments [ ( int ) ( srcpos > > > log2ofsegmentsize ) ] ; int bytestocopyfromsegment = math . min ( remainingbytesinsegment , length ) ; orderedcopy ( segment , ( int ) ( srcpos & bitmask ) , data , dataposition , bytestocopyfromsegment ) ; dataposition += bytestocopyfromsegment ; srcpos += bytestocopyfromsegment ; remainingbytesinsegment = segmentsize - ( int ) ( srcpos & bitmask ) ; length -= bytestocopyfromsegment ; } return dataposition - destpos ; }	copies exactly data.length bytes from this SegmentedByteArray into the provided byte array,guaranteeing that if the update is seen by another thread, then all other writes prior tothis call are also visible to that thread.
public void readfrom ( inputstream is , long length ) throws ioexception { int segmentsize = num_ << log2ofsegmentsize ; int segment = num_ ; byte scratch [ ] = new byte [ segmentsize ] ; while ( length > num_ ) { ensurecapacity ( segment ) ; long bytestocopy = math . min ( segmentsize , length ) ; long bytescopied = num_ ; while ( bytescopied < bytestocopy ) { bytescopied += is . read ( scratch , ( int ) bytescopied , ( int ) ( bytestocopy - bytescopied ) ) ; } orderedcopy ( scratch , num_ , segments [ segment ++ ] , num_ , ( int ) bytescopied ) ; length -= bytescopied ; } }	Copy bytes from the supplied InputStream into this array.
public void writeto ( outputstream os , long startposition , long len ) throws ioexception { int segmentsize = num_ << log2ofsegmentsize ; int remainingbytesinsegment = segmentsize - ( int ) ( startposition & bitmask ) ; long remainingbytesincopy = len ; while ( remainingbytesincopy > num_ ) { long bytestocopyfromsegment = math . min ( remainingbytesinsegment , remainingbytesincopy ) ; os . write ( segments [ ( int ) ( startposition > > > log2ofsegmentsize ) ] , ( int ) ( startposition & bitmask ) , ( int ) bytestocopyfromsegment ) ; startposition += bytestocopyfromsegment ; remainingbytesinsegment = segmentsize - ( int ) ( startposition & bitmask ) ; remainingbytesincopy -= bytestocopyfromsegment ; } }	Write a portion of this data to an OutputStream.
private void ensurecapacity ( int segmentindex ) { while ( segmentindex >= segments . length ) { segments = arrays . copyof ( segments , segments . length * num_ / num_ ) ; } if ( segments [ segmentindex ] == null ) { segments [ segmentindex ] = memoryrecycler . getbytearray ( ) ; } }	Ensures that the segment at segmentIndex exists.
public int getposition ( string fieldname ) { integer index = namefieldindexlookup . get ( fieldname ) ; if ( index == null ) { return - num_ ; } return index ; }	Returns the position of a field previously added to the map, or -1 if the field has not been added to the map.The positions of the fields are hashed into the hashedPositionArray by the hashCode of the fieldName.
private long calculatededupedsizesandtotalnumberofselectbuckets ( multilinkedelementarray elementarray , growingsegmentedlongarray matchindexhashandsizearray ) { long totalbuckets = num_ ; long maxsize = num_ ; int [ ] selectarray = new int [ num_ ] ; for ( int i = num_ ; i < elementarray . numlists ( ) ; i ++ ) { int listsize = elementarray . listsize ( i ) ; int setsize = num_ ; int predictedbuckets = hashcodes . hashtablesize ( listsize ) ; int hashmask = predictedbuckets - num_ ; if ( predictedbuckets > selectarray . length ) selectarray = new int [ predictedbuckets ] ; for ( int j = num_ ; j < predictedbuckets ; j ++ ) selectarray [ j ] = - num_ ; hollowordinaliterator iter = elementarray . iterator ( i ) ; int selectordinal = iter . next ( ) ; while ( selectordinal != hollowordinaliterator . no_more_ordinals ) { int hash = hashcodes . hashint ( selectordinal ) ; int bucket = hash & hashmask ; while ( bool_ ) { if ( selectarray [ bucket ] == selectordinal ) break ; if ( selectarray [ bucket ] == - num_ ) { selectarray [ bucket ] = selectordinal ; setsize ++ ; break ; } bucket = ( bucket + num_ ) & hashmask ; } selectordinal = iter . next ( ) ; } long matchindexhashandsize = matchindexhashandsizearray . get ( i ) ; matchindexhashandsize |= ( long ) setsize << num_ ; matchindexhashandsizearray . set ( i , matchindexhashandsize ) ; totalbuckets += hashcodes . hashtablesize ( setsize ) ; if ( setsize > maxsize ) maxsize = setsize ; } return totalbuckets | ( long ) bitsrequiredtorepresentvalue ( maxsize ) << num_ ; }	Called after initial pass.Returns the sum total number of select buckets in the low 7 bytes, and the bits required for the max set size in the high 1 byte.
protected static boolean hascollectionsindataset ( hollowdataset dataset ) { for ( hollowschema schema : dataset . getschemas ( ) ) { if ( ( schema instanceof hollowlistschema ) || ( schema instanceof hollowsetschema ) || ( schema instanceof hollowmapschema ) ) { return bool_ ; } } return bool_ ; }	Determines whether DataSet contains any collections schema.
public void generatefiles ( file directory ) throws ioexception { if ( packagename != null && ! packagename . trim ( ) . isempty ( ) ) { string packagedir = packagename . replace ( str_ , file . separator ) ; if ( ! directory . getabsolutepath ( ) . endswith ( packagedir ) ) { directory = new file ( directory , packagedir ) ; } } directory . mkdirs ( ) ; hollowapiclassjavagenerator apiclassgenerator = new hollowapiclassjavagenerator ( packagename , apiclassname , dataset , parameterizeclassnames , config ) ; hollowapifactoryjavagenerator apifactorygenerator = new hollowapifactoryjavagenerator ( packagename , apiclassname , dataset , config ) ; hollowhashindexgenerator hashindexgenerator = new hollowhashindexgenerator ( packagename , apiclassname , dataset , config ) ; generatefile ( directory , apiclassgenerator ) ; generatefile ( directory , apifactorygenerator ) ; generatefile ( directory , hashindexgenerator ) ; generatefilesforhollowschemas ( directory ) ; }	Generate files under the specified directory.
protected void generatefilesforhollowschemas ( file directory ) throws ioexception { for ( hollowschema schema : dataset . getschemas ( ) ) { string type = schema . getname ( ) ; if ( config . isusehollowprimitivetypes ( ) && hollowcodegenerationutils . isprimitivetype ( type ) ) continue ;	Generate files based on dataset schemas under the specified directory.
public boolean keymatches ( int ordinal , object ... keys ) { if ( keys . length != fieldpathindexes . length ) return bool_ ; for ( int i = num_ ; i < keys . length ; i ++ ) { if ( ! keymatches ( keys [ i ] , ordinal , i ) ) return bool_ ; } return bool_ ; }	Determine whether or not the specified ordinal contains the provided primary key value.
public object [ ] getrecordkey ( int ordinal ) { object [ ] results = new object [ fieldpathindexes . length ] ; for ( int i = num_ ; i < fieldpathindexes . length ; i ++ ) { results [ i ] = readvalue ( ordinal , i ) ; } return results ; }	Retrieve the primary key value for the specified ordinal.
public static fieldpath < objectfieldsegment > createfieldpathforprimarykey ( hollowdataset dataset , string type , string path ) { boolean autoexpand = ! path . endswith ( str_ ) ; path = autoexpand ? path : path . substring ( num_ , path . length ( ) - num_ ) ; fieldpath < fieldsegment > fp = createfieldpath ( dataset , type , path , autoexpand , bool_ , bool_ ) ;	Creates an object-based field path given a data set and the field path in symbolic form conforming to pathsassociated with a primary key.
public static fieldpath < fieldsegment > createfieldpathforhashindex ( hollowdataset dataset , string type , string path ) { return createfieldpath ( dataset , type , path , bool_ , bool_ , bool_ ) ; }	Creates a field path given a data set and the field path in symbolic form conforming to pathsassociated with a hash index.
public void put ( object obj , int ordinal ) { int hashcode = system . identityhashcode ( obj ) ; int segment = segment ( hashcode ) ; segments [ segment ] . put ( obj , hashcode , ordinal ) ; }	Associating the obj with an ordinal.
private void initialize ( ) { string lastreftype = this . fieldpath . getlastreftypeinpath ( ) ;	initialize field positions and field paths.
public boolean contains ( string key ) { if ( key == null ) throw new illegalargumentexception ( str_ ) ; tst current ; boolean result ; do { current = prefixindexvolatile ; result = current . contains ( key ) ; } while ( current != this . prefixindexvolatile ) ; return result ; }	Check if the given key exists in the index.
public void addfield ( string type , string objectfield ) { objectfilterconfig typeconfig = specifiedfieldconfigs . get ( type ) ; if ( typeconfig == null ) { typeconfig = new objectfilterconfig ( ) ; specifiedfieldconfigs . put ( type , typeconfig ) ; } typeconfig . addfield ( objectfield ) ; }	Add an individual field from an OBJECT schema.
public static list < hollowschema > dependencyorderedschemalist ( collection < hollowschema > schemas ) { dependencyindex idx = new dependencyindex ( ) ; map < string , hollowschema > schemamap = new hashmap < string , hollowschema > ( ) ; for ( hollowschema schema : schemas ) { schemamap . put ( schema . getname ( ) , schema ) ; idx . indexschema ( schema , schemas ) ; } list < hollowschema > orderedschemas = new arraylist < hollowschema > ( ) ; while ( idx . hasmoretypes ( ) ) orderedschemas . add ( schemamap . get ( idx . getnexttype ( ) ) ) ; return orderedschemas ; }	Dependency types come before dependent types.
public void initwithnextmajorversiondefaults_v3 ( ) { usepackagegrouping = bool_ ; usebooleanfieldergonomics = bool_ ; reserveprimarykeyindexfortypewithprimarykey = bool_ ; usehollowprimitivetypes = bool_ ; restrictapitofieldtype = bool_ ; useverbosetostring = bool_ ; }	Make it easier to automatically use defaults for next major version.
public long get ( long index ) { int segmentindex = ( int ) ( index > > log2ofsegmentsize ) ; if ( segmentindex >= segments . length || segments [ segmentindex ] == null ) return num_ ; int longinsegment = ( int ) ( index & bitmask ) ; return segments [ segmentindex ] [ longinsegment ] ; }	Get the value of the byte at the specified index.
public map < string , bitset > findmatchingrecords ( string fieldname , string fieldvalue ) { map < string , bitset > matches = new hashmap < string , bitset > ( ) ; for ( hollowtypereadstate typestate : readengine . gettypestates ( ) ) { augmentmatchingrecords ( typestate , fieldname , fieldvalue , matches ) ; } return matches ; }	Match any records which include a field with the provided fieldName and value.
public map < string , bitset > findmatchingrecords ( string typename , string fieldname , string fieldvalue ) { map < string , bitset > matches = new hashmap < string , bitset > ( ) ; hollowtypereadstate typestate = readengine . gettypestate ( typename ) ; if ( typestate != null ) augmentmatchingrecords ( typestate , fieldname , fieldvalue , matches ) ; return matches ; }	Match any records of the specified type, which have the specified field set to the specified value.
public void setelementmatchpaths ( string ... paths ) { resetresults ( ) ; this . elementpaths = paths ; this . elementkeypaths = null ; this . elementnonkeypaths = null ; }	Set the paths for which we will inspect differences across the two states.
public void setelementkeypaths ( string ... paths ) { resetresults ( ) ; elementkeypaths = new bitset ( elementpaths . length ) ; for ( int i = num_ ; i < paths . length ; i ++ ) { int elementpathidx = getelementpathidx ( paths [ i ] ) ; if ( elementpathidx == - num_ ) throw new illegalargumentexception ( str_ + paths [ i ] ) ; elementkeypaths . set ( elementpathidx ) ; } elementnonkeypaths = new bitset ( elementpaths . length ) ; elementnonkeypaths . set ( num_ , elementpaths . length ) ; elementnonkeypaths . andnot ( elementkeypaths ) ; }	Optionally specify paths for which we will match records within an individual type's hierarchy.
public void restorefromlaststate ( ) { producer . initializedatamodel ( datamodel ) ; long latestannouncedversion = announcementwatcher . getlatestversion ( ) ; if ( latestannouncedversion == hollowfilesystemannouncementwatcher . no_announcement_available || latestannouncedversion < num_ ) { return ; } restore ( latestannouncedversion , blobretriever ) ; }	Initializes the data model and restores from existing state.
public long runcycle ( ) { long recordsremoved = countrecordstoremove ( ) ; long recordsaddedormodified = this . mutations . values ( ) . size ( ) - recordsremoved ; try { long version = producer . runcycle ( populator ) ; if ( version == lastsucessfulcycle ) { return version ; } listeners . fireincrementalcyclecomplete ( version , recordsaddedormodified , recordsremoved , new hashmap < string , object > ( cyclemetadata ) ) ;	Runs a Hollow Cycle, if successful, cleans the mutations map.
public void excludekey ( hollowprimarykeyindex idx , object ... key ) { int excludeordinal = idx . getmatchingordinal ( key ) ; if ( excludeordinal >= num_ ) { bitset excludedordinals = this . excludedordinals . get ( idx . gettypestate ( ) ) ; if ( excludedordinals == null ) { excludedordinals = new bitset ( idx . gettypestate ( ) . maxordinal ( ) + num_ ) ; this . excludedordinals . put ( idx . gettypestate ( ) , excludedordinals ) ; } excludedordinals . set ( excludeordinal ) ; } }	Exclude the record which matches the specified key.
public void excludereferencedobjects ( ) { set < hollowreadstateengine > stateengines = new hashset < hollowreadstateengine > ( ) ; for ( map . entry < hollowtypereadstate , bitset > entry : excludedordinals . entryset ( ) ) stateengines . add ( entry . getkey ( ) . getstateengine ( ) ) ; for ( hollowreadstateengine stateengine : stateengines ) { map < string , bitset > typebitsetsforstateengine = new hashmap < string , bitset > ( ) ; for ( map . entry < hollowtypereadstate , bitset > entry : excludedordinals . entryset ( ) ) { if ( entry . getkey ( ) . getstateengine ( ) == stateengine ) { string type = entry . getkey ( ) . getschema ( ) . getname ( ) ; typebitsetsforstateengine . put ( type , bitset . valueof ( entry . getvalue ( ) . tolongarray ( ) ) ) ; } } transitivesettraverser . addtransitivematches ( stateengine , typebitsetsforstateengine ) ; for ( map . entry < string , bitset > entry : typebitsetsforstateengine . entryset ( ) ) excludedordinals . put ( stateengine . gettypestate ( entry . getkey ( ) ) , entry . getvalue ( ) ) ; } }	Exclude any objects which are referenced by excluded objects.
public void writeheader ( hollowblobheader header , dataoutputstream dos ) throws ioexception {	Write the header to the data output stream.
void calculatetypemetrics ( hollowreadstateengine hollowreadstateengine ) { collection < hollowtypereadstate > typestates = hollowreadstateengine . gettypestates ( ) ; if ( typestates == null ) return ; totalheapfootprint = num_ ; totalpopulatedordinals = num_ ; for ( hollowtypereadstate typestate : typestates ) { long heapcost = typestate . getapproximateheapfootprintinbytes ( ) ; totalheapfootprint += heapcost ; int populatedordinals = typestate . getpopulatedordinals ( ) . cardinality ( ) ; totalpopulatedordinals += populatedordinals ; string type = typestate . getschema ( ) . getname ( ) ; typeheapfootprint . put ( type , heapcost ) ; typepopulatedordinals . put ( type , populatedordinals ) ; } }	Calculates the memory heap footprint and populated ordinals per type and total.
public void writedatato ( bytedatabuffer buf ) { for ( int i = num_ ; i < fielddata . length ; i ++ ) { writefield ( buf , i ) ; } }	Concatenates all fields, in order, to the ByteDataBuffer supplied.
private static void writefixedlengthint ( bytedatabuffer fieldbuffer , int intbits ) { fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits ) ) ; }	Write 4 consecutive bytes.
private static void writefixedlengthlong ( bytedatabuffer fieldbuffer , long intbits ) { fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits > > > num_ ) ) ; fieldbuffer . write ( ( byte ) ( intbits ) ) ; }	Write 8 consecutive bytes.
public void returnordinaltopool ( int ordinal ) { if ( size == freeordinals . length ) { freeordinals = arrays . copyof ( freeordinals , freeordinals . length * num_ / num_ ) ; } freeordinals [ size ] = ordinal ; size ++ ; }	Return an ordinal to the pool after the object to which it was assigned is discarded.
public void sort ( ) { arrays . sort ( freeordinals , num_ , size ) ;	Ensure that all future ordinals are returned in ascending order.
public static int hash ( object key [ ] , fieldtype fieldtype [ ] ) { int hash = num_ ; for ( int i = num_ ; i < key . length ; i ++ ) { hash *= num_ ; hash ^= hash ( key [ i ] , fieldtype [ i ] ) ; } return hash ; }	Hash a key.
public static int hash ( object key , fieldtype fieldtype ) { switch ( fieldtype ) { case int : return hashcodes . hashint ( ( ( integer ) key ) . intvalue ( ) ) ; case long : long longval = ( ( long ) key ) . longvalue ( ) ; return hashcodes . hashint ( ( int ) ( longval ^ ( longval > > > num_ ) ) ) ; case reference : return hashcodes . hashint ( ( ( integer ) key ) . intvalue ( ) ) ; case bytes : return hashcodes . hashint ( hashcodes . hashcode ( ( byte [ ] ) key ) ) ; case string : return hashcodes . hashint ( key . hashcode ( ) ) ; case boolean : return hashcodes . hashint ( ( ( boolean ) key ) . booleanvalue ( ) ? num_ : num_ ) ; case double : long longbits = double . doubletorawlongbits ( ( ( double ) key ) . doublevalue ( ) ) ; return hashcodes . hashint ( ( int ) ( longbits ^ ( longbits > > > num_ ) ) ) ; case float : return hashcodes . hashint ( float . floattorawintbits ( ( ( float ) key ) . floatvalue ( ) ) ) ; default : throw new illegalargumentexception ( str_ + fieldtype ) ; } }	Hash a single key field.
private void resizestorage ( ) { int currentelementspernode = maxelementspernode ; int newelementspernode = ( int ) ( currentelementspernode * resize_multiple ) ; if ( newelementspernode <= currentelementspernode ) { throw new illegalstateexception ( str_ + currentelementspernode + str_ + newelementspernode ) ; } fixedlengthelementarray newstorage = new fixedlengthelementarray ( memoryrecycler , numnodes * bitsperelement * newelementspernode ) ; longstream . range ( num_ , numnodes ) . foreach ( nodeindex -> { long currentbucketstart = nodeindex * currentelementspernode * bitsperelement ; long newbucketstart = nodeindex * newelementspernode * bitsperelement ; for ( int offset = num_ ; offset < currentelementspernode ; offset ++ ) { long element = storage . getelementvalue ( currentbucketstart + offset * bitsperelement , bitsperelement , elementmask ) ; if ( element == no_element ) { break ;	Resize the underlying storage to a multiple of what it currently is.
private int findfreeordinal ( int preferredordinal ) { if ( preferredordinal != - num_ && unusedpreviousordinals . get ( preferredordinal ) ) { unusedpreviousordinals . clear ( preferredordinal ) ; return preferredordinal ; } return freeordinaltracker . getfreeordinal ( ) ; }	If the preferredOrdinal has not already been used, mark it and use it.
public void prepareforwrite ( ) { int maxordinal = num_ ; atomiclongarray pao = pointersandordinals ; for ( int i = num_ ; i < pao . length ( ) ; i ++ ) { long key = pao . get ( i ) ; if ( key != empty_bucket_value ) { int ordinal = ( int ) ( key > > > bits_per_pointer ) ; if ( ordinal > maxordinal ) { maxordinal = ordinal ; } } } long [ ] pbo = new long [ maxordinal + num_ ] ; arrays . fill ( pbo , - num_ ) ; for ( int i = num_ ; i < pao . length ( ) ; i ++ ) { long key = pao . get ( i ) ; if ( key != empty_bucket_value ) { int ordinal = ( int ) ( key > > > bits_per_pointer ) ; pbo [ ordinal ] = key & pointer_mask ; } } pointersbyordinal = pbo ; }	Create an array mapping the ordinals to pointers, so that they can be easily looked upwhen writing to blob streams.
private boolean compare ( bytedatabuffer serializedrepresentation , long key ) { long position = key & pointer_mask ; int sizeofdata = varint . readvint ( bytedata . getunderlyingarray ( ) , position ) ; if ( sizeofdata != serializedrepresentation . length ( ) ) { return bool_ ; } position += varint . sizeofvint ( sizeofdata ) ; for ( int i = num_ ; i < sizeofdata ; i ++ ) { if ( serializedrepresentation . get ( i ) != bytedata . get ( position ++ ) ) { return bool_ ; } } return bool_ ; }	Compare the byte sequence contained in the supplied ByteDataBuffer with thesequence contained in the map pointed to by the specified key, byte by byte.
private void growkeyarray ( ) { int newsize = pointersandordinals . length ( ) << num_ ; if ( newsize < num_ ) { throw new illegalstateexception ( str_ + str_ + str_ + pointersandordinals . length ( ) + str_ + newsize ) ; } growkeyarray ( newsize ) ; }	Grow the key array.
private int rehashpreviouslyaddeddata ( long key ) { long position = key & pointer_mask ; int sizeofdata = varint . readvint ( bytedata . getunderlyingarray ( ) , position ) ; position += varint . sizeofvint ( sizeofdata ) ; return hashcodes . hashcode ( bytedata . getunderlyingarray ( ) , position , sizeofdata ) ; }	Get the hash code for the byte array pointed to by the specified key.
private atomiclongarray emptykeyarray ( int size ) { atomiclongarray arr = new atomiclongarray ( size ) ;	Create an AtomicLongArray of the specified size, each value in the array will be EMPTY_BUCKET_VALUE.
public boolean ismatchequal ( int matchidx , hollowindexervaluetraverser othertraverser , int othermatchidx ) { for ( int i = num_ ; i < getnumfieldpaths ( ) ; i ++ ) { if ( ! hollowreadfieldutils . fieldsareequal ( ( hollowobjecttypedataaccess ) fieldtypedataaccess [ i ] , fieldmatchlists [ i ] . get ( matchidx ) , fieldschemaposition [ i ] , ( hollowobjecttypedataaccess ) othertraverser . fieldtypedataaccess [ i ] , othertraverser . fieldmatchlists [ i ] . get ( othermatchidx ) , othertraverser . fieldschemaposition [ i ] ) ) return bool_ ; } return bool_ ; }	This method assumes the other traverser has the same match fields specified in the same order.
public t findmatch ( q key ) { object [ ] keyarray = matchfields . stream ( ) . map ( mf -> mf . extract ( key ) ) . toarray ( ) ; int ordinal = hpki . getmatchingordinal ( keyarray ) ; if ( ordinal == - num_ ) { return null ; } return uniquetypeextractor . extract ( api , ordinal ) ; }	Finds the unique object, an instance of the unique type, for a given key.
readstatehelper swap ( ) { return new readstatehelper ( newreadstate ( current . getversion ( ) , pending . getstateengine ( ) ) , newreadstate ( pending . getversion ( ) , current . getstateengine ( ) ) ) ; }	Swap underlying state engines between current and pending while keeping the versions consistent;used after delta integrity checks have altered the underlying state engines.
public static int hashtablesize ( int numelements ) throws illegalargumentexception { if ( numelements < num_ ) { throw new illegalargumentexception ( str_ + numelements ) ; } else if ( numelements > hash_table_max_size ) { throw new illegalargumentexception ( str_ + numelements ) ; } if ( numelements == num_ ) return num_ ; if ( numelements < num_ ) return numelements * num_ ;	Determine size of hash table capable of storing the specified number of elements with a loadfactor applied.
public long runcompactioncycle ( hollowcompactor . compactionconfig config ) { if ( config != null && readstates . hascurrent ( ) ) { final hollowcompactor compactor = new hollowcompactor ( getwriteengine ( ) , readstates . current ( ) . getstateengine ( ) , config ) ; if ( compactor . needscompaction ( ) ) { return runcycle ( newstate -> compactor . compact ( ) ) ; } } return no_announcement_available ; }	Run a compaction cycle, will produce a data state with exactly the same data as currently, butreorganized so that ordinal holes are filled.
public void writesnapshot ( outputstream os ) throws ioexception { stateengine . prepareforwrite ( ) ; dataoutputstream dos = new dataoutputstream ( os ) ; writeheader ( dos , stateengine . getschemas ( ) , bool_ ) ; varint . writevint ( dos , stateengine . getorderedtypestates ( ) . size ( ) ) ; simultaneousexecutor executor = new simultaneousexecutor ( getclass ( ) , str_ ) ; for ( final hollowtypewritestate typestate : stateengine . getorderedtypestates ( ) ) { executor . execute ( new runnable ( ) { public void run ( ) { typestate . calculatesnapshot ( ) ; } } ) ; } try { executor . awaitsuccessfulcompletion ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } for ( hollowtypewritestate typestate : stateengine . getorderedtypestates ( ) ) { hollowschema schema = typestate . getschema ( ) ; schema . writeto ( dos ) ; writenumshards ( dos , typestate . getnumshards ( ) ) ; typestate . writesnapshot ( dos ) ; } os . flush ( ) ; }	Write the current state as a snapshot blob.
public void writedelta ( outputstream os ) throws ioexception { stateengine . prepareforwrite ( ) ; if ( stateengine . isrestored ( ) ) stateengine . ensureallnecessarystatesrestored ( ) ; list < hollowschema > changedtypes = changedtypes ( ) ; dataoutputstream dos = new dataoutputstream ( os ) ; writeheader ( dos , changedtypes , bool_ ) ; varint . writevint ( dos , changedtypes . size ( ) ) ; simultaneousexecutor executor = new simultaneousexecutor ( getclass ( ) , str_ ) ; for ( final hollowtypewritestate typestate : stateengine . getorderedtypestates ( ) ) { executor . execute ( new runnable ( ) { public void run ( ) { if ( typestate . haschangedsincelastcycle ( ) ) typestate . calculatedelta ( ) ; } } ) ; } try { executor . awaitsuccessfulcompletion ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } for ( hollowtypewritestate typestate : stateengine . getorderedtypestates ( ) ) { if ( typestate . haschangedsincelastcycle ( ) ) { hollowschema schema = typestate . getschema ( ) ; schema . writeto ( dos ) ; writenumshards ( dos , typestate . getnumshards ( ) ) ; typestate . writedelta ( dos ) ; } } os . flush ( ) ; }	Serialize the changes necessary to transition a consumer from the previous stateto the current state as a delta blob.
private void addtosetifnotprimitiveorcollection ( set < string > schemanameset , string ... schemanames ) { for ( string schemaname : schemanames ) {	Adds the schema name to the set if the schema name doesn't correspond to a Hollowprimitive type.
public static string normalizefieldpathtoparamname ( string fieldpath ) { string result = null ; if ( fieldpath . contains ( str_ ) ) { string [ ] parts = fieldpath . split ( str_ ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( lowercase ( parts [ num_ ] ) ) ; for ( int i = num_ ; i < parts . length ; i ++ ) { sb . append ( uppercase ( parts [ i ] ) ) ; } result = sb . tostring ( ) ; } else { result = lowercase ( fieldpath ) ; } if ( result . endswith ( str_ ) ) { return result . substring ( num_ , result . length ( ) - num_ ) ; } return result ; }	Convert field path into Param nameEg:- Actor {.
private void reindexhashindex ( ) { hollowhashindexbuilder builder = new hollowhashindexbuilder ( stateengine , type , selectfield , matchfields ) ; builder . buildindex ( ) ; this . hashstatevolatile = new hollowhashindexstate ( builder ) ; }	Recreate the hash index entirely.
public hollowhashindexresult findmatches ( object ... query ) { int hashcode = num_ ; for ( int i = num_ ; i < query . length ; i ++ ) { if ( query [ i ] == null ) throw new illegalargumentexception ( str_ + i ) ; hashcode ^= hashcodes . hashint ( keyhashcode ( query [ i ] , i ) ) ; } hollowhashindexresult result ; hollowhashindexstate hashstate ; do { result = null ; hashstate = hashstatevolatile ; long bucket = hashcode & hashstate . getmatchhashmask ( ) ; long hashbucketbit = bucket * hashstate . getbitspermatchhashentry ( ) ; boolean bucketisempty = hashstate . getmatchhashtable ( ) . getelementvalue ( hashbucketbit , hashstate . getbitspertraverserfield ( ) [ num_ ] ) == num_ ; while ( ! bucketisempty ) { if ( matchisequal ( hashstate . getmatchhashtable ( ) , hashbucketbit , query ) ) { int selectsize = ( int ) hashstate . getmatchhashtable ( ) . getelementvalue ( hashbucketbit + hashstate . getbitspermatchhashkey ( ) , hashstate . getbitsperselecttablesize ( ) ) ; long selectbucketpointer = hashstate . getmatchhashtable ( ) . getelementvalue ( hashbucketbit + hashstate . getbitspermatchhashkey ( ) + hashstate . getbitsperselecttablesize ( ) , hashstate . getbitsperselecttablepointer ( ) ) ; result = new hollowhashindexresult ( hashstate , selectbucketpointer , selectsize ) ; break ; } bucket = ( bucket + num_ ) & hashstate . getmatchhashmask ( ) ; hashbucketbit = bucket * hashstate . getbitspermatchhashentry ( ) ; bucketisempty = hashstate . getmatchhashtable ( ) . getelementvalue ( hashbucketbit , hashstate . getbitspertraverserfield ( ) [ num_ ] ) == num_ ; } } while ( hashstate != hashstatevolatile ) ; return result ; }	Query the index.
public void triggerasyncrefreshwithrandomdelay ( int maxdelaymillis ) { random rand = new random ( ) ; int delaymillis = maxdelaymillis > num_ ? rand . nextint ( maxdelaymillis ) : num_ ; triggerasyncrefreshwithdelay ( delaymillis ) ; }	Triggers async refresh after some random number of milliseconds have passed,between now and the specified maximum number of milliseconds.Any subsequent calls for async refresh will not begin until after the specified delayhas completed.
public void triggerasyncrefreshwithdelay ( int delaymillis ) { final hollowclient client = this . client ; final long targetbegintime = system . currenttimemillis ( ) + delaymillis ; refreshexecutor . execute ( new runnable ( ) { public void run ( ) { try { long delay = targetbegintime - system . currenttimemillis ( ) ; if ( delay > num_ ) thread . sleep ( delay ) ; client . triggerrefresh ( ) ; } catch ( throwable th ) { log . log ( level . severe , str_ , th ) ; } } } ) ; }	Triggers async refresh after the specified number of milliseconds has passed.Any subsequent calls for async refresh will not begin until after the specified delayhas completed.
public hollowtypediff addtypediff ( string type , string ... primarykeypaths ) { hollowtypediff typediff = new hollowtypediff ( this , type , primarykeypaths ) ; if ( typediff . hasanydata ( ) ) typediffs . put ( type , typediff ) ; return typediff ; }	Add a type to be included in the diff report.
public static void writevint ( outputstream out , int value ) throws ioexception { if ( value > num_ || value < num_ ) out . write ( ( byte ) ( num_ | ( ( value > > > num_ ) ) ) ) ; if ( value > num_ || value < num_ ) out . write ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; if ( value > num_ || value < num_ ) out . write ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; if ( value > num_ || value < num_ ) out . write ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; out . write ( ( byte ) ( value & num_ ) ) ; }	Encode the specified int as a variable length integer into the supplied OutputStream.
public static int writevint ( byte data [ ] , int pos , int value ) { if ( value > num_ || value < num_ ) data [ pos ++ ] = ( ( byte ) ( num_ | ( ( value > > > num_ ) ) ) ) ; if ( value > num_ || value < num_ ) data [ pos ++ ] = ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; if ( value > num_ || value < num_ ) data [ pos ++ ] = ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; if ( value > num_ || value < num_ ) data [ pos ++ ] = ( ( byte ) ( num_ | ( ( value > > > num_ ) & num_ ) ) ) ; data [ pos ++ ] = ( byte ) ( value & num_ ) ; return pos ; }	Write the value as a VarInt into the array, starting at the specified position.
public static int readvint ( inputstream in ) throws ioexception { byte b = ( byte ) in . read ( ) ; if ( b == ( byte ) num_ ) throw new runtimeexception ( str_ ) ; int value = b & num_ ; while ( ( b & num_ ) != num_ ) { b = ( byte ) in . read ( ) ; value <<= num_ ; value |= ( b & num_ ) ; } return value ; }	Read a variable length integer from the supplied InputStream.
public static long readvlong ( inputstream in ) throws ioexception { byte b = ( byte ) in . read ( ) ; if ( b == ( byte ) num_ ) throw new runtimeexception ( str_ ) ; long value = b & num_ ; while ( ( b & num_ ) != num_ ) { b = ( byte ) in . read ( ) ; value <<= num_ ; value |= ( b & num_ ) ; } return value ; }	Read a variable length long from the supplied InputStream.
protected final void addviewinternal ( view child , int index , viewgroup . layoutparams params ) { super . addview ( child , index , params ) ; }	Used internally for adding view. Need because we override addView topass-through to the Refreshable View.
protected final void refreshloadingviewssize ( ) { final int maximumpullscroll = ( int ) ( getmaximumpullscroll ( ) * num_ ) ; int pleft = getpaddingleft ( ) ; int ptop = getpaddingtop ( ) ; int pright = getpaddingright ( ) ; int pbottom = getpaddingbottom ( ) ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : if ( mmode . showheaderloadinglayout ( ) ) { mheaderlayout . setwidth ( maximumpullscroll ) ; pleft = - maximumpullscroll ; } else { pleft = num_ ; } if ( mmode . showfooterloadinglayout ( ) ) { mfooterlayout . setwidth ( maximumpullscroll ) ; pright = - maximumpullscroll ; } else { pright = num_ ; } break ; case vertical : if ( mmode . showheaderloadinglayout ( ) ) { mheaderlayout . setheight ( maximumpullscroll ) ; ptop = - maximumpullscroll ; } else { ptop = num_ ; } if ( mmode . showfooterloadinglayout ( ) ) { mfooterlayout . setheight ( maximumpullscroll ) ; pbottom = - maximumpullscroll ; } else { pbottom = num_ ; } break ; } if ( debug ) { log . d ( log_tag , string . format ( str_ , pleft , ptop , pright , pbottom ) ) ; } setpadding ( pleft , ptop , pright , pbottom ) ; }	Re-measure the Loading Views height, and adjust internal padding asnecessary.
protected void updateuiformode ( ) {	Updates the View State when the mode has been set.
private void pullevent ( ) { final int newscrollvalue ; final int itemdimension ; final float initialmotionvalue , lastmotionvalue ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : initialmotionvalue = minitialmotionx ; lastmotionvalue = mlastmotionx ; break ; case vertical : default : initialmotionvalue = minitialmotiony ; lastmotionvalue = mlastmotiony ; break ; } switch ( mcurrentmode ) { case pull_from_end : newscrollvalue = math . round ( math . max ( initialmotionvalue - lastmotionvalue , num_ ) / friction ) ; itemdimension = getfootersize ( ) ; break ; case pull_from_start : default : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , num_ ) / friction ) ; itemdimension = getheadersize ( ) ; break ; } setheaderscroll ( newscrollvalue ) ; if ( newscrollvalue != num_ && ! isrefreshing ( ) ) { float scale = math . abs ( newscrollvalue ) / ( float ) itemdimension ; switch ( mcurrentmode ) { case pull_from_end : mfooterlayout . onpull ( scale ) ; break ; case pull_from_start : default : mheaderlayout . onpull ( scale ) ; break ; } if ( mstate != state . pull_to_refresh && itemdimension >= math . abs ( newscrollvalue ) ) { setstate ( state . pull_to_refresh ) ; } else if ( mstate == state . pull_to_refresh && itemdimension < math . abs ( newscrollvalue ) ) { setstate ( state . release_to_refresh ) ; } } }	Actions a Pull Event.
givenrulebuilder < t , u > given ( string name , t value ) { return given ( new fact < t > ( name , value ) ) ; }	Adds a fact to the Rule.
@ safevarargs public final givenrulebuilder < t , u > given ( namevaluereferable ... facts ) { _rule . addfacts ( facts ) ; return this ; }	Adds one or more facts into the Rule.
public static rulebuilder < object , object > create ( class < ? extends rule > ruleclass , rulechainactiontype actiontype ) { return new rulebuilder < > ( ruleclass , actiontype ) ; }	Returns a new RuleBuilder for the specified Rule class.
public static rulebuilder < object , object > create ( ) { rulebuilder < object , object > rule = new rulebuilder < > ( goldenrule . class ) ; rule . _facttype = object . class ; return rule ; }	Returns a new RuleBuilder for the default Rule type.
public < s > rulebuilder < s , u > withfacttype ( class < s > facttype ) { rulebuilder < s , u > builder = new rulebuilder < > ( _ruleclass ) ; builder . _facttype = facttype ; builder . _resulttype = _resulttype ; builder . _actiontype = _actiontype ; return builder ; }	Specifies the fact type for the Rule being built.
public < s > rulebuilder < t , s > withresulttype ( class < s > resulttype ) { rulebuilder < t , s > builder = new rulebuilder < > ( _ruleclass ) ; builder . _facttype = _facttype ; builder . _resulttype = resulttype ; builder . _actiontype = _actiontype ; builder . _name = _name ; return builder ; }	Specifies the Result type for the Rule being built.
@ suppresswarnings ( str_ ) public givenrulebuilder < t , u > given ( string name , t value ) { rule < t , u > rule = _name . map ( rulename -> ( rule < t , u > ) new auditablerule < t , u > ( newrule ( ) , rulename ) ) . orelse ( newrule ( ) ) ; if ( rule == null ) { throw new illegalstateexception ( str_ ) ; } return new givenrulebuilder < t , u > ( rule , new fact < t > ( name , value ) ) ; }	Adds a fact to the Rule using a name value pair to specify a new fact.
@ suppresswarnings ( str_ ) @ safevarargs public final givenrulebuilder < t , u > given ( namevaluereferable ... facts ) { rule < t , u > rule = _name . map ( name -> ( rule < t , u > ) new auditablerule < t , u > ( newrule ( ) , name ) ) . orelse ( newrule ( ) ) ; if ( rule == null ) { throw new illegalstateexception ( str_ ) ; } return new givenrulebuilder < t , u > ( rule , facts ) ; }	Adds one or more facts to the Rule.
@ suppresswarnings ( str_ ) public thenrulebuilder < t , u > then ( consumer < namevaluereferabletypeconvertiblemap < t > > action ) { rule < t , u > rule = _name . map ( name -> ( rule < t , u > ) new auditablerule < t , u > ( newrule ( ) , name ) ) . orelse ( newrule ( ) ) ; if ( rule == null ) { throw new illegalstateexception ( str_ ) ; } return new thenrulebuilder < t , u > ( rule , action ) ; }	Adds an action as a Consumer to the Rule.
protected object getruleinstance ( class < ? > rule ) { try { return rule . newinstance ( ) ; } catch ( instantiationexception | illegalaccessexception ex ) { logger . warn ( str_ + rule + str_ , ex ) ; } return null ; }	Returns a rule instance For container aware contexts (like Spring, Guice, Weld, etc.) override this method and instantiate the rulevia the container.
public static optional < field > getannotatedfield ( class annotation , class clazz ) { list < field > fields = getannotatedfields ( annotation , clazz ) ; return optional . ofnullable ( fields . size ( ) > num_ ? fields . get ( num_ ) : null ) ; }	Method getAnnotatedField gets the first annotated field of the type of annotation specified.
public static optional < method > getannotatedmethod ( class annotation , class clazz ) { list < method > methods = getannotatedmethods ( annotation , clazz ) ; return optional . ofnullable ( methods . size ( ) > num_ ? methods . get ( num_ ) : null ) ; }	Method getAnnotatedMethod the first annotated method of the type of annotation specified.
@ suppresswarnings ( str_ ) public static < a extends annotation > a getannotation ( class < a > annotation , class < ? > clazz ) { return optional . ofnullable ( clazz . getannotation ( annotation ) ) . orelse ( ( a ) arrays . stream ( clazz . getdeclaredannotations ( ) ) . flatmap ( anno -> arrays . stream ( anno . getclass ( ) . getinterfaces ( ) ) . flatmap ( iface -> arrays . stream ( iface . getdeclaredannotations ( ) ) ) ) . filter ( annotation :: isinstance ) . findfirst ( ) . orelse ( null ) ) ; }	Method getAnnotation returns the annotation on a class or its parent annotation.
public void registerrule ( auditable rule ) { _lock . writelock ( ) . lock ( ) ; try { _auditmap . put ( rule . getname ( ) , new hashmap < > ( ) ) ; } finally { _lock . writelock ( ) . unlock ( ) ; } }	Registers a rule to be audited.
public void updaterulestatus ( auditable rule , rulestatus status ) { _lock . readlock ( ) . lock ( ) ; try { if ( _auditmap . containskey ( rule . getname ( ) ) ) { _lock . readlock ( ) . unlock ( ) ; _lock . writelock ( ) . lock ( ) ; try { _auditmap . get ( rule . getname ( ) ) . put ( thread . currentthread ( ) . getid ( ) , status ) ; _lock . readlock ( ) . lock ( ) ; } finally { _lock . writelock ( ) . unlock ( ) ; } } } finally { _lock . readlock ( ) . unlock ( ) ; } }	Updates the status of the rule & stores the status with the Auditor.
public map < string , rulestatus > getrulestatusmap ( ) { _lock . readlock ( ) . lock ( ) ; try { return _auditmap . keyset ( ) . stream ( ) . collect ( collectors . tomap ( key -> key , key -> _auditmap . get ( key ) . getordefault ( thread . currentthread ( ) . getid ( ) , rulestatus . pending ) ) ) ; } finally { _lock . readlock ( ) . unlock ( ) ; } }	Gets a map of each rule name with its associated status.
public < u > rulebookwithresulttypebuilder < u > withresulttype ( class < u > resulttype ) { _resulttype = resulttype ; return new rulebookwithresulttypebuilder < u > ( ( new rulebookbuilder < u > ( this ) ) . newrulebook ( ) ) ; }	Specifies the Result type for the RuleBook.
public thenrulebuilder < t , u > then ( consumer < namevaluereferabletypeconvertiblemap < t > > action ) { _rule . addaction ( action ) ; return this ; }	Adds a then action into the Rule.
public thenrulebuilder < t , u > then ( biconsumer < namevaluereferabletypeconvertiblemap < t > , result < u > > action ) { _rule . addaction ( action ) ; return this ; }	Addds a then action into the Rule.
public void reset ( ) { _lock . readlock ( ) . lock ( ) ; try { if ( _defaultvalue == null ) { return ; } } finally { _lock . readlock ( ) . unlock ( ) ; } setvalue ( _defaultvalue ) ; }	Resets the value of the Result to its default value.
@ suppresswarnings ( str_ ) public < t > rulebookrulewithfacttypebuilder < t , u > withfacttype ( class < t > facttype ) { rule < t , u > rule = ( rule < t , u > ) rulebuilder . create ( _ruleclass ) . withfacttype ( facttype ) . build ( ) ; _rulebook . addrule ( rule ) ; return new rulebookrulewithfacttypebuilder < > ( rule ) ; }	Specifies the fact type.
protected list < class < ? > > getpojorules ( ) { reflections reflections = new reflections ( _package ) ; list < class < ? > > rules = reflections . gettypesannotatedwith ( com . deliveredtechnologies . rulebook . annotation . rule . class ) . stream ( ) . filter ( rule -> rule . getannotatedsuperclass ( ) != null )	Gets the POJO Rules to be used by the RuleBook via reflection of the specified package.
private string reademptylineorendtable ( final bufferedreader tablecontent ) throws ioexception { final string column = tablecontent . readline ( ) ; if ( column != null && column . startswith ( end_table ) ) { return end_table ; } if ( column == null || ! column . isempty ( ) ) { throw new illegalargumentexception ( string . format ( str_ , column ) ) ; } return str_ ; }	Reads empty line or throw an exception if a none empty line was found.
private service [ ] toarray ( list < service > services ) { if ( services == null ) { return new service [ num_ ] ; } if ( services instanceof arraylist ) { return ( ( arraylist < service > ) services ) . toarray ( new service [ services . size ( ) ] ) ; } else { service [ ] ret = new service [ services . size ( ) ] ; for ( int i = num_ ; i < services . size ( ) ; i ++ ) { ret [ i ] = services . get ( i ) ; } return ret ; } }	convert list to array, never returns null.
private list < string > getportsfrombuildconfiguration ( imageconfiguration image ) {	Examine images for build configuration and extract all ports.
private list < serviceport > extractportsfromconfig ( ) { list < serviceport > ret = new linkedlist < > ( ) ; string ports = getconfig ( config . port ) ; if ( ports != null ) { for ( string port : stringutils . split ( ports , str_ ) ) { ret . add ( parseportmapping ( port ) ) ; } } return ret ; }	Config can override ports.
private serviceport parseportmapping ( string port ) { matcher matcher = port_mapping_pattern . matcher ( port ) ; if ( ! matcher . matches ( ) ) { log . error ( str_ , port ) ; throw new illegalargumentexception ( str_ + port ) ; } int serviceport = integer . parseint ( matcher . group ( str_ ) ) ; string optionaltargetport = matcher . group ( str_ ) ; string protocol = getprotocol ( matcher . group ( str_ ) ) ; serviceportbuilder builder = new serviceportbuilder ( ) . withport ( serviceport ) . withprotocol ( protocol ) . withname ( getdefaultportname ( serviceport , protocol ) ) ;	parse config specified ports.
private void addportifnotnull ( list < serviceport > ret , serviceport port ) { if ( port != null ) { ret . add ( port ) ; } }	null ports can happen for ignored mappings.
private serviceport shiftornull ( list < serviceport > ports ) { if ( ! ports . isempty ( ) ) { return ports . remove ( num_ ) ; } return null ; }	remove first element of list or null if list is empty.
private void addmissingserviceparts ( servicebuilder service , service defaultservice ) {	Merge services of same name with the default service.
public void appendimagestreamresource ( imagename imagename , file target ) throws mojoexecutionexception { string tag = stringutils . isblank ( imagename . gettag ( ) ) ? str_ : imagename . gettag ( ) ; try { imagestream is = new imagestreambuilder ( ) . withnewmetadata ( ) . withname ( imagename . getsimplename ( ) ) . endmetadata ( ) . withnewspec ( ) . addnewtag ( ) . withname ( tag ) . withnewfrom ( ) . withkind ( str_ ) . endfrom ( ) . endtag ( ) . endspec ( ) . build ( ) ; createorupdateimagestreamtag ( client , imagename , is ) ; appendimagestreamtofile ( is , target ) ; log . info ( str_ , imagename . getsimplename ( ) , target ) ; } catch ( kubernetesclientexception e ) { kubernetesresourceutil . handlekubernetesclientexception ( e , this . log ) ; } catch ( ioexception e ) { throw new mojoexecutionexception ( string . format ( str_ , imagename . getfullname ( ) , target . getabsolutefile ( ) , e . getmessage ( ) ) , e ) ; } }	Save the images stream to a file.
private static boolean portsmatch ( serviceport serviceport , intorstring intorstring ) { if ( intorstring != null ) { integer port = serviceport . getport ( ) ; integer intval = intorstring . getintval ( ) ; string strval = intorstring . getstrval ( ) ; if ( intval != null ) { if ( port != null ) { return port . intvalue ( ) == intval . intvalue ( ) ; } else {	Returns true if the given servicePort matches the intOrString value.
private static string servicetoportorblank ( string servicename ) { string envvarname = toserviceportenvironmentvariable ( servicename ) ; return getenvvarorsystemproperty ( envvarname , str_ ) ; }	Returns the named port for the given service name or blank.
private static string getservicehostandport ( string servicename , string defaulthost , string defaultport ) { string serviceenvvarprefix = getserviceenvvarprefix ( servicename ) ; string hostenvvar = serviceenvvarprefix + str_ ; string portenvvar = serviceenvvarprefix + str_ ; string host = getenvvarorsystemproperty ( hostenvvar , hostenvvar , defaulthost ) ; string port = getenvvarorsystemproperty ( portenvvar , portenvvar , defaultport ) ; string answer = host + str_ + port ; return answer ; }	Returns the service host and port for the given environment variable name.
public static void putifabsent ( map < string , string > map , string name , string value ) { if ( ! map . containskey ( name ) ) { map . put ( name , value ) ; } }	Adds the given key and value pair into the map if the map does not already contain a value for that key.
public static void mergeifabsent ( map < string , string > map , map < string , string > tomerge ) { for ( map . entry < string , string > entry : tomerge . entryset ( ) ) { putifabsent ( map , entry . getkey ( ) , entry . getvalue ( ) ) ; ; } }	Add all values of a map to another map, but onlfy if not already existing.
public static < k , v > map < k , v > mergemaps ( map < k , v > map1 , map < k , v > map2 ) { map < k , v > answer = new hashmap < > ( ) ; if ( map2 != null ) { answer . putall ( map2 ) ; } if ( map1 != null ) { answer . putall ( map1 ) ; } return answer ; }	Returns a new map with all the entries of map1 and any from map2 which don't override map1.Can handle either maps being null.
public static void putallifnotnull ( map < string , string > ret , map < string , string > toput ) { if ( toput != null ) { ret . putall ( toput ) ; } }	Copies all of the elements i.e., the mappings, from toPut map into ret, if toPut isn't null.
private void waituntilpodisready ( string podname , int nawaittimeout , final logger log ) throws interruptedexception { final countdownlatch readylatch = new countdownlatch ( num_ ) ; try ( watch watch = client . pods ( ) . withname ( podname ) . watch ( new watcher < pod > ( ) { @ override public void eventreceived ( action action , pod apod ) { if ( kuberneteshelper . ispodready ( apod ) ) { readylatch . countdown ( ) ; } } @ override public void onclose ( kubernetesclientexception e ) {	A Simple utility function to watch over pod until it gets ready.
public static string validatekubernetesid ( string currentvalue , string description ) throws illegalargumentexception { if ( stringutils . isblank ( currentvalue ) ) { throw new illegalargumentexception ( str_ + description + str_ ) ; } int size = currentvalue . length ( ) ; for ( int i = num_ ; i < size ; i ++ ) { char ch = currentvalue . charat ( i ) ; if ( character . isuppercase ( ch ) ) { throw new illegalargumentexception ( str_ + ch + str_ + i + str_ + description + str_ + currentvalue ) ; } } return currentvalue ; }	Validates that the given value is valid according to the kubernetes ID parsing rules, throwing an exception if not.
@ suppresswarnings ( str_ ) public static list < hasmetadata > toitemlist ( object entity ) throws ioexception { if ( entity instanceof list ) { return ( list < hasmetadata > ) entity ; } else if ( entity instanceof hasmetadata [ ] ) { hasmetadata [ ] array = ( hasmetadata [ ] ) entity ; return arrays . aslist ( array ) ; } else if ( entity instanceof kuberneteslist ) { kuberneteslist config = ( kuberneteslist ) entity ; return config . getitems ( ) ; } else if ( entity instanceof template ) { template objects = ( template ) entity ; return objects . getobjects ( ) ; } else { list < hasmetadata > answer = new arraylist < > ( ) ; if ( entity instanceof hasmetadata ) { answer . add ( ( hasmetadata ) entity ) ; } return answer ; } }	Loads the Kubernetes JSON and converts it to a list of entities.
public static string getresourceversion ( hasmetadata entity ) { if ( entity != null ) { objectmeta metadata = entity . getmetadata ( ) ; if ( metadata != null ) { string resourceversion = metadata . getresourceversion ( ) ; if ( stringutils . isnotblank ( resourceversion ) ) { return resourceversion ; } } } return null ; }	Returns the resource version for the entity or null if it does not have one.
public static boolean ispodready ( pod pod ) { if ( ! ispodrunning ( pod ) ) { return bool_ ; } podstatus podstatus = pod . getstatus ( ) ; if ( podstatus == null ) { return bool_ ; } list < podcondition > conditions = podstatus . getconditions ( ) ; if ( conditions == null || conditions . isempty ( ) ) { return bool_ ; }	Returns true if the pod is running and ready.
private static context getcurrentcontext ( config config ) { string contextname = config . getcurrentcontext ( ) ; if ( contextname != null ) { list < namedcontext > contexts = config . getcontexts ( ) ; if ( contexts != null ) { for ( namedcontext context : contexts ) { if ( objects . equals ( contextname , context . getname ( ) ) ) { return context . getcontext ( ) ; } } } } return null ; }	Returns the current context in the given config.
private boolean hasroute ( final kuberneteslistbuilder listbuilder , final string name ) { final atomicboolean answer = new atomicboolean ( bool_ ) ; listbuilder . accept ( new typedvisitor < routebuilder > ( ) { @ override public void visit ( routebuilder builder ) { objectmeta metadata = builder . getmetadata ( ) ; if ( metadata != null && name . equals ( metadata . getname ( ) ) ) { answer . set ( bool_ ) ; } } } ) ; return answer . get ( ) ; }	Returns true if we already have a route created for the given name.
public static boolean hasresource ( mavenproject project , string ... paths ) { urlclassloader compileclassloader = getcompileclassloader ( project ) ; for ( string path : paths ) { try { if ( compileclassloader . getresource ( path ) != null ) { return bool_ ; } } catch ( throwable e ) {	Returns true if any of the given resources could be found on the given class loader.
private static map < string , object > readandenrichfragment ( platformmode platformmode , resourceversioning apiversions , file file , string appname ) throws ioexception { pattern pattern = pattern . compile ( filename_pattern , pattern . case_insensitive ) ; matcher matcher = pattern . matcher ( file . getname ( ) ) ; if ( ! matcher . matches ( ) ) { throw new illegalargumentexception ( string . format ( str_ , file . getname ( ) ) ) ; } string name = matcher . group ( str_ ) ; string type = matcher . group ( str_ ) ; string ext = matcher . group ( str_ ) . tolowercase ( ) ; string kind ; map < string , object > fragment = readfragment ( file , ext ) ; if ( type != null ) { kind = getandvalidatekindfromtype ( file , type ) ; } else {	Read fragment and add default values.
public static list < envvar > converttoenvvarlist ( map < string , string > envvars ) { list < envvar > envlist = new linkedlist < > ( ) ; for ( map . entry < string , string > entry : envvars . entryset ( ) ) { string name = entry . getkey ( ) ; string value = entry . getvalue ( ) ; if ( name != null ) { envvar env = new envvarbuilder ( ) . withname ( name ) . withvalue ( value ) . build ( ) ; envlist . add ( env ) ; } } return envlist ; }	Convert a map of env vars to a list of K8s EnvVar objects.
public static hasmetadata mergeresources ( hasmetadata item1 , hasmetadata item2 , logger log , boolean switchonlocalcustomisation ) { if ( item1 instanceof deployment && item2 instanceof deployment ) { return mergedeployments ( ( deployment ) item1 , ( deployment ) item2 , log , switchonlocalcustomisation ) ; } if ( item1 instanceof configmap && item2 instanceof configmap ) { configmap cm1 = ( configmap ) item1 ; configmap cm2 = ( configmap ) item2 ; return mergeconfigmaps ( cm1 , cm2 , log , switchonlocalcustomisation ) ; } mergemetadata ( item1 , item2 ) ; return item1 ; }	Merges the given resources together into a single resource.If switchOnLocalCustomisation is false then the overrides from item2 are merged into item1.
private static map < string , string > mergemapsandremoveemptystrings ( map < string , string > overridemap , map < string , string > originalmap ) { map < string , string > answer = maputil . mergemaps ( overridemap , originalmap ) ; set < map . entry < string , string > > entries = overridemap . entryset ( ) ; for ( map . entry < string , string > entry : entries ) { string value = entry . getvalue ( ) ; if ( value == null || value . isempty ( ) ) { string key = entry . getkey ( ) ; answer . remove ( key ) ; } } return answer ; }	Returns a merge of the given maps and then removes any resulting empty string values (which is the way to remove, say, a label or annotationwhen overriding.
private static boolean islocalcustomisation ( podspec podspec ) { list < container > containers = podspec . getcontainers ( ) != null ? podspec . getcontainers ( ) : collections . < container > emptylist ( ) ; for ( container container : containers ) { if ( stringutils . isnotblank ( container . getimage ( ) ) ) { return bool_ ; } } return bool_ ; }	we could also use an annotation?.
private map < string , string > readconfig ( file f ) throws ioexception { map < string , string > map ; if ( f . getname ( ) . endswith ( json_extension ) ) { map = flatten ( json_mapper . readvalue ( f , map . class ) ) ; } else if ( f . getname ( ) . endswith ( yaml_extension ) || f . getname ( ) . endswith ( yml_extension ) ) { map = flatten ( yaml_mapper . readvalue ( f , map . class ) ) ; } else if ( f . getname ( ) . endswith ( properties_extension ) ) { properties properties = new properties ( ) ; properties . load ( new fileinputstream ( f ) ) ; map = propertiestomap ( properties ) ; } else { throw new illegalargumentexception ( str_ + f . getname ( ) + str_ ) ; } return map ; }	Reads the configuration from the file.
private void addportifvalid ( map < string , integer > map , string key , string port ) { if ( stringutils . isnotblank ( port ) ) { string t = port . trim ( ) ; if ( t . matches ( number_regex ) ) { map . put ( key , integer . parseint ( t ) ) ; } } }	Adds a port to the list.
public string getdockerjsonconfigstring ( final settings settings , final string serverid ) { server server = getserver ( settings , serverid ) ; if ( server == null ) { return str_ ; } jsonobject auth = new jsonobject ( ) ; auth . add ( str_ , new jsonprimitive ( server . getusername ( ) ) ) ; auth . add ( str_ , new jsonprimitive ( server . getpassword ( ) ) ) ; string mail = getconfigurationvalue ( server , str_ ) ; if ( ! stringutils . isblank ( mail ) ) { auth . add ( str_ , new jsonprimitive ( mail ) ) ; } jsonobject json = new jsonobject ( ) ; json . add ( serverid , auth ) ; return json . tostring ( ) ; }	Method used in MOJO.
public optional < map < string , object > > getpluginconfiguration ( string system , string id ) { return pluginconfiglookup . apply ( system , id ) ; }	Gets plugin configuration values.
public optional < map < string , object > > getsecretconfiguration ( string id ) { return secretconfiglookup . apply ( id ) ; }	Gets configuration values. Since there can be inner values,it returns a Map of Objects where an Object can be asimple type, List or another Map.
public static void download ( logger log , url downloadurl , file target ) throws mojoexecutionexception { log . progressstart ( ) ; try { okhttpclient client = new okhttpclient . builder ( ) . readtimeout ( num_ , timeunit . minutes ) . build ( ) ; request request = new request . builder ( ) . url ( downloadurl ) . build ( ) ; response response = client . newcall ( request ) . execute ( ) ; try ( outputstream out = new fileoutputstream ( target ) ; inputstream im = response . body ( ) . bytestream ( ) ) { long length = response . body ( ) . contentlength ( ) ; inputstream in = response . body ( ) . bytestream ( ) ; byte [ ] buffer = new byte [ num_ ] ; long readbytes = num_ ; while ( bool_ ) { int len = in . read ( buffer ) ; readbytes += len ; log . progressupdate ( target . getname ( ) , str_ , getprogressbar ( readbytes , length ) ) ; if ( len <= num_ ) { out . flush ( ) ; break ; } out . write ( buffer , num_ , len ) ; } } } catch ( ioexception e ) { throw new mojoexecutionexception ( str_ + downloadurl + str_ + target + str_ + e , e ) ; } finally { log . progressfinished ( ) ; } }	Download with showing the progress a given URL and store it in a file.
public static int compareversions ( string v1 , string v2 ) { string [ ] components1 = split ( v1 ) ; string [ ] components2 = split ( v2 ) ; int diff ; int length = math . min ( components1 . length , components2 . length ) ; for ( int i = num_ ; i < length ; i ++ ) { string s1 = components1 [ i ] ; string s2 = components2 [ i ] ; integer i1 = tryparseinteger ( s1 ) ; integer i2 = tryparseinteger ( s2 ) ; if ( i1 != null && i2 != null ) { diff = i1 . compareto ( i2 ) ; } else {	Compares two version strings such that "1.10.1" > "1.4" etc.
public static processorconfig blendprofilewithconfiguration ( processorconfigurationextractor configextractor , string profile , file resourcedir , processorconfig config ) throws ioexception {	Find an enricher or generator config, possibly via a profile and merge it with a given configuration.
public static profile lookup ( string name , file directory ) throws ioexception {	Lookup profiles from a given directory and merge it with a profile of thesame name found in the classpath.
private static list < profile > readprofilefromclasspath ( string name ) throws ioexception { list < profile > ret = new arraylist < > ( ) ; ret . addall ( readallfromclasspath ( name , str_ ) ) ; ret . addall ( readallfromclasspath ( name , str_ ) ) ; return ret ; }	Read all default profiles first, then merge in custom profiles found on the classpath.
public static list < profile > readallfromclasspath ( string name , string ext ) throws ioexception { list < profile > ret = new arraylist < > ( ) ; for ( string location : getmetainfprofilepaths ( ext ) ) { for ( string url : classutil . getresources ( location ) ) { for ( profile profile : fromyaml ( new url ( url ) . openstream ( ) ) ) { if ( name . equals ( profile . getname ( ) ) ) { ret . add ( profile ) ; } } } } return ret ; }	Read all profiles found in the classpath.
private static file findprofileyaml ( file directory ) { for ( string profilefile : profile_filenames ) { file ret = new file ( directory , string . format ( profilefile , str_ ) ) ; if ( ret . exists ( ) ) { return ret ; } } return null ; }	check for various variations of profile files.
private static list < string > getmetainfprofilepaths ( string ext ) { list < string > ret = new arraylist < > ( profile_filenames . length ) ; for ( string p : profile_filenames ) { ret . add ( str_ + getprofilefilename ( p , ext ) ) ; } return ret ; }	prepend meta-inf location.
public static list < profile > fromyaml ( inputstream is ) throws ioexception { typereference < list < profile > > typeref = new typereference < list < profile > > ( ) { } ; return mapper . readvalue ( is , typeref ) ; }	Load a profile from an input stream. This must be in YAML format.
private string getimagepullpolicy ( resourceconfig resourceconfig , string defaultvalue ) { if ( resourceconfig != null ) { return resourceconfig . getimagepullpolicy ( ) != null ? resourceconfig . getimagepullpolicy ( ) : defaultvalue ; } return defaultvalue ; }	This method overrides the ImagePullPolicy value by the value provided inXML config.
protected boolean isopenshiftmode ( ) { properties properties = getcontext ( ) . getconfiguration ( ) . getproperties ( ) ; if ( properties != null ) { return runtimemode . isopenshiftmode ( properties ) ; } return bool_ ; }	Returns true if we are in OpenShift S2I binary building mode.
protected int getreplicacount ( kuberneteslistbuilder builder , resourceconfig xmlresourceconfig , int defaultvalue ) { if ( xmlresourceconfig != null ) { list < hasmetadata > items = builder . builditems ( ) ; for ( hasmetadata item : items ) { if ( item instanceof deployment ) { if ( ( ( deployment ) item ) . getspec ( ) . getreplicas ( ) != null ) { return ( ( deployment ) item ) . getspec ( ) . getreplicas ( ) ; } } if ( item instanceof deploymentconfig ) { if ( ( ( deploymentconfig ) item ) . getspec ( ) . getreplicas ( ) != null ) { return ( ( deploymentconfig ) item ) . getspec ( ) . getreplicas ( ) ; } } } return xmlresourceconfig . getreplicas ( ) > num_ ? xmlresourceconfig . getreplicas ( ) : defaultvalue ; } return defaultvalue ; }	This method just makes sure that the replica count provided in XML configoverrides the default option; and resource fragments are always giventopmost priority.
public static element firstchild ( element element , string name ) { nodelist nodes = element . getchildnodes ( ) ; if ( nodes != null ) { for ( int i = num_ , size = nodes . getlength ( ) ; i < size ; i ++ ) { node item = nodes . item ( i ) ; if ( item instanceof element ) { element childelement = ( element ) item ; if ( name . equals ( childelement . gettagname ( ) ) ) { return childelement ; } } } } return null ; }	Returns the first child element for the given name.
public void installtemplate ( template entity , string sourcename ) { openshiftclient openshiftclient = getopenshiftclient ( ) ; if ( openshiftclient == null ) {	Installs the template into the namespace without processing it.
private int removetagbyname ( list < tagreference > tags , string tagname ) { list < tagreference > removetags = new arraylist < > ( ) ; for ( tagreference tag : tags ) { if ( objects . equals ( tagname , tag . getname ( ) ) ) { removetags . add ( tag ) ; } } tags . removeall ( removetags ) ; return removetags . size ( ) ; }	Removes all the tags with the given name.
public boolean applynamespace ( namespace entity ) { string namespace = getorcreatemetadata ( entity ) . getname ( ) ; log . info ( str_ + namespace ) ; string name = getname ( entity ) ; objects . requirenonnull ( name , str_ + entity ) ; namespace old = kubernetesclient . namespaces ( ) . withname ( name ) . get ( ) ; if ( ! isrunning ( old ) ) { try { object answer = kubernetesclient . namespaces ( ) . create ( entity ) ; loggeneratedentity ( str_ , namespace , entity , answer ) ; return bool_ ; } catch ( exception e ) { onapplyerror ( str_ + name + str_ + e . getmessage ( ) , e ) ; } } return bool_ ; }	Returns true if the namespace is created.
public boolean applyproject ( project project ) { return applyprojectrequest ( new projectrequestbuilder ( ) . withdisplayname ( project . getmetadata ( ) . getname ( ) ) . withmetadata ( project . getmetadata ( ) ) . build ( ) ) ; }	Creates and return a project in openshift.
public boolean applyprojectrequest ( projectrequest entity ) { string namespace = getorcreatemetadata ( entity ) . getname ( ) ; log . info ( str_ + namespace ) ; string name = getname ( entity ) ; objects . requirenonnull ( name , str_ + entity ) ; openshiftclient openshiftclient = getopenshiftclient ( ) ; if ( openshiftclient == null ) { log . warn ( str_ + namespace + str_ ) ; return bool_ ; } boolean exists = checknamespace ( name ) ;	Returns true if the ProjectRequest is created.
protected string getnamespace ( hasmetadata entity ) { string answer = kuberneteshelper . getnamespace ( entity ) ; if ( stringutils . isblank ( answer ) ) { answer = getnamespace ( ) ; }	Returns the namespace defined in the entity or the configured namespace.
protected void onapplyerror ( string message , exception e ) { log . error ( message , e ) ; throw new runtimeexception ( message , e ) ; }	Logs an error applying some JSON to Kubernetes and optionally throws an exception.
@ override public void create ( platformmode platformmode , kuberneteslistbuilder builder ) { final string name = config . getnamespace ( ) ; if ( name == null || name . isempty ( ) ) { return ; } if ( ! kubernetesresourceutil . checkforkind ( builder , namespace_kinds ) ) { string type = getconfig ( config . type ) ; if ( str_ . equalsignorecase ( type ) || str_ . equalsignorecase ( type ) ) { if ( platformmode == platformmode . kubernetes ) { log . info ( str_ + config . getnamespace ( ) ) ; namespace namespace = handlerhub . getnamespacehandler ( ) . getnamespace ( config . getnamespace ( ) ) ; builder . addtonamespaceitems ( namespace ) ; } else { log . info ( str_ + config . getnamespace ( ) ) ; project project = handlerhub . getprojecthandler ( ) . getproject ( config . getnamespace ( ) ) ; builder . addtoprojectitems ( project ) ; } } } }	This method will create a default Namespace or Project if a namespace property isspecified in the xml resourceConfig or as a parameter to a mojo.
@ override public void enrich ( platformmode platformmode , kuberneteslistbuilder builder ) { builder . accept ( new typedvisitor < objectmetabuilder > ( ) { private string getnamespacename ( ) { string name = null ; if ( config . getnamespace ( ) != null && ! config . getnamespace ( ) . isempty ( ) ) { name = config . getnamespace ( ) ; } name = builder . getitems ( ) . stream ( ) . filter ( item -> arrays . aslist ( namespace_kinds ) . contains ( item . getkind ( ) ) ) . findfirst ( ) . get ( ) . getmetadata ( ) . getname ( ) ; return name ; } @ override public void visit ( objectmetabuilder metabuilder ) { if ( ! kubernetesresourceutil . checkforkind ( builder , namespace_kinds ) ) { return ; } string name = getnamespacename ( ) ; if ( name == null || name . isempty ( ) ) { return ; } metabuilder . withnamespace ( name ) . build ( ) ; } } ) ;	This method will annotate all the items in the KubernetesListBuilder with thecreated new namespace or project.
protected map < string , string > getenv ( boolean prepackagephase ) throws mojoexecutionexception { map < string , string > ret = new hashmap < > ( ) ; if ( ! isfatjar ( ) ) { string mainclass = getconfig ( config . mainclass ) ; if ( mainclass == null ) { mainclass = mainclassdetector . getmainclass ( ) ; if ( mainclass == null ) { if ( ! prepackagephase ) { throw new mojoexecutionexception ( str_ ) ; } } } if ( mainclass != null ) { log . verbose ( str_ , mainclass ) ; ret . put ( java_main_class_env_var , mainclass ) ; } } list < string > javaoptions = getextrajavaoptions ( ) ; if ( javaoptions . size ( ) > num_ ) { ret . put ( java_options , stringutils . join ( javaoptions . iterator ( ) , str_ ) ) ; } return ret ; }	Hook for adding extra environment vars.
public static integer durationseconds ( string duration ) { bigdecimal ns = durationns ( duration ) ; if ( ns == null ) { return null ; } bigdecimal sec = ns . divide ( new bigdecimal ( num_ ) ) ; if ( sec . compareto ( new bigdecimal ( integer . max_value ) ) > num_ ) { throw new illegalargumentexception ( str_ ) ; } return sec . intvalue ( ) ; }	Parses a duration string anr returns its value in seconds.
public static bigdecimal durationns ( string durationp ) { if ( durationp == null ) { return null ; } string duration = durationp . trim ( ) ; if ( duration . length ( ) == num_ ) { return null ; } int unitpos = num_ ; while ( unitpos < duration . length ( ) && ( character . isdigit ( duration . charat ( unitpos ) ) || duration . charat ( unitpos ) == str_ ) ) { unitpos ++ ; } if ( unitpos >= duration . length ( ) ) { throw new illegalargumentexception ( str_ + duration ) ; } string tail = duration . substring ( unitpos ) ; long multiplier = null ; integer unitend = null ; for ( int i = num_ ; i < time_units . length ; i ++ ) { if ( tail . startswith ( time_units [ i ] ) ) { multiplier = unit_multipliers [ i ] ; unitend = unitpos + time_units [ i ] . length ( ) ; break ; } } if ( multiplier == null ) { throw new illegalargumentexception ( str_ + duration ) ; } bigdecimal value = new bigdecimal ( duration . substring ( num_ , unitpos ) ) ; value = value . multiply ( bigdecimal . valueof ( multiplier ) ) ; string remaining = duration . substring ( unitend ) ; bigdecimal remainingvalue = durationns ( remaining ) ; if ( remainingvalue != null ) { value = value . add ( remainingvalue ) ; } return value ; }	Parses a duration string anr returns its value in nanoseconds.
protected string [ ] scanfiles ( string ... patterns ) { string buildoutputdir = project . getbuild ( ) . getdirectory ( ) ; if ( buildoutputdir != null && new file ( buildoutputdir ) . exists ( ) ) { directoryscanner directoryscanner = new directoryscanner ( ) ; directoryscanner . setbasedir ( buildoutputdir ) ; directoryscanner . setincludes ( patterns ) ; directoryscanner . scan ( ) ; return directoryscanner . getincludedfiles ( ) ; } else { return new string [ num_ ] ; } }	Scan the project's output directory for certain files.
protected void disableopenshiftfeatures ( applyservice applyservice ) {	Lets disable OpenShift-only features if we are not running on OpenShift.
private boolean servicehasingressrule ( list < ingress > ingresses , service service ) { string servicename = kuberneteshelper . getname ( service ) ; for ( ingress ingress : ingresses ) { ingressspec spec = ingress . getspec ( ) ; if ( spec == null ) { break ; } list < ingressrule > rules = spec . getrules ( ) ; if ( rules == null ) { break ; } for ( ingressrule rule : rules ) { httpingressrulevalue http = rule . gethttp ( ) ; if ( http == null ) { break ; } list < httpingresspath > paths = http . getpaths ( ) ; if ( paths == null ) { break ; } for ( httpingresspath path : paths ) { ingressbackend backend = path . getbackend ( ) ; if ( backend == null ) { break ; } if ( objects . equals ( servicename , backend . getservicename ( ) ) ) { return bool_ ; } } } } return bool_ ; }	Returns true if there is an existing ingress rule for the given service.
public map < string , list < string > > parse ( final inputstream mapping ) { final properties mappingproperties = new properties ( ) ; try { mappingproperties . load ( mapping ) ; final map < string , list < string > > serializedcontent = new hashmap < > ( ) ; final set < string > kinds = mappingproperties . stringpropertynames ( ) ; for ( string kind : kinds ) { final string filenames = mappingproperties . getproperty ( kind ) ; final string [ ] filenametypes = filenames . split ( str_ ) ; final list < string > scannedfiletypes = new arraylist < > ( ) ; for ( final string filenametype : filenametypes ) { scannedfiletypes . add ( filenametype . trim ( ) ) ; } serializedcontent . put ( kind , scannedfiletypes ) ; } return serializedcontent ; } catch ( ioexception e ) { throw new illegalstateexception ( e ) ; } }	This method reads properties file to load custom mapping between kinds and filenames. ConfigMap=cm, configmapService=service .
private string getdefaulticonref ( ) { projectclassloaders cls = getcontext ( ) . getprojectclassloaders ( ) ; if ( cls . isclassincompileclasspath ( bool_ , str_ ) || getcontext ( ) . hasdependency ( str_ , null ) ) { return str_ ; } if ( cls . isclassincompileclasspath ( bool_ , str_ ) ) { return str_ ; } if ( getcontext ( ) . hasplugin ( null , springbootconfigurationhelper . spring_boot_maven_plugin_artifact_id ) || cls . isclassincompileclasspath ( bool_ , str_ ) ) { return str_ ; } if ( cls . isclassincompileclasspath ( bool_ , str_ ) ) { return str_ ; } if ( cls . isclassincompileclasspath ( bool_ , str_ , str_ ) ) { return str_ ; } if ( getcontext ( ) . hasplugin ( str_ , str_ ) || getcontext ( ) . hasdependency ( str_ , null ) ) { return str_ ; } if ( getcontext ( ) . hasplugin ( str_ , str_ ) || getcontext ( ) . hasdependency ( str_ , null ) ) {	Lets use the project and its classpath to try figure out what default icon to use.
private void copyappconfigfiles ( file appbuilddir , file appconfigdir ) throws ioexception { file [ ] files = appconfigdir . listfiles ( ) ; if ( files != null ) { appbuilddir . mkdirs ( ) ; for ( file file : files ) { file outfile = new file ( appbuilddir , file . getname ( ) ) ; if ( file . isdirectory ( ) ) { copyappconfigfiles ( outfile , file ) ; } else { files . copy ( file , outfile ) ; } } } }	Copies any local configuration files into the app directory.
protected static properties getpropertiesresource ( url resource ) { properties answer = new properties ( ) ; if ( resource != null ) { try ( inputstream stream = resource . openstream ( ) ) { answer . load ( stream ) ; } catch ( ioexception e ) { throw new illegalstateexception ( str_ + resource , e ) ; } } return answer ; }	Returns the given properties resource on the project classpath if found or an empty properties object if not.
public static optional < string > getspringbootversion ( mavenproject mavenproject ) { return optional . ofnullable ( mavenutil . getdependencyversion ( mavenproject , springbootconfigurationhelper . spring_boot_group_id , springbootconfigurationhelper . spring_boot_artifact_id ) ) ; }	Determine the spring-boot major version for the current project.
private void enrich ( platformmode platformmode , final processorconfig enricherconfig , final kuberneteslistbuilder builder , final list < enricher > enricherlist ) { loop ( enricherconfig , enricher -> { enricher . enrich ( platformmode , builder ) ; return null ; } ) ; }	Allow enricher to add Metadata to the resources.
public map < string , string > getrawconfig ( ) { return configuration . getprocessorconfig ( ) . orelse ( processorconfig . empty ) . getconfigmap ( name ) ; }	Get the raw, untyped configuration or an empty map.
private static map < string , object > getflattenedmap ( map < string , object > source ) { map < string , object > result = new linkedhashmap < > ( ) ; buildflattenedmap ( result , source , null ) ; return result ; }	Build a flattened representation of the Yaml tree.
protected static template getsingletontemplate ( kuberneteslist resources ) {	Returns the Template if the list contains a single Template only otherwise returns null.
private date getbuildreferencedate ( ) throws mojoexecutionexception {	get a reference date.
public string get ( configs . key key , string defaultval ) { string keyval = key != null ? key . name ( ) : str_ ; string val = config != null ? config . getconfig ( name , key . name ( ) ) : null ; if ( val == null ) { string fullkey = generator_prop_prefix + str_ + name + str_ + key ; val = configs . getsystempropertywithmavenpropertyasfallback ( properties , fullkey ) ; } return val != null ? val : defaultval ; }	Get a config value with a default.
public map < string , string > getconfigmap ( string name ) { return config . containskey ( name ) ? collections . unmodifiablemap ( config . get ( name ) ) : collections . < string , string > emptymap ( ) ; }	Return full configuration as raw string-string values.
public < t extends named > list < t > prepareprocessors ( list < t > namedlist , string type ) { list < t > ret = new arraylist < > ( ) ; map < string , t > lookup = new hashmap < > ( ) ; for ( t named : namedlist ) { lookup . put ( named . getname ( ) , named ) ; } for ( string inc : includes ) { if ( use ( inc ) ) { t named = lookup . get ( inc ) ; if ( named == null ) { list < string > keys = new arraylist < > ( lookup . keyset ( ) ) ; collections . sort ( keys ) ; throw new illegalargumentexception ( str_ + type + str_ + inc + str_ + str_ + type + str_ + stringutils . join ( keys , str_ ) ) ; } ret . add ( named ) ; } } return ret ; }	Order elements according to the order provided by the include statements.If no includes has been configured, return the given list unaltered.Otherwise arrange the elements from the list in to the include order and return a newlist.If an include specifies an element which does not exist, an exception is thrown.
protected void addfrom ( buildimageconfiguration . builder builder ) { string frommode = getconfigwithfallback ( config . frommode , str_ , getfrommodedefault ( context . getruntimemode ( ) ) ) ; string from = getconfigwithfallback ( config . from , str_ , null ) ; if ( str_ . equalsignorecase ( frommode ) ) { string fromimage = from ; if ( fromimage == null ) { fromimage = fromselector != null ? fromselector . getfrom ( ) : null ; } builder . from ( fromimage ) ; log . info ( str_ , fromimage ) ; } else if ( str_ . equalsignorecase ( frommode ) ) { map < string , string > fromext = new hashmap < > ( ) ; if ( from != null ) { imagename iname = new imagename ( from ) ;	Add the base image either from configuration or from a given selector.
private string getfrommodedefault ( runtimemode mode ) { if ( mode == runtimemode . openshift && fromselector != null && fromselector . isredhat ( ) ) { return str_ ; } else { return str_ ; } }	Use "istag" as default for "redhat" versions of this plugin.
protected string getimagename ( ) { if ( runtimemode . isopenshiftmode ( getproject ( ) . getproperties ( ) ) ) { return getconfigwithfallback ( config . name , str_ , str_ ) ; } else { return getconfigwithfallback ( config . name , str_ , str_ ) ; } }	Get Image name with a standard default.
protected string getregistry ( ) { if ( ! runtimemode . isopenshiftmode ( getproject ( ) . getproperties ( ) ) ) { return getconfigwithfallback ( config . registry , str_ , null ) ; } return null ; }	Get the docker registry where the image should be located.It returns null in Openshift mode.
boolean isonline ( ) { string isonline = getconfig ( config . online ) ; if ( isonline != null ) { return configs . asboolean ( isonline ) ; } boolean ret = asbooleanfromglobalprop ( str_ ) ; return ret != null ? ret : getdefaultonline ( ) ; }	Returns true if in offline mode, "false" if not speciied.Can be overriden by.
protected string getexternalserviceurl ( string servicename , string protocol ) { if ( ! isonline ( ) ) { getlog ( ) . info ( str_ + servicename + str_ ) ; return null ; } else { try { kubernetesclient kubernetes = getkubernetes ( ) ; string ns = kubernetes . getnamespace ( ) ; if ( stringutils . isblank ( ns ) ) { ns = getnamespace ( ) ; } service service = kubernetes . services ( ) . innamespace ( ns ) . withname ( servicename ) . get ( ) ; return service != null ? serviceurlutil . getserviceurl ( kubernetes , servicename , ns , protocol , bool_ ) : null ; } catch ( throwable e ) { throwable cause = e ; boolean notfound = bool_ ; boolean connecterror = bool_ ; stack < throwable > stack = unfoldexceptions ( e ) ; while ( ! stack . isempty ( ) ) { throwable t = stack . pop ( ) ; if ( t instanceof connectexception || str_ . equals ( t . getmessage ( ) ) ) { getlog ( ) . warn ( str_ , servicename , cause . getmessage ( ) ) ; return null ; } else if ( t instanceof illegalargumentexception || t . getmessage ( ) != null && t . getmessage ( ) . matches ( str_ ) ) { getlog ( ) . warn ( str_ , cause . getmessage ( ) ) ; return null ; } ; } getlog ( ) . warn ( str_ , servicename , cause . getmessage ( ) ) ; return null ; } } }	Returns the external access to the given service name.
protected boolean asbooleanfromglobalprop ( string prop ) { string value = getcontext ( ) . getconfiguration ( ) . getproperty ( prop ) ; if ( value == null ) { value = system . getproperty ( prop ) ; } return value != null ? boolean . valueof ( value ) : null ; }	Check a global prop from the project or system props.
private jestclient createjestclient ( string uri ) { httpclientconfig . builder builder = new httpclientconfig . builder ( uri ) . maxtotalconnection ( properties . getmaxtotalconnection ( ) ) . defaultmaxtotalconnectionperroute ( properties . getdefaultmaxtotalconnectionperroute ( ) ) . maxconnectionidletime ( properties . getmaxconnectionidletime ( ) , timeunit . milliseconds ) . readtimeout ( properties . getreadtimeout ( ) ) . multithreaded ( properties . getmultithreaded ( ) ) ; if ( stringutils . hastext ( this . properties . getusername ( ) ) ) { builder . defaultcredentials ( this . properties . getusername ( ) , this . properties . getpassword ( ) ) ; } string proxyhost = this . properties . getproxy ( ) . gethost ( ) ; if ( stringutils . hastext ( proxyhost ) ) { integer proxyport = this . properties . getproxy ( ) . getport ( ) ; assert . notnull ( proxyport , str_ ) ; builder . proxy ( new httphost ( proxyhost , proxyport ) ) ; } list < httpclientconfigbuildercustomizer > configbuildercustomizers = buildercustomizers != null ? buildercustomizers . getifavailable ( ) : new arraylist < > ( ) ; if ( ! collectionutils . isempty ( configbuildercustomizers ) ) { logger . info ( str_ ) ; configbuildercustomizers . stream ( ) . foreach ( customizer -> customizer . customize ( builder ) ) ; logger . info ( str_ ) ; } jestclientfactory factory = jestclientfactory != null ? jestclientfactory : new jestclientfactory ( ) ; factory . sethttpclientconfig ( builder . build ( ) ) ; return factory . getobject ( ) ; }	Create Jest client with URI.
private int createinternalnode ( ) throws nodevalidationexception { if ( logger . isinfoenabled ( ) ) { logger . info ( str_ ) ; } int port = socketutils . findavailabletcpport ( ) ; string clustername = internal_test_cluster_name + uuid . randomuuid ( ) ; settings . builder settingsbuilder = settings . builder ( ) . put ( str_ , clustername ) . put ( str_ , str_ ) . put ( str_ , string . valueof ( port ) ) ; if ( this . esnodeproperties != null ) { this . esnodeproperties . getproperties ( ) . foreach ( settingsbuilder :: put ) ; } collection < class < ? extends plugin > > plugins = scanplugins ( ) ; plugins . add ( netty4plugin . class ) ; this . node = new internalnode ( settingsbuilder . build ( ) , plugins ) . start ( ) ; return integer . parseint ( settingsbuilder . get ( str_ ) ) ; }	Create internal Elasticsearch node.
@ suppresswarnings ( str_ ) private static collection < class < ? extends plugin > > scanplugins ( ) { classpathscanningcandidatecomponentprovider componentprovider = new classpathscanningcandidatecomponentprovider ( bool_ ) ; componentprovider . addincludefilter ( new assignabletypefilter ( plugin . class ) ) ; return componentprovider . findcandidatecomponents ( str_ ) . stream ( ) . map ( beandefinition :: getbeanclassname ) . map ( name -> { try { return ( class < ? extends plugin > ) class . forname ( name ) ; } catch ( classnotfoundexception e ) { logger . warn ( str_ , e ) ; return null ; } } ) . collect ( collectors . toset ( ) ) ; }	List all official ES plugins available on ClassPath.
public static americanexpressrewardsbalance fromjson ( string jsonstring ) throws jsonexception { jsonobject json = new jsonobject ( jsonstring ) ; americanexpressrewardsbalance rewardsbalance = new americanexpressrewardsbalance ( ) ; if ( json . has ( error_key ) ) { jsonobject errorjson = json . getjsonobject ( error_key ) ; rewardsbalance . merrormessage = errorjson . getstring ( error_message_key ) ; rewardsbalance . merrorcode = errorjson . getstring ( error_code_key ) ; } rewardsbalance . mconversionrate = json . optstring ( json , conversion_rate_key , null ) ; rewardsbalance . mcurrencyamount = json . optstring ( json , currency_amount_key , null ) ; rewardsbalance . mcurrencyisocode = json . optstring ( json , currency_iso_code_key , null ) ; rewardsbalance . mrequestid = json . optstring ( json , request_id_key , null ) ; rewardsbalance . mrewardsamount = json . optstring ( json , rewards_amount_key , null ) ; rewardsbalance . mrewardsunit = json . optstring ( json , rewards_unit_key , null ) ; return rewardsbalance ; }	Used to parse a response from the Braintree Gateway to be used for American Express rewards balance.
public static void getrewardsbalance ( final braintreefragment fragment , final string nonce , final string currencyisocode ) { fragment . waitforconfiguration ( new configurationlistener ( ) { @ override public void onconfigurationfetched ( configuration configuration ) { string getrewardsbalanceurl = uri . parse ( amex_rewards_balance_path ) . buildupon ( ) . appendqueryparameter ( str_ , nonce ) . appendqueryparameter ( str_ , currencyisocode ) . build ( ) . tostring ( ) ; fragment . sendanalyticsevent ( str_ ) ; fragment . gethttpclient ( ) . get ( getrewardsbalanceurl , new httpresponsecallback ( ) { @ override public void success ( string responsebody ) { fragment . sendanalyticsevent ( str_ ) ; try { fragment . postamericanexpresscallback ( americanexpressrewardsbalance . fromjson ( responsebody ) ) ; } catch ( jsonexception e ) { fragment . sendanalyticsevent ( str_ ) ; fragment . postcallback ( e ) ; } } @ override public void failure ( exception exception ) { fragment . postcallback ( exception ) ; fragment . sendanalyticsevent ( str_ ) ; } } ) ; } } ) ; }	Gets the rewards balance associated with a Braintree nonce.
public static paypalpaymentresource fromjson ( string jsonstring ) throws jsonexception { jsonobject json = new jsonobject ( jsonstring ) ; paypalpaymentresource paypalpaymentresource = new paypalpaymentresource ( ) ; jsonobject redirectjson = json . optjsonobject ( payment_resource_key ) ; if ( redirectjson != null ) { paypalpaymentresource . redirecturl ( json . optstring ( redirectjson , redirect_url_key , str_ ) ) ; } else { redirectjson = json . optjsonobject ( agreement_setup_key ) ; paypalpaymentresource . redirecturl ( json . optstring ( redirectjson , approval_url_key , str_ ) ) ; } return paypalpaymentresource ; }	Create a PayPalPaymentResource from a jsonString.
@ override public void get ( string path , httpresponsecallback callback ) { if ( path == null ) { postcallbackonmainthread ( callback , new illegalargumentexception ( str_ ) ) ; return ; } uri uri ; if ( path . startswith ( str_ ) ) { uri = uri . parse ( path ) ; } else { uri = uri . parse ( mbaseurl + path ) ; } if ( mauthorization instanceof clienttoken ) { uri = uri . buildupon ( ) . appendqueryparameter ( authorization_fingerprint_key , ( ( clienttoken ) mauthorization ) . getauthorizationfingerprint ( ) ) . build ( ) ; } super . get ( uri . tostring ( ) , callback ) ; }	Make a HTTP GET request to Braintree using the base url, path and authorization provided.If the path is a full url, it will be used instead of the previously provided url.
@ override public void post ( string path , string data , httpresponsecallback callback ) { try { if ( mauthorization instanceof clienttoken ) { data = new jsonobject ( data ) . put ( authorization_fingerprint_key , ( ( clienttoken ) mauthorization ) . getauthorizationfingerprint ( ) ) . tostring ( ) ; } super . post ( path , data , callback ) ; } catch ( jsonexception e ) { postcallbackonmainthread ( callback , e ) ; } }	Make a HTTP POST request to Braintree using the base url, path and authorization provided.If the path is a full url, it will be used instead of the previously provided url.
static venmoconfiguration fromjson ( jsonobject json ) { if ( json == null ) { json = new jsonobject ( ) ; } venmoconfiguration venmoconfiguration = new venmoconfiguration ( ) ; venmoconfiguration . maccesstoken = json . optstring ( json , access_token_key , str_ ) ; venmoconfiguration . menvironment = json . optstring ( json , environment_key , str_ ) ; venmoconfiguration . mmerchantid = json . optstring ( json , merchant_id_key , str_ ) ; return venmoconfiguration ; }	Parses the Venmo configuration from json.
public static void collectdevicedata ( braintreefragment fragment , braintreeresponselistener < string > listener ) { collectdevicedata ( fragment , null , listener ) ; }	Collect device information for fraud identification purposes.
public static void collectdevicedata ( final braintreefragment fragment , final string merchantid , final braintreeresponselistener < string > listener ) { fragment . waitforconfiguration ( new configurationlistener ( ) { @ override public void onconfigurationfetched ( configuration configuration ) { final jsonobject devicedata = new jsonobject ( ) ; try { string clientmetadataid = getpaypalclientmetadataid ( fragment . getapplicationcontext ( ) ) ; if ( ! textutils . isempty ( clientmetadataid ) ) { devicedata . put ( correlation_id_key , clientmetadataid ) ; } } catch ( jsonexception ignored ) { } if ( configuration . getkount ( ) . isenabled ( ) ) { final string id ; if ( merchantid != null ) { id = merchantid ; } else { id = configuration . getkount ( ) . getkountmerchantid ( ) ; } try { final string devicesessionid = uuidhelper . getformatteduuid ( ) ; startdevicecollector ( fragment , id , devicesessionid , new braintreeresponselistener < string > ( ) { @ override public void onresponse ( string sessionid ) { try { devicedata . put ( device_session_id_key , devicesessionid ) ; devicedata . put ( fraud_merchant_id_key , id ) ; } catch ( jsonexception ignored ) { } listener . onresponse ( devicedata . tostring ( ) ) ; } } ) ; } catch ( classnotfoundexception | noclassdeffounderror | numberformatexception ignored ) { listener . onresponse ( devicedata . tostring ( ) ) ; } } else { listener . onresponse ( devicedata . tostring ( ) ) ; } } } ) ; }	Collect device information for fraud identification purposes.
public static void collectpaypaldevicedata ( final braintreefragment fragment , final braintreeresponselistener < string > listener ) { final jsonobject devicedata = new jsonobject ( ) ; try { string clientmetadataid = getpaypalclientmetadataid ( fragment . getapplicationcontext ( ) ) ; if ( ! textutils . isempty ( clientmetadataid ) ) { devicedata . put ( correlation_id_key , clientmetadataid ) ; } } catch ( jsonexception ignored ) { } listener . onresponse ( devicedata . tostring ( ) ) ; }	Collect PayPal device information for fraud identification purposes.
public static string getpaypalclientmetadataid ( context context ) { try { return paypalonetouchcore . getclientmetadataid ( context ) ; } catch ( noclassdeffounderror ignored ) { } try { return paypaldatacollector . getclientmetadataid ( context ) ; } catch ( noclassdeffounderror ignored ) { } return str_ ; }	Collect device information for fraud identification purposes from PayPal only.
@ suppresslint ( str_ ) public static boolean issignaturevalid ( context context , string packagename , string certificatesubject , string certificateissuer , int publickeyhashcode ) { if ( ! senablesignatureverification ) { return bool_ ; } packagemanager packagemanager = context . getpackagemanager ( ) ; signature [ ] signatures ; try { signatures = packagemanager . getpackageinfo ( packagename , packagemanager . get_signatures ) . signatures ; } catch ( namenotfoundexception e ) { return bool_ ; } inputstream certstream = null ; boolean validated = ( signatures . length != num_ ) ; for ( signature signature : signatures ) { try { certstream = new bytearrayinputstream ( signature . tobytearray ( ) ) ; x509certificate x509cert = ( x509certificate ) certificatefactory . getinstance ( str_ ) . generatecertificate ( certstream ) ; string subject = x509cert . getsubjectx500principal ( ) . getname ( ) ; string issuer = x509cert . getissuerx500principal ( ) . getname ( ) ; int actualpublickeyhashcode = x509cert . getpublickey ( ) . hashcode ( ) ; validated &= ( certificatesubject . equals ( subject ) && certificateissuer . equals ( issuer ) && publickeyhashcode == actualpublickeyhashcode ) ; if ( ! validated ) { return bool_ ; } } catch ( certificateexception e ) { return bool_ ; } finally { try { if ( certstream != null ) { certstream . close ( ) ; } } catch ( ioexception ignored ) { } } } return validated ; }	Check if an app has the correct, matching, signature.
public static string optstring ( jsonobject json , string name , string fallback ) { if ( json . isnull ( name ) ) { return fallback ; } else { return json . optstring ( name , fallback ) ; } }	Returns the value mapped by name if it exists, coercing it if necessary, or fallback if no such mapping exists.This is a work around for http://code.google.com/p/android/issues/detail?id=13830 returning "null" if the jsonvalue is null.
public static list < paymentmethodnonce > parsepaymentmethodnonces ( string jsonbody ) throws jsonexception { jsonarray paymentmethods = new jsonobject ( jsonbody ) . getjsonarray ( payment_method_nonce_collection_key ) ; if ( paymentmethods == null ) { return collections . emptylist ( ) ; } list < paymentmethodnonce > paymentmethodsnonces = new arraylist < > ( ) ; jsonobject json ; paymentmethodnonce paymentmethodnonce ; for ( int i = num_ ; i < paymentmethods . length ( ) ; i ++ ) { json = paymentmethods . getjsonobject ( i ) ; paymentmethodnonce = parsepaymentmethodnonces ( json , json . getstring ( payment_method_type_key ) ) ; if ( paymentmethodnonce != null ) { paymentmethodsnonces . add ( paymentmethodnonce ) ; } } return paymentmethodsnonces ; }	Parses a response from the Braintree gateway for a list of payment method nonces.
public checkoutrecipe getbrowsercheckoutconfig ( ) { for ( checkoutrecipe recipe : mcheckoutrecipesindecreasingpriorityorder ) { if ( recipe . gettarget ( ) == requesttarget . browser ) { return recipe ; } } return null ; }	Returns the browser recipe that can handle checkout, or null if there is none.
public billingagreementrecipe getbrowserbillingagreementconfig ( ) { for ( billingagreementrecipe recipe : mbillingagreementrecipesindecreasingpriorityorder ) { if ( recipe . gettarget ( ) == requesttarget . browser ) { return recipe ; } } return null ; }	Returns the browser recipe that can handle billing agreement, or null if there is none.
public void get ( final string path , final httpresponsecallback callback ) { if ( path == null ) { postcallbackonmainthread ( callback , new illegalargumentexception ( str_ ) ) ; return ; } final string url ; if ( path . startswith ( str_ ) ) { url = path ; } else { url = mbaseurl + path ; } mthreadpool . submit ( new runnable ( ) { @ override public void run ( ) { httpurlconnection connection = null ; try { connection = init ( url ) ; connection . setrequestmethod ( method_get ) ; postcallbackonmainthread ( callback , parseresponse ( connection ) ) ; } catch ( exception e ) { postcallbackonmainthread ( callback , e ) ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } } } ) ; }	Make a HTTP GET request to using the base url and path provided.
public void post ( final string path , final string data , final httpresponsecallback callback ) { if ( path == null ) { postcallbackonmainthread ( callback , new illegalargumentexception ( str_ ) ) ; return ; } mthreadpool . submit ( new runnable ( ) { @ override public void run ( ) { try { postcallbackonmainthread ( callback , post ( path , data ) ) ; } catch ( exception e ) { postcallbackonmainthread ( callback , e ) ; } } } ) ; }	Make a HTTP POST request using the base url and path provided.
public string post ( string path , string data ) throws exception { httpurlconnection connection = null ; try { if ( path . startswith ( str_ ) ) { connection = init ( path ) ; } else { connection = init ( mbaseurl + path ) ; } connection . setrequestproperty ( str_ , str_ ) ; connection . setrequestmethod ( method_post ) ; connection . setdooutput ( bool_ ) ; writeoutputstream ( connection . getoutputstream ( ) , data ) ; return parseresponse ( connection ) ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } }	Performs a synchronous post request.
public static void approvepayment ( braintreefragment fragment , localpaymentrequest request ) { fragment . browserswitch ( braintreerequestcodes . local_payment , request . getapprovalurl ( ) ) ; fragment . sendanalyticsevent ( paymenttypeforanalytics ( ) + str_ ) ; }	Initiates the browser switch for a payment flow by opening a browser where the customer can authenticate with their bank.
public < t extends braintreelistener > void addlistener ( t listener ) { if ( listener instanceof configurationlistener ) { mconfigurationlistener = ( configurationlistener ) listener ; } if ( listener instanceof braintreecancellistener ) { mcancellistener = ( braintreecancellistener ) listener ; } if ( listener instanceof paymentmethodnoncesupdatedlistener ) { mpaymentmethodnoncesupdatedlistener = ( paymentmethodnoncesupdatedlistener ) listener ; } if ( listener instanceof paymentmethodnoncecreatedlistener ) { mpaymentmethodnoncecreatedlistener = ( paymentmethodnoncecreatedlistener ) listener ; } if ( listener instanceof paymentmethodnoncedeletedlistener ) { mpaymentmethodnoncedeletedlistener = ( paymentmethodnoncedeletedlistener ) listener ; } if ( listener instanceof braintreepaymentresultlistener ) { mbraintreepaymentresultlistener = ( braintreepaymentresultlistener ) listener ; } if ( listener instanceof braintreeerrorlistener ) { merrorlistener = ( braintreeerrorlistener ) listener ; } if ( listener instanceof unionpaylistener ) { munionpaylistener = ( unionpaylistener ) listener ; } if ( listener instanceof americanexpresslistener ) { mamericanexpresslistener = ( americanexpresslistener ) listener ; } flushcallbacks ( ) ; }	Adds a listener.
public < t extends braintreelistener > void removelistener ( t listener ) { if ( listener instanceof configurationlistener ) { mconfigurationlistener = null ; } if ( listener instanceof braintreecancellistener ) { mcancellistener = null ; } if ( listener instanceof paymentmethodnoncesupdatedlistener ) { mpaymentmethodnoncesupdatedlistener = null ; } if ( listener instanceof paymentmethodnoncecreatedlistener ) { mpaymentmethodnoncecreatedlistener = null ; } if ( listener instanceof paymentmethodnoncedeletedlistener ) { mpaymentmethodnoncedeletedlistener = null ; } if ( listener instanceof braintreepaymentresultlistener ) { mbraintreepaymentresultlistener = null ; } if ( listener instanceof braintreeerrorlistener ) { merrorlistener = null ; } if ( listener instanceof unionpaylistener ) { munionpaylistener = null ; } if ( listener instanceof americanexpresslistener ) { mamericanexpresslistener = null ; } }	Removes a previously added listener.
public static void requestbillingagreement ( braintreefragment fragment , paypalrequest request , paypalapprovalhandler handler ) { if ( request . getamount ( ) == null ) { fragment . sendanalyticsevent ( str_ ) ; if ( request . shouldoffercredit ( ) ) { fragment . sendanalyticsevent ( str_ ) ; } requestonetimepayment ( fragment , request , bool_ , handler ) ; } else { fragment . postcallback ( new braintreeexception ( str_ ) ) ; } }	Starts the Billing Agreement flow for PayPal with custom PayPal approval handler.
protected static void onactivityresult ( final braintreefragment fragment , int resultcode , intent data ) { request request = getpersistedrequest ( fragment . getapplicationcontext ( ) ) ; string paymenttype = paymenttypeforrequest ( request ) ; string switchtype = switchtypeforintent ( data ) ; string eventprefix = paymenttype + str_ + switchtype ; if ( resultcode == appcompatactivity . result_ok && data != null && request != null ) { result result = paypalonetouchcore . parseresponse ( fragment . getapplicationcontext ( ) , request , data ) ; switch ( result . getresulttype ( ) ) { case error : fragment . postcallback ( new browserswitchexception ( result . geterror ( ) . getmessage ( ) ) ) ; fragment . sendanalyticsevent ( eventprefix + str_ ) ; break ; case cancel : fragment . postcancelcallback ( braintreerequestcodes . paypal ) ; fragment . sendanalyticsevent ( eventprefix + str_ ) ; break ; case success : onsuccess ( fragment , data , request , result ) ; fragment . sendanalyticsevent ( eventprefix + str_ ) ; break ; } } else { fragment . sendanalyticsevent ( eventprefix + str_ ) ; if ( resultcode != appcompatactivity . result_canceled ) { fragment . postcancelcallback ( braintreerequestcodes . paypal ) ; } } }	The result from PayPal's request.
private static paypalaccountbuilder parseresponse ( paypalrequest paypalrequest , request request , result result , intent intent ) { paypalaccountbuilder paypalaccountbuilder = new paypalaccountbuilder ( ) . clientmetadataid ( request . getclientmetadataid ( ) ) ; if ( paypalrequest != null && paypalrequest . getmerchantaccountid ( ) != null ) { paypalaccountbuilder . merchantaccountid ( paypalrequest . getmerchantaccountid ( ) ) ; } if ( request instanceof checkoutrequest && paypalrequest != null ) { paypalaccountbuilder . intent ( paypalrequest . getintent ( ) ) ; } if ( isappswitch ( intent ) ) { paypalaccountbuilder . source ( str_ ) ; } else { paypalaccountbuilder . source ( str_ ) ; } paypalaccountbuilder . onetouchcoredata ( result . getresponse ( ) ) ; return paypalaccountbuilder ; }	Parse the PayPal response URL using OneTouchCore.
public static void addnounstodictionary ( list < string > words ) { openkoreantextprocessor . addnounstodictionary ( javaconverters . asscalabufferconverter ( words ) . asscala ( ) ) ; }	Add user-defined words to the noun dictionary.
public static void removewordfromdictionary ( koreanposjava pos , list < string > words ) { openkoreantextprocessor . removewordsfromdictionary ( koreanpos . withname ( pos . tostring ( ) ) , javaconverters . asscalabufferconverter ( words ) . asscala ( ) ) ; }	Remove user-defined word List from the dictionary for the specified KoreanPos.
public static list < string > tokenstojavastringlist ( seq < koreantoken > tokens , boolean keepspace ) { iterator < koreantoken > tokenized = tokens . iterator ( ) ; list < string > output = new linkedlist < > ( ) ; while ( tokenized . hasnext ( ) ) { final koreantoken token = tokenized . next ( ) ; if ( keepspace || token . pos ( ) != koreanpos . space ( ) ) { output . add ( token . text ( ) ) ; } } return output ; }	Tokenize with the builder options into a String Iterable.
public static list < koreanphraseextractor . koreanphrase > extractphrases ( seq < koreantoken > tokens , boolean filterspam , boolean includehashtags ) { seq < koreanphraseextractor . koreanphrase > seq = openkoreantextprocessor . extractphrases ( tokens , filterspam , includehashtags ) ; return tojavalist ( seq ) ; }	Extract phrases from Korean input text.
public static string detokenize ( list < string > tokens ) { return openkoreantextprocessor . detokenize ( javaconverters . asscalabufferconverter ( tokens ) . asscala ( ) ) ; }	Detokenize the input list of words.
public static bytebuffer fetchfrom ( bytebuffer buf , readablebytechannel ch , int size ) throws ioexception { bytebuffer result = buf . duplicate ( ) ; result . limit ( size ) ; nioutils . readfromchannel ( ch , result ) ; result . flip ( ) ; return result ; }	Reads size amount of bytes from ch into a new ByteBuffer allocated from abuffer buf.
public static bytebuffer joinnalunits ( list < bytebuffer > nalunits ) { int size = num_ ; for ( bytebuffer nal : nalunits ) { size += num_ + nal . remaining ( ) ; } bytebuffer allocate = bytebuffer . allocate ( size ) ; joinnalunitstobuffer ( nalunits , allocate ) ; return allocate ; }	Joins buffers containing individual NAL units into a single AnnexBdelimited buffer.
public static void joinnalunitstobuffer ( list < bytebuffer > nalunits , bytebuffer out ) { for ( bytebuffer nal : nalunits ) { out . putint ( num_ ) ; out . put ( nal . duplicate ( ) ) ; } }	Joins buffers containing individual NAL units into a single AnnexBdelimited buffer.
public static profile forint ( int i ) { profile p ; if ( i <= num_ || i > all . length ) p = unknown ; else p = all [ i - num_ ] ; return p ; }	Returns a profile instance for the given index.
public static void normalizeandgeneratefixedprecision ( double [ ] taps , int precbits , short [ ] out ) { double sum = num_ ; for ( int i = num_ ; i < taps . length ; i ++ ) { sum += taps [ i ] ; } int sumfix = num_ ; int precnum = num_ << precbits ; for ( int i = num_ ; i < taps . length ; i ++ ) { double d = ( taps [ i ] * precnum ) / sum + precnum ; int s = ( int ) d ; taps [ i ] = d - s ; out [ i ] = ( short ) ( s - precnum ) ; sumfix += out [ i ] ; } long tapstaken = num_ ; while ( sumfix < precnum ) { int maxi = - num_ ; for ( int i = num_ ; i < taps . length ; i ++ ) { if ( ( tapstaken & ( num_ << i ) ) == num_ && ( maxi == - num_ || taps [ i ] > taps [ maxi ] ) ) maxi = i ; } out [ maxi ] ++ ; sumfix ++ ; tapstaken |= ( num_ << maxi ) ; } for ( int i = num_ ; i < taps . length ; i ++ ) { taps [ i ] += out [ i ] ; if ( ( tapstaken & ( num_ << i ) ) != num_ ) taps [ i ] -= num_ ; } }	Converts floating point taps to fixed precision taps.
public final state readtonextmarkerpartial ( bytebuffer out ) throws ioexception { if ( done ) return state . stop ; int skiponemarker = curmarker >= num_ && curmarker <= num_ ? num_ : num_ ; int written = out . position ( ) ; do { while ( buf . hasremaining ( ) ) { if ( curmarker >= num_ && curmarker <= num_ ) { if ( skiponemarker == num_ ) { return state . done ; } -- skiponemarker ; } if ( ! out . hasremaining ( ) ) return state . more_data ; out . put ( ( byte ) ( curmarker > > > num_ ) ) ; curmarker = ( curmarker << num_ ) | ( buf . get ( ) & num_ ) ; } buf = nioutils . fetchfromchannel ( channel , fetchsize ) ; pos += buf . remaining ( ) ; } while ( buf . hasremaining ( ) ) ; written = out . position ( ) - written ; if ( written > num_ && curmarker >= num_ && curmarker <= num_ ) return state . done ; for ( ; bytesinmarker > num_ && out . hasremaining ( ) ; ) { out . put ( ( byte ) ( curmarker > > > num_ ) ) ; curmarker = ( curmarker << num_ ) ; -- bytesinmarker ; if ( curmarker >= num_ && curmarker <= num_ ) return state . done ; } if ( bytesinmarker == num_ ) { done = bool_ ; return state . stop ; } else { return state . more_data ; } }	Reads one full segment till the next marker.
public bytebuffer readtonextmarkernewbuffer ( ) throws ioexception { if ( done ) return null ; list < bytebuffer > buffers = new arraylist < bytebuffer > ( ) ; readtonextmarkerbuffers ( buffers ) ; return nioutils . combinebuffers ( buffers ) ; }	Reads one full segment till the next marker.
public int getmaxavailableframe ( ) { if ( maxavailableframe == - num_ ) { int firstpoint = num_ ; for ( int i = max_max ; i > num_ ; i /= num_ ) { if ( new file ( string . format ( namepattern , i ) ) . exists ( ) ) { firstpoint = i ; break ; } } int pos = firstpoint ; for ( int interv = firstpoint / num_ ; interv > num_ ; interv /= num_ ) { if ( new file ( string . format ( namepattern , pos + interv ) ) . exists ( ) ) { pos += interv ; } } maxavailableframe = pos ; logger . info ( str_ + maxavailableframe ) ; } return math . min ( maxavailableframe , maxframes ) ; }	Finds maximum frame of a sequence by bisecting the range.Performs at max at max 48 Stat calls ( 2*log2(MAX_MAX) ).
public boolean modify ( file file , mp4edit edit ) throws ioexception { seekablebytechannel fi = null ; try { fi = nioutils . rwchannel ( file ) ; list < tuple . _2 < atom , bytebuffer > > fragments = dothefix ( fi , edit ) ; if ( fragments == null ) return bool_ ;	Tries to modify movie header in place according to what's implemented inthe edit, the file gets pysically modified if the operation issuccessful.
public static long geteditedduration ( trakbox track ) { list < edit > edits = track . getedits ( ) ; if ( edits == null ) return track . getduration ( ) ; long duration = num_ ; for ( edit edit : edits ) { duration += edit . getduration ( ) ; } return duration ; }	Calculates track duration considering edits.
public static long frametotimevalue ( trakbox trak , int framenumber ) { timetosamplebox stts = nodebox . findfirstpath ( trak , timetosamplebox . class , box . path ( str_ ) ) ; timetosampleentry [ ] timetosamples = stts . getentries ( ) ; long pts = num_ ; int sttsind = num_ , sttssubind = framenumber ; while ( sttssubind >= timetosamples [ sttsind ] . getsamplecount ( ) ) { sttssubind -= timetosamples [ sttsind ] . getsamplecount ( ) ; pts += timetosamples [ sttsind ] . getsamplecount ( ) * timetosamples [ sttsind ] . getsampleduration ( ) ; sttsind ++ ; } return pts + timetosamples [ sttsind ] . getsampleduration ( ) * sttssubind ; }	Finds timevalue of a frame numbermight be an expensive operation sinse it traverses compressed time tosample table.
public static int timevaluetoframe ( trakbox trak , long tv ) { timetosampleentry [ ] tts = nodebox . findfirstpath ( trak , timetosamplebox . class , box . path ( str_ ) ) . getentries ( ) ; int frame = num_ ; for ( int i = num_ ; tv > num_ && i < tts . length ; i ++ ) { long rem = tv / tts [ i ] . getsampleduration ( ) ; tv -= tts [ i ] . getsamplecount ( ) * tts [ i ] . getsampleduration ( ) ; frame += tv > num_ ? tts [ i ] . getsamplecount ( ) : rem ; } return frame ; }	Finds frame by timevalue.
public static long mediatoedited ( trakbox trak , long mediatv , int movietimescale ) { if ( trak . getedits ( ) == null ) return mediatv ; long accum = num_ ; for ( edit edit : trak . getedits ( ) ) { if ( mediatv < edit . getmediatime ( ) ) return accum ; long duration = trak . rescale ( edit . getduration ( ) , movietimescale ) ; if ( edit . getmediatime ( ) != - num_ && ( mediatv >= edit . getmediatime ( ) && mediatv < edit . getmediatime ( ) + duration ) ) { accum += mediatv - edit . getmediatime ( ) ; break ; } accum += duration ; } return accum ; }	Converts media timevalue to edited timevalue.
public static long editedtomedia ( trakbox trak , long editedtv , int movietimescale ) { if ( trak . getedits ( ) == null ) return editedtv ; long accum = num_ ; for ( edit edit : trak . getedits ( ) ) { long duration = trak . rescale ( edit . getduration ( ) , movietimescale ) ; if ( accum + duration > editedtv ) { return edit . getmediatime ( ) + editedtv - accum ; } accum += duration ; } return accum ; }	Converts edited timevalue to media timevalue.
public static int qtplayerframeno ( moviebox movie , int mediaframeno ) { trakbox videotrack = movie . getvideotrack ( ) ; long editedtv = mediatoedited ( videotrack , frametotimevalue ( videotrack , mediaframeno ) , movie . gettimescale ( ) ) ; return tv2qtframeno ( movie , editedtv ) ; }	Calculates frame number as it shows in quicktime player.
public static string qtplayertime ( moviebox movie , int mediaframeno ) { trakbox videotrack = movie . getvideotrack ( ) ; long editedtv = mediatoedited ( videotrack , frametotimevalue ( videotrack , mediaframeno ) , movie . gettimescale ( ) ) ; int sec = ( int ) ( editedtv / videotrack . gettimescale ( ) ) ; return string . format ( str_ , sec / num_ ) + str_ + string . format ( str_ , ( sec % num_ ) / num_ ) + str_ + string . format ( str_ , sec % num_ ) ; }	Calculates and formats standard time as in Quicktime player.
public static int timevaluetotimecodeframe ( trakbox timecodetrack , rationallarge tv , int movietimescale ) { timecodesampleentry se = ( timecodesampleentry ) timecodetrack . getsampleentries ( ) [ num_ ] ; return ( int ) ( ( num_ * tv . multiplys ( se . gettimescale ( ) ) / se . getframeduration ( ) ) + num_ ) / num_ ; }	Converts timevalue to frame number based on timecode track.
public static string formattimecode ( trakbox timecodetrack , int counter ) { timecodesampleentry tmcd = nodebox . findfirstpath ( timecodetrack , timecodesampleentry . class , box . path ( str_ ) ) ; byte nf = tmcd . getnumframes ( ) ; string tc = string . format ( str_ , counter % nf ) ; counter /= nf ; tc = string . format ( str_ , counter % num_ ) + str_ + tc ; counter /= num_ ; tc = string . format ( str_ , counter % num_ ) + str_ + tc ; counter /= num_ ; tc = string . format ( str_ , counter ) + str_ + tc ; return tc ; }	Formats tape timecode based on frame counter.
public static int _7 ( int val0 , int val1 , int val2 , int val3 , int val4 , int val5 , int val6 ) { return ( num_ << num_ ) | ( ( val0 & num_ ) << num_ ) | ( ( val1 & num_ ) << num_ ) | ( ( val2 & num_ ) << num_ ) | ( ( val3 & num_ ) << num_ ) | ( ( val4 & num_ ) << num_ ) | ( ( val5 & num_ ) << num_ ) | ( ( val6 & num_ ) ) ; }	Creates packed 4bit list with 7 values in it.
public static int set ( int list , int val , int n ) { int cnt = ( list > > num_ ) & num_ ; int newc = n + num_ ; cnt = newc > cnt ? newc : cnt ; return ( list & clear_mask [ n ] ) | ( ( val & num_ ) << ( n << num_ ) ) | ( cnt << num_ ) ; }	Sets a 4 bit value into the list.
public boolean matches ( colorspace inputcolor ) { if ( inputcolor == this ) return bool_ ; if ( inputcolor == any || this == any ) return bool_ ; if ( ( inputcolor == any_interleaved || this == any_interleaved || inputcolor == any_planar || this == any_planar ) && inputcolor . planar == this . planar ) return bool_ ; return bool_ ; }	Determines if two colors match.
public size compsize ( size size , int comp ) { if ( compwidth [ comp ] == num_ && compheight [ comp ] == num_ ) return size ; return new size ( size . getwidth ( ) > > compwidth [ comp ] , size . getheight ( ) > > compheight [ comp ] ) ; }	Calculates the component size based on the fullt size and color subsampling of the given component index.
public static mp4demuxer createrawmp4demuxer ( seekablebytechannel input ) throws ioexception { return new mp4demuxer ( input ) { @ override protected abstractmp4demuxertrack newtrack ( trakbox trak ) { return new mp4demuxertrack ( movie , trak , this . input ) ; } } ; }	does not modify packets.
protected int readcache ( boolean peek ) throws aacexception { int i ; if ( pos > buffer . length - word_bytes ) throw aacexception . endofstream ( ) ; else i = ( ( buffer [ pos ] & byte_mask ) << num_ ) | ( ( buffer [ pos + num_ ] & byte_mask ) << num_ ) | ( ( buffer [ pos + num_ ] & byte_mask ) << num_ ) | ( buffer [ pos + num_ ] & byte_mask ) ; if ( ! peek ) pos += word_bytes ; return i ; }	Reads the next four bytes.
public static wavheader createwavheader ( audioformat format , int samples ) { wavheader w = new wavheader ( str_ , num_ , str_ , new fmtchunk ( ( short ) num_ , ( short ) format . getchannels ( ) , format . getsamplerate ( ) , format . getsamplerate ( ) * format . getchannels ( ) * ( format . getsamplesizeinbits ( ) > > num_ ) , ( short ) ( format . getchannels ( ) * ( format . getsamplesizeinbits ( ) > > num_ ) ) , ( short ) format . getsamplesizeinbits ( ) ) , num_ , calcdatasize ( format . getchannels ( ) , format . getsamplesizeinbits ( ) > > num_ , samples ) ) ; return w ; }	Creates wav header for the specified audio format.
public static wavheader multichannelwav ( wavheader [ ] headers ) { wavheader w = emptywavheader ( ) ; int totalsize = num_ ; for ( int i = num_ ; i < headers . length ; i ++ ) { wavheader wavheader = headers [ i ] ; totalsize += wavheader . datasize ; } w . datasize = totalsize ; fmtchunk fmt = headers [ num_ ] . fmt ; int bitspersample = fmt . bitspersample ; int bytespersample = bitspersample / num_ ; int samplerate = ( int ) fmt . samplerate ; w . fmt . bitspersample = ( short ) bitspersample ; w . fmt . blockalign = ( short ) ( headers . length * bytespersample ) ; w . fmt . byterate = headers . length * bytespersample * samplerate ; w . fmt . numchannels = ( short ) headers . length ; w . fmt . samplerate = samplerate ; return w ; }	Takes single channel wavs as input produces multi channel wav.
public static aacdecoderconfig parsemp4decoderspecificinfo ( byte [ ] data ) throws aacexception { final ibitstream _in = bitstream . createbitstream ( data ) ; final aacdecoderconfig config = new aacdecoderconfig ( ) ; try { config . profile = readprofile ( _in ) ; int sf = _in . readbits ( num_ ) ; if ( sf == num_ ) config . samplefrequency = samplefrequency . forfrequency ( _in . readbits ( num_ ) ) ; else config . samplefrequency = samplefrequency . forint ( sf ) ; config . channelconfiguration = channelconfiguration . forint ( _in . readbits ( num_ ) ) ; profile cp = config . profile ; if ( aac_sbr == cp ) { config . extprofile = cp ; config . sbrpresent = bool_ ; sf = _in . readbits ( num_ ) ;	Parses the input arrays as a DecoderSpecificInfo, as used in MP4containers.
public void encode ( int symbol , context cm ) throws ioexception { int rangelps = mqconst . plps [ cm . getstate ( ) ] ; if ( symbol == cm . getmps ( ) ) { range -= rangelps ; offset += rangelps ; if ( range < num_ ) { while ( range < num_ ) renormalize ( ) ; cm . setstate ( mqconst . transitmps [ cm . getstate ( ) ] ) ; } } else { range = rangelps ; while ( range < num_ ) renormalize ( ) ; if ( mqconst . mpsswitch [ cm . getstate ( ) ] != num_ ) cm . setmps ( num_ - cm . getmps ( ) ) ; cm . setstate ( mqconst . transitlps [ cm . getstate ( ) ] ) ; } }	Encodes one symbol either 0 or 1.
public static pair < list < edit > > split ( moviebox movie , trakbox track , long tvmv ) { return splitedits ( track . getedits ( ) , new rational ( track . gettimescale ( ) , movie . gettimescale ( ) ) , tvmv ) ; }	Splits track on the timevalue specified.
public void decodeframe ( byte [ ] frame , samplebuffer buffer ) throws aacexception { if ( frame != null ) _in . setdata ( frame ) ; logger . debug ( str_ + _in . getbitsleft ( ) ) ; try { decode ( buffer ) ; } catch ( aacexception e ) { if ( ! e . isendofstream ( ) ) throw e ; else logger . warn ( str_ ) ; } }	Decodes one frame of AAC data in frame mode and returns the raw PCM data.
public void setbigendian ( boolean bigendian ) { if ( bigendian != this . bigendian ) { byte tmp ; for ( int i = num_ ; i < data . length ; i += num_ ) { tmp = data [ i ] ; data [ i ] = data [ i + num_ ] ; data [ i + num_ ] = tmp ; } this . bigendian = bigendian ; } }	Sets the endianness for the data.
public void deblockmbp ( encodedmb cur , encodedmb left , encodedmb top ) { int [ ] [ ] vertstrength = new int [ num_ ] [ num_ ] ; int [ ] [ ] horizstrength = new int [ num_ ] [ num_ ] ; calcstrengthforblocks ( cur , left , vertstrength , lookup_idx_p_v , lookup_idx_q_v ) ; calcstrengthforblocks ( cur , top , horizstrength , lookup_idx_p_h , lookup_idx_q_h ) ; deblockmbgeneric ( cur , left , top , vertstrength , horizstrength ) ; }	Deblocks P-macroblock.
public void encodenativeframe ( picture pic ) throws ioexception { if ( pic . getcolor ( ) != colorspace . rgb ) throw new illegalargumentexception ( str_ ) ; colorspace sinkcolor = sink . getinputcolor ( ) ; loanerpicture toencode ; if ( sinkcolor != null ) { toencode = pixelstore . getpicture ( pic . getwidth ( ) , pic . getheight ( ) , sinkcolor ) ; transform . transform ( pic , toencode . getpicture ( ) ) ; } else { toencode = new loanerpicture ( pic , num_ ) ; } packet pkt = packet . createpacket ( null , timestamp , fps . getnum ( ) , fps . getden ( ) , frameno , frametype . key , null ) ; sink . outputvideoframe ( new videoframewithpacket ( pkt , toencode ) ) ; if ( sinkcolor != null ) pixelstore . putback ( toencode ) ; timestamp += fps . getden ( ) ; frameno ++ ; }	Encodes a frame into a movie.
public static byte [ ] ebmlencodelen ( long value , int length ) { byte [ ] b = new byte [ length ] ; for ( int idx = num_ ; idx < length ; idx ++ ) {	Encodes unsigned integer with given length.
public static int ebmllength ( long v ) { if ( v == num_ ) return num_ ; int length = num_ ; while ( length > num_ && ( v & ebmllengthmasks [ length ] ) == num_ ) length -- ; return length ; }	This method is used mostly during writing EBML bitstream. It answers the following question "How many bytes should be used to encode unsigned integer value".
public void addpacket ( flvtag pkt ) throws ioexception { if ( ! writepacket ( writebuf , pkt ) ) { writebuf . flip ( ) ; startoflastpacket -= out . write ( writebuf ) ; writebuf . clear ( ) ; if ( ! writepacket ( writebuf , pkt ) ) throw new runtimeexception ( str_ ) ; } }	Add a packet to the underlying file.
public boolean repositionfile ( ) throws ioexception { int payloadsize = num_ ; for ( int i = num_ ; i < reposition_buffer_reads ; i ++ ) { while ( readbuf . hasremaining ( ) ) { payloadsize = ( ( payloadsize & num_ ) << num_ ) | ( readbuf . get ( ) & num_ ) ; int pointerpos = readbuf . position ( ) + num_ + payloadsize ; if ( readbuf . position ( ) >= num_ && pointerpos < readbuf . limit ( ) - num_ && readbuf . getint ( pointerpos ) - payloadsize == num_ ) { readbuf . position ( readbuf . position ( ) - num_ ) ; return bool_ ; } } initialread ( ch ) ; if ( ! readbuf . hasremaining ( ) ) break ; } return bool_ ; }	Searching for the next tag in a file after corrupt segment.
public int decodebin ( int m ) { int bin ; int qidx = ( range > > num_ ) & num_ ; int rlps = mconst . rangelps [ qidx ] [ cm [ num_ ] [ m ] ] ; range -= rlps ; int rs8 = range << num_ ; if ( code < rs8 ) {	Decodes one bin from arithmetice code word.
public int decodebinbypass ( ) { code <<= num_ ; -- nbitspending ; if ( nbitspending <= num_ ) readonebyte ( ) ; int tmp = code - ( range << num_ ) ; if ( tmp < num_ ) {	Special decoding process for symbols with uniform distribution.
public static final bytebuffer gotomarker ( bytebuffer buf , int n , int mmin , int mmax ) { if ( ! buf . hasremaining ( ) ) return null ; int from = buf . position ( ) ; bytebuffer result = buf . slice ( ) ; result . order ( byteorder . big_endian ) ; int val = num_ ; while ( buf . hasremaining ( ) ) { val = ( val << num_ ) | ( buf . get ( ) & num_ ) ; if ( val >= mmin && val <= mmax ) { if ( n == num_ ) { buf . position ( buf . position ( ) - num_ ) ; result . limit ( buf . position ( ) - from ) ; break ; } -- n ; } } return result ; }	Finds next Nth MPEG bitstream marker 0x000001xx and returns the data thatpreceeds it as a ByteBuffer sliceSegment byte order is always little endian.
public static samplefrequency forint ( int i ) { final samplefrequency freq ; if ( i >= num_ && i < num_ ) freq = values ( ) [ i ] ; else freq = sample_frequency_none ; return freq ; }	Returns a sample frequency instance for the given index.
@ override public void predictplane ( byte [ ] ref , int refx , int refy , int refw , int refh , int refvertstep , int refvertoff , int [ ] tgt , int tgty , int tgtw , int tgth , int tgtvertstep ) { super . predictplane ( ref , refx << num_ , refy << num_ , refw , refh , refvertstep , refvertoff , tgt , tgty , tgtw << num_ , tgth << num_ , tgtvertstep ) ; }	this may be a result of color greening out in long GOPs.
public static final void start ( int [ ] block , int dc ) { dc <<= dc_shift ; for ( int i = num_ ; i < num_ ; i += num_ ) { block [ i + num_ ] = dc ; block [ i + num_ ] = dc ; block [ i + num_ ] = dc ; block [ i + num_ ] = dc ; } }	Starts DCT reconstructionFaster then call to 'coeff' with ind = 0.
public static final void coeff ( int [ ] block , int ind , int level ) { for ( int i = num_ ; i < num_ ; i += num_ ) { block [ i ] += coeff [ ind ] [ i ] * level ; block [ i + num_ ] += coeff [ ind ] [ i + num_ ] * level ; block [ i + num_ ] += coeff [ ind ] [ i + num_ ] * level ; block [ i + num_ ] += coeff [ ind ] [ i + num_ ] * level ; } }	Recalculates image based on new DCT coefficient.
public static final void finish ( int block [ ] ) { for ( int i = num_ ; i < num_ ; i += num_ ) { block [ i ] = div ( block [ i ] ) ; block [ i + num_ ] = div ( block [ i + num_ ] ) ; block [ i + num_ ] = div ( block [ i + num_ ] ) ; block [ i + num_ ] = div ( block [ i + num_ ] ) ; } }	Finalizes DCT calculation.
public void concatbits ( bitsbuffer a ) { if ( a . len == num_ ) return ; int al = a . bufa ; int ah = a . bufb ; int bl , bh ; if ( len > num_ ) {	merge bits of a to b.
static int rewindreverse32 ( int v , int len ) { v = ( ( v > > s [ num_ ] ) & b [ num_ ] ) | ( ( v << s [ num_ ] ) & ~ b [ num_ ] ) ; v = ( ( v > > s [ num_ ] ) & b [ num_ ] ) | ( ( v << s [ num_ ] ) & ~ b [ num_ ] ) ; v = ( ( v > > s [ num_ ] ) & b [ num_ ] ) | ( ( v << s [ num_ ] ) & ~ b [ num_ ] ) ; v = ( ( v > > s [ num_ ] ) & b [ num_ ] ) | ( ( v << s [ num_ ] ) & ~ b [ num_ ] ) ; v = ( ( v > > s [ num_ ] ) & b [ num_ ] ) | ( ( v << s [ num_ ] ) & ~ b [ num_ ] ) ;	32 bit rewind and reverse.
protected int seektokeyframe ( int frame ) throws ioexception { if ( videoinputtrack instanceof seekabledemuxertrack ) { seekabledemuxertrack seekable = ( seekabledemuxertrack ) videoinputtrack ; seekable . gotosyncframe ( frame ) ; return ( int ) seekable . getcurframe ( ) ; } else { logger . warn ( str_ + videoinputtrack + str_ ) ; return - num_ ; } }	Seeks to a previous key frame prior or on the given frame, if the track isnot seekable returns 0.
protected loanerpicture getpixelbuffer ( bytebuffer firstframe ) { videocodecmeta videometa = getvideocodecmeta ( ) ; size size = videometa . getsize ( ) ; return pixelstore . getpicture ( ( size . getwidth ( ) + num_ ) & ~ num_ , ( size . getheight ( ) + num_ ) & ~ num_ , videometa . getcolor ( ) ) ; }	Returns a pixel buffer of a suitable size to hold the given video frame.
private int getgainchangepointid ( int lngain ) { for ( int i = num_ ; i < id_gain ; i ++ ) { if ( lngain == ln_gain [ i ] ) return i ; } return num_ ;	transformes the exponent value of the gain to the id of the gain changepoint.
public static int [ ] frombyte ( byte [ ] b , int depth , boolean isbe ) { if ( depth == num_ ) if ( isbe ) return from24be ( b ) ; else return from24le ( b ) ; else if ( depth == num_ ) if ( isbe ) return from16be ( b ) ; else return from16le ( b ) ; throw new notsupportedexception ( str_ + depth + str_ + ( isbe ? str_ : str_ ) + str_ ) ; }	Generic byte-array to integer-array conversionConverts each depth-bit sequence from the input byte array into integer.
public static byte [ ] tobyte ( int [ ] ia , int depth , boolean isbe ) { if ( depth == num_ ) if ( isbe ) return to24be ( ia ) ; else return to24le ( ia ) ; else if ( depth == num_ ) if ( isbe ) return to16be ( ia ) ; else return to16le ( ia ) ; throw new notsupportedexception ( str_ + depth + str_ + ( isbe ? str_ : str_ ) + str_ ) ; }	Generic integer-array to byte-array conversionConverts each integer into depth-bit sequence in the output byte array.
public static void tofloat ( audioformat format , bytebuffer buf , floatbuffer floatbuf ) { if ( ! format . issigned ( ) ) throw new notsupportedexception ( str_ ) ; if ( format . getsamplesizeinbits ( ) != num_ && format . getsamplesizeinbits ( ) != num_ ) throw new notsupportedexception ( format . getsamplesizeinbits ( ) + str_ ) ; if ( format . isbigendian ( ) ) { if ( format . getsamplesizeinbits ( ) == num_ ) { tofloat16be ( buf , floatbuf ) ; } else { tofloat24be ( buf , floatbuf ) ; } } else { if ( format . getsamplesizeinbits ( ) == num_ ) { tofloat16le ( buf , floatbuf ) ; } else { tofloat24le ( buf , floatbuf ) ; } } }	Converts PCM samples stored in buf and described with format to floatarray representation.
public static void fromfloat ( floatbuffer floatbuf , audioformat format , bytebuffer buf ) { if ( ! format . issigned ( ) ) throw new notsupportedexception ( str_ ) ; if ( format . getsamplesizeinbits ( ) != num_ && format . getsamplesizeinbits ( ) != num_ ) throw new notsupportedexception ( format . getsamplesizeinbits ( ) + str_ ) ; if ( format . isbigendian ( ) ) { if ( format . getsamplesizeinbits ( ) == num_ ) { fromfloat16be ( buf , floatbuf ) ; } else { fromfloat24be ( buf , floatbuf ) ; } } else { if ( format . getsamplesizeinbits ( ) == num_ ) { fromfloat16le ( buf , floatbuf ) ; } else { fromfloat24le ( buf , floatbuf ) ; } } }	Converts float PCM samples stored in floatBuf to integer representationaccording to format and stores them in buf.
public static void interleave ( audioformat format , bytebuffer [ ] ins , bytebuffer outb ) { int bytespersample = format . getsamplesizeinbits ( ) > > num_ ; int bytesperframe = bytespersample * ins . length ; int max = num_ ; for ( int i = num_ ; i < ins . length ; i ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; for ( int frames = num_ ; frames < max && outb . remaining ( ) >= bytesperframe ; frames ++ ) { for ( int j = num_ ; j < ins . length ; j ++ ) { if ( ins [ j ] . remaining ( ) < bytespersample ) { for ( int i = num_ ; i < bytespersample ; i ++ ) outb . put ( ( byte ) num_ ) ; } else { for ( int i = num_ ; i < bytespersample ; i ++ ) { outb . put ( ins [ j ] . get ( ) ) ; } } } } }	Interleaves audio samples in ins into outb using sample size from theformat.
public static void deinterleave ( audioformat format , bytebuffer inb , bytebuffer [ ] outs ) { int bytespersample = format . getsamplesizeinbits ( ) > > num_ ; int bytesperframe = bytespersample * outs . length ; while ( inb . remaining ( ) >= bytesperframe ) { for ( int j = num_ ; j < outs . length ; j ++ ) { for ( int i = num_ ; i < bytespersample ; i ++ ) { outs [ j ] . put ( inb . get ( ) ) ; } } } }	Deinterleaves audio samples from inb into outs using sample size fromformat.
public size getcodedsize ( ) { sampleentry se = getsampleentries ( ) [ num_ ] ; if ( ! ( se instanceof videosampleentry ) ) throw new illegalargumentexception ( str_ ) ; videosampleentry vse = ( videosampleentry ) se ; return new size ( vse . getwidth ( ) , vse . getheight ( ) ) ; }	Retrieves coded size of this video track.Note: May be different from video display dimension.
public static int [ ] buildwipemap ( int picwidthinmbs , int picheightinmbs , int sizeofupperleftgroup , boolean changedirection ) { int picsizeinmbs = picwidthinmbs * picheightinmbs ; int [ ] groups = new int [ picsizeinmbs ] ; int changedirectionint = changedirection ? num_ : num_ ; int k = num_ ; for ( int j = num_ ; j < picwidthinmbs ; j ++ ) { for ( int i = num_ ; i < picheightinmbs ; i ++ ) { int mbaddr = i * picwidthinmbs + j ; if ( k ++ < sizeofupperleftgroup ) { groups [ mbaddr ] = changedirectionint ; } else { groups [ mbaddr ] = num_ - changedirectionint ; } } } return groups ; }	A macroblock to slice group map that fills frame column by column.
protected static ul [ ] readulbatch ( bytebuffer _bb ) { int count = _bb . getint ( ) ; _bb . getint ( ) ; ul [ ] result = new ul [ count ] ; for ( int i = num_ ; i < count ; i ++ ) { result [ i ] = ul . read ( _bb ) ; } return result ; }	Utility method to read a batch of ULS.
protected static int [ ] readint32batch ( bytebuffer _bb ) { int count = _bb . getint ( ) ; _bb . getint ( ) ; int [ ] result = new int [ count ] ; for ( int i = num_ ; i < count ; i ++ ) { result [ i ] = _bb . getint ( ) ; } return result ; }	Utility method to read a batch of int32.
public static int calcmvpredictionmedian ( int a , int b , int c , int d , boolean aavb , boolean bavb , boolean cavb , boolean davb , int ref , int comp ) { if ( ! cavb ) { c = d ; cavb = davb ; } if ( aavb && ! bavb && ! cavb ) { b = c = a ; bavb = cavb = aavb ; } a = aavb ? a : null_vector ; b = bavb ? b : null_vector ; c = cavb ? c : null_vector ; if ( mvref ( a ) == ref && mvref ( b ) != ref && mvref ( c ) != ref ) return mvc ( a , comp ) ; else if ( mvref ( b ) == ref && mvref ( a ) != ref && mvref ( c ) != ref ) return mvc ( b , comp ) ; else if ( mvref ( c ) == ref && mvref ( a ) != ref && mvref ( b ) != ref ) return mvc ( c , comp ) ; return mvc ( a , comp ) + mvc ( b , comp ) + mvc ( c , comp ) - min ( mvc ( a , comp ) , mvc ( b , comp ) , mvc ( c , comp ) ) - max ( mvc ( a , comp ) , mvc ( b , comp ) , mvc ( c , comp ) ) ; }	Calculates median prediction.
public encodedframe encodeframe ( picture pic , bytebuffer _out ) { if ( pic . getcolor ( ) != colorspace . yuv420j ) throw new illegalargumentexception ( str_ + pic . getcolor ( ) ) ; if ( framenumber >= keyinterval ) { framenumber = num_ ; } slicetype slicetype = framenumber == num_ ? slicetype . i : slicetype . p ; boolean idr = framenumber == num_ ; bytebuffer data = doencodeframe ( pic , _out , idr , framenumber ++ , slicetype ) ; return new encodedframe ( data , idr ) ; }	Encode this picture into h.264 frame.
public bytebuffer encodeidrframe ( picture pic , bytebuffer _out ) { framenumber = num_ ; return doencodeframe ( pic , _out , bool_ , framenumber , slicetype . i ) ; }	Encode this picture as an IDR frame. IDR frame starts a new independentlydecodeable video sequence.
public bytebuffer encodepframe ( picture pic , bytebuffer _out ) { framenumber ++ ; return doencodeframe ( pic , _out , bool_ , framenumber , slicetype . p ) ; }	Encode this picture as a P-frame.
public java . util . collection < codec . id > getsupportedcodecs ( ) { final java . util . list < codec . id > retval = new java . util . linkedlist < codec . id > ( ) ; final java . util . set < codec . id > uniqueset = new java . util . hashset < codec . id > ( ) ; int numcodecs = getnumsupportedcodecs ( ) ; for ( int i = num_ ; i < numcodecs ; i ++ ) { codec . id id = getsupportedcodecid ( i ) ;	Returns a list of all codecs supported for this Object.
public java . util . collection < long > getsupportedtags ( ) { final java . util . list < long > retval = new java . util . linkedlist < long > ( ) ; final java . util . set < long > uniqueset = new java . util . hashset < long > ( ) ; int numcodecs = getnumsupportedcodecs ( ) ; for ( int i = num_ ; i < numcodecs ; i ++ ) { long tag = getsupportedcodectag ( i ) ; codec . id id = getsupportedcodecid ( i ) ;	Returns a list of all codec tags supported for this container.
final boolean addreference ( final jnireference ref ) {	Add a reference to the set of references we'll collect.
void gcinternal ( ) { jnireference ref = null ; while ( ( ref = ( jnireference ) mrefqueue . poll ( ) ) != null ) { ref . delete ( ) ; } }	The actual GC;.
final public void flush ( ) { blockinglock ( ) ; try { int numsurvivors = sweepandcollect ( ) ; for ( int i = num_ ; i < numsurvivors ; i ++ ) { final jnireference ref = mvalidreferences [ i ] ; if ( ref != null ) ref . delete ( ) ; } sweepandcollect ( ) ;	Internal Only.Immediately frees all active objects in the system.
@ suppresswarnings ( str_ ) public static void load ( string appname , jnilibrary library ) {	Load the given library into the given application.This method first searches in the classpath for native libraries that arebundled in there, and only if no matches are found, will it search therun-time paths of each OS.
private boolean unpacklibrary ( string path ) { boolean retval = bool_ ; try { final enumeration < url > c = jnilibrary . class . getclassloader ( ) . getresources ( path ) ; while ( c . hasmoreelements ( ) ) { final url url = c . nextelement ( ) ; log . trace ( str_ , path , url ) ; if ( url == null ) return bool_ ; boolean unpacked = bool_ ; file lib ; if ( url . getprotocol ( ) . tolowercase ( ) . equals ( str_ ) ) {	Looks for a URL in a classpath, and if found, unpacks it.
private static void deletetemporaryfiles ( ) { final file dir = gettmpdir ( ) ; final filenamefilter filter = new filenamefilter ( ) { public boolean accept ( file dir , string name ) { return name . endswith ( humble_temp_extension ) ; } } ; final file markers [ ] = dir . listfiles ( filter ) ; for ( file marker : markers ) { final string markername = marker . getname ( ) ; final string libname = markername . substring ( num_ , markername . length ( ) - humble_temp_extension . length ( ) ) ; final file lib = new file ( marker . getparentfile ( ) , libname ) ; if ( ! lib . exists ( ) || lib . delete ( ) ) marker . delete ( ) ; } }	Finds all ".humble" temp files in the temp directory and nukes them.
public static audiochannel . layout getdefaultlayout ( int numchannels ) { return audiochannel . layout . swigtoenum ( videojni . audiochannel_getdefaultlayout ( numchannels ) ) ; }	Return default channel layout for a given number of channels.
public static audiochannel . type getchannelfromlayoutatindex ( audiochannel . layout layout , int index ) { return audiochannel . type . swigtoenum ( videojni . audiochannel_getchannelfromlayoutatindex ( layout . swigvalue ( ) , index ) ) ; }	Get the channel with the given index in channel_layout.
public static mediapacket make ( ) { long cptr = videojni . mediapacket_make__swig_0 ( ) ; return ( cptr == num_ ) ? null : new mediapacket ( cptr , bool_ ) ; }	Create a new Packet.
public static string getversioninfo ( ) { final class < ? > c = version . class ; final stringbuilder b = new stringbuilder ( ) ; final package p = c . getpackage ( ) ; b . append ( str_ + c . getcanonicalname ( ) + str_ ) ; b . append ( str_ + p . getspecificationvendor ( ) + str_ ) ; b . append ( str_ + p . getspecificationtitle ( ) + str_ ) ; b . append ( str_ + p . getspecificationversion ( ) + str_ ) ; b . append ( str_ + p . getimplementationvendor ( ) + str_ ) ; b . append ( str_ + p . getimplementationtitle ( ) + str_ ) ; b . append ( str_ + p . getimplementationversion ( ) + str_ ) ; return b . tostring ( ) ; }	Prints the version of this library to System.out along withsome information on what this jar is.
public static rational getdefaulttimebase ( ) { long cptr = videojni . global_getdefaulttimebase ( ) ; return ( cptr == num_ ) ? null : new rational ( cptr , bool_ ) ; }	The default timebase used by media if not otherwise specified.
public static demuxer make ( ) { long cptr = videojni . demuxer_make ( ) ; return ( cptr == num_ ) ? null : new demuxer ( cptr , bool_ ) ; }	Create a new Demuxer.
private static void playvideo ( string filename ) throws interruptedexception , ioexception { demuxer demuxer = demuxer . make ( ) ; demuxer . open ( filename , null , bool_ , bool_ , null , null ) ; int numstreams = demuxer . getnumstreams ( ) ; int videostreamid = - num_ ; long streamstarttime = global . no_pts ; decoder videodecoder = null ; for ( int i = num_ ; i < numstreams ; i ++ ) { final demuxerstream stream = demuxer . getstream ( i ) ; streamstarttime = stream . getstarttime ( ) ; final decoder decoder = stream . getdecoder ( ) ; if ( decoder != null && decoder . getcodectype ( ) == mediadescriptor . type . media_video ) { videostreamid = i ; videodecoder = decoder ;	Opens a file, and plays the video from it on a screen at the right rate.
private static bufferedimage displayvideoatcorrecttime ( long streamstarttime , final mediapicture picture , final mediapictureconverter converter , bufferedimage image , final imageframe window , long systemstarttime , final rational systemtimebase , final rational streamtimebase ) throws interruptedexception { long streamtimestamp = picture . gettimestamp ( ) ;	Takes the video picture and displays it at the right time.
public static codecdescriptor make ( codec . id id ) { long cptr = videojni . codecdescriptor_make ( id . swigvalue ( ) ) ; return ( cptr == num_ ) ? null : new codecdescriptor ( cptr , bool_ ) ; }	Get the descriptor for the given id.
public static void printoption ( java . io . printstream stream , configurable configobj , property prop ) { if ( prop . gettype ( ) != property . type . property_flags ) { stream . printf ( str_ , prop . getname ( ) , configobj . getpropertyasstring ( prop . getname ( ) ) , prop . gettype ( ) ) ; } else {	Print information about the property on the configurable object.
static humbleio registerfactory ( string protocolprefix ) { urlprotocolmanager manager = urlprotocolmanager . getmanager ( ) ; manager . registerfactory ( protocolprefix , mfactory ) ; return mfactory ; }	Register a new protocol name for this factory that Humble.IO will use forthe given protocol.
static public string generateuniquename ( object src , string extension ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( uuid . randomuuid ( ) . tostring ( ) ) ; if ( src != null ) { builder . append ( str_ ) ; builder . append ( src . getclass ( ) . getname ( ) ) ; builder . append ( str_ ) ; builder . append ( integer . tohexstring ( src . hashcode ( ) ) ) ; } if ( extension != null ) { builder . append ( extension ) ; } return builder . tostring ( ) ; }	Generates a unique name suitable for using in the map methods for the URLparameter.
public static mediaaudioresampler make ( audiochannel . layout outlayout , int outsamplerate , audioformat . type outformat , audiochannel . layout inlayout , int insamplerate , audioformat . type informat ) { long cptr = videojni . mediaaudioresampler_make ( outlayout . swigvalue ( ) , outsamplerate , outformat . swigvalue ( ) , inlayout . swigvalue ( ) , insamplerate , informat . swigvalue ( ) ) ; return ( cptr == num_ ) ? null : new mediaaudioresampler ( cptr , bool_ ) ; }	Create a new MediaAudioResampler.
public java . util . collection < rational > getsupportedvideoframerates ( ) { java . util . list < rational > retval = new java . util . linkedlist < rational > ( ) ; int count = getnumsupportedvideoframerates ( ) ; for ( int i = num_ ; i < count ; i ++ ) { rational rate = getsupportedvideoframerate ( i ) ; if ( rate != null ) retval . add ( rate ) ; } return retval ; }	Returns a list of supported frame-rates this codec can encodevideo to.
public java . util . collection < pixelformat . type > getsupportedvideopixelformats ( ) { java . util . list < pixelformat . type > retval = new java . util . linkedlist < pixelformat . type > ( ) ; int count = getnumsupportedvideopixelformats ( ) ; for ( int i = num_ ; i < count ; i ++ ) { pixelformat . type type = getsupportedvideopixelformat ( i ) ; if ( type != null && type != pixelformat . type . pix_fmt_none ) retval . add ( type ) ; } return retval ; }	Returns a list of supported pixel formats this codec can encodevideo in.
public java . util . collection < integer > getsupportedaudiosamplerates ( ) { java . util . list < integer > retval = new java . util . linkedlist < integer > ( ) ; int count = getnumsupportedaudiosamplerates ( ) ; for ( int i = num_ ; i < count ; i ++ ) { int rate = getsupportedaudiosamplerate ( i ) ; if ( rate != num_ ) retval . add ( rate ) ; } return retval ; }	Returns a list of supported audio sample rates this codec can encodeaudio in.
public java . util . collection < audioformat . type > getsupportedaudioformats ( ) { java . util . list < audioformat . type > retval = new java . util . linkedlist < audioformat . type > ( ) ; int count = getnumsupportedaudioformats ( ) ; for ( int i = num_ ; i < count ; i ++ ) { audioformat . type fmt = getsupportedaudioformat ( i ) ; if ( fmt != null && fmt != audioformat . type . sample_fmt_none ) retval . add ( fmt ) ; } return retval ; }	Returns a list of supported audio sample formats this codec can encodeaudio in.
public java . util . collection < audiochannel . layout > getsupportedaudiochannellayouts ( ) { java . util . list < audiochannel . layout > retval = new java . util . linkedlist < audiochannel . layout > ( ) ; int count = getnumsupportedaudiochannellayouts ( ) ; for ( int i = num_ ; i < count ; i ++ ) { audiochannel . layout layout = getsupportedaudiochannellayout ( i ) ; if ( layout != audiochannel . layout . ch_layout_unknown ) retval . add ( layout ) ; } return retval ; }	Returns a list of supported audio channel layouts this codec can encodeaudio in.
public void setflag ( coder . flag flag , boolean value ) { videojni . coder_setflag ( swigcptr , this , flag . swigvalue ( ) , value ) ; }	Set a flag to true or false.
public void setflag2 ( coder . flag2 flag , boolean value ) { videojni . coder_setflag2 ( swigcptr , this , flag . swigvalue ( ) , value ) ; }	Set a flag2 to true or false.
public decoder getdecoder ( ) { long cptr = videojni . demuxerstream_getdecoder ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new decoder ( cptr , bool_ ) ; }	Get the decoder that can decode the information in this Demuxer stream.
public demuxer getdemuxer ( ) { long cptr = videojni . demuxerstream_getdemuxer ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new demuxer ( cptr , bool_ ) ; }	Get the Demuxer this DemuxerStream belongs to.
public static java . util . collection < muxerformat > getformats ( ) { java . util . collection < muxerformat > retval = new java . util . hashset < muxerformat > ( ) ; int count = getnumformats ( ) ; for ( int i = num_ ; i < count ; ++ i ) { muxerformat fmt = getformat ( i ) ; if ( fmt != null ) retval . add ( fmt ) ; } return retval ; }	Return a collection of all output formats installed on this system.
public static filtergraph make ( ) { long cptr = videojni . filtergraph_make ( ) ; return ( cptr == num_ ) ? null : new filtergraph ( cptr , bool_ ) ; }	Creates a new FilterGraph.
public bitstreamfiltertype gettype ( ) { long cptr = videojni . bitstreamfilter_gettype ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new bitstreamfiltertype ( cptr , bool_ ) ; }	Get the type of this filter.
public java . nio . bytebuffer getbytebuffer ( int offset , int length ) { return getbytebuffer ( offset , length , null ) ; }	Returns up to length bytes, starting at offset in the underlyingbuffer we're managing.
public static audioframe make ( final audioformat audioformat ) { try { return new audioframe ( audioformat ) ; } catch ( lineunavailableexception e ) { log . error ( str_ , e . getmessage ( ) ) ; return null ; } }	Get a connection to the speaker, if available.
protected static mediapicture resample ( mediapicture input , mediapictureresampler resampler ) {	Re-sample a picture.
protected void validateimage ( bufferedimage image ) {	Test that the passed image is valid and conforms to theconverters specifications.
protected void validatepicture ( mediapicture picture ) {	Test that the passed picture is valid and conforms to theconverters specifications.
public filtergraph getfiltergraph ( ) { long cptr = videojni . filterlink_getfiltergraph ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new filtergraph ( cptr , bool_ ) ; }	Get the FilterGraph this FilterLink belongs to.
public keyvaluebag getmetadata ( ) { long cptr = videojni . mediaraw_getmetadata ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new keyvaluebag ( cptr , bool_ ) ; }	Get any meta-data associated with this media item.
public static cpuarch getcpuarch ( string javacpu ) { final cpuarch javaarch ; final string javacpuarch = javacpu != null ? javacpu . tolowercase ( ) : str_ ;	Get the CPU architecture based on the passed in javaCPUArch specifier.The string should be of a format returned from {.
public static cpuarch getcpuarchfromgnustring ( string gnustring ) { final string nativecpu = gnustring . tolowercase ( ) ; final cpuarch nativearch ;	Return a CPUArch from parsing a GNU autoconf triple.For example "x86_64-w64-mingw32" will return {.
public static osfamily getosfamily ( string osname ) { final osfamily retval ; if ( osname != null && osname . length ( ) > num_ ) { if ( osname . startswith ( str_ ) ) retval = osfamily . windows ; else if ( osname . startswith ( str_ ) ) retval = osfamily . mac ; else if ( osname . startswith ( str_ ) ) retval = osfamily . linux ; else retval = osfamily . unknown ; } else retval = osfamily . unknown ; return retval ; }	Get the OSFamily based on the passed in osName specifier.The string should be of a format returned from {.
public static osfamily getosfamilyfromgnustring ( string gnustring ) { final string nativeos = ( gnustring != null ? gnustring . tolowercase ( ) : str_ ) ; final osfamily retval ; if ( nativeos . startswith ( str_ ) || nativeos . startswith ( str_ ) ) retval = osfamily . windows ; else if ( nativeos . startswith ( str_ ) ) retval = osfamily . mac ; else if ( nativeos . startswith ( str_ ) ) retval = osfamily . linux ; else retval = osfamily . unknown ; return retval ; }	Return an OS Family from parsing a GNU autoconf triple.For example "x86_64-w64-mingw32" will return {.
private static void playsound ( string filename ) throws interruptedexception , ioexception , lineunavailableexception { demuxer demuxer = demuxer . make ( ) ; demuxer . open ( filename , null , bool_ , bool_ , null , null ) ; int numstreams = demuxer . getnumstreams ( ) ; int audiostreamid = - num_ ; decoder audiodecoder = null ; for ( int i = num_ ; i < numstreams ; i ++ ) { final demuxerstream stream = demuxer . getstream ( i ) ; final decoder decoder = stream . getdecoder ( ) ; if ( decoder != null && decoder . getcodectype ( ) == mediadescriptor . type . media_audio ) { audiostreamid = i ; audiodecoder = decoder ;	Opens a file, and plays the audio from it on the speakers.
synchronized void loadlibrary0 ( string alibraryname , long amajorversion ) { if ( alreadyloadedlibrary ( alibraryname , amajorversion ) )	This is the method that actually loads the library.
void setloadedlibrary ( string alibraryname , long amajorversion ) { set < long > foundversions = mloadedlibraries . get ( alibraryname ) ; if ( foundversions == null ) { foundversions = new hashset < long > ( ) ; mloadedlibraries . put ( alibraryname , foundversions ) ; } foundversions . add ( amajorversion ) ; }	Tell the cache that we've loaded this version.
boolean loadcandidatelibrary ( string alibraryname , long amajorversion , list < string > alibcandidates ) { boolean retval = bool_ ; for ( string candidate : alibcandidates ) { log . trace ( str_ , new object [ ] { alibraryname , amajorversion == null ? str_ : amajorversion . longvalue ( ) , candidate } ) ; file candidatefile = new file ( candidate ) ; if ( candidatefile . exists ( ) ) { string abspath = candidatefile . getabsolutepath ( ) ; try { log . trace ( str_ , new object [ ] { alibraryname , amajorversion == null ? str_ : amajorversion . longvalue ( ) , abspath } ) ;	Iterates through the set of aLibCandidates until it succeeds in loading alibrary.
private void initializesearchpaths ( ) { string pathvar = null ; if ( mjavaproppaths == null ) { pathvar = system . getproperty ( str_ , str_ ) ; log . trace ( str_ , pathvar ) ; mjavaproppaths = getentitiesfrompath ( pathvar ) ; } if ( mjavaenvpaths == null ) { string envvar = getsystemruntimelibrarypathvar ( ) ; pathvar = system . getenv ( envvar ) ; log . trace ( str_ , envvar , pathvar ) ; mjavaenvpaths = getentitiesfrompath ( pathvar ) ; } }	Initialize the paths we'll search for libraries in.
boolean alreadyloadedlibrary ( string alibraryname , long amajorversion ) { boolean retval = bool_ ; set < long > foundversions = mloadedlibraries . get ( alibraryname ) ; if ( foundversions != null ) {	Checks our cache to see if we've already loaded this library.We will also detect if we've already loaded another version of thislibrary, and log a warning, but otherwise will return false in that case.
public void delete ( ) {	Explicitly deletes the underlying native storage used bythe object this object references.
public muxerstream getstream ( int position ) throws java . lang . interruptedexception , java . io . ioexception { long cptr = videojni . muxer_getstream ( swigcptr , this , position ) ; return ( cptr == num_ ) ? null : new muxerstream ( cptr , bool_ ) ; }	Get the MuxerStream at the given position.
public muxer getmuxer ( ) { long cptr = videojni . muxerstream_getmuxer ( swigcptr , this ) ; return ( cptr == num_ ) ? null : new muxer ( cptr , bool_ ) ; }	Get the Muxer that this stream belongs to.
public static setscripttransaction makescripttx ( privatekeyaccount sender , string script , byte chainid , long fee , long timestamp ) { return new setscripttransaction ( sender , script , chainid , fee , timestamp ) ; }	Creates a signed SetScript object.
public static byte [ ] decode ( string input ) throws illegalargumentexception { if ( input . startswith ( str_ ) ) input = input . substring ( num_ ) ; if ( input . length ( ) == num_ ) return new byte [ num_ ] ;	Decodes the given base58 string into the original data bytes.
public static string generateseed ( ) { byte [ ] bytes = new byte [ num_ ] ; new securerandom ( ) . nextbytes ( bytes ) ; byte [ ] rhash = hash ( bytes , num_ , num_ , sha256 ) ; bytes [ num_ ] = rhash [ num_ ] ; biginteger rand = new biginteger ( bytes ) ; biginteger mask = new biginteger ( new byte [ ] { num_ , num_ , num_ , - num_ } ) ;	Generates a 15-word random seed.
public transaction gettransaction ( string txid ) throws ioexception { return wavesjsonmapper . convertvalue ( send ( str_ + txid ) , transaction . class ) ; }	Returns object by its ID.
public list < transaction > getaddresstransactions ( string address , int limit ) throws ioexception { return getaddresstransactions ( address , limit , null ) ; }	Returns transactions by address with limit.
public list < transaction > getaddresstransactions ( string address , int limit , string after ) throws ioexception { string requesturl = string . format ( str_ , address , limit ) ; if ( after != null ) { requesturl += string . format ( str_ , after ) ; } return wavesjsonmapper . < list < list < transaction > > > convertvalue ( send ( requesturl ) , new typereference < list < list < transaction > > > ( ) { } ) . get ( num_ ) ; }	Returns transactions by address with limit after passed transaction id.
public list < blockheader > getblockheaderseq ( int from , int to ) throws ioexception { string path = string . format ( str_ , from , to ) ; httpresponse r = exec ( request ( path ) ) ; return parse ( r , block_header_list ) ; }	Returns seq of block headers.
public block getblock ( string signature ) throws ioexception { return wavesjsonmapper . convertvalue ( send ( str_ + signature ) , block . class ) ; }	Returns block by its signature.
public string send ( transaction tx ) throws ioexception { return parse ( exec ( request ( tx ) ) , str_ ) . astext ( ) ; }	Sends a signed object and returns its ID.
public string setscript ( privatekeyaccount from , string script , byte chainid , long fee ) throws ioexception { return send ( transactions . makescripttx ( from , compilescript ( script ) , chainid , fee ) ) ; }	Sets a validating script for an account.
public string compilescript ( string script ) throws ioexception { if ( script == null || script . isempty ( ) ) { return null ; } httppost request = new httppost ( uri . resolve ( str_ ) ) ; request . setentity ( new stringentity ( script ) ) ; return parse ( exec ( request ) , str_ ) . astext ( ) ; }	Compiles a script.
public void writeprimitivearray ( object array , int off , int len ) throws ioexception { class < ? > componenttype = array . getclass ( ) . getcomponenttype ( ) ; if ( componenttype == byte . class ) { writerawbytes ( ( byte [ ] ) array , off , len ) ; } else if ( componenttype == char . class ) { writefchararr ( ( char [ ] ) array , off , len ) ; } else if ( componenttype == short . class ) { writefshortarr ( ( short [ ] ) array , off , len ) ; } else if ( componenttype == int . class ) { writefintarr ( ( int [ ] ) array , off , len ) ; } else if ( componenttype == double . class ) { writefdoublearr ( ( double [ ] ) array , off , len ) ; } else if ( componenttype == float . class ) { writeffloatarr ( ( float [ ] ) array , off , len ) ; } else if ( componenttype == long . class ) { writeflongarr ( ( long [ ] ) array , off , len ) ; } else if ( componenttype == boolean . class ) { writefbooleanarr ( ( boolean [ ] ) array , off , len ) ; } else { throw new runtimeexception ( str_ ) ; } }	write prim array no len no tag.
@ override public void flush ( ) throws ioexception { if ( outstream != null ) outstream . write ( getbuffer ( ) , num_ , ( int ) pos ) ; pos = num_ ; }	writes current buffer to underlying output and resets buffer.
public int tomemory ( object o , long address , int availablesize ) throws ioexception { out . resetforreuse ( ) ; writetarget . setbase ( address , availablesize ) ; out . writeobject ( o ) ; int written = out . getwritten ( ) ; return written ; }	throws FSTBufferTooSmallException in case object does not fit into given range.
@ override public fstclazzinfo readclass ( ) throws ioexception , classnotfoundexception { if ( lastdirectclass != null ) { fstclazzinfo clinfo = conf . getclinforegistry ( ) . getclinfo ( lastdirectclass , conf ) ; lastdirectclass = null ; return clinfo ; } return null ; }	in case readClass already reads full minbin value.
public int tobytearray ( object obj , byte result [ ] , int resultoffset , int avaiablesize ) { output . resetforreuse ( ) ; try { output . writeobject ( obj ) ; } catch ( ioexception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } int written = output . getwritten ( ) ; if ( written > avaiablesize ) { throw fstbuffertoosmallexception . instance ; } system . arraycopy ( output . getbuffer ( ) , num_ , result , resultoffset , written ) ; return written ; }	will throw an FSTBufferTooSmallException if buffer is too small.
public void _setmmfdata ( file file , filechannel filechannel , cleaner cleaner ) { this . file = file ; this . filechannel = filechannel ; this . cleaner = cleaner ; }	hack to update underlying file in slices handed out to app.
public static int getspecificity ( final class < ? > clazz ) { if ( clazz == null ) return num_ ; final lineageinfo lineageinfo = fstclazzlineageinfo . getlineageinfo ( clazz ) ; return lineageinfo == null ? num_ : lineageinfo . specificity ; }	Returns the specificity of the specified class as defined above.
public void resizestore ( long required , long maxgrowbytes ) { if ( mappedfile == null ) throw new runtimeexception ( str_ + required ) ; if ( required <= memory . length ( ) ) return ; mutationcount ++ ; system . out . println ( str_ + mappedfile + str_ + required + str_ + numelem ) ; long tim = system . currenttimemillis ( ) ; ( ( mmfbytez ) memory ) . freeandclose ( ) ; memory = null ; try { file mf = new file ( mappedfile ) ; fileoutputstream f = new fileoutputstream ( mf , bool_ ) ; long len = mf . length ( ) ; required = required + math . min ( required , maxgrowbytes ) ; byte [ ] towrite = new byte [ num_ ] ; long max = ( required - len ) / num_ ; for ( long i = num_ ; i < max + num_ ; i ++ ) { f . write ( towrite ) ; } f . flush ( ) ; f . close ( ) ; resetmem ( mappedfile , mf . length ( ) ) ; system . out . println ( str_ + ( system . currenttimemillis ( ) - tim ) + str_ + numelem ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	PRIVILEGED method. You gotta know what your doing here ..currently a very expensive operation .. frees everything, resize file and remap.Remapping involves rebuild of index.
public void removebinary ( bytesource key ) { checkthread ( ) ; if ( key . length ( ) != keylen ) throw new runtimeexception ( str_ + keylen ) ; mutationcount ++ ; long rem = index . get ( key ) ; if ( rem != num_ ) { index . remove ( key ) ; decelems ( ) ; removeentry ( rem ) ; } }	remove the key from the binary map.
void writestringasc ( string name ) throws ioexception { int len = name . length ( ) ; if ( len >= num_ ) { throw new runtimeexception ( str_ ) ; } writefbyte ( ( byte ) len ) ; buffout . ensurefree ( len ) ; if ( ascstringcache == null || ascstringcache . length < len ) ascstringcache = new byte [ len ] ; name . getbytes ( num_ , len , ascstringcache , num_ ) ; writerawbytes ( ascstringcache , num_ , len ) ; }	length < 127 !!!!!.
@ override public void setoutstream ( outputstream outstream ) { if ( buffout == null ) {	if output stream is null, just encode into a byte array.
public static fstconfiguration createjsonconfiguration ( boolean prettyprint , boolean sharereferences ) { if ( sharereferences && prettyprint ) { throw new runtimeexception ( str_ ) ; } return createjsonconfiguration ( prettyprint , sharereferences , null ) ; }	create a json conf with given attributes.
public static fstconfiguration createstructconfiguration ( ) { fstconfiguration conf = new fstconfiguration ( null ) ; conf . setstructmode ( bool_ ) ; return conf ; }	special configuration used internally for struct emulation.
public int calcobjectsizebytesnotautility ( object obj ) throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream ( num_ ) ; fstobjectoutput ou = new fstobjectoutput ( bout , this ) ; ou . writeobject ( obj , obj . getclass ( ) ) ; ou . close ( ) ; return bout . tobytearray ( ) . length ; }	for optimization purposes, do not use to benchmark processing time or in a regular program asthis methods creates a temporary binaryoutputstream and serializes the object in order to measure thesize.
public void clearcaches ( ) { try { fstinputstream . cachedbuffer . set ( null ) ; while ( ! cachelock . compareandset ( bool_ , bool_ ) ) {	clear cached softref's and ThreadLocal.
public fstobjectinput getobjectinput ( inputstream in ) { fstobjectinput fstobjectinput = getin ( ) ; try { fstobjectinput . resetforreuse ( in ) ; return fstobjectinput ; } catch ( ioexception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } return null ; }	utility for thread safety and reuse.
public fstobjectinput getobjectinput ( byte arr [ ] , int len ) { fstobjectinput fstobjectinput = getin ( ) ; try { fstobjectinput . resetforreuseusearray ( arr , len ) ; return fstobjectinput ; } catch ( ioexception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } return null ; }	take the given array as input.
public fstobjectinput getobjectinputcopyfrom ( byte arr [ ] , int off , int len ) { fstobjectinput fstobjectinput = getin ( ) ; try { fstobjectinput . resetforreusecopyarray ( arr , off , len ) ; return fstobjectinput ; } catch ( ioexception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } return null ; }	take the given array and copy it to input. the array IS copied.
public fstobjectoutput getobjectoutput ( outputstream out ) { fstobjectoutput fstobjectoutput = getout ( ) ; fstobjectoutput . resetforreuse ( out ) ; return fstobjectoutput ; }	utility for thread safety and reuse.
public fstconfiguration registercrossplatformclassmapping ( string [ ] [ ] keysandvals ) { for ( int i = num_ ; i < keysandvals . length ; i ++ ) { string [ ] keysandval = keysandvals [ i ] ; registercrossplatformclassmapping ( keysandval [ num_ ] , keysandval [ num_ ] ) ; } return this ; }	init right after creation of configuration, not during operation as it is not threadsafe regarding mutationcurrently only for minbin serialization.
public string getcpnameforclass ( class cl ) { string res = minbinnamesreverse . get ( cl . getname ( ) ) ; if ( res == null ) { if ( cl . isanonymousclass ( ) ) { return getcpnameforclass ( cl . getsuperclass ( ) ) ; } return cl . getname ( ) ; } return res ; }	get cross platform symbolic class identifier.
public void writeint ( byte type , long data ) { if ( ! minbin . isprimitive ( type ) || minbin . isarray ( type ) ) throw new runtimeexception ( str_ ) ; writeout ( type ) ; writerawint ( type , data ) ; }	write an int type with header.
protected void writerawint ( byte type , long data ) { int numbytes = minbin . extractnumbytes ( type ) ; for ( int i = num_ ; i < numbytes ; i ++ ) { writeout ( ( byte ) ( data & num_ ) ) ; data = data > > > num_ ; } }	encode int without header tag.
public void writeintpacked ( long data ) { if ( data <= byte . max_value && data >= byte . min_value ) writeint ( minbin . int_8 , data ) ; else if ( data <= short . max_value && data >= short . min_value ) writeint ( minbin . int_16 , data ) ; else if ( data <= integer . max_value && data >= integer . min_value ) writeint ( minbin . int_32 , data ) ; else if ( data <= long . max_value && data >= long . min_value ) writeint ( minbin . int_64 , data ) ; }	encode int using only as much bytes as needed to represent it.
public void writeraw ( byte [ ] bufferedname , int i , int length ) { if ( pos + length >= bytez . length - num_ ) { resize ( ) ; } system . arraycopy ( bufferedname , i , bytez , pos , length ) ; pos += length ; }	allow write through to underlying byte for performance reasons.
protected fstclazzinfo . fstfieldinfo getcachedfi ( class ... possibles ) { if ( refs == null ) { refs = refslocal . get ( ) ; } if ( curdepth >= refs . length ) { return new fstclazzinfo . fstfieldinfo ( possibles , null , bool_ ) ; } else { fstclazzinfo . fstfieldinfo inf = refs [ curdepth ] ; if ( inf == null ) { inf = new fstclazzinfo . fstfieldinfo ( possibles , null , bool_ ) ; refs [ curdepth ] = inf ; return inf ; } inf . setpossibleclasses ( possibles ) ; return inf ; } }	avoid creation of dummy ref.
protected void objectwillbewritten ( object obj , int streamposition ) { if ( listener != null ) { listener . objectwillbewritten ( obj , streamposition ) ; } }	hook for debugging profiling. register a FSTSerialisationListener to use.
protected void objecthasbeenwritten ( object obj , int oldstreamposition , int streamposition ) { if ( listener != null ) { listener . objecthasbeenwritten ( obj , oldstreamposition , streamposition ) ; } }	hook for debugging profiling. empty impl, you need to subclass to make use of this hook.
protected fstclazzinfo getfstclazzinfo ( fstclazzinfo . fstfieldinfo referencee , class clazz ) { fstclazzinfo serializationinfo = null ; fstclazzinfo lastinfo = referencee . lastinfo ; if ( lastinfo != null && lastinfo . getclazz ( ) == clazz && lastinfo . conf == conf ) { serializationinfo = lastinfo ; } else { serializationinfo = getclassinforegistry ( ) . getclinfo ( clazz , conf ) ; referencee . lastinfo = serializationinfo ; } return serializationinfo ; }	if class is same as last referenced, returned cached clzinfo, else do a lookup.
protected void writearray ( fstclazzinfo . fstfieldinfo referencee , object array ) throws ioexception { if ( array == null ) { getcodec ( ) . writeclass ( object . class ) ; getcodec ( ) . writefint ( - num_ ) ; return ; } final int len = array . getlength ( array ) ; class < ? > componenttype = array . getclass ( ) . getcomponenttype ( ) ; getcodec ( ) . writeclass ( array . getclass ( ) ) ; getcodec ( ) . writefint ( len ) ; if ( ! componenttype . isarray ( ) ) { if ( getcodec ( ) . isprimitivearray ( array , componenttype ) ) { getcodec ( ) . writeprimitivearray ( array , num_ , len ) ; } else {	incoming array is already registered.
public void setstring ( string s ) { if ( s == null ) { setlen ( num_ ) ; return ; } if ( s . length ( ) > charslen ( ) ) { throw new runtimeexception ( str_ + s . length ( ) + str_ + charslen ( ) ) ; } for ( int i = num_ ; i < s . length ( ) ; i ++ ) { chars ( i , s . charat ( i ) ) ; } len = s . length ( ) ; }	modify content of this StructString. The length of the new String must not exceedthe length of internal char array.
@ override public void writeprimitivearray ( object array , int start , int length ) throws ioexception { out . writearray ( array , start , length ) ; }	does not write class tag and length.
public fststructchange finishchangetracking ( ) { tracker . snapshotchanges ( ( int ) getoffset ( ) , getbase ( ) ) ; fststructchange res = tracker ; tracker = null ; return res ; }	works only if change tracking is enabled.
public void snapshotchanges ( int originbase , bytez origin ) { int sumlen = num_ ; for ( int i = num_ ; i < curindex ; i ++ ) { sumlen += changelength [ i ] ; } snapshot = new byte [ sumlen ] ; int targetidx = num_ ; for ( int i = num_ ; i < curindex ; i ++ ) { int changeoffset = changeoffsets [ i ] ; int len = changelength [ i ] ; for ( int ii = num_ ; ii < len ; ii ++ ) { snapshot [ targetidx ++ ] = origin . get ( changeoffset + ii ) ; } } rebase ( originbase ) ; }	collects all changes and rebases.
public int registerobjectforwrite ( object o , int streamposition , fstclazzinfo clzinfo , int reusetype [ ] ) { if ( disabled ) { return integer . min_value ; }	add an object to the register, return handle if already present. Called during write only.
@ override public int tobytearray ( object o , byte arr [ ] , int startindex , int availablesize ) { out . resetforreuse ( ) ; writetarget . setbase ( arr , startindex , availablesize ) ; try { out . writeobject ( o ) ; } catch ( ioexception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } int written = out . getwritten ( ) ; return written ; }	throws FSTBufferTooSmallExcpetion in case object does not fit into given rangeZero Copy method.
@ override public object toobject ( byte arr [ ] , int startindex , int availablesize ) { try { in . resetforreuse ( null ) ; readtarget . setbase ( arr , startindex , availablesize ) ; object o = in . readobject ( ) ; return o ; } catch ( exception e ) { fstutil . < runtimeexception > rethrow ( e ) ; } return null ; }	throws FSTBufferTooSmallExcpetion in case object does not fit into given range.
public byte [ ] readbytearray ( int len ) { if ( available ( ) < len ) { throw new runtimeexception ( str_ ) ; } byte b [ ] = new byte [ len ] ; int count = num_ ; while ( pollindex != addindex && count < len ) { b [ count ++ ] = storage . get ( pollindex ++ ) ; if ( pollindex >= storage . length ( ) ) { pollindex = num_ ; } } return b ; }	convenience method to read len byte array. Throws an excpetion if not enough data is present.
public int readint ( ) { if ( available ( ) < num_ ) { throw new runtimeexception ( str_ ) ; } int ch1 = poll ( ) ; int ch2 = poll ( ) ; int ch3 = poll ( ) ; int ch4 = poll ( ) ; return ( ch4 << num_ ) + ( ch3 << num_ ) + ( ch2 << num_ ) + ( ch1 << num_ ) ; }	read an int. throws an exception if not enough data is present.
public void back ( int len ) { if ( pollindex >= len ) pollindex -= len ; else pollindex = pollindex + capacity ( ) - len ; }	'unread' len bytes.
public void setthreadpoolenabled ( boolean value ) { if ( value && ( threadpool == null ) ) { threadpool = executors . newcachedthreadpool ( ) ; } threadpoolenabled = value ; }	Set thread pool enabled.This thread pool is not for the service threads, it is for the user service method.If your service method takes a long time, or will be blocked, please set this property to be true.
public static void startembeddedcassandra ( file file , string tmpdir , long timeout ) throws ioexception , configurationexception { if ( cassandradaemon != null ) { return ; } checkconfignameforrestart ( file . getabsolutepath ( ) ) ; log . debug ( str_ ) ; log . debug ( str_ ) ; system . setproperty ( str_ , str_ + file . getabsolutepath ( ) ) ; system . setproperty ( str_ , str_ ) ; system . setproperty ( str_ , str_ ) ;	Set embedded cassandra up and spawn it in a new thread.
public static void cleandataembeddedcassandra ( string keyspace , string ... excludedtables ) { if ( session != null ) { cleandatawithnativedriver ( keyspace , excludedtables ) ; } }	truncate data in keyspace, except specified tables.
private static path copy ( string resource , string directory ) throws ioexception { mkdir ( directory ) ; string filename = resource . substring ( resource . lastindexof ( str_ ) + num_ ) ; inputstream from = embeddedcassandraserverhelper . class . getresourceasstream ( resource ) ; path copyname = paths . get ( directory , filename ) ; files . copy ( from , copyname ) ; return copyname ; }	Copies a resource from within the jar to a directory.
public static boolean remoteporttaken ( string node , int port , int timeout ) { socket s = null ; try { s = new socket ( ) ; s . setreuseaddress ( bool_ ) ; socketaddress sa = new inetsocketaddress ( node , port ) ; s . connect ( sa , timeout * num_ ) ; } catch ( ioexception e ) { if ( e . getmessage ( ) . equals ( str_ ) ) { return bool_ ; } if ( e instanceof sockettimeoutexception || e instanceof unknownhostexception ) { throw e ; } } finally { if ( s != null ) { if ( s . isconnected ( ) ) { return bool_ ; } else { } try { s . close ( ) ; } catch ( ioexception e ) { } } return bool_ ; } }	Check if a remote port is taken.
public static subscriberstate empty ( ) { return subscriberstate . builder ( ) . serverstate ( str_ ) . streamid ( - num_ ) . parameterupdaterstatus ( collections . emptymap ( ) ) . totalupdates ( - num_ ) . ismaster ( bool_ ) . build ( ) ; }	Returns an empty subscriber statewith -1 as total updates, master as falseand server state as empty.
public static map < string , opdescriptor > onnxopdescriptors ( ) throws exception { try ( inputstream is = new classpathresource ( str_ ) . getinputstream ( ) ) { objectmapper objectmapper = new objectmapper ( ) ; onnxdescriptor opdescriptor = objectmapper . readvalue ( is , onnxdescriptor . class ) ; map < string , opdescriptor > descriptormap = new hashmap < > ( ) ; for ( opdescriptor descriptor : opdescriptor . getdescriptors ( ) ) { descriptormap . put ( descriptor . getname ( ) , descriptor ) ; } return descriptormap ; } }	Get the onnx op descriptors by name.
public list < long [ ] > calculateoutputshape ( ) { list < long [ ] > ret = new arraylist < > ( ) ; if ( larg ( ) . getshape ( ) != null && rarg ( ) . getshape ( ) != null ) ret . add ( shape . broadcastoutputshape ( larg ( ) . getshape ( ) , rarg ( ) . getshape ( ) ) ) ; else if ( larg ( ) . getshape ( ) != null ) ret . add ( larg ( ) . getshape ( ) ) ; return ret ; }	Calculate the output shape for this op.
public static boolean or ( icomplexndarray n , condition cond ) { boolean ret = bool_ ; icomplexndarray linear = n . linearview ( ) ; for ( int i = num_ ; i < linear . length ( ) ; i ++ ) { ret = ret || cond . apply ( linear . getcomplex ( i ) ) ; } return ret ; }	Or over the whole ndarray given some condition.
public static boolean and ( final indarray n , final condition cond ) { if ( cond instanceof basecondition ) { long val = ( long ) nd4j . getexecutioner ( ) . exec ( new matchcondition ( n , cond ) , integer . max_value ) . getdouble ( num_ ) ; if ( val == n . lengthlong ( ) ) return bool_ ; else return bool_ ; } else { boolean ret = bool_ ; final atomicboolean a = new atomicboolean ( ret ) ; shape . iterate ( n , new coordinatefunction ( ) { @ override public void process ( long [ ] ... coord ) { if ( a . get ( ) ) a . compareandset ( bool_ , a . get ( ) && cond . apply ( n . getdouble ( coord [ num_ ] ) ) ) ; } } ) ; return a . get ( ) ; } }	And over the whole ndarray given some condition.
public static boolean [ ] and ( final indarray n , final condition condition , int ... dimension ) { if ( ! ( condition instanceof basecondition ) ) throw new unsupportedoperationexception ( str_ ) ; matchcondition op = new matchcondition ( n , condition ) ; indarray arr = nd4j . getexecutioner ( ) . exec ( op , dimension ) ; boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; long tadlength = shape . gettadlength ( n . shape ( ) , dimension ) ; for ( int i = num_ ; i < arr . length ( ) ; i ++ ) { if ( arr . getdouble ( i ) == tadlength ) result [ i ] = bool_ ; else result [ i ] = bool_ ; } return result ; }	And over the whole ndarray given some condition, with respect to dimensions.
public static boolean [ ] or ( final indarray n , final condition condition , int ... dimension ) { if ( ! ( condition instanceof basecondition ) ) throw new unsupportedoperationexception ( str_ ) ; matchcondition op = new matchcondition ( n , condition ) ; indarray arr = nd4j . getexecutioner ( ) . exec ( op , dimension ) ;	Or over the whole ndarray given some condition, with respect to dimensions.
public static void applywhere ( final indarray to , final condition condition , final number number ) { if ( condition instanceof basecondition ) {	This method sets provided number to all elements which match specified condition.
public static indarray firstindex ( indarray array , condition condition ) { if ( ! ( condition instanceof basecondition ) ) throw new unsupportedoperationexception ( str_ ) ; firstindex idx = new firstindex ( array , condition ) ; nd4j . getexecutioner ( ) . exec ( idx ) ; return nd4j . scalar ( ( double ) idx . getfinalresult ( ) ) ; }	This method returns first index matching given conditionPLEASE NOTE: This method will return -1 value if condition wasn't met.
public int asflatproperties ( flatbufferbuilder bufferbuilder ) { int iname = bufferbuilder . createstring ( name ) ; int ii = flatproperties . createivector ( bufferbuilder , ints . toarray ( i ) ) ; int il = flatproperties . createlvector ( bufferbuilder , longs . toarray ( l ) ) ; int id = flatproperties . createdvector ( bufferbuilder , doubles . toarray ( d ) ) ; int arrays [ ] = new int [ a . size ( ) ] ; int cnt = num_ ; for ( val array : a ) { int off = array . toflatarray ( bufferbuilder ) ; arrays [ cnt ++ ] = off ; } int ia = flatproperties . createavector ( bufferbuilder , arrays ) ; return flatproperties . createflatproperties ( bufferbuilder , iname , ii , il , id , ia ) ; }	This method converts this FunctionProperties instance to FlatBuffers representation.
public static functionproperties fromflatproperties ( flatproperties properties ) { val props = new functionproperties ( ) ; for ( int e = num_ ; e < properties . ilength ( ) ; e ++ ) props . geti ( ) . add ( properties . i ( e ) ) ; for ( int e = num_ ; e < properties . llength ( ) ; e ++ ) props . getl ( ) . add ( properties . l ( e ) ) ; for ( int e = num_ ; e < properties . dlength ( ) ; e ++ ) props . getd ( ) . add ( properties . d ( e ) ) ; for ( int e = num_ ; e < properties . ilength ( ) ; e ++ ) props . geta ( ) . add ( nd4j . createfromflatarray ( properties . a ( e ) ) ) ; return props ; }	This method creates new FunctionProperties instance from FlatBuffers representation.
public static int asflatproperties ( flatbufferbuilder bufferbuilder , collection < functionproperties > properties ) { int props [ ] = new int [ properties . size ( ) ] ; int cnt = num_ ; for ( val p : properties ) props [ cnt ++ ] = p . asflatproperties ( bufferbuilder ) ; return flatnode . createpropertiesvector ( bufferbuilder , props ) ; }	This method converts multiple FunctionProperties to FlatBuffers representation.
public void set ( throwable t ) { try { lock . writelock ( ) . lock ( ) ; this . t = t ; } finally { lock . writelock ( ) . unlock ( ) ; } }	This method updates state with given Throwable.
public void setiffirst ( throwable t ) { try { lock . writelock ( ) . lock ( ) ; if ( this . t == null ) this . t = t ; } finally { lock . writelock ( ) . unlock ( ) ; } }	This method updates state only if it wasn't set before.
public static list < double > mergecoords ( list < double > x , list < double > y ) { if ( x . size ( ) != y . size ( ) ) throw new illegalargumentexception ( str_ ) ; list < double > ret = new arraylist < double > ( ) ; for ( int i = num_ ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }	This will merge the coordinates of the given coordinate system.
public static list < list < double > > partitionvariable ( list < double > arr , int chunk ) { int count = num_ ; list < list < double > > ret = new arraylist < list < double > > ( ) ; while ( count < arr . size ( ) ) { list < double > sublist = arr . sublist ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; }	This will partition the given whole variable data applyTransformToDestination in to the specified chunk number.
public databuffer . type nd4jtypefromonnxtype ( onnxproto3 . tensorproto . datatype datatype ) { switch ( datatype ) { case double : return databuffer . type . double ; case float : return databuffer . type . float ; case float16 : return databuffer . type . half ; case int32 : case int64 : return databuffer . type . int ; default : return databuffer . type . unknown ; } }	Convert an onnx type to the proper nd4j type.
public void shutdown ( ) { if ( initlocker . get ( ) && shutdownlocker . compareandset ( bool_ , bool_ ) ) {	This method initiates shutdown sequence for this instance.PLEASE NOTE: This method is blocking for first caller only.
public int getcurrentdevicearchitecture ( ) { int deviceid = nd4j . getaffinitymanager ( ) . getdeviceforcurrentthread ( ) ; if ( ! arch . containskey ( deviceid ) ) { int major = nativeopsholder . getinstance ( ) . getdevicenativeops ( ) . getdevicemajor ( new cudapointer ( deviceid ) ) ; int minor = nativeopsholder . getinstance ( ) . getdevicenativeops ( ) . getdeviceminor ( new cudapointer ( deviceid ) ) ; integer cc = integer . parseint ( new string ( str_ + major + minor ) ) ; arch . put ( deviceid , cc ) ; return cc ; } return arch . get ( deviceid ) ; }	Get the current device architecture.
public static indarray col2im ( indarray col , int sy , int sx , int ph , int pw , int h , int w ) { if ( col . rank ( ) != num_ ) throw new illegalargumentexception ( str_ ) ; indarray output = nd4j . create ( new long [ ] { col . size ( num_ ) , col . size ( num_ ) , h , w } ) ; col2im col2im = col2im . builder ( ) . inputarrays ( new indarray [ ] { col } ) . outputs ( new indarray [ ] { output } ) . conv2dconfig ( conv2dconfig . builder ( ) . sy ( sy ) . sx ( sx ) . dw ( num_ ) . dh ( num_ ) . kh ( h ) . kw ( w ) . ph ( ph ) . pw ( pw ) . build ( ) ) . build ( ) ; nd4j . getexecutioner ( ) . exec ( col2im ) ; return col2im . outputarguments ( ) [ num_ ] ; }	Rearrange matrixcolumns into blocks.
public static indarray pooling2d ( indarray img , int kh , int kw , int sy , int sx , int ph , int pw , int dh , int dw , boolean issamemode , pooling2d . pooling2dtype type , pooling2d . divisor divisor , double extra , int virtualheight , int virtualwidth , indarray out ) { pooling2d pooling = pooling2d . builder ( ) . arrayinputs ( new indarray [ ] { img } ) . arrayoutputs ( new indarray [ ] { out } ) . config ( pooling2dconfig . builder ( ) . dh ( dh ) . dw ( dw ) . extra ( extra ) . kh ( kh ) . kw ( kw ) . ph ( ph ) . pw ( pw ) . issamemode ( issamemode ) . sx ( sx ) . sy ( sy ) . virtualheight ( virtualheight ) . virtualwidth ( virtualwidth ) . type ( type ) . divisor ( divisor ) . build ( ) ) . build ( ) ; nd4j . getexecutioner ( ) . exec ( pooling ) ; return out ; }	Pooling 2d implementation.
public static compressiondescriptor frombytebuffer ( bytebuffer bytebuffer ) { compressiondescriptor compressiondescriptor = new compressiondescriptor ( ) ;	Instantiate a compression descriptor fromthe given bytebuffer.
public static < u extends aggregate > list < batch < u > > getbatches ( list < u > list , int partitionsize ) { list < list < u > > partitions = lists . partition ( list , partitionsize ) ; list < batch < u > > split = new arraylist < > ( ) ; for ( list < u > partition : partitions ) { split . add ( new batch < u > ( partition ) ) ; } return split ; }	Helper method to create batch from list of aggregates, for cases when list of aggregates is higher then batchLimit.
protected static void validateconcat ( int dimension , indarray ... arrs ) { if ( arrs [ num_ ] . isscalar ( ) ) { for ( int i = num_ ; i < arrs . length ; i ++ ) if ( ! arrs [ i ] . isscalar ( ) ) throw new illegalargumentexception ( str_ ) ; } else { int dims = arrs [ num_ ] . shape ( ) . length ; long [ ] shape = arrayutil . removeindex ( arrs [ num_ ] . shape ( ) , dimension ) ; for ( int i = num_ ; i < arrs . length ; i ++ ) { assert arrays . equals ( shape , arrayutil . removeindex ( arrs [ i ] . shape ( ) , dimension ) ) ; assert arrs [ i ] . shape ( ) . length == dims ; } } }	input arrays must have same number of dimensions.
@ override public void setdtype ( databuffer . type dtype ) { assert dtype == databuffer . type . double || dtype == databuffer . type . float || dtype == databuffer . type . int : str_ ;	Sets the data opType.
@ override public indarray linspace ( int lower , int upper , int num ) { double [ ] data = new double [ num ] ; for ( int i = num_ ; i < num ; i ++ ) { double t = ( double ) i / ( num - num_ ) ; data [ i ] = lower * ( num_ - t ) + t * upper ; }	Generate a linearly spaced vector.
@ override public indarray toflattened ( collection < indarray > matrices ) { int length = num_ ; for ( indarray m : matrices ) length += m . length ( ) ; indarray ret = nd4j . create ( num_ , length ) ; int linearindex = num_ ; for ( indarray d : matrices ) { ret . put ( new indarrayindex [ ] { ndarrayindex . interval ( linearindex , linearindex + d . length ( ) ) } , d ) ; linearindex += d . length ( ) ; } return ret ; }	Returns a vector with all of the elements in every nd arrayequal to the sum of the lengths of the ndarrays.
@ override public indarray bilinearproducts ( indarray curr , indarray in ) { assert curr . shape ( ) . length == num_ ; if ( in . columns ( ) != num_ ) { throw new assertionerror ( str_ ) ; } if ( in . rows ( ) != curr . size ( curr . shape ( ) . length - num_ ) ) { throw new assertionerror ( str_ ) ; } if ( curr . size ( curr . shape ( ) . length - num_ ) != curr . size ( curr . shape ( ) . length - num_ ) ) { throw new assertionerror ( str_ ) ; } indarray ret = nd4j . create ( curr . slices ( ) , num_ ) ; indarray int = in . transpose ( ) ; for ( int i = num_ ; i < curr . slices ( ) ; i ++ ) { indarray slice = curr . slice ( i ) ; indarray inttimesslice = int . mmul ( slice ) ; ret . putscalar ( i , nd4j . getblaswrapper ( ) . dot ( inttimesslice , in ) ) ; } return ret ; }	Returns a column vector where each entry is the nth bilinearproduct of the nth slices of the two tensors.
@ override public icomplexndarray createcomplex ( double [ ] data ) { assert data . length % num_ == num_ : str_ ; return createcomplex ( data , new int [ ] { num_ , data . length / num_ } ) ; }	Creates an ndarray with the specified data.
@ override public icomplexndarray complexvalueof ( int num , double value ) { icomplexndarray ones = complexones ( num ) ; ones . assign ( nd4j . createdouble ( value , num_ ) ) ; return ones ; }	Creates an 1 x num ndarray with the specified value.
@ override public icomplexndarray complexvalueof ( int [ ] shape , double value ) { icomplexndarray ones = complexones ( shape ) ; ones . assign ( nd4j . scalar ( value ) ) ; return ones ; }	Creates an shape ndarray with the specified value.
@ override public boolean shouldreplicate ( ) { long now = system . currenttimemillis ( ) ; long diff = math . abs ( now - lastsynced ) ; return diff > synctime ; }	Returns true ifthe updater has accumulated enough ndarrays toreplicate to the workers.
@ override public icomplexnumber subi ( icomplexnumber c , icomplexnumber result ) { return result . set ( realcomponent ( ) . doublevalue ( ) - c . realcomponent ( ) . doublevalue ( ) , imaginarycomponent ( ) . doublevalue ( ) - c . imaginarycomponent ( ) . doublevalue ( ) ) ; }	Subtract two complex numbers, in-place.
public static icomplexnumber atan ( icomplexnumber num ) { complex c = new complex ( num . realcomponent ( ) . doublevalue ( ) , num . imaginarycomponent ( ) . doublevalue ( ) ) . atan ( ) ; return nd4j . createdouble ( c . getreal ( ) , c . getimaginary ( ) ) ; }	Return the sin value of the given complex number.
public static icomplexnumber ceil ( icomplexnumber num ) { complex c = new complex ( fastmath . ceil ( num . realcomponent ( ) . doublevalue ( ) ) , fastmath . ceil ( num . imaginarycomponent ( ) . doublevalue ( ) ) ) ; return nd4j . createdouble ( c . getreal ( ) , c . getimaginary ( ) ) ; }	Return the ceiling value of the given complex number.
public static icomplexnumber neg ( icomplexnumber num ) { complex c = new complex ( num . realcomponent ( ) . doublevalue ( ) , num . imaginarycomponent ( ) . doublevalue ( ) ) . negate ( ) ; return nd4j . createdouble ( c . getreal ( ) , c . getimaginary ( ) ) ; }	Return the log value of the given complex number.
public static icomplexnumber abs ( icomplexnumber num ) { double c = new complex ( num . realcomponent ( ) . doublevalue ( ) , num . imaginarycomponent ( ) . doublevalue ( ) ) . abs ( ) ; return nd4j . createdouble ( c , num_ ) ; }	Return the absolute value of the given complex number.
public static icomplexnumber pow ( icomplexnumber num , icomplexnumber power ) { complex c = new complex ( num . realcomponent ( ) . doublevalue ( ) , num . imaginarycomponent ( ) . doublevalue ( ) ) . pow ( new complex ( power . realcomponent ( ) . doublevalue ( ) , power . imaginarycomponent ( ) . doublevalue ( ) ) ) ; if ( c . isnan ( ) ) c = new complex ( nd4j . eps_threshold , num_ ) ; return nd4j . createdouble ( c . getreal ( ) , c . getimaginary ( ) ) ; }	Raise a complex number to a power.
@ override public void binarize ( double cutoff ) { indarray linear = getfeaturematrix ( ) . linearview ( ) ; for ( int i = num_ ; i < getfeatures ( ) . length ( ) ; i ++ ) { double curr = linear . getdouble ( i ) ; if ( curr > cutoff ) getfeatures ( ) . putscalar ( i , num_ ) ; else getfeatures ( ) . putscalar ( i , num_ ) ; } }	Binarizes the dataset such that any number greater than cutoff is 1 otherwise zero.
@ override public dataset sample ( int numsamples , org . nd4j . linalg . api . rng . random rng , boolean withreplacement ) { indarray examples = nd4j . create ( numsamples , getfeatures ( ) . columns ( ) ) ; indarray outcomes = nd4j . create ( numsamples , numoutcomes ( ) ) ; set < integer > added = new hashset < > ( ) ; for ( int i = num_ ; i < numsamples ; i ++ ) { int picked = rng . nextint ( numexamples ( ) ) ; if ( ! withreplacement ) while ( added . contains ( picked ) ) picked = rng . nextint ( numexamples ( ) ) ; examples . putrow ( i , get ( picked ) . getfeatures ( ) ) ; outcomes . putrow ( i , get ( picked ) . getlabels ( ) ) ; } return new dataset ( examples , outcomes ) ; }	Sample a dataset.
@ override public long getmemoryfootprint ( ) { long reqmem = features . lengthlong ( ) * nd4j . sizeofdatatype ( ) ; reqmem += labels == null ? num_ : labels . lengthlong ( ) * nd4j . sizeofdatatype ( ) ; reqmem += featuresmask == null ? num_ : featuresmask . lengthlong ( ) * nd4j . sizeofdatatype ( ) ; reqmem += labelsmask == null ? num_ : labelsmask . lengthlong ( ) * nd4j . sizeofdatatype ( ) ; return reqmem ; }	This method returns memory used by this DataSet.
public static string stringifyexception ( throwable e ) { stringwriter stm = new stringwriter ( ) ; printwriter wrt = new printwriter ( stm ) ; e . printstacktrace ( wrt ) ; wrt . close ( ) ; return stm . tostring ( ) ; }	Make a string representation of the exception.
public static string simplehostname ( string fullhostname ) { if ( inetaddresses . isinetaddress ( fullhostname ) ) { return fullhostname ; } int offset = fullhostname . indexof ( str_ ) ; if ( offset != - num_ ) { return fullhostname . substring ( num_ , offset ) ; } return fullhostname ; }	Given a full hostname, return the word upto the first dot.
public static string arraytostring ( string [ ] strs ) { if ( strs . length == num_ ) { return str_ ; } stringbuilder sbuf = new stringbuilder ( ) ; sbuf . append ( strs [ num_ ] ) ; for ( int idx = num_ ; idx < strs . length ; idx ++ ) { sbuf . append ( str_ ) ; sbuf . append ( strs [ idx ] ) ; } return sbuf . tostring ( ) ; }	Given an array of strings, return a comma-separated list of its elements.
public static string bytetohexstring ( byte [ ] bytes , int start , int end ) { if ( bytes == null ) { throw new illegalargumentexception ( str_ ) ; } stringbuilder s = new stringbuilder ( ) ; for ( int i = start ; i < end ; i ++ ) { s . append ( format ( str_ , bytes [ i ] ) ) ; } return s . tostring ( ) ; }	Given an array of bytes it will convert the bytes to a hex stringrepresentation of the bytes.
public static string [ ] getstrings ( string str , string delim ) { collection < string > values = getstringcollection ( str , delim ) ; if ( values . size ( ) == num_ ) { return null ; } return values . toarray ( new string [ values . size ( ) ] ) ; }	Returns an arraylist of strings.
public static string [ ] split ( string str , char escapechar , char separator ) { if ( str == null ) { return null ; } arraylist < string > strlist = new arraylist < string > ( ) ; stringbuilder split = new stringbuilder ( ) ; int index = num_ ; while ( ( index = findnext ( str , separator , escapechar , index , split ) ) >= num_ ) { ++ index ;	Split a string using the given separator.
public static string [ ] split ( string str , char separator ) {	Split a string using the given separator, with no escaping performed.
public static int findnext ( string str , char separator , char escapechar , int start , stringbuilder split ) { int numpreescapes = num_ ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char curchar = str . charat ( i ) ; if ( numpreescapes == num_ && curchar == separator ) {	Finds the first occurrence of the separator character ignoring the escapedseparators starting from the index.
public static string escapehtml ( string string ) { if ( string == null ) { return null ; } stringbuilder sb = new stringbuilder ( ) ; boolean lastcharacterwasspace = bool_ ; char [ ] chars = string . tochararray ( ) ; for ( char c : chars ) { if ( c == str_ ) { if ( lastcharacterwasspace ) { lastcharacterwasspace = bool_ ; sb . append ( str_ ) ; } else { lastcharacterwasspace = bool_ ; sb . append ( str_ ) ; } } else { lastcharacterwasspace = bool_ ; switch ( c ) { case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; case str_ : sb . append ( str_ ) ; break ; default : sb . append ( c ) ; break ; } } } return sb . tostring ( ) ; }	Escapes HTML Special characters present in the string.
public static string join ( charsequence separator , iterable < ? > strings ) { iterator < ? > i = strings . iterator ( ) ; if ( ! i . hasnext ( ) ) { return str_ ; } stringbuilder sb = new stringbuilder ( i . next ( ) . tostring ( ) ) ; while ( i . hasnext ( ) ) { sb . append ( separator ) ; sb . append ( i . next ( ) . tostring ( ) ) ; } return sb . tostring ( ) ; }	Concatenates strings, using a separator.
public static string camelize ( string s ) { stringbuilder sb = new stringbuilder ( ) ; string [ ] words = split ( stringutils . tolowercase ( s ) , escape_char , str_ ) ; for ( string word : words ) sb . append ( org . apache . commons . lang3 . stringutils . capitalize ( word ) ) ; return sb . tostring ( ) ; }	Convert SOME_STUFF to SomeStuff.
public static string getstacktrace ( thread t ) { final stacktraceelement [ ] stacktrace = t . getstacktrace ( ) ; stringbuilder str = new stringbuilder ( ) ; for ( stacktraceelement e : stacktrace ) { str . append ( e . tostring ( ) + str_ ) ; } return str . tostring ( ) ; }	Get stack trace for a given thread.
public static indarray invert ( indarray arr , boolean inplace ) { if ( ! arr . issquare ( ) ) { throw new illegalargumentexception ( str_ ) ; }	Inverts a matrix.
public biginteger at ( int n ) { while ( a . size ( ) <= n ) { final int lastn = a . size ( ) - num_ ; final biginteger nextn = biginteger . valueof ( lastn + num_ ) ; a . add ( a . get ( lastn ) . multiply ( nextn ) ) ; } return a . get ( n ) ; }	Compute the factorial of the non-negative integer.
public boolean isactualonhostside ( ) {	This method returns, if host side has actual copy of data.
public boolean isactualondeviceside ( ) {	This method returns, if device side has actual copy of data.
@ override public pair < databuffer , long [ ] > createshapeinformation ( int [ ] shape ) { char order = nd4j . order ( ) ; return createshapeinformation ( shape , order ) ; }	This method creates shapeInformation buffer, based on shape being passed in.
@ override public pair < databuffer , long [ ] > createshapeinformation ( long [ ] shape , char order ) { long [ ] stride = nd4j . getstrides ( shape , order ) ;	This method creates shapeInformation buffer, based on shape & order being passed in.
public static boolean isvector ( databuffer shapeinfo ) { int rank = shape . rank ( shapeinfo ) ; if ( rank > num_ || rank < num_ ) return bool_ ; else { int len = shape . length ( shapeinfo ) ; databuffer shape = shape . shapeof ( shapeinfo ) ; return shape . getint ( num_ ) == len || shape . getint ( num_ ) == len ; } }	Returns whether the given shape is a vector.
public static char getorder ( indarray arr ) { return getorder ( arr . shape ( ) , arr . stride ( ) , arr . elementstride ( ) ) ; }	Infer the order for the ndarray based on thearray's strides.
public static long offsetfor ( indarray arr , int [ ] indexes ) { shapeoffsetresolution resolution = new shapeoffsetresolution ( arr ) ; resolution . exec ( shape . toindexes ( indexes ) ) ; return resolution . getoffset ( ) ; }	Compute the offset for the given arraygiven the indices.
public static indarrayindex [ ] toindexes ( int [ ] indices ) { indarrayindex [ ] ret = new indarrayindex [ indices . length ] ; for ( int i = num_ ; i < ret . length ; i ++ ) ret [ i ] = new ndarrayindex ( indices [ i ] ) ; return ret ; }	Convert the given int indexesto nd array indexes.
protected short getshort ( long i ) { if ( datatype ( ) != type . half ) throw new unsupportedoperationexception ( str_ ) ; return fromfloat ( ( ( halfindexer ) indexer ) . get ( offset ( ) + i ) ) ; }	Special method for.
@ override public databuffer reallocate ( long length ) { pointer oldpointer = pointer ; if ( isattached ( ) ) { long capacity = length * getelementsize ( ) ; switch ( datatype ( ) ) { case double : pointer = getparentworkspace ( ) . alloc ( capacity , type . double , bool_ ) . asdoublepointer ( ) ; indexer = doubleindexer . create ( ( doublepointer ) pointer ) ; break ; case float : pointer = getparentworkspace ( ) . alloc ( capacity , type . float , bool_ ) . asfloatpointer ( ) ; indexer = floatindexer . create ( ( floatpointer ) pointer ) ; break ; case int : pointer = getparentworkspace ( ) . alloc ( capacity , type . int , bool_ ) . asintpointer ( ) ; indexer = intindexer . create ( ( intpointer ) pointer ) ; break ; } workspacegenerationid = getparentworkspace ( ) . getgenerationid ( ) ; } else { switch ( datatype ( ) ) { case int : pointer = new intpointer ( length ) ; indexer = intindexer . create ( ( intpointer ) pointer ) ; break ; case double : pointer = new doublepointer ( length ) ; indexer = doubleindexer . create ( ( doublepointer ) pointer ) ; break ; case float : pointer = new floatpointer ( length ) ; indexer = floatindexer . create ( ( floatpointer ) pointer ) ; break ; } } pointer . memcpy ( pointer , oldpointer , this . length ( ) * getelementsize ( ) ) ;	Reallocate the native memory of the buffer.
public static void copyatstride ( int n , buffertype buffertype , bytebuffer from , int fromoffset , int fromstride , bytebuffer to , int tooffset , int tostride ) {	Copy from the given from bufferto the to buffer at the specifiedoffsets and strides.
@ override public databuffer getconstantbuffer ( float [ ] array ) {	This method returns DataBuffer with contant equal to input array.PLEASE NOTE: This method assumes that you'll never ever change values within result DataBuffer.
public string kafkauri ( ) { return string . format ( str_ , kafkabrokerlist , topicname , groupid , zookeeperhost , zookeeperport , stringencoder . class . getname ( ) , stringencoder . class . getname ( ) ) ; }	Returns a kafka connection uri.
public static indarray pow ( indarray ndarray , indarray power , boolean dup ) { indarray result = ( dup ? nd4j . create ( ndarray . shape ( ) , ndarray . ordering ( ) ) : ndarray ) ; return exec ( new pow ( ndarray , power , result , ndarray . length ( ) , num_ ) ) ; }	Element-wise power function - x^y, performed element-wise.
public static indarray log ( indarray ndarray , double base , boolean duplicate ) { return nd4j . getexecutioner ( ) . exec ( new logx ( duplicate ? ndarray . dup ( ndarray . ordering ( ) ) : ndarray , base ) ) . z ( ) ; }	Log on arbitrary base.
public static indarray max ( indarray ndarray , double k , boolean dup ) { return exec ( dup ? new scalarmax ( ndarray . dup ( ) , k ) : new scalarmax ( ndarray , k ) ) ; }	Maximum function with a scalar.
public static indarray max ( indarray first , indarray second , boolean dup ) { if ( dup ) { first = first . dup ( ) ; } return exec ( new oldmax ( second , first , first , first . length ( ) ) ) ; }	Element wise maximum function between 2 INDArrays.
public static indarray min ( indarray ndarray , double k , boolean dup ) { return exec ( dup ? new scalarmin ( ndarray . dup ( ) , k ) : new scalarmin ( ndarray , k ) ) ; }	Minimum function with a scalar.
public static indarray min ( indarray first , indarray second , boolean dup ) { if ( dup ) { first = first . dup ( ) ; } return exec ( new oldmin ( second , first , first , first . length ( ) ) ) ; }	Element wise minimum function between 2 INDArrays.
public static indarray stabilize ( indarray ndarray , double k , boolean dup ) { return exec ( dup ? new stabilize ( ndarray , ndarray . dup ( ) , k ) : new stabilize ( ndarray , k ) ) ; }	Stabilize to be within a range of k.
public static indarray expm1 ( indarray ndarray , boolean dup ) { return exec ( dup ? new expm1 ( ndarray , ndarray . dup ( ) ) : new expm1 ( ndarray ) ) ; }	Elementwise exponential - 1 function.
public static indarray log1p ( indarray ndarray , boolean dup ) { return exec ( dup ? new log1p ( ndarray , ndarray . dup ( ) ) : new log1p ( ndarray ) ) ; }	Log of x + 1 function.
public static indarray [ ] preparebounds ( indarray bounds , indarray x ) { return new indarray [ ] { nd4j . valuearrayof ( x . shape ( ) , bounds . getdouble ( num_ ) ) , nd4j . valuearrayof ( x . shape ( ) , bounds . getdouble ( num_ ) ) } ; }	Prepare the boundaries for processing.
@ override public dataset next ( ) { if ( ! iter . hasnext ( ) && passes < numpasses ) { passes ++ ; batch = num_ ; log . info ( str_ + passes + str_ + batch ) ; iter . reset ( ) ; } batch ++ ; dataset next = iter . next ( ) ; if ( preprocessor != null ) preprocessor . preprocess ( next ) ; return next ; }	Returns the next element in the iteration.
public static allocationshape buildallocationshape ( databuffer buffer ) { allocationshape shape = new allocationshape ( ) ; shape . setstride ( num_ ) ; shape . setoffset ( buffer . originaloffset ( ) ) ; shape . setdatatype ( buffer . datatype ( ) ) ; shape . setlength ( buffer . length ( ) ) ; return shape ; }	This method returns AllocationShape for the whole DataBuffer.
public static boolean nameexistsinpath ( string name ) { string path = system . getenv ( path_env_variable ) ; string [ ] dirs = path . split ( file . pathseparator ) ; for ( string dir : dirs ) { file dirfile = new file ( dir ) ; if ( ! dirfile . exists ( ) ) continue ; if ( dirfile . isfile ( ) && dirfile . getname ( ) . equals ( name ) ) return bool_ ; else { iterator < file > files = fileutils . iteratefiles ( dirfile , null , bool_ ) ; while ( files . hasnext ( ) ) { file curr = files . next ( ) ; if ( curr . getname ( ) . equals ( name ) ) return bool_ ; } } } return bool_ ; }	Check if a file exists in the path.
protected void read ( objectinputstream s ) throws ioexception , classnotfoundexception { data = nd4j . createbuffer ( length , bool_ ) ; data . read ( s ) ; }	Custom deserialization for Java serialization.
protected void sweeptail ( ) { integer deviceid = allocator . getdeviceid ( ) ; int cnt = num_ ;	This method ensures the events in the beginning of FIFO queues are finished.
@ override public indarray createfromnpypointer ( pointer pointer ) { pointer datapointer = nativeops . datapointfornumpy ( pointer ) ; int databufferelementsize = nativeops . elementsizefornpyarray ( pointer ) ; databuffer data = null ; pointer shapebufferpointer = nativeops . shapebufferfornumpy ( pointer ) ; int length = nativeops . lengthforshapebufferpointer ( shapebufferpointer ) ; shapebufferpointer . capacity ( num_ * length ) ; shapebufferpointer . limit ( num_ * length ) ; shapebufferpointer . position ( num_ ) ; val intpointer = new longpointer ( shapebufferpointer ) ; databuffer shapebuffer = nd4j . createbuffer ( shapebufferpointer , databuffer . type . long , length , longrawindexer . create ( intpointer ) ) ; datapointer . position ( num_ ) ; datapointer . limit ( databufferelementsize * shape . length ( shapebuffer ) ) ; datapointer . capacity ( databufferelementsize * shape . length ( shapebuffer ) ) ;	Create from an in memory numpy pointer.
@ override public indarray createfromnpyfile ( file file ) { byte [ ] pathbytes = file . getabsolutepath ( ) . getbytes ( charset . forname ( str_ ) ) ; string otherbytes = new string ( pathbytes ) ; system . out . println ( otherbytes ) ; bytebuffer directbuffer = bytebuffer . allocatedirect ( pathbytes . length ) . order ( byteorder . nativeorder ( ) ) ; directbuffer . put ( pathbytes ) ; directbuffer . rewind ( ) ; directbuffer . position ( num_ ) ; pointer pointer = nativeops . numpyfromfile ( new bytepointer ( directbuffer ) ) ; indarray result = createfromnpypointer ( pointer ) ;	Create from a given numpy file.
@ override public pagedpointer alloc ( long requiredmemory , memorykind kind , databuffer . type datatype , boolean initialize ) { throw new unsupportedoperationexception ( str_ ) ; }	This method does allocation from a given Workspace.
@ override public void attachobject ( object object ) { if ( ! objectlocks . containskey ( object ) ) objectlocks . put ( object , new reentrantreadwritelock ( ) ) ; }	This method notifies locker, that specific object was added to tracking list.
public boolean started ( ) { return master . equals ( serverstate . started . name ( ) . tolowercase ( ) ) && responder . equals ( serverstate . started . name ( ) . tolowercase ( ) ) ; }	Returns true if bththe master and responder are started.
@ override public op exec ( op op ) { checkforcompression ( op ) ; invokewatchdog ( op ) ; if ( op instanceof accumulation ) { exec ( ( accumulation ) op , new int [ ] { integer . max_value } ) ; } else if ( op instanceof indexaccumulation ) { exec ( ( indexaccumulation ) op , new int [ ] { integer . max_value } ) ; } else if ( op instanceof scalarop || op instanceof transformop ) {	This is one of the main entry points for ops that are executed without respect to dimension.Developers note: For CudaGridExecutioner that's also the MetaOp/GridOp creation point.
@ override public void flushqueueblocking ( ) { flushqueue ( ) ;	This method forces all currently enqueued ops to be executed immediatelyPLEASE NOTE: This call is always blocking, until all queued operations are finished.
public inputstream getinputstream ( ) throws filenotfoundexception { url url = this . geturl ( ) ; if ( isjarurl ( url ) ) { try { url = extractactualurl ( url ) ; zipfile zipfile = new zipfile ( url . getfile ( ) ) ; zipentry entry = zipfile . getentry ( this . resourcename ) ; inputstream stream = zipfile . getinputstream ( entry ) ; return stream ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } } else { file srcfile = this . getfile ( ) ; return new fileinputstream ( srcfile ) ; } }	Returns requested ClassPathResource as InputStream object.
@ override public integer getdeviceforthread ( long threadid ) { if ( getnumberofdevices ( ) == num_ ) return num_ ; integer aff = affinitymap . get ( threadid ) ; if ( aff == null ) { integer deviceid = getnextdevice ( threadid ) ; affinitymap . put ( threadid , deviceid ) ; affiliated . set ( new atomicboolean ( bool_ ) ) ; if ( threadid == thread . currentthread ( ) . getid ( ) ) { nativeopsholder . getinstance ( ) . getdevicenativeops ( ) . setdevice ( new cudapointer ( deviceid ) ) ;	This method returns deviceId for given thread, identified by threadIdIf no device was assigned to this thread before this call, it'll be assinged here.
@ override public void attachthreadtodevice ( long threadid , integer deviceid ) { list < integer > devices = new arraylist < > ( cudaenvironment . getinstance ( ) . getconfiguration ( ) . getavailabledevices ( ) ) ; logger . debug ( str_ , threadid , deviceid , devices . size ( ) ) ; affinitymap . put ( threadid , deviceid ) ; }	This method pairs specified thread & device.
protected integer getnextdevice ( long threadid ) { integer device = null ; if ( ! cudaenvironment . getinstance ( ) . getconfiguration ( ) . isforcedsinglegpu ( ) && getnumberofdevices ( ) > num_ ) {	This method returns device id available.
public static string getosname ( ) { ostype ostype = calculateos ( ) ; switch ( ostype ) { case apple : return str_ ; case linux : return str_ ; case sun : return str_ ; case windows : return str_ ; } return str_ ; }	Get the name of the osfor libary discovery on the classpath.
public static archtype calculatearch ( ) { string osarch = system . getproperty ( str_ ) ; osarch = osarch . tolowercase ( locale . english ) ; if ( osarch . equals ( str_ ) || osarch . equals ( str_ ) || osarch . equals ( str_ ) ) { return archtype . x86 ; } if ( osarch . startswith ( str_ ) || osarch . startswith ( str_ ) ) { return archtype . x86_64 ; } if ( osarch . equals ( str_ ) || osarch . equals ( str_ ) ) { return archtype . ppc ; } if ( osarch . startswith ( str_ ) ) { return archtype . ppc_64 ; } if ( osarch . startswith ( str_ ) ) { return archtype . sparc ; } if ( osarch . startswith ( str_ ) ) { return archtype . arm ; } if ( osarch . startswith ( str_ ) ) { return archtype . mips ; } if ( osarch . contains ( str_ ) ) { return archtype . risc ; } return archtype . unknown ; }	Calculates the current ARCHType.
public void publish ( indarray arr ) { if ( producertemplate == null ) producertemplate = camelcontext . createproducertemplate ( ) ; producertemplate . sendbody ( str_ , arr ) ; }	Publish to a kafka topicbased on the connection information.
@ override public databuffer create ( pointer pointer , databuffer . type type , long length , indexer indexer ) { switch ( type ) { case int : return new intbuffer ( pointer , indexer , length ) ; case double : return new doublebuffer ( pointer , indexer , length ) ; case float : return new floatbuffer ( pointer , indexer , length ) ; case long : return new longbuffer ( pointer , indexer , length ) ; } throw new illegalargumentexception ( str_ + type ) ; }	Create a data buffer based on thegiven pointer, data buffer opType,and length of the buffer.
protected void interceptintdatatype ( op op ) {	This method checks if any Op operand has data opType of INT, and throws exception if any.
@ override public icomplexnumber addi ( icomplexnumber c , icomplexnumber result ) { return result . set ( result . realcomponent ( ) . floatvalue ( ) + c . realcomponent ( ) . floatvalue ( ) , result . imaginarycomponent ( ) . floatvalue ( ) + c . imaginarycomponent ( ) . floatvalue ( ) ) ; }	Add two complex numbers in-place.
@ override public void processmessage ( ) { if ( payload != null ) {	This method assigns specific value to either specific row, or whole array.Array is identified by key.
public sdvariable avgpooling3d ( sdvariable [ ] inputs , pooling3dconfig pooling3dconfig ) { pooling3d maxpooling3d = pooling3d . builder ( ) . inputs ( inputs ) . samediff ( samediff ( ) ) . pooling3dconfig ( pooling3dconfig ) . type ( pooling3d . pooling3dtype . avg ) . build ( ) ; return maxpooling3d . outputvariables ( ) [ num_ ] ; }	Avg pooling 3d operation.
public sdvariable depthwiseconv2d ( sdvariable [ ] inputs , conv2dconfig depthconv2dconfig ) { sconv2d depthwiseconv2d = sconv2d . sbuilder ( ) . inputfunctions ( inputs ) . samediff ( samediff ( ) ) . conv2dconfig ( depthconv2dconfig ) . build ( ) ; return depthwiseconv2d . outputvariables ( ) [ num_ ] ; }	Depthwise Conv2d operation. This is just separable convolution withonly the depth-wise weights specified.
public void reset ( ) { invocationscount . set ( num_ ) ; classaggergator . reset ( ) ; longaggergator . reset ( ) ; classcounter . reset ( ) ; opcounter . reset ( ) ; classpairscounter . reset ( ) ; oppairscounter . reset ( ) ; matchingcounter . reset ( ) ; matchingcounterdetailed . reset ( ) ; matchingcounterinverted . reset ( ) ; methodsaggregator . reset ( ) ; scalaraggregator . reset ( ) ; nonewsaggregator . reset ( ) ; stridedaggregator . reset ( ) ; tadnonewsaggregator . reset ( ) ; tadstridedaggregator . reset ( ) ; mixedorderaggregator . reset ( ) ; blasaggregator . reset ( ) ; blasordercounter . reset ( ) ; ordercounter . reset ( ) ; listeners . clear ( ) ; }	This method resets all counters.
protected string getopclass ( op op ) { if ( op instanceof scalarop ) { return str_ ; } else if ( op instanceof metaop ) { return str_ ; } else if ( op instanceof gridop ) { return str_ ; } else if ( op instanceof broadcastop ) { return str_ ; } else if ( op instanceof randomop ) { return str_ ; } else if ( op instanceof accumulation ) { return str_ ; } else if ( op instanceof transformop ) { if ( op . y ( ) == null ) { return str_ ; } else return str_ ; } else if ( op instanceof indexaccumulation ) { return str_ ; } else if ( op instanceof customop ) { return str_ ; } else return str_ ; }	This method returns op class opName.
public indarray storeandallocatenewarray ( ) { val shape = samediff . getshapeforvarname ( getvarname ( ) ) ; if ( getarr ( ) != null && arrays . equals ( getarr ( ) . shape ( ) , shape ) ) return getarr ( ) ; if ( varname == null ) throw new nd4jillegalstateexception ( str_ ) ; if ( shape == null ) { throw new nd4jillegalstateexception ( str_ + varname ) ; } val arr = getweightinitscheme ( ) . create ( shape ) ; samediff . putarrayforvarname ( getvarname ( ) , arr ) ; return arr ; }	Allocate and return a new arraybased on the vertex id and weight initialization.
public long [ ] getshape ( ) { long [ ] initialshape = samediff . getshapeforvarname ( getvarname ( ) ) ; if ( initialshape == null ) { val arr = getarr ( ) ; if ( arr != null ) return arr . shape ( ) ; } return initialshape ; }	Returns the shape of this variable.
public indarray eval ( ) { samediff exec = samediff . dup ( ) ; exec . definefunction ( str_ , new samediff . samedifffunctiondefinition ( ) { @ override public sdvariable [ ] define ( samediff samediff , map < string , indarray > inputs , sdvariable [ ] variableinputs ) { return new sdvariable [ ] { sdvariable . this } ; } } ) ; sdvariable output = exec . invokefunctionon ( str_ , exec ) ; return output . getsamediff ( ) . execandendresult ( ) ; }	Evaluate the result of this variable.
@ override public indarray compress ( double [ ] data , int [ ] shape , char order ) { doublepointer pointer = new doublepointer ( data ) ; databuffer shapeinfo = nd4j . getshapeinfoprovider ( ) . createshapeinformation ( shape , order ) . getfirst ( ) ; databuffer buffer = compresspointer ( databuffer . typeex . double , pointer , data . length , num_ ) ; return nd4j . createarrayfromshapebuffer ( buffer , shapeinfo ) ; }	This method creates compressed INDArray from Java double array, skipping usual INDArray instantiation routines.
public static icomplexndarray expi ( icomplexndarray toexp ) { icomplexndarray flattened = toexp . ravel ( ) ; for ( int i = num_ ; i < flattened . length ( ) ; i ++ ) { icomplexnumber n = flattened . getcomplex ( i ) ; flattened . put ( i , nd4j . scalar ( complexutil . exp ( n ) ) ) ; } return flattened . reshape ( toexp . shape ( ) ) ; }	Returns the exponential of a complex ndarray.
public static icomplexndarray center ( icomplexndarray arr , long [ ] shape ) { if ( arr . length ( ) < arrayutil . prod ( shape ) ) return arr ; for ( int i = num_ ; i < shape . length ; i ++ ) if ( shape [ i ] < num_ ) shape [ i ] = num_ ; indarray shapematrix = ndarrayutil . tondarray ( shape ) ; indarray currshape = ndarrayutil . tondarray ( arr . shape ( ) ) ; indarray startindex = transforms . floor ( currshape . sub ( shapematrix ) . divi ( nd4j . scalar ( num_ ) ) ) ; indarray endindex = startindex . add ( shapematrix ) ; indarrayindex [ ] indexes = indices . createfromstartandend ( startindex , endindex ) ; if ( shapematrix . length ( ) > num_ ) return arr . get ( indexes ) ; else { icomplexndarray ret = nd4j . createcomplex ( new int [ ] { ( int ) shapematrix . getdouble ( num_ ) } ) ; int start = ( int ) startindex . getdouble ( num_ ) ; int end = ( int ) endindex . getdouble ( num_ ) ; int count = num_ ; for ( int i = start ; i < end ; i ++ ) { ret . putscalar ( count ++ , arr . getcomplex ( i ) ) ; } return ret ; } }	Center an array.
public static icomplexndarray truncate ( icomplexndarray nd , int n , int dimension ) { if ( nd . isvector ( ) ) { icomplexndarray truncated = nd4j . createcomplex ( new int [ ] { num_ , n } ) ; for ( int i = num_ ; i < n ; i ++ ) truncated . putscalar ( i , nd . getcomplex ( i ) ) ; return truncated ; } if ( nd . size ( dimension ) > n ) { long [ ] shape = arrayutil . copy ( nd . shape ( ) ) ; shape [ dimension ] = n ; icomplexndarray ret = nd4j . createcomplex ( shape ) ; icomplexndarray ndlinear = nd . linearview ( ) ; icomplexndarray retlinear = ret . linearview ( ) ; for ( int i = num_ ; i < ret . length ( ) ; i ++ ) retlinear . putscalar ( i , ndlinear . getcomplex ( i ) ) ; return ret ; } return nd ; }	Truncates an ndarray to the specified shape.If the shape is the same or greater, it just returnsthe original array.
public static icomplexndarray padwithzeros ( icomplexndarray nd , long [ ] targetshape ) { if ( arrays . equals ( nd . shape ( ) , targetshape ) ) return nd ;	Pads an ndarray with zeros.
@ override public int iamax ( indarray arr ) { switch ( arr . data ( ) . datatype ( ) ) { case double : defaultopexecutioner . validatedatatype ( databuffer . type . double , arr ) ; return idamax ( arr . length ( ) , arr , num_ ) ; case float : defaultopexecutioner . validatedatatype ( databuffer . type . float , arr ) ; return isamax ( arr . length ( ) , arr , num_ ) ; case half : defaultopexecutioner . validatedatatype ( databuffer . type . half , arr ) ; return ihamax ( arr . length ( ) , arr , num_ ) ; default : } throw new unsupportedoperationexception ( ) ; }	Find the index of the element with maximum absolute value.
public void broadcast ( indarray array ) { if ( array == null ) return ; nd4j . getexecutioner ( ) . commit ( ) ; int numdevices = nd4j . getaffinitymanager ( ) . getnumberofdevices ( ) ; for ( int i = num_ ; i < numdevices ; i ++ ) {	This method duplicates array, and stores it to all devices.
@ override public void processmessage ( ) { vectoraggregation aggregation = new vectoraggregation ( rowindex , ( short ) voidconfiguration . getnumberofshards ( ) , shardindex , storage . getarray ( key ) . getrow ( rowindex ) . dup ( ) ) ; aggregation . setoriginatorid ( this . getoriginatorid ( ) ) ; transport . sendmessage ( aggregation ) ; }	This method will be started in context of executor, either Shard, Client or Backup node.
static public bigdecimal gamma ( mathcontext mc ) { if ( mc . getprecision ( ) < gamma . precision ( ) ) { return gamma . round ( mc ) ; } else { double eps = prec2err ( num_ , mc . getprecision ( ) ) ; mathcontext mcloc = new mathcontext ( num_ + mc . getprecision ( ) ) ; bigdecimal resul = bigdecimal . one ; resul = resul . add ( log ( num_ , mcloc ) ) ; resul = resul . subtract ( log ( num_ , mcloc ) ) ; int kmax = ( int ) ( ( math . log ( eps / num_ ) - num_ ) / num_ ) ; mcloc = new mathcontext ( num_ + err2prec ( num_ , eps / kmax ) ) ; for ( int n = num_ ; ; n ++ ) { bigdecimal c = zeta ( num_ * n + num_ , mcloc ) . subtract ( bigdecimal . one ) ; biginteger fourn = biginteger . valueof ( num_ * n + num_ ) ; fourn = fourn . shiftleft ( num_ * n ) ; c = divideround ( c , fourn ) ; resul = resul . subtract ( c ) ; if ( c . doublevalue ( ) < num_ * eps ) { break ; } } return resul . round ( mc ) ; } }	Euler-Mascheroni constant.
static public bigdecimal sqrt ( final bigdecimal x ) { if ( x . compareto ( bigdecimal . zero ) < num_ ) { throw new arithmeticexception ( str_ + x . tostring ( ) + str_ ) ; } return root ( num_ , x ) ; }	The square root.
static public bigdecimal cbrt ( final bigdecimal x ) { if ( x . compareto ( bigdecimal . zero ) < num_ ) { return root ( num_ , x . negate ( ) ) . negate ( ) ; } else { return root ( num_ , x ) ; } }	The cube root.
static public bigdecimal exp ( final mathcontext mc ) { if ( mc . getprecision ( ) < e . precision ( ) ) { return e . round ( mc ) ; } else { bigdecimal uni = scaleprec ( bigdecimal . one , mc . getprecision ( ) ) ; return exp ( uni ) ; } }	The base of the natural logarithm.
static public bigdecimal pow ( final bigdecimal x , final bigdecimal y ) { if ( x . compareto ( bigdecimal . zero ) < num_ ) { throw new arithmeticexception ( str_ + x . tostring ( ) ) ; } else if ( x . compareto ( bigdecimal . zero ) == num_ ) { return bigdecimal . zero ; } else { bigdecimal logx = log ( x ) ; bigdecimal ylogx = y . multiply ( logx ) ; bigdecimal resul = exp ( ylogx ) ; double errr = math . abs ( logx . doublevalue ( ) * y . ulp ( ) . doublevalue ( ) / num_ ) + math . abs ( y . doublevalue ( ) * x . ulp ( ) . doublevalue ( ) / num_ / x . doublevalue ( ) ) ; mathcontext mcr = new mathcontext ( err2prec ( num_ , errr ) ) ; return resul . round ( mcr ) ; } }	Power function.
static public bigdecimal powround ( final bigdecimal x , final int n ) { mathcontext mc = new mathcontext ( x . precision ( ) - ( int ) math . log10 ( ( double ) ( math . abs ( n ) ) ) ) ; return x . pow ( n , mc ) ; }	Raise to an integer power and round.
static public bigdecimal tanh ( final bigdecimal x ) { if ( x . compareto ( bigdecimal . zero ) < num_ ) { return tanh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compareto ( bigdecimal . zero ) == num_ ) { return bigdecimal . zero ; } else { bigdecimal xhighpr = scaleprec ( x , num_ ) ; bigdecimal exp2x = exp ( xhighpr . multiply ( new bigdecimal ( - num_ ) ) ) ; double eps = num_ * x . ulp ( ) . doublevalue ( ) / math . pow ( math . cosh ( x . doublevalue ( ) ) , num_ ) ; mathcontext mc = new mathcontext ( err2prec ( math . tanh ( x . doublevalue ( ) ) , eps ) ) ; return bigdecimal . one . subtract ( exp2x ) . divide ( bigdecimal . one . add ( exp2x ) , mc ) ; } }	The hyperbolic tangent.
static public bigdecimal asinh ( final bigdecimal x ) { if ( x . compareto ( bigdecimal . zero ) == num_ ) { return bigdecimal . zero ; } else { bigdecimal xhighpr = scaleprec ( x , num_ ) ; bigdecimal logx = log ( hypot ( num_ , xhighpr ) . add ( xhighpr ) ) ; double xdbl = x . doublevalue ( ) ; double eps = num_ * x . ulp ( ) . doublevalue ( ) / math . hypot ( num_ , xdbl ) ; mathcontext mc = new mathcontext ( err2prec ( logx . doublevalue ( ) , eps ) ) ; return logx . round ( mc ) ; } }	The inverse hyperbolic sine.
static public bigdecimal acosh ( final bigdecimal x ) { if ( x . compareto ( bigdecimal . one ) < num_ ) { throw new arithmeticexception ( str_ + x . tostring ( ) ) ; } else if ( x . compareto ( bigdecimal . one ) == num_ ) { return bigdecimal . zero ; } else { bigdecimal xhighpr = scaleprec ( x , num_ ) ; bigdecimal logx = log ( sqrt ( xhighpr . pow ( num_ ) . subtract ( bigdecimal . one ) ) . add ( xhighpr ) ) ; double xdbl = x . doublevalue ( ) ; double eps = num_ * x . ulp ( ) . doublevalue ( ) / math . sqrt ( xdbl * xdbl - num_ ) ; mathcontext mc = new mathcontext ( err2prec ( logx . doublevalue ( ) , eps ) ) ; return logx . round ( mc ) ; } }	The inverse hyperbolic cosine.
static public bigdecimal scaleprec ( final bigdecimal x , int d ) { return x . setscale ( d + x . scale ( ) ) ; }	Append decimal zeros to the value.
static public bigdecimal scaleprec ( final bigdecimal x , final mathcontext mc ) { final int diffpr = mc . getprecision ( ) - x . precision ( ) ; if ( diffpr > num_ ) { return scaleprec ( x , diffpr ) ; } else { return x ; } }	Boost the precision by appending decimal zeros to the value.
static public int err2prec ( bigdecimal x , bigdecimal xerr ) { return err2prec ( xerr . divide ( x , mathcontext . decimal64 ) . doublevalue ( ) ) ; }	Convert an absolute error to a precision.
public void putfunctionforid ( string id , differentialfunction function ) { if ( functioninstancesbyid . containskey ( id ) ) { throw new nd4jillegalstateexception ( str_ ) ; } else if ( function instanceof sdvariable ) { throw new nd4jillegalstateexception ( str_ ) ; } functioninstancesbyid . put ( id , function ) ; }	Put the function for id.
public string [ ] getinputsforfunction ( differentialfunction function ) { if ( ! incomingargsreverse . containskey ( function . getownname ( ) ) ) throw new nd4jillegalstateexception ( str_ + function . getownname ( ) ) ; return incomingargsreverse . get ( function . getownname ( ) ) ; }	Returns the inputs for the given function.
public void updatearrayforvarname ( string varname , indarray arr ) { if ( ! variablenametoarr . containskey ( varname ) ) { throw new nd4jillegalstateexception ( str_ + varname + str_ ) ; } variablenametoarr . put ( varname , arr ) ; reversearraylookup . put ( arr , getvariable ( varname ) ) ; }	Update the ndarray for the given vertex id.
public void putshapeforvarname ( string varname , long [ ] shape ) { if ( shape == null ) { throw new nd4jillegalstateexception ( str_ ) ; } if ( variablenametoshape . containskey ( varname ) ) { throw new nd4jillegalstateexception ( str_ + varname + str_ ) ; } for ( int i = num_ ; i < shape . length ; i ++ ) { if ( shape [ i ] < num_ ) { addasplaceholder ( varname ) ; placeholderoriginalshapes . put ( varname , shape ) ; return ; } } variablenametoshape . put ( varname , shape ) ; }	Associate a vertex id with the given shape.
public void associatearraywithvariable ( indarray arr , sdvariable variable ) { if ( variable == null ) { throw new nd4jillegalargumentexception ( str_ ) ; } if ( arr == null ) { throw new nd4jillegalargumentexception ( str_ ) ; } reversearraylookup . put ( arr , variable ) ; variablenametoarr . put ( variable . getvarname ( ) , arr ) ; if ( ! shapealreadyexistsforvarname ( variable . getvarname ( ) ) ) putshapeforvarname ( variable . getvarname ( ) , arr . shape ( ) ) ; else { updateshapeforvarname ( variable . getvarname ( ) , arr . shape ( ) ) ; } }	Associate the array with the given variable.
public < t > t getpropertyforfunction ( differentialfunction functioninstance , string propertyname ) { if ( ! propertiesforfunction . containskey ( functioninstance . getownname ( ) ) ) { return null ; } else { val map = propertiesforfunction . get ( functioninstance . getownname ( ) ) ; return ( t ) map . get ( propertyname ) ; } }	Get the property for a given function.
public void addpropertyforfunction ( differentialfunction functionfor , string propertyname , indarray property ) { addpropertyforfunction ( functionfor , propertyname , ( object ) property ) ; }	Add a property for the given function.
public void addoutgoingfor ( string [ ] varnames , differentialfunction function ) { if ( function . getownname ( ) == null ) throw new nd4jillegalstateexception ( str_ ) ; if ( outgoingargsreverse . containskey ( function . getownname ( ) ) ) { throw new nd4jillegalstateexception ( str_ + function ) ; } if ( varnames == null ) throw new nd4jillegalstateexception ( str_ ) ; for ( int i = num_ ; i < varnames . length ; i ++ ) { if ( varnames [ i ] == null ) throw new nd4jillegalstateexception ( str_ ) ; } outgoingargsreverse . put ( function . getownname ( ) , varnames ) ; outgoingargs . put ( varnames , function ) ; for ( val resultname : varnames ) { list < differentialfunction > funcs = functionoutputfor . get ( resultname ) ; if ( funcs == null ) { funcs = new arraylist < > ( ) ; functionoutputfor . put ( resultname , funcs ) ; } funcs . add ( function ) ; } }	Adds outgoing arguments to the graph.Also checks for input argumentsand updates the graph adding an appropriate edgewhen the full graph is declared.
public void addargsfor ( string [ ] variables , differentialfunction function ) { if ( function . getownname ( ) == null ) throw new nd4jillegalstateexception ( str_ ) ;	Adds incoming args to the graph.
public boolean hasargs ( differentialfunction function ) { val vertexidargs = incomingargsreverse . get ( function . getownname ( ) ) ; if ( vertexidargs != null ) { val args = incomingargs . get ( vertexidargs ) ; if ( args != null ) return bool_ ; } return bool_ ; }	Returns true if this function alreadyhas defined arguments.
public indarray [ ] eval ( map < string , indarray > inputs ) { samediff execpipeline = dup ( ) ; list < differentialfunction > opexecaction = execpipeline . exec ( ) . getright ( ) ; if ( opexecaction . isempty ( ) ) throw new illegalstateexception ( str_ ) ; indarray [ ] ret = new indarray [ opexecaction . size ( ) ] ; for ( int i = num_ ; i < ret . length ; i ++ ) { val varname = opexecaction . get ( i ) . outputvariables ( ) [ num_ ] . getvarname ( ) ; ret [ i ] = execpipeline . getarrforvarname ( varname ) ; } return ret ; }	Evaluate the given inputsbased on the current graph.
public sdvariable one ( string name , int [ ] shape ) { return var ( name , arrayutil . tolongarray ( shape ) , new constantinitscheme ( str_ , num_ ) ) ; }	Variable initializationwith 1.0.
public sdvariable oneslike ( string name , sdvariable input ) { return f ( ) . oneslike ( name , input ) ; }	Return a variable of all 1s, with the same shape as the input.
public sdvariable zeroslike ( string name , sdvariable input ) { return f ( ) . zeroslike ( name , input ) ; }	Return a variable of all 0s, with the same shape as the input.
public void removeargfromfunction ( string varname , differentialfunction function ) { val args = function . args ( ) ; for ( int i = num_ ; i < args . length ; i ++ ) { if ( args [ i ] . getvarname ( ) . equals ( varname ) ) { val reverseargs = incomingargsreverse . get ( function . getownname ( ) ) ; incomingargs . remove ( reverseargs ) ; incomingargsreverse . remove ( function . getownname ( ) ) ; val newargs = new arraylist < string > ( args . length - num_ ) ; for ( int arg = num_ ; arg < args . length ; arg ++ ) { if ( ! reverseargs [ arg ] . equals ( varname ) ) { newargs . add ( reverseargs [ arg ] ) ; } } val newargsarr = newargs . toarray ( new string [ newargs . size ( ) ] ) ; incomingargs . put ( newargsarr , function ) ; incomingargsreverse . put ( function . getownname ( ) , newargsarr ) ;	Remove an argument for a function.
public void setgradientforvariablename ( string variablename , sdvariable variable ) { if ( variable == null ) { throw new nd4jillegalstateexception ( str_ + variablename ) ; } gradients . put ( variablename , variable ) ; }	Assign a vertex idto a gradient.
public sdvariable avgpooling3d ( sdvariable [ ] inputs , pooling3dconfig pooling3dconfig ) { return avgpooling3d ( null , inputs , pooling3dconfig ) ; }	Average pooling 3d operation.
public sdvariable gru ( string basename , grucellconfiguration configuration ) { return new grucell ( this , configuration ) . outputvariables ( basename ) [ num_ ] ; }	The gru cell.
public list < differentialfunction > exec ( list < differentialfunction > ops ) { for ( int i = num_ ; i < ops . size ( ) ; i ++ ) { op op = ( op ) ops . get ( i ) ; nd4j . getexecutioner ( ) . exec ( op ) ; } return ops ; }	Executes the list of operations.This exec method is foronly invoking operationsrather than creating them.
public while whilestatement ( samediffconditional samediffconditional , samedifffunctiondefinition conditionbody , samediff . samedifffunctiondefinition loopbody , sdvariable [ ] inputvars ) { return while . builder ( ) . inputvars ( inputvars ) . condition ( conditionbody ) . predicate ( samediffconditional ) . truebody ( loopbody ) . parent ( this ) . blockname ( str_ + uuid . randomuuid ( ) . tostring ( ) ) . build ( ) ; }	Creates a while statement.
public pair < map < sdvariable , differentialfunction > , list < differentialfunction > > exec ( string functionname ) { if ( debugmode ) { return samedifffunctioninstances . get ( functionname ) . enabledebugmode ( ) . exec ( ) ; } else return samedifffunctioninstances . get ( functionname ) . exec ( ) ; }	Exec a given function.
public list < differentialfunction > exec ( string functionname , list < differentialfunction > cachedops ) { return samedifffunctioninstances . get ( functionname ) . exec ( cachedops ) ; }	Exec the given functiongiven the ops.
public indarray execbackwardandendresult ( ) { list < differentialfunction > backwards = execbackwards ( ) . getright ( ) ; differentialfunction df = backwards . get ( backwards . size ( ) - num_ ) ; if ( df instanceof op ) { return ( ( op ) df ) . z ( ) ; } else if ( df instanceof dynamiccustomop ) { return ( ( dynamiccustomop ) df ) . getoutputargument ( num_ ) ; } else { return null ; } }	Exec a backwards operationand return the end result.
public void addasplaceholder ( string varname ) { placeholdervarnames . add ( varname ) ; if ( getvariable ( varname ) != null && getvariable ( varname ) . getshape ( ) != null ) { placeholderoriginalshapes . put ( varname , getvariable ( varname ) . getshape ( ) ) ; } }	Add this vertex id as a place holder.
@ override public pointer allocate ( long bytes , memorykind kind , boolean initialize ) { atomicallocator allocator = atomicallocator . getinstance ( ) ;	This method returns Pointer to allocated memory chunkPLEASE NOTE: Cache options depend on specific implementations.
public static int lengthfordtype ( databuffer . type type ) { switch ( type ) { case double : return num_ ; case float : return num_ ; case int : return num_ ; case half : return num_ ; case long : return num_ ; case compressed : default : throw new illegalargumentexception ( str_ ) ; } }	Returns the length for the given data opType.
public static string getdtypeforname ( databuffer . type allocationmode ) { switch ( allocationmode ) { case double : return str_ ; case float : return str_ ; case int : return str_ ; case half : return str_ ; default : return str_ ; } }	Gets the name of the alocation mode.
public static databuffer . type getdtypefromcontext ( ) { try { lock . readlock ( ) . lock ( ) ; if ( dtype == null ) { lock . readlock ( ) . unlock ( ) ; lock . writelock ( ) . lock ( ) ; if ( dtype == null ) dtype = getdtypefromcontext ( nd4jcontext . getinstance ( ) . getconf ( ) . getproperty ( str_ ) ) ; lock . writelock ( ) . unlock ( ) ; lock . readlock ( ) . lock ( ) ; } return dtype ; } finally { lock . readlock ( ) . unlock ( ) ; } }	get the allocation mode from the context.
@ override public int getopnumbyname ( string opname ) { try { differentialfunction op = differentialfunctionclassholder . getinstance ( ) . getinstance ( opname ) ; return op . opnum ( ) ; } catch ( exception e ) { throw new runtimeexception ( str_ + opname + str_ , e ) ; } }	This method returns op id number for given opName.
@ override public void destroyallworkspacesforcurrentthread ( ) { ensurethreadexistense ( ) ; list < memoryworkspace > workspaces = new arraylist < > ( ) ; workspaces . addall ( backingmap . get ( ) . values ( ) ) ; for ( memoryworkspace workspace : workspaces ) { destroyworkspace ( workspace ) ; } system . gc ( ) ; }	This method destroys all workspaces allocated in current thread.
public synchronized void printallocationstatisticsforcurrentthread ( ) { ensurethreadexistense ( ) ; map < string , memoryworkspace > map = backingmap . get ( ) ; log . info ( str_ ) ; log . info ( str_ , map . size ( ) ) ; log . info ( str_ ) ; for ( string key : map . keyset ( ) ) { long current = ( ( nd4jworkspace ) map . get ( key ) ) . getcurrentsize ( ) ; long spilled = ( ( nd4jworkspace ) map . get ( key ) ) . getspilledsize ( ) ; long pinned = ( ( nd4jworkspace ) map . get ( key ) ) . getpinnedsize ( ) ; log . info ( string . format ( str_ , ( key + str_ ) , stringutils . traditionalbinaryprefix . long2string ( current , str_ , num_ ) , stringutils . traditionalbinaryprefix . long2string ( spilled , str_ , num_ ) , stringutils . traditionalbinaryprefix . long2string ( pinned , str_ , num_ ) , current , spilled , pinned ) ) ; } }	This method prints out basic statistics for workspaces allocated in current thread.
@ override public void trmv ( char order , char uplo , char transa , char diag , indarray a , indarray x ) { if ( nd4j . getexecutioner ( ) . getprofilingmode ( ) == opexecutioner . profilingmode . all ) opprofiler . getinstance ( ) . processblascall ( bool_ , a , x ) ;	trmv computes a matrix-vector product using a triangular matrix.
@ override public indarray exec ( variance accumulation , boolean biascorrected , int ... dimension ) { return processop ( accumulation ) . z ( ) ; }	Execute an accumulation along one or more dimensions.
@ override public indarray thresholddecode ( indarray encoded , indarray target ) { return backendexecutioner . thresholddecode ( encoded , target ) ; }	This method decodes thresholds array, and puts it into target array.
public string getnodename ( string name ) {	Map a tensorflow node nameto the samediff equivalentfor import.
private void invoke ( scalarop op , int [ ] dimension ) { dimension = shape . normalizeaxis ( op . x ( ) . rank ( ) , dimension ) ;	ScalarOp along dimension.
public static void assertnoworkspacesopen ( string msg ) throws nd4jworkspaceexception { if ( nd4j . getworkspacemanager ( ) . anyworkspaceactiveforcurrentthread ( ) ) { list < memoryworkspace > l = nd4j . getworkspacemanager ( ) . getallworkspacesforcurrentthread ( ) ; list < string > workspaces = new arraylist < > ( l . size ( ) ) ; for ( memoryworkspace ws : l ) { if ( ws . isscopeactive ( ) ) { workspaces . add ( ws . getid ( ) ) ; } } throw new nd4jworkspaceexception ( msg + str_ + workspaces ) ; } }	Assert that no workspaces are currently open.
private indarray negativeloglikelihood ( indarray labels , indarray alpha , indarray mu , indarray sigma ) { indarray labelsminusmu = labelsminusmu ( labels , mu ) ; indarray diffsquared = labelsminusmu . mul ( labelsminusmu ) . sum ( num_ ) ; indarray phitimesalphasum = phi ( diffsquared , sigma ) . muli ( alpha ) . sum ( num_ ) ;	This method returns an array consisting of each of the training samples,for each label in each sample, the negative log likelihood of thatvalue falling within the given gaussian mixtures.
public void requesttick ( long time , timeunit timeunit ) { long timeframems = timeunit . milliseconds . convert ( time , timeunit ) ; long currenttime = system . currenttimemillis ( ) ; boolean iswaiting = bool_ ;	This method requests to change state to Tick.PLEASE NOTE: this method is blocking, if memory is in Toe state.PLEASE NOTE: if Tick can't be acquired within specified timeframe, exception will be thrown.
public boolean tryrequesttoe ( ) { scheduletoe ( ) ; if ( istoewaiting . get ( ) || getcurrentstate ( ) == accessstate . toe ) {	This method requests to change state to ToePLEASE NOTE: this method is non-blocking, if Toe request is impossible atm, it will return false.
public void releasetoe ( ) { if ( getcurrentstate ( ) == accessstate . toe ) { if ( num_ > num_ ) {	This method requests release Toe status back to Tack.PLEASE NOTE: only the thread originally entered Toe state is able to release it.
public accessstate getcurrentstate ( ) { if ( accessstate . values ( ) [ currentstate . get ( ) ] == accessstate . toe ) { return accessstate . toe ; } else { if ( tickrequests . get ( ) <= tackrequests . get ( ) ) {	This method returns the current memory state.
@ override public void processmessage ( ) { if ( clipboard . istracking ( this . originatorid , this . gettaskid ( ) ) ) { clipboard . pin ( this ) ; if ( clipboard . isready ( this . originatorid , taskid ) ) { voidaggregation aggregation = clipboard . unpin ( this . originatorid , taskid ) ;	Vector aggregations are saved only by Shards started aggregation process. All other Shards are ignoring this meesage.
protected void initializecurrfromlist ( list < dataset > examples ) { if ( examples . isempty ( ) ) log . warn ( str_ ) ; indarray inputs = createinputmatrix ( examples . size ( ) ) ; indarray labels = createoutputmatrix ( examples . size ( ) ) ; for ( int i = num_ ; i < examples . size ( ) ; i ++ ) { inputs . putrow ( i , examples . get ( i ) . getfeaturematrix ( ) ) ; labels . putrow ( i , examples . get ( i ) . getlabels ( ) ) ; } curr = new dataset ( inputs , labels ) ; }	Initializes this data transform fetcher from the passed in datasets.
protected void inithostcollectors ( ) { for ( int i = num_ ; i < configuration . getnumberofgcthreads ( ) ; i ++ ) { referencequeue < basedatabuffer > queue = new referencequeue < > ( ) ; unifiedgarbagecollectorthread uthread = new unifiedgarbagecollectorthread ( i , queue ) ;	This method executes preconfigured number of host memory garbage collectors.
@ override public pointer getpointer ( databuffer buffer , cudacontext context ) { return memoryhandler . getdevicepointer ( buffer , context ) ; }	This method returns actual device pointer valid for current object.
@ override public void synchronizehostdata ( databuffer buffer ) {	This method should be called to make sure that data on host side is actualized.
@ override public void applyupdater ( indarray gradient , int iteration , int epoch ) { if ( historicalgradient == null ) throw new illegalstateexception ( str_ ) ; double learningrate = config . getlearningrate ( iteration , epoch ) ; double epsilon = config . getepsilon ( ) ; historicalgradient . addi ( gradient . mul ( gradient ) ) ; indarray sqrthistory = sqrt ( historicalgradient . dup ( gradientreshapeorder ) , bool_ ) . addi ( epsilon ) ;	Gets feature specific learning ratesAdagrad keeps a history of gradients being passed in.Note that each gradient passed in becomes adapted over time, hence the opName adagrad.
@ override public void synchronizetohost ( allocationpoint point ) { if ( ! point . isconstant ( ) && point . isenqueued ( ) ) { waittillfinished ( point ) ; } super . synchronizetohost ( point ) ; }	This method makes sure HOST memory contains latest data from GPUAdditionally, this method checks, that there's no ops pending execution for this array.
public static indarrayindex [ ] create ( indarray index ) { if ( index . ismatrix ( ) ) { if ( index . rows ( ) > integer . max_value ) throw new nd4jarraysizeexception ( ) ; ndarrayindex [ ] ret = new ndarrayindex [ ( int ) index . rows ( ) ] ; for ( int i = num_ ; i < index . rows ( ) ; i ++ ) { indarray row = index . getrow ( i ) ; val nums = new long [ ( int ) index . getrow ( i ) . columns ( ) ] ; for ( int j = num_ ; j < row . columns ( ) ; j ++ ) { nums [ j ] = ( int ) row . getfloat ( j ) ; } ndarrayindex idx = new ndarrayindex ( nums ) ; ret [ i ] = idx ; } return ret ; } else if ( index . isvector ( ) ) { long [ ] indices = ndarrayutil . tolongs ( index ) ; return new ndarrayindex [ ] { new ndarrayindex ( indices ) } ; } throw new illegalargumentexception ( str_ ) ; }	Create from a matrix. The rows are the indicesThe columns are the individual element in each ndarrayindex.
public map < string , object > propertiesforfunction ( ) { val fields = differentialfunctionclassholder . getinstance ( ) . getfieldsforfunction ( this ) ; map < string , object > ret = new linkedhashmap < > ( ) ; for ( val entry : fields . entryset ( ) ) { try { ret . put ( entry . getkey ( ) , fields . get ( entry . getkey ( ) ) . get ( this ) ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } } return ret ; }	Returns the properties for a given function.
public boolean hasplaceholderinputs ( ) { val args = args ( ) ; for ( val arg : args ) if ( samediff . hasplaceholdervariables ( arg ( ) . getvarname ( ) ) ) return bool_ ; return bool_ ; }	Returns true if thisfunction has place holder inputs.
public list < sdvariable > diff ( list < sdvariable > i_v1 ) { list < sdvariable > vals = dodiff ( i_v1 ) ; if ( vals == null ) { throw new illegalstateexception ( str_ + this . opname ( ) ) ; } val outputvars = args ( ) ; for ( int i = num_ ; i < vals . size ( ) ; i ++ ) { sdvariable var = outputvars [ i ] ; sdvariable grad = var . getgradient ( ) ; if ( grad != null ) { sdvariable gradvar = f ( ) . add ( grad , vals . get ( i ) ) ; try { vals . set ( i , gradvar ) ; } catch ( unsupportedoperationexception e ) { throw new unsupportedoperationexception ( str_ + this . getclass ( ) . getsimplename ( ) + str_ , e ) ; } samediff . setgradientforvariablename ( var . getvarname ( ) , gradvar ) ; } else { sdvariable gradvar = vals . get ( i ) ; samediff . updatevariablenameandreference ( gradvar , var . getvarname ( ) + str_ ) ; samediff . setgradientforvariablename ( var . getvarname ( ) , gradvar ) ; samediff . setforwardvariableforvarname ( gradvar . getvarname ( ) , var ) ; } } return vals ; }	Perform automatic differentiationwrt the input variables.
public string format ( indarray arr , boolean summarize ) { this . scientificformat = str_ ; int addprecision = this . precision ; while ( addprecision > num_ ) { this . scientificformat += str_ ; addprecision -= num_ ; } this . scientificformat = this . scientificformat + str_ ; if ( this . scientificformat . length ( ) + num_ > this . padding ) this . padding = this . scientificformat . length ( ) + num_ ; this . maxtoprintwithoutswitching = math . pow ( num_ , this . precision ) ; this . mintoprintwithoutswitching = num_ / ( this . maxtoprintwithoutswitching ) ; if ( summarize && arr . length ( ) > num_ ) return format ( arr , num_ , bool_ ) ; return format ( arr , num_ , bool_ ) ; }	Format the given ndarray as a string.
@ override public samediff importgraph ( graph_type tfgraph ) { samediff diff = samediff . create ( ) ; importstate < graph_type , tensor_type > importstate = new importstate < > ( ) ; importstate . setsamediff ( diff ) ; importstate . setgraph ( tfgraph ) ; val variablesforgraph = variablesforgraph ( tfgraph ) ; importstate . setvariables ( variablesforgraph ) ;	This method converts given TF.
@ override public blob convert ( icomplexndarray toconvert ) throws ioexception , sqlexception { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; dataoutputstream dos = new dataoutputstream ( bos ) ; nd4j . writecomplex ( toconvert , dos ) ; byte [ ] bytes = bos . tobytearray ( ) ; connection c = datasource . getconnection ( ) ; blob b = c . createblob ( ) ; b . setbytes ( num_ , bytes ) ; return b ; }	Convert an ndarray to a blob.
@ override public icomplexndarray loadcomplex ( blob blob ) throws sqlexception , ioexception { datainputstream dis = new datainputstream ( blob . getbinarystream ( ) ) ; return nd4j . readcomplex ( dis ) ; }	Load a complex ndarray from a blob.
@ override public void save ( icomplexndarray save , string id ) throws ioexception , sqlexception { dosave ( save , id ) ; }	Save the ndarray.
protected void copyrealto ( indarray arr ) { indarray linear = arr . linearview ( ) ; icomplexndarray thislinear = linearview ( ) ; if ( arr . isscalar ( ) ) arr . putscalar ( num_ , getreal ( num_ ) ) ; else for ( int i = num_ ; i < linear . length ( ) ; i ++ ) { arr . putscalar ( i , thislinear . getreal ( i ) ) ; } }	Copy real numbers to arr.
protected void copyimagto ( indarray arr ) { indarray linear = arr . linearview ( ) ; icomplexndarray thislinear = linearview ( ) ; if ( arr . isscalar ( ) ) arr . putscalar ( num_ , getreal ( num_ ) ) ; else for ( int i = num_ ; i < linear . length ( ) ; i ++ ) { arr . putscalar ( i , thislinear . getimag ( i ) ) ; } }	Copy imaginary numbers to the givenndarray.
@ override public icomplexndarray epsi ( number other ) { icomplexndarray linear = linearview ( ) ; double otherval = other . doublevalue ( ) ; for ( int i = num_ ; i < linearview ( ) . length ( ) ; i ++ ) { icomplexnumber n = linear . getcomplex ( i ) ; double real = n . realcomponent ( ) . doublevalue ( ) ; double diff = math . abs ( real - otherval ) ; if ( diff <= nd4j . eps_threshold ) linear . putscalar ( i , nd4j . createdouble ( num_ , num_ ) ) ; else linear . putscalar ( i , nd4j . createdouble ( num_ , num_ ) ) ; } return this ; }	Returns an ndarray with 1 if the element is epsilon equals.
@ override public icomplexndarray assign ( icomplexndarray arr ) { if ( ! arr . isscalar ( ) ) linalgexceptions . assertsamelength ( this , arr ) ; icomplexndarray linear = linearview ( ) ; icomplexndarray otherlinear = arr . linearview ( ) ; for ( int i = num_ ; i < linear . length ( ) ; i ++ ) { linear . putscalar ( i , otherlinear . getcomplex ( i ) ) ; } return this ; }	Assign all of the elements in the givenndarray to this ndarray.
@ override public icomplexndarray getrows ( int [ ] rindices ) { indarray rows = nd4j . create ( rindices . length , columns ( ) ) ; for ( int i = num_ ; i < rindices . length ; i ++ ) { rows . putrow ( i , getrow ( rindices [ i ] ) ) ; } return ( icomplexndarray ) rows ; }	Get whole rows from the passed indices.
@ override public icomplexndarray putrow ( long row , indarray toput ) { return ( icomplexndarray ) super . putrow ( row , toput ) ; }	Insert a row in to this arrayWill throw an exception if thisndarray is not a matrix.
@ override public icomplexndarray putcolumn ( int column , indarray toput ) { assert toput . isvector ( ) && toput . length ( ) == rows ( ) : str_ + toput . length ( ) + str_ + columns ( ) ; icomplexndarray r = getcolumn ( column ) ; if ( toput instanceof icomplexndarray ) { icomplexndarray putcomplex = ( icomplexndarray ) toput ; for ( int i = num_ ; i < r . length ( ) ; i ++ ) { icomplexnumber n = putcomplex . getcomplex ( i ) ; r . putscalar ( i , n ) ; } } else { for ( int i = num_ ; i < r . length ( ) ; i ++ ) r . putscalar ( i , nd4j . createdouble ( toput . getdouble ( i ) , num_ ) ) ; } return this ; }	Insert a column in to this arrayWill throw an exception if thisndarray is not a matrix.
@ override public icomplexndarray sub ( indarray other , indarray result ) { return dup ( ) . subi ( other , result ) ; }	copy subtraction of two matrices.
@ override public icomplexndarray add ( indarray other , indarray result ) { return dup ( ) . addi ( other , result ) ; }	copy addition of two matrices.
@ override public icomplexndarray subi ( indarray other , indarray result ) { icomplexndarray cother = ( icomplexndarray ) other ; icomplexndarray cresult = ( icomplexndarray ) result ; if ( other . isscalar ( ) ) return subi ( cother . getcomplex ( num_ ) , result ) ; if ( result == this ) nd4j . getblaswrapper ( ) . axpy ( nd4j . neg_unit , cother , cresult ) ; else if ( result == other ) { if ( data . datatype ( ) == ( databuffer . type . double ) ) { nd4j . getblaswrapper ( ) . scal ( nd4j . neg_unit . asdouble ( ) , cresult ) ; nd4j . getblaswrapper ( ) . axpy ( nd4j . unit , this , cresult ) ; } else { nd4j . getblaswrapper ( ) . scal ( nd4j . neg_unit . asfloat ( ) , cresult ) ; nd4j . getblaswrapper ( ) . axpy ( nd4j . unit , this , cresult ) ; } } else { nd4j . getblaswrapper ( ) . copy ( this , result ) ; nd4j . getblaswrapper ( ) . axpy ( nd4j . neg_unit , cother , cresult ) ; } return cresult ; }	in place subtraction of two matrices.
@ override public icomplexndarray addi ( indarray other , indarray result ) { icomplexndarray cother = ( icomplexndarray ) other ; icomplexndarray cresult = ( icomplexndarray ) result ; if ( cother . isscalar ( ) ) { return cresult . addi ( cother . getcomplex ( num_ ) , result ) ; } if ( isscalar ( ) ) { return cother . addi ( getcomplex ( num_ ) , result ) ; } if ( result == this ) { nd4j . getblaswrapper ( ) . axpy ( nd4j . unit , cother , cresult ) ; } else if ( result == other ) { nd4j . getblaswrapper ( ) . axpy ( nd4j . unit , this , cresult ) ; } else { indarray resultlinear = result . linearview ( ) ; indarray otherlinear = other . linearview ( ) ; indarray linear = linearview ( ) ; for ( int i = num_ ; i < resultlinear . length ( ) ; i ++ ) { resultlinear . putscalar ( i , otherlinear . getdouble ( i ) + linear . getdouble ( i ) ) ; } } return ( icomplexndarray ) result ; }	in place addition of two matrices.
@ override public icomplexndarray assign ( number value ) { icomplexndarray one = linearview ( ) ; for ( int i = num_ ; i < one . length ( ) ; i ++ ) one . putscalar ( i , nd4j . createdouble ( value . doublevalue ( ) , num_ ) ) ; return this ; }	Set the value of the ndarray to the specified value.
@ override public icomplexndarray ravel ( ) { if ( length ( ) >= integer . max_value ) throw new illegalargumentexception ( str_ ) ; icomplexndarray ret = nd4j . createcomplex ( ( int ) length ( ) , ordering ( ) ) ; icomplexndarray linear = linearview ( ) ; for ( int i = num_ ; i < length ( ) ; i ++ ) { ret . putscalar ( i , linear . getcomplex ( i ) ) ; } return ret ; }	Flattens the array for linear indexing.
public static icomplexndarray eigenvalues ( indarray a ) { assert a . rows ( ) == a . columns ( ) ; indarray wr = nd4j . create ( a . rows ( ) , a . rows ( ) ) ; indarray wi = wr . dup ( ) ; nd4j . getblaswrapper ( ) . geev ( str_ , str_ , a . dup ( ) , wr , wi , dummy , dummy ) ; return nd4j . createcomplex ( wr , wi ) ; }	Computes the eigenvalues of a general matrix.
public static indarray symmetricgeneralizedeigenvalues ( indarray a , indarray b ) { assert a . rows ( ) == a . columns ( ) ; assert b . rows ( ) == b . columns ( ) ; indarray w = nd4j . create ( a . rows ( ) ) ; a = invertmatrix . invert ( b , bool_ ) . mmuli ( a ) ; nd4j . getblaswrapper ( ) . syev ( str_ , str_ , a , w ) ; return w ; }	Compute generalized eigenvalues of the problem A x = L B x.The data will be unchanged, no eigenvectors returned.
@ override public int iamax ( icomplexndarray arr ) { if ( arr . data ( ) . datatype ( ) == databuffer . type . double ) return izamax ( arr . length ( ) , arr , blasbufferutil . getblasstride ( arr ) ) ; return icamax ( arr . length ( ) , arr , blasbufferutil . getblasstride ( arr ) ) ; }	finds the element of a vector that has the largest absolute value.
@ override public void copy ( icomplexndarray x , icomplexndarray y ) { if ( x . data ( ) . datatype ( ) == databuffer . type . double ) zcopy ( x . length ( ) , x , blasbufferutil . getblasstride ( x ) , y , blasbufferutil . getblasstride ( y ) ) ; else ccopy ( x . length ( ) , x , blasbufferutil . getblasstride ( x ) , y , blasbufferutil . getblasstride ( y ) ) ; }	copy a vector to another vector.
@ override public void scal ( long n , icomplexnumber alpha , icomplexndarray x ) { if ( x . data ( ) . datatype ( ) == databuffer . type . double ) zscal ( n , alpha . asdouble ( ) , x , blasbufferutil . getblasstride ( x ) ) ; else cscal ( n , alpha . asfloat ( ) , x , blasbufferutil . getblasstride ( x ) ) ; }	computes a vector by a scalar product.
@ override public void processmessage ( ) {	This method calculates dot of gives rows.
private static sdvariable nonzerocount ( sdvariable weights , sdvariable labels ) { samediff sd = weights . getsamediff ( ) ; sdvariable present = sd . neq ( weights , num_ ) ; sdvariable presentbroadcast = sd . zeroslike ( labels ) . add ( present ) ; return sd . sum ( presentbroadcast ) ; }	Determine the number of weight entries that are non-zero, after broadcasting.
private static lossinfo doreduce ( samediff sd , string outputname , boolean ismean , lossinfo . builder b , reduction reduction , sdvariable prereduceloss , sdvariable label , sdvariable weights , int [ ] dimensions ) { switch ( reduction ) { case none :	Perform the final reduction on the loss function.
public static < t > constructor < t > getnoargconstructor ( class < t > clazz ) { try { constructor < t > ctor = clazz . getdeclaredconstructor ( new class [ num_ ] ) ; ctor . setaccessible ( bool_ ) ; return ctor ; } catch ( nosuchmethodexception e ) {	Throw an IllegalStateException if the class does not have a no-arg constructor.
public static methodhandle getconstructor ( class < ? > clazz , class < ? > ... args ) { try {	Gets a constructor that has the specified types of arguments.Throw an IllegalStateException if the class does not have such a constructor.
public static < t > t invoke ( methodhandle methodhandle , object ... params ) { try { return ( t ) methodhandle . invokewitharguments ( params ) ; } catch ( runtimeexception e ) { throw e ; } catch ( throwable throwable ) { throw new runtimeexception ( throwable ) ; } }	Wraps any non-runtime exceptions with a runtime exception.
@ suppresswarnings ( str_ ) public static < a extends annotation > a getannotation ( annotation [ ] annotations , class < a > annotationtype ) { for ( annotation anno : annotations ) if ( annotationtype . isassignablefrom ( anno . getclass ( ) ) ) return ( a ) anno ; return null ; }	Gets the annotation that has the specified type, or null if there isn't one.
public static < a extends annotation > a getdeclaredannotation ( class < ? > onclass , class < a > annotationtype ) { return getannotation ( onclass . getdeclaredannotations ( ) , annotationtype ) ; }	Get the declared annotation, ignoring any inherited annotations.
public static < a extends annotation > boolean isdeclaredannotationpresent ( class < ? > onclass , class < a > annotationtype ) { return getdeclaredannotation ( onclass , annotationtype ) != null ; }	Is the declared annotation present, ignoring any inherited annotations.
@ suppresswarnings ( str_ ) public static < s > s create ( class < ? super s > interf , result < s > result ) { return ( s ) proxy . newproxyinstance ( result . getclass ( ) . getclassloader ( ) , new class [ ] { interf } , new resultproxy < > ( result ) ) ; }	Create a ResultProxy for the given interface.
public p load ( final baseentity < ? > ent , final loadcontext ctx ) { try {	Converts an entity to an object of the appropriate type for this metadata structure.Does not check that the entity is appropriate; that should be done when choosingwhich EntityMetadata to call.
public fullentity < ? > save ( final p pojo , final savecontext ctx ) { try { return translator . save ( pojo , bool_ , ctx , path . root ( ) ) . get ( ) ; } catch ( saveexception ex ) { throw ex ; } catch ( exception ex ) { throw new saveexception ( pojo , ex ) ; } }	Converts an object to a datastore Entity with the appropriate Key type.
public static memcacheservice createproxy ( final memcacheservice raw , final int retrycount ) { return ( memcacheservice ) java . lang . reflect . proxy . newproxyinstance ( raw . getclass ( ) . getclassloader ( ) , raw . getclass ( ) . getinterfaces ( ) , new memcacheserviceretryproxy ( raw , retrycount ) ) ; }	Create the proxy that does retries.
public < t > entitymetadata < t > getmetadatasafe ( string kind ) throws illegalargumentexception { entitymetadata < t > metadata = this . getmetadata ( kind ) ; if ( metadata == null ) throw new illegalargumentexception ( str_ + kind + str_ ) ; else return metadata ; }	Gets metadata for the specified kind.
public < t > queryresults < key < t > > querykeysonly ( final keyquery query ) { log . trace ( str_ ) ; return new keyqueryresults < > ( ds . run ( query ) ) ; }	Perform a keys-only query.
public < t > queryresults < t > queryhybrid ( final keyquery query , final int chunksize ) { log . trace ( str_ ) ; final queryresults < key < t > > results = new keyqueryresults < > ( ds . run ( query ) ) ; return new hybridqueryresults < > ( loader . createloadengine ( ) , results , chunksize ) ; }	Perform a keys-only plus batch gets.
public < t > queryresults < t > querynormal ( final entityquery query , final int chunksize ) { log . trace ( str_ ) ;	A normal, non-hybrid query.
public < t > queryresults < t > queryprojection ( final projectionentityquery query ) { log . trace ( str_ ) ; final loadengine loadengine = loader . createloadengine ( ) ; return new projectionqueryresults < > ( ds . run ( query ) , loadengine ) ; }	A projection query. Bypasses the session entirely.
public int querycount ( final keyquery query ) { log . trace ( str_ ) ; final queryresults < com . google . cloud . datastore . key > results = ds . run ( query ) ; return iterators . size ( results ) ; }	The fundamental query count operation.
private < t > iterator < iterator < t > > safepartition ( final iterator < t > input , int chunksize ) {	Detects Integer.MAX_VALUE and prevents OOM exceptions.
private iterator < resultwithcursor < t > > load ( final iterator < resultwithcursor < key < t > > > keys ) { final list < entry < resultwithcursor < key < t > > , result < t > > > results = lists . newarraylist ( ) ; while ( keys . hasnext ( ) ) { final resultwithcursor < key < t > > next = keys . next ( ) ; results . add ( maps . immutableentry ( next , loadengine . load ( next . getresult ( ) ) ) ) ; } loadengine . execute ( ) ; return iterators . transform ( results . iterator ( ) , entry -> new resultwithcursor < > ( entry . getvalue ( ) . now ( ) , entry . getkey ( ) . getcursorafter ( ) ) ) ; }	Loads them; note that it's possible for some loaded results to be null.
public static string msg ( path path , string msg ) { stringbuilder bld = new stringbuilder ( ) ; bld . append ( str_ ) ; bld . append ( path . topathstring ( ) ) ; if ( bld . length ( ) < path_padding ) while ( bld . length ( ) < path_padding ) bld . append ( str_ ) ; else bld . append ( str_ ) ; bld . append ( msg ) ; return bld . tostring ( ) ; }	Create a log a message for a given path.
public static < t > key < t > create ( final t pojo ) { return objectifyservice . factory ( ) . keys ( ) . keyof ( pojo ) ; }	Create a key from a registered POJO entity.
private int comparetowithidentityhash ( final object k1 , final object k2 ) { return integer . compare ( system . identityhashcode ( k1 ) , system . identityhashcode ( k2 ) ) ; }	I have no idea what this is about, it was in the old logic.
public static < v > key < v > key ( final com . google . cloud . datastore . key raw ) { if ( raw == null ) return null ; else return new key < > ( raw ) ; }	Easy null-safe conversion of the raw key.
public static com . google . cloud . datastore . key key ( final key < ? > typed ) { if ( typed == null ) return null ; else return typed . getraw ( ) ; }	Easy null-safe conversion of the typed key.
private static string getkindhere ( final class < ? > clazz ) {	Get the kind from the class if the class has an .
static boolean ismissingtypeparameters ( type type ) { if ( type instanceof class ) { for ( class < ? > clazz = ( class < ? > ) type ; clazz != null ; clazz = clazz . getenclosingclass ( ) ) { if ( clazz . gettypeparameters ( ) . length != num_ ) return bool_ ; } return bool_ ; } else if ( type instanceof parameterizedtype ) { return bool_ ; } else { throw new assertionerror ( str_ + type . getclass ( ) ) ; } }	Checks if the given type is a class that is supposed to have type parameters, but doesn't.In other words, if it's a really raw type.
public static boolean issupertype ( type supertype , type subtype ) { if ( supertype instanceof parameterizedtype || supertype instanceof class || supertype instanceof genericarraytype ) { class < ? > superclass = erase ( supertype ) ; type mappedsubtype = getexactsupertype ( capture ( subtype ) , superclass ) ; if ( mappedsubtype == null ) { return bool_ ; } else if ( supertype instanceof class < ? > ) { return bool_ ; } else if ( mappedsubtype instanceof class < ? > ) {	Checks if the capture of subType is a subtype of superType.
private static type [ ] getexactdirectsupertypes ( type type ) { if ( type instanceof parameterizedtype || type instanceof class ) { class < ? > clazz ; if ( type instanceof parameterizedtype ) { clazz = ( class < ? > ) ( ( parameterizedtype ) type ) . getrawtype ( ) ; } else {	Returns the direct supertypes of the given type.
public static type capture ( type type ) { if ( type instanceof parameterizedtype ) { return capture ( ( parameterizedtype ) type ) ; } else { return type ; } }	Applies capture conversion to the given type.
public < p , d > translator < p , d > gettranslator ( final typekey < p > tk , final createcontext ctx , final path path ) { return factory . gettranslators ( ) . get ( tk , ctx , path ) ; }	Get the relevant translator, creating it if necessary.
@ suppresswarnings ( str_ ) public < p > populator < p > getpopulator ( final class < p > clazz , final path path ) { if ( clazz == null || clazz . equals ( object . class ) ) { return ( populator < p > ) nullpopulator . instance ; } else { final classtranslator < p > classtranslator = ( classtranslator < p > ) this . < p , fullentity < ? > > gettranslator ( new typekey < > ( clazz ) , this , path ) ; return classtranslator . getpopulator ( ) ; } }	Get the populator for the specified class.
private boolean getindexinstruction ( class < p > clazz ) { index ind = clazz . getannotation ( index . class ) ; unindex unind = clazz . getannotation ( unindex . class ) ; if ( ind != null && unind != null ) throw new illegalstateexception ( str_ + clazz ) ; if ( ind != null ) return bool_ ; else if ( unind != null ) return bool_ ; else return null ; }	Figure out if there is an index instruction for the whole class.
private boolean isofinterest ( method method ) { for ( annotation [ ] annos : method . getparameterannotations ( ) ) if ( typeutils . getannotation ( annos , alsoload . class ) != null ) return bool_ ; return bool_ ; }	Determine if we should create a Property for the method (ie, .
private list < property > getdeclaredproperties ( objectifyfactory fact , class < ? > clazz ) { list < property > good = new arraylist < > ( ) ; for ( field field : clazz . getdeclaredfields ( ) ) if ( isofinterest ( field ) ) good . add ( new fieldproperty ( fact , clazz , field ) ) ; for ( method method : clazz . getdeclaredmethods ( ) ) if ( isofinterest ( method ) ) good . add ( new methodproperty ( method ) ) ; return good ; }	Get all the persistable fields and methods declared on a class.
public keymetadata < p > getkeymetadata ( ) { final populator < object > populator = props . get ( num_ ) ; preconditions . checkstate ( populator instanceof keypopulator , str_ + this . clazz ) ; return ( ( keypopulator < p > ) populator ) . getkeymetadata ( ) ; }	Gets the key metadata but only if this was an .
public < t > result < t > get ( final key < t > key ) { assert ! isexecuted ( ) ; sessionvalue < t > sv = getsession ( ) . get ( key ) ; if ( sv == null ) { log . trace ( str_ , key ) ; this . pending . add ( key . getraw ( ) ) ; result < t > result = new resultcache < t > ( ) { @ override @ suppresswarnings ( str_ ) public t nowuncached ( ) {	Gets a result, using the session cache if possible.
public void execute ( ) { if ( needsexecution ( ) ) { log . trace ( str_ , pending ) ; result < map < com . google . cloud . datastore . key , entity > > fetched = fetchpending ( ) ; translated = loadengine . translate ( fetched ) ;	Turn this into a result set.
private result < map < com . google . cloud . datastore . key , entity > > fetchpending ( ) {	Possibly pulls some values from the stuffed collection.
private void addindexeddiscriminators ( final class < ? > clazz ) { if ( clazz == object . class ) return ; this . addindexeddiscriminators ( clazz . getsuperclass ( ) ) ; final subclass sub = clazz . getannotation ( subclass . class ) ; if ( sub != null && sub . index ( ) ) { final string disc = ( sub . name ( ) . length ( ) > num_ ) ? sub . name ( ) : clazz . getsimplename ( ) ; this . indexeddiscriminators . add ( stringvalue . of ( disc ) ) ; } }	Recursively go through the class hierarchy adding any discriminators that are indexed.
public void registersubclass ( classtranslator < ? extends p > translator ) { bydiscriminator . put ( translator . getdiscriminator ( ) , translator ) ; subclass sub = translator . getdeclaredclass ( ) . getannotation ( subclass . class ) ; for ( string alsoload : sub . alsoload ( ) ) bydiscriminator . put ( alsoload , translator ) ; byclass . put ( translator . getdeclaredclass ( ) , translator ) ; }	Register a subclass translator with this class translator.
public static type getcollectioncomponenttype ( type collectiontype ) { type componenttype = generictypereflector . gettypeparameter ( collectiontype , collection . class . gettypeparameters ( ) [ num_ ] ) ; if ( componenttype == null )	Get the component type of a Collection.
public static type getmapkeytype ( type maptype ) { type componenttype = generictypereflector . gettypeparameter ( maptype , map . class . gettypeparameters ( ) [ num_ ] ) ; if ( componenttype == null )	Get the key type of a Map.
public static forwardpath of ( path path ) { forwardpath next = new forwardpath ( path ) ; if ( path . getprevious ( ) == path . root ( ) ) return next ; forwardpath previous = of ( path . getprevious ( ) ) ; previous . next = next ; return previous ; }	Recursive method which reverses the path into a ForwardPath.
public path getfinalpath ( ) { forwardpath here = this ; while ( here . next != null ) here = here . next ; return here . getpath ( ) ; }	Get the complete path in this chain, typically for error messages or debugging.
public string topathstring ( ) { if ( this == root ) { return str_ ; } else { stringbuilder builder = new stringbuilder ( ) ; topathstring ( builder ) ; return builder . tostring ( ) ; } }	Create the full x.y.z string.
public int depth ( ) { int depth = num_ ; path here = this ; while ( here != root ) { depth ++ ; here = here . previous ; } return depth ; }	ROOT is 0, top level Entity properties are 1, embedded things are higher.
public void putall ( final collection < bucket > updates ) { final set < key > good = this . cacheputifuntouched ( updates ) ; if ( good . size ( ) == updates . size ( ) ) return ;	Update a set of buckets with new values.
public void empty ( final iterable < key > keys ) { final map < key , object > updates = new hashmap < > ( ) ; for ( final key key : keys ) if ( cachecontrol . iscacheable ( key ) ) updates . put ( key , null ) ; this . memcachewithretry . putall ( updates ) ; }	Revert a set of keys to the empty state.
private set < key > cacheputifuntouched ( final iterable < bucket > buckets ) { final map < key , casput > payload = new hashmap < > ( ) ; final set < key > successes = new hashset < > ( ) ; for ( final bucket buck : buckets ) { if ( ! buck . iscacheable ( ) ) { successes . add ( buck . getkey ( ) ) ; continue ; } final integer expiryseconds = cachecontrol . getexpiryseconds ( buck . getkey ( ) ) ; if ( expiryseconds == null ) { successes . add ( buck . getkey ( ) ) ; continue ; } payload . put ( buck . getkey ( ) , new casput ( buck . identifiablevalue , buck . getnexttostore ( ) , expiryseconds ) ) ; } successes . addall ( this . memcache . putifuntouched ( payload ) ) ; return successes ; }	Put buckets in the cache, checking for cacheability and collisions.
private map < key , object > cachegetall ( final collection < key > keys ) { try { return this . memcache . getall ( keys ) ; } catch ( exception ex ) {	Bulk get on keys, getting the raw objects.
public static set < key > keysof ( final collection < bucket > buckets ) { return buckets . stream ( ) . map ( bucket :: getkey ) . collect ( collectors . toset ( ) ) ; }	Basically a list comprehension of the keys for convenience.
@ suppresswarnings ( str_ ) public < k extends incompletekey > void setkey ( final fullentity . builder < k > container , final p pojo ) { final incompletekey rawkey = getincompletekey ( pojo ) ; if ( ! ( rawkey instanceof com . google . cloud . datastore . key ) ) {	Sets the key on a container from the POJO.
public void setlongid ( p pojo , long id ) { if ( ! clazz . isassignablefrom ( pojo . getclass ( ) ) ) throw new illegalargumentexception ( str_ + clazz . getname ( ) + str_ + pojo . getclass ( ) . getname ( ) ) ; this . idmeta . getproperty ( ) . set ( pojo , id ) ; }	Sets the numeric id field.
private com . google . cloud . datastore . key getparentraw ( p pojo ) { if ( parentmeta == null ) return null ; final value < object > value = parentmeta . getvalue ( pojo , new savecontext ( ) , path . root ( ) ) ; return ( value == null || value . gettype ( ) == valuetype . null ) ? null : ( com . google . cloud . datastore . key ) value . get ( ) ; }	Get the contents of the .
private void registersubclass ( final classtranslator < p > translator , final typekey < ? super p > superclasstypekey , final createcontext ctx , final path path ) { if ( superclasstypekey . gettypeasclass ( ) == object . class ) return ; @ suppresswarnings ( str_ ) final classtranslator < ? super p > supertranslator = create ( ( typekey ) superclasstypekey , ctx , path ) ; supertranslator . registersubclass ( translator ) ; registersubclass ( translator , new typekey < > ( superclasstypekey . gettypeasclass ( ) . getsuperclass ( ) ) , ctx , path ) ; }	Recursively register this subclass with all the superclass translators.
private static boolean couldhavecommonsubtype ( type type1 , type type2 ) {	Checks if the intersection of two types is not empty.
private static type transformowner ( type givenowner , class < ? > clazz ) { if ( givenowner == null ) {	Transforms the given owner type into an appropriate one when constructing a parameterized type.
public < a extends annotation > a getannotationanywhere ( class < a > annotationtype ) { a anno = getannotation ( annotationtype ) ; if ( anno == null ) { class < ? > clazz = ( class < ? > ) generictypereflector . erase ( type ) ; return clazz . getannotation ( annotationtype ) ; } else { return anno ; } }	Checks not only the listed annotations but also annotations on the class.
public void addall ( final session other ) { if ( log . istraceenabled ( ) ) log . trace ( str_ , other . map . keyset ( ) ) ; map . putall ( other . map ) ; }	Add all entries in the other session to this one.
public < t > result < t > load ( final key < t > key ) { if ( key == null ) throw new nullpointerexception ( str_ ) ; final result < t > result = round . get ( key ) ;	Gets the result, possibly from the session, putting it in the session if necessary.Also will recursively prepare the session with .
public void execute ( ) { if ( round . needsexecution ( ) ) { round old = round ; round = old . next ( ) ; old . execute ( ) ; } }	Starts asychronous fetching of the batch.
public result < map < key < ? > , object > > translate ( final result < map < com . google . cloud . datastore . key , entity > > raw ) { return new resultcache < map < key < ? > , object > > ( ) { private loadcontext ctx ; @ override public map < key < ? > , object > nowuncached ( ) { final map < key < ? > , object > result = new hashmap < > ( raw . now ( ) . size ( ) * num_ ) ; ctx = new loadcontext ( loadengine . this ) ; for ( final entity ent : raw . now ( ) . values ( ) ) { final key < ? > key = key . create ( ent . getkey ( ) ) ; final object entity = load ( ent , ctx ) ; result . put ( key , entity ) ; } return result ; } @ override protected void postexecutehook ( ) { ctx . done ( ) ; ctx = null ; } } ; }	Asynchronously translate raw to processed; might produce successive load operations as refs are filled in.
public result < map < com . google . cloud . datastore . key , entity > > fetch ( set < com . google . cloud . datastore . key > keys ) { log . debug ( str_ , keys . size ( ) , keys ) ; final future < map < com . google . cloud . datastore . key , entity > > fut = datastore . get ( keys , readoptions . toarray ( new readoption [ readoptions . size ( ) ] ) ) ; return resultadapter . create ( fut ) ; }	Fetch the keys from the async datastore using the current transaction context.
@ suppresswarnings ( str_ ) public < t > t load ( final baseentity < com . google . cloud . datastore . key > ent , final loadcontext ctx ) { if ( ent == null ) return null ; final entitymetadata < t > meta = ofy . factory ( ) . getmetadata ( ent . getkey ( ) . getkind ( ) ) ; if ( meta == null ) return ( t ) ent ; else return meta . load ( ent , ctx ) ; }	Converts a datastore entity into a typed pojo object.
public com . google . cloud . datastore . key createrawany ( final com . google . cloud . datastore . key parent , final string kind , final object id ) { if ( id instanceof string ) return createraw ( parent , kind , ( string ) id ) ; else if ( id instanceof long ) return createraw ( parent , kind , ( long ) id ) ; else throw new illegalargumentexception ( str_ + id + str_ ) ; }	Construct a Key from a Long or String id.
public static com . google . cloud . datastore . key raw ( final key < ? > key ) { return key == null ? null : key . getraw ( ) ; }	Null-safe extraction of the raw key.
@ suppresswarnings ( str_ ) public static < s > value < s > getidvalue ( final incompletekey key ) { if ( key instanceof com . google . cloud . datastore . key ) { final com . google . cloud . datastore . key completekey = ( com . google . cloud . datastore . key ) key ; if ( completekey . hasid ( ) ) return ( value < s > ) longvalue . of ( completekey . getid ( ) ) ; else return ( value < s > ) stringvalue . of ( completekey . getname ( ) ) ; } else { return null ; } }	Gets the String or Long id from the key as a Value, or null if incomplete.
@ sneakythrows public static com . google . cloud . datastore . key fromurlsafe ( final string urlsafekey ) { if ( urlsafekey . startswith ( str_ ) ) { return keyformat . instance . parseoldstyleappenginekey ( urlsafekey ) ; } else { return com . google . cloud . datastore . key . fromurlsafe ( urlsafekey ) ; } }	Understands both the legacy format "ag1zfnZvb2Rvb2R5bmUwcgcLEgFCGAEM" and new format,providing the key either way.
@ override public objectifyimpl transactionless ( final objectifyimpl parent ) { return parent . makenew ( next -> new transactorno ( next , parenttransactor . getsession ( ) ) ) ; }	This version goes back to life without a transaction, but preserves current options.We use the session from the parent, ie life before transactions.
@ override public < r > r transactnew ( final objectifyimpl parent , final int limittries , final work < r > work ) { return transactionless ( parent ) . transactnew ( limittries , work ) ; }	We need to make sure the parentSession is the transactionless session, not the sessionfor our transaction.
private < r > r transactonce ( final objectifyimpl parent , final work < r > work ) { final objectifyimpl txnofy = factory . open ( parent . getoptions ( ) , next -> new transactoryes ( next , this ) ) ; boolean committedsuccessfully = bool_ ; try { final r result = work . run ( ) ; txnofy . flush ( ) ; txnofy . gettransaction ( ) . commit ( ) ; committedsuccessfully = bool_ ; return result ; } finally { if ( txnofy . gettransaction ( ) . isactive ( ) ) { try { txnofy . gettransaction ( ) . rollback ( ) ; } catch ( runtimeexception ex ) { log . error ( str_ , ex ) ; } } txnofy . close ( ) ; if ( committedsuccessfully ) { ( ( privateasynctransaction ) txnofy . gettransaction ( ) ) . runcommitlisteners ( ) ; } } }	One attempt at executing a transaction.
private boolean matches ( object onpojo , if < ? , ? > [ ] conditions ) { if ( conditions == null ) return bool_ ; object value = this . get ( onpojo ) ; for ( if < ? , ? > condition : conditions ) { @ suppresswarnings ( str_ ) if < object , object > cond = ( if < object , object > ) condition ; if ( cond . matchesvalue ( value ) ) return bool_ ; if ( cond . matchespojo ( onpojo ) ) return bool_ ; } return bool_ ; }	Tests whether a set of conditions match.
private objectify ofy ( ) {	Get the current objectify instance associated with this ref.
public asyncdatastore asyncdatastore ( final boolean enableglobalcache ) { if ( this . entitymemcache != null && enableglobalcache && this . registrar . iscacheenabled ( ) ) return new cachingasyncdatastore ( asyncdatastore ( ) , this . entitymemcache ) ; else return asyncdatastore ( ) ; }	Might produce a caching version if caching is enabled.
@ suppresswarnings ( str_ ) public < t > entitymetadata < t > getmetadataforentity ( final t obj ) throws illegalargumentexception {	Named differently so you don't accidentally use the Object form.
private < t > keyrange < t > allocate ( final incompletekey incompletekey , final int num ) { final incompletekey [ ] allocations = new incompletekey [ num ] ; arrays . fill ( allocations , incompletekey ) ; final list < key < t > > typedkeys = datastore ( ) . allocateid ( allocations ) . stream ( ) . map ( key :: < t > create ) . collect ( collectors . tolist ( ) ) ; return new keyrange < > ( typedkeys ) ; }	Allocate num copies of the incompleteKey.
public objectifyimpl open ( final objectifyoptions opts , final transactorsupplier transactorsupplier ) { final objectifyimpl objectify = new objectifyimpl ( this , opts , transactorsupplier ) ; stacks . get ( ) . add ( objectify ) ; return objectify ; }	This is only public because it is used from the impl package; don't use this as a public API.
public void close ( final objectify ofy ) { final deque < objectify > stack = stacks . get ( ) ; if ( stack . isempty ( ) ) throw new illegalstateexception ( str_ ) ; final objectify popped = stack . removelast ( ) ; assert popped == ofy : str_ ; }	Pops context off of stack after a transaction completes.
public static void homogenizeindexes ( final list < value < ? > > list ) { if ( isindexhomogeneous ( list ) ) return ; for ( int i = num_ ; i < list . size ( ) ; i ++ ) { final value < ? > value = list . get ( i ) ; if ( value . excludefromindexes ( ) ) list . set ( i , index ( value , bool_ ) ) ; } }	The datastore has a weird behavior of reordering values in a list so that indexed ones come before nonindexedones.
public static < t > ref < t > create ( t value ) { key < t > key = key . create ( value ) ; return create ( key ) ; }	Creates a Ref from a registered pojo entity.
final public t safe ( ) throws notfoundexception { t t = this . get ( ) ; if ( t == null ) throw new notfoundexception ( key ( ) ) ; else return t ; }	Obtain the entity value, throwing an exception if the entity was not found.
public boolean add ( k key , v value ) { list < v > list = this . get ( key ) ; if ( list == null ) { list = new arraylist < > ( ) ; this . put ( key , list ) ; } return list . add ( value ) ; }	Adds a value to the set associated with the key.
@ override public boolean isdone ( ) { boolean done = this . raw . isdone ( ) ; if ( ! triggered && done ) { this . triggered = bool_ ; pendingfutures . removepending ( this ) ; this . trigger ( ) ; } return done ; }	This version also checks to see if we are done and we still need to call the trigger.If so, it calls it.
public if < ? , ? > [ ] generateifconditions ( class < ? extends if < ? , ? > > [ ] ifclasses , field field ) { if ( ifclasses . length == num_ ) return always ; if < ? , ? > [ ] result = new if < ? , ? > [ ifclasses . length ] ; for ( int i = num_ ; i < ifclasses . length ; i ++ ) { class < ? extends if < ? , ? > > ifclass = ifclasses [ i ] ; result [ i ] = this . createif ( ifclass , field ) ;	Clever enough to recognize that an empty set of conditions means Always.
public void done ( ) { engine . execute ( ) ; while ( deferred != null ) { final list < runnable > runme = deferred ; deferred = null ;	Call this when a load process completes.
public object getcontainer ( type containertype , path path ) { class < ? > containerclass = generictypereflector . erase ( containertype ) ; iterator < object > containersit = containers . descendingiterator ( ) ;	Get the container object which is appropriate for the specified property.
private stat getstat ( string kind ) { stat stat = this . stats . get ( kind ) ; if ( stat == null ) { stat = new stat ( ) ; this . stats . put ( kind , stat ) ; } return stat ; }	We're just tracking statistics so we don't really need to worry about these stepping on each other;if there's a hit or miss lost no big deal.
public static void unwrapandthrow ( throwable ex ) { if ( ex instanceof runtimeexception ) throw ( runtimeexception ) ex ; else if ( ex instanceof error ) throw ( error ) ex ; else if ( ex instanceof executionexception ) unwrapandthrow ( ex . getcause ( ) ) ; else throw new undeclaredthrowableexception ( ex ) ; }	Properly unwraps ExecutionException, throwing the relevant original cause.
public < p , d > translator < p , d > get ( final typekey tk , final createcontext ctx , final path path ) { translator < ? , ? > translator = translators . get ( tk ) ; if ( translator == null ) { translator = create ( tk , ctx , path ) ; translators . put ( tk , translator ) ; }	Obtains the Translator appropriate for this type and annotations.
public < p > translator < p , fullentity < ? > > getroot ( final class < p > clazz ) { return get ( new typekey ( clazz ) , new createcontext ( fact ) , path . root ( ) ) ; }	Get the translator for a root entity class.
private translator < ? , ? > create ( final typekey tk , final createcontext ctx , final path path ) { for ( final translatorfactory < ? , ? > trans : this . translatorfactories ) { @ suppresswarnings ( str_ ) final translator < ? , ? > sofar = trans . create ( tk , ctx , path ) ; if ( sofar != null ) return sofar ; } throw new illegalargumentexception ( str_ + tk . gettype ( ) + str_ + arrays . tostring ( tk . getannotations ( ) ) ) ; }	Create a translator from scratch by going through the discovery process.
@ override public void load ( final fullentity < ? > container , final loadcontext ctx , final path containerpath , final p intopojo ) { try { if ( translator instanceof recycles ) ctx . recycle ( property . get ( intopojo ) ) ; final value < d > value = ( translator instanceof synthetic ) ? null : getpropertyfromcontainer ( container , containerpath ) ;	Gets the appropriate value from the container and sets it on the appropriate field of the pojo.
private value < d > getpropertyfromcontainer ( final fullentity < ? > container , final path containerpath ) { string foundname = null ; value < d > value = null ; for ( string name : property . getloadnames ( ) ) { if ( container . contains ( name ) ) { if ( foundname != null ) throw new illegalstateexception ( str_ + property . getname ( ) + str_ + containerpath . extend ( foundname ) + str_ + containerpath . extend ( name ) + str_ ) ;	Gets the relevant property from the container, detecting alsoload collisions.
public void setvalue ( final object pojo , final value < d > value , final loadcontext ctx , final path containerpath ) throws skipexception { final path propertypath = containerpath . extend ( property . getname ( ) ) ; final p loaded = translator . load ( value , ctx , propertypath ) ; setonpojo ( pojo , loaded , ctx , propertypath ) ; }	Set this raw datastore value on the relevant property of the pojo, doing whatever translations are necessary.
@ override public void save ( final p onpojo , boolean index , final savecontext ctx , final path containerpath , final fullentity . builder < ? > into ) { if ( property . issaved ( onpojo ) ) {	Gets the appropriate field value from the pojo and puts it in the container at the appropriate prop nameand with the appropriate indexing.
public value < d > getvalue ( final object pojo , final savecontext ctx , final path containerpath ) { @ suppresswarnings ( str_ ) final p value = ( p ) property . get ( pojo ) ; return translator . save ( value , bool_ , ctx , containerpath . extend ( property . getname ( ) ) ) ; }	Get the value for the property and translate it into datastore format.
@ suppresswarnings ( str_ ) protected final < em extends extendablemessage < em > > void writeextensions ( em msg , jsongenerator gen ) throws ioexception { boolean openext = bool_ ; for ( map . entry < fielddescriptor , object > field : msg . getallfields ( ) . entryset ( ) ) { fielddescriptor fd = field . getkey ( ) ; if ( fd . isextension ( ) ) { if ( fd . isrepeated ( ) ) { list < object > extvalue = ( list < object > ) field . getvalue ( ) ; if ( ! extvalue . isempty ( ) ) { openrtbjsonextwriter < object > extwriter = factory . getwriter ( msg . getclass ( ) , extvalue . get ( num_ ) . getclass ( ) , fd . getname ( ) ) ; if ( extwriter != null ) { openext = openext ( gen , openext ) ; extwriter . writerepeated ( extvalue , gen ) ; } } } else { object extvalue = field . getvalue ( ) ; openrtbjsonextwriter < object > extwriter = factory . getwriter ( msg . getclass ( ) , extvalue . getclass ( ) , fd . getname ( ) ) ; if ( extwriter != null ) { openext = openext ( gen , openext ) ; extwriter . writesingle ( extvalue , gen ) ; } } } } if ( openext ) { gen . writeendobject ( ) ; } }	Write any extensions that may exist in a message.
protected final boolean writecontentcategory ( string cat , jsongenerator gen ) throws ioexception { if ( ! factory . isstrict ( ) || openrtbutils . categoryfromname ( cat ) != null ) { gen . writestring ( cat ) ; return bool_ ; } else { return bool_ ; } }	Writes a string that represents a ContentCategory's JSON name, returning success status.If the factory is in strict mode, the category name is validated.
protected final void writecontentcategories ( string fieldname , list < string > cats , jsongenerator gen ) throws ioexception { if ( ! cats . isempty ( ) ) { gen . writearrayfieldstart ( fieldname ) ; for ( string cat : cats ) { writecontentcategory ( cat , gen ) ; } gen . writeendarray ( ) ; } }	Writes an array of ContentCategory if not empty.
public string process ( snippetprocessorcontext ctx , string snippet ) { checknotnull ( ctx ) ; stringbuilder sb = ctx . builder ( ) ; sb . setlength ( num_ ) ; string currsnippet = snippet ; boolean processedmacros = bool_ ; int snippetpos = num_ ; int macropos = currsnippet . indexof ( str_ ) ; while ( macropos != - num_ ) { sb . append ( currsnippet . substring ( snippetpos , macropos ) ) ; int macroend = processmacroat ( ctx , currsnippet , macropos ) ; if ( macroend == - num_ ) { sb . append ( str_ ) ; snippetpos = macropos + num_ ; } else { snippetpos = macroend ; processedmacros = bool_ ; } macropos = currsnippet . indexof ( str_ , snippetpos ) ; } if ( processedmacros ) { sb . append ( currsnippet , snippetpos , currsnippet . length ( ) ) ; currsnippet = sb . tostring ( ) ; } sb . setlength ( num_ ) ; string ret = urlencode ( ctx , currsnippet ) ; sb . setlength ( num_ ) ; return ret ; }	Processes the raw snippet that was set by the bid, making any transformations necessary.
public static iterable < bid . builder > bids ( bidresponse . builder response ) { return new responsebidsiterator ( response , seat_any , null ) ; }	Iterates all bids.
@ nullable public static bid . builder bidwithid ( bidresponse . builder response , string id ) { checknotnull ( id ) ; for ( seatbid . builder seatbid : response . getseatbidbuilderlist ( ) ) { for ( bid . builder bid : seatbid . getbidbuilderlist ( ) ) { if ( id . equals ( bid . getid ( ) ) ) { return bid ; } } } return null ; }	Finds a bid by ID.
public static boolean updatebids ( bidresponse . builder response , function < bid . builder , boolean > updater ) { checknotnull ( updater ) ; boolean updated = bool_ ; for ( seatbid . builder seatbid : response . getseatbidbuilderlist ( ) ) { updated |= protoutils . update ( seatbid . getbidbuilderlist ( ) , updater ) ; } return updated ; }	Updates bids, from all seats.
public static boolean removebids ( bidresponse . builder response , predicate < bid . builder > filter ) { checknotnull ( filter ) ; boolean updated = bool_ ; for ( seatbid . builder seatbid : response . getseatbidbuilderlist ( ) ) { updated |= removebids ( seatbid , filter ) ; } return updated ; }	Remove bids by bid.
protected final < eb extends extendablebuilder < ? , eb > > void readextensions ( eb msg , jsonparser par ) throws ioexception { @ suppresswarnings ( str_ ) set < openrtbjsonextreader < eb > > extreaders = factory . getreaders ( ( class < eb > ) msg . getclass ( ) ) ; if ( extreaders . isempty ( ) ) { par . skipchildren ( ) ; return ; } startobject ( par ) ; jsontoken toklast = par . getcurrenttoken ( ) ; jsonlocation loclast = par . getcurrentlocation ( ) ; while ( bool_ ) { boolean extread = bool_ ; for ( openrtbjsonextreader < eb > extreader : extreaders ) { if ( extreader . filter ( par ) ) { extreader . read ( msg , par ) ; jsontoken toknew = par . getcurrenttoken ( ) ; jsonlocation locnew = par . getcurrentlocation ( ) ; boolean advanced = toknew != toklast || ! locnew . equals ( loclast ) ; extread |= advanced ; if ( ! endobject ( par ) ) { return ; } else if ( advanced && par . getcurrenttoken ( ) != jsontoken . field_name ) { toklast = par . nexttoken ( ) ; loclast = par . getcurrentlocation ( ) ; } else { toklast = toknew ; loclast = locnew ; } } } if ( ! endobject ( par ) ) {	Read any extensions that may exist in a message.
protected final boolean emptytonull ( jsonparser par ) throws ioexception { jsontoken token = par . getcurrenttoken ( ) ; if ( token == null ) { token = par . nexttoken ( ) ; } return ! factory ( ) . isstrict ( ) && token == null ; }	Special case for empty-string input. Returning null in non-.
public final < eb extends extendablebuilder < ? , eb > > openrtbjsonfactory register ( openrtbjsonextreader < eb > extreader , class < eb > msgklass ) { extreaders . put ( msgklass . getname ( ) , extreader ) ; return this ; }	Register an extension reader.
public final < t > openrtbjsonfactory register ( openrtbjsonextwriter < t > extwriter , class < t > extklass , class < ? extends message > msgklass , string fieldname ) { map < string , map < string , openrtbjsonextwriter < ? > > > mapmsg = extwriters . get ( msgklass . getname ( ) ) ; if ( mapmsg == null ) { extwriters . put ( msgklass . getname ( ) , mapmsg = new linkedhashmap < > ( ) ) ; } map < string , openrtbjsonextwriter < ? > > mapklass = mapmsg . get ( extklass . getname ( ) ) ; if ( mapklass == null ) { mapmsg . put ( extklass . getname ( ) , mapklass = new linkedhashmap < > ( ) ) ; } mapklass . put ( fieldname == null ? fieldname_all : fieldname , extwriter ) ; return this ; }	Register an extension writer, bound to a specific field name.
public void process ( snippetprocessorcontext bidctx ) { for ( seatbid . builder seat : bidctx . response ( ) . getseatbidbuilderlist ( ) ) { for ( bid . builder bid : seat . getbidbuilderlist ( ) ) { bidctx . setbid ( bid ) ; processfields ( bidctx ) ; } } }	Processes the context's response in-place, modifying properties that may contain macros.
protected void processfields ( snippetprocessorcontext bidctx ) { bid . builder bid = bidctx . getbid ( ) ;	Processes all fields of a bid that should support macro expansion.
public static < b extends messagelite . builder > boolean update ( iterable < b > objs , function < b , boolean > updater ) { checknotnull ( updater ) ; boolean updated = bool_ ; for ( b obj : objs ) { updated |= updater . apply ( obj ) ; } return updated ; }	Updates every builder from a sequence.
public static < m extends messageliteorbuilder > list < m > filter ( list < m > objs , predicate < m > filter ) { checknotnull ( filter ) ; for ( int i = num_ ; i < objs . size ( ) ; ++ i ) { if ( ! filter . test ( objs . get ( i ) ) ) {	Runs a filter through a sequence of objects.
public static string getcurrentname ( jsonparser par ) throws ioexception { string name = par . getcurrentname ( ) ; return name == null ? str_ : name ; }	Returns the current field name, or empty string if none.
public static void startobject ( jsonparser par ) throws ioexception { jsontoken token = par . getcurrenttoken ( ) ; if ( token == null || token == jsontoken . field_name ) { token = par . nexttoken ( ) ; } if ( token == jsontoken . start_object ) { par . nexttoken ( ) ; } else { throw new jsonparseexception ( par , str_ ) ; } }	Starts an Object, skipping the '{' token, and if necessary a field name before it.
public static void startarray ( jsonparser par ) throws ioexception { jsontoken token = par . getcurrenttoken ( ) ; if ( token == null || token == jsontoken . field_name ) { token = par . nexttoken ( ) ; } if ( token == jsontoken . start_array ) { par . nexttoken ( ) ; } else { throw new jsonparseexception ( par , str_ ) ; } }	Starts an Array, skipping the '[' token, and if necessary a field name before it.
public static jsontoken peektoken ( jsonparser par ) throws ioexception { jsontoken token = par . getcurrenttoken ( ) ; if ( token == null || token == jsontoken . field_name ) { token = par . nexttoken ( ) ; } return token ; }	Skips a field name if necessary, returning the current token then.
public static void writeintboolfield ( string fieldname , boolean data , jsongenerator gen ) throws ioexception { gen . writenumberfield ( fieldname , data ? num_ : num_ ) ; }	Writes a boolean as int, where false = 0 and true = 1.
public static void writestrings ( string fieldname , list < string > data , jsongenerator gen ) throws ioexception { if ( ! data . isempty ( ) ) { gen . writearrayfieldstart ( fieldname ) ; for ( string d : data ) { gen . writestring ( d ) ; } gen . writeendarray ( ) ; } }	Writes a string array if not empty.
public static void writeints ( string fieldname , list < integer > data , jsongenerator gen ) throws ioexception { if ( ! data . isempty ( ) ) { gen . writearrayfieldstart ( fieldname ) ; for ( integer d : data ) { gen . writenumber ( d ) ; } gen . writeendarray ( ) ; } }	Writes an int array if not empty.
public static void writelongs ( string fieldname , list < long > data , jsongenerator gen ) throws ioexception { if ( ! data . isempty ( ) ) { gen . writearrayfieldstart ( fieldname ) ; for ( long d : data ) { writelong ( d , gen ) ; } gen . writeendarray ( ) ; } }	Writes a long array if not empty, using quotes for values that are too big.
public static void writeenums ( string fieldname , list < ? extends protocolmessageenum > enums , jsongenerator gen ) throws ioexception { if ( ! enums . isempty ( ) ) { gen . writearrayfieldstart ( fieldname ) ; for ( protocolmessageenum e : enums ) { writeenum ( e , gen ) ; } gen . writeendarray ( ) ; } }	Writes a enum array if not empty.
public static url resolveurl ( url base , string target ) throws malformedurlexception { target = target . trim ( ) ; if ( target . startswith ( str_ ) ) { return fixpurequerytargets ( base , target ) ; } return new url ( base , target ) ; }	Resolve relative URL-s and fix a few java.net.URL errors in handling ofURLs with embedded params and pure query targets.
static url fixpurequerytargets ( url base , string target ) throws malformedurlexception { if ( ! target . startswith ( str_ ) ) return new url ( base , target ) ; string basepath = base . getpath ( ) ; string baserightmost = str_ ; int baserightmostidx = basepath . lastindexof ( str_ ) ; if ( baserightmostidx != - num_ ) { baserightmost = basepath . substring ( baserightmostidx + num_ ) ; } if ( target . startswith ( str_ ) ) target = baserightmost + target ; return new url ( base , target ) ; }	Handle the case in RFC3986 section 5.4.1 example 7, and similar.
public static string [ ] gethostsegments ( url url ) { string host = url . gethost ( ) ;	Partitions of the hostname of the url by ".".
public static string gethost ( string url ) { try { return new url ( url ) . gethost ( ) . tolowercase ( locale . root ) ; } catch ( malformedurlexception e ) { return null ; } }	Returns the lowercased hostname for the url or null if the url is notwell formed.
public static string getpage ( string url ) { try {	Returns the page for the url.
public static list < string > loadlistfromconf ( string paramkey , map stormconf ) { object obj = stormconf . get ( paramkey ) ; list < string > list = new linkedlist < > ( ) ; if ( obj == null ) return list ; if ( obj instanceof persistentvector ) { list . addall ( ( persistentvector ) obj ) ; } else {	Return one or more Strings regardless of whether they are represented asa single String or a list in the config or an empty List if no valuecould be found for that key.
public static map extractconfigelement ( map conf ) { if ( conf . size ( ) == num_ ) { object confnode = conf . get ( str_ ) ; if ( confnode != null && confnode instanceof map ) { conf = ( map ) confnode ; } } return conf ; }	If the config consists of a single key 'config', its values are usedinstead.
public synchronized protocol getprotocol ( url url ) {	Returns an instance of the protocol to use for a given URL.
public static byte [ ] generatewarcinfo ( map < string , string > fields ) { stringbuffer buffer = new stringbuffer ( ) ; buffer . append ( warc_version ) ; buffer . append ( crlf ) ; buffer . append ( str_ ) . append ( crlf ) ; string mainid = uuid . randomuuid ( ) . tostring ( ) ;	Generates a WARC info entry which can be stored at the beginning of eachWARC file.
public static string extractrefreshurl ( string value ) { if ( stringutils . isblank ( value ) ) return null ;	Returns a normalised value of the content attribute for the refresh tag.
public metadata getmetaforoutlink ( string targeturl , string sourceurl , metadata parentmd ) { metadata md = _filter ( parentmd , mdtotransfer ) ;	Determine which metadata should be transfered to an outlink.
public metadata filter ( metadata metadata ) { metadata filtered_md = _filter ( metadata , mdtotransfer ) ;	Determine which metadata should be persisted for a given documentincluding those which are not necessarily transferred to the outlinks.
public static void add ( string url , metadata md , date nextfetch ) { log . debug ( str_ , url , md , nextfetch ) ; scheduledurl tuple = new scheduledurl ( url , md , nextfetch ) ; synchronized ( queue ) { queue . add ( tuple ) ; } }	Add a new URL.
public static string cleanfieldname ( string name ) { string lowercase = name . tolowercase ( ) ; lowercase = lowercase . replaceall ( str_ , str_ ) ; if ( lowercase . length ( ) < num_ || lowercase . length ( ) > num_ ) throw new runtimeexception ( str_ + lowercase ) ; if ( lowercase . equals ( str_ ) ) throw new runtimeexception ( str_ ) ; return lowercase ; }	Remove the non-cloudSearch-legal characters.
private static string getcharsetfrombom ( final byte [ ] bytedata ) { bominputstream bomin = new bominputstream ( new bytearrayinputstream ( bytedata ) ) ; try { byteordermark bom = bomin . getbom ( ) ; if ( bom != null ) { return bom . getcharsetname ( ) ; } } catch ( ioexception e ) { return null ; } return null ; }	Detects any BOMs and returns the corresponding charset.
private static string getcharsetfromtext ( byte [ ] content , string declaredcharset , int maxlengthcharsetdetection ) { string charset = null ;	Use a third party library as last resort to guess the charset from thebytes.
private static string getcharsetfrommeta ( byte buffer [ ] , int maxlength ) {	Attempt to find a META tag in the HTML that hints at the character setused to write the document.
private final boolean sniff ( byte [ ] content ) { byte [ ] beginning = content ; if ( content . length > maxoffsetguess && maxoffsetguess > num_ ) { beginning = arrays . copyofrange ( content , num_ , maxoffsetguess ) ; } int position = bytes . indexof ( beginning , clue ) ; if ( position != - num_ ) { return bool_ ; } return bool_ ; }	Examines the first bytes of the content for a clue of whether thisdocument is a sitemap, based on namespaces.
public void setvalue ( string key , string value ) { md . put ( key , new string [ ] { value } ) ; }	Set the value for a given key.
public static string getfirstvalue ( metadata md , string ... keys ) { for ( string key : keys ) { string val = md . getfirstvalue ( key ) ; if ( stringutils . isblank ( val ) ) continue ; return val ; } return null ; }	Returns the first non empty value found for the keys or null if nonefound.
public static list < cookie > getcookies ( string [ ] cookiesstrings , url targeturl ) { arraylist < cookie > list = new arraylist < cookie > ( ) ; for ( string cs : cookiesstrings ) { string name = null ; string value = null ; string expires = null ; string domain = null ; string path = null ; boolean secure = bool_ ; string [ ] tokens = cs . split ( str_ ) ; int equals = tokens [ num_ ] . indexof ( str_ ) ; name = tokens [ num_ ] . substring ( num_ , equals ) ; value = tokens [ num_ ] . substring ( equals + num_ ) ; for ( int i = num_ ; i < tokens . length ; i ++ ) { string ti = tokens [ i ] . trim ( ) ; if ( ti . equalsignorecase ( str_ ) ) secure = bool_ ; if ( ti . tolowercase ( ) . startswith ( str_ ) ) { path = ti . substring ( num_ ) ; } if ( ti . tolowercase ( ) . startswith ( str_ ) ) { domain = ti . substring ( num_ ) ; } if ( ti . tolowercase ( ) . startswith ( str_ ) ) { expires = ti . substring ( num_ ) ; } } basicclientcookie cookie = new basicclientcookie ( name , value ) ;	Get a list of cookies based on the cookies string taken from responseheader and the target url.
public static boolean checkdomainmatchtourl ( string cookiedomain , string urlhostname ) { try { if ( cookiedomain . startswith ( str_ ) ) { cookiedomain = cookiedomain . substring ( num_ ) ; } string [ ] domaintokens = cookiedomain . split ( str_ ) ; string [ ] hosttokens = urlhostname . split ( str_ ) ; int tokendif = hosttokens . length - domaintokens . length ; if ( tokendif < num_ ) { return bool_ ; } for ( int i = domaintokens . length - num_ ; i >= num_ ; i -- ) { if ( ! domaintokens [ i ] . equalsignorecase ( hosttokens [ i + tokendif ] ) ) { return bool_ ; } } return bool_ ; } catch ( exception e ) { return bool_ ; } }	Helper method to check if url matches a cookie domain.
protected static string getcachekey ( url url ) { string protocol = url . getprotocol ( ) . tolowercase ( locale . root ) ; string host = url . gethost ( ) . tolowercase ( locale . root ) ; int port = url . getport ( ) ; if ( port == - num_ ) { port = url . getdefaultport ( ) ; } return protocol + str_ + host + str_ + port ; }	Compose unique key to store and access robot rules in cache for given URL.
public baserobotrules getrobotrulessetfromcache ( url url ) { string cachekey = getcachekey ( url ) ; baserobotrules robotrules = cache . getifpresent ( cachekey ) ; if ( robotrules != null ) { return robotrules ; } return empty_rules ; }	Returns the robots rules from the cache or empty rules if not found.
public void extractmetatags ( documentfragment doc ) throws xpathexpressionexception { nodelist nodes = ( nodelist ) expression . evaluate ( doc , xpathconstants . nodeset ) ; if ( nodes == null ) return ; int numnodes = nodes . getlength ( ) ; for ( int i = num_ ; i < numnodes ; i ++ ) { node n = ( node ) nodes . item ( i ) ;	called by the parser bolts.
protected final void ack ( tuple t , string url ) {	Must be called by extending classes to store and collect in one go.
public boolean filter ( string url , metadata metadata ) throws malformedurlexception { url u = new url ( url ) ;	Try the rules from the hostname, domain name, metadata and global scopesin this order.
@ override public string filter ( url sourceurl , metadata sourcemetadata , string urlstring ) { iterator < rule > i = rules . iterator ( ) ; while ( i . hasnext ( ) ) { rule r = i . next ( ) ; matcher matcher = r . pattern . matcher ( urlstring ) ; urlstring = matcher . replaceall ( r . substitution ) ; } if ( urlstring . equals ( str_ ) ) { urlstring = null ; } return urlstring ; }	This function does the replacements by iterating through all the regexpatterns.
private list < rule > readrules ( string rulesfile ) { try { inputstream regexstream = getclass ( ) . getclassloader ( ) . getresourceasstream ( rulesfile ) ; reader reader = new inputstreamreader ( regexstream , standardcharsets . utf_8 ) ; return readconfiguration ( reader ) ; } catch ( exception e ) { log . error ( str_ , e ) ; return empty_rules ; } }	Reads the configuration file and populates a List of Rules.
private string processqueryelements ( string urltofilter ) { try {	Basic filter to remove query parameters from urls so parameters thatdon't change the content of the page can be removed.
@ suppresswarnings ( str_ ) public static navigationfilters fromconf ( map stormconf ) { string configfile = confutils . getstring ( stormconf , str_ ) ; if ( stringutils . isnotblank ( configfile ) ) { try { return new navigationfilters ( stormconf , configfile ) ; } catch ( ioexception e ) { string message = str_ + configfile ; log . error ( message ) ; throw new runtimeexception ( message , e ) ; } } return navigationfilters . emptynavigationfilters ; }	Loads and configure the NavigationFilters based on the storm config ifthere is one otherwise returns an emptyNavigationFilters.
public gziphdfsbolt addrecordformat ( recordformat format , int position ) { multiplerecordformat formats ; if ( this . format == null ) { formats = new multiplerecordformat ( format ) ; this . format = formats ; } else { if ( this . format instanceof multiplerecordformat ) { formats = ( multiplerecordformat ) this . format ; } else { formats = new multiplerecordformat ( this . format ) ; this . format = formats ; } formats . addformat ( new gzippedrecordformat ( format ) , position ) ; } return this ; }	Add an additional record format at given position.
private long throttlequeries ( ) { if ( timelastquerysent != num_ ) {	Returns the amount of time to wait if the backend was queried toorecently and needs throttling or -1 if the backend can be queriedstraight away.
private boolean triggerqueries ( ) { if ( timelastqueryreceived != num_ && maxdelaybetweenqueries > num_ ) {	Indicates whether enough time has elapsed since receiving the results ofthe previous query so that a new one can be sent even if the buffer isnot empty.
@ suppresswarnings ( str_ ) public static parsefilters fromconf ( map stormconf ) { string parseconfigfile = confutils . getstring ( stormconf , str_ ) ; if ( stringutils . isnotblank ( parseconfigfile ) ) { try { return new parsefilters ( stormconf , parseconfigfile ) ; } catch ( ioexception e ) { string message = str_ + parseconfigfile ; log . error ( message ) ; throw new runtimeexception ( message , e ) ; } } return parsefilters . emptyparsefilter ; }	Loads and configure the ParseFilters based on the storm config if thereis one otherwise returns an emptyParseFilter.
protected void append ( node newnode ) throws org . xml . sax . saxexception { node currentnode = m_currentnode ; if ( null != currentnode ) { currentnode . appendchild ( newnode ) ;	Append a node to the current container.
@ override public void processinginstruction ( string target , string data ) throws org . xml . sax . saxexception { append ( m_doc . createprocessinginstruction ( target , data ) ) ; }	Receive notification of a processing instruction.
@ override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . saxexception {	Report an XML comment anywhere in the document.This callback will be used for comments inside or outside the documentelement, including comments in the external DTD subset (if read).
@ override public void startdtd ( string name , string publicid , string systemid ) throws org . xml . sax . saxexception {	Report the start of DTD declarations, if any.Any declarations are assumed to be in the internal subset unlessotherwise indicated.
protected string valueforurl ( tuple tuple ) { string url = tuple . getstringbyfield ( str_ ) ; metadata metadata = ( metadata ) tuple . getvaluebyfield ( str_ ) ;	Returns the value to be used as the URL for indexing purposes, if presentthe canonical value is used instead.
protected string trimtext ( string text ) { if ( maxlengthtext == - num_ ) return text ; if ( text == null ) return text ; if ( text . length ( ) <= maxlengthtext ) return text ; return text . substring ( num_ , maxlengthtext ) ; }	Returns a trimmed string or the original one if it is below the thresholdset in the configuration.
protected final optional < integer > checkcustominterval ( metadata metadata , status s ) { if ( customintervals == null ) return optional . empty ( ) ; for ( custominterval custominterval : customintervals ) { string [ ] values = metadata . getvalues ( custominterval . key ) ; if ( values == null ) { continue ; } for ( string v : values ) { if ( v . equals ( custominterval . value ) ) { return custominterval . getdurationforstatus ( s ) ; } } } return optional . empty ( ) ; }	Returns the first matching custom interval.
public static urlfilters fromconf ( map stormconf ) { string configfile = confutils . getstring ( stormconf , str_ ) ; if ( stringutils . isnotblank ( configfile ) ) { try { return new urlfilters ( stormconf , configfile ) ; } catch ( ioexception e ) { string message = str_ + configfile ; log . error ( message ) ; throw new runtimeexception ( message , e ) ; } } return urlfilters . emptyurlfilters ; }	Loads and configure the URLFilters based on the storm config if there isone otherwise returns an empty URLFilter.
public void setwheelitemcount ( int count ) { mitemcount = count ; mitemangle = calculateitemangle ( count ) ; if ( mwheelbounds != null ) { invalidate ( ) ;	Sets the number of items to be displayed on the wheel.
public static int resolvesizeandstate ( int size , int measurespec ) { int result = size ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; switch ( specmode ) { case measurespec . unspecified : result = size ; break ; case measurespec . at_most : if ( specsize < size ) { result = specsize ; } else { result = size ; } break ; case measurespec . exactly : result = specsize ; break ; } return result ; }	Taken and modified from Android Source for API < 11.
public void setemptyitemdrawable ( drawable drawable ) { memptyitemdrawable = drawable ; empty_cache_item . mdrawable = drawable ; if ( mwheelbounds != null ) { invalidate ( ) ; } }	Sets the empty item drawable that is drawn when outside of the adapter range.
public void setangle ( float angle ) { mangle = angle ; updateselectedposition ( ) ; if ( monanglechangelistener != null ) { monanglechangelistener . onwheelanglechange ( mangle ) ; } invalidate ( ) ; }	Set the angle of the wheel instantaneously.Note this does not animate to the provided angle.
private void updateselectedposition ( ) { int position = ( int ) ( ( - mangle + - num_ * math . signum ( mangle ) * mitemangle ) / mitemangle ) ; setselectedposition ( position ) ; }	Checks to see if the selectedPosition has changed.
public void invalidatewheelitemdrawable ( int position ) { int adapterpos = rawpositiontoadapterposition ( position ) ; if ( isemptyitemposition ( adapterpos ) ) return ; cacheitem cacheitem = mitemcachearray [ adapterpos ] ; if ( cacheitem != null ) cacheitem . mdirty = bool_ ; invalidate ( ) ; }	Invalidate the drawable at the specific position so that the next Draw callwill refresh the Drawable at this given position in the adapter.
public int rawpositiontowheelposition ( int position , int adapterposition ) { int circularoffset = misrepeatable ? ( ( int ) math . floor ( ( position / ( float ) madapteritemcount ) ) * ( madapteritemcount - mitemcount ) ) : num_ ; return circle . clamp ( adapterposition + circularoffset , mitemcount ) ; }	Converts the raw position to a position within the wheel item bounds.
private void update ( float deltatime ) { float vel = mangularvelocity ; float velsqr = vel * vel ; if ( vel > num_ ) {	Estimates the wheel's new angle and angular velocity.
private int getcontrastcolor ( map . entry < string , integer > entry ) { string colorname = materialcolor . getcolorname ( entry ) ; return materialcolor . getcontrastcolor ( colorname ) ; }	get the materials darker contrast.
static int clamp ( int value , int upperlimit ) { if ( value < num_ ) { return value + ( - num_ * ( int ) math . floor ( value / ( float ) upperlimit ) ) * upperlimit ; } else { return value % upperlimit ; } }	Clamps the value to a number between 0 and the upperLimit.
protected void writecoveralls ( final jsonwriter writer , final sourcecallback sourcecallback , final list < coverageparser > parsers ) throws processingexception , ioexception { try { getlog ( ) . info ( str_ + writer . getcoverallsfile ( ) . getabsolutepath ( ) + str_ ) ; long now = system . currenttimemillis ( ) ; sourcecallback . onbegin ( ) ; for ( coverageparser parser : parsers ) { getlog ( ) . info ( str_ + parser . getcoveragefile ( ) . getabsolutepath ( ) ) ; parser . parse ( sourcecallback ) ; } sourcecallback . oncomplete ( ) ; long duration = system . currenttimemillis ( ) - now ; getlog ( ) . info ( str_ + duration + str_ ) ; } finally { writer . close ( ) ; } }	Writes coverage data to JSON file.
@ override public bytebuffer getdataasbytebuffer ( ) { bytebuffer bb = bytebuffer . allocate ( ( int ) getsize ( ) ) ; resetlocaliterator ( ) ; while ( hasnext ( ) ) bb . put ( nextbyte ( ) ) ; return bb ; }	Trasfer data to a ByteBuffer.Note we cast char to byte, discarding top byte, if any.This is because CDM char is really a byte, not a java char.
public void setstring ( string val ) { int rank = getrank ( ) ; if ( rank != num_ ) throw new illegalargumentexception ( str_ ) ; int arraylen = indexcalc . getshape ( num_ ) ; int strlen = math . min ( val . length ( ) , arraylen ) ; for ( int k = num_ ; k < strlen ; k ++ ) storage [ k ] = val . charat ( k ) ; char c = num_ ; for ( int k = strlen ; k < arraylen ; k ++ ) storage [ k ] = c ; }	Set the ArrayChar values from the characters in the String.
public arrayobject make1dstringarray ( ) { int nelems = ( getrank ( ) == num_ ) ? num_ : ( int ) getsize ( ) / indexcalc . getshape ( getrank ( ) - num_ ) ; array sarr = array . factory ( datatype . string , new int [ ] { nelems } ) ; indexiterator newsiter = sarr . getindexiterator ( ) ; arraychar . stringiterator siter = getstringiterator ( ) ; while ( siter . hasnext ( ) ) { newsiter . setobjectnext ( siter . next ( ) ) ; } return ( arrayobject ) sarr ; }	Make this into the equivilent 1D ArrayObject of Strings.
public static arraychar makefromstring ( string s , int max ) { arraychar result = new arraychar . d1 ( max ) ; for ( int i = num_ ; i < max && i < s . length ( ) ; i ++ ) result . setchar ( i , s . charat ( i ) ) ; return result ; }	Create an ArrayChar from a String.
public static arraychar makefromstringarray ( arrayobject values ) {	Create an ArrayChar from an ArrayObject of Strings.
public static arraychar makefromstringarray ( arrayobject values , int strlen ) {	Create an ArrayChar from an ArrayObject of Strings.Inverse of make1DStringArray.
@ override public int [ ] getforecasttimeintervaloffset ( grib2record gr ) { grib2pds pds = gr . getpds ( ) ; if ( ! pds . istimeinterval ( ) ) { return null ; }	Reference time is the start time of the first forecast, other forecasts at 6-hour intervals. Number in Ave = number of forecast used.
public void show ( ) { setstate ( frame . normal ) ;	show the window.
public void showifnoticonified ( ) { if ( getstate ( ) == frame . iconified ) return ;	show if not iconified.
static public long makesizeestimate ( ucar . nc2 . dt . griddataset gds , list < string > gridlist , latlonrect llbb , projectionrect projrect , int horizstride , range zrange , calendardaterange daterange , int stride_time , boolean addlatlon ) throws ioexception , invalidrangeexception { cfgridwriter2 writer2 = new cfgridwriter2 ( ) ; return writer2 . writeortestsize ( gds , gridlist , llbb , projrect , horizstride , zrange , daterange , stride_time , addlatlon , bool_ , null ) ; }	Compute the size of the file without writing.
public static void main ( string [ ] args ) throws ioexception { int count = num_ ; string file = ( args . length > num_ ) ? args [ num_ ] : str_ ; randomaccessfile raf = new randomaccessfile ( file , str_ ) ; system . out . printf ( str_ , raf . getlocation ( ) ) ; grib1recordscanner scan = new grib1recordscanner ( raf ) ; while ( scan . hasnext ( ) ) { scan . next ( ) ; count ++ ; } raf . close ( ) ; system . out . printf ( str_ , count ) ; }	Count the number of records in a grib1 file.
public static unitname newunitname ( final string name , final string plural ) throws nameexception { return newunitname ( name , plural , null ) ; }	Factory method for constructing a UnitName from a name and a plural formof the name.
public static unitname newunitname ( final string name , final string plural , final string symbol ) throws nameexception { return new unitname ( name , plural , symbol ) ; }	Factory method for constructing a UnitName from a name, a plural form ofthe name, and a symbol.
protected string makeplural ( final string name ) { string plural ; final int length = name . length ( ) ; final char lastchar = name . charat ( length - num_ ) ; if ( lastchar != str_ ) { plural = name + ( lastchar == str_ || lastchar == str_ || lastchar == str_ || name . endswith ( str_ ) ? str_ : str_ ) ; } else { if ( length == num_ ) { plural = name + str_ ; } else { final char penultimatechar = name . charat ( length - num_ ) ; plural = ( penultimatechar == str_ || penultimatechar == str_ || penultimatechar == str_ || penultimatechar == str_ || penultimatechar == str_ ) ? name + str_ : name . substring ( num_ , length - num_ ) + str_ ; } } return plural ; }	Returns the plural form of a name.
public boolean included ( date d ) { if ( isempty ) return bool_ ; if ( getstart ( ) . after ( d ) ) return bool_ ; if ( getend ( ) . before ( d ) ) return bool_ ; return bool_ ; }	Determine if the given date is included in this date range.The date range includes the start and end dates.
public daterange intersect ( daterange clip ) { if ( isempty ) return this ; if ( clip . isempty ) return clip ; datetype ss = getstart ( ) ; datetype s = ss . before ( clip . getstart ( ) ) ? clip . getstart ( ) : ss ; datetype ee = getend ( ) ; datetype e = ee . before ( clip . getend ( ) ) ? ee : clip . getend ( ) ; return new daterange ( s , e , null , resolution ) ; }	Intersect with another date range.
public void extend ( daterange dr ) { boolean localempty = isempty ; if ( localempty || dr . getstart ( ) . before ( getstart ( ) ) ) setstart ( dr . getstart ( ) ) ; if ( localempty || getend ( ) . before ( dr . getend ( ) ) ) setend ( dr . getend ( ) ) ; }	Extend this date range by the given one.
public void extend ( date d ) { if ( d . before ( getstart ( ) . getdate ( ) ) ) setstart ( new datetype ( bool_ , d ) ) ; if ( getend ( ) . before ( d ) ) setend ( new datetype ( bool_ , d ) ) ; }	Extend this date range by the given Date.
public void setstart ( datetype start ) { this . start = start ; usestart = bool_ ; if ( useend ) { this . ismoving = this . start . ispresent ( ) || this . end . ispresent ( ) ; useduration = bool_ ; recalcduration ( ) ; } else { this . ismoving = this . start . ispresent ( ) ; this . end = this . start . add ( duration ) ; } checkifempty ( ) ; }	Set the starting Date.
public void setend ( datetype end ) { this . end = end ; useend = bool_ ; if ( usestart ) { this . ismoving = this . start . ispresent ( ) || this . end . ispresent ( ) ; useduration = bool_ ; recalcduration ( ) ; } else { this . ismoving = this . end . ispresent ( ) ; this . start = this . end . subtract ( duration ) ; } checkifempty ( ) ; }	Set the ending Date.
public void setduration ( timeduration duration ) { this . duration = duration ; useduration = bool_ ; if ( usestart ) { this . ismoving = this . start . ispresent ( ) ; this . end = this . start . add ( duration ) ; useend = bool_ ; } else { this . ismoving = this . end . ispresent ( ) ; this . start = this . end . subtract ( duration ) ; } checkifempty ( ) ; }	Set the duration of the interval.
public void addmapbean ( mapbean mb ) { mapbeanmenu . addaction ( mb . getactiondesc ( ) , mb . geticon ( ) , mb . getaction ( ) ) ;	add a MapBean to the User Interface.
public void yyerror ( string s ) { system . err . println ( str_ + s + str_ + charno + str_ ) ; string context = getinput ( ) ; int show = ( context . length ( ) < contextlen ? context . length ( ) : contextlen ) ; system . err . println ( context . substring ( context . length ( ) - show ) + str_ ) ; new exception ( ) . printstacktrace ( system . err ) ; }	Entry point for error reporting.
public string getname ( ) { string loc = ncd . getlocation ( ) ; int pos = loc . lastindexof ( str_ ) ; if ( pos < num_ ) pos = loc . lastindexof ( str_ ) ; return ( pos < num_ ) ? loc : loc . substring ( pos + num_ ) ; }	the name of the dataset is the last part of the location.
public string paramstostring ( ) { formatter f = new formatter ( ) ; f . format ( str_ , lat0deg , lon0deg , par1deg , par2deg , earth ) ; return f . tostring ( ) ; }	Create a String of the parameters.
public filedsp open ( byte [ ] rawdata ) throws dapexception { try { this . raw = rawdata ; bytearrayinputstream stream = new bytearrayinputstream ( this . raw ) ; chunkinputstream rdr = new chunkinputstream ( stream , requestmode . dap ) ; string document = rdr . readdmr ( ) ; byte [ ] serialdata = daputil . readbinaryfile ( rdr ) ; super . build ( document , serialdata , rdr . getremotebyteorder ( ) ) ; return this ; } catch ( ioexception ioe ) { throw new dapexception ( ioe ) . setcode ( dapcodes . sc_internal_server_error ) ; } }	Extension to access a raw byte stream.
private optional < list < rangeiterator > > computebounds ( latlonrect llbb , int horizstride ) { synchronized ( this ) { if ( edges == null ) edges = new edges ( ) ; } return edges . computeboundsexhaustive ( llbb , horizstride ) ; }	return y, x ranges.
private void synchui ( boolean slidersok ) { eventok = bool_ ; if ( slidersok ) minslider . setvalue ( scale . world2slider ( daterange . getstart ( ) ) ) ; minfield . setvalue ( daterange . getstart ( ) ) ; if ( maxfield != null ) { if ( slidersok ) maxslider . setvalue ( scale . world2slider ( daterange . getend ( ) ) ) ; maxfield . setvalue ( daterange . getend ( ) ) ; } if ( durationfield != null ) durationfield . setvalue ( daterange . getduration ( ) ) ; eventok = bool_ ; }	set values on the UI.
public int [ ] computeunlimitedchunking ( list < dimension > dims , int elemsize ) { int maxelements = defaultchunksize / elemsize ; int [ ] result = fillrightmost ( convertunlimitedshape ( dims ) , maxelements ) ; long resultsize = new section ( result ) . computesize ( ) ; if ( resultsize < minchunksize ) { maxelements = minchunksize / elemsize ; result = incrunlimitedshape ( dims , result , maxelements ) ; } return result ; }	make it easy to test by using dimension list.
public void register ( path dir ) throws ioexception { if ( ! enable ) return ; watchkey key = dir . register ( watcher , entry_create , entry_delete , entry_modify ) ; if ( trace ) { path prev = keys . get ( key ) ; if ( prev == null ) { system . out . format ( str_ , dir ) ; } else { if ( ! dir . equals ( prev ) ) { system . out . format ( str_ , prev , dir ) ; } } } keys . put ( key , dir ) ; }	Register the given directory with the WatchService.
public void processevents ( ) { if ( ! enable ) return ; for ( ; ; ) {	Process all events for keys queued to the watcher.
static public featuredataset wrap ( featuretype wantfeaturetype , netcdfdataset ncd , ucar . nc2 . util . canceltask task , formatter errlog ) throws ioexception { if ( debug ) system . out . println ( str_ + ncd . getlocation ( ) + str_ + wantfeaturetype ) ;	Wrap a NetcdfDataset as a FeatureDataset.
static public boolean featuretypeok ( featuretype want , featuretype factype ) { if ( want == null ) return bool_ ; if ( want == factype ) return bool_ ; if ( want == featuretype . any_point ) { return factype . ispointfeaturetype ( ) ; } if ( factype == featuretype . any_point ) { return want . ispointfeaturetype ( ) ; } if ( want == featuretype . coverage ) { return factype . iscoveragefeaturetype ( ) ; } if ( want == featuretype . grid ) {	Determine if factory type matches wanted feature type.
static public featuretype findfeaturetype ( netcdffile ncd ) {	Try to determine the feature type of the dataset, by examining its metadata.
public int writecatalog ( httpservletrequest req , httpservletresponse res , catalog cat , boolean islocalcatalog ) throws ioexception { string cathtmlasstring = convertcatalogtohtml ( cat , islocalcatalog ) ;	Write an Catalog to the HttpServletResponse, return the size in bytes of the catalog written to the response.
string convertcatalogtohtml ( catalog cat , boolean islocalcatalog ) { stringbuilder sb = new stringbuilder ( num_ ) ; string uri = cat . geturistring ( ) ; if ( uri == null ) uri = cat . getname ( ) ; if ( uri == null ) uri = str_ ; string catname = escape . html ( uri ) ;	Write a catalog in HTML, make it look like a file directory.
public string getusercss ( ) { return new stringbuilder ( ) . append ( str_ ) . append ( this . htmlconfig . prepareurlstringforhtml ( this . htmlconfig . getpagecssurl ( ) ) ) . append ( str_ ) . tostring ( ) ; }	public static final String UNIDATA_CSS.
public string getuserhead ( ) { return new stringbuilder ( ) . append ( str_ ) . append ( str_ ) . append ( this . htmlconfig . prepareurlstringforhtml ( this . htmlconfig . gethostinstlogourl ( ) ) ) . append ( str_ ) . append ( str_ ) . append ( this . htmlconfig . gethostinstlogoalt ( ) ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( this . tdscontext . getwebappdisplayname ( ) ) . append ( str_ ) . append ( str_ ) . tostring ( ) ; }	public static final String UNIDATA_HEAD.
private object makedynamiccatalog ( string path , uri baseuri ) throws ioexception { boolean islatest = path . endswith ( str_ ) ;	barfola on the return type.
private void addglobalservices ( catalogbuilder cat ) {	rigamorole to modify invariant catalogs; we may need to add global services.
static public void init ( credentialsprovider provider , string useragent ) { if ( provider != null ) try { httpsession . setglobalcredentialsprovider ( provider ) ; } catch ( httpexception e ) { throw new illegalargumentexception ( e ) ; } if ( useragent != null ) httpsession . setglobaluseragent ( useragent + str_ ) ; else httpsession . setglobaluseragent ( str_ ) ; }	initialize the HttpClient layer.
@ urlencoded @ deprecated public static string getcontentasstring ( httpsession session , string urlencoded ) throws ioexception { httpsession usesession = session ; try { if ( usesession == null ) usesession = httpfactory . newsession ( urlencoded ) ; try ( httpmethod m = httpfactory . get ( usesession , urlencoded ) ) { m . execute ( ) ; return m . getresponseasstring ( ) ; } } finally { if ( ( session == null ) && ( usesession != null ) ) usesession . close ( ) ; } }	Get the content from a url.
public static int putcontent ( string urlencoded , string content ) throws ioexception { try ( httpmethod m = httpfactory . put ( urlencoded ) ) { m . setrequestcontent ( new stringentity ( content , str_ , str_ ) ) ; m . execute ( ) ; int resultcode = m . getstatuscode ( ) ;	Put content to a url, using HTTP PUT.
protected frontpage getfrontpage ( daprequest drq , dapcontext cxt ) throws dapexception { if ( this . defaultroots == null ) {	Isolate front page builder so we can override if desired for testing.
@ override public catalogbuilder makecatalog ( string match , string reqpath , uri caturi ) throws ioexception { stategrib localstate = ( stategrib ) checkstate ( ) ; if ( localstate == null ) return null ;	see top javadoc for possible URLs.
private threddsmetadata . geospatialcoverage extractgeospatial ( gribcollectionimmutable . groupgc group ) { gdshorizcoordsys gdscoordsys = group . getgdshorizcoordsys ( ) ; latlonrect llbb = gridcoordsys . getlatlonboundingbox ( gdscoordsys . proj , gdscoordsys . getstartx ( ) , gdscoordsys . getstarty ( ) , gdscoordsys . getendx ( ) , gdscoordsys . getendy ( ) ) ; double dx = num_ , dy = num_ ; if ( gdscoordsys . islatlon ( ) ) { dx = math . abs ( gdscoordsys . dx ) ; dy = math . abs ( gdscoordsys . dy ) ; } return new threddsmetadata . geospatialcoverage ( llbb , null , dx , dy ) ; }	LOOK how come we arent using MetadataExtractor ??.
public gribcollectionimmutable . dataset getsingledatasetorbytypename ( gribcollectionimmutable gc , string typename ) { if ( gc . getdatasets ( ) . size ( ) == num_ ) return gc . getdataset ( num_ ) ; for ( gribcollectionimmutable . dataset ds : gc . getdatasets ( ) ) if ( ds . gettype ( ) . tostring ( ) . equalsignorecase ( typename ) ) return ds ; return null ; }	kinda kludgey, but trying not keep URLs stable.
public boolean nearlyequals ( vertcoordvalue other ) { return misc . nearlyequals ( value1 , other . value1 ) && misc . nearlyequals ( value2 , other . value2 ) ; }	cannot do approx equals and be consistent with hashCode, so make seperate call.
public static unitid newunitid ( final string name , final string plural , final string symbol ) { unitid id ; try { id = name == null ? new unitsymbol ( symbol ) : unitname . newunitname ( name , plural , symbol ) ; } catch ( final nameexception e ) { id = null ;	Factory method for constructing an identifier from a name, plural, andsymbol.
public static gradsattribute parseattribute ( string attrspec ) { string [ ] toks = attrspec . split ( str_ ) ; stringbuffer buf = new stringbuffer ( ) ; for ( int i = num_ ; i < toks . length ; i ++ ) { buf . append ( toks [ i ] ) ; buf . append ( str_ ) ; }	Parse an attribute spec.
int readtop ( ucar . unidata . io . randomaccessfile raf ) throws ioexception { int pos = num_ ;	read the header of input file and parsing the NOWRAD part.
public static int shortstoint ( short s1 , short s2 , boolean swapbytes ) { byte [ ] b = new byte [ num_ ] ; b [ num_ ] = ( byte ) ( s1 > > > num_ ) ; b [ num_ ] = ( byte ) ( s1 > > > num_ ) ; b [ num_ ] = ( byte ) ( s2 > > > num_ ) ; b [ num_ ] = ( byte ) ( s2 > > > num_ ) ; return bytestoint ( b , bool_ ) ; }	convert two short into a integer.
public static int bytestoint ( byte [ ] bytes , boolean swapbytes ) { byte a = bytes [ num_ ] ; byte b = bytes [ num_ ] ; byte c = bytes [ num_ ] ; byte d = bytes [ num_ ] ; if ( swapbytes ) { return ( ( a & num_ ) ) + ( ( b & num_ ) << num_ ) + ( ( c & num_ ) << num_ ) + ( ( d & num_ ) << num_ ) ; } else { return ( ( a & num_ ) << num_ ) + ( ( b & num_ ) << num_ ) + ( ( c & num_ ) << num_ ) + ( ( d & num_ ) ) ; } }	convert bytes into integer.
static public java . util . date getdate ( int juliandays , int msecs ) { long total = ( ( long ) ( juliandays - num_ ) ) * num_ * num_ * num_ + msecs ; return new date ( total ) ; }	get jave date.
public static string makevalidnetcdfobjectname ( string name ) { stringbuilder sb = new stringbuilder ( name ) ; while ( sb . length ( ) > num_ ) { int cp = sb . codepointat ( num_ ) ;	Convert a name to a legal netcdf-3 name.
static public boolean isvalidnetcdf3objectname ( string name ) { matcher m = objectnamepatternold . matcher ( name ) ; return m . matches ( ) ; }	Determine if the given name can be used for a Dimension, Attribute, or Variable name.Should match makeValidNetcdf3ObjectName.
private ucar . ma2 . array readrecorddata ( ucar . nc2 . structure s , section section ) throws java . io . ioexception {	Read data from record structure.
private ucar . ma2 . array readrecorddatasubset ( ucar . nc2 . structure s , section section ) throws java . io . ioexception { range recordrange = section . getrange ( num_ ) ; int nrecords = recordrange . length ( ) ;	Read data from record structure, that has been subsetted.Read one record at at time, put requested variable into ArrayStructureMA.
protected void fillnonrecordvariables ( ) throws ioexception {	fill buffer with fill value.
public gradstimestruct maketimestruct ( int timeindex ) { double tval = getvalues ( ) [ timeindex ] ; date d = dateunit . getstandarddate ( tval + str_ + getunit ( ) ) ; calendar calendar = calendar . getinstance ( ) ; calendar . settimezone ( java . util . timezone . gettimezone ( str_ ) ) ; calendar . settime ( d ) ; return maketimestruct ( calendar ) ; }	Make a time struct from the index.
private gradstimestruct maketimestruct ( calendar calendar ) { gradstimestruct ts = new gradstimestruct ( ) ; ts . year = calendar . get ( calendar . year ) ; ts . month = calendar . get ( calendar . month ) + num_ ;	Make a GradsTimeStruct from the calendar state.
public static boolean hastimetemplate ( string template ) { for ( int i = num_ ; i < timetemplates . length ; i ++ ) { if ( template . indexof ( timetemplates [ i ] ) >= num_ ) { return bool_ ; } } return bool_ ; }	Does this file definition have a time template in it?.
public void add ( serversidefunction function ) { if ( function instanceof boolfunction ) { boolfunctions . put ( function . getname ( ) , function ) ; } if ( function instanceof btfunction ) { btfunctions . put ( function . getname ( ) , function ) ; } }	Adds a function to the library.
public boolfunction getboolfunction ( string name ) throws nosuchfunctionexception { if ( ! boolfunctions . containskey ( name ) ) { loadnewfunction ( name ) ; } return ( boolfunction ) boolfunctions . get ( name ) ; }	Retrieves a boolean function from the library.
public btfunction getbtfunction ( string name ) throws nosuchfunctionexception { if ( ! btfunctions . containskey ( name ) ) { loadnewfunction ( name ) ; } return ( btfunction ) btfunctions . get ( name ) ; }	Retrieves a BaseType function from the library.
protected void loadnewfunction ( string name ) { try { string fullname = prefix + name ; class value = class . forname ( fullname ) ; if ( ( serversidefunction . class ) . isassignablefrom ( value ) ) { add ( ( serversidefunction ) value . newinstance ( ) ) ; return ; } } catch ( classnotfoundexception e ) { } catch ( illegalaccessexception e ) { } catch ( instantiationexception e ) { } }	Tries to load a function with the given name.
public final string getlevelname ( gridrecord gr ) { if ( cust != null ) { string result = cust . getlevelnameshort ( gr . getleveltype1 ( ) ) ; if ( result != null ) return result ; } string levelunit = getlevelunit ( gr ) ; if ( levelunit != null ) { int level1 = ( int ) gr . getlevel1 ( ) ; int level2 = ( int ) gr . getlevel2 ( ) ; if ( levelunit . equalsignorecase ( str_ ) ) { return str_ ; } else if ( level1 == num_ ) { return str_ ; } else if ( level1 == num_ ) { return str_ ; } else if ( level1 == num_ ) { return str_ ; } else if ( level2 != num_ ) { return str_ ; } } return str_ ; }	gets the LevelName.
public final string getleveldescription ( gridrecord gr ) { if ( cust != null ) { string result = cust . getleveldescription ( gr . getleveltype1 ( ) ) ; if ( result != null ) return result ; }	gets the LevelDescription.
public final string getlevelunit ( gridrecord gr ) { if ( cust != null ) { string result = cust . getlevelunits ( gr . getleveltype1 ( ) ) ; if ( result != null ) return result ; } return visad . jmet . metunits . makesymbol ( ( ( mcidasgridrecord ) gr ) . getlevelunitname ( ) ) ; }	gets the LevelUnit.
public final int getprojectiontype ( griddefrecord gds ) { string name = getprojectionname ( gds ) . trim ( ) ; switch ( name ) { case str_ : return mercator ; case str_ : return lambertconformal ; case str_ : return polarstereographic ; default : return - num_ ; } }	gets the ProjectionType.
public final boolean isverticalcoordinate ( gridrecord gr ) { if ( cust != null ) { return cust . isverticalcoordinate ( gr . getleveltype1 ( ) ) ; } int type = gr . getleveltype1 ( ) ; if ( ( ( mcidasgridrecord ) gr ) . hasgribinfo ( ) ) { if ( type == num_ ) { return bool_ ; } if ( type == num_ ) { return bool_ ; } if ( type == num_ ) { return bool_ ; } if ( ( type >= num_ ) && ( type <= num_ ) ) { return bool_ ; } if ( type == num_ ) { return bool_ ; } if ( type == num_ ) { return bool_ ; } } else if ( getlevelunit ( gr ) . equals ( str_ ) ) { return bool_ ; } return bool_ ; }	is this a VerticalCoordinate.
public boolean islayer ( gridrecord gr ) { if ( cust != null ) { return cust . islayer ( gr . getleveltype1 ( ) ) ; } if ( gr . getlevel2 ( ) == num_ ) { return bool_ ; } return bool_ ; }	Is this a layer?.
static public coordinatetransform makecoordinatetransform ( netcdfdataset ds , attributecontainer ctv , formatter parseinfo , formatter errinfo ) {	Make a CoordinateTransform object from the parameters in a Coordinate Transform Variable, using an intrinsic or registered CoordTransBuilder.
static public variableds makedummytransformvariable ( netcdfdataset ds , coordinatetransform ct ) { variableds v = new variableds ( ds , null , null , ct . getname ( ) , datatype . char , str_ , null , null ) ; list < parameter > params = ct . getparameters ( ) ; for ( parameter p : params ) { if ( p . isstring ( ) ) v . addattribute ( new attribute ( p . getname ( ) , p . getstringvalue ( ) ) ) ; else { double [ ] data = p . getnumericvalues ( ) ; array dataa = array . factory ( datatype . double , new int [ ] { data . length } , data ) ; v . addattribute ( new attribute ( p . getname ( ) , dataa ) ) ; } } v . addattribute ( new attribute ( _coordinate . transformtype , ct . gettransformtype ( ) . tostring ( ) ) ) ;	Create a "dummy" Coordinate Transform Variable based on the given CoordinateTransform.This creates a scalar Variable with dummy data, and adds the Parameters of the CoordinateTransformas attributes.
static public projectionimpl makeprojection ( coveragetransform gct , formatter errinfo ) {	Make a CoordinateTransform object from the parameters in a GridCoordTransform, using an intrinsic orregistered CoordTransBuilder.
public static void main ( string args [ ] ) { boolean usepopup = bool_ ; for ( int i = num_ ; i < args . length ; i ++ ) { if ( args [ i ] . equals ( str_ ) ) usepopup = bool_ ; } try { store = xmlstore . createfromfile ( str_ , null ) ; p = store . getpreferences ( ) ; } catch ( ioexception e ) { system . out . println ( str_ + e ) ; }	Standalone application.
public void save ( ) { collectionnametable . savestate ( bool_ ) ; datatable . savestate ( bool_ ) ; prefs . putbeanobject ( str_ , infowindow . getbounds ( ) ) ; prefs . putint ( str_ , split . getdividerlocation ( ) ) ; }	private MetadataManager mm;.
@ override public final chronology withzone ( datetimezone zone ) { if ( zone . equals ( datetimezone . utc ) ) return this . withutc ( ) ; throw new unsupportedoperationexception ( str_ ) ; }	Throws UnsupportedOperationException unless the time zone is UTC.
public void writecount ( long count ) throws ioexception { countbuffer . clear ( ) ; countbuffer . putlong ( count ) ; byte [ ] countbuf = countbuffer . array ( ) ; int len = countbuffer . position ( ) ; writebytes ( countbuf , len ) ; if ( debug ) { system . err . printf ( str_ , count ) ; } }	Write out a prefix count.
public void writeatomicarray ( daptype daptype , object values ) throws ioexception { assert values != null && values . getclass ( ) . isarray ( ) ; bytebuffer buf = serialwriter . encodearray ( daptype , values , this . order ) ; byte [ ] bytes = buf . array ( ) ; int len = buf . position ( ) ; writebytes ( bytes , len ) ; if ( debug ) { system . err . printf ( str_ , daptype . getshortname ( ) ) ; for ( int i = num_ ; i < len ; i ++ ) { int x = ( int ) ( order == byteorder . big_endian ? bytes [ i ] : bytes [ ( len - num_ ) - i ] ) ; system . err . printf ( str_ , ( int ) ( x & num_ ) ) ; } system . err . println ( ) ; } }	Write out an array of atomic values.
public void writebytes ( byte [ ] bytes , int len ) throws ioexception { outputbytes ( bytes , num_ , len ) ; if ( this . checksummode . enabled ( checksummode . dap ) ) { this . checksum . update ( bytes , num_ , len ) ; if ( dumpcsum ) { system . err . print ( str_ ) ; for ( int i = num_ ; i < len ; i ++ ) { system . err . printf ( str_ , bytes [ i ] ) ; } system . err . println ( ) ; } } }	Write out a set of bytes.
public void outputbytes ( byte [ ] bytes , int start , int count ) throws ioexception { if ( dumpdata ) { system . err . printf ( str_ , start , count ) ; for ( int i = num_ ; i < count ; i ++ ) { system . err . printf ( str_ , bytes [ i ] ) ; } system . err . println ( str_ ) ; system . err . flush ( ) ; } output . write ( bytes , start , count ) ; }	Deliberate choke point for debugging.
void finishinit ( ) {	stuff to do after UI is complete.
static public calendardaterange of ( daterange dr ) { if ( dr == null ) return null ; return calendardaterange . of ( dr . getstart ( ) . getdate ( ) , dr . getend ( ) . getdate ( ) ) ; }	Does not handle non-standard calendars.
public static grib2gds factory ( int template , byte [ ] data ) { grib2gds result ; switch ( template ) { case num_ : result = new latlon ( data ) ; break ; case num_ : result = new rotatedlatlon ( data ) ; break ; case num_ : result = new mercator ( data ) ; break ; case num_ : result = new polarstereographic ( data ) ; break ; case num_ : result = new lambertconformal ( data , num_ ) ; break ; case num_ : result = new albersequalarea ( data ) ; break ; case num_ : result = new gausslatlon ( data ) ; break ; case num_ :	reletive error in position - GRIB numbers sometimes miscoded.
public int ddsparse ( string text , dds dds ) throws parseexception { return dapparse ( text , dds , null , null ) ; }	Call this to parse a DDS.
public int dasparse ( string text , das das ) throws parseexception { return dapparse ( text , null , das , null ) ; }	Call this to parse a DAS.
private void swapgridheader ( int [ ] gh ) { mcidasutil . flip ( gh , num_ , num_ ) ; mcidasutil . flip ( gh , num_ , num_ ) ; mcidasutil . flip ( gh , num_ , num_ ) ; mcidasutil . flip ( gh , num_ , num_ ) ; mcidasutil . flip ( gh , num_ , num_ ) ; }	Swap the grid header, avoiding strings.
public float [ ] readgrid ( mcidasgridrecord gr ) throws ioexception { float [ ] data ;	Read the grid.
public static void main ( string [ ] args ) throws ioexception { string file = str_ ; if ( args . length > num_ ) { file = args [ num_ ] ; } mcidasgridreader mg = new mcidasgridreader ( file ) ; gridindex gridindex = mg . getgridindex ( ) ; list grids = gridindex . getgridrecords ( ) ; system . out . println ( str_ + grids . size ( ) + str_ ) ; int num = math . min ( grids . size ( ) , num_ ) ; for ( int i = num_ ; i < num ; i ++ ) { system . out . println ( grids . get ( i ) ) ; } }	for testing purposes.
private void writeaconstraint ( string name , boolean isimplemented ) { string defvalue ; if ( isimplemented ) defvalue = str_ ; else defvalue = str_ ; fileoutput += str_ + name + str_ + str_ + str_ + defvalue + str_ + str_ ; }	Writes a constraint OWS element out.
private void writeheadersandss ( ) { fileoutput += str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ ; writeserviceinfo ( ) ; }	Writes headers and service sections.
public void writeoperations ( ) { fileoutput += str_ ; for ( wfsrequesttype rt : operationlist ) { writeaoperation ( rt ) ; }	Takes all added operations and writes an operations metadata section.
public void readall ( file dir , filefilter ff , closure closure , logfilter logf , stats stat ) throws ioexception { file [ ] files = dir . listfiles ( ) ; if ( files == null ) { system . out . printf ( str_ , dir ) ; return ; } list < file > list = arrays . aslist ( files ) ; collections . sort ( list ) ; for ( file f : list ) { if ( ( ff != null ) && ! ff . accept ( f ) ) continue ; if ( f . isdirectory ( ) ) readall ( f , ff , closure , logf , stat ) ; else scanlogfile ( f , closure , logf , stat ) ; } }	Read all the files in a directory and process them.
public void scanlogfile ( file file , closure closure , logfilter logf , stats stat ) throws ioexception { try ( inputstream ios = new fileinputstream ( file ) ) { system . out . printf ( str_ , file . getpath ( ) ) ; bufferedreader datais = new bufferedreader ( new inputstreamreader ( ios , cdm . utf8charset ) , num_ * num_ ) ; int total = num_ ; int count = num_ ; while ( ( maxlines < num_ ) || ( count < maxlines ) ) { log log = parser . nextlog ( datais ) ; if ( log == null ) break ; total ++ ; if ( ( logf != null ) && ! logf . pass ( log ) ) continue ; closure . process ( log ) ; count ++ ; } if ( stat != null ) { stat . total += total ; stat . passed += count ; } system . out . printf ( str_ , file . getpath ( ) , total , count ) ; } }	Read a log file.
public int getgridpackingtype ( int gridnumber ) throws ioexception {	Get the grid packing type.
public gempakgridrecord findgrid ( string parm ) { list < gridrecord > gridlist = gridindex . getgridrecords ( ) ; if ( gridlist == null ) { return null ; } for ( gridrecord grid : gridlist ) { gempakgridrecord gh = ( gempakgridrecord ) grid ; if ( gh . param . trim ( ) . equals ( parm ) ) { return gh ; } } return null ; }	Find the first grid with this name.
public float [ ] dm_rpkg ( int isword , int nword , int decimalscale ) throws ioexception {	Unpack a packed grid.
private synchronized float [ ] unpackdata ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalscale ) throws ioexception { if ( ipktyp == mdggrb ) { if ( ! usedp ) { return unpackgrib1data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalscale ) ; } else { if ( nword * num_ < kxky * nbits ) {	Read packed data.
private synchronized float [ ] dp_ugrb ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalscale ) throws ioexception { float scalefactor = ( decimalscale == num_ ) ? num_ : ( float ) math . pow ( num_ , - decimalscale ) ;	Unpack grib data packed into ints.
private float [ ] unpackgrib1data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalscale ) throws ioexception {	Read packed Grib1 data using ucar.grib code.
private float [ ] unpackgrib2data ( int iiword , int lendat , int [ ] iarray , float [ ] rarray ) throws ioexception { long start = getoffset ( iiword ) ; rf . seek ( start ) ; grib2record gr = makegribrecord ( rf , start ) ; float [ ] data = gr . readdata ( rf ) ; if ( ( ( iarray [ num_ ] > > num_ ) & num_ ) == num_ ) {	Read packed Grib2 data.
public void printgrids ( ) { list < gridrecord > gridlist = gridindex . getgridrecords ( ) ; if ( gridlist == null ) return ; system . out . println ( str_ ) ; for ( gridrecord agridlist : gridlist ) { system . out . println ( agridlist ) ; } }	Print out the grids.
private void getnextbyte ( ) throws ioexception { if ( ! needtoswap ) {	Get the next byte.
public static calendardate of ( calendar cal , int year , int monthofyear , int dayofmonth , int hourofday , int minuteofhour , int secondofminute ) { chronology base = calendar . getchronology ( cal ) ; datetime dt = new datetime ( year , monthofyear , dayofmonth , hourofday , minuteofhour , secondofminute , base ) ; if ( ! calendar . isdefaultchronology ( cal ) ) dt = dt . withchronology ( calendar . getchronology ( cal ) ) ; dt = dt . withzone ( datetimezone . utc ) ; return new calendardate ( cal , dt ) ; }	Get Calendar date from fields. Uses UTZ time zone.
public static calendardate of ( java . util . date date ) { datetime dt = new datetime ( date , datetimezone . utc ) ; return new calendardate ( null , dt ) ; }	Create CalendarDate from a java.util.Date.Uses standard Calendar.
public static calendardate of ( long msecs ) {	Create CalendarDate from msecs since epochUses standard Calendar.
public static calendardate of ( calendar cal , long msecs ) { chronology base = calendar . getchronology ( cal ) ; datetime dt = new datetime ( msecs , base ) ; return new calendardate ( cal , dt ) ; }	Create CalendarDate from msecs since epochUses the given Calendar.
public static calendardate parseudunits ( string calendarname , string udunits ) { int pos = udunits . indexof ( str_ ) ; if ( pos < num_ ) return null ; string valstring = udunits . substring ( num_ , pos ) . trim ( ) ; string unitstring = udunits . substring ( pos + num_ ) . trim ( ) ; calendardateunit cdu = calendardateunit . of ( calendarname , unitstring ) ; double val = double . parsedouble ( valstring ) ; return cdu . makecalendardate ( val ) ; }	Get CalendarDate from udunit date string.
public long getdifference ( calendardate o , calendarperiod . field fld ) { switch ( fld ) { case millisec : return getdifferenceinmsecs ( o ) ; case second : return ( long ) ( getdifferenceinmsecs ( o ) / millisecs_in_second ) ; case minute : return ( long ) ( getdifferenceinmsecs ( o ) / millisecs_in_minute ) ; case hour : return ( long ) ( getdifferenceinmsecs ( o ) / millisecs_in_hour ) ; case day : return ( long ) ( getdifferenceinmsecs ( o ) / millisecs_in_day ) ; case month : int tmonth = getfieldvalue ( calendarperiod . field . month ) ; int omonth = o . getfieldvalue ( calendarperiod . field . month ) ; int years = ( int ) this . getdifference ( o , calendarperiod . field . year ) ; return tmonth - omonth + num_ * years ; case year : int tyear = getfieldvalue ( calendarperiod . field . year ) ; int oyear = o . getfieldvalue ( calendarperiod . field . year ) ; return tyear - oyear ; } return datetime . getmillis ( ) - o . datetime . getmillis ( ) ; }	Get difference between two calendar dates in given Field units.
protected cdmarrayatomic createatomicvar ( datacursor data ) throws dapexception { cdmarrayatomic array = new cdmarrayatomic ( data ) ; return array ; }	Create an Atomic Valued variable.
public void setup ( httpservletrequest req , httpservletresponse resp ) throws senderror { this . req = req ; this . res = resp ; if ( ! once ) doonce ( req ) ;	Setup for each request.
static protected string escapestring ( string s ) { stringbuilder buf = new stringbuilder ( ) ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { int c = s . charat ( i ) ; switch ( c ) { case str_ : buf . append ( str_ ) ; break ; case str_ : buf . append ( str_ ) ; break ; case str_ : buf . append ( str_ ) ; break ; case str_ : buf . append ( str_ ) ; break ; case str_ : buf . append ( str_ ) ; break ; case str_ : buf . append ( str_ ) ; break ; default : if ( c < str_ ) buf . append ( string . format ( str_ , ( c & num_ ) ) ) ; else buf . append ( ( char ) c ) ; break ; } } return buf . tostring ( ) ; }	Given a typical string, insert backslashesbefore '"' and '\\' characters and control characters.
static public list < slice > createslices ( list < range > rangelist ) throws dap4 . core . util . dapexception { list < slice > slices = new arraylist < slice > ( rangelist . size ( ) ) ; for ( int i = num_ ; i < rangelist . size ( ) ; i ++ ) { range r = rangelist . get ( i ) ;	Convert a list of ucar.ma2.Range to a list of SliceMore or less the inverst of create CDMRanges.
static public netcdffile unwrapfile ( netcdffile file ) { for ( ; ; ) { if ( file instanceof netcdfdataset ) { netcdfdataset ds = ( netcdfdataset ) file ; file = ds . getreferencedfile ( ) ; if ( file == null ) break ; } else break ; } return file ; }	NetcdfDataset can wrap a NetcdfFile.Goal of this procedure is to get down to thelowest level NetcdfFile instance.
static public boolean containsvlen ( list < dimension > dimset ) { if ( dimset == null ) return bool_ ; for ( dimension dim : dimset ) { if ( dim . isvariablelength ( ) ) return bool_ ; } return bool_ ; }	Test if any dimension is variable length.
static public int [ ] computeeffectiveshape ( list < dapdimension > dimset ) { if ( dimset == null || dimset . size ( ) == num_ ) return new int [ num_ ] ; int effectiverank = dimset . size ( ) ; int [ ] shape = new int [ effectiverank ] ; for ( int i = num_ ; i < effectiverank ; i ++ ) { shape [ i ] = ( int ) dimset . get ( i ) . getsize ( ) ; } return shape ; }	Compute the shape inferred from a set of slices.'Effective' means that any trailing vlen will beignored.
public date add ( date d ) { calendar cal = calendar . getinstance ( ) ; cal . settime ( d ) ; cal . add ( calendar . second , ( int ) getvalueinseconds ( ) ) ; return cal . gettime ( ) ; }	Add the time amount to the given Date, return a new Date.
@ override protected unit mymultiplyby ( final unit that ) throws multiplyexception { return that instanceof scaledunit ? new scaledunit ( getscale ( ) * ( ( scaledunit ) that ) . getscale ( ) , getunit ( ) . multiplyby ( ( ( scaledunit ) that ) . getunit ( ) ) ) : new scaledunit ( getscale ( ) , getunit ( ) . multiplyby ( that ) ) ; }	Multiplies this unit by another unit.
@ override protected unit mydivideby ( final unit that ) throws operationexception { return that instanceof scaledunit ? new scaledunit ( getscale ( ) / ( ( scaledunit ) that ) . getscale ( ) , getunit ( ) . divideby ( ( ( scaledunit ) that ) . getunit ( ) ) ) : new scaledunit ( getscale ( ) , getunit ( ) . divideby ( that ) ) ; }	Divides this unit by another unit.
@ override protected unit mydivideinto ( final unit that ) throws operationexception { return that instanceof scaledunit ? new scaledunit ( ( ( scaledunit ) that ) . getscale ( ) / getscale ( ) , getunit ( ) . divideinto ( ( ( scaledunit ) that ) . getunit ( ) ) ) : new scaledunit ( num_ / getscale ( ) , getunit ( ) . divideinto ( that ) ) ; }	Divides this unit into another unit.
@ override protected unit myraiseto ( final int power ) throws raiseexception { return new scaledunit ( math . pow ( getscale ( ) , power ) , getunit ( ) . raiseto ( power ) ) ; }	Raises this unit to a power.
public double toderivedunit ( final double amount ) throws conversionexception { if ( ! ( _unit instanceof derivableunit ) ) { throw new conversionexception ( this , getderivedunit ( ) ) ; } return ( ( derivableunit ) _unit ) . toderivedunit ( amount * getscale ( ) ) ; }	Converts a numeric value from this unit to the underlying derived unit.
public float [ ] toderivedunit ( final float [ ] input , final float [ ] output ) throws conversionexception { final float scale = ( float ) getscale ( ) ; for ( int i = input . length ; -- i >= num_ ; ) { output [ i ] = input [ i ] * scale ; } if ( ! ( _unit instanceof derivableunit ) ) { throw new conversionexception ( this , getderivedunit ( ) ) ; } return ( ( derivableunit ) getunit ( ) ) . toderivedunit ( output , output ) ; }	Converts numeric values from this unit to the underlying derived unit.
public double fromderivedunit ( final double amount ) throws conversionexception { if ( ! ( _unit instanceof derivableunit ) ) { throw new conversionexception ( getderivedunit ( ) , this ) ; } return ( ( derivableunit ) getunit ( ) ) . fromderivedunit ( amount ) / getscale ( ) ; }	Converts a numeric value from the underlying derived unit to this unit.
public string getcanonicalstring ( ) { return derivedunitimpl . dimensionless . equals ( _unit ) ? double . tostring ( getscale ( ) ) : double . tostring ( getscale ( ) ) + str_ + _unit . tostring ( ) ; }	Returns the canonical string representation of the unit.
public array readdata ( sectioniterable want ) throws ioexception , invalidrangeexception { if ( vindex instanceof partitioncollectionimmutable . variableindexpartitioned ) return readdatafrompartition ( ( partitioncollectionimmutable . variableindexpartitioned ) vindex , want ) ; else return readdatafromcollection ( vindex , want ) ; }	Read the section of data described by want.
public array readdata2 ( coordsset want , rangeiterator yrange , rangeiterator xrange ) throws ioexception { if ( vindex instanceof partitioncollectionimmutable . variableindexpartitioned ) return readdatafrompartition2 ( ( partitioncollectionimmutable . variableindexpartitioned ) vindex , want , yrange , xrange ) ; else return readdatafromcollection2 ( vindex , want , yrange , xrange ) ; }	Coordinate based subsetting for Coverage.
@ override public pointfeaturecollection flatten ( list < string > stationnames , calendardaterange daterange , list < variablesimpleif > varlist ) throws ioexception { if ( ( stationnames == null ) || ( stationnames . size ( ) == num_ ) ) return new stationtimeseriescollectionflattened ( this , daterange ) ; list < stationfeature > subsetstations = getstationhelper ( ) . getstationfeaturesfromnames ( stationnames ) ; return new stationtimeseriescollectionflattened ( new stationsubset ( this , subsetstations ) , daterange ) ; }	might need to override for efficiency.
public invservice findservice ( string name ) { if ( name == null ) return null ; for ( invservice s : services ) { if ( name . equals ( s . getname ( ) ) ) return s ;	Find the named service declared in the top level of this catalog.
public int getgatesize ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect_gate_size ) ; case velocity_hi : case velocity_low : case spectrum_width : return ( ( int ) doppler_gate_size ) ;	This method returns the gate size in meters.
public int getgatestart ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect_first_gate ) ; case velocity_hi : case velocity_low : case spectrum_width : return ( ( int ) doppler_first_gate ) ;	This method returns the starting gate in meters.
public int getgatecount ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect_gate_count ) ; case velocity_hi : case velocity_low : case spectrum_width : return ( ( int ) doppler_gate_count ) ;	This method returns the number of gates.
public void writexml ( netcdfdataset ncd , outputstream os , boolean showcoords , string uri ) throws ioexception {	Write a NetcdfDataset as an NcML-G document to the specified stream.
public dimension preferredlayoutsize ( container target ) { synchronized ( target . gettreelock ( ) ) { dimension dim = new dimension ( num_ , num_ ) ; for ( int i = num_ ; i < target . getcomponentcount ( ) ; i ++ ) { component m = target . getcomponent ( i ) ; if ( m . isvisible ( ) ) { dimension d = m . getpreferredsize ( ) ;	deal with having components on more than one line.
static crawlabledataset verifydescendantdataset ( crawlabledataset ancestorcrds , string path , crawlabledatasetfilter filter ) {	Return the requested dataset if it is the ancestor dataset or an alloweddescendant of the ancestor dataset, otherwise return null.
public invcatalogimpl generateproxydsresolvercatalog ( crawlabledataset catalogcrds , proxydatasethandler pdh ) throws ioexception { throw new java . lang . unsupportedoperationexception ( str_ ) ; }	Not supported by SimpleCatalogBuilder.
static public calendardateunit of ( string calendarname , string udunitstring ) { calendar calt = calendar . get ( calendarname ) ; if ( calt == null ) calt = calendar . getdefault ( ) ; return new calendardateunit ( calt , udunitstring ) ; }	Create a CalendarDateUnit from a calendar name and a udunit string = "unit since calendarDate".
static public calendardateunit withcalendar ( calendar calt , string udunitstring ) { if ( calt == null ) calt = calendar . getdefault ( ) ; return new calendardateunit ( calt , udunitstring ) ; }	Create a CalendarDateUnit from a calendar and a udunit string = "unit since calendarDate".
static public calendardateunit of ( calendar calt , calendarperiod . field periodfield , calendardate basedate ) { if ( calt == null ) calt = calendar . getdefault ( ) ; return new calendardateunit ( calt , periodfield , basedate ) ; }	Create a CalendarDateUnit from a calendar, a CalendarPeriod.Field, and a base date.
public quantitydimension getquantitydimension ( ) { factor [ ] factors = getfactors ( ) ; for ( int i = factors . length ; -- i >= num_ ; ) { factor factor = factors [ i ] ; factors [ i ] = new factor ( ( ( baseunit ) factor . getbase ( ) ) . getbasequantity ( ) , factor . getexponent ( ) ) ; } return new quantitydimension ( factors ) ; }	Returns the corresponding quantity dimension.
public boolean isvalidfile ( ucar . unidata . io . randomaccessfile raf ) { try { raf . order ( randomaccessfile . little_endian ) ;	Check if this is a valid SIGMET-IRIS file for this IOServiceProvider.
public array readdata1 ( ucar . nc2 . variable v2 , section section ) throws ioexception , invalidrangeexception {	Read data from a top level Variable and return a memory resident Array.
public array readintdata ( layoutregular index , variable v2 ) throws ioexception { int [ ] var = ( int [ ] ) ( v2 . read ( ) . get1djavaarray ( v2 . getdatatype ( ) ) ) ; int [ ] data = new int [ ( int ) index . gettotalnelems ( ) ] ; while ( index . hasnext ( ) ) { layout . chunk chunk = index . next ( ) ; system . arraycopy ( var , ( int ) chunk . getsrcpos ( ) / num_ , data , ( int ) chunk . getdestelem ( ) , chunk . getnelems ( ) ) ; } return array . factory ( v2 . getdatatype ( ) , new int [ ] { ( int ) index . gettotalnelems ( ) } , data ) ; }	Read data from a top level Variable of INTEGER data type and return a memory resident Array.
public long readtobytechannel11 ( ucar . nc2 . variable v2 , section section , writablebytechannel channel ) throws java . io . ioexception , ucar . ma2 . invalidrangeexception { array data = readdata ( v2 , section ) ; float [ ] ftdata = new float [ ( int ) data . getsize ( ) ] ; byte [ ] bytedata = new byte [ ( int ) data . getsize ( ) * num_ ] ; indexiterator iter = data . getindexiterator ( ) ; int i = num_ ; bytebuffer buffer = bytebuffer . allocatedirect ( bytedata . length ) ; while ( iter . hasnext ( ) ) { ftdata [ i ] = iter . getfloatnext ( ) ; bytedata [ i ] = new float ( ftdata [ i ] ) . bytevalue ( ) ; buffer . put ( bytedata [ i ] ) ; i ++ ; } buffer = bytebuffer . wrap ( bytedata ) ;	Read data from a top level Variable and send data to a WritableByteChannel.
static float calcelev ( short angle ) { final double maxval = num_ ; double ang = ( double ) angle ; if ( angle < num_ ) ang = ( ~ angle ) + num_ ; double temp = ( ang / maxval ) * num_ ; bigdecimal bd = new bigdecimal ( temp ) ; bigdecimal result = bd . setscale ( num_ , roundingmode . half_down ) ; return result . floatvalue ( ) ; }	Calculate radial elevation of each ray.
static float calcstep ( float range_first , float range_last , short num_bins ) { float step = ( range_last - range_first ) / ( num_bins - num_ ) ; bigdecimal bd = new bigdecimal ( step ) ; bigdecimal result = bd . setscale ( num_ , roundingmode . half_down ) ; return result . floatvalue ( ) ; }	Calculate distance between sequential bins in a ray.
static float calcaz ( short az0 , short az1 ) {	Calculate azimuth of a ray.
static float calcdata ( map < string , number > rechdr , short dty , byte data ) { short [ ] coef = { num_ , num_ , num_ , num_ } ;	Calculate data values from raw ingest data.
static float calcnyquist ( int prf , int wave ) { double tmp = ( prf * wave * num_ ) * num_ ; tmp = tmp * num_ ;	Calculate of Nyquist velocity.
public verticaltransform makeverticaltransform ( netcdfdataset ds , dimension timedim ) { return builder . makemathtransform ( ds , timedim , this ) ; }	Use the builder to make the Vertical Transform function.
static public void setdebugflags ( ucar . nc2 . util . debugflags debugflag ) { debugopen = debugflag . isset ( str_ ) ; debugmissing = debugflag . isset ( str_ ) ; debugmissingdetails = debugflag . isset ( str_ ) ; debugproj = debugflag . isset ( str_ ) ; debugvert = debugflag . isset ( str_ ) ; debugtiming = debugflag . isset ( str_ ) ; }	Set the debug flags.
static public void setextendindex ( boolean b ) { indexfilemodeonopen = b ? indexextendmode . extendwrite : indexextendmode . readonly ; indexfilemodeonsync = b ? indexextendmode . extendwrite : indexextendmode . readonly ; }	Set how indexes are used for both open and sync.
private void readxy ( variable v2 , int ensidx , int timeidx , int levidx , range yrange , range xrange , indexiterator ii ) throws ioexception , invalidrangeexception { gridvariable pv = ( gridvariable ) v2 . getspobject ( ) ; gridhorizcoordsys hsys = pv . gethorizcoordsys ( ) ; int nx = hsys . getnx ( ) ; gridrecord record = pv . findrecord ( ensidx , timeidx , levidx ) ; if ( record == null ) { attribute att = v2 . findattribute ( str_ ) ; float missing_value = ( att == null ) ? - num_ : att . getnumericvalue ( ) . floatvalue ( ) ; int xycount = yrange . length ( ) * xrange . length ( ) ; for ( int j = num_ ; j < xycount ; j ++ ) { ii . setfloatnext ( missing_value ) ; } return ; }	read one YX array.
public boolean ismissingxy ( variable v2 , int timeidx , int ensidx , int levidx ) throws invalidrangeexception { gridvariable pv = ( gridvariable ) v2 . getspobject ( ) ; if ( ( timeidx < num_ ) || ( timeidx >= pv . getntimes ( ) ) ) { throw new invalidrangeexception ( str_ + timeidx ) ; } if ( ( levidx < num_ ) || ( levidx >= pv . getvertnlevels ( ) ) ) { throw new invalidrangeexception ( str_ + levidx ) ; } if ( ( ensidx < num_ ) || ( ensidx >= pv . getnensembles ( ) ) ) { throw new invalidrangeexception ( str_ + ensidx ) ; } return ( null == pv . findrecord ( ensidx , timeidx , levidx ) ) ; }	Is this XY level missing?.
public latlonrect getlatlonboundingbox ( ) { if ( llbb == null ) { if ( ( getxhorizaxis ( ) instanceof coordinateaxis2d ) && ( getyhorizaxis ( ) instanceof coordinateaxis2d ) ) { return null ; } coordinateaxis horizxaxis = getxhorizaxis ( ) ; coordinateaxis horizyaxis = getyhorizaxis ( ) ; if ( islatlon ( ) ) { double startlat = horizyaxis . getminvalue ( ) ; double startlon = horizxaxis . getminvalue ( ) ; double deltalat = horizyaxis . getmaxvalue ( ) - startlat ; double deltalon = horizxaxis . getmaxvalue ( ) - startlon ; latlonpoint llpt = new latlonpointimpl ( startlat , startlon ) ; llbb = new latlonrect ( llpt , deltalat , deltalon ) ; } else { projectionimpl dataprojection = getprojection ( ) ; projectionrect bb = getboundingbox ( ) ; if ( bb != null ) llbb = dataprojection . projtolatlonbb ( bb ) ; } } return llbb ; }	Get horizontal bounding box in lat, lon coordinates.
public void finish ( ) { sequenceoffset = new int [ nelems ] ; total = num_ ; for ( int i = num_ ; i < nelems ; i ++ ) { sequenceoffset [ i ] = total ; total += sequencelen [ i ] ; } sdata = new structuredata [ nelems ] ; for ( int i = num_ ; i < nelems ; i ++ ) sdata [ i ] = new structuredataa ( this , sequenceoffset [ i ] ) ;	Call this when you have set all the sequence lengths.
public static void tab ( stringbuffer sbuff , int tabstop , boolean alwaysone ) { int len = sbuff . length ( ) ; if ( tabstop > len ) { sbuff . setlength ( tabstop ) ; for ( int i = len ; i < tabstop ; i ++ ) { sbuff . setcharat ( i , str_ ) ; } } else if ( alwaysone ) { sbuff . setlength ( len + num_ ) ; sbuff . setcharat ( len , str_ ) ; } }	Blank fill sbuff with blanks, until position tabStop.
public static string pad ( string s , int width , boolean rightjustify ) { if ( s . length ( ) >= width ) { return s ; } stringbuilder sbuff = new stringbuilder ( width ) ; int need = width - s . length ( ) ; sbuff . setlength ( need ) ; for ( int i = num_ ; i < need ; i ++ ) { sbuff . setcharat ( i , str_ ) ; } if ( rightjustify ) { sbuff . append ( s ) ; } else { sbuff . insert ( num_ , s ) ; } return sbuff . tostring ( ) ; }	Create a new string by padding the existing one with blanks to specified width.Do nothing if length is already greater or equal to width.
public static string i ( int v , int width ) { return pad ( integer . tostring ( v ) , width , bool_ ) ; }	Format an integer value.
public static string l ( long v , int width ) { return pad ( long . tostring ( v ) , width , bool_ ) ; }	Format a long value.
public static string formatbytesize ( double size ) { string unit = null ; if ( size > num_ ) { unit = str_ ; size *= num_ ; } else if ( size > num_ ) { unit = str_ ; size *= num_ ; } else if ( size > num_ ) { unit = str_ ; size *= num_ ; } else if ( size > num_ ) { unit = str_ ; size *= num_ ; } else if ( size > num_ ) { unit = str_ ; size *= num_ ; } else { unit = str_ ; } return format . d ( size , num_ ) + str_ + unit ; }	Nicely formatted representation of bytes, eg turn 5.636E7 into.
private static void show ( double d , int sigfig ) { system . out . println ( str_ + d + str_ + sigfig + str_ + format . d ( d , sigfig ) ) ; }	Show the value of a double to the significant figures.
private static void show2 ( double d , int dec_places ) { system . out . println ( str_ + d + str_ + dec_places + str_ + format . dfrac ( d , dec_places ) ) ; }	Show the value of a double with specified number of decimal places.
private string getshapestring ( int [ ] shape ) { stringbuilder buf = new stringbuilder ( ) ; for ( int i = num_ ; i < shape . length ; i ++ ) { if ( i != num_ ) buf . append ( str_ ) ; buf . append ( shape [ i ] ) ; } return buf . tostring ( ) ; }	display name plus the dimensions.
public slice finish ( ) throws dapexception {	Perform sanity checks on a slice and repair where possible.
public string toconstraintstring ( ) throws dapexception { assert this . first != undefined && this . stride != undefined && this . stop != undefined ; if ( ( this . stop - this . first ) == num_ ) { return string . format ( str_ ) ; } else if ( this . stride == num_ ) { if ( ( this . stop - this . first ) == num_ ) return string . format ( str_ , this . first ) ; else return string . format ( str_ , this . first , this . stop - num_ ) ; } else return string . format ( str_ , this . first , this . stride , this . stop - num_ ) ; }	Convert this slice to a stringsuitable for use in a constraint.
static public slice compose ( slice target , slice src ) throws dapexception { long sr_stride = target . getstride ( ) * src . getstride ( ) ; long sr_first = map ( target , src . getfirst ( ) ) ; long lastx = map ( target , src . getlast ( ) ) ; long sr_last = ( target . getlast ( ) < lastx ? target . getlast ( ) : lastx ) ;	Take two slices and compose src wrt targetAssume neither argument is null.
static long map ( slice target , long i ) throws dapexception { if ( i < num_ ) throw new dapexception ( str_ ) ; if ( i > target . getstop ( ) ) throw new dapexception ( str_ ) ; return target . getfirst ( ) + i * target . getstride ( ) ; }	Map ith element of one range wrt a target range.
static public void dumpbytes ( bytebuffer buf0 , boolean skipdmr ) { int savepos = buf0 . position ( ) ; int limit0 = buf0 . limit ( ) ; int skipcount = num_ ; if ( limit0 > maxlimit ) limit0 = maxlimit ; if ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; if ( skipdmr ) { byteorder saveorder = buf0 . order ( ) ; buf0 . order ( byteorder . big_endian ) ;	Provide a simple dump of binary data.
public static earthellipsoid gettype ( string name ) { if ( name == null ) return null ; return hash . get ( name ) ; }	Find the EarthEllipsoid that matches this name.
public static earthellipsoid gettype ( int epsgid ) { collection < earthellipsoid > all = getall ( ) ; for ( earthellipsoid ellipsoid : all ) { if ( ellipsoid . epsgid == epsgid ) { return ellipsoid ; } } return null ; }	Find the EarthEllipsoid that matches this EPSG Id.
private array decodevlendata ( ncstreamproto . datacol dproto , section parentsection ) throws ioexception { datatype datatype = ncstream . convertdatatype ( dproto . getdatatype ( ) ) ; bytebuffer bb = dproto . getprimdata ( ) . asreadonlybytebuffer ( ) ; byteorder bo = dproto . getbigend ( ) ? byteorder . big_endian : byteorder . little_endian ; bb . order ( bo ) ; array alldata = array . factory ( datatype , new int [ ] { dproto . getnelems ( ) } , bb ) ;	vlen inside a Structure.
public arraylist extract ( string url ) throws ioexception { if ( debug ) system . out . println ( str_ + url ) ; baseurl = new url ( url ) ; inputstream in = baseurl . openstream ( ) ; inputstreamreader r = new inputstreamreader ( filtertag ( in ) , cdm . utf8 ) ; htmleditorkit . parsercallback callback = new callerbacker ( ) ; urllist = new arraylist ( ) ; wanturls = bool_ ; wanttext = bool_ ; parser . parse ( r , callback , bool_ ) ; return urllist ; }	Extract all A-HREF contained URLS from the given URL and return in List.
public string gettextcontent ( string url ) throws ioexception { if ( debug ) system . out . println ( str_ + url ) ; baseurl = new url ( url ) ; inputstream in = baseurl . openstream ( ) ; inputstreamreader r = new inputstreamreader ( filtertag ( in ) , cdm . utf8 ) ; htmleditorkit . parsercallback callback = new callerbacker ( ) ; textbuffer = new stringbuffer ( num_ ) ; wanturls = bool_ ; wanttext = bool_ ; parser . parse ( r , callback , bool_ ) ; return textbuffer . tostring ( ) ; }	Extract text content from the given URL and return in String.
private inputstream filtertag ( inputstream in ) throws ioexception { bufferedreader buffin = new bufferedreader ( new inputstreamreader ( in , cdm . utf8 ) ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( num_ ) ; string line = buffin . readline ( ) ; while ( line != null ) { string lline = line . tolowercase ( ) ; if ( lline . contains ( str_ ) )	workaround for HTMLEditorKit.Parser, cant deal with "content-encoding".
@ override public long readtobytechannel ( ucar . nc2 . variable v2 , section section , writablebytechannel channel ) throws java . io . ioexception , ucar . ma2 . invalidrangeexception { array data = readdata ( v2 , section ) ; return iosphelper . copytobytechannel ( data , channel ) ; }	LOOK DataOutputStream uses big-endian.
@ override public void addall ( iterable < attribute > atts ) { for ( attribute att : atts ) addattribute ( att ) ; }	Add all; replace old if has same name.
@ override public boolean removeattribute ( string attname ) { attribute att = findattribute ( attname ) ; return att != null && atts . remove ( att ) ; }	Remove an Attribute by name.
@ override public boolean removeattributeignorecase ( string attname ) { attribute att = findattributeignorecase ( attname ) ; return att != null && atts . remove ( att ) ; }	Remove an Attribute by name, ignoring case.
public list < double > getoffsetsintimeunits ( ) { double start = firstdate . getmillis ( ) ; list < double > result = new arraylist < > ( runtimes . length ) ; for ( int idx = num_ ; idx < runtimes . length ; idx ++ ) { double runtime = ( double ) getruntime ( idx ) ; double msecs = ( runtime - start ) ; result . add ( msecs / timeunit . getvalueinmillisecs ( ) ) ; } return result ; }	Get offsets from firstDate, in units of timeUnit.
public void addactionsourcelistener ( actionsourcelistener l ) { if ( ! eventtype . equals ( l . geteventtypename ( ) ) ) throw new illegalargumentexception ( str_ + eventtype + str_ + l . geteventtypename ( ) ) ; lm . addlistener ( l ) ; l . addactionvaluelistener ( this ) ; }	add an ActionSource listener.
static public date getstandarddate ( string text ) { double value ; string udunitstring ; text = text . trim ( ) ; stringtokenizer stoker = new stringtokenizer ( text ) ; string firsttoke = stoker . nexttoken ( ) ; try { value = double . parsedouble ( firsttoke ) ; udunitstring = text . substring ( firsttoke . length ( ) ) ; } catch ( numberformatexception e ) {	Create a java.util.Date from this udunits String.
static public date getstandardoriso ( string text ) { date result = getstandarddate ( text ) ; if ( result == null ) { dateformatter formatter = new dateformatter ( ) ; result = formatter . getisodate ( text ) ; } return result ; }	Create a java.util.Date from a udunit or ISO String.
public date getdateorigin ( ) { if ( ! ( uu instanceof timescaleunit ) ) return null ; timescaleunit tu = ( timescaleunit ) uu ; return tu . getorigin ( ) ; }	Get the origin Date.
public date getdate ( ) { double secs = timeunit . getvalueinseconds ( value ) ; return new date ( getdateorigin ( ) . gettime ( ) + ( long ) ( num_ * secs ) ) ; }	Get the equivalent java.util.Date.
public date makedate ( double val ) { if ( double . isnan ( val ) ) return null ; double secs = timeunit . getvalueinseconds ( val ) ;	Create a Date from this base unit and the given value.
public double makevalue ( date date ) { double secs = date . gettime ( ) / num_ ; double origin_secs = getdateorigin ( ) . gettime ( ) / num_ ; double diff = secs - origin_secs ; try { timeunit . setvalueinseconds ( diff ) ; } catch ( exception e ) { throw new runtimeexception ( e . getmessage ( ) ) ; } return timeunit . getvalue ( ) ; }	Create the equivalent value from this base unit and the given Date.Inverse of makeDate.
public string makestandarddatestring ( double value ) { date date = makedate ( value ) ; if ( date == null ) return null ; dateformatter formatter = new dateformatter ( ) ; return formatter . todatetimestringiso ( date ) ; }	Make a standard GMT string representation from this unit and given value.
private double getgridspacinginkm ( string type ) { double value = gds . getdouble ( type ) ; if ( double . isnan ( value ) ) return value ; string gridunit = gds . getparam ( griddefrecord . grid_units ) ; simpleunit unit ; if ( gridunit == null || gridunit . length ( ) == num_ ) { unit = simpleunit . meterunit ; } else { unit = simpleunit . factory ( gridunit ) ; } if ( unit != null && simpleunit . iscompatible ( unit . getunitstring ( ) , str_ ) ) { value = unit . convertto ( value , simpleunit . kmunit ) ; } return value ; }	Get the grid spacing in kilometers.
void adddimensionstonetcdffile ( netcdffile ncfile ) { if ( islatlon ) { ncfile . adddimension ( g , new dimension ( str_ , gds . getint ( griddefrecord . ny ) , bool_ ) ) ; ncfile . adddimension ( g , new dimension ( str_ , gds . getint ( griddefrecord . nx ) , bool_ ) ) ; } else { ncfile . adddimension ( g , new dimension ( str_ , gds . getint ( griddefrecord . ny ) , bool_ ) ) ; ncfile . adddimension ( g , new dimension ( str_ , gds . getint ( griddefrecord . nx ) , bool_ ) ) ; } }	Add the dimensions associated with this coord sys to the netCDF file.
private double [ ] addcoordaxis ( netcdffile ncfile , string name , int n , double start , double incr , string units , string desc , string standard_name , axistype axis ) {	Add a coordinate axis.
private boolean makeprojection ( netcdffile ncfile , int projtype ) { switch ( projtype ) { case gridtablelookup . rotatedlatlon : makerotatedlatlon ( ncfile ) ; break ; case gridtablelookup . polarstereographic : makeps ( ) ; break ; case gridtablelookup . lambertconformal : makelc ( ) ; break ; case gridtablelookup . mercator : makemercator ( ) ; break ; case gridtablelookup . orthographic :	Make a projection and add it to the netCDF file.
private void addgdsparams ( variable v ) {	Add the GDS params to the variable as attributes.
private void addcoordsystemvariable ( netcdffile ncfile , string name , string dims ) { variable v = new variable ( ncfile , g , null , name ) ; v . setdatatype ( datatype . char ) ; v . setdimensions ( str_ ) ;	Add coordinate system variable.
private void makelc ( ) {	Make a LambertConformalConic projection.
private void makeps ( ) { string nproj = gds . getparam ( griddefrecord . npproj ) ; double latorigin = ( nproj == null || nproj . equalsignorecase ( str_ ) ) ? num_ : - num_ ;	Make a PolarStereographic projection.
private void makemercator ( ) { double latin = gds . getdouble ( griddefrecord . lad ) ;	Make a Mercator projection.
private void setdxdy ( double startx , double starty , projectionimpl proj ) { double lo2 = gds . getdouble ( griddefrecord . lo2 ) ; double la2 = gds . getdouble ( griddefrecord . la2 ) ; if ( double . isnan ( lo2 ) || double . isnan ( la2 ) ) { return ; } latlonpointimpl endll = new latlonpointimpl ( la2 , lo2 ) ; projectionpointimpl end = ( projectionpointimpl ) proj . latlontoproj ( endll ) ; double dx = math . abs ( end . getx ( ) - startx ) / ( gds . getint ( griddefrecord . nx ) - num_ ) ; double dy = math . abs ( end . gety ( ) - starty ) / ( gds . getint ( griddefrecord . ny ) - num_ ) ; gds . addparam ( griddefrecord . dx , string . valueof ( dx ) ) ; gds . addparam ( griddefrecord . dy , string . valueof ( dy ) ) ; gds . addparam ( griddefrecord . grid_units , str_ ) ; }	Calculate the dx and dy from startx, starty and projection.
protected invdatasetimpl readdataset ( invcatalogimpl catalog , invdatasetimpl parent , element dselem , uri base ) {	read a dataset element.
public object readmetadatacontentfromurl ( invdataset dataset , java . net . uri uri ) throws java . io . ioexception { element elem = readcontentfromurl ( uri ) ; object contentobject = readmetadatacontent ( dataset , elem ) ; if ( debugmetadataread ) system . out . println ( str_ + contentobject . getclass ( ) . getname ( ) ) ; return contentobject ; }	this is only called for ThredddsMetadata.
public int getleveltype1 ( ) {	Get the type for the first level of this GridRecord.
public boolean isvalidfile ( randomaccessfile raf ) throws ioexception { raf . seek ( num_ ) ; string test = raf . readstring ( magic . length ( ) ) ; return test . equals ( magic ) ; }	Check if this is a valid file for this IOServiceProvider.You must make this method thread safe, ie dont keep any state.
public void write ( byte [ ] b , int off , int len ) throws ioexception { count += len ; super . write ( b , off , len ) ; }	Writes an array of bytes to the compressed output stream.
@ override public void setclearname ( string clearname ) { super . setclearname ( clearname ) ; if ( _attr != null ) _attr . setclearname ( clearname ) ; if ( _attrtbl != null ) _attrtbl . setclearname ( clearname ) ; }	Sets the unencoded name of the class instance.
static public string getcoordinatename ( netcdfdataset ds , axistype a ) { list < variable > varlist = ds . getvariables ( ) ; for ( variable v : varlist ) { if ( v instanceof structure ) { list < variable > vars = ( ( structure ) v ) . getvariables ( ) ; for ( variable vs : vars ) { string axistype = ds . findattvalueignorecase ( vs , _coordinate . axistype , null ) ; if ( ( axistype != null ) && axistype . equals ( a . tostring ( ) ) ) return vs . getshortname ( ) ; } } else { string axistype = ds . findattvalueignorecase ( v , _coordinate . axistype , null ) ; if ( ( axistype != null ) && axistype . equals ( a . tostring ( ) ) ) return v . getshortname ( ) ; } } if ( a == axistype . lat ) return findvariablename ( ds , str_ ) ; if ( a == axistype . lon ) return findvariablename ( ds , str_ ) ; if ( a == axistype . time ) return findvariablename ( ds , str_ ) ; if ( a == axistype . height ) { variable v = findvariable ( ds , str_ ) ; if ( null == v ) v = findvariable ( ds , str_ ) ; if ( v != null ) return v . getshortname ( ) ; }	Tries to find the coordinate variable of the specified type.
static public string getcoordinatename ( netcdfdataset ds , axistype a , dimension dim ) { string name = getcoordinatename ( ds , a ) ; if ( name == null ) return null ; variable v = ds . findvariable ( name ) ; if ( v == null ) return null ; if ( v . isscalar ( ) ) return null ; if ( ! v . getdimension ( num_ ) . equals ( dim ) ) return null ; return name ; }	Tries to find the coordinate variable of the specified type, which has the specified dimension as its firsst dimension.
public string buildxml ( ) { stringbuilder response = new stringbuilder ( ) ; response . append ( str_ ) ; if ( code > num_ ) response . append ( string . format ( str_ , code ) ) ; response . append ( str_ ) ; if ( message != null ) response . append ( str_ + getmessage ( ) + str_ ) ; if ( context != null ) response . append ( str_ + getcontext ( ) + str_ ) ; if ( otherinfo != null ) response . append ( str_ + getotherinfo ( ) + str_ ) ; return response . tostring ( ) ; }	Convert an ErrorResponse to the equivalent XML.
public dapexception buildexception ( ) { string xml = buildxml ( ) ; dapexception dapex = new dapexception ( xml ) . setcode ( code ) ; return dapex ; }	Convert an ErrorResponse to the equivalent DapException.
private list < dimension > breakuplevels ( netcdfdataset ds , variable levelvar ) throws ioexception { if ( debugbreakup ) parseinfo . format ( str_ , levelvar . getshortname ( ) ) ; list < dimension > dimlist = new arraylist < > ( ) ; arraychar levelvardata ; try { levelvardata = ( arraychar ) levelvar . read ( ) ; } catch ( ioexception ioe ) { return dimlist ; } list < string > values = null ; string currentunits = null ; arraychar . stringiterator iter = levelvardata . getstringiterator ( ) ; while ( iter . hasnext ( ) ) { string s = iter . next ( ) ; if ( debugbreakup ) parseinfo . format ( str_ , s ) ; stringtokenizer stoke = new stringtokenizer ( s ) ; if ( ! stoke . hasmoretokens ( ) ) continue ;	return the list of Dimensions that were created.
private dimension makezcoordaxis ( netcdfdataset ds , list < string > values , string units ) throws ioexception { int len = values . size ( ) ; string name = makezcoordname ( units ) ; if ( len > num_ ) name = name + integer . tostring ( len ) ; else name = name + values . get ( num_ ) ; stringutil2 . replace ( name , str_ , str_ ) ; dimension dim ; if ( null != ( dim = ds . getrootgroup ( ) . finddimension ( name ) ) ) { if ( dim . getlength ( ) == len ) {	make a new variable out of the list in "values".
private void createnewvariables ( netcdfdataset ds , variable ncvar , list < dimension > newdims , dimension leveldim ) throws invalidrangeexception { list < dimension > dims = ncvar . getdimensions ( ) ; int newdimindex = dims . indexof ( leveldim ) ;	create new variables as sections of ncVar.
private coordinateaxis maketimecoordaxisfromreference ( netcdfdataset ds , variable timevar , array vals ) { variable refvar = ds . findvariable ( str_ ) ; if ( refvar == null ) return null ; double refvalue ; try { array refarray = refvar . read ( ) ; refvalue = refarray . getdouble ( refarray . getindex ( ) ) ;	construct time coordinate from reftime variable.
public static float bitshave ( float value , int bitmask ) { if ( float . isnan ( value ) ) return value ;	Shave n bits off the float.
public static void main ( string [ ] args ) { string filein = ( args . length > num_ ) ? args [ num_ ] : str_ ; string fileout = ( args . length > num_ ) ? args [ num_ ] : str_ ; try ( gribtonetcdfwriter writer = new gribtonetcdfwriter ( filein , fileout ) ) { writer . write ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	Write Grib file to a netcdf4 file.
static public netcdfdataset wrap ( netcdffile ncfile , set < enhance > mode ) throws ioexception { if ( ncfile instanceof netcdfdataset ) { netcdfdataset ncd = ( netcdfdataset ) ncfile ; if ( ! ncd . enhanceneeded ( mode ) ) return ( netcdfdataset ) ncfile ; }	Make NetcdfFile into NetcdfDataset with given enhance mode.
public static netcdffile openfile ( string location , ucar . nc2 . util . canceltask canceltask ) throws ioexception { dataseturl durl = dataseturl . finddataseturl ( location ) ; return openoracquirefile ( null , null , null , durl , - num_ , canceltask , null ) ; }	Factory method for opening a NetcdfFile through the netCDF API.
public void clearcoordinatesystems ( ) { coordsys = new arraylist < > ( ) ; coordaxes = new arraylist < > ( ) ; coordtransforms = new arraylist < > ( ) ; for ( variable v : getvariables ( ) ) { variableenhanced ve = ( variableenhanced ) v ; ve . clearcoordinatesystems ( ) ;	Clear Coordinate System metadata, to allow them to be redone.
public coordinateaxis findcoordinateaxis ( axistype type ) { if ( type == null ) return null ; for ( coordinateaxis v : coordaxes ) { if ( type == v . getaxistype ( ) ) return v ; } return null ; }	Retrieve the CoordinateAxis with the specified Axis Type.
public coordinateaxis findcoordinateaxis ( string fullname ) { if ( fullname == null ) return null ; for ( coordinateaxis v : coordaxes ) { if ( fullname . equals ( v . getfullname ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateAxis with the specified type.
public coordinatesystem findcoordinatesystem ( string name ) { if ( name == null ) return null ; for ( coordinatesystem v : coordsys ) { if ( name . equals ( v . getname ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateSystem with the specified name.
public coordinatetransform findcoordinatetransform ( string name ) { if ( name == null ) return null ; for ( coordinatetransform v : coordtransforms ) { if ( name . equals ( v . getname ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateTransform with the specified name.
public boolean enhanceneeded ( set < enhance > want ) throws ioexception { if ( want == null ) return bool_ ; for ( enhance mode : want ) { if ( ! this . enhancemode . contains ( mode ) ) return bool_ ; } return bool_ ; }	is this enhancement already done ?.
public void setvalues ( variable v , int npts , double start , double incr ) { if ( npts != v . getsize ( ) ) throw new illegalargumentexception ( str_ + npts + str_ + v . getsize ( ) ) ; array data = array . makearray ( v . getdatatype ( ) , npts , start , incr ) ; if ( v . getrank ( ) != num_ ) data = data . reshape ( v . getshape ( ) ) ; v . setcacheddata ( data , bool_ ) ; }	Generate the list of values from a starting value and an increment.Will reshape to variable if needed.
public void setvalues ( variable v , list < string > values ) throws illegalargumentexception { array data = array . makearray ( v . getdatatype ( ) , values ) ; if ( data . getsize ( ) != v . getsize ( ) ) throw new illegalargumentexception ( str_ + v . getfullname ( ) + str_ + v . getsize ( ) + str_ + data . getsize ( ) ) ; if ( v . getrank ( ) != num_ )	Set the data values from a list of Strings.
static public array makearray ( datatype dtype , list < string > stringvalues ) throws numberformatexception { return array . makearray ( dtype , stringvalues ) ; }	Make a 1D array from a list of strings.
public long index ( ) { long offset = num_ ; for ( int i = num_ ; i < this . indices . length ; i ++ ) { offset *= this . dimsizes [ i ] ; offset += this . indices [ i ] ; } return offset ; }	Compute the linear indexfrom the current odometer indices.
static public mfileos7 getexistingfile ( string filename ) throws ioexception { if ( filename == null ) return null ; path path = paths . get ( filename ) ; if ( files . exists ( path ) ) return new mfileos7 ( path ) ; return null ; }	Make MFileOS7 if file exists, otherwise return null.
public list < esrifeature > getfeatures ( rectangle2d bbox ) { if ( bbox == null ) return features ; list < esrifeature > list = new arraylist < > ( ) ; for ( esrifeature gf : features ) { if ( gf . getbounds2d ( ) . intersects ( bbox ) ) list . add ( gf ) ; } return list ; }	Get a List of all the features in the shapefile that intersectthe specified bounding box.
private void discretize ( double [ ] d , int n ) { if ( coarseness == num_ ) return ; for ( int i = num_ ; i < n ; i ++ ) { d [ i ] = ( math . rint ( resolution * d [ i ] ) / resolution ) ; } }	Discretize elements of array to a lower resolution.
public void add ( threddsmetadata tmd , boolean includeinherited ) { creators . addall ( tmd . getcreators ( ) ) ; contributors . addall ( tmd . getcontributors ( ) ) ; dates . addall ( tmd . getdates ( ) ) ; docs . addall ( tmd . getdocumentation ( ) ) ; keywords . addall ( tmd . getkeywords ( ) ) ; projects . addall ( tmd . getprojects ( ) ) ; properties . addall ( tmd . getproperties ( ) ) ; publishers . addall ( tmd . getpublishers ( ) ) ; variables . addall ( tmd . getvariables ( ) ) ; if ( includeinherited ) metadata . addall ( tmd . getmetadata ( ) ) ; else { for ( invmetadata mdata : tmd . getmetadata ( ) ) { if ( ! mdata . isinherited ( ) ) metadata . add ( mdata ) ; } }	Add all the content from another ThreddsMetadata.
public void adddocumentation ( string type , string content ) { if ( content == null ) { removedocumentation ( type ) ; return ; } content = content . trim ( ) ; for ( invdocumentation doc : getdocumentation ( ) ) { string dtype = doc . gettype ( ) ; if ( ( dtype != null ) && dtype . equalsignorecase ( type ) ) { doc . setinlinecontent ( content ) ; return ; } } if ( content . length ( ) > num_ ) adddocumentation ( new invdocumentation ( null , null , null , type , content ) ) ; }	set specified type of documentation.
public void removedocumentation ( string type ) { iterator iter = docs . iterator ( ) ; while ( iter . hasnext ( ) ) { invdocumentation doc = ( invdocumentation ) iter . next ( ) ; string dtype = doc . gettype ( ) ; if ( ( dtype != null ) && dtype . equalsignorecase ( type ) ) iter . remove ( ) ; } }	remove all instances of specified type of documentation.
private int getmaxbytes ( long start ) { int segno = num_ ; while ( start >= segmax [ segno ] ) segno ++ ; return ( int ) ( segmax [ segno ] - start ) ; }	how many more bytes are in this segment ?.
public static boolean ismine ( netcdffile ncfile ) { string cs = ncfile . findattvalueignorecase ( null , cdm . conventions , null ) ; if ( cs != null ) return bool_ ; string s = ncfile . findattvalueignorecase ( null , str_ , null ) ; if ( ( s == null ) || ! ( s . equalsignorecase ( str_ ) || s . equalsignorecase ( str_ ) ) ) return bool_ ; if ( ( null == ncfile . findglobalattribute ( str_ ) ) || ( null == ncfile . findglobalattribute ( str_ ) ) || ( null == ncfile . findglobalattribute ( str_ ) ) || ( null == ncfile . findglobalattribute ( str_ ) ) || ( null == ncfile . findglobalattribute ( str_ ) ) ) return bool_ ; return ! ( null == ncfile . finddimension ( str_ ) || null == ncfile . finddimension ( str_ ) ) ; }	Is this my file?.
static public list < string > breakupconventionnames ( string convattvalue ) { list < string > names = new arraylist < > ( ) ; if ( ( convattvalue . indexof ( str_ ) > num_ ) || ( convattvalue . indexof ( str_ ) > num_ ) ) { stringtokenizer stoke = new stringtokenizer ( convattvalue , str_ ) ; while ( stoke . hasmoretokens ( ) ) { string name = stoke . nexttoken ( ) ; names . add ( name . trim ( ) ) ; } } else if ( ( convattvalue . indexof ( str_ ) > num_ ) ) { stringtokenizer stoke = new stringtokenizer ( convattvalue , str_ ) ; while ( stoke . hasmoretokens ( ) ) { string name = stoke . nexttoken ( ) ; names . add ( name . trim ( ) ) ; } } else { stringtokenizer stoke = new stringtokenizer ( convattvalue , str_ ) ; while ( stoke . hasmoretokens ( ) ) { string name = stoke . nexttoken ( ) ; names . add ( name . trim ( ) ) ; } } return names ; }	Breakup list of Convention names in the Convention attribute in CF compliant way.
static public string buildconventionattribute ( string mainconv , string ... convatts ) { list < string > result = new arraylist < > ( ) ; result . add ( mainconv ) ; for ( string convs : convatts ) { if ( convs == null ) continue ; list < string > ss = breakupconventionnames ( convs ) ;	Build a list of Conventions.
@ override public void buildcoordinatesystems ( netcdfdataset ncdataset ) {	Heres where the work is to identify coordinate axes and coordinate systems.
protected void findcoordinateaxes ( netcdfdataset ncdataset ) { for ( varprocess vp : varlist ) { if ( vp . coordaxes != null ) findcoordinateaxes ( vp , vp . coordaxes ) ; if ( vp . coordinates != null ) findcoordinateaxes ( vp , vp . coordinates ) ; } }	Identify coordinate axes, set VarProcess.isCoordinateAxis = true.Default is to look for those referenced by _CoordinateAxes attribute.Note coordinate variables are already identified.
protected void findcoordinatesystems ( netcdfdataset ncdataset ) { for ( varprocess vp : varlist ) { if ( vp . coordsys != null ) { stringtokenizer stoker = new stringtokenizer ( vp . coordsys ) ; while ( stoker . hasmoretokens ( ) ) { string vname = stoker . nexttoken ( ) ; varprocess ap = findvarprocess ( vname , vp ) ; if ( ap != null ) { if ( ! ap . iscoordinatesystem ) parseinfo . format ( str_ , vname , vp . v . getfullname ( ) ) ; ap . iscoordinatesystem = bool_ ; } else { parseinfo . format ( str_ , vname , vp . v . getfullname ( ) ) ; useradvice . format ( str_ , vname , vp . v . getfullname ( ) ) ; } } } } }	Identify coordinate systems, set VarProcess.isCoordinateSystem = true.Default is to look for those referenced by _CoordinateSystems attribute.
protected void makecoordinatesystems ( netcdfdataset ncdataset ) { for ( varprocess vp : varlist ) { if ( vp . iscoordinatesystem ) { vp . makecoordinatesystem ( ) ; } } }	Take all previously identified Coordinate Systems and create aCoordinateSystem object.
protected void makecoordinatesystemsmaximal ( netcdfdataset ncdataset ) { boolean requirecompletecoordsys = ! ncdataset . getenhancemode ( ) . contains ( netcdfdataset . enhance . incompletecoordsystems ) ; for ( varprocess vp : varlist ) { variableenhanced ve = ( variableenhanced ) vp . v ; if ( vp . hascoordinatesystem ( ) || ! vp . isdata ( ) ) continue ;	If a variable still doesnt have a coordinate system, use hueristics to try to find one that was probably forgotten.Examine existing CS.
protected boolean iscoordinateaxisforvariable ( variable axis , variableenhanced v ) { list < dimension > vardims = v . getdimensionsall ( ) ; list < dimension > axisdims = axis . getdimensionsall ( ) ;	Does this axis "fit" this variable.True if all of the dimensions in the axis also appear in the variable.If char variable, last dimension is left out.
public void subset ( invdataset ds ) { invdatasetimpl dataset = ( invdatasetimpl ) ds ;	Munge this catalog so the given dataset is the top catalog.
public void filter ( datasetfilter filter ) { mark ( filter , topdataset ) ; delete ( topdataset ) ; this . filter = filter ; }	Munge this catalog to remove any dataset that doesnt pass through the filter.
private boolean mark ( datasetfilter filter , invdatasetimpl ds ) { if ( ds instanceof invcatalogref ) { invcatalogref catref = ( invcatalogref ) ds ; if ( ! catref . isread ( ) ) return bool_ ; }	unread CatalogRefs are always kept.
public void initonce ( httpservletrequest req ) throws senderror { if ( once ) return ; once = bool_ ; log . info ( getclass ( ) . getname ( ) + str_ ) ; if ( this . tdscontext == null ) throw new senderror ( httpservletresponse . sc_internal_server_error , str_ ) ;	Invoked on first get so that everything is available,especially Spring stuff.
public boolean count ( string name , comparable value ) { counter counter = map . get ( name ) ; if ( counter == null ) { counter = add ( name ) ; } return counter . count ( value ) ; }	Add value to the named counter.Add counter if it doesnt already exist.
private void add ( final string name , final string symbol , final double definition ) throws prefixexistsexception { addname ( name , definition ) ; addsymbol ( symbol , definition ) ; }	Adds a prefix to the database.
public int compare ( tablerow other , int col ) { string s1 = getvalueat ( col ) . tostring ( ) ; string s2 = other . getvalueat ( col ) . tostring ( ) ; int ret = s1 . comparetoignorecase ( s2 ) ;	for other behavior, override this; use compareXXX routines.
protected int compareboolean ( tablerow other , int col , boolean b1 , boolean b2 ) {	for use by the subclass.
void passreserved ( xmlattributemap map , dapnode node ) throws parseexception { try { dapattribute attr = null ; for ( map . entry < string , saxevent > entry : map . entryset ( ) ) { saxevent event = entry . getvalue ( ) ; string key = entry . getkey ( ) ; string value = event . value ; if ( isreserved ( key ) ) node . addxmlattribute ( key , value ) ; } } catch ( dapexception de ) { throw new parseexception ( de ) ; } }	add any reserved xml attributes to a node unchanged.
private boolean hasvaliddaterange ( string time_start , string time_end , string time_duration ) {	Determine if a valid date range was specified.
synchronized public void register ( string classname , boolean last ) throws dapexception { try { class < ? extends dsp > klass = ( class < ? extends dsp > ) loader . loadclass ( classname ) ; register ( klass , last ) ; } catch ( classnotfoundexception e ) { throw new dapexception ( e ) ; } }	Register a DSP, using its class string name.
synchronized public void register ( class < ? extends dsp > klass , boolean last ) {	Register a DSP class.
synchronized public boolean registered ( class < ? extends dsp > klass ) { for ( registration r : registry ) { if ( r . dspclass == klass ) return bool_ ; } return bool_ ; }	See if a specific DSP is registered.
synchronized public void unregister ( class < ? extends dsp > klass ) { for ( int i = num_ ; i < registry . size ( ) ; i ++ ) { if ( registry . get ( i ) . dspclass == klass ) { registry . remove ( i ) ; break ; } } }	Unregister dsp.
public double getforecasttimeintervalsizeinhours ( grib2pds pds ) { grib2pds . pdsinterval pdsintv = ( grib2pds . pdsinterval ) pds ; int timeunitorg = pds . gettimeunit ( ) ;	Get interval size in units of hours.Only use in GribVariable to decide on variable identity when intvMerge = false.
@ nullable public int [ ] getforecasttimeintervaloffset ( grib2record gr ) { timecoordintvdatevalue tinvd = getforecasttimeinterval ( gr ) ; if ( tinvd == null ) return null ; grib2pds pds = gr . getpds ( ) ; int unit = converttimeunit ( pds . gettimeunit ( ) ) ; timecoordintvvalue tinv = tinvd . convertreferencedate ( gr . getreferencedate ( ) , grib2utils . getcalendarperiod ( unit ) ) ; if ( tinv == null ) return null ; int [ ] result = new int [ num_ ] ; result [ num_ ] = tinv . getbounds1 ( ) ; result [ num_ ] = tinv . getbounds2 ( ) ; return result ; }	If this has a time interval coordinate, get time interval.
@ override public vertcoordtype getvertunit ( int code ) {	Unit of vertical coordinate.from Grib2 code table 4.5.Only levels with units get a dimension added.
public void sort ( ) { list < dapnode > sorted = new arraylist < dapnode > ( ) ; sortr ( this , sorted ) ;	Sort the nodelist into prefix left to right order.
static public varatt findvariablewithattribute ( netcdfdataset ds , string attname ) { for ( variable v : ds . getvariables ( ) ) { attribute att = v . findattributeignorecase ( attname ) ; if ( att != null ) return new varatt ( v , att ) ; }	Find first variable with given attribute name.
static public variable findvariablewithattributevalue ( netcdfdataset ds , string attname , string attvalue ) { for ( variable v : ds . getvariables ( ) ) { string havevalue = ds . findattvalueignorecase ( v , attname , null ) ; if ( ( havevalue != null ) && havevalue . equals ( attvalue ) ) return v ; }	Find first variable with given attribute name and value.If not found, search one level into structures.
static public string findnameofvariablewithattributevalue ( netcdfdataset ds , string attname , string attvalue ) { variable v = findvariablewithattributevalue ( ds , attname , attvalue ) ; return ( v == null ) ? null : v . getshortname ( ) ; }	Find first variable with given attribute name and value.
static public variable findvariablewithattributevalue ( structure struct , string attname , string attvalue ) { for ( variable v : struct . getvariables ( ) ) { attribute att = v . findattributeignorecase ( attname ) ; if ( ( att != null ) && att . getstringvalue ( ) . equals ( attvalue ) ) return v ; } return null ; }	Find first member variable in this struct with given attribute name and value.
static public structure findnestedstructure ( structure s ) { for ( variable v : s . getvariables ( ) ) { if ( ( v instanceof structure ) ) return ( structure ) v ; } return null ; }	Find first nested structure.
static public boolean hasnetcdf3recordstructure ( netcdfdataset ds ) { variable v = ds . findvariable ( str_ ) ; return ( v != null ) && ( v . getdatatype ( ) == datatype . structure ) ; }	Does this dataset have a record structure? netcdf-3 specific.
static public string getliteral ( netcdfdataset ds , string key , formatter errlog ) { if ( key . startswith ( str_ ) ) { string val = ds . findattvalueignorecase ( null , key . substring ( num_ ) , null ) ; if ( ( val == null ) && ( errlog != null ) ) errlog . format ( str_ , key ) ; return val ; } return key ; }	Translate key to value.
static public featuretype getfeaturetype ( netcdfdataset ds , string key , formatter errlog ) { featuretype ft = null ; string fts = getliteral ( ds , key , errlog ) ; if ( fts != null ) { ft = featuretype . valueof ( fts . touppercase ( ) ) ; if ( ( ft == null ) && ( errlog != null ) ) errlog . format ( str_ , fts , key ) ; } return ft ; }	Turn the key into a String and return the corresponding featureType, if any.
static public string getvariablename ( netcdfdataset ds , string key , formatter errlog ) { variable v = null ; string vs = getliteral ( ds , key , errlog ) ; if ( vs != null ) { v = ds . findvariable ( vs ) ; if ( ( v == null ) && ( errlog != null ) ) errlog . format ( str_ , vs , key ) ; } return v == null ? null : v . getshortname ( ) ; }	Find the variable pointed to by key.
public double getcoordvalue ( int j , int i ) { if ( coords == null ) doread ( ) ; return coords . get ( j , i ) ; }	Get the coordinate value at the i, j index.
static private double connectlon ( double connect , double val ) { if ( double . isnan ( connect ) ) return val ; if ( double . isnan ( val ) ) return val ; double diff = val - connect ; if ( math . abs ( diff ) < max_jump ) return val ;	larger than you would ever expect.
public double [ ] getcoordvalues ( ) { if ( coords == null ) doread ( ) ; if ( ! isnumeric ( ) ) throw new unsupportedoperationexception ( str_ ) ; return ( double [ ] ) coords . get1djavaarray ( datatype . double ) ; }	Get the coordinate values as a 1D double array, in canonical order.
public coordinateaxis2d section ( range r1 , range r2 ) throws invalidrangeexception { list < range > section = new arraylist < > ( ) ; section . add ( r1 ) ; section . add ( r2 ) ; return ( coordinateaxis2d ) section ( section ) ; }	Create a new CoordinateAxis2D as a section of this CoordinateAxis2D.
private int findclosest ( arraydouble . d2 boundsforrun , double target ) { double mindiff = double . max_value ; int idxfound = - num_ ; int n = boundsforrun . getshape ( ) [ num_ ] ; for ( int i = num_ ; i < n ; i ++ ) { double midpoint = ( boundsforrun . get ( i , num_ ) + boundsforrun . get ( i , num_ ) ) / num_ ; double diff = math . abs ( midpoint - target ) ; if ( diff < mindiff ) { mindiff = diff ; idxfound = i ; } } return idxfound ; }	return index of closest value to target.
@ deprecated public string getname ( ) { switch ( sort ) { case attribute : case dimension : case enumeration :	getName is deprecated because, as the code below shows,it has no consistent meaning.
public void addaction ( string menuname , action act ) { act . putvalue ( action . name , menuname ) ; super . add ( act ) ; }	Add an action to the popup menu.Note that the menuName is made the NAME value of the action.
public match match ( string path ) { sortedmap < string , match > tail = treemap . tailmap ( path ) ; if ( tail . isempty ( ) ) return null ; string after = tail . firstkey ( ) ;	Find the longest match.
public static void main ( string [ ] args ) { projectionmanager d = new projectionmanager ( null , null ) ; d . setvisible ( ) ; }	testing 1-2-3.
public int indexof ( byte [ ] data , int start , int max ) { int j = num_ ; if ( data . length == num_ ) return - num_ ; if ( start + max > data . length ) system . out . println ( str_ ) ; for ( int i = start ; i < start + max ; i ++ ) { while ( j > num_ && match [ j ] != data [ i ] ) j = failure [ j - num_ ] ; if ( match [ j ] == data [ i ] ) j ++ ; if ( j == match . length ) return i - match . length + num_ ; } return - num_ ; }	Finds the first occurrence of match in data.
public static synchronized void add ( url url , sourcepicture sp ) { tools . log ( str_ + url . tostring ( ) ) ; if ( sp . getsourcebufferedimage ( ) == null ) { tools . log ( str_ ) ; return ; } if ( ( maxcache < num_ ) ) { tools . log ( str_ ) ; return ; } if ( isincache ( url ) ) { tools . log ( str_ + url . tostring ( ) + str_ ) ; return ; } if ( picturecache . size ( ) >= maxcache ) removeleastpopular ( ) ; if ( picturecache . size ( ) < maxcache ) picturecache . put ( url . tostring ( ) , sp ) ;	store an image in the cache.
public static synchronized void reportcache ( ) { tools . log ( str_ + integer . tostring ( picturecache . size ( ) ) + str_ + integer . tostring ( maxcache ) ) ;	method to inspect the cache.
public static void stopbackgroundloading ( ) { enumeration e = cacheloadsinprogress . elements ( ) ; while ( e . hasmoreelements ( ) ) { ( ( sourcepicture ) e . nextelement ( ) ) . stoploading ( ) ; } }	method to stop all background loading.
public static boolean stopbackgroundloadingexcept ( url exemptionurl ) { sourcepicture sp ; string exemptionurlstring = exemptionurl . tostring ( ) ; enumeration e = cacheloadsinprogress . elements ( ) ; boolean inprogress = bool_ ; while ( e . hasmoreelements ( ) ) { sp = ( ( sourcepicture ) e . nextelement ( ) ) ; if ( ! sp . geturlstring ( ) . equals ( exemptionurlstring ) ) sp . stoploading ( ) ; else { tools . log ( str_ ) ; inprogress = bool_ ; } } return inprogress ; }	method to stop all background loading except the indicated file.
static public httpmethod get ( httpsession session , string legalurl ) throws httpexception { return makemethod ( httpsession . methods . get , session , legalurl ) ; }	Static factory methods for creating HTTPMethod instances.
static protected httpmethod makemethod ( httpsession . methods m , httpsession session , string url ) throws httpexception { httpmethod meth = null ; if ( mockmethodclass == null ) {	Common method creation code so we can isolate mocking.
public object nextfloat ( daptype basetype ) throws dapexception { typesort atomtype = basetype . gettypesort ( ) ; switch ( atomtype ) { case float32 : return new float [ ] { random . nextfloat ( ) } ; case float64 : return new double [ ] { random . nextdouble ( ) } ; default : break ; } throw new dapexception ( str_ + basetype ) ; }	return a float type value.
public int nextcount ( int max ) throws dapexception { int min = num_ ; if ( max < min || min < num_ ) throw new dapexception ( str_ ) ; int range = ( max + num_ ) - min ;	Return an integer in range 1..max inclusive.
@ override protected array readdata ( variable cdmvar , section section ) throws ioexception , invalidrangeexception {	Primary read entry point.This is the primary implementor of Variable.read.
private static filesystemprovider getprovider ( uri uri ) throws ioexception { if ( fsproviders . containskey ( uri . getscheme ( ) ) ) { return fsproviders . get ( uri . getscheme ( ) ) ; } else { filesystem fs ; try { fs = filesystems . newfilesystem ( uri , new hashmap < string , object > ( ) , thread . currentthread ( ) . getcontextclassloader ( ) ) ; } catch ( filesystemalreadyexistsexception e ) { fs = filesystems . getfilesystem ( uri ) ; } fsproviders . put ( uri . getscheme ( ) , fs . provider ( ) ) ; return fs . provider ( ) ; } }	filesystem can't be re-created either.
private static void readstationtable ( ) throws ioexception { stationtablehash = new hashmap < string , station > ( ) ; classloader cl = level2volumescan . class . getclassloader ( ) ; inputstream is = cl . getresourceasstream ( str_ ) ; list < tableparser . record > recs = tableparser . readtable ( is , str_ , num_ ) ; for ( tableparser . record record : recs ) { station s = new station ( ) ; s . id = str_ + record . get ( num_ ) ; s . name = record . get ( num_ ) + str_ + record . get ( num_ ) ; s . lat = ( double ) record . get ( num_ ) * num_ ; s . lon = ( double ) record . get ( num_ ) * num_ ; s . elev = ( double ) record . get ( num_ ) ; stationtablehash . put ( s . id , s ) ; if ( showstations ) system . out . println ( str_ + s ) ; } }	this is the old Gempak table, not as precise.
@ override public int getindex ( t gr ) { integer result = valmap . get ( extract ( gr ) ) ; return ( result == null ) ? num_ : result ; }	Used by CoordinateND.makeSparseArray; not used by CoordinateTime2D.
protected void removedatavariable ( string varname ) { iterator iter = datavariables . iterator ( ) ; while ( iter . hasnext ( ) ) { variablesimpleif v = ( variablesimpleif ) iter . next ( ) ; if ( v . getshortname ( ) . equals ( varname ) ) iter . remove ( ) ; } }	reminder for subclasses to set this.
private string cloud_hgt2_meters ( string height ) { if ( height . equals ( str_ ) ) { return str_ ; } else {	convert cloud height to meters.
@ override public array reallyread ( variable mainv , section section , canceltask canceltask ) throws ioexception , invalidrangeexception { fmrcinvlite . gridset . grid gridlite = ( fmrcinvlite . gridset . grid ) mainv . getspobject ( ) ;	here is where agg variables get read.
public void setnumcolors ( int n ) { if ( n != ncolors ) { colors = new color [ n ] ; int prevn = math . min ( ncolors , n ) ; system . arraycopy ( usecolors , num_ , colors , num_ , prevn ) ; for ( int i = ncolors ; i < n ; i ++ ) colors [ i ] = color . white ; usecolors = colors ; ncolors = n ; edge = new double [ ncolors ] ; hist = new int [ ncolors + num_ ] ; } }	Set the number of colors in the colorscale.
private affinetransform calctransform ( rectangle2d screen , bounds world ) {	map world coords to screen coords.
static authscope uritoauthscope ( uri uri ) { assert ( uri != null ) ; return new authscope ( uri . gethost ( ) , uri . getport ( ) , authscope . any_realm , uri . getscheme ( ) ) ; }	Create an AuthScope from a URI; remove any principal.
public void finish ( ) { if ( gcs . size ( ) == num_ ) return ; if ( gcs . size ( ) == num_ ) { list hcs = gethorizcoordsys ( ) ; griddefrecord . compare ( ( griddefrecord ) hcs . get ( num_ ) , ( griddefrecord ) hcs . get ( num_ ) ) ; } }	compares GDS for duplicates.
public boolean isreciprocalof ( final factor that ) { return getbase ( ) . equals ( that . getbase ( ) ) && getexponent ( ) == - that . getexponent ( ) ; }	Indicates if this Factor is the reciprocal of another Factor.
public invcatalog getdircatalog ( file directory , string filterpattern , boolean sortinincreasingorder , boolean adddatasetsize ) { return ( this . getdircatalog ( directory , filterpattern , sortinincreasingorder , null , adddatasetsize , null , null , null ) ) ; }	Return a catalog for the given directory.
public int findidx ( int want ) { if ( isconstant ) return ( want == start ) ? num_ : - num_ ; if ( issequential ) return want - start ; if ( issorted ) { return arrays . binarysearch ( raw , want ) ; }	Find which index holds the value want.
private object readmetadatacontentfromurl ( invdataset dataset , string urlstring ) throws java . net . malformedurlexception , java . io . ioexception {	Create an InvMetadata content object from an XML document at a named URL.The content object is an ArrayList of CatalogGenConfig instances.
public object readmetadatacontent ( invdataset dataset , org . jdom2 . element mdataelement ) { log . debug ( str_ ) ;	Create an InvMetadata content object from an org.w3c.dom.Element.The content object is an ArrayList of CatalogGenConfig instances.
public void addmetadatacontent ( org . jdom2 . element mdatajdomelement , object contentobject ) {	Serialize the InvMetadata content object to a org.w3c.dom.Element.
public boolean validatemetadatacontent ( object contentobject , stringbuilder out ) { boolean ok = bool_ ; arraylist catgenconfiglist = ( arraylist ) contentobject ; iterator iter = catgenconfiglist . iterator ( ) ; while ( iter . hasnext ( ) ) { cataloggenconfig catgenconf = ( cataloggenconfig ) iter . next ( ) ; ok &= catgenconf . validate ( out ) ; } return ok ; }	Validate the content object.
private cataloggenconfig readcatgenconfigelement ( invdataset parentdataset , element catgenconfelement ) { string type = catgenconfelement . getattributevalue ( str_ ) ; cataloggenconfig catgenconf = new cataloggenconfig ( parentdataset , type ) ;	Return a CatalogGenConfig when given a 'catalogGenConfig' JDOM element.
private datasetsource readdatasetsourceelement ( invdataset parentdataset , element dssourceelement ) { string name = dssourceelement . getattributevalue ( str_ ) ; string type = dssourceelement . getattributevalue ( str_ ) ; string structure = dssourceelement . getattributevalue ( str_ ) ; string accesspoint = dssourceelement . getattributevalue ( str_ ) ; string createcatalogrefs = dssourceelement . getattributevalue ( str_ ) ;	Return a DatasetSource when given a 'datasetSource' JDOM element.
private datasetnamer readdatasetnamerelement ( invdataset parentdataset , element dsnamerelement ) { string name = dsnamerelement . getattributevalue ( str_ ) ; string addlevel = dsnamerelement . getattributevalue ( str_ ) ; string type = dsnamerelement . getattributevalue ( str_ ) ; string matchpattern = dsnamerelement . getattributevalue ( str_ ) ; string substitutepattern = dsnamerelement . getattributevalue ( str_ ) ; string attribcontainer = dsnamerelement . getattributevalue ( str_ ) ; string attribname = dsnamerelement . getattributevalue ( str_ ) ; datasetnamer dsnamer = new datasetnamer ( parentdataset , name , addlevel , type , matchpattern , substitutepattern , attribcontainer , attribname ) ; return ( dsnamer ) ; }	Return a DatasetNamer when given a 'datasetNamer' JDOM element.
private datasetfilter readdatasetfilterelement ( datasetsource parentdatasetsource , element dsfilterelement ) { string name = dsfilterelement . getattributevalue ( str_ ) ; string type = dsfilterelement . getattributevalue ( str_ ) ; string matchpattern = dsfilterelement . getattributevalue ( str_ ) ; datasetfilter dsfilter = new datasetfilter ( parentdatasetsource , name , datasetfilter . type . gettype ( type ) , matchpattern ) ; string matchpatterntarget = dsfilterelement . getattributevalue ( str_ ) ; dsfilter . setmatchpatterntarget ( matchpatterntarget ) ; if ( dsfilterelement . getattributevalue ( str_ ) != null ) { boolean applytocollectiondatasets = boolean . valueof ( dsfilterelement . getattributevalue ( str_ ) ) . booleanvalue ( ) ; dsfilter . setapplytocollectiondatasets ( applytocollectiondatasets ) ; } if ( dsfilterelement . getattributevalue ( str_ ) != null ) { boolean applytoatomicdatasets = boolean . valueof ( dsfilterelement . getattributevalue ( str_ ) ) . booleanvalue ( ) ; dsfilter . setapplytoatomicdatasets ( applytoatomicdatasets ) ; } if ( dsfilterelement . getattributevalue ( str_ ) != null ) { boolean rejectmatchingdatasets = boolean . valueof ( dsfilterelement . getattributevalue ( str_ ) ) . booleanvalue ( ) ; dsfilter . setrejectmatchingdatasets ( rejectmatchingdatasets ) ; } return ( dsfilter ) ; }	Return a DatasetFilter when given a 'datasetFilter' JDOM element.
private resultservice readresultserviceelement ( invdataset parentdataset , element resultserviceelement ) { string name = resultserviceelement . getattributevalue ( str_ ) ; string servicetype = resultserviceelement . getattributevalue ( str_ ) ; string base = resultserviceelement . getattributevalue ( str_ ) ; string suffix = resultserviceelement . getattributevalue ( str_ ) ; string accesspointheader = resultserviceelement . getattributevalue ( str_ ) ; return ( new resultservice ( name , servicetype . gettype ( servicetype ) , base , suffix , accesspointheader ) ) ; }	Return a ResultService when given a 'resultService' JDOM element.
private org . jdom2 . element createcatgenconfigelement ( cataloggenconfig cgc ) {	Create a 'catalogGenConfig' JDOM element.
private org . jdom2 . element createdatasetsourceelement ( datasetsource dssource ) { element dsselem = new element ( str_ , catalog_gen_config_namespace_0_5 ) ; if ( dssource != null ) {	Create a 'DatasetSource' JDOM element.
private org . jdom2 . element createdatasetnamerelement ( datasetnamer dsnamer ) { element dsnelem = new element ( str_ , catalog_gen_config_namespace_0_5 ) ; if ( dsnamer != null ) {	Create a 'DatasetNamer' JDOM element.
private org . jdom2 . element createdatasetfilterelement ( datasetfilter dsfilter ) { element dsfelem = new element ( str_ , catalog_gen_config_namespace_0_5 ) ; if ( dsfilter != null ) {	Create a 'DatasetFilter' JDOM element.
private org . jdom2 . element createresultserviceelement ( resultservice resultservice ) { element rselem = new element ( str_ , catalog_gen_config_namespace_0_5 ) ; if ( resultservice != null ) {	Create a 'ResultService' JDOM element.
static public boolean isset ( string flagname ) { if ( store == null ) return bool_ ; namepart np = partit ( flagname ) ; if ( debug ) { try { if ( ( np . storename . length ( ) > num_ ) && ! store . nodeexists ( np . storename ) ) system . out . println ( str_ + flagname + str_ + np ) ; else if ( null == store . node ( np . storename ) . get ( np . keyname , null ) ) system . out . println ( str_ + flagname + str_ + np ) ; } catch ( backingstoreexception e ) { } }	Return the value of the named flag.
static public void constructmenu ( jmenu topmenu ) { if ( debug ) system . out . println ( str_ ) ; if ( topmenu . getitemcount ( ) > num_ ) topmenu . removeall ( ) ; try { addtomenu ( topmenu , store ) ;	Construct cascading pull-aside menus using the values of the debug flagsin the Preferences object.
public void addparameters ( string tbl ) throws ioexception { try ( inputstream is = getinputstream ( tbl ) ) { if ( is == null ) { throw new ioexception ( str_ + tbl ) ; } string content = readcontents ( is ) ;	Add parameters from the table.
private gempakparameter makeparameter ( string [ ] words ) { int num = num_ ; string description ; if ( words [ num_ ] != null ) { num = ( int ) double . parsedouble ( words [ num_ ] ) ; } if ( ( words [ num_ ] == null ) || words [ num_ ] . equals ( str_ ) ) {	Make a parameter from the tokens.
public gempakparameter getparameter ( string name ) { gempakparameter param = parammap . get ( name ) ; if ( param == null ) {	Get the parameter for the given name.
private string readcontents ( inputstream is ) throws ioexception { return new string ( readbytes ( is ) , cdm . utf8charset ) ; }	Read in the bytes from the given InputStreamand construct and return a String.Closes the InputStream argument.
private byte [ ] readbytes ( inputstream is ) throws ioexception { int totalread = num_ ; byte [ ] content = new byte [ num_ ] ; while ( bool_ ) { int howmany = is . read ( content , totalread , content . length - totalread ) ; if ( howmany < num_ ) { break ; } if ( howmany == num_ ) { continue ; } totalread += howmany ; if ( totalread >= content . length ) { byte [ ] tmp = content ; int newlength = ( ( content . length < num_ ) ? content . length * num_ : content . length + num_ ) ; content = new byte [ newlength ] ; system . arraycopy ( tmp , num_ , content , num_ , totalread ) ; } } is . close ( ) ; byte [ ] results = new byte [ totalread ] ; system . arraycopy ( content , num_ , results , num_ , totalread ) ; return results ; }	Read the bytes in the given input stream.
public string replacefiletemplate ( string filespec , int ensindex ) { return filespec . replaceall ( ens_template_id , getensemblenames ( ) . get ( ensindex ) ) ; }	Replace the ensemble template parameter in a filename.
public void setstationinfo ( string stnidvname , string stndescvname ) { this . stnidvname = stnidvname ; this . stndescvname = stndescvname ; variable stationvar = ncfile . findvariable ( stnidvname ) ; stationidtype = stationvar . getdatatype ( ) ; }	Set extra information used by station obs datasets.
protected boolean accept ( stringbuffer buff ) { if ( ! validate ( buff ) ) { validate ( buff ) ; return bool_ ; } if ( acceptifdifferent ( geteditvalue ( ) ) ) { setstorevalue ( validvalue ) ; sendevent ( ) ; } return bool_ ; }	Get current value from editComponent, save to store.If different from old value, fire PropertyChangeEvent.Return false if invalid format, add error message to buff if not null.
@ nullable public byte [ ] getbitmap ( randomaccessfile raf ) throws ioexception {	Read the bit map array.
public void setnetcdffile ( netcdffile ncf ) { this . ncfile = ncf ; this . filename = ncf . getlocation ( ) ; final getdatarunnable runner = new getdatarunnable ( ) { public void run ( object o ) throws ioexception { final stringwriter sw = new stringwriter ( num_ ) ; ncdumpw . print ( ncfile , command , sw , task ) ; result = sw . tostring ( ) ; } } ; task = new getdatatask ( runner , filename , null ) ; stopbutton . startprogressmonitortask ( task ) ; }	allow calling from outside.
static public void setdebugflags ( ucar . nc2 . util . debugflags debugflag ) { debugce = debugflag . isset ( str_ ) ; debugservercall = debugflag . isset ( str_ ) ; debugopenresult = debugflag . isset ( str_ ) ; debugdataresult = debugflag . isset ( str_ ) ; debugchararray = debugflag . isset ( str_ ) ; debugconstruct = debugflag . isset ( str_ ) ; debugpreload = debugflag . isset ( str_ ) ; debugtime = debugflag . isset ( str_ ) ; showncfile = debugflag . isset ( str_ ) ; debugattributes = debugflag . isset ( str_ ) ; debugcached = debugflag . isset ( str_ ) ; }	Debugging flags. This is a way to decouple setting flags from particular implementations.
namepieces parsename ( string name ) { namepieces pieces = new namepieces ( ) ; int dotpos = name . lastindexof ( str_ ) ; int slashpos = name . lastindexof ( str_ ) ; if ( slashpos < num_ && dotpos < num_ ) { pieces . name = name ; } else if ( slashpos >= num_ && dotpos < num_ ) { pieces . prefix = name . substring ( num_ , slashpos ) ; pieces . name = name . substring ( slashpos + num_ , name . length ( ) ) ; } else if ( slashpos < num_ && dotpos >= num_ ) { pieces . var = name . substring ( num_ , dotpos ) ; pieces . name = name . substring ( dotpos + num_ , name . length ( ) ) ; } else {	Utility to decompose a name.
private boolean isgroup ( dstructure dstruct ) { basetype parent = ( basetype ) dstruct . getparent ( ) ; if ( parent == null ) return bool_ ; if ( parent instanceof dstructure ) return isgroup ( ( dstructure ) parent ) ; return bool_ ; }	make a structure into a group if its scalar and all parents are groups.
dimension getnetcdfstrlendim ( dodsvariable v ) { attributetable table = das . getattributetablen ( v . getfullname ( ) ) ;	Checks to see if this is netcdf char array.
dimension getshareddimension ( group group , dimension d ) { if ( d . getshortname ( ) == null ) return d ; if ( group == null ) group = rootgroup ; for ( dimension sd : group . getdimensions ( ) ) { if ( sd . getshortname ( ) . equals ( d . getshortname ( ) ) && sd . getlength ( ) == d . getlength ( ) ) return sd ; } d . setshared ( bool_ ) ; group . adddimension ( d ) ; return d ; }	If an equivilent shared dimension already exists, use it, else add d to shared dimensions.Equivilent is same name and length.
list < dimension > constructdimensions ( group group , opendap . dap . darray dodsarray ) { if ( group == null ) group = rootgroup ; list < dimension > dims = new arraylist < dimension > ( ) ; enumeration enumerate = dodsarray . getdimensions ( ) ; while ( enumerate . hasmoreelements ( ) ) { opendap . dap . darraydimension dad = ( opendap . dap . darraydimension ) enumerate . nextelement ( ) ; string name = dad . getencodedname ( ) ; if ( name != null ) name = stringutil2 . unescape ( name ) ; dimension myd ; if ( name == null ) {	construct list of dimensions to use.
static public boolean isunsigned ( opendap . dap . basetype dtype ) { return ( dtype instanceof dbyte ) || ( dtype instanceof duint16 ) || ( dtype instanceof duint32 ) ; }	Get whether this is an unsigned type.
datadds readdataddsfromserver ( string ce ) throws ioexception , opendap . dap . dap2exception { if ( debugservercall ) system . out . println ( str_ + ce + str_ ) ; long start = num_ ; if ( debugtime ) start = system . currenttimemillis ( ) ; if ( ! ce . startswith ( str_ ) ) ce = str_ + ce ; datadds data ; synchronized ( this ) { data = dodsconnection . getdata ( ce , null ) ; } if ( debugtime ) system . out . println ( str_ + ( system . currenttimemillis ( ) - start ) / num_ ) ; if ( debugdataresult ) { system . out . println ( str_ ) ; data . print ( system . out ) ; } return data ; }	This does the actual connection to the opendap server and reading of the data.All data calls go through here so we can add debugging.
public static imageicon geticon ( string fulliconname , boolean errmsg ) { imageicon icon = null ; java . net . url iconr = cl . getresource ( fulliconname ) ; if ( debugicon ) { system . out . println ( str_ + cl . getclassloader ( ) ) ; system . out . println ( str_ + fulliconname + str_ + iconr ) ; } if ( iconr != null ) icon = new imageicon ( iconr ) ; if ( ( icon == null ) && errmsg ) system . out . println ( str_ + fulliconname ) ; else if ( debugicon ) system . out . println ( str_ + fulliconname ) ; return icon ; }	Get a gif file, make it into an ImageIcon.
public static image getimage ( string fullimagename ) { image image = null ; java . net . url url = cl . getresource ( fullimagename ) ; if ( url != null ) image = toolkit . getdefaulttoolkit ( ) . createimage ( url ) ; if ( image == null ) system . out . println ( str_ + fullimagename ) ; return image ; }	Get a gif file, make it into an Image.
public static cursor makecursor ( string name ) { image image = getimage ( name ) ; if ( null == image ) return null ; cursor cursor ; try { toolkit tk = toolkit . getdefaulttoolkit ( ) ; if ( debug ) { imageobserver obs = new imageobserver ( ) { public boolean imageupdate ( image image , int flags , int x , int y , int width , int height ) { return bool_ ; } } ; system . out . println ( str_ + tk . getbestcursorsize ( image . getwidth ( obs ) , image . getheight ( obs ) ) ) ; system . out . println ( str_ + tk . getmaximumcursorcolors ( ) ) ; } cursor = tk . createcustomcursor ( image , new point ( num_ , num_ ) , name ) ; } catch ( indexoutofboundsexception e ) { system . out . println ( str_ + e ) ; return null ; } return cursor ; }	Get a gif file, make it into a Cursor.
static public object readdatafill ( randomaccessfile raf , layout index , datatype datatype , object fillvalue , int byteorder ) throws java . io . ioexception { object arr = ( fillvalue == null ) ? makeprimitivearray ( ( int ) index . gettotalnelems ( ) , datatype ) : makeprimitivearray ( ( int ) index . gettotalnelems ( ) , datatype , fillvalue ) ; return readdata ( raf , index , datatype , arr , byteorder , bool_ ) ; }	Read data subset from RandomAccessFile, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object readdatafill ( positioningdatainputstream is , layout index , datatype datatype , object fillvalue ) throws java . io . ioexception { object arr = ( fillvalue == null ) ? makeprimitivearray ( ( int ) index . gettotalnelems ( ) , datatype ) : makeprimitivearray ( ( int ) index . gettotalnelems ( ) , datatype , fillvalue ) ; return readdata ( is , index , datatype , arr ) ; }	Read data subset from PositioningDataInputStream, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object readdatafill ( layoutbb layout , datatype datatype , object fillvalue ) throws java . io . ioexception { long size = layout . gettotalnelems ( ) ; if ( datatype == datatype . structure ) size *= layout . getelemsize ( ) ; object arr = ( fillvalue == null ) ? makeprimitivearray ( ( int ) size , datatype ) : makeprimitivearray ( ( int ) size , datatype , fillvalue ) ; return readdata ( layout , datatype , arr ) ; }	Read data subset from ByteBuffer, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object makeprimitivearray ( int size , datatype datatype ) { object arr = null ; if ( ( datatype . getprimitiveclasstype ( ) == byte . class ) || ( datatype == datatype . char ) || ( datatype == datatype . opaque ) || ( datatype == datatype . structure ) ) { arr = new byte [ size ] ; } else if ( datatype . getprimitiveclasstype ( ) == short . class ) { arr = new short [ size ] ; } else if ( datatype . getprimitiveclasstype ( ) == int . class ) { arr = new int [ size ] ; } else if ( datatype . getprimitiveclasstype ( ) == long . class ) { arr = new long [ size ] ; } else if ( datatype == datatype . float ) { arr = new float [ size ] ; } else if ( datatype == datatype . double ) { arr = new double [ size ] ; } else if ( datatype == datatype . string ) { arr = new string [ size ] ; } return arr ; }	Create 1D primitive array of the given size and type.
static public char [ ] convertbytetocharutf ( byte [ ] bytearray ) { charset c = cdm . utf8charset ; charbuffer output = c . decode ( bytebuffer . wrap ( bytearray ) ) ; return output . array ( ) ; }	convert byte array to char array, assuming UTF-8 encoding.
static public byte [ ] convertchartobyteutf ( char [ ] from ) { charset c = cdm . utf8charset ; bytebuffer output = c . encode ( charbuffer . wrap ( from ) ) ; return output . array ( ) ; }	convert char array to byte array, assuming UTF-8 encoding.
static public char [ ] convertbytetochar ( byte [ ] bytearray ) { int size = bytearray . length ; char [ ] cbuff = new char [ size ] ; for ( int i = num_ ; i < size ; i ++ ) cbuff [ i ] = ( char ) datatype . unsignedbytetoshort ( bytearray [ i ] ) ;	convert byte array to char array.
static public ucar . ma2 . array readsection ( parsedsectionspec cer ) throws ioexception , invalidrangeexception { variable inner = null ; list < range > totalranges = new arraylist < > ( ) ; parsedsectionspec current = cer ; while ( current != null ) { totalranges . addall ( current . section . getranges ( ) ) ; inner = current . v ; current = current . child ; } assert inner != null ; section total = new section ( totalranges ) ; array result = array . factory ( inner . getdatatype ( ) , total . getshape ( ) ) ;	section reading for member data.
static private arraystructure sectionarraystructure ( parsedsectionspec child , arraystructure innerdata , structuremembers . member m ) throws ioexception , invalidrangeexception { structuremembers membersw = new structuremembers ( m . getstructuremembers ( ) ) ;	LOOK could be used in createView ??.
public string getscalarstring ( int recnum , structuremembers . member m ) { array data = m . getdataarray ( ) ; return ( string ) data . getobject ( recnum ) . tostring ( ) ; }	Get member databuffer of type String or char.
public structuredata getscalarstructure ( int index , structuremembers . member m ) { if ( m . getdatatype ( ) != datatype . structure ) throw new forbiddenconversionexception ( str_ ) ; array ca = memberarray ( index , memberindex ( m ) ) ; if ( ca . getdatatype ( ) != datatype . structure && ca . getdatatype ( ) != datatype . sequence ) throw new forbiddenconversionexception ( str_ ) ; cdmarraystructure as = ( cdmarraystructure ) ca ; return as . getstructuredata ( num_ ) ; }	Non-atomic cases.
@ override public ucar . ma2 . array getarray ( int recno , structuremembers . member m ) { return ( ucar . ma2 . array ) memberarray ( recno , memberindex ( m ) ) ; }	Key interface method coming in from StructureDataA.
static structuremembers computemembers ( dapvariable var ) { dapstructure ds = ( dapstructure ) var . getbasetype ( ) ; structuremembers sm = new structuremembers ( ds . getshortname ( ) ) ; list < dapvariable > fields = ds . getfields ( ) ; for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { dapvariable field = fields . get ( i ) ; daptype dt = field . getbasetype ( ) ; datatype cdmtype = cdmtypefcns . daptype2cdmtype ( dt ) ; structuremembers . member m = sm . addmember ( field . getshortname ( ) , str_ , null , cdmtype , cdmutil . computeeffectiveshape ( field . getdimensions ( ) ) ) ; m . setdataparam ( i ) ;	Compute the StructureMembers objectfrom a DapStructure. May need to recurseif a field is itself a Structure.
public void adddimensionstonetcdffile ( netcdffile ncfile , group g ) { ncfile . adddimension ( g , new dimension ( getname ( ) , getnensembles ( ) , bool_ ) ) ; }	Add this as a dimension to a netCDF file.
public static string normalizepath ( string path ) {	Normalize the given path so that it can be used in the creation of a CrawlableDataset.This method can be used on absolute or relative paths.Normal uses slashes ("/") as path seperator, not backslashes ("\"), and doesnot use trailing slashes.
public void addexplicitdataset ( string cachename , string location , string id , string ncoords , string coordvalues , string sectionspec , ucar . nc2 . util . cache . filefactory reader ) { dataset nested = makedataset ( cachename , location , id , ncoords , coordvalues , sectionspec , null , reader ) ; explicitdatasets . add ( nested ) ; }	Add a nested dataset, specified by an explicit netcdf element.enhance is handled by the reader, so its always false here.
public void adddatasetscan ( element crawlabledatasetelement , string dirname , string suffix , string regexppatternstring , string dateformatmark , set < netcdfdataset . enhance > enhancemode , string subdirs , string olderthan ) { datasetmanager . adddirectoryscan ( dirname , suffix , regexppatternstring , subdirs , olderthan , enhancemode ) ; this . dateformatmark = dateformatmark ; if ( dateformatmark != null ) { isdate = bool_ ; if ( type == type . joinexisting ) type = type . joinexistingone ;	Add a dataset scan.
public void finish ( canceltask canceltask ) throws ioexception { datasetmanager . scan ( bool_ ) ;	all elements are processed, finish construction.
protected void makedatasets ( canceltask canceltask ) throws ioexception {	Make the list of Datasets, from explicit and scans.
protected dataset gettypicaldataset ( ) throws ioexception { list < dataset > nesteddatasets = getdatasets ( ) ; int n = nesteddatasets . size ( ) ; if ( n == num_ ) throw new filenotfoundexception ( str_ ) ; int select ; if ( typicaldatasetmode == typicaldataset . latest ) select = n - num_ ; else if ( typicaldatasetmode == typicaldataset . penultimate ) select = ( n < num_ ) ? num_ : n - num_ ; else if ( typicaldatasetmode == typicaldataset . first ) select = num_ ; else {	Open one of the nested datasets as a template for the aggregation dataset.
protected dataset makedataset ( string cachename , string location , string id , string ncoords , string coordvalues , string sectionspec , enumset < netcdfdataset . enhance > enhance , ucar . nc2 . util . cache . filefactory reader ) { return new dataset ( cachename , location , id , enhance , reader ) ;	Dataset factory, so subclasses can override.
void putresourcecontrol ( dataset ds ) { if ( logger . isdebugenabled ( ) ) logger . debug ( str_ + ds . getrestrictaccess ( ) + str_ + ds . getname ( ) ) ; resourcecontrolhash . put ( ds . geturlpath ( ) , ds . getrestrictaccess ( ) ) ;	This tracks Dataset elements that have resource control attributes.
public void addpoint ( double x , double y ) { point ptprev = null ; if ( points . size ( ) > num_ ) { ptprev = points . get ( points . size ( ) - num_ ) ; } this . points . add ( new cfpoint ( x , y , ptprev , null , null ) ) ; }	Add a point to the end of the line.
public double [ ] getbbupper ( ) { double [ ] bbupper = new double [ num_ ] ; list < point > ptlist = this . getpoints ( ) ; if ( ptlist . isempty ( ) ) return null ; bbupper [ num_ ] = ptlist . get ( num_ ) . gety ( ) ; bbupper [ num_ ] = ptlist . get ( num_ ) . gety ( ) ; for ( point pt : this . getpoints ( ) ) { if ( bbupper [ num_ ] < pt . getx ( ) ) { bbupper [ num_ ] = pt . getx ( ) ; } if ( bbupper [ num_ ] < pt . gety ( ) ) { bbupper [ num_ ] = pt . gety ( ) ; } }	Gets the upper bounding box coordinate on the line.
public double [ ] getbblower ( ) { double [ ] bblower = new double [ num_ ] ; list < point > ptlist = this . getpoints ( ) ; if ( ptlist . isempty ( ) ) return null ; bblower [ num_ ] = ptlist . get ( num_ ) . gety ( ) ; bblower [ num_ ] = ptlist . get ( num_ ) . gety ( ) ; for ( point pt : this . getpoints ( ) ) { if ( bblower [ num_ ] > pt . getx ( ) ) { bblower [ num_ ] = pt . getx ( ) ; } if ( bblower [ num_ ] > pt . gety ( ) ) { bblower [ num_ ] = pt . gety ( ) ; } }	Gets the lower bounding box coordinate on the line.
boolean validate ( stringbuilder out ) { this . isvalid = bool_ ;	Validate this DatasetFilter object.
private boolean match ( invdataset dataset ) {	Test whether the given dataset matches the filter criteria.
public void addall ( featuredatasetpoint fdpoint ) throws ioexception { try ( pointfeatureiterator pointfeatiter = new flatteneddatasetpointcollection ( fdpoint ) . getpointfeatureiterator ( ) ) { while ( pointfeatiter . hasnext ( ) ) { stationpointfeature pointfeat = ( stationpointfeature ) pointfeatiter . next ( ) ; add ( pointfeat ) ; } } }	fdPoint remains open.
public void parseconstraint ( reqstate rs ) throws parseexception , opendap . dap . dap2exception , nosuchvariableexception , nosuchfunctionexception , invalidoperatorexception , invalidparameterexception , sbhexception , wrongtypeexception { parseconstraint ( rs . getconstraintexpression ( ) , rs . getrequesturl ( ) . tostring ( ) ) ; }	Convenience wrapper for parseConstraint.
public boolean evalclauses ( object specialo ) throws nosuchvariableexception , dap2serversideexception , ioexception { boolean result = bool_ ; enumeration ec = getclauses ( ) ; while ( ec . hasmoreelements ( ) && result == bool_ ) { object o = ec . nextelement ( ) ; if ( _debug ) { system . out . println ( str_ + ec . nextelement ( ) ) ; } result = ( ( toplevelclause ) o ) . evaluate ( ) ; }	Evaluate all of the Clauses in the Clause vector.
public void printconstraint ( printwriter pw ) { enumeration ec = getclauses ( ) ; boolean first = bool_ ; while ( ec . hasmoreelements ( ) ) { clause cl = ( clause ) ec . nextelement ( ) ; if ( ! first ) pw . print ( str_ ) ; cl . printconstraint ( pw ) ; first = bool_ ; } pw . flush ( ) ; }	Print all of the Clauses in the Clause vector.
static public boolean amendfromodl ( netcdffile ncfile , group eosgroup ) throws ioexception { string smeta = getstructmetadata ( eosgroup ) ; if ( smeta == null ) { return bool_ ; } hdfeos fixer = new hdfeos ( ) ; fixer . fixattributes ( ncfile . getrootgroup ( ) ) ; fixer . amendfromodl ( ncfile , smeta ) ; return bool_ ; }	Amend the given NetcdfFile with metadata from HDF-EOS structMetadata.All Variables named StructMetadata.n, where n= 1, 2, 3 ..
private void setshareddimensions ( variable v , list < element > values , list < dimension > unknowndims , string location ) { if ( values . size ( ) == num_ ) { return ; }	convert to shared dimensions.
private dimension checkunknowndims ( string wantdim , list < dimension > unknowndims , dimension olddim , string location ) { for ( dimension dim : unknowndims ) { if ( dim . getshortname ( ) . equals ( wantdim ) ) { int len = olddim . getlength ( ) ; if ( len == num_ ) { dim . setunlimited ( bool_ ) ;	look if the wanted dimension is in the unknownDims list.
private group findgroupnested ( group parent , string name ) { for ( group g : parent . getgroups ( ) ) { if ( g . getshortname ( ) . equals ( name ) ) { return g ; } } for ( group g : parent . getgroups ( ) ) { group result = findgroupnested ( g , name ) ; if ( result != null ) { return result ; } } return null ; }	look for a group with the given name.
public string readxlinkcontent ( ) throws java . io . ioexception { if ( uri == null ) return str_ ; url url = uri . tourl ( ) ; inputstream is = url . openstream ( ) ; bytearrayoutputstream os = new bytearrayoutputstream ( is . available ( ) ) ;	Get inline content as a string, else null if there is none.
public uri getstandarduri ( ) { try { invcatalog cat = dataset . getparentcatalog ( ) ; if ( cat == null ) return new uri ( getunresolvedurlname ( ) ) ; return cat . resolveuri ( getunresolvedurlname ( ) ) ; } catch ( java . net . urisyntaxexception e ) { logger . warn ( str_ + getunresolvedurlname ( ) ) ; return null ; } }	Construct the standard THREDDS access URI for this dataset access method,resolve if the URI is relative.
public void setprojection ( projectionmanager . projectionclass pc ) {	construct input fields based on Projection Class.
public void addlayoutcomponent ( component comp , object constraint ) { if ( debug ) system . out . println ( name + str_ + comp . getclass ( ) . getname ( ) + str_ + comp . hashcode ( ) + str_ + constraint ) ; if ( ! ( constraint instanceof constraint ) ) throw new illegalargumentexception ( str_ ) ; constraintmap . put ( comp , constraint ) ; globalbounds = null ; }	Adds the specified component to the layout, using the specifiedconstraint object.
public void invalidatelayout ( container target ) { if ( debug ) system . out . println ( name + str_ ) ; globalbounds = null ;	Invalidates the layout, indicating that if the layout managerhas cached information it should be discarded.
public void removelayoutcomponent ( component comp ) { if ( debug ) system . out . println ( str_ ) ; constraintmap . remove ( comp ) ; globalbounds = null ; }	Removes the specified component from the layout.
public dimension minimumlayoutsize ( container parent ) { if ( debug ) system . out . println ( str_ ) ; if ( globalbounds == null ) layoutcontainer ( parent ) ; return globalbounds . getsize ( ) ; }	Calculates the minimum size dimensions for the specifiedcontainer, given the components it contains.
public void layoutcontainer ( container target ) { synchronized ( target . gettreelock ( ) ) { if ( debug ) system . out . println ( name + str_ ) ;	Lays out the specified container.
public static boolean isradialcoordsys ( formatter parseinfo , coordinatesystem cs ) { return ( cs . getazimuthaxis ( ) != null ) && ( cs . getradialaxis ( ) != null ) && ( cs . getelevationaxis ( ) != null ) ; }	Determine if this CoordinateSystem can be made into a RadialCoordSys.
public double getmaximumradial ( ) { if ( maxradial == num_ ) { try { array radialdata = getradialaxisdatacached ( ) ; maxradial = mamath . getmaximum ( radialdata ) ; string units = getradialaxis ( ) . getunitsstring ( ) ; simpleunit radialunit = simpleunit . factory ( units ) ; maxradial = radialunit . convertto ( maxradial , simpleunit . kmunit ) ;	Get the maximum radial distance, in km.
public double [ ] earthtosat ( double geographic_lon , double geographic_lat ) { geographic_lat = geographic_lat * deg_to_rad ; geographic_lon = geographic_lon * deg_to_rad ; double geocentric_lat = math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * math . tan ( geographic_lat ) ) ; double r_earth = r_pol / math . sqrt ( num_ - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * math . cos ( geocentric_lat ) * math . cos ( geocentric_lat ) ) ; double r_1 = h - r_earth * math . cos ( geocentric_lat ) * math . cos ( geographic_lon - sub_lon ) ; double r_2 = - r_earth * math . cos ( geocentric_lat ) * math . sin ( geographic_lon - sub_lon ) ; double r_3 = r_earth * math . sin ( geocentric_lat ) ; if ( r_1 > h ) {	Transform geographic Earth coordinates to satellite view angle coordinate systemalso known as the "intermediate" coordinate system in CGMS Normalized Geostationary Projection.
public double [ ] sattoearth ( double x , double y ) { if ( scan_geom . equals ( goes ) ) {	Transform satellite view angle coordinates, known as the "intermeidate" coordinates in theCGMS Normalized Geostationary Projection, to geographic Earth coordinates.
public double [ ] goes_to_geos ( double lamda_goes , double theta_goes ) { double theta_geos = math . asin ( math . sin ( theta_goes ) * math . cos ( lamda_goes ) ) ; double lamda_geos = math . atan ( math . tan ( lamda_goes ) / math . cos ( theta_goes ) ) ; return new double [ ] { lamda_geos , theta_geos } ; }	Transform view angle coordinates in the GOES scan geometry frame to view angle coordinatesin the GEOS scan geometry frame.
public static string scangeomtosweepangleaxis ( string scangeometry ) { string sweepangleaxis = str_ ; if ( scangeometry . equals ( goes ) ) { sweepangleaxis = str_ ; } return sweepangleaxis ; }	Find sweep_angle_axis associated with a scan geometry.
public static string sweepangleaxistoscangeom ( string sweepangleaxis ) { string scangeom = goes ; if ( sweepangleaxis . equals ( str_ ) ) { scangeom = geos ; } return scangeom ; }	Find scan geometry associated with sweep_angle_axis.
void setruntimecoords ( coordinateruntime runtimes ) { for ( int idx = num_ ; idx < runtimes . getsize ( ) ; idx ++ ) { calendardate cd = runtimes . getruntimedate ( idx ) ; long runtime = runtimes . getruntime ( idx ) ; coordinatetimeabstract time = timemap . get ( runtime ) ; if ( time == null ) { time = istimeinterval ? new coordinatetimeintv ( this . code , this . timeunit , cd , new arraylist < > ( num_ ) , null ) : new coordinatetime ( this . code , this . timeunit , cd , new arraylist < > ( num_ ) , null ) ; timemap . put ( runtime , time ) ; } } }	set the list of runtime coordinates; add any that are not already present, and make an empty CoordinateTimeAbstract for it.
public static void writepointobsdataset ( pointobsdataset pobsdataset , string fileout ) throws ioexception {	write data from a ucar.nc2.dt.PointObsDataset into CF point format.
public static boolean rewritepointfeaturedataset ( string filein , string fileout , boolean inmemory ) throws ioexception { system . out . println ( str_ + filein + str_ + fileout + str_ + inmemory ) ; long start = system . currenttimemillis ( ) ;	Open a ucar.nc2.ft.PointFeatureCollection, write out in CF point format.
public arraysequence getarraysequence ( string membername ) { structuremembers . member m = members . findmember ( membername ) ; if ( m == null ) throw new illegalargumentexception ( str_ + membername ) ; return getarraysequence ( m ) ; }	Get ArraySequence for a member of type Sequence.
public string getfullname ( ) { return ( parent == null ) ? name : ( parent . getfullname ( ) == null || parent . getfullname ( ) . length ( ) == num_ ) ? name : parent . getfullname ( ) + str_ + name ; }	Get the full, heirarchical name of the dataset, which has all parent collection names.
public string getuniqueid ( ) { string authority = getauthority ( ) ; if ( ( authority != null ) && ( getid ( ) != null ) ) return authority + str_ + getid ( ) ; else if ( getid ( ) != null ) return getid ( ) ; else return null ; }	If this dataset has an authority and an ID, then the concatenation of them is theglobally unique ID.
public invaccess getaccess ( thredds . catalog . servicetype type ) { for ( invaccess a : getaccess ( ) ) { invservice s = a . getservice ( ) ; if ( s . getservicetype ( ) == type ) return a ; } return null ; }	Get access element of the specified service type for this dataset.If more than one, get the first one.
public invdatasetimpl finddatasetbyname ( string name ) { for ( invdataset ds : getdatasets ( ) ) { if ( ds . getname ( ) . equals ( name ) ) return ( invdatasetimpl ) ds ; } return null ; }	Find an immediate child dataset by its name.
public invcatalog getparentcatalog ( ) { if ( catalog != null ) return catalog ; return ( parent != null ) ? parent . getparentcatalog ( ) : null ; }	Get containing catalog.
public java . util . list < invmetadata > getmetadata ( thredds . catalog . metadatatype want ) { list < invmetadata > result = new arraylist < invmetadata > ( ) ; for ( invmetadata m : getmetadata ( ) ) { metadatatype mtype = metadatatype . gettype ( m . getmetadatatype ( ) ) ; if ( mtype == want ) result . add ( m ) ; } return result ; }	Get the metadata elements of the specified type.
public invservice findservice ( string name ) { if ( name == null ) return null ;	Find the named service declared in this dataset or one of its parents.
public threddsmetadata . variables getvariables ( string vocab ) { threddsmetadata . variables result = new threddsmetadata . variables ( vocab , null , null , null , null ) ; if ( variables == null ) return result ; for ( threddsmetadata . variables vs : variables ) { if ( vs . getvocabulary ( ) . equals ( vocab ) ) result . getvariablelist ( ) . addall ( vs . getvariablelist ( ) ) ; } return result ; }	get Variables from the specified vocabulary.
public static list < invcatalogref > findallcatrefsindatasettree ( list < invdataset > datasets , stringbuilder log , boolean onlyrelativeurls ) { list < invcatalogref > catreflist = new arraylist < invcatalogref > ( ) ; for ( invdataset invds : datasets ) { invdatasetimpl curds = ( invdatasetimpl ) invds ; if ( curds instanceof invdatasetscan ) continue ; if ( curds instanceof invcatalogref ) { invcatalogref catref = ( invcatalogref ) curds ; string name = catref . getname ( ) ; string href = catref . getxlinkhref ( ) ; uri uri ; try { uri = new uri ( href ) ; } catch ( urisyntaxexception e ) { log . append ( log . length ( ) > num_ ? str_ : str_ ) . append ( str_ ) . append ( name ) . append ( str_ ) . append ( href ) . append ( str_ ) ; continue ; } if ( onlyrelativeurls && uri . isabsolute ( ) ) continue ; catreflist . add ( catref ) ; continue ; } if ( curds . hasnesteddatasets ( ) ) catreflist . addall ( findallcatrefsindatasettree ( curds . getdatasets ( ) , log , onlyrelativeurls ) ) ; } return catreflist ; }	Find all catalogRef elements in the dataset tree formed by the given dataset list.
static public string escapepathforurl ( string path ) { try { return new uri ( null , null , path , null ) . tostring ( ) ; } catch ( urisyntaxexception e ) { return path ; } }	Escape the characters necessary for a path to be valid for a URL.
private arraydouble . d3 addstagger ( arraydouble . d3 array , int dimindex ) {	Add 1 to the size of the array for the given dimension.Use linear average and interpolation to fill in the values.
private double [ ] extrapinterpolate ( double [ ] array ) { int n = array . length ; double [ ] d = new double [ n + num_ ] ;	Add one element to the array by linear interpolationand extrapolation at the ends.
private double computerho ( double lat ) { return earth_radius * math . sqrt ( c - num_ * n * math . sin ( lat ) ) / n ; }	Compute the RHO parameter.
public string getdetailinfo ( ) { formatter ff = new formatter ( ) ; ff . format ( str_ , super . getdetailinfo ( ) ) ; ff . format ( str_ , parseinfo ) ; return ff . tostring ( ) ; }	Get the detail information.
protected structure makestructure ( string partname , list < dimension > dimensions , boolean includemissing ) { list < gempakparameter > params = gemreader . getparameters ( partname ) ; if ( params == null ) { return null ; } structure svar = new structure ( ncfile , null , null , partname ) ; svar . setdimensions ( dimensions ) ; for ( gempakparameter param : params ) { svar . addmembervariable ( makeparamvariable ( param , null ) ) ; } if ( includemissing ) { svar . addmembervariable ( makemissingvariable ( ) ) ; } return svar ; }	Make a structure for the part.
protected variable makemissingvariable ( ) { variable var = new variable ( ncfile , null , null , missing_var ) ; var . setdatatype ( datatype . byte ) ; var . setdimensions ( ( list < dimension > ) null ) ; var . addattribute ( new attribute ( str_ , str_ ) ) ; var . addattribute ( new attribute ( cdm . missing_value , ( byte ) num_ ) ) ; return var ; }	Make the missing variable.
protected variable makeparamvariable ( gempakparameter param , list < dimension > dims ) { variable var = new variable ( ncfile , null , null , param . getname ( ) ) ; var . setdatatype ( datatype . float ) ; var . setdimensions ( dims ) ; var . addattribute ( new attribute ( cdm . long_name , param . getdescription ( ) ) ) ; string units = param . getunit ( ) ; if ( ( units != null ) && ! units . equals ( str_ ) ) { var . addattribute ( new attribute ( cdm . units , units ) ) ; } var . addattribute ( new attribute ( cdm . missing_value , rmiss ) ) ; return var ; }	Make a variable from a GempakParmaeter.
protected void addglobalattributes ( ) {	Add on global attributes for all types.
protected int getstnvarsize ( string name ) { int size = - num_ ; for ( int i = num_ ; i < stnvarnames . length ; i ++ ) { if ( name . equals ( stnvarnames [ i ] ) ) { size = stnvarsizes [ i ] ; break ; } } return size ; }	Get the size of a particular station variable.
private array get1darray ( datatype type , int len ) { array vararray = null ; if ( type . equals ( datatype . float ) ) { vararray = new arrayfloat . d1 ( len ) ; } else if ( type . equals ( datatype . double ) ) { vararray = new arraydouble . d1 ( len ) ; } else if ( type . equals ( datatype . int ) ) { vararray = new arrayint . d1 ( len , bool_ ) ; } return vararray ; }	Get a 1DArray for the type and length.
private int yy_lr_goto_state_ ( int yystate , int yysym ) { int yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; if ( num_ <= yyr && yyr <= yylast_ && yycheck_ [ yyr ] == yystate ) return yytable_ [ yyr ] ; else return yydefgoto_ [ yysym - yyntokens_ ] ; }	Compute post-reduction state.
private string yysyntax_error ( int yystate , int tok ) { if ( yyerrorverbose ) { if ( tok != yyempty_ ) { stringbuffer res = new stringbuffer ( str_ ) ; res . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; int yyn = yypact_ [ yystate ] ; if ( ! yy_pact_value_is_default_ ( yyn ) ) { int yyxbegin = yyn < num_ ? - yyn : num_ ; int yychecklim = yylast_ - yyn + num_ ; int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; int count = num_ ; for ( int x = yyxbegin ; x < yyxend ; ++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; if ( count < num_ ) { count = num_ ; for ( int x = yyxbegin ; x < yyxend ; ++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { res . append ( count ++ == num_ ? str_ : str_ ) ; res . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; } } } return res . tostring ( ) ; } } return str_ ; }	Generate an error message.
private void yy_reduce_print ( int yyrule , yystack yystack ) { if ( yydebug == num_ ) return ; int yylno = yyrline_ [ yyrule ] ; int yynrhs = yyr2_ [ yyrule ] ; yycdebug ( str_ + ( yyrule - num_ ) + str_ + yylno + str_ ) ; for ( int yyi = num_ ; yyi < yynrhs ; yyi ++ ) yy_symbol_print ( str_ + ( yyi + num_ ) + str_ , yystos_ [ yystack . stateat ( yynrhs - ( yyi + num_ ) ) ] , ( ( yystack . valueat ( yynrhs - ( yyi + num_ ) ) ) ) ) ; }	Report on the debug stream that the rule yyrule is going to be reduced.
public string readdmr ( ) throws dapexception { try { if ( state != state . initial ) throw new dapexception ( str_ ) ; byte [ ] dmr8 = null ; if ( requestmode == requestmode . dmr ) {	Read the DMR, trimmed.
public string readerror ( ) throws ioexception { state = state . error ;	Read an error chunk.
public int read ( byte [ ] buf , int off , int len ) throws ioexception {	Reads up to len databuffer of databuffer from the input stream into anarray of databuffer.
boolean readheader ( inputstream input ) throws ioexception { byte [ ] bytehdr = new byte [ num_ ] ; int red = input . read ( bytehdr ) ; if ( red == - num_ ) return bool_ ; if ( red < num_ ) throw new ioexception ( str_ ) ; this . flags = ( ( int ) bytehdr [ num_ ] ) & num_ ;	Read the size+flags header from the input stream and use it toinitialize the chunk state.
static public date isostringtodate ( string iso ) throws illegalargumentexception { calendardate dt = isostringtocalendardate ( null , iso ) ; return dt . todate ( ) ; }	Does not handle non-standard Calendars.
static public list < record > readtable ( string urlstring , string format , int maxlines ) throws ioexception , numberformatexception { inputstream ios ; if ( urlstring . startswith ( str_ ) ) { url url = new url ( urlstring ) ; ios = url . openstream ( ) ; } else { ios = new fileinputstream ( urlstring ) ; } return readtable ( ios , format , maxlines ) ; }	Reads a URL or file in as a table.
static private void transfergroup ( netcdffile ds , netcdfdataset targetds , group src , group targetgroup , replacevariablecheck replacecheck ) { boolean unlimitedok = bool_ ;	transfer the objects in src group to the target group.
private file getstnfile ( string location ) { file file = new file ( location ) ; file stnfile = new file ( file . getparentfile ( ) , stn_file ) ; if ( ! stnfile . exists ( ) ) { if ( file . getparentfile ( ) == null ) return null ; stnfile = new file ( file . getparentfile ( ) . getparentfile ( ) , stn_file ) ; if ( ! stnfile . exists ( ) ) return null ; } return stnfile ; }	stn file must be in the same directory or one up.
@ override public void open ( randomaccessfile raff , netcdffile ncfile , canceltask canceltask ) throws ioexception { super . open ( raff , ncfile , canceltask ) ; int pos = location . lastindexof ( str_ ) ; string ext = location . substring ( pos ) ; file file = new file ( location ) ; file stnfile = getstnfile ( location ) ; if ( stnfile == null ) throw new filenotfoundexception ( str_ + location ) ; if ( ext . equals ( idx_ext ) ) { stnraf = randomaccessfile . acquire ( stnfile . getpath ( ) ) ; } else if ( ext . equals ( dat_ext ) ) { stnraf = randomaccessfile . acquire ( stnfile . getpath ( ) ) ; dataraf = raff ;	if a DAT file.
public int getbeginning ( int index ) {	Gets the beginning index of a geometry's points given the index of the geometry within the array.
public int getend ( int index ) {	Gets the ending index of a geometry's points given the index of the geometry within the array.
private boolean createallruntimecollections ( formatter errlog ) throws ioexception { long start = system . currenttimemillis ( ) ; this . type = gribcollectionimmutable . type . src ; boolean ok = bool_ ; list < mfile > files = new arraylist < > ( ) ; list < ? extends group > groups = makegroups ( files , bool_ , errlog ) ; list < mfile > allfiles = collections . unmodifiablelist ( files ) ;	creates seperate collection and index for each runtime.
protected void seteditvalue ( object value ) { if ( value == null ) tf . settext ( str_ ) ; else tf . settext ( value . tostring ( ) ) ;	set current value of editComponent.
datatype getdatatype ( int format ) { datatype p ; switch ( format ) { case num_ :	Return the string of entity ID for the Dorade image file.
public static double [ ] ecftolla ( double x , double y , double z , double a , double b ) { double longitude = math . atan2 ( y , x ) ; double eprimesquared = ( a * a - b * b ) / ( b * b ) ; double p = math . sqrt ( x * x + y * y ) ; double theta = math . atan ( ( z * a ) / ( p * b ) ) ; double sinetheta = math . sin ( theta ) ; double costheta = math . cos ( theta ) ; double f = num_ / num_ ; double e2 = num_ * f - f * f ; double top = z + eprimesquared * b * sinetheta * sinetheta * sinetheta ; double bottom = p - e2 * a * costheta * costheta * costheta ; double geodeticlat = math . atan ( top / bottom ) ; double sinelat = math . sin ( geodeticlat ) ; double n = a / math . sqrt ( num_ - e2 * sinelat * sinelat ) ; double altitude = ( p / math . cos ( geodeticlat ) ) - n ;	comparing api to others.
public static string cleanunit ( string unit ) { if ( unit == null ) return null ;	Clean up strings to be used for unit string.
public static string cleanname ( string name ) { if ( name == null ) return null ; int pos = name . indexof ( str_ ) ; if ( pos < num_ ) pos = name . indexof ( str_ ) ; if ( pos > num_ ) name = name . substring ( num_ , pos ) ; name = stringutil2 . replace ( name , str_ , str_ ) ; stringbuilder sb = new stringbuilder ( name ) ; stringutil2 . replace ( sb , str_ , str_ ) ; stringutil2 . remove ( sb , str_ ) ; return stringutil2 . collapsewhitespace ( sb . tostring ( ) . trim ( ) ) ; }	Clean up strings to be used in Netcdf Object names.
public static boolean isunitless ( string unit ) { if ( unit == null ) return bool_ ; string munge = unit . tolowercase ( ) . trim ( ) ; munge = stringutil2 . remove ( munge , str_ ) ; return munge . length ( ) == num_ || munge . startswith ( str_ ) || munge . startswith ( str_ ) || munge . startswith ( str_ ) || munge . startswith ( str_ ) || munge . startswith ( str_ ) || munge . startswith ( str_ ) || munge . equals ( str_ ) ; }	The given unit is "unitless".
static notes factory ( notesort ns , int g , int id , nc4dsp dsp ) { notes note = null ; switch ( ns ) { case type : note = new typenotes ( g , id , dsp ) ; break ; case var : note = new varnotes ( g , id , dsp ) ; break ; case dim : note = new dimnotes ( g , id , dsp ) ; break ; case group : note = new groupnotes ( g , id , dsp ) ; break ; } return note ; }	Use a factory so we can debug constructor calls.
static public long getvarid ( varnotes note ) { return getvarid ( note . gid , note . id , note . getfieldindex ( ) ) ; }	Manage the compound id for variables.
void parsedas ( das das ) throws ioexception { enumeration tablenames = das . getnames ( ) ; while ( tablenames . hasmoreelements ( ) ) { string tablename = ( string ) tablenames . nextelement ( ) ; attributetable atttable = das . getattributetablen ( tablename ) ; if ( tablename . equals ( str_ ) || tablename . equals ( str_ ) ) { addattributetable ( this , atttable , tablename , bool_ ) ; } else if ( tablename . equals ( str_ ) || tablename . equals ( str_ ) ) {	Parse the DAS, assign attribute tables to the DodsV objects.Nested attribute tables are supposed to follow the tree we construct with dodsV, so its easy to assign to correct dodsV.
dodsv finddodsv ( string name , boolean usedone ) { for ( dodsv dodsv : children ) { if ( usedone && dodsv . isdone ) continue ;	Search the immediate children for a BaseType with given name.
dodsv finddatav ( dodsv ddsv ) { if ( ddsv . parent . bt != null ) { dodsv parentv = finddatav ( ddsv . parent ) ; if ( parentv == null )	find the DodsV object in the dataVlist corresponding to the ddsV.
dodsv findbyindex ( int index ) { if ( children . size ( ) <= index ) return null ; return children . get ( index ) ; }	Return a child by index.
public group getparentgroup ( ) { group g = super . getparentgroup ( ) ; if ( g == null ) { g = ncfile . getrootgroup ( ) ; super . setparentgroup ( g ) ; } assert g != null ; return g ; }	Get the parent group.
public dimension getdimension ( int i ) { if ( ( i < num_ ) || ( i >= getrank ( ) ) ) return null ; return dimensions . get ( i ) ; }	Get the ith dimension.
public int finddimensionindex ( string name ) { for ( int i = num_ ; i < dimensions . size ( ) ; i ++ ) { dimension d = dimensions . get ( i ) ; if ( name . equals ( d . getshortname ( ) ) ) return i ; } return - num_ ; }	Find the index of the named Dimension in this Variable.
public string getunitsstring ( ) { string units = null ; attribute att = findattribute ( cdm . units ) ; if ( att == null ) att = findattributeignorecase ( cdm . units ) ; if ( ( att != null ) && att . isstring ( ) ) { units = att . getstringvalue ( ) ; if ( units != null ) units = units . trim ( ) ; } return units ; }	Get the Unit String for the Variable.Looks for the CDM.UNITS attribute value.
public section getshapeassection ( ) { if ( shapeassection == null ) { try { list < range > list = new arraylist < > ( ) ; for ( dimension d : dimensions ) { int len = d . getlength ( ) ; if ( len > num_ ) list . add ( new range ( d . getshortname ( ) , num_ , len - num_ ) ) ; else if ( len == num_ ) list . add ( range . empty ) ;	Get shape as a Section object.
public variable slice ( int dim , int value ) throws invalidrangeexception { if ( ( dim < num_ ) || ( dim >= shape . length ) ) throw new invalidrangeexception ( str_ + dim ) ;	Create a new Variable that is a logical slice of this Variable, byfixing the specified dimension at the specified index value.
public void setenumtypedef ( enumtypedef enumtypedef ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( ! datatype . isenum ( ) ) throw new unsupportedoperationexception ( str_ ) ; this . enumtypedef = enumtypedef ; }	Public by accident.
public array read ( list < range > ranges ) throws ioexception , invalidrangeexception { if ( null == ranges ) return _read ( ) ; return read ( new section ( ranges ) ) ; }	Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
public string readscalarstring ( ) throws ioexception { array data = getscalardata ( ) ; if ( datatype == datatype . string ) return ( string ) data . getobject ( index . scalarindeximmutable ) ; else if ( datatype == datatype . char ) { arraychar datac = ( arraychar ) data ; return datac . getstring ( ) ; } else throw new illegalargumentexception ( str_ + getfullname ( ) ) ; }	Get the value as a String for a scalar Variable.
protected array _read ( ) throws ioexception {	non-structure-member Variables.
protected array _read ( section section ) throws ioexception , invalidrangeexception {	assume filled, validated Section.
public string writecdl ( boolean usefullname , boolean strict ) { formatter buf = new formatter ( ) ; writecdl ( buf , new indent ( num_ ) , usefullname , strict ) ; return buf . tostring ( ) ; }	CDL representation of a Variable.
public string tostringdebug ( ) { formatter f = new formatter ( ) ; f . format ( str_ , getfullname ( ) ) ; if ( ncfile != null ) { f . format ( str_ , getdatasetlocation ( ) ) ; string extra = ncfile . tostringdebug ( this ) ; if ( extra != null ) f . format ( str_ , extra ) ; } return f . tostring ( ) ; }	String representation of Variable and its attributes.
public void setdatatype ( datatype datatype ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; this . datatype = datatype ; this . elementsize = getdatatype ( ) . getsize ( ) ; }	Set the data type.
public void setdimensions ( list < dimension > dims ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; this . dimensions = ( dims == null ) ? new arraylist < > ( ) : new arraylist < > ( dims ) ; resetshape ( ) ; }	Set the shape with a list of Dimensions.
public void resetshape ( ) {	Use when dimensions have changed, to recalculate the shape.
public void setdimensions ( string dimstring ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; try { setdimensions ( dimension . makedimensionslist ( getparentgroup ( ) , dimstring ) ) ;	Set the dimensions using the dimensions names.
public void resetdimensions ( ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; arraylist < dimension > newdimensions = new arraylist < > ( ) ; for ( dimension dim : dimensions ) { if ( dim . isshared ( ) ) { dimension newd = getparentgroup ( ) . finddimension ( dim . getshortname ( ) ) ; if ( newd == null ) throw new illegalargumentexception ( str_ + getfullname ( ) + str_ + dim ) ; newdimensions . add ( newd ) ; } else { newdimensions . add ( dim ) ; } } this . dimensions = newdimensions ; resetshape ( ) ; }	Reset the dimension array.
public void setdimension ( int idx , dimension dim ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; dimensions . set ( idx , dim ) ; resetshape ( ) ; }	Replace a dimension with an equivalent one.
public void setcacheddata ( array cachedata , boolean ismetadata ) { if ( ( cachedata != null ) && ( cachedata . getelementtype ( ) != getdatatype ( ) . getprimitiveclasstype ( ) ) ) throw new illegalargumentexception ( str_ + cachedata . getelementtype ( ) + str_ + getdatatype ( ) ) ; this . cache . data = cachedata ; this . ismetadata = ismetadata ; this . cache . cachingset = bool_ ; this . cache . iscaching = bool_ ; }	Set the data cache.
public list < dimension > getdimensionsall ( ) { list < dimension > dimsall = new arraylist < > ( ) ; adddimensionsall ( dimsall , this ) ; return dimsall ; }	Get list of Dimensions, including parents if any.
protected void setboundingbox ( ) { latlonrect largestbb = null ;	you must set EarthLocation before you call this.
void finish ( ) { gridlist = new arraylist < > ( uvhash . values ( ) ) ; collections . sort ( gridlist ) ;	call after adding all runs.
public iterable < dataset > getalldatasets ( ) { list < dataset > all = new arraylist < > ( ) ; addall ( this , all ) ; return all ; }	get all datasets contained directly in this catalog.
public boolean dspmatch ( string path , dapcontext context ) { for ( string ext : synextensions ) { if ( path . endswith ( ext ) ) return bool_ ; } return bool_ ; }	A path is a Synthetic path if it ends in .dmr or .syn.
public cdmdsp open ( netcdfdataset ncd ) throws dapexception { assert this . context != null ; this . dmrfactory = new dmrfactory ( ) ; this . ncdfile = ncd ; setlocation ( this . ncdfile . getlocation ( ) ) ; builddmr ( ) ; return this ; }	Provide an extra API for use in testing.
public void builddmr ( ) throws dapexception { if ( getdmr ( ) != null ) return ; try { if ( dumpcdl ) { system . out . println ( str_ ) ; this . ncdfile . writecdl ( system . out , bool_ ) ; system . out . flush ( ) ; }	Extract the metadata from the NetcdfDatasetand build the DMR.
protected void buildseqtypes ( variable cdmvar ) throws dapexception { if ( cdmutil . hasvlen ( cdmvar ) ) { buildseqtype ( cdmvar ) ; } if ( cdmvar . getdatatype ( ) == datatype . structure || cdmvar . getdatatype ( ) == datatype . sequence ) { structure struct = ( structure ) cdmvar ; list < variable > fields = struct . getvariables ( ) ; for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { variable field = fields . get ( i ) ; buildseqtypes ( field ) ;	Walk this variable, including fields, to construct sequence typesfor any contained vlen dimensions.
protected void builddimrefs ( dapvariable dapvar , list < dimension > cdmdims ) throws dapexception { if ( cdmdims == null || cdmdims . size ( ) == num_ ) return ;	Assign dimensions to a variable.
protected enumtypedef findmatchingenum ( enumtypedef varenum ) throws dapexception { list < enumtypedef > candidates = new arraylist < > ( ) ; for ( map . entry < dapnode , cdmnode > entry : this . nodemap . getcdmmap ( ) . entryset ( ) ) { cdmnode cdmnode = entry . getvalue ( ) ; if ( cdmnode . getsort ( ) != cdmsort . enumeration ) continue ;	Unfortunately, the CDM Iosp does notactually use the declared enums.
static list < dimension > getcoredimset ( list < dimension > dimset ) throws dapexception { if ( dimset == null ) return null ; list < dimension > core = new arraylist < > ( ) ; int pos = - num_ ; int count = num_ ; for ( int i = num_ ; i < dimset . size ( ) ; i ++ ) { if ( dimset . get ( i ) . isvariablelength ( ) ) { pos = i ; count ++ ; } else core . add ( dimset . get ( i ) ) ; } if ( ( pos != dimset . size ( ) - num_ ) || count > num_ ) throw new dapexception ( str_ ) ; return core ; }	Strip vlen dimensions from a set of dimensions.
public int scanbufrfile ( string filename , counter total ) throws exception { int count = num_ ; try ( randomaccessfile raf = new randomaccessfile ( filename , str_ ) ) { messagescanner scan = new messagescanner ( raf ) ; while ( scan . hasnext ( ) ) { message m = scan . next ( ) ; if ( m == null ) continue ; try { if ( showmess ) out . format ( str_ , indent , count , m . getheader ( ) ) ; count ++ ; counter counter = new counter ( ) ; processbufrmessageasdataset ( scan , m , counter ) ; if ( showmess ) out . format ( str_ , indent , counter . nvals , counter . nmiss ) ; total . add ( counter ) ; } catch ( exception e ) { system . out . printf ( str_ , e . getmessage ( ) , m . getheader ( ) ) ; indent . setindentlevel ( num_ ) ; } } } return count ; }	open the file and extract BUFR messages.
private void processbufrmessageasdataset ( messagescanner scan , message m , counter counter ) throws exception { byte [ ] mbytes = scan . getmessagebytes ( m ) ; netcdffile ncfile = netcdffile . openinmemory ( str_ , mbytes , str_ ) ; sequence obs = ( sequence ) ncfile . findvariable ( bufriosp2 . obsrecord ) ; structuredataiterator sdataiter = obs . getstructureiterator ( - num_ ) ; processsequence ( obs , sdataiter , counter ) ; }	convert one message ino a NetcdfDataset and print data.
public void dopost ( httpservletrequest req , httpservletresponse res ) throws servletexception , ioexception { log . info ( str_ + usagelog . setuprequestcontext ( req ) ) ;	POST handles uploaded files.
public affinetransform gettransform ( ) { at . settransform ( pix_per_world , num_ , num_ , - pix_per_world , pix_x0 , pix_y0 ) ; if ( debug ) { system . out . println ( str_ + pix_per_world + str_ + pix_x0 + str_ + pix_y0 ) ; system . out . println ( str_ + at ) ; } return at ; }	Get the affine transform based on screen size and world bounding box.
public boolean wantrotate ( double displaywidth , double displayheight ) { getmaparea ( bb ) ;	calculate if we want to rotate based on aspect ratio.
public projectionrect getmaparea ( projectionrect rect ) { if ( rect == null ) rect = new projectionrect ( ) ; double width = pwidth / pix_per_world ; double height = pheight / pix_per_world ;	Get current MapArea .
public point2d worldtoscreen ( projectionpointimpl w , point2d p ) { p . setlocation ( pix_per_world * w . getx ( ) + pix_x0 , - pix_per_world * w . gety ( ) + pix_y0 ) ; return p ; }	convert a world coordinate to a display point.
public void pan ( double deltax , double deltay ) { zoom . push ( ) ; pix_x0 -= deltax ; pix_y0 -= deltay ; firemapareaevent ( ) ; }	call this to change the center of the screen's world coordinates.deltax, deltay in display coordinates.
public void zoom ( double startx , double starty , double width , double height ) { if ( debugzoom ) system . out . println ( str_ + startx + str_ + starty + str_ + width + str_ + height + str_ ) ; if ( ( width < num_ ) || ( height < num_ ) ) return ; zoom . push ( ) ; pix_x0 -= startx + width / num_ - pwidth / num_ ; pix_y0 -= starty + height / num_ - pheight / num_ ; zoom ( pwidth / width ) ; }	call this to zoom into a subset of the screen.startx, starty are the upper left corner of the box in display coordswidth, height the size of the box in display coords.
private void recalcfromboundingbox ( ) { if ( debugrecalc ) { system . out . println ( str_ + bb ) ; system . out . println ( str_ + pwidth + str_ + pheight ) ; }	adjust bounding box to fit inside the screen size.
public synchronized void addlistener ( object l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; haslisteners = bool_ ; } else logger . warn ( str_ + l ) ; }	Add a listener.
public synchronized void removelistener ( object l ) { if ( listeners . contains ( l ) ) { listeners . remove ( l ) ; haslisteners = ( listeners . size ( ) > num_ ) ; } else logger . warn ( str_ + l ) ; }	Remove a listener.
public synchronized void sendevent ( java . util . eventobject event ) { if ( ! haslisteners || ! enabled ) return ; object [ ] args = new object [ num_ ] ; args [ num_ ] = event ;	Send an event to all registered listeners. If an exception is thrown, removethe Listener from the list.
public synchronized void sendeventexcludesource ( java . util . eventobject event ) { if ( ! haslisteners || ! enabled ) return ; object source = event . getsource ( ) ; object [ ] args = new object [ num_ ] ; args [ num_ ] = event ;	Send an event to all registered listeners, except the named one.
public static boolean print ( string command , writer out , ucar . nc2 . util . canceltask ct ) throws ioexception {	ncdump that parses a command string.
static public string printvariabledata ( variableif v , ucar . nc2 . util . canceltask ct ) throws ioexception { array data = v . read ( ) ; stringwriter writer = new stringwriter ( num_ ) ; printarray ( data , v . getfullname ( ) , new printwriter ( writer ) , new indent ( num_ ) , ct ) ; return writer . tostring ( ) ; }	Print all the data of the given Variable.
static public string printvariabledatasection ( variable v , string sectionspec , ucar . nc2 . util . canceltask ct ) throws ioexception , invalidrangeexception { array data = v . read ( sectionspec ) ; stringwriter writer = new stringwriter ( num_ ) ; printarray ( data , v . getfullname ( ) , new printwriter ( writer ) , new indent ( num_ ) , ct ) ; return writer . tostring ( ) ; }	Print a section of the data of the given Variable.
static public void printstructuredata ( printwriter out , structuredata sdata ) throws ioexception { printstructuredata ( out , sdata , new indent ( num_ ) , null ) ; out . flush ( ) ; }	Print contents of a StructureData.
static public void printarrayplain ( array ma , printwriter out ) { ma . resetlocaliterator ( ) ; while ( ma . hasnext ( ) ) { out . print ( ma . next ( ) ) ; out . print ( str_ ) ; } }	Print array as undifferentiated sequence of values.
static public void printarray ( array array , printwriter pw ) { printarray ( array , null , null , pw , new indent ( num_ ) , null , bool_ ) ; }	Print array to PrintWriter.
static public void writencml ( netcdffile ncfile , writer writer , wantvalues showvalues , string url ) throws ioexception { preconditions . checknotnull ( ncfile ) ; preconditions . checknotnull ( writer ) ; preconditions . checknotnull ( showvalues ) ; predicate < variable > writevarspred ; switch ( showvalues ) { case none : writevarspred = ncmlwriter . writenovariablespredicate ; break ; case coordsonly : writevarspred = ncmlwriter . writecoordinatevariablespredicate ; break ; case all : writevarspred = ncmlwriter . writeallvariablespredicate ; break ; default : string message = string . format ( str_ , showvalues ) ; throw new assertionerror ( message ) ; } ncmlwriter ncmlwriter = new ncmlwriter ( ) ; ncmlwriter . setwritevariablespredicate ( writevarspred ) ; element netcdfelement = ncmlwriter . makenetcdfelement ( ncfile , url ) ; ncmlwriter . writetowriter ( netcdfelement , writer ) ; }	Write the NcML representation for a file.Note that ucar.nc2.dataset.NcMLWriter has a JDOM implementation, for complete NcML.This method implements only the "core" NcML for plain ole netcdf files.
protected double readattributedouble ( attributecontainer v , string attname , double defvalue ) { attribute att = v . findattributeignorecase ( attname ) ; if ( att == null ) return defvalue ; if ( att . isstring ( ) ) return double . parsedouble ( att . getstringvalue ( ) ) ; else return att . getnumericvalue ( ) . doublevalue ( ) ; }	Read a variable attribute as a double.
protected boolean addparameter ( coordinatetransform rs , string paramname , netcdffile ds , string varnameescaped ) { if ( null == ( ds . findvariable ( varnameescaped ) ) ) { if ( null != errbuffer ) errbuffer . format ( str_ , gettransformname ( ) , varnameescaped ) ; return bool_ ; } rs . addparameter ( new parameter ( paramname , varnameescaped ) ) ; return bool_ ; }	Add a Parameter to a CoordinateTransform.Make sure that the variable exists.
protected object readas ( dapvariable atomvar , daptype basetype , list < slice > slices ) throws dapexception { if ( basetype . gettypesort ( ) == typesort . enum ) {	Allow specification of basetype to use; used for enumerations.
public final boolean ispositiveup ( gridrecord gr ) { int type = gr . getleveltype1 ( ) ; if ( ( type == num_ ) || ( type == num_ ) ) { return bool_ ; } return bool_ ; }	is this a PositiveUp VerticalCoordinate.
public boolean iscompatible ( final unit that ) {	Indicates if numeric values in this unit are convertible with anotherunit.
public string makelabel ( final string quantityid ) { final stringbuilder buf = new stringbuilder ( quantityid ) ; if ( quantityid . contains ( str_ ) ) { buf . insert ( num_ , str_ ) . append ( str_ ) ; } buf . append ( str_ ) ; final int start = buf . length ( ) ; buf . append ( tostring ( ) ) ; if ( buf . substring ( start ) . indexof ( str_ ) != - num_ ) { buf . insert ( start , str_ ) . append ( str_ ) ; } return buf . tostring ( ) ; }	Returns a label for a quantity in this unit.
public void setbitoffset ( int bitoffset ) throws ioexception { if ( bitoffset % num_ == num_ ) { raf . seek ( startpos + bitoffset / num_ ) ; bitpos = num_ ; bitbuf = num_ ; } else { raf . seek ( startpos + bitoffset / num_ ) ; bitpos = num_ - ( bitoffset % num_ ) ; bitbuf = ( byte ) raf . read ( ) ; bitbuf &= num_ > > ( num_ - bitpos ) ;	Position file at bitOffset from startPos.
public long bits2uint ( int nb ) throws ioexception { assert nb <= num_ ; assert nb >= num_ ; long result = num_ ; int bitsleft = nb ; while ( bitsleft > num_ ) {	Read the next nb bits and return an Unsigned Long .
public long bits2sint ( int nb ) throws ioexception { long result = bits2uint ( nb ) ;	Read the next nb bits and return an Signed Long .
private void openconnection ( string urlstring , command command ) throws ioexception , dap2exception { inputstream is = null ; try { try ( httpmethod method = httpfactory . get ( _session , urlstring ) ) { if ( acceptcompress ) method . setcompression ( str_ ) ;	Open a connection to the DODS server.
public das getdas ( ) throws ioexception , dap2exception { dascommand command = new dascommand ( ) ; if ( filepath != null ) {	Returns the DAS object from the dataset referenced by this object's URL.The DAS object is referred to by appending `.das' to the end of a DODSURL.
private string getcompletece ( string ce ) { string localprojstring = null ; string localselstring = null ; if ( ce == null ) return str_ ;	Use some sense when assembling the CE.
@ override public latlonpoint projtolatlon ( projectionpoint world , latlonpointimpl result ) { double fromx = world . getx ( ) - falseeasting ; double fromy = world . gety ( ) - falsenorthing ; double tolat_r = fromy / earthradius ; double tolon_r ; if ( misc . nearlyequals ( math . abs ( tolat_r ) , pi_over_2 , num_ ) ) { tolat_r = tolat_r < num_ ? - pi_over_2 : + pi_over_2 ; tolon_r = math . toradians ( centmeridian ) ;	Convert projection coordinates to a LatLonPoint.
private string idvdatasetcatalog ( string xml ) { string ret = xml . replace ( str_ , str_ ) ; ret = ret . replace ( str_ , str_ ) ; stringbuilder sub = new stringbuilder ( ret . substring ( num_ , ret . indexof ( str_ ) ) ) ; sub . append ( str_ ) ; sub . append ( str_ ) ; string endcoverage = str_ ; sub . append ( ret . substring ( ret . indexof ( endcoverage ) + endcoverage . length ( ) ) ) ; return sub . tostring ( ) ; }	This code tweaks our catalog output to match.
private daterange idvcompatiblerange ( daterange range ) { calendardate start = range . getstart ( ) . getcalendardate ( ) ; calendardate end = range . getend ( ) . getcalendardate ( ) ; return new daterange ( start . todate ( ) , end . todate ( ) ) ; }	present and 14 days.
boolean isvalidfile ( ucar . unidata . io . randomaccessfile rafile ) {	Check basic DMSP file validity of given random access file.
private void handlesatelliteinformation ( ) { spacecraftidatt = new attribute ( this . spacecraftidattname , headerinfo . get ( headerinfotitle . spacecraft_id . tostring ( ) ) ) ; noradidatt = new attribute ( this . noradidattname , headerinfo . get ( headerinfotitle . norad_id . tostring ( ) ) ) ; }	Parse the satellite information from the header.
private void handlesensorinformation ( ) { numsamplesperband = integer . parseint ( headerinfo . get ( headerinfotitle . samples_per_band . tostring ( ) ) ) ; numsamplesperbanddim = new dimension ( this . numsamplesperbanddimname , numsamplesperband ) ;	Parse the sensor information from the header.
static public element readrootelement ( string location ) throws ioexception { org . jdom2 . document doc ; try { saxbuilder builder = new saxbuilder ( ) ; doc = builder . build ( location ) ; } catch ( jdomexception e ) { throw new ioexception ( e . getmessage ( ) ) ; } return doc . getrootelement ( ) ; }	Read an XML Document from a URL and return the root element.
static public string cleancharacterdata ( string text ) { if ( text == null ) return null ; boolean bad = bool_ ; for ( int i = num_ , len = text . length ( ) ; i < len ; i ++ ) { int ch = text . charat ( i ) ; if ( ! org . jdom2 . verifier . isxmlcharacter ( ch ) ) { bad = bool_ ; break ; } } if ( ! bad ) return text ; stringbuilder sbuff = new stringbuilder ( text . length ( ) ) ; for ( int i = num_ , len = text . length ( ) ; i < len ; i ++ ) { int ch = text . charat ( i ) ; if ( org . jdom2 . verifier . isxmlcharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; } return sbuff . tostring ( ) ; }	Make sure that text is XML safe.
private static string xunescapestring ( string in , char escape , boolean spaceplus ) { try { if ( in == null ) return null ; byte [ ] utf8 = in . getbytes ( utf8charset ) ; byte escape8 = ( byte ) escape ; byte [ ] out = new byte [ utf8 . length ] ;	Given a string that contains WWW escape sequences, translate those escapesequences back into ASCII characters.
public static string escapeurlquery ( string ce ) { try { ce = escapestring ( ce , _allowableinurlquery ) ; } catch ( exception e ) { ce = null ; } return ce ; }	Define the DEFINITIVE URL constraint expression escape function.
public static string unescapeurlquery ( string ce ) { try { ce = unescapestring ( ce ) ; } catch ( exception e ) { ce = null ; } return ce ; }	Define the DEFINITIVE URL constraint expression unescape function.
public static string backslashdecode ( string s ) { stringbuilder buf = new stringbuilder ( s ) ; int i = num_ ; while ( i < buf . length ( ) ) { if ( buf . charat ( i ) == str_ ) { buf . deletecharat ( i ) ; } i ++ ; } return buf . tostring ( ) ; }	Define the DEFINITIVE URL BACKSLASH unescape function.
public static string backslashencode ( string s ) { stringbuilder buf = new stringbuilder ( ) ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { int c = buf . charat ( i ) ; if ( _mustbackslashescape . indexof ( c ) >= num_ ) buf . append ( _backslashescape ) ; buf . append ( ( char ) c ) ; } return buf . tostring ( ) ; }	Define the DEFINITIVE URL BACKSLASH escape function.
protected void addlightningglobalattributes ( netcdffile ncfile ) { ncfile . addattribute ( null , new attribute ( cf . feature_type , cf . featuretype . point . tostring ( ) ) ) ; ncfile . addattribute ( null , new attribute ( cdm . history , str_ ) ) ; }	Add the global attributes.
static public short swapshort ( byte [ ] b , int offset ) {	Returns the short resulting from swapping 2 bytes at a specifiedoffset in a byte array.
static public int swapint ( byte [ ] b , int offset ) {	Returns the int resulting from reversing 4 bytes at a specifiedoffset in a byte array.
static public double swapdouble ( byte [ ] b , int offset ) { long accum = num_ ; long shiftedval ; for ( int shiftby = num_ , i = offset ; shiftby < num_ ; shiftby += num_ , i ++ ) { shiftedval = ( ( long ) ( b [ i ] & num_ ) ) << shiftby ; accum |= shiftedval ; } return double . longbitstodouble ( accum ) ; }	Returns the double resulting from reversing 8 bytes at a specifiedoffset in a byte array.
static public float swapfloat ( float v ) { int l = swapint ( float . floattointbits ( v ) ) ; return ( float . intbitstofloat ( l ) ) ; }	Returns the float resulting from reversing 4 bytes of a specifiedfloat.
static public double swapdouble ( double v ) { long l = swaplong ( double . doubletolongbits ( v ) ) ; return ( double . longbitstodouble ( l ) ) ; }	Returns the double resulting from reversing 8 bytes of a specifieddouble.
static public byte [ ] shorttobytes ( short v ) { byte [ ] b = new byte [ num_ ] ; int allbits = num_ ; for ( int i = num_ ; i < num_ ; i ++ ) { b [ num_ - i ] = ( byte ) ( ( v & ( allbits << i * num_ ) ) > > i * num_ ) ; } return b ; }	Convert a short to an array of 2 bytes.
static public byte [ ] inttobytes ( int v ) { byte [ ] b = new byte [ num_ ] ; int allbits = num_ ; for ( int i = num_ ; i < num_ ; i ++ ) { b [ num_ - i ] = ( byte ) ( ( v & ( allbits << i * num_ ) ) > > i * num_ ) ; } return b ; }	Convert an int to an array of 4 bytes.
static public byte [ ] longtobytes ( long v ) { byte [ ] b = new byte [ num_ ] ; long allbits = num_ ; for ( int i = num_ ; i < num_ ; i ++ ) { b [ num_ - i ] = ( byte ) ( ( v & ( allbits << i * num_ ) ) > > i * num_ ) ; } return b ; }	Convert a long to an array of 8 bytes.
public verticaltransform subset ( range t_range , range z_range , range y_range , range x_range ) throws ucar . ma2 . invalidrangeexception { return new verticaltransformsubset ( this , t_range , z_range , y_range , x_range ) ; }	Create a subset of this VerticalTransform.
public string writexml ( date lastmodified ) { xmloutputter fmt = new xmloutputter ( format . getprettyformat ( ) ) ; return fmt . outputstring ( writedocument ( lastmodified ) ) ; }	Write the XML representation to a String.
private array makec ( array s , double a , double b ) { int nz = ( int ) s . getsize ( ) ; index sindex = s . getindex ( ) ; if ( a == num_ ) return s ;	Make the C array.
public void startxml ( ) { fileoutput += str_ ; fileoutput += str_ + str_ + wfscontroller . tdsnamespace + str_ + wfsxmlhelper . encquotes ( namespace ) + str_ + str_ + str_ + str_ + server + str_ + str_ ; fileoutput += str_ + str_ ; }	Initiate the response with an XML file with an XML header.
public void writefeatures ( ) { for ( wfsfeature feat : featurelist ) { fileoutput += str_ + feat . gettitle ( ) + str_ ; fileoutput += str_ ; fileoutput += str_ + feat . gettype ( ) + str_ ; fileoutput += str_ ; for ( wfsfeatureattribute attribute : feat . getattributes ( ) ) { fileoutput += str_ + attribute . getname ( ) + str_ + attribute . gettype ( ) + str_ ; } fileoutput += str_ ; fileoutput += str_ ; fileoutput += str_ ; fileoutput += str_ ; fileoutput += str_ + feat . getname ( ) + str_ + feat . gettitle ( ) + str_ ; } }	Write the features from the featureList. For each feature, write its attributes.
void addlevels ( list < gridrecord > records ) { for ( gridrecord record : records ) { double d = new double ( record . getlevel1 ( ) ) ; if ( ! levels . contains ( d ) ) { levels . add ( d ) ; } if ( dontusevertical && ( levels . size ( ) > num_ ) ) { if ( gridserviceprovider . debugvert ) { system . out . println ( str_ + verticalname + str_ + record . getleveltype1 ( ) + str_ + levels . size ( ) ) ; } } } collections . sort ( levels ) ; if ( positive . equals ( str_ ) ) { collections . reverse ( levels ) ;	Add levels from the GridRecords.
void adddimensionstonetcdffile ( netcdffile ncfile , group g ) { if ( dontusevertical ) { return ; } int nlevs = levels . size ( ) ; ncfile . adddimension ( g , new dimension ( verticalname , nlevs , bool_ ) ) ; }	Add dimensions to the netcdf file.
void addtonetcdffile ( netcdffile ncfile , group g ) { if ( dontusevertical ) { return ; } if ( g == null ) { g = ncfile . getrootgroup ( ) ; } string dims = str_ ; if ( ! dontusevertical ) { dims = dims + str_ + verticalname ; } if ( hcs . islatlon ( ) ) { dims = dims + str_ ; } else { dims = dims + str_ ; }	Add this coordinate system to the netCDF file.
void findcoordinatetransform ( group g , string namestartswith , int leveltype ) {	Find the coordinate transform.
int getindex ( gridrecord record ) { double d = new double ( record . getlevel1 ( ) ) ; return levels . indexof ( d ) ; }	Get the index of a particular GridRecord.
static public void exit ( ) { if ( timer != null ) { timer . cancel ( ) ; system . out . printf ( str_ ) ; } timer = null ; }	Be sure to call this when your application exits, otherwise your process may not exit without being killed.
public file getfile ( string filelocation ) { if ( ! alwaysusecache ) { file f = new file ( filelocation ) ; if ( f . exists ( ) ) return f ; if ( canwrite ( f ) ) return f ; } if ( neverusecache ) { throw new illegalstateexception ( str_ + filelocation ) ; } file f = new file ( makecachepath ( filelocation ) ) ; if ( cachepathpolicy == cachepathpolicy . nesteddirectory ) { file dir = f . getparentfile ( ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) cachelog . warn ( str_ + dir . getpath ( ) ) ; } return f ; }	Get the named File.If exists or isWritable, return it.Otherwise get corresponding file in the cache directory.If fileLocation has "/" in it, and cachePathPolicy == NestedDirectory, thenested directories will be created.
public file getexistingfileorcache ( string filelocation ) { file f = new file ( filelocation ) ; if ( f . exists ( ) ) return f ; if ( neverusecache ) return null ; file fc = new file ( makecachepath ( filelocation ) ) ; if ( fc . exists ( ) ) return fc ; return null ; }	Looking for an existing file, in cache or no.
public void showcache ( printstream pw ) { pw . println ( str_ ) ; pw . println ( str_ ) ; file dir = new file ( root ) ; file [ ] files = dir . listfiles ( ) ; if ( files != null ) for ( file file : files ) { string org = null ; try { org = urldecoder . decode ( file . getname ( ) , str_ ) ; } catch ( unsupportedencodingexception e ) { e . printstacktrace ( ) ; } pw . println ( str_ + file . length ( ) + str_ + new date ( file . lastmodified ( ) ) + str_ + org ) ; } }	Show cache contents, for debugging.
public void cleancache ( file dir , formatter sbuff , boolean isroot ) { long now = system . currenttimemillis ( ) ; file [ ] files = dir . listfiles ( ) ; if ( files == null ) { throw new illegalstateexception ( str_ + dir . getabsolutepath ( ) ) ; }	Remove any files or directories whose last modified time greater than persistMinutes.
public static bearing calculatebearing ( earth e , latlonpoint pt1 , latlonpoint pt2 , bearing result ) { return calculatebearing ( e , pt1 . getlatitude ( ) , pt1 . getlongitude ( ) , pt2 . getlatitude ( ) , pt2 . getlongitude ( ) , result ) ; }	Calculate the bearing between the 2 points.See calculateBearing below.
public static bearing calculatebearing ( latlonpoint pt1 , latlonpoint pt2 , bearing result ) { return calculatebearing ( defaultearth , pt1 . getlatitude ( ) , pt1 . getlongitude ( ) , pt2 . getlatitude ( ) , pt2 . getlongitude ( ) , result ) ; }	Calculate the bearing between the 2 points.See calculateBearing below.
public static void main ( string [ ] args ) {	Test the calculations - forward and back.
public static latlonpointimpl findpoint ( earth e , latlonpoint pt1 , double az , double dist , latlonpointimpl result ) { return findpoint ( e , pt1 . getlatitude ( ) , pt1 . getlongitude ( ) , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public static latlonpointimpl findpoint ( latlonpoint pt1 , double az , double dist , latlonpointimpl result ) { return findpoint ( defaultearth , pt1 . getlatitude ( ) , pt1 . getlongitude ( ) , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public static latlonpointimpl findpoint ( double lat1 , double lon1 , double az , double dist , latlonpointimpl result ) { return findpoint ( defaultearth , lat1 , lon1 , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public void loadpictureinthread ( url imageurl , int priority , double rotation ) { if ( picturestatuscode == loading ) { stoploadingexcept ( imageurl ) ; } this . imageurl = imageurl ; this . rotation = rotation ; loadthread t = new loadthread ( this ) ; t . setpriority ( priority ) ; t . start ( ) ; }	method to invoke with a filename or URL of a picture that is to be loadeda new thread.
public void loadpicture ( url imageurl , double rotation ) { if ( picturestatuscode == loading ) { stoploadingexcept ( imageurl ) ; } this . imageurl = imageurl ; this . rotation = rotation ; loadpicture ( ) ; }	method to invoke with a filename or URL of a picture that is to be loaded inthe main thread.
public void loadpicture ( ) { tools . log ( str_ + imageurl . tostring ( ) + str_ + integer . tostring ( this . hashcode ( ) ) ) ;	loads a picture from the URL in the imageUrl object into the sourcePictureBufferedImageobject and updates the status when done or failed.
public void stoploading ( ) { if ( imageurl == null ) return ;	this method can be invoked to stop the current reader.
public boolean stoploadingexcept ( url exemptionurl ) { if ( imageurl == null ) return bool_ ;	this method can be invoked to stop the current reader except if itis reading the desired file.
public dimension getsize ( ) { if ( sourcepicturebufferedimage != null ) return new dimension ( sourcepicturebufferedimage . getwidth ( ) , sourcepicturebufferedimage . getheight ( ) ) ; else return new dimension ( num_ , num_ ) ; }	return the size of the image or Zero if there is none.
public void setsourcebufferedimage ( bufferedimage img , string statusmessage ) { sourcepicturebufferedimage = img ; setstatus ( ready , statusmessage ) ; }	sets the buffered image.
public uri getstandarduri ( ) { try { catalog cat = dataset . getparentcatalog ( ) ; if ( cat == null ) return new uri ( getunresolvedurlname ( ) ) ; return cat . resolveuri ( getunresolvedurlname ( ) ) ; } catch ( java . net . urisyntaxexception e ) { throw new runtimeexception ( str_ + getunresolvedurlname ( ) ) ; } }	Construct the standard THREDDS access URI for this dataset access method,resolved agaisnt the parent catalog if the URI is relative.
static public void transferinfo ( list < datadescriptor > fromlist , list < datadescriptor > tolist ) {	Transfer info from the "proto message" to another message with the exact same structure.
int countbits ( ) { int total_nbits = num_ ; total_nbytescdm = num_ ; for ( datadescriptor dd : subkeys ) { if ( dd . subkeys != null ) { total_nbits += dd . countbits ( ) ; total_nbytescdm += dd . total_nbytescdm ; } else if ( dd . f == num_ ) { total_nbits += dd . bitwidth ; total_nbytescdm += dd . getbytewidthcdm ( ) ; } }	count the bits used by the data in this dd and its childrenonly accurate for not compressed, and not variable length.
public boolean equals2 ( object o ) { if ( this == o ) return bool_ ; if ( o == null || getclass ( ) != o . getclass ( ) ) return bool_ ; datadescriptor that = ( datadescriptor ) o ; if ( fxy != that . fxy ) return bool_ ; if ( replication != that . replication ) return bool_ ; if ( type != that . type ) return bool_ ; if ( subkeys != null ? ! subkeys . equals ( that . subkeys ) : that . subkeys != null ) return bool_ ; return bool_ ; }	LOOK need different hashCode, reader assumes using object id.
private int loadheader ( ) { if ( headerloaded ) return num_ ; inputstream s = stream ; if ( s == null ) return - num_ ; try { bufferedinputstream bs = new bufferedinputstream ( s ) ; ds = new datainputstream ( bs ) ; header = new byte [ num_ ] ; ds . readfully ( header ) ;	Load the dbase file header.
private int loaddata ( ) { if ( ! headerloaded ) return - num_ ; if ( dataloaded ) return num_ ; inputstream s = stream ; if ( s == null ) return - num_ ; try { for ( int i = num_ ; i < nrecords ; i ++ ) { byte recbyte = ds . readbyte ( ) ; if ( recbyte == num_ ) { for ( int j = num_ ; j < nfields ; j ++ ) { data [ j ] . readrown ( ds , i ) ; } } else { nrecords -- ; i -- ; } } dataloaded = bool_ ; } catch ( java . io . ioexception e ) { close ( s ) ; return - num_ ; } finally { close ( s ) ; } return num_ ; }	Load the dbase file data.
public dbasedata getfield ( string name ) { for ( int i = num_ ; i < nfields ; i ++ ) { if ( fielddesc [ i ] . name . equals ( name ) ) return data [ i ] ; } return null ; }	Extract the data for a given field by name.
public double [ ] getdoublesbyname ( string name ) { dbasedata d ; if ( ( d = getfield ( name ) ) == null ) return null ; if ( d . gettype ( ) == dbasedata . type_char ) { string [ ] s = d . getstrings ( ) ; double [ ] dd = new double [ s . length ] ; for ( int i = num_ ; i < s . length ; i ++ ) { dd [ i ] = double . valueof ( s [ i ] ) ; } return dd ; } if ( d . gettype ( ) == dbasedata . type_boolean ) { boolean [ ] b = d . getbooleans ( ) ; double [ ] dd = new double [ b . length ] ; for ( int i = num_ ; i < b . length ; i ++ ) { if ( b [ i ] ) { dd [ i ] = num_ ; } else { dd [ i ] = num_ ; } } return dd ; } return d . getdoubles ( ) ; }	Extract the double array of data for a field by Name.
public string [ ] getstringsbyname ( string name ) { dbasedata d ; if ( ( d = getfield ( name ) ) == null ) return null ; if ( d . gettype ( ) != dbasedata . type_char ) return null ; return d . getstrings ( ) ; }	Extract the string array of data for a field by Name.
public boolean [ ] getbooleansbyname ( string name ) { dbasedata d ; if ( ( d = getfield ( name ) ) == null ) return null ; if ( d . gettype ( ) != dbasedata . type_boolean ) return null ; return d . getbooleans ( ) ; }	Extract the boolean array of data for a field by Name.
public string getfieldname ( int i ) { if ( i >= nfields || i < num_ ) { return null ; } return ( fielddesc [ i ] . name ) ; }	Get the name of a field by column number.
public string [ ] getfieldnames ( ) { string [ ] s = new string [ nfields ] ; for ( int i = num_ ; i < nfields ; i ++ ) { s [ i ] = getfieldname ( i ) ; } return s ; }	Get a list of all the field names in the dbase file.
public static void main ( string [ ] args ) { if ( args . length < num_ ) { system . out . println ( str_ ) ; system . exit ( - num_ ) ; } for ( string s : args ) { system . out . println ( str_ + s + str_ ) ; try { dbasefile dbf = new dbasefile ( s ) ;	Test program, dumps a Dbase file to stdout.
public map < string , dapattribute > getattributes ( ) { if ( attributes == null ) attributes = new hashmap < string , dapattribute > ( ) ; return attributes ; }	attributes are not allowed on some node types.
synchronized public dapattribute setattribute ( dapattribute attr ) throws dapexception { if ( attributes == null ) attributes = new hashmap < string , dapattribute > ( ) ; dapattribute old = attributes . get ( attr . getshortname ( ) ) ; attributes . put ( attr . getshortname ( ) , attr ) ; attr . setparent ( this ) ; return old ; }	This may occur after initial construction.
public synchronized void removeattribute ( dapattribute attr ) throws dapexception { if ( this . attributes == null ) return ; string name = attr . getshortname ( ) ; if ( this . attributes . containskey ( name ) ) this . attributes . remove ( name ) ; }	Used by AbstractDSP to suppress certain attributes.
public dapgroup getgroup ( ) { if ( this . sort == dapsort . dataset ) return null ;	Closest containing group.
public dapnode getcontainer ( ) { dapnode parent = this . parent ; switch ( getsort ( ) ) { default : break ; case enumconst : parent = ( ( dapenumconst ) this ) . getparent ( ) . getcontainer ( ) ; break ; case attribute : case attributeset : case otherxml : parent = ( ( dapattribute ) this ) . getparent ( ) ; if ( parent instanceof dapvariable ) parent = parent . getcontainer ( ) ; break ; case map : parent = ( ( dapmap ) this ) . getvariable ( ) . getcontainer ( ) ; break ; } return parent ; }	Closest containing group, structure, sequence.
public string getescapedshortname ( ) { if ( this . escapedname == null ) this . escapedname = escape . backslashescape ( getshortname ( ) , null ) ; return this . escapedname ; }	Here, escaped means backslash escaped short name.
public list < dapnode > getcontainerpath ( ) { list < dapnode > path = new arraylist < dapnode > ( ) ; dapnode current = this . getcontainer ( ) ; for ( ; ; ) { path . add ( num_ , current ) ; if ( current . getcontainer ( ) == null ) break ; current = current . getcontainer ( ) ; } return path ; }	Get the transitive list of containersNot including this node.
public list < dapgroup > getgrouppath ( ) { list < dapgroup > path = new arraylist < dapgroup > ( ) ; dapnode current = this ; for ( ; ; ) { if ( current . getsort ( ) == dapsort . group || current . getsort ( ) == dapsort . dataset ) path . add ( num_ , ( dapgroup ) current ) ; if ( current . getcontainer ( ) == null ) break ; current = current . getcontainer ( ) ; } return path ; }	Get the transitive list of containing groupsPossibly including this node.
public string computefqn ( ) { list < dapnode > path = getpath ( ) ;	Compute the FQN of this node.
protected void build ( dapdataset dmr , byte [ ] serialdata , byteorder order ) throws dapexception { setdmr ( dmr ) ;	Build the data from the incoming serial dataNote that some DSP's will not use.
public void putbeancollection ( string key , collection newvalue ) {	Stores a Collection of beans.
public list getlist ( string key , list def ) { try { object bean = getbean ( key , def ) ; return ( list ) bean ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }	Get an arrayList. This returns a copy of the stored list.
private object _getobject ( string keyname ) { object result = null ; try { result = keyvalues . get ( keyname ) ; if ( result == null ) {	assume key non-null, locked node.
public float [ ] readdata ( randomaccessfile raf , long drspos ) throws ioexception { raf . seek ( drspos ) ; grib2sectiondatarepresentation drs = new grib2sectiondatarepresentation ( raf ) ; grib2sectionbitmap bms = new grib2sectionbitmap ( raf ) ; grib2sectiondata datasection = new grib2sectiondata ( raf ) ; grib2gds gds = getgds ( ) ; grib2datareader reader = new grib2datareader ( drs . getdatatemplate ( ) , gdss . getnumberpoints ( ) , drs . getdatapoints ( ) , getscanmode ( ) , gds . getnxraw ( ) , datasection . getstartingposition ( ) , datasection . getmsglength ( ) ) ; grib2drs gdrs = drs . getdrs ( raf ) ; float [ ] data = reader . getdata ( raf , bms , gdrs ) ; if ( gds . isthin ( ) ) data = quasiregular . convertquasigrid ( data , gds . getnptsinline ( ) , gds . getnxraw ( ) , gds . getnyraw ( ) , gribdata . getinterpolationmethod ( ) ) ; lastrecordread = this ; return data ; }	Read data array.
public dspprinter print ( ) throws dapexception { dapdataset dmr = this . dsp . getdmr ( ) ; if ( this . ce == null ) this . ce = ceconstraint . getuniversal ( dmr ) ; this . printer . setindent ( num_ ) ; list < dapvariable > topvars = dmr . gettopvariables ( ) ; for ( int i = num_ ; i < topvars . size ( ) ; i ++ ) { dapvariable top = topvars . get ( i ) ; list < slice > slices = this . ce . getconstrainedslices ( top ) ; if ( this . ce . references ( top ) ) { datacursor data = dsp . getvariabledata ( top ) ; printvariable ( data , slices ) ; } } printer . eol ( ) ; return this ; }	Print data from a DSP- optionally constrained.
protected void printcompoundinstance ( datacursor datav ) throws dapexception {	Print a single structure or sequence or record instance.
public string writetostring ( element elem ) { try ( stringwriter writer = new stringwriter ( ) ) { writetowriter ( elem , writer ) ; return writer . tostring ( ) ; } catch ( ioexception e ) { throw new assertionerror ( str_ , e ) ; } }	Writes an NcML element to a string.
public void writetofile ( element elem , file outfile ) throws ioexception { try ( outputstream outstream = new bufferedoutputstream ( new fileoutputstream ( outfile , bool_ ) ) ) { writetostream ( elem , outstream ) ; } }	Writes an NcML element to an output file.
public void writetostream ( element elem , outputstream outstream ) throws ioexception { try ( writer writer = new bufferedwriter ( new outputstreamwriter ( new bufferedoutputstream ( outstream ) , xmlformat . getencoding ( ) ) ) ) { writetowriter ( elem , writer ) ; } }	Writes an NcML element to an output stream.
public void writetowriter ( element elem , writer writer ) throws ioexception { xmloutputter . setformat ( xmlformat ) ; elem . detach ( ) ;	Writes an NcML element to a Writer.
public element makedimensionelement ( dimension dim ) throws illegalargumentexception { if ( ! dim . isshared ( ) ) { throw new illegalargumentexception ( str_ + str_ ) ; } element dimelem = new element ( str_ , namespace ) ; dimelem . setattribute ( str_ , dim . getshortname ( ) ) ; dimelem . setattribute ( str_ , integer . tostring ( dim . getlength ( ) ) ) ; if ( dim . isunlimited ( ) ) dimelem . setattribute ( str_ , str_ ) ; return dimelem ; }	Only for shared dimensions.
public projectionct makecoordinatetransform ( attributecontainer ctv , string units ) { int [ ] area = getintarray ( ctv , mcidasareaprojection . attr_areadir ) ; int [ ] nav = getintarray ( ctv , mcidasareaprojection . attr_navblock ) ; int [ ] aux = null ; if ( ctv . findattributeignorecase ( mcidasareaprojection . attr_auxblock ) != null ) { aux = getintarray ( ctv , mcidasareaprojection . attr_auxblock ) ; }	Make the coordinate transform.
private int [ ] getintarray ( attributecontainer ctv , string attname ) { attribute att = ctv . findattribute ( attname ) ; if ( att == null ) { throw new illegalargumentexception ( str_ + ctv . getname ( ) + str_ + attname + str_ ) ; } array arr = att . getvalues ( ) ; return ( int [ ] ) arr . get1djavaarray ( int . class ) ; }	get the int array from the variable attribute.
private static baseunit bu ( final string name , final string symbol , final basequantity quantity ) throws nameexception , unitexistsexception { return baseunit . getorcreate ( unitname . newunitname ( name , null , symbol ) , quantity ) ; }	Factory method for constructing a base unit.
private static unit du ( final string name , final string symbol , final unit definition ) throws nameexception { return definition . clone ( unitname . newunitname ( name , null , symbol ) ) ; }	Factory method for constructing a derived unit.
private static unitdbimpl baseunitdb ( ) throws nameexception , unitexistsexception , nosuchunitexception { final unitdbimpl db = new unitdbimpl ( num_ , num_ ) ; db . addunit ( ampere ) ; db . addunit ( candela ) ; db . addunit ( kelvin ) ; db . addunit ( kilogram ) ; db . addunit ( meter ) ; db . addunit ( mole ) ; db . addunit ( second ) ; db . addunit ( radian ) ; db . addunit ( steradian ) ; db . addalias ( str_ , str_ ) ; return db ; }	Returns the base unit database of the SI.
public static synchronized si instance ( ) throws unitsystemexception { if ( si == null ) { try { si = new si ( ) ; } catch ( final unitexception e ) { throw new unitsystemexception ( str_ , e ) ; } } return si ; }	Returns an instance of the SI system of units.
int findcoordelement ( double [ ] target , boolean bounded ) { switch ( axis . getspacing ( ) ) { case regularinterval :	Given a coordinate interval, find what grid element matches it.
private int findclosest ( double target ) { double mindiff = double . max_value ; double usevalue = double . min_value ; int idxfound = - num_ ; for ( int i = num_ ; i < axis . getncoords ( ) ; i ++ ) { double coord = axis . getcoordmidpoint ( i ) ; double diff = math . abs ( coord - target ) ; if ( diff < mindiff || ( diff == mindiff && coord > usevalue ) ) { mindiff = diff ; idxfound = i ; usevalue = coord ; } } return idxfound ; }	if its a tie, use the larger one.
private optional < coveragecoordaxisbuilder > subsetvalues ( double minvalue , double maxvalue , int stride ) { if ( axis . getspacing ( ) == coveragecoordaxis . spacing . discontiguousinterval ) return subsetvaluesdiscontinuous ( minvalue , maxvalue , stride ) ; double lower = axis . isascending ( ) ? math . min ( minvalue , maxvalue ) : math . max ( minvalue , maxvalue ) ; double upper = axis . isascending ( ) ? math . max ( minvalue , maxvalue ) : math . min ( minvalue , maxvalue ) ; int minindex = findcoordelement ( lower , bool_ ) ; int maxindex = findcoordelement ( upper , bool_ ) ; if ( minindex >= axis . getncoords ( ) ) return optional . empty ( string . format ( str_ , lower , axis . getendvalue ( ) ) ) ; if ( maxindex < num_ ) return optional . empty ( string . format ( str_ , upper , axis . getstartvalue ( ) ) ) ; if ( minindex < num_ ) minindex = num_ ; if ( maxindex >= axis . getncoords ( ) ) maxindex = axis . getncoords ( ) - num_ ; int count = maxindex - minindex + num_ ; if ( count <= num_ ) throw new illegalargumentexception ( str_ ) ; try { return optional . of ( subsetbyindex ( new range ( minindex , maxindex , stride ) ) ) ; } catch ( invalidrangeexception e ) { return optional . empty ( e . getmessage ( ) ) ; } }	look must handle discon interval different.
@ nonnull public datafactory . result openfeaturedataset ( dataset dataset , ucar . nc2 . util . canceltask task ) throws ioexception { return openfeaturedataset ( null , dataset , task , new result ( ) ) ; }	Open a FeatureDataset from an Dataset object, deciding on which Access to use.
public datafactory . result openfeaturedataset ( access access , ucar . nc2 . util . canceltask task ) throws ioexception { dataset ds = access . getdataset ( ) ; datafactory . result result = new result ( ) ; if ( ds . getfeaturetype ( ) == null ) { result . errlog . format ( str_ ) ; result . fatalerror = bool_ ; return result ; } return openfeaturedataset ( ds . getfeaturetype ( ) , access , task , result ) ; }	Open a FeatureDataset from an Access object.
public static void annotate ( dataset ds , netcdfdataset ncdataset ) { ncdataset . settitle ( ds . getname ( ) ) ; ncdataset . setid ( ds . getid ( ) ) ;	Add information from the Dataset to the NetcdfDataset.
public static float [ ] readdata ( randomaccessfile raf , long startpos ) throws ioexception { raf . seek ( startpos ) ; grib1record gr = new grib1record ( raf ) ; return gr . readdata ( raf ) ; }	Read data array by first reading in GribRecord.All sections are read in, so scanMode is from the datafile, not the index.
public string assemble ( enumset < parts > parts ) { stringbuilder uri = new stringbuilder ( ) ;	Reassemble the url using the specified parts.
static public string canonical ( string s ) { if ( s != null ) { s = s . trim ( ) ; if ( s . length ( ) == num_ ) s = null ; } return s ; }	Canonicalize a part of a URL.
private string normalize ( string units ) { switch ( units ) { case str_ : units = str_ ; break ; case str_ : units = str_ ; break ; case str_ : units = str_ ; break ; case str_ : units = str_ ; break ; default : units = stringutil2 . substitute ( units , str_ , str_ ) ; units = stringutil2 . remove ( units , str_ ) ; units = stringutil2 . remove ( units , str_ ) ; break ; } return units ; }	pretty much WRF specific.
public void finish ( ) { if ( init ) return ; init = bool_ ; if ( xlinkhref == null ) return ; xlinkhref = xlinkhref . trim ( ) ; try { this . xlinkuri = dataset . getparentcatalog ( ) . resolveuri ( xlinkhref ) ; } catch ( java . net . urisyntaxexception e ) { log . append ( str_ ) . append ( xlinkhref ) . append ( str_ ) ; return ; }	Finish getting the metadata if necessary.If this is an XLink, this will trigger a read of the href the first time called.
public synchronized object get ( object key ) { int index = keys . indexof ( key ) ; if ( index != - num_ ) return elements . elementat ( index ) ; else return null ; }	Returns the value to which the key is mapped in this table.
public synchronized object put ( object key , object value ) throws nullpointerexception { if ( key == null || value == null ) throw new nullpointerexception ( ) ; int index = keys . indexof ( key ) ; if ( index != - num_ ) { object prev = elements . elementat ( index ) ; elements . setelementat ( value , index ) ; return prev ; } else { keys . addelement ( key ) ; elements . addelement ( value ) ; return null ; } }	Maps the specified key to the specified value in this table.
public date getdate ( ) { calendar calendar = calendar . getinstance ( timezone . gettimezone ( str_ ) ) ; calendar . set ( calendar . year , year ) ; calendar . set ( calendar . month , month - num_ ) ;	Return this as a java Date object.
void printxmlattributes ( dapnode node , ceconstraint ce , int flags ) throws ioexception { if ( ( flags & perline ) != num_ ) printer . indent ( num_ ) ;	Print info from the node that needs to be in the form of xml attributes.
protected void printxmlattribute ( string name , string value , int flags ) throws dapexception { if ( name == null ) return ; if ( ( flags & nonnil ) == num_ && ( value == null || value . length ( ) == num_ ) ) return ; if ( ( flags & perline ) != num_ ) { printer . eol ( ) ; printer . margin ( ) ; } printer . print ( str_ + name + str_ ) ; printer . print ( str_ ) ; if ( value != null ) {	PrintXMLAttributes helper function.
static boolean isspecial ( dapattribute attr ) { if ( attr . getparent ( ) . getsort ( ) == dapsort . dataset ) { for ( string s : groupspecial ) { if ( s . equals ( attr . getshortname ( ) ) ) return bool_ ; } } else if ( attr . getparent ( ) . getsort ( ) == dapsort . variable ) { for ( string s : varspecial ) { if ( s . equals ( attr . getshortname ( ) ) ) return bool_ ; } } return bool_ ; }	Special here is not the same as reserved.
void printdimrefs ( dapvariable var ) throws dapexception { if ( var . getrank ( ) == num_ ) return ; list < dapdimension > dimset = this . ce . getconstraineddimensions ( var ) ; if ( dimset == null ) throw new dapexception ( str_ + var ) ; assert var . getrank ( ) == dimset . size ( ) ; for ( int i = num_ ; i < var . getrank ( ) ; i ++ ) { dapdimension dim = dimset . get ( i ) ; printer . marginprint ( str_ ) ; if ( dim . isshared ( ) ) { string fqn = dim . getfqn ( ) ; assert ( fqn != null ) : str_ ; fqn = fqnxmlescape ( fqn ) ; printxmlattribute ( str_ , fqn , xmlescaped ) ; } else { long size = dim . getsize ( ) ;	Print the dimrefs for a variable's dimensions.If the variable has a non-whole projection, then use sizeelse use the dimension name.
public static boolean isvalidfile ( randomaccessfile raf ) { string filename = raf . getlocation ( ) ; areafile af = null ; try { af = new areafile ( filename ) ;	Check to see if this is a valid AREA file.
private void setareadirectoryattributes ( variable v ) { if ( ( dirblock == null ) || ( ad == null ) ) { return ; } for ( int i = num_ ; i < num_ ; i ++ ) { if ( i == num_ ) { continue ; } v . addattribute ( new attribute ( getaddescription ( i ) , dirblock [ i ] ) ) ; } }	Set the area directory attributes on the variable.
private void setnavblockattributes ( variable v ) { if ( ( navblock == null ) || ( ad == null ) ) { return ; } v . addattribute ( new attribute ( str_ , mcidasutil . intbitstostring ( navblock [ num_ ] ) ) ) ; }	Set the navigation block attributes on the variable.
private int getcaltype ( string calname ) { int caltypeout = calibrator . cal_none ; if ( calname . trim ( ) . equals ( str_ ) ) { caltypeout = calibrator . cal_alb ; } else if ( calname . trim ( ) . equals ( str_ ) ) { caltypeout = calibrator . cal_brit ; } else if ( calname . trim ( ) . equals ( str_ ) ) { caltypeout = calibrator . cal_rad ; } else if ( calname . trim ( ) . equals ( str_ ) ) { caltypeout = calibrator . cal_raw ; } else if ( calname . trim ( ) . equals ( str_ ) ) { caltypeout = calibrator . cal_temp ; } return caltypeout ; }	Get the calibration type from the name.
private void setcaltypeattributes ( variable image , int caltype ) { string longname = str_ ;	Set the long name and units for the calibration type.
static public void findcoords ( tableconfig nt , netcdfdataset ds , predicate p ) { nt . lat = findcoordshortnamebytype ( ds , axistype . lat , p ) ; nt . lon = findcoordshortnamebytype ( ds , axistype . lon , p ) ; nt . time = findcoordshortnamebytype ( ds , axistype . time , p ) ; nt . elev = findcoordshortnamebytype ( ds , axistype . height , p ) ; if ( nt . elev == null ) nt . elev = findcoordshortnamebytype ( ds , axistype . pressure , p ) ; }	search for Axis by Type, assign to TableConfig if found.search for Lat, Lon, Time, Height.
static public string findcoordnamebytype ( netcdfdataset ds , axistype atype ) { coordinateaxis coordaxis = findcoordbytype ( ds , atype ) ; return coordaxis == null ? null : coordaxis . getfullname ( ) ; }	search for Axis by Type.
static public coordinateaxis findcoordbytype ( netcdfdataset ds , axistype atype ) { return findcoordbytype ( ds , atype , null ) ; }	Search for Axis by Type.
static public coordinateaxis findcoordbytype ( netcdfdataset ds , axistype atype , predicate p ) {	search for Axis by Type and test against a predicate.
static public dimension finddimensionbytype ( netcdfdataset ds , axistype atype ) { coordinateaxis axis = findcoordbytype ( ds , atype ) ; if ( axis == null ) return null ; if ( axis . isscalar ( ) ) return null ; return axis . getdimension ( num_ ) ; }	search for Dimension used by axis of given by Type.
static private coordinatesystem findbestcoordinatesystem ( netcdfdataset ds ) {	Find the CoordinateSystem with the most number of CoordinateAxes.
private coveragecoordaxis1d finddependent ( coveragecoordaxis independentaxis , axistype axistype ) { for ( coveragecoordaxis axis : axes ) { if ( axis . getdependencetype ( ) == coveragecoordaxis . dependencetype . dependent ) { for ( string axisname : axis . dependson ) { if ( axisname . equalsignorecase ( independentaxis . getname ( ) ) && axis . getaxistype ( ) == axistype ) return ( coveragecoordaxis1d ) axis ; } } } return null ; }	find the dependent axis that depend on independentAxis.
public basetype getvariable ( int row , string name ) throws nosuchvariableexception { int dotindex = name . indexof ( str_ ) ; if ( dotindex != - num_ ) {	Returns the named variable in the given row of the sequence.
private byte readmarker ( datainputstream source ) throws ioexception { byte marker = source . readbyte ( ) ;	Reads a marker byte from the input stream.
protected void writemarker ( dataoutputstream sink , byte marker ) throws ioexception {	Writes a marker byte to the output stream.
public static void main ( string [ ] args ) { timeseries dataset1 = createdataset ( str_ , num_ , new minute ( ) , num_ ) ; multipleaxischart demo = new multipleaxischart ( str_ , str_ , str_ , dataset1 ) ; timeseries dataset2 = createdataset ( str_ , num_ , new minute ( ) , num_ ) ; demo . addseries ( str_ , dataset2 ) ; timeseries dataset3 = createdataset ( str_ , num_ , new minute ( ) , num_ ) ; demo . addseries ( str_ , dataset3 ) ; timeseries dataset4 = createdataset ( str_ , num_ , new minute ( ) , num_ ) ; demo . addseries ( str_ , dataset4 ) ; demo . finish ( new java . awt . dimension ( num_ , num_ ) ) ; jframe frame = new jframe ( str_ ) ; frame . getcontentpane ( ) . add ( demo , borderlayout . center ) ; frame . setsize ( num_ , num_ ) ; frame . setvisible ( bool_ ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; }	Starting point for the demonstration application.
public string [ ] getjavaarraystring ( structuremembers . member m ) { if ( m . getdatatype ( ) == datatype . string ) { array data = getarray ( m ) ; int n = m . getsize ( ) ; string [ ] result = new string [ n ] ; for ( int i = num_ ; i < result . length ; i ++ ) result [ i ] = ( string ) data . getobject ( i ) ; return result ; } else if ( m . getdatatype ( ) == datatype . char ) { arraychar data = ( arraychar ) getarray ( m ) ; arraychar . stringiterator iter = data . getstringiterator ( ) ; string [ ] result = new string [ iter . getnumelems ( ) ] ; int count = num_ ; while ( iter . hasnext ( ) ) result [ count ++ ] = iter . next ( ) ; return result ; } throw new illegalargumentexception ( str_ + m . getdatatype ( ) ) ; }	LOOK can we optimize ??.
public doradeparm [ ] getparamlist ( ) { int paramcount = num_ ; for ( int i = num_ ; i < nsensors ; i ++ ) paramcount += myradds [ i ] . getnparams ( ) ; doradeparm [ ] list = new doradeparm [ paramcount ] ; int next = num_ ; for ( int i = num_ ; i < nsensors ; i ++ ) { int nparams = myradds [ i ] . getnparams ( ) ; system . arraycopy ( myradds [ i ] . getparamlist ( ) , num_ , list , next , nparams ) ; next += nparams ; } return list ; }	Get the array of available parameter names for this volume.
public void setstations ( java . util . list stns ) { stnrender . setstations ( stns ) ; redraw ( bool_ ) ; }	Set the list of Stations.
public void setselectedstation ( string id ) { stnrender . setselectedstation ( id ) ; selectedstation = stnrender . getselectedstation ( ) ; assert selectedstation != null ; np . setlatloncentermaparea ( selectedstation . getlatitude ( ) , selectedstation . getlongitude ( ) ) ; redraw ( ) ; }	Looks for the station with given id.
protected void redraw ( ) { long tstart = system . currenttimemillis ( ) ; java . awt . graphics2d gnp = np . getbufferedimagegraphics ( ) ; if ( gnp == null )	Redraw the graphics on the screen.
private void readobject ( objectinputstream s ) throws ioexception , classnotfoundexception { double x = s . readdouble ( ) ; double y = s . readdouble ( ) ; double w = s . readdouble ( ) ; double h = s . readdouble ( ) ; setrect ( x , y , w , h ) ; }	Read the object from the input stream of the serialized object.
private void writeobject ( objectoutputstream s ) throws ioexception { s . writedouble ( getx ( ) ) ; s . writedouble ( gety ( ) ) ; s . writedouble ( getwidth ( ) ) ; s . writedouble ( getheight ( ) ) ; }	Wrtie the object to the output stream.
public void add ( final unitdbimpl that ) throws unitexistsexception { unitset . addall ( that . unitset ) ; namemap . putall ( that . namemap ) ; symbolmap . putall ( that . symbolmap ) ; }	Adds all the entries in another UnitDBImpl to this database.
public void addunit ( final unit unit ) throws unitexistsexception , nameexception { if ( unit . getname ( ) == null ) { throw new nameexception ( str_ ) ; } addbyname ( unit . getname ( ) , unit ) ; addbyname ( unit . getplural ( ) , unit ) ; addbysymbol ( unit . getsymbol ( ) , unit ) ; unitset . add ( unit ) ; }	Adds a unit to the database.
public final void addsymbol ( final string symbol , final string name ) throws nosuchunitexception , unitexistsexception { addalias ( null , name , symbol , null ) ; }	Adds a symbol for a unit already in the database.
public unit get ( final string id ) { unit unit = getbysymbol ( id ) ; if ( unit == null ) { unit = getbyname ( id ) ; } return unit ; }	Gets a unit by either name, plural, or symbol.
private final void addbyname ( final string name , final unit newunit ) throws unitexistsexception { if ( name != null ) { addunique ( namemap , canonicalize ( name ) , newunit ) ; } }	Adds a unit to the database by name.
private final void addbysymbol ( final string symbol , final unit newunit ) throws unitexistsexception { if ( symbol != null ) { addunique ( symbolmap , symbol , newunit ) ; } }	Adds a unit to the database by symbol.
private static final void addunique ( final map < string , unit > map , final string key , final unit newunit ) throws unitexistsexception { final unit oldunit = map . put ( key , newunit ) ; if ( oldunit != null && ! oldunit . equals ( newunit ) ) { throw new unitexistsexception ( oldunit , newunit ) ; } }	Adds a unique unit to a map..
public void addtomenu ( final jmenu menu ) { final uimanager . lookandfeelinfo [ ] plafinfo = uimanager . getinstalledlookandfeels ( ) ; for ( uimanager . lookandfeelinfo aplafinfo : plafinfo ) { addtomenu ( aplafinfo . getname ( ) , aplafinfo . getclassname ( ) , menu ) ; } final lookandfeel current = uimanager . getlookandfeel ( ) ; system . out . printf ( str_ , current . getname ( ) ) ; }	Add a set of MenuItems to the given JMenu, one for each possible L&F.if this platform doesnt support the L&F, disable the MenuItem.
@ nullable public static grib2record findrecordbydrspos ( randomaccessfile raf , long drspos ) throws ioexception { long pos = math . max ( num_ , drspos - ( num_ * num_ ) ) ;	tricky bit of business.
public boolean read ( string datasetname , object specialo ) throws nosuchvariableexception , ioexception {	called if its scalar.
public void serialize ( string dataset , dataoutputstream sink , ceevaluator ce , object specialo ) throws nosuchvariableexception , dap2serversideexception , ioexception { if ( org == null ) { super . serialize ( dataset , sink , ce , specialo ) ; return ; }	overrride for array of Structures.
@ override public projectionimpl constructcopy ( ) { projectionimpl result = new verticalperspectiveview ( getoriginlat ( ) , getoriginlon ( ) , r , getheight ( ) , false_east , false_north ) ; result . setdefaultmaparea ( defaultmaparea ) ; result . setname ( name ) ; return result ; }	"map limit" circle of this radius from the origin, p 173.
public threddsdatafactory . result openfeaturedataset ( invdataset invdataset , ucar . nc2 . util . canceltask task ) throws ioexception { return openfeaturedataset ( null , invdataset , task , new result ( ) ) ; }	Open a FeatureDataset from an InvDataset object, deciding on which InvAccess to use.
public threddsdatafactory . result openfeaturedataset ( invaccess access , ucar . nc2 . util . canceltask task ) throws ioexception { invdataset invdataset = access . getdataset ( ) ; threddsdatafactory . result result = new result ( ) ; if ( invdataset . getdatatype ( ) == null ) { result . errlog . format ( str_ ) ; result . fatalerror = bool_ ; return result ; } return openfeaturedataset ( invdataset . getdatatype ( ) , access , task , result ) ; }	Open a FeatureDataset from an InvAccess object.
public netcdfdataset opendataset ( invdataset invdataset , boolean acquire , ucar . nc2 . util . canceltask task , formatter log ) throws ioexception { result result = new result ( ) ; netcdfdataset ncd = opendataset ( invdataset , acquire , task , result ) ; if ( log != null ) log . format ( str_ , result . errlog ) ; return ( result . fatalerror ) ? null : ncd ; }	Try to open as a NetcdfDataset.
public static void annotate ( invdataset ds , netcdfdataset ncdataset ) { ncdataset . settitle ( ds . getname ( ) ) ; ncdataset . setid ( ds . getid ( ) ) ;	Add information from the InvDataset to the NetcdfDataset.
void addpartition ( int partno , int groupno , int varno , int ndups , int nrecords , int nmissing , gribcollectionmutable . variableindex vi ) { if ( partlist == null ) partlist = new arraylist < > ( nparts ) ; partlist . add ( new partitionforvariable2d ( partno , groupno , varno ) ) ; this . ndups += ndups ; this . nrecords += nrecords ; this . nmissing += nmissing ; }	only used by PartitionBuilder, not PartitionBuilderFromIndex.
@ nullable public gribcollectionmutable makegribcollection ( ) { gribcollectionmutable result = gribcdmindex . openmutablegcfromindex ( dcm . getindexfilename ( gribcdmindex . ncx_suffix ) , config , bool_ , bool_ , logger ) ; if ( result == null ) { logger . error ( str_ , dcm . getindexfilename ( gribcdmindex . ncx_suffix ) ) ; return null ; } lastmodified = result . lastmodified ; filesize = result . filesize ; if ( result . masterruntime != null ) partitiondate = result . masterruntime . getfirstdate ( ) ; return result ; }	the children must already exist.
public static regexpanddurationtimecoverageenhancer getinstancetomatchondatasetname ( string matchpattern , string substitutionpattern , string duration ) { return new regexpanddurationtimecoverageenhancer ( matchpattern , substitutionpattern , duration , matchtarget . dataset_name ) ; }	Factory method that returns a RegExpAndDurationTimeCoverageEnhancer instancethat will apply the match pattern to the dataset name.
public static regexpanddurationtimecoverageenhancer getinstancetomatchondatasetpath ( string matchpattern , string substitutionpattern , string duration ) { return new regexpanddurationtimecoverageenhancer ( matchpattern , substitutionpattern , duration , matchtarget . dataset_path ) ; }	Factory method that returns a RegExpAndDurationTimeCoverageEnhancer instancethat will apply the match pattern to the dataset path.
public boolean writexml ( querycapability dqc , string filename ) { try { bufferedoutputstream os = new bufferedoutputstream ( new fileoutputstream ( filename ) ) ; writexml ( dqc , os ) ; os . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return bool_ ; } return bool_ ; }	Write the catalog as an XML document to the specified filename.
private ucar . ma2 . arraystructure readstructuredata ( ucar . nc2 . structure s , section section ) throws java . io . ioexception , invalidrangeexception { h4header . vinfo vinfo = ( h4header . vinfo ) s . getspobject ( ) ; vinfo . setlayoutinfo ( ) ;	Structures must be fixed sized.
public void setpicture ( url filenameurl , string legendparam , double rotation ) { legend = legendparam ; centerwhenscaled = bool_ ; sclpic . setscalesize ( getsize ( ) ) ; sclpic . stoploadingexcept ( filenameurl ) ; sclpic . loadandscalepictureinthread ( filenameurl , thread . max_priority , rotation ) ; }	brings up the indicated picture on the display.
public void setbufferedimage ( bufferedimage img , string statusmessage ) { legend = statusmessage ; centerwhenscaled = bool_ ; dimension dim = getsize ( ) ; sclpic . setscalesize ( dim ) ; sourcepicture source = new sourcepicture ( ) ; source . setsourcebufferedimage ( img , statusmessage ) ; sclpic . setsourcepicture ( source ) ; if ( ! scaletofit ) sclpic . setscalefactor ( num_ ) ; sclpic . scalepicture ( ) ; repaint ( ) ; }	sets the buffered image directly.
public void zoomtofit ( ) {	this method sets the desired scaled size of the ScalablePictureto the size of the JPanel and fires off a createScaledPictureInThreadrequest if the ScalablePicture has been loaded or is ready.
public void paintcomponent ( graphics g ) { int windowwidth = getsize ( ) . width ; int windowheight = getsize ( ) . height ; tools . log ( str_ ) ; if ( dragging == bool_ ) {	we are overriding the default paintComponent method, grabbing the Graphicshandle and doing our own drawing here.
public static int [ ] tg_ftoi ( int [ ] iftime , int start ) { int [ ] intdtf = new int [ num_ ] ;	This subroutine converts the two integers stored in a grid fileinto three integers containing the date, time and forecast time.
public static string tg_itoc ( int [ ] intdtf ) { string gdattim = str_ ;	This subroutine converts an integer time array containing the date,time and forecast time into a GEMPAK grid time.
public static string ti_itoc ( int [ ] idtarr ) { string dattim ; string date , time ;	This subroutine converts an integer time array into a standardGEMPAK time.
public static int ti_daym ( int iyear , int imon ) { int iday = num_ ; if ( ( imon > num_ ) && ( imon < num_ ) ) {	This subroutine returns the number of days in the given month.The year must be a full four-digit year.
public static string lv_ccrd ( int ivcord ) {	This subroutine translates a numeric value for IVCORD into itscharacter value in VCOORD.
public static int [ ] swp4 ( int [ ] values , int startindex , int number ) { for ( int i = startindex ; i < startindex + number ; i ++ ) { values [ i ] = integer . reversebytes ( values [ i ] ) ; } return values ; }	Swap the order of the integers in place.
public static string getgridpackingname ( int pktyp ) { string packingtype = str_ ; switch ( pktyp ) { case gempakconstants . mdgnon : packingtype = str_ ; break ; case gempakconstants . mdggrb : packingtype = str_ ; break ; case gempakconstants . mdgnmc : packingtype = str_ ; break ; case gempakconstants . mdgdif : packingtype = str_ ; break ; case gempakconstants . mdgdec : packingtype = str_ ; break ; case gempakconstants . mdgrb2 : packingtype = str_ ; break ; default : break ; } return packingtype ; }	Get a name for the grid packing type.
public static string getdatatype ( int typrt ) { string datatype = str_ + typrt ; switch ( typrt ) { case gempakconstants . mdreal : datatype = str_ ; break ; case gempakconstants . mdintg : datatype = str_ ; break ; case gempakconstants . mdchar : datatype = str_ ; break ; case gempakconstants . mdrpck : datatype = str_ ; break ; case gempakconstants . mdgrid : datatype = str_ ; break ; default : break ; } return datatype ; }	Get a name for the data packing type.
public void readdata ( inputstream is , statusui statusui ) throws ioexception , eofexception , dap2exception {	Read the data stream from the given InputStream.
public final void externalize ( outputstream os , boolean compress , boolean headers ) throws ioexception {	Dump the dataset using externalize methods.
public static tagenum gettag ( short code ) { tagenum te = hash . get ( code ) ; if ( te == null ) te = new tagenum ( str_ , str_ , code ) ; return te ; }	Find the Tag that matches the code.
public bufferedimage getnextimage ( boolean forward ) { if ( grid != null ) { if ( forward ) { this . time ++ ; if ( this . time >= this . ntimes ) this . time = num_ ; } else { this . time -- ; if ( this . time < num_ ) this . time = this . ntimes - num_ ; } array data ; try { data = grid . readdataslice ( this . time , num_ , - num_ , - num_ ) ; return imagearrayadapter . makegrayscaleimage ( data , grid ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return null ; } } if ( currentfile == null ) return null ; if ( currentdir == null ) { currentdirfileno = num_ ; currentdir = currentfile . getparentfile ( ) ; currentdirfilelist = new arraylist < > ( ) ; addtolist ( currentdir , currentdirfilelist ) ;	This assumes you have opened a file.
static public int size ( daptype type ) { switch ( type . gettypesort ( ) ) { case char :	Conmpute the size, in databuffer,of the daptype wrt to a serialization;0 if undefined.
private static int sumarray ( int [ ] arr ) { if ( arr == null ) throw new nullpointerexception ( str_ ) ; if ( arr . length == num_ ) throw new illegalargumentexception ( str_ ) ; int sum = num_ ; for ( int i = num_ ; i < arr . length ; i ++ ) { if ( arr [ i ] <= num_ ) { throw new illegalargumentexception ( str_ ) ; } sum += arr [ i ] ; } return sum ; }	Calculates the sum of the values in the given array.
public void setgrid ( rectangle2d bbox , double width , double height ) { offsetx = bbox . getx ( ) ; offsety = bbox . gety ( ) ;	Set the grid scale.
public void setoverlap ( int overlap ) {	Set how much the data may overlap.
public void clear ( ) { for ( int y = num_ ; y < county ; y ++ ) for ( int x = num_ ; x < countx ; x ++ ) gridarray [ y ] [ x ] . used = bool_ ; }	clear all the grid cells.
public boolean markifclear ( rectangle2d rect , object o ) { double centerx = rect . getx ( ) + rect . getwidth ( ) / num_ ; double centery = rect . gety ( ) + rect . getheight ( ) / num_ ; int indexx = ( int ) ( ( centerx - offsetx ) / gridwidth ) ; int indexy = ( int ) ( ( centery - offsety ) / gridheight ) ; if ( debugmark ) system . out . println ( str_ + rect + str_ + indexx + str_ + indexy ) ; if ( ( indexx < num_ ) || ( indexx >= countx ) || ( indexy < num_ ) || ( indexy >= county ) )	Check if the given rect intersects an already drawn one.If not, set the corresponding cell as marked, store object, return true,meaning "ok to draw".
public object findintersection ( rectangle2d rect ) { double centerx = rect . getx ( ) + rect . getwidth ( ) / num_ ; double centery = rect . gety ( ) + rect . getheight ( ) / num_ ; int indexx = ( int ) ( ( centerx - offsetx ) / gridwidth ) ; int indexy = ( int ) ( ( centery - offsety ) / gridheight ) ;	Check if the given rect intersects an already drawn object.
public object findintersection ( point2d p ) { int indexx = ( int ) ( ( p . getx ( ) - offsetx ) / gridwidth ) ; int indexy = ( int ) ( ( p . gety ( ) - offsety ) / gridheight ) ;	Check if the given point is contained in already drawn object.
public object findclosest ( point2d pt ) { object o = null ; int indexx = ( int ) ( ( pt . getx ( ) - offsetx ) / gridwidth ) ; int indexy = ( int ) ( ( pt . gety ( ) - offsety ) / gridheight ) ; if ( debugclosest ) system . out . println ( str_ + pt + str_ + indexx + str_ + indexy ) ; if ( ( indexx < num_ ) || ( indexx >= countx ) || ( indexy < num_ ) || ( indexy >= county ) )	Find the closest marked cell to the given point.
private double distancesq ( point2d pt , int indexx , int indexy ) { if ( ( indexx < num_ ) || ( indexx >= countx ) || ( indexy < num_ ) || ( indexy >= county ) )	if out of bbox or cell not marked, return MAX_DOUBLE.
public static synchronized baseunit getorcreate ( final unitname id , final basequantity basequantity ) throws nameexception , unitexistsexception { baseunit baseunit ; final baseunit nameunit = namemap . get ( id ) ; final baseunit quantityunit = quantitymap . get ( basequantity ) ; if ( nameunit != null || quantityunit != null ) { baseunit = nameunit != null ? nameunit : quantityunit ; if ( ( nameunit != null && ! basequantity . equals ( nameunit . getbasequantity ( ) ) ) || ( quantityunit != null && ! id . equals ( quantityunit . getunitname ( ) ) ) ) { throw new unitexistsexception ( str_ + baseunit + str_ ) ; } } else { baseunit = new baseunit ( id , basequantity ) ; quantitymap . put ( basequantity , baseunit ) ; namemap . put ( id , baseunit ) ; } return baseunit ; }	Factory method for creating a new BaseUnit or obtaining apreviously-created one.
static private servicetype searchfragment ( string fragment ) { if ( fragment . length ( ) == num_ ) return null ; map < string , string > map = parsefragment ( fragment ) ; if ( map == null ) return null ; string protocol = map . get ( str_ ) ; if ( protocol == null ) { for ( string p : fragprotocols ) { if ( map . get ( p ) != null ) { protocol = p ; break ; } } } if ( protocol != null ) { if ( protocol . equalsignorecase ( str_ ) || protocol . equalsignorecase ( str_ ) ) return servicetype . opendap ; if ( protocol . equalsignorecase ( str_ ) ) return servicetype . dap4 ; if ( protocol . equalsignorecase ( str_ ) ) return servicetype . cdmremote ; if ( protocol . equalsignorecase ( str_ ) ) return servicetype . thredds ; if ( protocol . equalsignorecase ( str_ ) ) return servicetype . ncml ; } return null ; }	Given a location, find markers indicated which protocol to useLOOK what use case is this handling ?.
static private servicetype searchpath ( string url ) { if ( bool_ ) {	Given a url, search the path to look for protocol indicators.
static private servicetype decodepathextension ( string path ) {	Check path extension; assumes no query or fragment.
static private servicetype checkifdods ( string location ) throws ioexception { int len = location . length ( ) ;	not sure what other opendap servers do, so fall back on check for dds.
public long senddata2 ( variable v , section section , outputstream out , ncstreamcompression compress ) throws ioexception , invalidrangeexception { if ( show ) system . out . printf ( str_ , v . getfullname ( ) , section ) ; boolean isvlen = v . isvariablelength ( ) ;	LOOK compression not used.
static public string fqnsuffix ( string fqn ) { int structindex = fqn . lastindexof ( str_ ) ; int groupindex = fqn . lastindexof ( str_ ) ; if ( structindex >= num_ ) return fqn . substring ( structindex + num_ , fqn . length ( ) ) ; else return fqn . substring ( groupindex + num_ , fqn . length ( ) ) ; }	return last name part of an fqn; result will be escaped.
static public string fqnprefix ( string fqn ) { int structindex = fqn . lastindexof ( str_ ) ; int groupindex = fqn . lastindexof ( str_ ) ; if ( structindex >= num_ ) return fqn . substring ( num_ , structindex ) ; else return fqn . substring ( num_ , groupindex ) ; }	return prefix name part of an fqn; result will be escaped.
static public string locatefile ( string filename , string abspath , boolean wantdir ) { deque < string > q = new arraydeque < string > ( ) ;	Walk the specified subtree dir tree to try to locate file|dir named filename.Use breadth first search.
static public string locaterelative ( string relpath , string abspath , boolean wantdir ) {	Walk the specified dir tree to locate file specified by relative path.Use breadth first search.
static public byte [ ] extract ( bytebuffer buf ) { int len = buf . limit ( ) ; byte [ ] bytes = new byte [ len ] ; buf . rewind ( ) ; buf . get ( bytes ) ; return bytes ; }	Properly extract the byte contents of a ByteBuffer.
static public list < dapvariable > getstructurepath ( dapvariable var ) { list < dapnode > path = var . getpath ( ) ; list < dapvariable > structpath = new arraylist < dapvariable > ( ) ; for ( int i = num_ ; i < path . size ( ) ; i ++ ) { dapnode node = path . get ( i ) ; switch ( node . getsort ( ) ) { case dataset : case group : break ; case variable : structpath . add ( ( dapvariable ) node ) ; break ; default : assert bool_ : str_ ; } } return structpath ; }	Given a dap variable, get the path from thetop-level variable to and including the given variablesuch that all but the last element is a structure.
static public string nullify ( string path ) { return ( path != null && path . length ( ) == num_ ? null : path ) ; }	Convert "" paths to null.
static public string join ( string [ ] array , string sep , int from , int upto ) { if ( sep == null ) sep = str_ ; if ( from < num_ || upto > array . length ) throw new indexoutofboundsexception ( ) ; if ( upto <= from ) return str_ ; stringbuilder result = new stringbuilder ( ) ; boolean first = bool_ ; for ( int i = from ; i < upto ; i ++ , first = bool_ ) { if ( ! first ) result . append ( sep ) ; result . append ( array [ i ] ) ; } return result . tostring ( ) ; }	Given an Array of Strings and a separator and a count,concat the first count elements of an array with separatorbetween them.
static public boolean hasdriveletter ( string path ) { boolean hasdr = bool_ ; if ( path != null && path . length ( ) >= num_ ) { hasdr = ( driveletters . indexof ( path . charat ( num_ ) ) >= num_ && path . charat ( num_ ) == str_ ) ; } return hasdr ; }	return true if this path appears to start with a windows drive letter.
static public list < string > getprotocols ( string url , int [ ] breakpoint ) {	Return the set of leading protocols for a url; may be more than one.
static public list < slice > indextoslices ( index indices , dapvariable template ) throws dap4 . core . util . dapexception { list < dapdimension > dims = template . getdimensions ( ) ; list < slice > slices = indextoslices ( indices , dims ) ; return slices ; }	Provide a helper function to convert an Index object toa slice list.
static public list < slice > offsettoslices ( long offset , dapvariable template ) throws dapexception { list < dapdimension > dims = template . getdimensions ( ) ; long [ ] dimsizes = daputil . getdimsizes ( dims ) ; return indextoslices ( offsettoindex ( offset , dimsizes ) , template ) ; }	Provide a helper function to convert an offset toa slice list.
static public boolean iscontiguous ( list < slice > slices ) { for ( slice sl : slices ) { if ( sl . getstride ( ) != num_ ) return bool_ ; } return bool_ ; }	Test if a set of slices represent a contiguous regionThis is equivalent to saying all strides are one.
static public boolean issinglepoint ( list < slice > slices ) { for ( slice sl : slices ) { if ( sl . getcount ( ) != num_ ) return bool_ ; } return bool_ ; }	Test if a set of slices represent a single position.
static public index slicestoindex ( list < slice > slices ) throws dapexception { long [ ] positions = new long [ slices . size ( ) ] ; long [ ] dimsizes = new long [ slices . size ( ) ] ; for ( int i = num_ ; i < positions . length ; i ++ ) { slice s = slices . get ( i ) ; if ( s . getcount ( ) != num_ ) throw new dapexception ( str_ ) ; positions [ i ] = s . getfirst ( ) ; dimsizes [ i ] = s . getmax ( ) ; } return new index ( positions , dimsizes ) ; }	If a set of slices refers to a single position,then return the corresponding Index.
public dataresult readdata ( inputstream is , netcdffile ncfile , string location ) throws ioexception { byte [ ] b = new byte [ num_ ] ; int bytesread = ncstream . readfully ( is , b ) ; if ( bytesread < b . length ) throw new eofexception ( location ) ; if ( ncstream . test ( b , ncstream . magic_data ) ) return readdata1 ( is , ncfile ) ; if ( ncstream . test ( b , ncstream . magic_data2 ) ) return readdata2 ( is ) ; throw new ioexception ( str_ + location ) ; }	Read the result of a data request.
public void setstationinfo ( string stnidvname , string stndescvname , string stnindexvname , stationhelper stationhelper ) { this . stnidvname = stnidvname ; this . stndescvname = stndescvname ; this . stnindexvname = stnindexvname ; this . stationhelper = stationhelper ; if ( stnidvname != null ) { variable stationvar = ncfile . findvariable ( stnidvname ) ; stationidtype = stationvar . getdatatype ( ) ; } }	Set extra information used by station obs datasets.Use stnIdVName or stnIndexVName.
public featurecollectionconfig readconfigfromcatalog ( string catalogandpath ) { string catfilename ; string fcname = null ; int pos = catalogandpath . indexof ( str_ ) ; if ( pos > num_ ) { catfilename = catalogandpath . substring ( num_ , pos ) ; fcname = catalogandpath . substring ( pos + num_ ) ; } else { catfilename = catalogandpath ; } file cat = new file ( catfilename ) ; org . jdom2 . document doc ; try { saxbuilder builder = new saxbuilder ( ) ; doc = builder . build ( cat ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } try { list < element > fcelems = new arraylist < > ( ) ; findfeaturecollection ( doc . getrootelement ( ) , fcname , fcelems ) ; if ( fcelems . size ( ) > num_ ) return readconfig ( fcelems . get ( num_ ) ) ; } catch ( illegalstateexception e ) { e . printstacktrace ( ) ; } return null ; }	Read a catalog and extract a FeatureCollectionConfig from it.
void updategroups ( list < dapgroup > groups ) {	We will need to re-order the groups.
public dapvariable findvariable ( string name ) { dapnode var = findingroup ( name , dapsort . variable ) ; return ( dapvariable ) var ; }	Locate a variable in this group.
protected axistype getaxistype ( netcdfdataset ncdataset , variableenhanced v ) { string unit = v . getunitsstring ( ) ; if ( unit == null ) return null ; unit = unit . trim ( ) ; if ( unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) ) return axistype . lon ; if ( unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) || unit . equalsignorecase ( str_ ) ) return axistype . lat ; if ( simpleunit . isdateunit ( unit ) ) { return axistype . time ; }	we assume that coordinate axes get identified by being coordinate variables.
@ nullable public static gribstattype getstattype ( int timerangeindicator ) { switch ( timerangeindicator ) { case num_ : case num_ : case num_ : case num_ : case num_ : case num_ : case num_ : case num_ : case num_ : return gribstattype . average ; case num_ : case num_ : case num_ : case num_ : return gribstattype . accumulation ; case num_ : return gribstattype . differencefromend ; case num_ : return gribstattype . covariance ; case num_ : case num_ : return gribstattype . standarddeviation ; default : return null ; } }	The time unit statistical type, derived from code table 5).
private optional < coveragecoordaxis > subsetlon ( latlonrect llbb , int stride ) throws invalidrangeexception { double wantmin = latlonpointimpl . lonnormalfrom ( llbb . getlonmin ( ) , lonaxis . getstartvalue ( ) ) ; double wantmax = latlonpointimpl . lonnormalfrom ( llbb . getlonmax ( ) , lonaxis . getstartvalue ( ) ) ; double start = lonaxis . getstartvalue ( ) ; double end = lonaxis . getendvalue ( ) ;	here's where to deal with crossing seam.
public list < rangeiterator > getranges ( ) { list < rangeiterator > result = new arraylist < > ( ) ; result . add ( getyaxis ( ) . getrange ( ) ) ; rangeiterator lonrange = getxaxis ( ) . getrangeiterator ( ) ; if ( lonrange == null ) lonrange = getxaxis ( ) . getrange ( ) ;	return y, x range.
static synchronized protected void setdefaults ( map < prop , object > props ) { if ( bool_ ) {	Provide defaults for a settings map.
public string getsessionid ( ) { string sid = null ; string jsid = null ; list < cookie > cookies = this . sessioncontext . getcookiestore ( ) . getcookies ( ) ; for ( cookie cookie : cookies ) { if ( cookie . getname ( ) . equalsignorecase ( str_ ) ) sid = cookie . getvalue ( ) ; if ( cookie . getname ( ) . equalsignorecase ( str_ ) ) jsid = cookie . getvalue ( ) ; } return ( sid == null ? jsid : sid ) ; }	Extract the sessionid cookie value.
public httpsession setmaxredirects ( int n ) { if ( n < num_ )	Set the max number of redirects to follow.
public httpsession setusesessions ( boolean tf ) { localsettings . put ( prop . usesessions , ( boolean ) tf ) ; this . cachevalid = bool_ ; return this ; }	Should we use sessionid's?.
synchronized public void close ( ) { if ( this . closed ) return ;	Close the session. This implies closingany open methods.
synchronized protected void setauthenticationandproxy ( httpclientbuilder cb ) throws httpexception {	Handle authentication and Proxy'ing.
static protected synchronized void track ( httpsession session ) { if ( ! testing ) throw new unsupportedoperationexception ( ) ; if ( sessionlist == null ) sessionlist = new concurrentskiplistset < httpsession > ( ) ; sessionlist . add ( session ) ; }	If we are testing, then track the sessions for kill.
@ deprecated static public void setglobalcredentialsprovider ( authscope scope , credentialsprovider provider ) throws httpexception { setglobalcredentialsprovider ( provider , scope ) ; }	Deprecated, but here for back compatibility.
void validate ( string urlstring ) { if ( urlstring == null ) return ; uri uri ; try { uri = new uri ( urlstring ) ; } catch ( urisyntaxexception e ) { javax . swing . joptionpane . showmessagedialog ( null , str_ + urlstring + str_ + e . getmessage ( ) + str_ ) ; return ; } string contents = gettext ( ) ;	private DqcFactory dqcFactory = null;.
static public index factory ( int [ ] shape ) { int rank = shape . length ; switch ( rank ) { case num_ : return new index0d ( ) ; case num_ : return new index1d ( shape ) ; case num_ : return new index2d ( shape ) ; case num_ : return new index3d ( shape ) ; case num_ : return new index4d ( shape ) ; case num_ : return new index5d ( shape ) ; case num_ : return new index6d ( shape ) ; case num_ : return new index7d ( shape ) ; default : return new index ( shape ) ; } }	Generate a subclass of Index optimized for this array's rank.
static private long computestrides ( int [ ] shape , int [ ] stride ) { long product = num_ ; for ( int ii = shape . length - num_ ; ii >= num_ ; ii -- ) { final int thisdim = shape [ ii ] ; if ( thisdim < num_ ) continue ;	Compute standard strides based on array's shape.Ignore vlen.
index section ( list < range > ranges ) throws invalidrangeexception {	create a new Index based on a subsection of this one, with rank reduction ifdimension length == 1.
index reduce ( ) { index c = this ; for ( int ii = num_ ; ii < rank ; ii ++ ) if ( shape [ ii ] == num_ ) {	Create a new Index based on current one byeliminating any dimensions with length one.
index reduce ( int dim ) { if ( ( dim < num_ ) || ( dim >= rank ) ) throw new illegalargumentexception ( str_ + dim ) ; if ( shape [ dim ] != num_ ) throw new illegalargumentexception ( str_ + dim + str_ ) ; index newindex = index . factory ( rank - num_ ) ; newindex . offset = offset ; int count = num_ ; for ( int ii = num_ ; ii < rank ; ii ++ ) { if ( ii != dim ) { newindex . shape [ count ] = shape [ ii ] ; newindex . stride [ count ] = stride [ ii ] ;	Create a new Index based on current one byeliminating the specified dimension;.
index transpose ( int index1 , int index2 ) { if ( ( index1 < num_ ) || ( index1 >= rank ) ) throw new illegalargumentexception ( ) ; if ( ( index2 < num_ ) || ( index2 >= rank ) ) throw new illegalargumentexception ( ) ; index newindex = ( index ) this . clone ( ) ; newindex . stride [ index1 ] = stride [ index2 ] ; newindex . stride [ index2 ] = stride [ index1 ] ; newindex . shape [ index1 ] = shape [ index2 ] ; newindex . shape [ index2 ] = shape [ index1 ] ; newindex . fastiterator = bool_ ; newindex . precalc ( ) ;	create a new Index based on current one, excepttranspose two of the indices.
index permute ( int [ ] dims ) { if ( dims . length != shape . length ) throw new illegalargumentexception ( ) ; for ( int dim : dims ) if ( ( dim < num_ ) || ( dim >= rank ) ) throw new illegalargumentexception ( ) ; boolean ispermuted = bool_ ; index newindex = ( index ) this . clone ( ) ; for ( int i = num_ ; i < dims . length ; i ++ ) { newindex . stride [ i ] = stride [ dims [ i ] ] ; newindex . shape [ i ] = shape [ dims [ i ] ] ;	create a new Index based on a permutation of the current indices; vlen fails.
indexiterator getindexiterator ( array maa ) { if ( fastiterator ) return new iteratorfast ( size , maa ) ; else return new iteratorimpl ( maa ) ; }	Get an index iterator for traversing the array in canonical order.
public int currentelement ( ) { int value = offset ;	Get the current element's index into the 1D backing array.VLEN stops processing.
public index set ( int [ ] index ) { if ( index . length != rank ) throw new arrayindexoutofboundsexception ( ) ; if ( rank == num_ ) return this ; int prefixrank = ( hasvlen ? rank : rank - num_ ) ; system . arraycopy ( index , num_ , current , num_ , prefixrank ) ; if ( hasvlen ) current [ prefixrank ] = - num_ ; return this ; }	Set the current element's index.
public void setdim ( int dim , int value ) { if ( value < num_ || value >= shape [ dim ] )	set current element at dimension dim to v.
public index set ( int v0 , int v1 , int v2 ) { setdim ( num_ , v0 ) ; setdim ( num_ , v1 ) ; setdim ( num_ , v2 ) ; return this ; }	set current element at dimension 0,1,2 to v0,v1,v2.
public string gettimeintervalname ( ) {	Check if we all time intervals have the same length.
@ override public calendardaterange makecalendardaterange ( ucar . nc2 . time . calendar cal ) { calendardateunit cdu = calendardateunit . of ( cal , timeunit . getfield ( ) , refdate ) ; calendardate start = cdu . makecalendardate ( timeunit . getvalue ( ) * timeintervals . get ( num_ ) . getbounds2 ( ) ) ; calendardate end = cdu . makecalendardate ( timeunit . getvalue ( ) * timeintervals . get ( getsize ( ) - num_ ) . getbounds2 ( ) ) ; return calendardaterange . of ( start , end ) ; }	Make calendar date range, using the first and last ending bounds.
protected list < string > makedatelist ( boolean unique ) { key date = datetimekeys . get ( num_ ) ; key time = datetimekeys . get ( num_ ) ; list < int [ ] > tocheck ; if ( date . type . equals ( row ) ) { tocheck = headers . rowheaders ; } else { tocheck = headers . colheaders ; } list < string > filedates = new arraylist < > ( ) ; for ( int [ ] header : tocheck ) { if ( header [ num_ ] != imissd ) {	Get the list of dates.
private list < gempakparameter > makeparams ( dmpart part ) { list < gempakparameter > gemparms = new arraylist < > ( part . kparms ) ; for ( dmparam param : part . params ) { string name = param . kprmnm ; gempakparameter parm = gempakparameters . getparameter ( name ) ; if ( parm == null ) {	Make GempakParameters from the list of.
private list < gempakstation > getstationlist ( ) { key slat = findkey ( gempakstation . slat ) ; if ( slat == null ) { return null ; } list < int [ ] > tocheck ; if ( slat . type . equals ( row ) ) { tocheck = headers . rowheaders ; } else { tocheck = headers . colheaders ; } list < gempakstation > filestations = new arraylist < > ( ) ; int i = num_ ; for ( int [ ] header : tocheck ) { if ( header [ num_ ] != imissd ) { gempakstation station = makestation ( header ) ; if ( station != null ) { station . setindex ( i + num_ ) ; filestations . add ( station ) ; } } i ++ ; } return filestations ; }	Get the station list.
public list < string > getstationkeynames ( ) { list < string > keys = new arraylist < > ( ) ; if ( ( stationkeys != null ) && ! stationkeys . isempty ( ) ) { for ( key key : stationkeys ) { keys . add ( key . name ) ; } } return keys ; }	Get the station key names.
public list < date > getdates ( ) { if ( ( dates == null || dates . isempty ( ) ) && ! datelist . isempty ( ) ) { dates = new arraylist < > ( datelist . size ( ) ) ; datefmt . settimezone ( timezone . gettimezone ( str_ ) ) ; for ( string datestring : datelist ) { date d = datefmt . parse ( datestring , new parseposition ( num_ ) ) ;	Get the list of dates in this file.
public int findstationindex ( string id ) { for ( gempakstation station : getstations ( ) ) { if ( station . getstid ( ) . equals ( id ) ) { return station . getindex ( ) ; } } return - num_ ; }	Find the station index for the specified station id.
public string getfiletype ( ) { string type = str_ ; switch ( dmlabel . kftype ) { case mfsn : type = str_ ; break ; case mfsf : type = str_ ; break ; default : } if ( ! subtype . equals ( str_ ) ) { type = type + str_ + subtype + str_ ; } return type ; }	Get the type for this file.
public void indent ( int n ) { depth += n ; if ( depth < num_ ) depth = num_ ; else if ( depth > maxdepth ) depth = maxdepth ; }	Set depth += n.
public void setindent ( int n ) { depth = n ; if ( depth < num_ ) depth = num_ ; else if ( depth > maxdepth ) depth = maxdepth ; }	Set depth = n.
public static gribindex readorcreateindexfromsinglefile ( boolean isgrib1 , mfile mfile , collectionupdatetype force , org . slf4j . logger logger ) throws ioexception { gribindex index = isgrib1 ? new grib1index ( ) : new grib2index ( ) ; if ( ! index . readindex ( mfile . getpath ( ) , mfile . getlastmodified ( ) , force ) ) {	Create a gbx9 index from a single grib1 or grib2 file.Use the existing index if it already exists.
public void adddirectoryscan ( string dirname , string suffix , string regexppatternstring , string subdirss , string olders , object auxinfo ) { compositemfilefilter filters = new compositemfilefilter ( ) ; if ( null != regexppatternstring ) filters . addincludefilter ( new regexpmatchonname ( regexppatternstring ) ) ; else if ( suffix != null ) filters . addincludefilter ( new wildcardmatchonpath ( str_ + suffix + str_ ) ) ; if ( olders != null ) { try { timeduration tu = new timeduration ( olders ) ; filters . addandfilter ( new lastmodifiedlimit ( ( long ) ( num_ * tu . getvalueinseconds ( ) ) ) ) ; } catch ( exception e ) { logger . error ( collectionname + str_ , olders ) ; } } boolean wantsubdirs = bool_ ; if ( ( subdirss != null ) && subdirss . equalsignorecase ( str_ ) ) wantsubdirs = bool_ ; collectionconfig mc = new collectionconfig ( dirname , dirname , wantsubdirs , filters , auxinfo ) ;	Add a directory scan to the collection.
@ override public boolean isscanneeded ( ) {	Compute if synchronous scan is needed.True if recheck is true and enough time has elapsed.
private boolean scanfirsttime ( ) throws ioexception { map < string , mfile > newmap = new hashmap < > ( ) ; if ( ! hasscans ( ) ) { map = newmap ; return bool_ ; } reallyscan ( newmap ) ;	only called from synch methods.
public static void setdebugflags ( ucar . nc2 . util . debugflags debugflags ) { debug = debugflags . isset ( str_ ) ; debugwrite = debugflags . isset ( str_ ) ; debugchunk = debugflags . isset ( str_ ) ; }	Set debugging flags.
public variable addvariable ( variable oldvar ) { list < dimension > newdims = getnewdimensions ( oldvar ) ; variable newvar ; if ( ( oldvar . getdatatype ( ) . equals ( datatype . string ) ) && ( ! version . isextendedmodel ( ) ) ) { newvar = writer . addstringvariable ( null , oldvar , newdims ) ; } else { newvar = writer . addvariable ( null , oldvar . getshortname ( ) , oldvar . getdatatype ( ) , newdims ) ; } varmap . put ( oldvar , newvar ) ; varlist . add ( oldvar ) ; for ( attribute orgatt : oldvar . getattributes ( ) ) writer . addvariableattribute ( newvar , convertattribute ( orgatt ) ) ; return newvar ; }	Specify which variable will get written.
public netcdffile write ( canceltask cancel ) throws ioexception { try { if ( version . isextendedmodel ( ) ) addgroupextended ( null , filein . getrootgroup ( ) ) ; else addgroupclassic ( ) ; if ( cancel != null && cancel . iscancel ( ) ) return null ;	Write the input file to the output file.
public static void validate ( xmlobject doc , boolean strict ) throws xmlexception {	Validates an xml doc.
@ override public string toconstraintstring ( ) throws dapexception { assert this . first != undefined && this . stride != undefined && this . stop != undefined ; stringbuilder buf = new stringbuilder ( ) ; buf . append ( str_ ) ; boolean first = bool_ ; for ( slice sub : this . subslices ) { if ( ! first ) buf . append ( str_ ) ; first = bool_ ; if ( ( sub . stop - sub . first ) == num_ ) { buf . append ( str_ ) ; } else if ( sub . stride == num_ ) { if ( ( sub . stop - sub . first ) == num_ ) buf . append ( sub . first ) ; else buf . append ( string . format ( str_ , sub . first , sub . stop - num_ ) ) ; } else buf . append ( string . format ( str_ , sub . first , sub . stride , sub . stop - num_ ) ) ; } buf . append ( str_ ) ; return buf . tostring ( ) ; }	Convert this multislice to a stringsuitable for use in a constraint.
public void setoriginalvariable ( ucar . nc2 . variable orgvar ) { if ( ! ( orgvar instanceof structure ) ) throw new illegalargumentexception ( str_ + orgvar . getfullname ( ) ) ; this . orgvar = ( structure ) orgvar ; }	Set the Structure to wrap.
@ override public array reallyread ( variable client , section section , canceltask canceltask ) throws ioexception , invalidrangeexception { if ( section . computesize ( ) == getsize ( ) ) return _read ( ) ; array result ; if ( hascacheddata ( ) ) result = super . reallyread ( client , section , canceltask ) ; else if ( orgvar != null ) result = orgvar . read ( section ) ; else { throw new illegalstateexception ( str_ ) ;	section of regular Variable.
private boolean convertneeded ( structuremembers smdata ) { for ( variable v : getvariables ( ) ) { if ( v instanceof variableds ) { variableds vds = ( variableds ) v ; if ( vds . needconvert ( ) ) return bool_ ; } else if ( v instanceof structureds ) { structureds nested = ( structureds ) v ; if ( nested . convertneeded ( null ) ) return bool_ ; }	is conversion needed?.
protected arraystructure convert ( array data , section section ) throws ioexception { arraystructure orgas = ( arraystructure ) data ; if ( ! convertneeded ( orgas . getstructuremembers ( ) ) ) {	3) variable with cached data added to StructureDS through NcML.
private void convertmemberinfo ( structuremembers wrappersm ) { for ( structuremembers . member m : wrappersm . getmembers ( ) ) { variable v = findvariable ( m . getname ( ) ) ; if ( ( v == null ) && ( orgvar != null ) )	the wrapper StructureMembers must be converted to correspond to the wrapper Structure.
private variableenhanced findvariablefromorgname ( string orgname ) { for ( variable vtop : getvariables ( ) ) { variable v = vtop ; while ( v instanceof variableenhanced ) { variableenhanced ve = ( variableenhanced ) v ; if ( ( ve . getoriginalname ( ) != null ) && ( ve . getoriginalname ( ) . equals ( orgname ) ) ) return ( variableenhanced ) vtop ; v = ve . getoriginalvariable ( ) ; } } return null ; }	look for the top variable that has an orgVar with the wanted orgName.
private boolean varhasdata ( variable v , structuremembers sm ) { if ( sm . findmember ( v . getshortname ( ) ) != null ) return bool_ ; while ( v instanceof variableenhanced ) { variableenhanced ve = ( variableenhanced ) v ; if ( sm . findmember ( ve . getoriginalname ( ) ) != null ) return bool_ ; v = ve . getoriginalvariable ( ) ; } return bool_ ; }	verify that the variable has data in the data array.
public void enhance ( set < netcdfdataset . enhance > mode ) { for ( variable v : getvariables ( ) ) { variableenhanced ve = ( variableenhanced ) v ; ve . enhance ( mode ) ; } }	DO NOT USE DIRECTLY.
public boolean resourcecontrolok ( httpservletrequest req , httpservletresponse res , string reqpath ) { if ( null == reqpath ) reqpath = tdspathutils . extractpath ( req , null ) ;	Check if this is making a request for a restricted dataset, and if so, if its allowed.
private arraysequence makeemptysequence ( sequence seq ) { structuremembers members = seq . makestructuremembers ( ) ; return new arraysequence ( members , new emptystructuredataiterator ( ) , - num_ ) ; }	Create an empty ArraySequence for missing data.
private arraysequence makearraysequence ( sequence seq , list < gempakparameter > params , float [ ] values ) { if ( values == null ) { return makeemptysequence ( seq ) ; } int numlevels = values . length / params . size ( ) ; structuremembers members = seq . makestructuremembers ( ) ; int offset = arraystructurebb . setoffsets ( members ) ; int size = offset * numlevels ; byte [ ] bytes = new byte [ size ] ; bytebuffer buf = bytebuffer . wrap ( bytes ) ; arraystructurebb abb = new arraystructurebb ( members , new int [ ] { numlevels } , buf , num_ ) ; int var = num_ ; for ( int i = num_ ; i < numlevels ; i ++ ) { for ( gempakparameter param : params ) { if ( members . findmember ( param . getname ( ) ) != null ) { buf . putfloat ( values [ var ] ) ; } var ++ ; } } return new arraysequence ( members , new sequenceiterator ( numlevels , abb ) , numlevels ) ; }	Create an ArraySequence to hold the data.
protected sequence makesequence ( structure parent , string partname , boolean includemissing ) { list < gempakparameter > params = gemreader . getparameters ( partname ) ; if ( params == null ) { return null ; } sequence svar = new sequence ( ncfile , null , parent , partname ) ; svar . setdimensions ( str_ ) ; for ( gempakparameter param : params ) { variable v = makeparamvariable ( param , null ) ; addverticalcoordattribute ( v ) ; svar . addmembervariable ( v ) ; } if ( includemissing ) { svar . addmembervariable ( makemissingvariable ( ) ) ; } return svar ; }	Make a Sequence for the part.
private void addverticalcoordattribute ( variable v ) { gempaksoundingfilereader gsfr = ( gempaksoundingfilereader ) gemreader ; int verttype = gsfr . getverticalcoordinate ( ) ; string pname = v . getfullname ( ) ; if ( gemreader . getfilesubtype ( ) . equals ( gempaksoundingfilereader . merged ) ) { if ( ( verttype == gempaksoundingfilereader . pres_coord ) && pname . equals ( str_ ) ) { v . addattribute ( new attribute ( _coordinate . axistype , axistype . pressure . name ( ) ) ) ; } else if ( ( verttype == gempaksoundingfilereader . hght_coord ) && ( pname . equals ( str_ ) || pname . equals ( str_ ) || pname . equals ( str_ ) ) ) { v . addattribute ( new attribute ( _coordinate . axistype , axistype . height . name ( ) ) ) ; } } else if ( pname . equals ( str_ ) ) { v . addattribute ( new attribute ( _coordinate . axistype , axistype . pressure . name ( ) ) ) ; } }	Add the vertical coordinate variables if necessary.
public void readxmlasynch ( string uristring , catalogsetcallback callback ) { invcatalogimpl cat = readxml ( uristring ) ; callback . setcatalog ( cat ) ; }	This allows the possibility of reading a catalog in another thread.
public invcatalogimpl readxml ( string catasstring , uri baseuri ) { return readxml ( new stringreader ( catasstring ) , baseuri ) ; }	Create an InvCatalog by reading catalog XML from a String.Failures and exceptions are handled by causing validate() tofail.
public invcatalogimpl readxml ( stringreader catasstringreader , uri baseuri ) { xmlentityresolver resolver = new xmlentityresolver ( bool_ ) ; saxbuilder builder = resolver . getsaxbuilder ( ) ; document indoc ; try { indoc = builder . build ( catasstringreader ) ; } catch ( exception e ) { invcatalogimpl cat = new invcatalogimpl ( baseuri . tostring ( ) , null , null ) ; cat . appenderrormessage ( str_ + str_ + e . getclass ( ) . getname ( ) + str_ + e . getmessage ( ) + str_ + fatalmessages . tostring ( ) + str_ + errmessages . tostring ( ) + str_ + warnmessages . tostring ( ) + str_ , bool_ ) ; return cat ; } return readxml ( indoc , baseuri ) ; }	Create an InvCatalog by reading catalog XML from a StringReader.Failures and exceptions are handled by causing validate() tofail.
public void writexml ( invcatalogimpl catalog , outputstream os , boolean raw ) throws ioexception { invcatalogconvertif converter = this . getcatalogconverter ( xmlentityresolver . catalog_namespace_10 ) ; converter . writexml ( catalog , os , raw ) ; }	Write the InvCatalogImpl to the OutputStream as a InvCatalog 1.0 document.
public metadataconverterif getmetadataconverter ( string key ) { if ( key == null ) return null ; return metadataconverters . get ( key ) ; }	Find the MetadataConverterIF registered for this key.
private static unitname dimensionlessid ( ) { unitname id ; try { id = unitname . newunitname ( str_ , str_ , str_ ) ; } catch ( final nameexception e ) { id = null ; } return id ; }	Returns the identifiers associated with the dimensionless, derived unit.
@ override protected unit mymultiplyby ( final unit that ) throws multiplyexception { unit result ; if ( dimension . getrank ( ) == num_ ) { result = that ; } else { if ( ! ( that instanceof derivedunit ) ) { result = that . multiplyby ( this ) ; } else { final unitdimension thatdimension = ( ( derivedunit ) that ) . getdimension ( ) ; result = thatdimension . getrank ( ) == num_ ? this : new derivedunitimpl ( dimension . multiplyby ( thatdimension ) ) ; } } return result ; }	Multiplies this derived unit by another.
@ override protected unit mydivideby ( final unit that ) throws operationexception { unit result ; if ( dimension . getrank ( ) == num_ ) { result = that . raiseto ( - num_ ) ; } else { if ( ! ( that instanceof derivedunit ) ) { result = that . divideinto ( this ) ; } else { final unitdimension thatdimension = ( ( derivedunit ) that ) . getdimension ( ) ; result = thatdimension . getrank ( ) == num_ ? this : new derivedunitimpl ( dimension . divideby ( thatdimension ) ) ; } } return result ; }	Divides this derived unit by another.
public final float [ ] toderivedunit ( final float [ ] input , final float [ ] output ) { if ( input != output ) { system . arraycopy ( input , num_ , output , num_ , input . length ) ; } return output ; }	Converts numerical values from this unit to the derived unit.
@ override public final boolean iscompatible ( final unit that ) { final derivedunit unit = that . getderivedunit ( ) ; return equals ( unit ) || isreciprocalof ( unit ) ; }	Indicates if values in this unit are convertible with another unit.
public string writefeature ( simplegeometry geom ) { if ( geom instanceof point ) return writepoint ( ( point ) geom ) ; else if ( geom instanceof line ) return writeline ( ( line ) geom ) ; else if ( geom instanceof polygon ) return writepolygon ( ( polygon ) geom ) ; else return null ; }	Checks the type of the Simple Geom and calls the appropriate method to build the xml.
private string writepoint ( point point ) { string xml = str_ ; xml += str_ + str_ + point . getx ( ) + str_ + point . gety ( ) + str_ + str_ ; return xml ; }	Takes in a point and writes its xml.
private string writeline ( line line ) { string xml = str_ ; xml += str_ ; for ( point point : line . getpoints ( ) ) { xml += point . getx ( ) + str_ + point . gety ( ) + str_ ; } xml += str_ ; return xml ; }	Takes in a line and iterates through all its points, writing the posList to xml.
private string writepolygon ( polygon poly ) { string xml = str_ ; xml += str_ ; polygon polygon = poly ;	Takes in a polygon, checks whether it is an interior or exterior ring, and writes the corresponding xml.Iterates through all linked polygons.
list < node > getsubnodes ( node parent ) { list < node > subs = new arraylist < > ( ) ; nodelist nodes = parent . getchildnodes ( ) ; for ( int i = num_ ; i < nodes . getlength ( ) ; i ++ ) { node n = nodes . item ( i ) ; if ( n . getnodetype ( ) == node . element_node ) subs . add ( n ) ; } return subs ; }	Return the subnodes of a node with non-element nodes suppressed.
protected void passreserved ( node node , dapnode dap ) throws parseexception { try { namednodemap attrs = node . getattributes ( ) ; for ( int i = num_ ; i < attrs . getlength ( ) ; i ++ ) { node n = attrs . item ( i ) ; string key = n . getnodename ( ) ; string value = n . getnodevalue ( ) ; if ( isreserved ( key ) ) dap . addxmlattribute ( key , value ) ; } } catch ( dapexception de ) { throw new parseexception ( de ) ; } }	Pass reserved xml attributes unchanged.
public static string getsubsetstring ( variable var , int beginind , int endind , int id ) { if ( var == null ) return null ; string substr = str_ ; list < dimension > dimlist = var . getdimensions ( ) ;	Gets the subset string to be used in NetCDFFile.read given a variable and some indicies.useful for subsetting timeseries.
static public arraystructurema factoryma ( arraystructure from ) throws ioexception { if ( from instanceof arraystructurema ) return ( arraystructurema ) from ;	Turn any ArrayStructure into a ArrayStructureMA.
public void setmemberarray ( string membername , array data ) { structuremembers . member m = members . findmember ( membername ) ; m . setdataarray ( data ) ; }	Set the data array for this member.
static public arraystructurema factoryma ( structure from , int [ ] shape ) throws ioexception { structuremembers sm = from . makestructuremembers ( ) ; for ( variable v : from . getvariables ( ) ) { array data ; if ( v instanceof sequence ) { data = array . factory ( datatype . sequence , shape ) ;	Create an ArrayStructure for a Structure.
public geometrytype getgeometrytype ( string name ) { variable geometryvar = ds . findvariable ( name ) ; if ( geometryvar == null ) return null ;	Given a variable name, returns the geometry type which that variable is associated with.If the variable has no simple geometry information, null will be returned.
public stationtimeseriesfeature makestation ( structuredata stationdata , int recnum ) { stationfeature s = ft . makestation ( stationdata ) ; if ( s == null ) return null ; return new standardstationfeatureimpl ( s , timeunit , stationdata , recnum ) ; }	Make a Station from the station data structure.
protected void compileast ( ceast ast ) throws dapexception { switch ( ast . sort ) { case constraint : for ( ceast clause : ast . clauses ) { compileast ( clause ) ; }	Recursive AST walker; compilation of filters is done elsewhere.
public void compilefilter ( dapvariable var , dapsequence seq , ceast expr ) throws dapexception { if ( expr == null ) return ; if ( expr . sort == ceast . sort . segment ) {	Convert field references in a filter.
protected void dimredef ( ceast node ) throws dapexception { dapdimension dim = ( dapdimension ) dataset . findbyfqn ( node . name , dapsort . dimension ) ; if ( dim == null ) throw new dapexception ( str_ + node . name ) ; slice slice = node . slice ; slice . finish ( ) ; ce . addredef ( dim , slice ) ; }	Process a dim redefinition.
protected array createview ( index index ) { return arrayobject . factory ( datatype , elementtype , isvlen , index , storage ) ; }	create new Array with given indexImpl and the same backing store.
public boolean containedin ( latlonrect b ) { return ( b . getwidth ( ) >= width ) && b . contains ( upperright ) && b . contains ( lowerleft ) ; }	Determine if this bounding box is contained in another LatLonRect.
public void extend ( latlonpoint p ) { if ( contains ( p ) ) return ; double lat = p . getlatitude ( ) ; double lon = p . getlongitude ( ) ;	Extend the bounding box to contain this point.
public void extend ( latlonrect r ) { preconditions . checknotnull ( r ) ;	Extend the bounding box to contain the given rectangle.
public latlonrect intersect ( latlonrect clip ) { double latmin = math . max ( getlatmin ( ) , clip . getlatmin ( ) ) ; double latmax = math . min ( getlatmax ( ) , clip . getlatmax ( ) ) ; double deltalat = latmax - latmin ; if ( deltalat < num_ ) return null ;	Create the instersection of this LatLon with the given one.
public static array add ( array a , array b ) throws illegalargumentexception { array result = array . factory ( a . getdatatype ( ) , a . getshape ( ) ) ; if ( a . getelementtype ( ) == double . class ) { adddouble ( result , a , b ) ; } else throw new unsupportedoperationexception ( ) ; return result ; }	Add elements of two arrays together, allocating the result array.The result type and the operation type are taken from the type of a.
public static boolean conformable ( array a , array b ) { return conformable ( a . getshape ( ) , b . getshape ( ) ) ; }	Check that two arrays are conformable.
public static boolean conformable ( int [ ] shapea , int [ ] shapeb ) { if ( reducedrank ( shapea ) != reducedrank ( shapeb ) ) return bool_ ; int rankb = shapeb . length ; int dimb = num_ ; for ( int ashapea : shapea ) {	Check that two array shapes are conformable.The shapes must match exactly, except that dimensions of length 1 are ignored.
public static array convert ( array org , datatype wanttype ) { if ( org == null ) return null ; class wantclass = wanttype . getprimitiveclasstype ( ) ; if ( org . getelementtype ( ) . equals ( wantclass ) ) return org ; array result = array . factory ( wanttype , org . getshape ( ) ) ; copy ( wanttype , org . getindexiterator ( ) , result . getindexiterator ( ) ) ; return result ; }	Convert original array to desired type.
public static void copy ( array result , array a ) throws illegalargumentexception { class classtype = a . getelementtype ( ) ; if ( classtype == double . class ) { copydouble ( result , a ) ; } else if ( classtype == float . class ) { copyfloat ( result , a ) ; } else if ( classtype == long . class ) { copylong ( result , a ) ; } else if ( classtype == int . class ) { copyint ( result , a ) ; } else if ( classtype == short . class ) { copyshort ( result , a ) ; } else if ( classtype == char . class ) { copychar ( result , a ) ; } else if ( classtype == byte . class ) { copybyte ( result , a ) ; } else if ( classtype == boolean . class ) { copyboolean ( result , a ) ; } else copyobject ( result , a ) ; }	Copy array a to array result, the result array will be in canonical orderThe operation type is taken from the type of a.
public static void copyboolean ( array result , array a ) throws illegalargumentexception { if ( ! conformable ( a , result ) ) throw new illegalargumentexception ( str_ ) ; indexiterator itera = a . getindexiterator ( ) ; indexiterator iterr = result . getindexiterator ( ) ; while ( itera . hasnext ( ) ) iterr . setbooleannext ( itera . getbooleannext ( ) ) ; }	copy array a to array result as bytesThe array a and result must be type boolean.
public static void copyobject ( array result , array a ) throws illegalargumentexception { if ( ! conformable ( a , result ) ) throw new illegalargumentexception ( str_ ) ; indexiterator itera = a . getindexiterator ( ) ; indexiterator iterr = result . getindexiterator ( ) ; while ( itera . hasnext ( ) ) { iterr . setobjectnext ( itera . getobjectnext ( ) ) ; } }	copy array a to array result as an ObjectThe array a and result must be type object.
public static mamath . minmax getminmax ( array a ) { indexiterator iter = a . getindexiterator ( ) ; double max = - double . max_value ; double min = double . max_value ; while ( iter . hasnext ( ) ) { double val = iter . getdoublenext ( ) ; if ( double . isnan ( val ) ) continue ; if ( val > max ) max = val ; if ( val < min ) min = val ; } return new minmax ( min , max ) ; }	Find min and max value in this array, getting values as doubles.
public static void setdouble ( array result , double val ) { indexiterator iter = result . getindexiterator ( ) ; while ( iter . hasnext ( ) ) { iter . setdoublenext ( val ) ; } }	Set all the elements of this array to the given double value.The value is converted to the element type of the array, if needed.
public catalogbuilder makecatalogbuilder ( ) { catalogbuilder builder = new catalogbuilder ( this ) ; for ( dataset ds : getdatasetslocal ( ) ) { builder . adddataset ( makedatasetbuilder ( null , ds ) ) ; } return builder ; }	turn ConfigCatalog into a mutable CatalogBuilder so we can mutate.
static public projectionimpl factory ( projection proj ) { if ( proj instanceof projectionimpl ) { return ( projectionimpl ) proj ; } return new projectionadapter ( proj ) ; }	Create a ProjectionImpl from the projection.
public static string unescapedapidentifier ( string id ) { string s ; try { s = unescapestring ( id ) ; } catch ( exception e ) { s = null ; } return s ; }	Define the DEFINITIVE opendap identifier unescape function.
public static string urldecode ( string s ) { try {	Define the DEFINITIVE URL unescape function.
public static string unescapeurl ( string url ) { string newurl ; newurl = urldecode ( url ) ; return newurl ; }	Decode all of the parts of the url including query and fragment.
static public string backslashescape ( string x , string reservedchars ) { if ( x == null ) { return null ; } else if ( reservedchars == null ) { return x ; } boolean ok = bool_ ; for ( int pos = num_ ; pos < x . length ( ) ; pos ++ ) { char c = x . charat ( pos ) ; if ( reservedchars . indexof ( c ) >= num_ ) { ok = bool_ ; break ; } } if ( ok ) return x ;	backslash escape a string.
static public string backslashunescape ( string x ) { if ( ! x . contains ( str_ ) ) return x ;	backslash unescape a string.
public static list < string > tokenizeescapedname ( string escapedname ) { list < string > result = new arraylist < > ( ) ; int pos = num_ ; int start = num_ ; while ( bool_ ) { pos = escapedname . indexof ( sep , pos + num_ ) ; if ( pos <= num_ ) break ; if ( ( pos > num_ ) && escapedname . charat ( pos - num_ ) != str_ ) { result . add ( escapedname . substring ( start , pos ) ) ; start = pos + num_ ; } } result . add ( escapedname . substring ( start , escapedname . length ( ) ) ) ;	Tokenize an escaped name using "." as delimiter, skipping "\.".
public static int indexof ( string escapedname , char c ) { int pos = num_ ; while ( bool_ ) { pos = escapedname . indexof ( c , pos + num_ ) ; if ( pos <= num_ ) return pos ; if ( ( pos > num_ ) && escapedname . charat ( pos - num_ ) != str_ ) return pos ; } }	Find first occurence of char c in escapedName, excluding escaped c.
public static string backslashtodap ( string bs ) { stringbuilder buf = new stringbuilder ( ) ; int len = bs . length ( ) ; for ( int i = num_ ; i < len ; i ++ ) { char c = bs . charat ( i ) ; if ( i < ( len - num_ ) && c == str_ ) { c = bs . charat ( ++ i ) ; } if ( _allowableindap . indexof ( c ) < num_ ) { buf . append ( _uriescape ) ;	Given a backslash escaped name,convert to a DAP escaped name.
protected object readatomicscalar ( varnotes vi , typenotes ti ) throws dapexception { dapvariable atomvar = ( dapvariable ) gettemplate ( ) ;	Read a top-level scalar atomic variable.
static list < nc4cursor > getcursorpath ( nc4cursor cursor ) { list < nc4cursor > path = new arraylist < > ( ) ; for ( ; ; ) { if ( ! cursor . getscheme ( ) . iscompoundarray ( ) )	Given a cursor, get a list of "containing" cursorswith the following constraints.1.
public static object getuidefaultofclass ( class clazz , string property ) { object retval = null ; uidefaults defaults = getuidefaultsofclass ( clazz ) ; list < object > listkeys = collections . list ( defaults . keys ( ) ) ; for ( object key : listkeys ) { if ( key . equals ( property ) ) { return defaults . get ( key ) ; } if ( key . tostring ( ) . equalsignorecase ( property ) ) { retval = defaults . get ( key ) ; } } return retval ; }	Convenience method for retrieving the UIDefault for a single propertyof a particular class.
public static < t extends jcomponent > class getjclass ( t component ) { class < ? > clazz = component . getclass ( ) ; while ( ! clazz . getname ( ) . matches ( str_ ) ) { clazz = clazz . getsuperclass ( ) ; } return clazz ; }	Convenience method to obtain the Swing class from which thiscomponent was directly or indirectly derived.
public void compile ( ) throws dapexception { assert ( this . dataset != null && this . databuffer != null ) ;	The goal here is to process the serializeddatabuffer and locate top-level variable positionsin the serialized databuffer.
protected d4cursor compilestructurearray ( dapvariable var , d4cursor container ) throws dapexception { dapstructure dapstruct = ( dapstructure ) var . getbasetype ( ) ; d4cursor structarray = new d4cursor ( scheme . structarray , this . dsp , var , container ) . setoffset ( getpos ( this . databuffer ) ) ; list < dapdimension > dimset = var . getdimensions ( ) ; long dimproduct = daputil . dimproduct ( dimset ) ; d4cursor [ ] instances = new d4cursor [ ( int ) dimproduct ] ; odometer odom = odometer . factory ( daputil . dimsettoslices ( dimset ) , dimset ) ; while ( odom . hasnext ( ) ) { index index = odom . next ( ) ; d4cursor instance = compilestructure ( var , dapstruct , structarray ) ; instance . setindex ( index ) ; instances [ ( int ) index . index ( ) ] = instance ; } structarray . setelements ( instances ) ; return structarray ; }	Compile a structure array.
protected d4cursor compilestructure ( dapvariable var , dapstructure dapstruct , d4cursor container ) throws dapexception { int pos = getpos ( this . databuffer ) ; d4cursor d4ds = new d4cursor ( scheme . structure , ( d4dsp ) this . dsp , var , container ) . setoffset ( pos ) ; list < dapvariable > dfields = dapstruct . getfields ( ) ; for ( int m = num_ ; m < dfields . size ( ) ; m ++ ) { dapvariable dfield = dfields . get ( m ) ; d4cursor dvfield = compilevar ( dfield , d4ds ) ; d4ds . addfield ( m , dvfield ) ; assert dfield . getparent ( ) != null ; } return d4ds ; }	Compile a structure instance.
protected d4cursor compilesequencearray ( dapvariable var , d4cursor container ) throws dapexception { dapsequence dapseq = ( dapsequence ) var . getbasetype ( ) ; d4cursor seqarray = new d4cursor ( scheme . seqarray , this . dsp , var , container ) . setoffset ( getpos ( this . databuffer ) ) ; list < dapdimension > dimset = var . getdimensions ( ) ; long dimproduct = daputil . dimproduct ( dimset ) ; d4cursor [ ] instances = new d4cursor [ ( int ) dimproduct ] ; odometer odom = odometer . factory ( daputil . dimsettoslices ( dimset ) , dimset ) ; while ( odom . hasnext ( ) ) { index index = odom . next ( ) ; d4cursor instance = compilesequence ( var , dapseq , seqarray ) ; instance . setindex ( index ) ; instances [ ( int ) index . index ( ) ] = instance ; } seqarray . setelements ( instances ) ; return seqarray ; }	Compile a sequence array.
public d4cursor compilesequence ( dapvariable var , dapsequence dapseq , d4cursor container ) throws dapexception { int pos = getpos ( this . databuffer ) ; d4cursor seq = new d4cursor ( scheme . sequence , this . dsp , var , container ) . setoffset ( pos ) ; list < dapvariable > dfields = dapseq . getfields ( ) ;	Compile a sequence as a set of records.
public long readlelong ( ) throws ioexception { readfully ( w , num_ , num_ ) ; return ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) << num_ | ( long ) ( w [ num_ ] & num_ ) ; }	read a long in little endian format.
public field getfield ( string name ) { field fld = flds . get ( name ) ; if ( fld == null ) return null ; return ( fld instanceof fieldresizable ) ? ( ( fieldresizable ) fld ) . getdelegate ( ) : fld ; }	Find the field with the specified name.
public object getfieldvalue ( string name ) { field fld = getfield ( name ) ; if ( fld == null ) throw new illegalargumentexception ( str_ + name ) ; return fld . getvalue ( ) ; }	Get current value of the named field.
public void setfieldvalue ( string name , object value ) { field fld = getfield ( name ) ; if ( fld == null ) throw new illegalargumentexception ( str_ + name ) ; fld . setvalue ( value ) ; }	Set the current value of the named field.
public field addfield ( field fld ) { addfield ( fld , cursorcol , cursorrow , null ) ; cursorrow ++ ; return fld ; }	Add a field created by the user.
public field . checkbox addcheckboxfield ( string fldname , string label , boolean defvalue ) { field . checkbox fld = new field . checkbox ( fldname , label , defvalue , storedata ) ; addfield ( fld ) ; return fld ; }	Add a boolean field as a checkbox.
public field . date adddatefield ( string fldname , string label , date defvalue ) { field . date fld = new field . date ( fldname , label , defvalue , storedata ) ; addfield ( new fieldresizable ( fld , this ) ) ; return fld ; }	Add a field that edits a date.
public field . double adddoublefield ( string fldname , string label , double defvalue ) { field . double fld = new field . double ( fldname , label , defvalue , - num_ , storedata ) ; addfield ( new fieldresizable ( fld , this ) ) ; return fld ; }	Add a field that edits a double.
public field . int addintfield ( string fldname , string label , int defvalue ) { field . int fld = new field . int ( fldname , label , defvalue , storedata ) ; addfield ( new fieldresizable ( fld , this ) ) ; return fld ; }	Add a field that edits an integer.
public field . password addpasswordfield ( string fldname , string label , string defvalue ) { field . password fld = new field . password ( fldname , label , defvalue , storedata ) ; addfield ( new fieldresizable ( fld , this ) ) ; return fld ; }	Add a password text field.
public field . text addtextfield ( string fldname , string label , string defvalue ) { field . text fld = new field . text ( fldname , label , defvalue , storedata ) ; addfield ( new fieldresizable ( fld , this ) ) ; return fld ; }	Add a text field.
public field . textcombo addtextcombofield ( string fldname , string label , java . util . collection defvalues , int nkeep , boolean editable ) { field . textcombo fld = new field . textcombo ( fldname , label , defvalues , nkeep , storedata ) ; addfield ( fld ) ; fld . seteditable ( editable ) ; return fld ; }	Add a text combobox field.
public field . textarea addtextareafield ( string fldname , string label , string def , int nrows ) { field . textarea fld = new field . textarea ( fldname , label , def , nrows , storedata ) ; addfield ( fld ) ; return fld ; }	Add a TextArea field.
public void addheading ( string heading , int row ) { layoutcomponents . add ( new layoutcomponent ( heading , num_ , row , null ) ) ; }	Add a heading at the specified row. this spans all columns.
public void addcomponent ( component comp , int col , int row , string constraint ) { layoutcomponents . add ( new layoutcomponent ( comp , col , row , constraint ) ) ; }	Add a Component.
public void addemptyrow ( int row , int size ) { layoutcomponents . add ( new layoutcomponent ( null , size , row , null ) ) ; }	Add a seperator after the last field added.
static public frame findactiveframe ( ) { frame [ ] frames = jframe . getframes ( ) ; for ( frame frame : frames ) { if ( frame . isvisible ( ) ) return frame ; } return null ; }	thanks to Heinz M. Kabutz.
public float getcellspacing ( ) throws descriptorexception { float [ ] cellranges = mycelv . getcellranges ( ) ;	Get the cell spacing.
public final factor [ ] getfactors ( ) { final factor [ ] factors = new factor [ _factors . length ] ; system . arraycopy ( _factors , num_ , factors , num_ , factors . length ) ; return factors ; }	Returns the array of Factor-s constituting this dimension.
protected factor [ ] mult ( final dimension that ) {	Multiplies this dimension by another dimension.
protected factor [ ] pow ( final int power ) { factor [ ] factors ; if ( power == num_ ) { factors = new factor [ num_ ] ; } else { factors = getfactors ( ) ; if ( power != num_ ) { for ( int i = factors . length ; -- i >= num_ ; ) { factors [ i ] = factors [ i ] . pow ( power ) ; } } } return factors ; }	Raises this dimension to a power.
public final boolean isreciprocalof ( final dimension that ) { final factor [ ] thesefactors = _factors ; final factor [ ] thosefactors = that . _factors ; boolean isreciprocalof ; if ( thesefactors . length != thosefactors . length ) { isreciprocalof = bool_ ; } else { int i ; for ( i = thesefactors . length ; -- i >= num_ ; ) { if ( ! thesefactors [ i ] . isreciprocalof ( thosefactors [ i ] ) ) { break ; } } isreciprocalof = i < num_ ; } return isreciprocalof ; }	Indicates if this Dimension is the reciprocal of another dimension.
public final boolean isdimensionless ( ) { for ( int i = _factors . length ; -- i >= num_ ; ) { if ( ! _factors [ i ] . isdimensionless ( ) ) { return bool_ ; } } return bool_ ; }	Indicates if this dimension is dimensionless.
public static grib1paramtables factory ( string paramtablepath , string lookuptablepath ) throws ioexception { if ( paramtablepath == null && lookuptablepath == null ) return new grib1paramtables ( ) ; lookup lookup = null ; grib1paramtablereader override = null ; grib1paramtablereader table ; if ( paramtablepath != null ) { table = localtablehash . get ( paramtablepath ) ; if ( table == null ) { table = new grib1paramtablereader ( paramtablepath ) ; localtablehash . put ( paramtablepath , table ) ; override = table ; } } if ( lookuptablepath != null ) { lookup = new lookup ( ) ; if ( ! lookup . readlookuptable ( lookuptablepath ) ) throw new filenotfoundexception ( str_ + lookuptablepath ) ; } return new grib1paramtables ( lookup , override ) ; }	Get a Grib1ParamTables object, optionally specifying a parameter table or lookup table specific to this dataset.
public static grib1paramtables factory ( org . jdom2 . element paramtableelem ) { if ( paramtableelem == null ) return new grib1paramtables ( ) ; return new grib1paramtables ( null , new grib1paramtablereader ( paramtableelem ) ) ; }	Get a Grib1Tables object, optionally specifiying a parameter table in XML specific to this dataset.
public static boolean addparametertablelookup ( string lookupfilename ) throws ioexception { lookup lookup = new lookup ( ) ; if ( ! lookup . readlookuptable ( lookupfilename ) ) return bool_ ; synchronized ( lock ) { standardlookup . tables . addall ( standardtablesstart , lookup . tables ) ; standardtablesstart += lookup . tables . size ( ) ; } return bool_ ; }	Add all tables in list to standard tables.
public static void addparametertable ( int center , int subcenter , int tableversion , string tablefilename ) { grib1paramtablereader table = new grib1paramtablereader ( center , subcenter , tableversion , tablefilename ) ; synchronized ( lock ) { standardlookup . tables . add ( standardtablesstart , table ) ; standardtablesstart ++ ; } }	Add table to standard tables for a specific center, subcenter and version.
@ override protected unit myraiseto ( final int power ) throws raiseexception { if ( power == num_ ) { return derivedunitimpl . dimensionless ; } if ( power == num_ ) { return this ; } throw new raiseexception ( this ) ; }	Raise this unit to a power.
public float [ ] toderivedunit ( final float [ ] input , final float [ ] output ) throws conversionexception { for ( int i = input . length ; -- i >= num_ ; ) { output [ i ] = ( float ) ( math . exp ( input [ i ] * lnbase ) ) ; } return reference . toderivedunit ( output , output ) ; }	Converts values in this unit to the equivalent values in the convertiblederived unit.
private static void initunittable ( ) { unittable = new hashtable < > ( ) ;	Initialize the unit table.
private variable makeverticalvariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws ioexception { string vert_unit = null ; string vert_type ; arrayfloat . d1 data = new arrayfloat . d1 ( n_levels ) ; axistype axistype = null ; switch ( vert_sys ) { case ( num_ ) : vert_unit = null ; vert_type = str_ ; break ; case ( num_ ) : case ( num_ ) : vert_unit = str_ ; vert_type = str_ ; axistype = axistype . height ; break ; case ( num_ ) : vert_unit = str_ ; vert_type = str_ ; axistype = axistype . pressure ; break ; default : throw new ioexception ( str_ ) ; } variable vertvar = new variable ( ncfile , null , null , vert_type ) ; vertvar . setdimensions ( level ) ; vertvar . setdatatype ( datatype . float ) ; if ( vert_unit != null ) { vertvar . addattribute ( new attribute ( cdm . units , vert_unit ) ) ; } if ( axistype != null ) { vertvar . addattribute ( new attribute ( _coordinate . axistype , axistype . tostring ( ) ) ) ; } switch ( vert_sys ) { case ( num_ ) : case ( num_ ) : for ( int i = num_ ; i < n_levels ; i ++ ) { data . set ( i , vert_args [ num_ ] + vert_args [ num_ ] * i ) ; } break ; case ( num_ ) :	Create a vertical dimension variable based on the info.
protected static string peekname ( randomaccessfile file ) throws descriptorexception { try { long filepos = file . getfilepointer ( ) ; byte [ ] namebytes = new byte [ num_ ] ; if ( file . read ( namebytes ) == - num_ ) return null ;	Return the name of the DORADE descriptor at the current locationin the file.
protected short grabshort ( byte [ ] bytes , int offset ) { int ndx0 = offset + ( littleendiandata ? num_ : num_ ) ; int ndx1 = offset + ( littleendiandata ? num_ : num_ ) ;	Unpack a two-byte integer from the given byte array.
protected static int grabint ( byte [ ] bytes , int offset , boolean littleendiandata ) { int ndx0 = offset + ( littleendiandata ? num_ : num_ ) ; int ndx1 = offset + ( littleendiandata ? num_ : num_ ) ; int ndx2 = offset + ( littleendiandata ? num_ : num_ ) ; int ndx3 = offset + ( littleendiandata ? num_ : num_ ) ;	Unpack a four-byte integer from the given byte array.
protected float grabfloat ( byte [ ] bytes , int offset ) throws descriptorexception { try { byte [ ] src ; if ( littleendiandata ) { src = new byte [ num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset ] ; offset = num_ ; } else { src = bytes ; } datainputstream stream = new datainputstream ( new bytearrayinputstream ( src , offset , num_ ) ) ; return stream . readfloat ( ) ; } catch ( exception ex ) { throw new descriptorexception ( ex ) ; } }	Unpack a four-byte IEEE float from the given byte array.
protected double grabdouble ( byte [ ] bytes , int offset ) throws descriptorexception { try { byte [ ] src ; if ( littleendiandata ) { src = new byte [ num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset + num_ ] ; src [ num_ ] = bytes [ offset ] ; offset = num_ ; } else { src = bytes ; } datainputstream stream = new datainputstream ( new bytearrayinputstream ( src , offset , num_ ) ) ; return stream . readdouble ( ) ; } catch ( exception ex ) { throw new descriptorexception ( ex ) ; } }	Unpack an eight-byte IEEE float from the given byte array.
private void aa ( final string alias , final string name ) throws unitexistsexception , nosuchunitexception , unitparseexception , specificationexception , unitdbexception , prefixdbexception , operationexception , nameexception , unitsystemexception { aa ( alias , name , null ) ; }	Adds an alias for a unit to the database.
private void as ( final string symbol , final string name ) throws unitexistsexception , nosuchunitexception , unitparseexception , specificationexception , unitdbexception , prefixdbexception , operationexception , nameexception , unitsystemexception { addsymbol ( symbol , name ) ; }	Adds a symbol for a unit to the database.
public static converter create ( unit fromunit , unit tounit ) throws conversionexception { return fromunit . getconverterto ( tounit ) ; }	Factory method for creating a unit converter.
public void setstructuredata ( list < structuredata > structuredata ) throws ioexception { datamodel = new structuredatamodel ( structuredata ) ; inittable ( datamodel ) ; }	Set the data as a collection of StructureData.
public void setpointfeaturedata ( list < pointfeature > obsdata ) throws ioexception { datamodel = new pointfeaturedatamodel ( obsdata ) ; inittable ( datamodel ) ; }	Set the data as a collection of PointFeature.
public void draw ( java . awt . graphics2d g , affinetransform pixelat ) { g . setcolor ( color ) ; g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_off ) ; g . setstroke ( new java . awt . basicstroke ( num_ ) ) ; rectangle2d cliprect = ( rectangle2d ) g . getclip ( ) ; iterator siter = getshapes ( g , pixelat ) ; while ( siter . hasnext ( ) ) { shape s = ( shape ) siter . next ( ) ; rectangle2d shapebounds = s . getbounds2d ( ) ; if ( shapebounds . intersects ( cliprect ) ) g . draw ( s ) ; } }	Draws all the features that are within the graphics clip rectangle,using the previously set displayProjection.
protected iterator getshapes ( java . awt . graphics2d g , affinetransform normal2device ) { if ( shapelist != null ) return shapelist . iterator ( ) ; if ( debug . isset ( str_ ) ) system . out . println ( str_ ) ; projectionimpl dataproject = getdataprojection ( ) ;	get the set of shapes to draw, convert projections if need be.
public void processstream ( inputstream is ) throws ioexception { int pos = - num_ ; buffer b = null ; while ( bool_ ) { b = ( pos < num_ ) ? readbuffer ( is ) : readbuffer ( is , b , pos ) ; pos = processbuffer ( b , is ) ; if ( b . done ) break ; } }	process all the bytes in the stream.
private boolean readbuffer ( inputstream is , byte [ ] dest , int start , int want ) throws ioexception { int done = num_ ; while ( done < want ) { int got = is . read ( dest , start + done , want - done ) ; if ( got < num_ ) return bool_ ; done += got ; } if ( showread ) system . out . println ( str_ + bytesread + str_ + done ) ; bytesread += done ; return bool_ ; }	read into dest byte array, until buffer is full or end of stream.
private void getmorebytes ( ) throws ioexception { currentoffset = num_ ;	Get more bytes into buffer.
public int read ( byte b [ ] , int off , int len ) throws ioexception { if ( len <= num_ ) { return num_ ; } int c = read ( ) ; if ( c == - num_ ) return - num_ ; b [ off ] = ( byte ) c ;	Reads up to len bytes of data from this input stream into an array ofbytes.
public long skip ( long n ) { if ( bytesremaining >= n ) { bytesremaining -= n ; return n ; } else { int oldbytesremaining = bytesremaining ; bytesremaining = num_ ; return oldbytesremaining ; } }	Skips over and discards n bytes of data from the input stream.
void adddimensionstonetcdffile ( netcdffile ncfile , group g ) { if ( ! isvertdimensionused ( ) ) return ; int nlevs = levels . size ( ) ; if ( coordvalues != null ) nlevs = coordvalues . length ; ncfile . adddimension ( g , new dimension ( getvariablename ( ) , nlevs , bool_ ) ) ; }	Add this coord as a dimension to the netCDF file.
private int coordindex ( gridrecord record ) { double val = record . getlevel1 ( ) ; double val2 = record . getlevel2 ( ) ; if ( usesbounds && ( val > val2 ) ) { val = record . getlevel2 ( ) ; val2 = record . getlevel1 ( ) ; } for ( int i = num_ ; i < levels . size ( ) ; i ++ ) { levelcoord lc = ( levelcoord ) levels . get ( i ) ; if ( usesbounds ) { if ( ucar . nc2 . util . misc . nearlyequals ( lc . value1 , val ) && ucar . nc2 . util . misc . nearlyequals ( lc . value2 , val2 ) ) { return i ; } } else { if ( ucar . nc2 . util . misc . nearlyequals ( lc . value1 , val ) ) { return i ; } } } return - num_ ; }	Get the coordinate index for the record.
public boolean isvalidfile ( ucar . unidata . io . randomaccessfile raf ) { nowradheader localheader = new nowradheader ( ) ; return ( localheader . isvalidfile ( raf ) ) ; }	checking the file.
public void open ( ucar . unidata . io . randomaccessfile raf , ucar . nc2 . netcdffile file , ucar . nc2 . util . canceltask canceltask ) throws ioexception { super . open ( raf , ncfile , canceltask ) ; headerparser = new nowradheader ( ) ; try { headerparser . read ( this . raf , ncfile ) ; } catch ( exception e ) { }	Open the file and read the header part.
public array readdata ( variable v2 , section section ) throws ioexception , invalidrangeexception {	Read the data for each variable passed in.
public byte [ ] readonerowdata ( byte [ ] ddata , int rlen , int xt ) throws ioexception , invalidrangeexception { int run ; byte [ ] bdata = new byte [ xt ] ; int nbin = num_ ; int total = num_ ; for ( run = num_ ; run < rlen ; run ++ ) { int drun = datatype . unsignedbytetoshort ( ddata [ run ] ) > > num_ ; byte dcode1 = ( byte ) ( datatype . unsignedbytetoshort ( ddata [ run ] ) & num_ ) ; for ( int i = num_ ; i < drun ; i ++ ) { bdata [ nbin ++ ] = dcode1 ; total ++ ; } } if ( total < xt ) { for ( run = total ; run < xt ; run ++ ) { bdata [ run ] = num_ ; } } return bdata ; }	Read data from encoded values and run len into regular data array.
private void createfromdataset ( netcdfdataset ncd ) {	take advantage of the work already done by NetcdfDataset.
private basetype createvariable ( netcdffile ncfile , variable v ) { basetype bt ; if ( v . getrank ( ) == num_ )	turn Variable into opendap variable.
public void setmaparea ( projectionrect ma ) { if ( debugbb ) system . out . println ( str_ + ma ) ; navigate . setmaparea ( ma ) ; }	Set the Map Area.
public void setmaparea ( latlonrect llbb ) { if ( debugbb ) system . out . println ( str_ + llbb ) ; navigate . setmaparea ( project . latlontoprojbb ( llbb ) ) ; }	Set the Map Area by converting LatLonRect to a ProjectionRect.
public void setlatloncentermaparea ( double lat , double lon ) { projectionpoint center = project . latlontoproj ( lat , lon ) ; projectionrect ma = getmaparea ( ) ; ma . setx ( center . getx ( ) - ma . getwidth ( ) / num_ ) ; ma . sety ( center . gety ( ) - ma . getheight ( ) / num_ ) ; setmaparea ( ma ) ; }	set the center point of the MapArea.
public void setprojectionimpl ( projectionimpl p ) {	Set the Projection, change the Map Area to the projection's default.
public void addactionstomenu ( jmenu menu ) { bamutil . addactiontomenu ( menu , zoomin ) ; bamutil . addactiontomenu ( menu , zoomout ) ; bamutil . addactiontomenu ( menu , zoomback ) ; bamutil . addactiontomenu ( menu , zoomdefault ) ; menu . addseparator ( ) ; bamutil . addactiontomenu ( menu , moveup ) ; bamutil . addactiontomenu ( menu , movedown ) ; bamutil . addactiontomenu ( menu , moveright ) ; bamutil . addactiontomenu ( menu , moveleft ) ; menu . addseparator ( ) ; bamutil . addactiontomenu ( menu , setreferenceaction ) ; }	Add all of the toolbar's actions to a menu.
private void redrawlater ( int delay ) { boolean already = ( redrawtimer != null ) && ( redrawtimer . isrunning ( ) ) ; if ( debugthread ) system . out . println ( str_ + already ) ; if ( already ) return ;	from panning, so wait delay msecs before doing the redraw.
private void newscreensize ( rectangle b ) { boolean samesize = ( b . width == mybounds . width ) && ( b . height == mybounds . height ) ; if ( debugbounds ) system . out . println ( str_ + mybounds ) ; if ( samesize && ( b . x == mybounds . x ) && ( b . y == mybounds . y ) ) return ; mybounds . setbounds ( b ) ; if ( samesize ) return ; if ( debugbounds ) system . out . println ( str_ + b ) ;	when component resizes we need a new buffer.
public void setselected ( variableif v ) { if ( v == null ) { return ; }	Set the currently selected Variable.
public double getdouble ( int offset ) { dapvariable d4var = ( dapvariable ) gettemplate ( ) ; long [ ] dimsizes = daputil . getdimsizes ( d4var . getdimensions ( ) ) ; return getdouble ( daputil . offsettoindex ( offset , dimsizes ) ) ; }	Convert int base to Index based.
protected double getdouble ( dap4 . core . util . index idx ) { assert data . getscheme ( ) == scheme . atomic ; try { object value = data . read ( idx ) ; value = convert . convert ( daptype . float64 , this . basetype , value ) ; return ( double ) java . lang . reflect . array . get ( value , num_ ) ; } catch ( ioexception ioe ) { throw new indexoutofboundsexception ( ioe . getmessage ( ) ) ; } }	Get the array element at a specific dap4 index as a double.
protected object getobject ( dap4 . core . util . index idx ) { assert data . getscheme ( ) == scheme . atomic ; try { object value = data . read ( idx ) ; value = java . lang . reflect . array . get ( value , num_ ) ; return value ; } catch ( ioexception ioe ) { throw new indexoutofboundsexception ( ioe . getmessage ( ) ) ; } }	Get the array element at a specific dap4 index as an Object.
string gini_getsectorid ( int ent_id ) { string name ; switch ( ent_id ) { case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; case num_ : name = str_ ; break ; default : name = str_ ; } return name ; }	Return the string of Sector for the GINI image file.
private double readscaledint ( bytebuffer buf ) {	Read a scaled, 3-byte integer from file and convert to double.
public parameter findparameterignorecase ( string name ) { for ( parameter a : params ) { if ( name . equalsignorecase ( a . getname ( ) ) ) return a ; } return null ; }	Convenience function; look up Parameter by name, ignoring case.
private void swapbyteorder ( ) {	Swap the byte order from the system default.
public int [ ] gettimestepsperfile ( string filename ) { if ( chsubs != null ) { for ( chsub ch : chsubs ) { if ( filename . contains ( ch . substring ) ) { return new int [ ] { ch . numtimes , ch . starttimeindex } ; } } } return new int [ ] { timestepsperfile , num_ } ; }	Get the number of timesteps per file and the starting offset.
public string getfilename ( int eindex , int tindex ) { string datafilepath = datafile ; if ( ( gettemplatetype ( ) == ens_template ) || ( gettemplatetype ( ) == ens_time_template ) ) { datafilepath = getensembledimension ( ) . replacefiletemplate ( datafilepath , eindex ) ; } datafilepath = gettimedimension ( ) . replacefiletemplate ( datafilepath , tindex ) ; if ( ( chsubs != null ) && ( datafilepath . contains ( chsub_template_id ) ) ) { for ( chsub ch : chsubs ) { if ( ( tindex >= ch . starttimeindex ) && ( tindex <= ch . endtimeindex ) ) { datafilepath = datafilepath . replace ( chsub_template_id , ch . substring ) ; break ; } } } return getfullpath ( datafilepath ) ; }	Get the file name for the particular time and ensemble index.
private list < string > getfilenames ( ) throws ioexception { if ( filenames == null ) { filenames = new arraylist < > ( ) ; timestepsperfile = tdim . getsize ( ) ; if ( ! istemplate ( ) ) {	Get the list of filenames.
private string getddfpath ( ) { if ( pathtoddf == null ) { int lastslash = ddfile . lastindexof ( str_ ) ; if ( lastslash < num_ ) { lastslash = ddfile . lastindexof ( file . separator ) ; } pathtoddf = ( lastslash < num_ ) ? str_ : ddfile . substring ( num_ , lastslash + num_ ) ; } return pathtoddf ; }	Get the path to the Data Descriptor File.
private string getfullpath ( string filename ) { string file ; string ddfpath = getddfpath ( ) ; if ( filename . startswith ( str_ ) ) { file = filename . replace ( str_ , str_ ) ; file = ddfpath + file ; } else { file f = new file ( filename ) ; if ( ! f . isabsolute ( ) ) { file = ddfpath + filename ; } else { file = filename ; } } return file ; }	Get the full path for a given filename.
private void addchsub ( chsub sub ) { if ( chsubs == null ) { chsubs = new arraylist < > ( ) ; } chsubs . add ( sub ) ; }	Add a Chsub.
public timecoordintvvalue convertreferencedate ( calendardate refdate , calendarperiod timeunit ) { if ( timeunit == null ) { throw new illegalargumentexception ( str_ ) ; } int startoffset = timeunit . getoffset ( refdate , start ) ;	Calculate the offset in units of timeUnit from the given reference date?.
int readwmo ( ucar . unidata . io . randomaccessfile raf ) throws ioexception { int pos = num_ ;	read the header of input file and parsing the WMO part.
public byte [ ] getuncompdata ( int offset , int len ) { if ( len == num_ ) len = uncompdata . length - offset ; byte [ ] data = new byte [ len ] ; system . arraycopy ( uncompdata , offset , data , num_ , len ) ; return data ; }	read the compressed data.
int pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isz , string structname , int code ) {	construct a dataset for special graphic symbol packet with code 12, 13, and 14.
int pcode_25 ( int [ ] pos , int hoff , int len , boolean isz ) { arraylist dims = new arraylist ( ) ; dimension sdim = new dimension ( str_ , len ) ; ncfile . adddimension ( null , sdim ) ; dims . add ( sdim ) ; structure dist = new structure ( ncfile , null , null , str_ ) ; dist . setdimensions ( dims ) ; ncfile . addvariable ( null , dist ) ; dist . addattribute ( new attribute ( cdm . long_name , str_ ) ) ; variable ii0 = new variable ( ncfile , null , dist , str_ ) ; ii0 . setdimensions ( ( string ) null ) ; ii0 . setdatatype ( datatype . short ) ; dist . addmembervariable ( ii0 ) ; variable ii1 = new variable ( ncfile , null , dist , str_ ) ; ii1 . setdimensions ( ( string ) null ) ; ii1 . setdatatype ( datatype . short ) ; dist . addmembervariable ( ii1 ) ; variable jj0 = new variable ( ncfile , null , dist , str_ ) ; jj0 . setdimensions ( ( string ) null ) ; jj0 . setdatatype ( datatype . short ) ; dist . addmembervariable ( jj0 ) ; int [ ] pos1 = new int [ len ] ; system . arraycopy ( pos , num_ , pos1 , num_ , len ) ; dist . setspobject ( new vinfo ( num_ , num_ , num_ , num_ , hoff , num_ , isr , isz , pos1 , null , num_ , num_ ) ) ; return num_ ; }	construct a dataset for special symbol packet with code 25.
int checkmsgheader ( ucar . unidata . io . randomaccessfile raf ) throws ioexception { int rc ; long actualsize ; int readlen ; actualsize = raf . length ( ) ; int pos = num_ ; raf . seek ( pos ) ;	check level III file header.
int pcode_5 ( int [ ] pos , int hoff , int len , boolean isz ) { arraylist dims = new arraylist ( ) ;	construct a dataset for vector arrow data packet with code 5.
int pcode_128 ( int [ ] pos , int [ ] size , int code , int hoff , int len , string structname , string abbre , boolean isz ) {	construct a dataset for text and special symbol packets with code 1, 2, and 8.
public int [ ] getlevels ( int nlevel , short [ ] th ) { int [ ] levels = new int [ nlevel ] ; int ival ; int isign ; for ( int i = num_ ; i < nlevel ; i ++ ) { ival = convertshort2unsignedint ( th [ i ] ) ; if ( ( ival & num_ ) == num_ ) { isign = - num_ ; if ( ( ival & num_ ) == num_ ) isign = num_ ; levels [ i ] = isign * ( ival & num_ ) ; } else { levels [ i ] = - num_ + ( ival & num_ ) ; } } return levels ; }	get the table to calibrate data value.
public int [ ] getdualpollevels ( short [ ] th ) { int inc = th . length ; int [ ] levels = new int [ inc ] ;	get the calibrate data values for dualpol data.
void addvariable ( string pname , string longname , netcdffile nc , arraylist dims , string coordinates , datatype dtype , string ut , long hoff , long hedsiz , boolean isz , int nlevel , int [ ] levels , int iscale ) { variable v = new variable ( nc , null , null , pname ) ; v . setdatatype ( dtype ) ; v . setdimensions ( dims ) ; ncfile . addvariable ( null , v ) ; v . addattribute ( new attribute ( cdm . long_name , longname ) ) ; v . addattribute ( new attribute ( cdm . units , ut ) ) ; v . addattribute ( new attribute ( _coordinate . axes , coordinates ) ) ; v . setspobject ( new vinfo ( numx , numx0 , numy , numy0 , hoff , hedsiz , isr , isz , null , levels , iscale , nlevel ) ) ; }	adding new variable to the netcdf file.
void addparameter ( string pname , string longname , netcdffile nc , arraylist dims , attribute att , datatype dtype , string ut , long hoff , long doff , boolean isz , int y0 ) { string vname = pname ; variable vvar = new variable ( nc , null , null , vname ) ; vvar . setdatatype ( dtype ) ; if ( dims != null ) vvar . setdimensions ( dims ) ; else vvar . setdimensions ( str_ ) ; if ( att != null ) vvar . addattribute ( att ) ; vvar . addattribute ( new attribute ( cdm . units , ut ) ) ; vvar . addattribute ( new attribute ( cdm . long_name , longname ) ) ; nc . addvariable ( null , vvar ) ; vvar . setspobject ( new vinfo ( numx , numx0 , numy , y0 , hoff , doff , isr , isz , null , null , num_ , num_ ) ) ; }	adding new parameter to the netcdf file.
byte [ ] uncompressed ( bytebuffer buf , int offset , int uncomplen ) throws ioexception { byte [ ] header = new byte [ offset ] ; buf . position ( num_ ) ; buf . get ( header ) ; byte [ ] out = new byte [ offset + uncomplen ] ; system . arraycopy ( header , num_ , out , num_ , offset ) ; cbzip2inputstream cbzip2 = new cbzip2inputstream ( ) ; int numcompbytes = buf . remaining ( ) ; byte [ ] bufc = new byte [ numcompbytes ] ; buf . get ( bufc , num_ , numcompbytes ) ; bytearrayinputstream bis = new bytearrayinputstream ( bufc , num_ , numcompbytes - num_ ) ;	uncompress the TDWR products.
int getuint ( byte [ ] b , int num ) { int base = num_ ; int i ; int word = num_ ; int bv [ ] = new int [ num ] ; for ( i = num_ ; i < num ; i ++ ) { bv [ i ] = convertunsignedbyte2short ( b [ i ] ) ; } for ( i = num - num_ ; i >= num_ ; i -- ) { word += base * bv [ i ] ; base *= num_ ; } return word ; }	get unsigned integer from byte array.
int getint ( byte [ ] b , int num ) { int base = num_ ; int i ; int word = num_ ; int bv [ ] = new int [ num ] ; for ( i = num_ ; i < num ; i ++ ) { bv [ i ] = convertunsignedbyte2short ( b [ i ] ) ; } if ( bv [ num_ ] > num_ ) { bv [ num_ ] -= num_ ; base = - num_ ; } for ( i = num - num_ ; i >= num_ ; i -- ) { word += base * bv [ i ] ; base *= num_ ; } return word ; }	get signed integer from bytes.
protected object convert ( byte [ ] barray , datatype datatype , int nelems , int byteorder ) { if ( datatype == datatype . byte ) { return barray ; } if ( datatype == datatype . char ) { return iosphelper . convertbytetochar ( barray ) ; } bytebuffer bbuff = bytebuffer . wrap ( barray ) ; if ( byteorder >= num_ ) bbuff . order ( byteorder == ucar . unidata . io . randomaccessfile . little_endian ? byteorder . little_endian : byteorder . big_endian ) ; if ( datatype == datatype . short ) { shortbuffer tbuff = bbuff . asshortbuffer ( ) ; short [ ] pa = new short [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( datatype == datatype . int ) { intbuffer tbuff = bbuff . asintbuffer ( ) ; int [ ] pa = new int [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( datatype == datatype . float ) { floatbuffer tbuff = bbuff . asfloatbuffer ( ) ; float [ ] pa = new float [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( datatype == datatype . double ) { doublebuffer tbuff = bbuff . asdoublebuffer ( ) ; double [ ] pa = new double [ nelems ] ; tbuff . get ( pa ) ; return pa ; } throw new illegalstateexception ( ) ; }	this converts a byte array to another primitive array.
protected void dodmr ( daprequest drq , dapcontext cxt ) throws ioexception {	Process a DMR request.
protected daprequest getrequeststate ( httpservletrequest rq , httpservletresponse rsp ) throws ioexception { return new daprequest ( this , rq , rsp ) ; }	Merge the servlet inputs into a single objectfor easier transport as well as adding value.
protected void senderror ( daprequest drq , int httpcode , throwable t ) throws ioexception { if ( httpcode == num_ ) httpcode = httpservletresponse . sc_bad_request ; errorresponse err = new errorresponse ( ) ; err . setcode ( httpcode ) ; if ( t == null ) { err . setmessage ( str_ + drq . geturl ( ) ) ; } else { stringwriter sw = new stringwriter ( ) ; printwriter p = new printwriter ( sw ) ; t . printstacktrace ( p ) ; p . close ( ) ; sw . close ( ) ; err . setmessage ( sw . tostring ( ) ) ; } err . setcontext ( drq . geturl ( ) ) ; string errormsg = err . buildxml ( ) ; drq . getresponse ( ) . senderror ( httpcode , errormsg ) ; }	Generate an error based on the parameters.
public boolean anchor ( point p ) { firststretch = bool_ ; anchorpt . x = p . x ; anchorpt . y = p . y ; stretchedpt . x = lastpt . x = anchorpt . x ; stretchedpt . y = lastpt . y = anchorpt . y ; return bool_ ; }	Set the anchor point.
public void stretch ( point p ) { lastpt . x = stretchedpt . x ; lastpt . y = stretchedpt . y ; stretchedpt . x = p . x ; stretchedpt . y = p . y ; graphics2d g = ( graphics2d ) component . getgraphics ( ) ; if ( g != null ) { try { g . setxormode ( component . getbackground ( ) ) ; if ( firststretch == bool_ ) firststretch = bool_ ; else drawlast ( g ) ; drawnext ( g ) ; } finally { g . dispose ( ) ; }	Erase the last rectangle and draw a new one from the anchor point to this point.
private date dateonlyformat ( string text ) throws java . text . parseexception { text = ( text == null ) ? str_ : text . trim ( ) ; dateonlyformat ( ) ; return dateonlyformat . parse ( text ) ; }	Parse text in the format "yyyy-MM-dd".
protected void replacedatavars ( structuremembers sm ) { for ( structuremembers . member m : sm . getmembers ( ) ) { variablesimpleif org = this . cols . get ( m . getname ( ) ) ; int rank = org . getrank ( ) ; list < dimension > orgdims = org . getdimensions ( ) ;	change shape of the data variables.
public static void ensurearraysizeokay ( long tsize , string attributeto ) { if ( tsize >= integer . max_value ) throw new runtimeexception ( memorytoomuchdata + str_ + messageformat . format ( memoryarraysize , str_ + tsize , str_ + integer . max_value ) + ( attributeto == null || attributeto . length ( ) == num_ ? str_ : str_ + attributeto + str_ ) ) ; }	Even if JavaBits is 64, the limit on an array size is Integer.MAX_VALUE.
public static int int2 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; return int2 ( a , b ) ; }	Convert 2 bytes into a signed integer.
public static int uint ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; return ( int ) datatype . unsignedbytetoshort ( ( byte ) a ) ; }	Convert unsigned bytes into an integer.
public static int int3 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; return int3 ( a , b , c ) ; }	Convert 3 bytes into a signed integer.
public static int uint2 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; return uint2 ( a , b ) ; }	Convert 2 bytes into an unsigned integer.
public static int uint3 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; return uint3 ( a , b , c ) ; }	Convert 3 bytes into an unsigned integer.
public static float float4 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; return float4 ( a , b , c , d ) ; }	Convert 4 bytes into a float value.
public static float float4 ( int a , int b , int c , int d ) { int sgn , mant , exp ; mant = b << num_ | c << num_ | d ; if ( mant == num_ ) { return num_ ; } sgn = - ( ( ( a & num_ ) > > num_ ) - num_ ) ; exp = ( a & num_ ) - num_ ; return ( float ) ( sgn * math . pow ( num_ , exp - num_ ) * mant ) ; }	Convert 4 bytes to a float.
public static long int8 ( randomaccessfile raf ) throws ioexception { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; int e = raf . read ( ) ; int f = raf . read ( ) ; int g = raf . read ( ) ; int h = raf . read ( ) ; return ( num_ - ( ( a & num_ ) > > num_ ) ) * ( ( long ) ( a & num_ ) << num_ | ( long ) b << num_ | ( long ) c << num_ | ( long ) d << num_ | e << num_ | f << num_ | g << num_ | h ) ; }	Convert 8 bytes into a signed long.
public static int countbits ( byte [ ] bitmap ) { int bits = num_ ; for ( byte b : bitmap ) { short s = datatype . unsignedbytetoshort ( b ) ; bits += long . bitcount ( s ) ; } return bits ; }	count number of bits on in bitmap.
@ override public projectionimpl constructcopy ( ) { projectionimpl result = new lambertconformal ( getoriginlat ( ) , getoriginlon ( ) , getparallelone ( ) , getparalleltwo ( ) , getfalseeasting ( ) , getfalsenorthing ( ) , earth_radius ) ; result . setdefaultmaparea ( defaultmaparea ) ; result . setname ( name ) ; return result ; }	lon naught ??.
public string towks ( ) { stringbuilder sbuff = new stringbuilder ( ) ; sbuff . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; if ( bool_ ) { sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; } else { sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; } sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; sbuff . append ( str_ ) ; sbuff . append ( str_ ) . append ( getoriginlat ( ) ) . append ( str_ ) ;	Create a WKS string.
static public string entityescape ( string s , string wrt ) { if ( wrt == null ) wrt = entityescapes ; stringbuilder escaped = new stringbuilder ( ) ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; int index = wrt . indexof ( c ) ; if ( index < num_ ) escaped . append ( c ) ; else switch ( c ) { case str_ : escaped . append ( str_ + entity_amp + str_ ) ; break ; case str_ : escaped . append ( str_ + entity_lt + str_ ) ; break ; case str_ : escaped . append ( str_ + entity_gt + str_ ) ; break ; case str_ : escaped . append ( str_ + entity_quot + str_ ) ; break ; case str_ : escaped . append ( str_ + entity_apos + str_ ) ; break ; case str_ : case str_ : case str_ : escaped . append ( c ) ;	Escape selected characters in a string using XML entities.
static public string backslashunescape ( string s ) { stringbuilder clear = new stringbuilder ( ) ; for ( int i = num_ ; i < s . length ( ) ; ) { char c = s . charat ( i ++ ) ; if ( c == str_ ) { c = s . charat ( i ++ ) ; switch ( c ) { case str_ : c = str_ ; break ; case str_ : c = str_ ; break ; case str_ : c = str_ ; break ; case str_ : c = str_ ; break ; default : break ; } clear . append ( c ) ; } else clear . append ( c ) ; } return clear . tostring ( ) ; }	Remove backslashed characters in a string.
static public list < string > backslashsplit ( string s , char sep ) { list < string > path = new arraylist < string > ( ) ; int len = s . length ( ) ; stringbuilder piece = new stringbuilder ( ) ; int i = num_ ; for ( ; i <= len - num_ ; i ++ ) { char c = s . charat ( i ) ; if ( c == str_ && i < ( len - num_ ) ) { piece . append ( c ) ;	Split a string with respect to a separatorcharacter and taking backslashes into consideration.
private fmrcinv makefmrcinv ( formatter debug ) throws ioexception { try { map < calendardate , fmrinv > fmrmap = new hashmap < > ( ) ;	scan has been done, create FmrcInv.
static public string getservicespecial ( string path ) { string ss = null ; if ( path . startswith ( str_ ) ) ss = str_ ; else if ( path . startswith ( str_ ) ) ss = str_ ; return ss ; }	the ones that dont start with thredds.
public int projectedcomponents ( boolean constrained ) { int comp ; if ( constrained ) { comp = ( ( darray ) arrayvar ) . isproject ( ) ? num_ : num_ ; enumeration e = mapvars . elements ( ) ; while ( e . hasmoreelements ( ) ) { if ( ( ( darray ) e . nextelement ( ) ) . isproject ( ) ) comp ++ ; } } else { comp = num_ + mapvars . size ( ) ; } return comp ; }	How many prohected components of this Grid object?.
public final calendardate getreferencetime ( ) { int sec = ( second < num_ || second > num_ ) ? num_ : second ; return calendardate . of ( null , year , month , day , hour , minute , sec ) ; }	return record header time as a CalendarDate.
static public arraystructurebb factory ( arraystructurebb org , section section ) { if ( section == null || section . computesize ( ) == org . getsize ( ) ) return org ; return new arraystructurebbsection ( org . getstructuremembers ( ) , org . getshape ( ) , org . getbytebuffer ( ) , section ) ; }	Make a section of an ArrayStructureBB.
public static void main1 ( string [ ] args ) { if ( index_dir . exists ( ) ) { system . out . println ( str_ + index_dir + str_ ) ; system . exit ( num_ ) ; } luceneindexer indexer = new luceneindexer ( ) ; date start = new date ( ) ; try { indexwriter writer = new indexwriter ( index_dir , new standardanalyzer ( ) , bool_ ) ; system . out . println ( str_ + index_dir + str_ ) ; indexer . indexdocs ( writer , doc_dir ) ; system . out . println ( str_ ) ; writer . optimize ( ) ; writer . close ( ) ; date end = new date ( ) ; system . out . println ( end . gettime ( ) - start . gettime ( ) + str_ ) ; } catch ( ioexception e ) { system . out . println ( str_ + e . getclass ( ) + str_ + e . getmessage ( ) ) ; } }	Index all text files under a directory.
private grib1record readrecord ( grib1indexproto . grib1record p ) { grib1sectionindicator is = new grib1sectionindicator ( p . getgribmessagestart ( ) , p . getgribmessagelength ( ) ) ; grib1sectionproductdefinition pds = new grib1sectionproductdefinition ( p . getpds ( ) . tobytearray ( ) ) ; grib1sectiongriddefinition gds = pds . gdsexists ( ) ? gdslist . get ( p . getgdsidx ( ) ) : new grib1sectiongriddefinition ( pds ) ; grib1sectionbitmap bms = pds . bmsexists ( ) ? new grib1sectionbitmap ( p . getbmspos ( ) ) : null ; grib1sectionbinarydata datasection = new grib1sectionbinarydata ( p . getdatapos ( ) , p . getdatalen ( ) ) ; return new grib1record ( p . getheader ( ) . tobytearray ( ) , is , gds , pds , bms , datasection ) ; }	deserialize the Grib1Record object.
public static boolean ismine ( netcdffile ncfile ) { return ( null != ncfile . findglobalattribute ( str_ ) ) && ( null != ncfile . findglobalattribute ( str_ ) ) && ( null != ncfile . findglobalattribute ( str_ ) ) && ( null != ncfile . findglobalattribute ( str_ ) ) && ( null != ncfile . findglobalattribute ( str_ ) ) && ( null != ncfile . findglobalattribute ( str_ ) ) ;	Do we think this is a M3IO file.
private coordinatetransform makeutmprojection ( netcdfdataset ds ) { int zone = ( int ) findattributedouble ( ds , str_ ) ; double ycent = findattributedouble ( ds , str_ ) ;	Intend to use EPSG system parameters.
public void reacquire ( ) throws ioexception { try { areareader . af = new areafile ( location ) ; } catch ( throwable e ) { throw new ioexception ( e ) ; } }	reacquire any resources like file handles.
public boolean before ( date d ) { if ( ispresent ( ) ) return bool_ ; return date . isbefore ( calendardate . of ( d ) ) ; }	Is this date before the given date.
public boolean before ( datetype d ) { if ( d . ispresent ( ) ) return bool_ ; if ( ispresent ( ) ) return bool_ ; return date . isbefore ( d . getcalendardate ( ) ) ; }	Is this date before the given date.
public boolean after ( date d ) { if ( ispresent ( ) ) return bool_ ; return date . isafter ( calendardate . of ( d ) ) ; }	Is this date after the given date.
public final void setvalue ( int i , basetype newval ) { vals [ i ] = newval ; basetype parent = ( basetype ) gettemplate ( ) . getparent ( ) ; vals [ i ] . setparent ( parent ) ; }	Set the i'th value of the array.
public void addcoordinatesystem ( coordinatesystem cs ) { if ( cs == null ) throw new runtimeexception ( str_ + forvar . getfullname ( ) ) ; if ( coordsys == null ) coordsys = new arraylist < > ( num_ ) ; coordsys . add ( cs ) ; }	Add a CoordinateSystem to the dataset.
public void setunitsstring ( string units ) { this . units = units ; forvar . addattribute ( new attribute ( cdm . units , units ) ) ; }	Set the Unit String for this Variable.
public string getunitsstring ( ) { string result = units ; if ( ( result == null ) && ( forvar != null ) ) { attribute att = forvar . findattribute ( cdm . units ) ; if ( att == null ) att = forvar . findattributeignorecase ( cdm . units ) ; if ( ( att != null ) && att . isstring ( ) ) result = att . getstringvalue ( ) ; } return ( result == null ) ? null : result . trim ( ) ; }	Get the Unit String for the Variable.
public synchronized void init ( readmode readmode , preferencesext prefs ) { if ( readmode == null ) readmode = defaultreadmode ; this . prefs = prefs ; trackernumber = prefs . getlong ( str_ , num_ ) ; numbercatalogs = prefs . getint ( str_ , num_ ) ; nextcatid = prefs . getlong ( str_ , num_ ) ; makedebugactions ( ) ; this . contentrootpath = this . tdscontext . getthreddsdirectory ( ) ; this . contextpath = tdscontext . getcontextpath ( ) ; reread ( readmode , bool_ ) ; }	called from TdsInit on spring-managed auto-wired bean.
private configcatalog readcatalog ( string catalogrelpath , string catalogfullpath ) { uri uri ; try {	Does the actual work of reading a catalog.
private void processdatasets ( long catid , readmode readmode , string dirpath , list < dataset > datasets , set < string > idmap ) throws ioexception { if ( exceedlimit ) return ; for ( dataset ds : datasets ) { if ( datasettracker . trackdataset ( catid , ds , callback ) ) countdatasets ++ ; if ( maxdatasetsprocess > num_ && countdatasets > maxdatasetsprocess ) exceedlimit = bool_ ;	dirPath = the directory path, reletive to the rootDir.
private void readcatsindirectory ( readmode readmode , string dirpath , path directory ) throws ioexception { if ( exceedlimit ) return ;	dirPath is the directory relative to rootDir, directory is absolute.
static public boolean betweenlon ( double lon , double lonbeg , double lonend ) { lonbeg = lonnormal ( lonbeg , lon ) ; lonend = lonnormal ( lonend , lon ) ; return ( lon >= lonbeg ) && ( lon <= lonend ) ; }	Test if point lies between two longitudes, deal with wrapping.
static public string lattostring ( double lat , int ndec ) { boolean is_north = ( lat >= num_ ) ; if ( ! is_north ) lat = - lat ; string f = str_ + ndec + str_ ; formatter latbuff = new formatter ( ) ; latbuff . format ( f , lat ) ; latbuff . format ( str_ , is_north ? str_ : str_ ) ; return latbuff . tostring ( ) ; }	Make a nicely formatted representation of a latitude, eg 40.34N or 12.9S.
static public string lontostring ( double lon , int ndec ) { double wlon = lonnormal ( lon ) ; boolean is_east = ( wlon >= num_ ) ; if ( ! is_east ) wlon = - wlon ; string f = str_ + ndec + str_ ; formatter latbuff = new formatter ( ) ; latbuff . format ( f , wlon ) ; latbuff . format ( str_ , is_east ? str_ : str_ ) ; return latbuff . tostring ( ) ; }	Make a nicely formatted representation of a longitude, eg 120.3W or 99.99E.
public int compareto ( final basequantity that ) { int comp ; if ( this == that ) { comp = num_ ; } else { comp = getname ( ) . comparetoignorecase ( that . getname ( ) ) ; if ( comp == num_ && getsymbol ( ) != null ) { comp = getsymbol ( ) . compareto ( that . getsymbol ( ) ) ; } } return comp ; }	Compares this base quantity to another base quantity.
public datasetnode getselecteddataset ( ) { invcatalogtreenode tnode = getselectednode ( ) ; return tnode == null ? null : tnode . ds ; }	Get the currently selected InvDataset.
public void setselecteddataset ( dataset ds ) { if ( ds == null ) return ; treepath path = makepath ( ds ) ; if ( path == null ) return ; tree . setselectionpath ( path ) ; tree . scrollpathtovisible ( path ) ; }	Set the currently selected InvDataset.
treepath maketreepath ( treenode node ) { arraylist < treenode > path = new arraylist < > ( ) ; path . add ( node ) ; treenode parent = node . getparent ( ) ; while ( parent != null ) { path . add ( num_ , parent ) ; parent = parent . getparent ( ) ; } object [ ] paths = path . toarray ( ) ; return new treepath ( paths ) ; }	Create the TreePath corresponding to the given TreeNode.
public void openall ( boolean includecatref ) { if ( catalog == null ) return ; open ( ( invcatalogtreenode ) model . getroot ( ) , includecatref ) ; tree . repaint ( ) ; }	Open all nodes of the tree.
public void setcatalog ( string location ) { catalogbuilder builder = new catalogbuilder ( ) ; try { catalog cat = builder . buildfromlocation ( location , null ) ; setcatalog ( cat ) ; } catch ( exception ioe ) { joptionpane . showmessagedialog ( this , str_ + location + str_ + builder . geterrormessage ( ) ) ; } }	Set the InvCatalog to display.The catalog is read asynchronously and displayed if successfully read.You must use a PropertyChangeEventListener to be notified if successful.
public void setcatalog ( catalog catalog ) { if ( catalog == null ) return ; string catalogname = catalog . getbaseuri ( ) . tostring ( ) ; this . catalog = catalog ;	Set the catalog to be displayed.
private string findalias ( netcdfdataset ds , variable v ) { string alias = ds . findattvalueignorecase ( v , str_ , null ) ; if ( alias == null ) alias = ds . findattvalueignorecase ( v , str_ , str_ ) ; return alias ; }	look for an coord_axis or coord_alias attribute.
public int writevint ( int i ) throws ioexception { int count = num_ ; while ( ( i & ~ num_ ) != num_ ) { writebyte ( ( byte ) ( ( i & num_ ) | num_ ) ) ; i >>>= num_ ; count ++ ; } writebyte ( ( byte ) i ) ; return count + num_ ; }	Writes an int in a variable-length format.
public int writechars ( string s , int start , int length ) throws ioexception { final int end = start + length ; int count = num_ ; for ( int i = start ; i < end ; i ++ ) { final int code = ( int ) s . charat ( i ) ; if ( code >= num_ && code <= num_ ) { writebyte ( ( byte ) code ) ; count ++ ; } else if ( ( ( code >= num_ ) && ( code <= num_ ) ) || code == num_ ) { writebyte ( ( byte ) ( num_ | ( code > > num_ ) ) ) ; writebyte ( ( byte ) ( num_ | ( code & num_ ) ) ) ; count += num_ ; } else { writebyte ( ( byte ) ( num_ | ( code > > > num_ ) ) ) ; writebyte ( ( byte ) ( num_ | ( ( code > > num_ ) & num_ ) ) ) ; writebyte ( ( byte ) ( num_ | ( code & num_ ) ) ) ; count += num_ ; } } return count ; }	Writes a sequence of UTF-8 encoded characters from a string.
public void readchars ( char [ ] buffer , int start , int length ) throws ioexception { final int end = start + length ; for ( int i = start ; i < end ; i ++ ) { byte b = readbyte ( ) ; if ( ( b & num_ ) == num_ ) buffer [ i ] = ( char ) ( b & num_ ) ; else if ( ( b & num_ ) != num_ ) { buffer [ i ] = ( char ) ( ( ( b & num_ ) << num_ ) | ( readbyte ( ) & num_ ) ) ; } else buffer [ i ] = ( char ) ( ( ( b & num_ ) << num_ ) | ( ( readbyte ( ) & num_ ) << num_ ) | ( readbyte ( ) & num_ ) ) ; } }	Reads UTF-8 encoded characters into an array.
public static void setdebugflags ( ucar . nc2 . util . debugflags debugflag ) { debugread = debugflag . isset ( str_ ) ; debugindexonly = debugflag . isset ( str_ ) ; debugindexonlyshow = debugflag . isset ( str_ ) ; debuggbxindexonly = debugflag . isset ( str_ ) ; }	we are running with only ncx index files, no data.
public void addmember ( member m ) { members . add ( m ) ; if ( memberhash != null ) memberhash . put ( m . getname ( ) , m ) ; }	Add a member.
public int hidemember ( member m ) { if ( m == null ) return - num_ ; int index = members . indexof ( m ) ; members . remove ( m ) ; if ( memberhash != null ) memberhash . remove ( m . getname ( ) ) ; return index ; }	Remove the given member.
public java . util . list < string > getmembernames ( ) { list < string > membernames = new arraylist < > ( ) ; for ( member m : members ) { membernames . add ( m . getname ( ) ) ; } return membernames ; }	Get the names of the members.
public member findmember ( string membername ) { if ( membername == null ) return null ; if ( memberhash == null ) {	Find the member by its name.
@ nullable public byte [ ] getbitmap ( randomaccessfile raf ) throws ioexception { if ( startingposition <= num_ ) { throw new illegalstateexception ( str_ ) ; } raf . seek ( startingposition ) ;	Read the bitmap array when needed, return null if none.
public void restorestate ( preferencesext store ) { if ( store == null ) return ; int ncols = table . getcolumncount ( ) ;	Set the state from the last saved in the PreferencesExt.
public iterator getselectedrows ( ) { treepath [ ] paths = table . getselectionpaths ( ) ; if ( ( paths == null ) || ( paths . length < num_ ) ) return null ; hashset set = new hashset ( num_ * paths . length ) ; for ( treepath path : paths ) { model . addrowstosetfrompath ( table . gettree ( ) , path , set ) ; } return set . iterator ( ) ; }	Get the currently selected rows.
public int [ ] getmodelindex ( ) { int [ ] modelindex = new int [ model . getcolumncount ( ) ] ; try { tablecolumnmodel tcm = table . getcolumnmodel ( ) ; for ( int i = num_ ; i < model . getcolumncount ( ) ; i ++ ) { tablecolumn tc = tcm . getcolumn ( i ) ; modelindex [ i ] = tc . getmodelindex ( ) ; } } catch ( java . lang . arrayindexoutofboundsexception e ) {	this array translates the column index to the model index.
public array getarray ( structuremembers . member m ) { if ( m == null ) throw new illegalargumentexception ( str_ ) ; return memberdata . get ( m ) ; }	Get member data array of any type as an Array.
public double getscalardouble ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getdouble ( index . scalarindeximmutable ) ; }	Get member data of type double.
public double [ ] getjavaarraydouble ( structuremembers . member m ) { array data = getarray ( m ) ; return ( double [ ] ) data . getstorage ( ) ; }	Get java double array for a member of type double.
public float getscalarfloat ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getfloat ( index . scalarindeximmutable ) ; }	Get member data of type float.
public float [ ] getjavaarrayfloat ( structuremembers . member m ) { array data = getarray ( m ) ; return ( float [ ] ) data . getstorage ( ) ; }	Get java float array for a member of type float.
public byte getscalarbyte ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getbyte ( index . scalarindeximmutable ) ; }	Get member data of type byte.
public byte [ ] getjavaarraybyte ( structuremembers . member m ) { array data = getarray ( m ) ; return ( byte [ ] ) data . getstorage ( ) ; }	Get java byte array for a member of type byte.
public int getscalarint ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getint ( index . scalarindeximmutable ) ; }	Get member data of type int.
public int [ ] getjavaarrayint ( structuremembers . member m ) { array data = getarray ( m ) ; return ( int [ ] ) data . getstorage ( ) ; }	Get java int array for a member of type int.
public short getscalarshort ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getshort ( index . scalarindeximmutable ) ; }	Get member data of type short.
public short [ ] getjavaarrayshort ( structuremembers . member m ) { array data = getarray ( m ) ; return ( short [ ] ) data . getstorage ( ) ; }	Get java short array for a member of type short.
public long getscalarlong ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getlong ( index . scalarindeximmutable ) ; }	Get member data of type long.
public long [ ] getjavaarraylong ( structuremembers . member m ) { array data = getarray ( m ) ; return ( long [ ] ) data . getstorage ( ) ; }	Get java long array for a member of type long.
public char getscalarchar ( structuremembers . member m ) { array data = getarray ( m ) ; return data . getchar ( index . scalarindeximmutable ) ; }	Get member data of type char.
public char [ ] getjavaarraychar ( structuremembers . member m ) { array data = getarray ( m ) ; return ( char [ ] ) data . getstorage ( ) ; }	Get java char array for a member of type char.
public void doonedataset ( invdataset ds ) { if ( debug ) system . out . println ( str_ + ds . getname ( ) ) ; if ( isdatasetuseable ( ds , messbuffer ) ) { string id = stringutil2 . replace ( ds . getid ( ) , str_ , str_ ) ; string fileoutname = filedir + str_ + id + str_ ; try { outputstream out = new bufferedoutputstream ( new fileoutputstream ( fileoutname ) ) ;	Write a DIF record for a specific dataset.
public dataset copydataset ( datasetnode parent ) { return new dataset ( parent , name , flds , accessbuilders , datasetbuilders ) ; }	make an immutable copy without changin DatasetBuilder.
public void transfermetadata ( datasetnode from , boolean parentsalso ) { if ( parentsalso ) { threddsmetadata inherit = getinheritablemetadata ( ) ;	transfer all metadata, optionally also inheritable metadata from parents.
public threddsmetadata getinheritablemetadata ( ) { threddsmetadata tmi = ( threddsmetadata ) get ( dataset . threddsmetadatainheritable ) ; if ( tmi == null ) { tmi = new threddsmetadata ( ) ; put ( dataset . threddsmetadatainheritable , tmi ) ; } return tmi ; }	get the inheritable ThreddsMetadata object. If doesnt exist, create new, empty one.
void addproduct ( gridrecord record ) { records . add ( record ) ; if ( firstrecord == null ) { firstrecord = record ; } }	Add in a new product.
public void showmissing ( formatter f ) {	Dump out the missing data.
public int showmissingsummary ( formatter f ) { int count = num_ ; int total = recordtracker . length ; for ( int i = num_ ; i < total ; i ++ ) { if ( recordtracker [ i ] == null ) count ++ ; } f . format ( str_ , count , total , name ) ; return count ; }	Dump out the missing data as a summary.
public gridrecord findrecord ( int ens , int time , int level ) { if ( hasensemble ( ) ) { return recordtracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; } else { return recordtracker [ time * nlevels + level ] ; } }	Find the grid record for the time and level indicesCanonical ordering is ens, time, level.
public string dump ( ) { dateformatter formatter = new dateformatter ( ) ; formatter sbuff = new formatter ( ) ; sbuff . format ( str_ , name , records . size ( ) ) ; for ( gridrecord record : records ) { sbuff . format ( str_ , record . getleveltype1 ( ) , record . getlevel1 ( ) ) ; if ( null != record . getvalidtime ( ) ) sbuff . format ( str_ , formatter . todatetimestring ( record . getvalidtime ( ) ) ) ; sbuff . format ( str_ ) ; } return sbuff . tostring ( ) ; }	Dump this variable.
protected string makelongname ( ) { formatter f = new formatter ( ) ; gridparameter param = lookup . getparameter ( firstrecord ) ; if ( param == null ) return null ; f . format ( str_ , param . getdescription ( ) ) ; string levelname = makelevelname ( firstrecord , lookup ) ; if ( levelname . length ( ) != num_ ) f . format ( str_ , levelname ) ; return f . tostring ( ) ; }	Make a long name for the variable.
public optional < coveragecoordaxis > subsetbyintervals ( list < mamath . minmax > lonintvs , int stride ) { if ( axistype != axistype . lon ) return optional . empty ( str_ ) ; if ( ! isregular ( ) ) return optional . empty ( str_ ) ; coordaxishelper helper = new coordaxishelper ( this ) ; double start = double . nan ; boolean first = bool_ ; list < rangeiterator > ranges = new arraylist < > ( ) ; for ( mamath . minmax lonintv : lonintvs ) { if ( first ) start = lonintv . min ; first = bool_ ; optional < rangeiterator > opt = helper . makerange ( lonintv . min , lonintv . max , stride ) ; if ( ! opt . ispresent ( ) ) return optional . empty ( opt . geterrormessage ( ) ) ; ranges . add ( opt . get ( ) ) ; } try { rangecomposite compositerange = new rangecomposite ( axistype . lon . tostring ( ) , ranges ) ; int npts = compositerange . length ( ) ; double end = start + npts * resolution ; coveragecoordaxisbuilder builder = new coveragecoordaxisbuilder ( this ) ;	only for longitude, only for regular (do we need a subclass for longitude 1D coords ??.
static boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { if ( b1 == b2 ) return bool_ ; if ( b1 == null || b2 == null ) return bool_ ; if ( b1 . length < len || b2 . length < len ) return bool_ ; for ( int i = num_ ; i < len ; i ++ ) { if ( b1 [ i ] != b2 [ i ] ) return bool_ ; } return bool_ ; }	Not quite memcmp.
protected dapdataset parsedmr ( string document ) throws dapexception {	It is common to want to parse a DMR text to a DapDataset,so provide this utility.
protected void processattributes ( dapdataset dataset ) throws dapexception { list < dapnode > nodes = dataset . getnodelist ( ) ; for ( dapnode node : nodes ) { switch ( node . getsort ( ) ) { case group : case dataset : case variable : map < string , dapattribute > attrs = node . getattributes ( ) ; if ( attrs . size ( ) > num_ ) { list < dapattribute > suppressed = new arraylist < > ( ) ; for ( dapattribute dattr : attrs . values ( ) ) { if ( suppress ( dattr . getshortname ( ) ) ) suppressed . add ( dattr ) ; } for ( dapattribute dattr : suppressed ) { node . removeattribute ( dattr ) ; } } break ; default : break ; } }	Walk the dataset tree and remove selected attributessuch as _Unsigned.
public void addcoords ( list < coordinate > coords , partitioncollectionmutable . partition part ) { coordinate runtime = null ; for ( coordinate coord : coords ) { switch ( coord . gettype ( ) ) { case runtime : coordinateruntime rtime = ( coordinateruntime ) coord ; if ( runtimebuilder == null ) runtimebuilder = new coordinateruntime . builder2 ( rtime . gettimeunits ( ) ) ; runtimebuilder . addall ( coord ) ; runtime = coord ; if ( debugpartitionerrors && ! duplicateruntimemessage && part != null ) testduplicateruntime ( rtime , part ) ; break ; case time : coordinatetime time = ( coordinatetime ) coord ; if ( timebuilder == null ) timebuilder = new coordinatetime . builder2 ( coord . getcode ( ) , time . gettimeunit ( ) , time . getrefdate ( ) ) ; timebuilder . addall ( coord ) ; break ; case timeintv : coordinatetimeintv timeintv = ( coordinatetimeintv ) coord ; if ( timeintvbuilder == null ) timeintvbuilder = new coordinatetimeintv . builder2 ( null , coord . getcode ( ) , timeintv . gettimeunit ( ) , timeintv . getrefdate ( ) ) ; timeintvbuilder . addall ( intervalfilter ( ( coordinatetimeintv ) coord ) ) ; break ; case time2d : coordinatetime2d time2d = ( coordinatetime2d ) coord ; if ( time2dbuilder == null ) time2dbuilder = new coordinatetime2dunionizer ( time2d . istimeinterval ( ) , time2d . gettimeunit ( ) , coord . getcode ( ) , bool_ , logger ) ; time2dbuilder . addall ( time2d ) ;	only one message per CoordinatePartitionUnionizer instance.
public void setgaussianlats ( int nparallels , float la1 , float la2 ) { log . debug ( str_ , la1 , la2 ) ; if ( this . gausslats != null ) throw new runtimeexception ( str_ ) ; int nlats = ( num_ * nparallels ) ; gaussianlatitudes gausslats = gaussianlatitudes . factory ( nlats ) ; int beststartindex = num_ , bestendindex = num_ ; double beststartdiff = double . max_value ; double bestenddiff = double . max_value ; for ( int i = num_ ; i < nlats ; i ++ ) { double diff = math . abs ( gausslats . latd [ i ] - la1 ) ; if ( diff < beststartdiff ) { beststartdiff = diff ; beststartindex = i ; } diff = math . abs ( gausslats . latd [ i ] - la2 ) ; if ( diff < bestenddiff ) { bestenddiff = diff ; bestendindex = i ; } } log . debug ( str_ , beststartindex , bestendindex ) ; if ( math . abs ( bestendindex - beststartindex ) + num_ != nyraw ) { log . warn ( str_ ) ;	some weird adjustment for la1 and la2.
private static parsedsectionspec parsevariableselector ( object parent , string selector ) throws invalidrangeexception { string varnameesc , indexselect = null ; int pos1 = escapestrings . indexof ( selector , str_ ) ; if ( pos1 < num_ ) {	parse variable name and index selector out of the selector String. variable name must be escaped.
public static string makesectionspecstring ( variable v , list < range > ranges ) throws invalidrangeexception { stringbuilder sb = new stringbuilder ( ) ; makespec ( sb , v , ranges ) ; return sb . tostring ( ) ; }	Make section specification String from a range list for a Variable.
private boolean box9 ( double wantlat , double wantlon , int [ ] rectindex ) { int row = rectindex [ num_ ] ; int minrow = math . max ( row - num_ , num_ ) ; int maxrow = math . min ( row + num_ , nrows ) ; int col = rectindex [ num_ ] ; int mincol = math . max ( col - num_ , num_ ) ; int maxcol = math . min ( col + num_ , ncols ) ; if ( debug ) system . out . printf ( str_ ) ; for ( int i = minrow ; i <= maxrow ; i ++ ) for ( int j = mincol ; j <= maxcol ; j ++ ) { rectindex [ num_ ] = i ; rectindex [ num_ ] = j ; if ( contains ( wantlat , wantlon , rectindex ) ) return bool_ ; } return bool_ ; }	we think its got to be in one of the 9 boxes around rectIndex.
public synchronized void close ( ) { if ( closed ) return ;	Calling close will force the method to close, and willforce any open stream to terminate.
public int execute ( ) throws httpexception { httpresponse res = executeraw ( ) ; if ( res != null ) return res . getstatusline ( ) . getstatuscode ( ) ; else throw new httpexception ( str_ ) ; }	Create a request, add headers, and content,then send to HTTPSession to do the bulk of the work.
protected boolean identifyencodingstation ( netcdfdataset ds , encodinginfo info , cf . featuretype ftype , formatter errlog ) {	for stations, figure out the encoding.
protected string matchaxistypeanddimension ( netcdfdataset ds , axistype type , final dimension outer ) { variable var = coordsysevaluator . findcoordbytype ( ds , type , new coordsysevaluator . predicate ( ) { public boolean match ( coordinateaxis axis ) { if ( ( outer == null ) && ( axis . getrank ( ) == num_ ) ) return bool_ ; if ( ( outer != null ) && ( axis . getrank ( ) == num_ ) && ( outer . equals ( axis . getdimension ( num_ ) ) ) ) return bool_ ;	class, I don't understand enough of the code base to anticipate implementation artifacts.
public void setstream ( inputstream zstream ) { last = num_ ; origptr = num_ ; blocksize100k = num_ ; blockrandomised = bool_ ; bsbuff = num_ ; bslive = num_ ; mcrc = new crc ( ) ; ninuse = num_ ; bsstream = null ; streamend = bool_ ; currentchar = - num_ ; currentstate = start_block_state ; storedblockcrc = storedcombinedcrc = num_ ; computedblockcrc = computedcombinedcrc = num_ ; i2 = count = chprev = ch2 = num_ ; i = tpos = num_ ; rntogo = num_ ; rtpos = num_ ; j2 = num_ ; z = num_ ; bssetstream ( zstream ) ; initialize ( ) ; if ( ! streamend ) {	Added 5-30-2006 to allow for resetting of the input usedby this object. This saves in memory allocation costs.
public int read ( ) { if ( streamend ) { return - num_ ; } else { int retchar = currentchar ; switch ( currentstate ) { case start_block_state : break ; case rand_part_a_state : break ; case rand_part_b_state : setuprandpartb ( ) ; break ; case rand_part_c_state : setuprandpartc ( ) ; break ; case no_rand_part_a_state : break ; case no_rand_part_b_state : setupnorandpartb ( ) ; break ; case no_rand_part_c_state : setupnorandpartc ( ) ; break ; default : break ; } return retchar ; } }	Reads the stream.
public void start ( java . awt . component top , string taskname , int progressmaxcount ) {	Call this from awt event thread.The task is run in a background thread.
static public uri parsetouri ( final string u ) throws urisyntaxexception { stringbuilder buf = new stringbuilder ( ) ; int i = num_ ; while ( i < u . length ( ) ) { char c = u . charat ( i ) ; if ( c == str_ ) { if ( i + num_ == u . length ( ) ) throw new urisyntaxexception ( u , str_ ) ; buf . append ( str_ ) ; i ++ ; c = u . charat ( i ) ; buf . append ( string . format ( str_ , ( int ) c ) ) ; } else buf . append ( c ) ; i ++ ; } return new uri ( buf . tostring ( ) ) ; }	Convert a uri string to an instance of java.net.URI.The critical thing is that this procedure can handle backslashescaped uris as well as %xx escaped uris.
static uri uriexclude ( final uri uri , uripart ... excludes ) { uribuilder urib = new uribuilder ( ) ; enumset < uripart > set = enumset . of ( excludes [ num_ ] , excludes ) ; for ( uripart part : uripart . values ( ) ) { if ( set . contains ( part ) ) continue ; switch ( part ) { case scheme : urib . setscheme ( uri . getscheme ( ) ) ; break ; case userinfo : urib . setuserinfo ( uri . getuserinfo ( ) ) ; break ; case host : urib . sethost ( uri . gethost ( ) ) ; break ; case port : urib . setport ( uri . getport ( ) ) ; break ; case path : urib . setpath ( uri . getpath ( ) ) ; break ; case query : urib . setcustomquery ( uri . getquery ( ) ) ; break ; case fragment : urib . setfragment ( uri . getfragment ( ) ) ; break ; } } try { return urib . build ( ) ; } catch ( urisyntaxexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } }	Remove selected fields from a URI producing a new URI.
static public string nullify ( string s ) { if ( s != null && s . length ( ) == num_ ) s = null ; return s ; }	Convert a zero-length string to null.
static public string canonjoin ( string prefix , string suffix ) { if ( prefix == null ) prefix = str_ ; if ( suffix == null ) suffix = str_ ; prefix = httputil . canonicalpath ( prefix ) ; suffix = httputil . canonicalpath ( suffix ) ; stringbuilder result = new stringbuilder ( ) ; result . append ( prefix ) ; int prelen = prefix . length ( ) ; if ( prelen > num_ && result . charat ( prelen - num_ ) != str_ ) { result . append ( str_ ) ; prelen ++ ; } if ( suffix . length ( ) > num_ && suffix . charat ( num_ ) == str_ ) result . append ( suffix . substring ( num_ ) ) ; else result . append ( suffix ) ; int len = result . length ( ) ; if ( len > num_ && result . charat ( len - num_ ) == str_ ) { result . deletecharat ( len - num_ ) ; len -- ; } return result . tostring ( ) ; }	Join two string together to form proper pathWITHOUT trailing slash.
public boolean accept ( crawlabledataset dataset ) { date lastmoddate = dataset . lastmodified ( ) ; if ( lastmoddate != null ) { long now = system . currenttimemillis ( ) ; if ( now - lastmoddate . gettime ( ) > lastmodifiedlimitinmillis ) return bool_ ; } return bool_ ; }	Accept datasets whose last modified date is at least thelast modified limit of milliseconds in the past.
void copyinfo ( gribcollectionmutable from ) { this . center = from . center ; this . subcenter = from . subcenter ; this . master = from . master ; this . local = from . local ; this . genprocesstype = from . genprocesstype ; this . genprocessid = from . genprocessid ; this . backprocessid = from . backprocessid ; }	for making partition collection.
public list < string > getfilenames ( ) { list < string > result = new arraylist < > ( ) ; for ( mfile file : filemap . values ( ) ) result . add ( file . getpath ( ) ) ; collections . sort ( result ) ; return result ; }	The files that comprise the collection.Actual paths, including the grib cache if used.
void setindexraf ( randomaccessfile indexraf ) { this . indexraf = indexraf ; if ( indexraf != null ) { this . indexfilename = indexraf . getlocation ( ) ; } }	public by accident, do not use.
private string getindexfilepathincache ( ) { file indexfile = gribcdmindex . makeindexfile ( name , directory ) ; return gribindexcache . getfileorcache ( indexfile . getpath ( ) ) . getpath ( ) ; }	get index filename.
public int ncounters ( ) { if ( nested == null ) return num_ ; else { int ncounters = num_ ; for ( bitcountercompressed [ ] counters : nested ) { if ( counters == null ) continue ; for ( bitcountercompressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; } return ncounters ; } }	Number of nested fields.
public attribute addglobalattribute ( string name , string value ) { return addglobalattribute ( new attribute ( name , value ) ) ; }	Add a Global attribute of type String to the file.
public attribute addglobalattribute ( string name , array values ) { return addglobalattribute ( new attribute ( name , values ) ) ; }	Add a Global attribute of type Array to the file.
public attribute deleteglobalattribute ( string attname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; attribute att = findglobalattribute ( attname ) ; if ( null == att ) return null ; rootgroup . remove ( att ) ; return att ; }	Delete a global Attribute.
public attribute renameglobalattribute ( string oldname , string newname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; attribute att = findglobalattribute ( oldname ) ; if ( null == att ) return null ; rootgroup . remove ( att ) ; att = new attribute ( newname , att . getvalues ( ) ) ; rootgroup . addattribute ( att ) ; return att ; }	Rename a global Attribute.
public void addvariableattribute ( string varname , string attname , string value ) { addvariableattribute ( varname , new attribute ( attname , value ) ) ; }	Add an attribute of type String to the named Variable.
public void addvariableattribute ( string varname , string attname , array value ) { attribute att = new attribute ( attname , value ) ; addvariableattribute ( varname , att ) ; }	Add an attribute of type Array to the named Variable.
public attribute deletevariableattribute ( string varname , string attname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; variable v = findvariable ( varname ) ; if ( v == null ) return null ; attribute att = v . findattribute ( attname ) ; if ( null == att ) return null ; v . remove ( att ) ; return att ; }	Delete a variable Attribute.
public attribute renamevariableattribute ( string varname , string attname , string newname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; variable v = findvariable ( varname ) ; if ( v == null ) return null ; attribute att = v . findattribute ( attname ) ; if ( null == att ) return null ; v . remove ( att ) ; att = new attribute ( newname , att . getvalues ( ) ) ; v . addattribute ( att ) ; return att ; }	Rename a variable Attribute.
protected void makefilesubtype ( ) {	Set the file subType.
private void writeheadersandbb ( ) { fileoutput += str_ + wfsxmlhelper . encquotes ( str_ + namespace + str_ + server + str_ + wfsxmlhelper . ampersand + str_ + wfsxmlhelper . ampersand + str_ + wfsxmlhelper . ampersand + str_ + wfscontroller . tdsnamespace + str_ + ftname ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfscontroller . tdsnamespace + str_ + wfsxmlhelper . encquotes ( namespace ) + str_ + wfsxmlhelper . encquotes ( str_ ) + str_ + wfsxmlhelper . encquotes ( string . valueof ( geometries . size ( ) ) ) + str_ + wfsxmlhelper . encquotes ( string . valueof ( geometries . size ( ) ) ) + str_ ; double [ ] boundlower ; double [ ] boundupper ; if ( geometries . isempty ( ) ) { boundlower = new double [ num_ ] ; boundupper = new double [ num_ ] ; boundlower [ num_ ] = - num_ ; boundlower [ num_ ] = - num_ ; boundupper [ num_ ] = num_ ; boundupper [ num_ ] = num_ ; } else { boundlower = geometries . get ( num_ ) . getbblower ( ) ; boundupper = geometries . get ( num_ ) . getbbupper ( ) ; }	Writes headers and bounding box.
public void writemembers ( ) { int index = num_ ; gmlfeaturewriter writer = new gmlfeaturewriter ( ) ; for ( simplegeometry geometryitem : geometries ) {	In the WFS specification for GetFeature each feature type is its ownmember and so writeMembers add each member to the fileOutput.
public string writestationobsdatasetxml ( ) { xmloutputter fmt = new xmloutputter ( format . getprettyformat ( ) ) ; return fmt . outputstring ( makestationobsdatasetdocument ( ) ) ; }	Write stationObsDataset XML document.
public string writestationcollectionxml ( ) throws ioexception { xmloutputter fmt = new xmloutputter ( format . getprettyformat ( ) ) ; return fmt . outputstring ( makestationcollectiondocument ( ) ) ; }	Write stationCollection XML document.
public void writedsr ( string dsr ) throws ioexception { if ( state != state . initial ) throw new dapexception ( str_ ) ; if ( dsr == null ) throw new dapexception ( str_ ) ;	Write the DSR; do not bother to cache.
void senddxr ( byte [ ] dxr8 ) throws ioexception { if ( dxr8 == null || dxr8 . length == num_ ) return ;	Output the specifiedd DMR or DSR or..., but xml only.
public void writeerror ( int httpcode , string msg , string cxt , string other ) throws ioexception { dmr8 = null ; errorresponse response = new errorresponse ( httpcode , msg , cxt , other ) ; string errorbody = response . buildxml ( ) ;	Write an error chunk.If mode == DMR then replaces the dmrelse reset the current chunk thuslosing any partial write.
public void close ( ) throws ioexception { if ( closed ) return ; closed = bool_ ; if ( dmr8 != null ) { senddxr ( dmr8 ) ; dmr8 = null ; } if ( mode == requestmode . dmr ) return ;	Closes this output stream and releases any system resourcesassociated with this stream. Except, the underlying stream is notactually closed; that is left to the servlet level.
@ override public void flush ( ) throws ioexception { if ( mode == requestmode . dmr ) return ;	Overload flush to also write out the DMR.
public boolean contains ( int want ) { if ( want < first ( ) ) return bool_ ; if ( want > last ( ) ) return bool_ ; if ( stride == num_ ) return bool_ ; return ( want - first ) % stride == num_ ; }	Is want contained in this Range?.
public int element ( int i ) throws invalidrangeexception { if ( i < num_ ) throw new invalidrangeexception ( str_ ) ; if ( i >= length ) throw new invalidrangeexception ( str_ ) ; return first + i * stride ; }	Get ith element.
public range shiftorigin ( int origin ) throws invalidrangeexception { if ( this == vlen ) return vlen ; int first = first ( ) - origin ; int last = last ( ) - origin ; return new range ( name , first , last , stride ) ; }	Create a new Range shifting this range by a constant factor.
protected object readdata ( layout index , datatype datatype ) throws java . io . ioexception { return iosphelper . readdatafill ( raf , index , datatype , null , - num_ ) ; }	Read data subset from file for a variable, create primitive array.
protected long readdata ( layout index , datatype datatype , writablebytechannel out ) throws java . io . ioexception { long count = num_ ; if ( datatype . getprimitiveclasstype ( ) == byte . class || datatype == datatype . char ) { while ( index . hasnext ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . readtobytechannel ( out , chunk . getsrcpos ( ) , chunk . getnelems ( ) ) ; } } else if ( datatype . getprimitiveclasstype ( ) == short . class ) { while ( index . hasnext ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . readtobytechannel ( out , chunk . getsrcpos ( ) , num_ * chunk . getnelems ( ) ) ; } } else if ( datatype . getprimitiveclasstype ( ) == int . class || ( datatype == datatype . float ) ) { while ( index . hasnext ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . readtobytechannel ( out , chunk . getsrcpos ( ) , num_ * chunk . getnelems ( ) ) ; } } else if ( ( datatype == datatype . double ) || datatype . getprimitiveclasstype ( ) == long . class ) { while ( index . hasnext ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . readtobytechannel ( out , chunk . getsrcpos ( ) , num_ * chunk . getnelems ( ) ) ; } } return count ; }	Read data subset from file for a variable, to WritableByteChannel.Will send as bigendian, since thats what the underlying file has.
public primitivevector subset ( int start , int stop , int stride ) { booleanprimitivevector n = new booleanprimitivevector ( gettemplate ( ) ) ; stride = math . max ( stride , num_ ) ; stop = math . max ( start , stop ) ; int length = num_ + ( stop - start ) / stride ; n . setlength ( length ) ; int count = num_ ; for ( int i = start ; i <= stop ; i += stride ) { n . setvalue ( count , vals [ i ] ) ; count ++ ; } return n ; }	Create a new primitive vector using a subset of the data.
public void setvalues ( float [ ] values ) { vals = values ; proj = gempakutil . st_itoc ( float . floattointbits ( vals [ num_ ] ) ) . trim ( ) ; addparam ( proj , proj ) ; addparam ( gds_key , this . tostring ( ) ) ; setparams ( ) ; }	Set the grid nav block values.
private double [ ] makedoublearray ( int [ ] ints ) { double [ ] newarray = new double [ ints . length ] ; for ( int i = num_ ; i < ints . length ; i ++ ) { newarray [ i ] = ints [ i ] ; } return newarray ; }	make a double array out of an int array.
@ requestmapping ( str_ ) public void getdatasetboundaries ( ncssparamsbean params , httpservletrequest req , httpservletresponse res ) throws ioexception , unsupportedresponseformatexception { supportedformat format = supportedoperation . dataset_boundaries_request . getsupportedformat ( params . getaccept ( ) ) ; switch ( format ) { case wkt : getdatasetboundarieswkt ( req , res ) ; break ; case json : getdatasetboundariesgeojson ( req , res ) ; break ; default : throw new illegalargumentexception ( string . format ( str_ , supportedformat . wkt , supportedformat . json , format ) ) ; } }	Supported for backwards compatibility.
private void checkrequestedvars ( coveragecollection gcd , ncssgridparamsbean params ) throws variablenotcontainedindatasetexception {	Checks that all the requested vars exist.
public static datasetsourcestructure getstructure ( string name ) { if ( name == null ) return null ; return ( datasetsourcestructure ) hash . get ( name ) ; }	Find the DatasetSourceStructure that matches this name.
@ override public string getresourcepath ( daprequest drq , string location ) throws dapexception { string realpath ; if ( tdsrequesteddataset . getdatasetmanager ( ) != null ) { realpath = tdsrequesteddataset . getlocationfromrequestpath ( location ) ; } else { assert tdsrequesteddataset . getdatasetmanager ( ) == null ; string prefix = drq . getresourceroot ( ) ; assert ( prefix != null ) ; realpath = daputil . canonjoin ( prefix , location ) ; } if ( ! testing ) { if ( ! tdsrequesteddataset . resourcecontrolok ( drq . getrequest ( ) , drq . getresponse ( ) , realpath ) ) throw new dapexception ( str_ + location ) . setcode ( dapcodes . sc_forbidden ) ; } file f = new file ( realpath ) ; if ( ! f . exists ( ) || ! f . canread ( ) ) throw new dapexception ( str_ + location ) . setcode ( dapcodes . sc_not_found ) ;	to work under Intellij.
private void makeverticaldimensions ( list < gridvertcoord > vertcoordlist , netcdffile ncfile , group group ) {	Make a vertical dimensions.
boolean readpib ( randomaccessfile raf ) throws ioexception { this . firstheader = new awxfilefirstheader ( ) ; int pos = num_ ; raf . seek ( pos ) ;	Read the header and populate the ncfile.
public boolean finish ( ) { boolean ok = bool_ ; java . util . iterator iter ; logger . debug ( str_ + getname ( ) + str_ + getid ( ) ) ; authorityname = null ; datatype = null ; dataformattype = null ; defaultservice = null ; gc = null ; tc = null ; docs = new arraylist < > ( ) ; metadata = new arraylist < > ( ) ; properties = new arraylist < > ( ) ; creators = new arraylist < > ( ) ; contributors = new arraylist < > ( ) ; dates = new arraylist < > ( ) ; keywords = new arraylist < > ( ) ; projects = new arraylist < > ( ) ; publishers = new arraylist < > ( ) ; variables = new arraylist < > ( ) ; canonicalize ( ) ;	Finish constructing after all elements have been added.This does the inheritence thingThis can be called again if new elements are added.
private void transferinheritable2publicmetadata ( invdatasetimpl parent ) { if ( parent == null ) return ; logger . debug ( str_ + parent . getid ( ) ) ; transfer2publicmetadata ( parent . getlocalmetadatainheritable ( ) , bool_ ) ;	Look for InvMetadata elements in the parent that need to be added to the public metadata of this dataset.Recurse up through all ancestors.
public void transfermetadata ( invdatasetimpl fromds , boolean copyinheritedmetadatafromparents ) { if ( fromds == null ) return ; logger . debug ( str_ + fromds . getname ( ) ) ; if ( this != fromds ) getlocalmetadata ( ) . add ( fromds . getlocalmetadata ( ) , bool_ ) ; transferinheritablemetadata ( fromds , getlocalmetadatainheritable ( ) , copyinheritedmetadatafromparents ) ; setresourcecontrol ( fromds . getrestrictaccess ( ) ) ; }	Transfer all inheritable metadata from fromDs to the local metadata of this dataset.Called by InvDatasetScan to transfer inheritable metaddata to the nested catalogRef.
private void transferinheritablemetadata ( invdatasetimpl fromds , threddsmetadata target , boolean copyinheritedmetadatafromparents ) { if ( fromds == null ) return ; logger . debug ( str_ + fromds . getname ( ) ) ; target . add ( fromds . getlocalmetadatainheritable ( ) , bool_ ) ;	transfer inherited metadata, consolidating it into target.
public void setcontributors ( list < threddsmetadata . contributor > a ) { list < threddsmetadata . contributor > dest = tm . getcontributors ( ) ; for ( threddsmetadata . contributor item : a ) { if ( ! dest . contains ( item ) ) dest . add ( item ) ; } hashcode = num_ ; }	LOOK these are wrong.
public void adddataset ( int index , invdatasetimpl ds ) { if ( ds == null ) return ; ds . setparent ( this ) ; datasets . add ( index , ds ) ; hashcode = num_ ; }	Add a nested dataset at the location indicated by index.
public boolean removedataset ( invdatasetimpl ds ) { if ( this . datasets . remove ( ds ) ) { ds . setparent ( null ) ; invcatalogimpl cat = ( invcatalogimpl ) getparentcatalog ( ) ; if ( cat != null ) cat . removedatasetbyid ( ds ) ; return ( bool_ ) ; } return ( bool_ ) ; }	Remove the given dataset element from this dataset if it is in the dataset.
public boolean replacedataset ( invdatasetimpl remove , invdatasetimpl add ) { for ( int i = num_ ; i < datasets . size ( ) ; i ++ ) { invdataset dataset = datasets . get ( i ) ; if ( dataset . equals ( remove ) ) { datasets . set ( i , add ) ; invcatalogimpl cat = ( invcatalogimpl ) getparentcatalog ( ) ; if ( cat != null ) { cat . removedatasetbyid ( remove ) ; cat . adddatasetbyid ( add ) ; } return bool_ ; } } return bool_ ; }	Replace the given dataset if it is a nesetd dataset.
public void addservice ( invservice service ) {	Add a service to this dataset.
public void removeservice ( invservice service ) { serviceslocal . remove ( service ) ; services . remove ( service ) ;	Remove a service from this dataset.
public void setserviceslocal ( java . util . list < invservice > s ) { this . services = new arraylist < > ( ) ; this . serviceslocal = new arraylist < > ( ) ; for ( invservice elem : s ) { addservice ( elem ) ; } hashcode = num_ ; }	Set the list of services attached specifically to this dataset.Discard any previous servies.
public boolean removelocalmetadata ( invmetadata metadata ) { invdatasetimpl parentdataset = ( ( invdatasetimpl ) metadata . getparentdataset ( ) ) ; list localmdata = parentdataset . getlocalmetadata ( ) . getmetadata ( ) ; if ( localmdata . contains ( metadata ) ) { if ( localmdata . remove ( metadata ) ) { hashcode = num_ ;	Remove the given InvMetadata from the set of metadata local to this dataset.
public object getuserproperty ( object key ) { if ( usermap == null ) return null ; return usermap . get ( key ) ; }	Look up the User property having the given key.
boolean validate ( stringbuilder out ) { this . isvalid = bool_ ;	Validate this DatasetNamer object.
public final list < string > getdescriptors ( ) { list < string > desc = new arraylist < string > ( ) ; for ( short fxy : descriptors ) desc . add ( descriptor . makestring ( fxy ) ) ; return desc ; }	get list of data descriptors as Strings.
public static string constructserverpath ( httpservletrequest hsreq ) { return hsreq . getscheme ( ) + str_ + hsreq . getservername ( ) + str_ + hsreq . getserverport ( ) + str_ ; }	Constructs the full server URI from a request.
private void getcapabilities ( printwriter out , httpservletrequest hsreq , simplegeometrycsbuilder sgcs ) { wfsgetcapabilitieswriter gcdw = new wfsgetcapabilitieswriter ( out , wfscontroller . constructserverpath ( hsreq ) ) ; gcdw . startxml ( ) ; gcdw . addoperation ( wfsrequesttype . getcapabilities ) ; gcdw . addoperation ( wfsrequesttype . describefeaturetype ) ; gcdw . addoperation ( wfsrequesttype . getfeature ) ; gcdw . writeoperations ( ) ; list < string > seriesnames = sgcs . getgeometryseriesnames ( ) ; for ( string name : seriesnames ) { gcdw . addfeature ( new wfsfeature ( tdsnamespace + str_ + name , name ) ) ; } gcdw . writefeaturetypes ( ) ; gcdw . finishxml ( ) ; }	Processes GetCapabilities requests.
private wfsexceptionwriter getfeature ( printwriter out , httpservletrequest hsreq , simplegeometrycsbuilder sgcs , string ftname , string fullftname ) { list < simplegeometry > geometrylist = new arraylist < simplegeometry > ( ) ; geometrytype geot = sgcs . getgeometrytype ( ftname ) ; if ( geot == null ) { return new wfsexceptionwriter ( str_ + fullftname + str_ , str_ , str_ ) ; } try { switch ( geot ) { case point : point pt = sgcs . getpoint ( ftname , num_ ) ; int j = num_ ; while ( pt != null ) { geometrylist . add ( pt ) ; j ++ ; pt = sgcs . getpoint ( ftname , j ) ; } break ; case line : line line = sgcs . getline ( ftname , num_ ) ; int k = num_ ; while ( line != null ) { geometrylist . add ( line ) ; k ++ ; line = sgcs . getline ( ftname , k ) ; } break ; case polygon : polygon poly = sgcs . getpolygon ( ftname , num_ ) ; int i = num_ ; while ( poly != null ) { geometrylist . add ( poly ) ; i ++ ; poly = sgcs . getpolygon ( ftname , i ) ; } break ; } }	Processes GetFeature requests.
private wfsexceptionwriter checkparametersforerror ( string request , string version , string service , string typename ) {	Checks request parameters for errors.Will send back an XML Exception if any errors are encountered.
@ requestmapping ( str_ ) public void httphandler ( httpservletrequest hsreq , httpservletresponse hsres ) { try { printwriter wr = hsres . getwriter ( ) ; list < string > paramnames = new linkedlist < string > ( ) ; enumeration < string > paramnamese = hsreq . getparameternames ( ) ; while ( paramnamese . hasmoreelements ( ) ) paramnames . add ( paramnamese . nextelement ( ) ) ;	A handler for WFS based HTTP requests that sends to other request handlersto handle the request.Servlet Path: /wfs/{request}.
public string getcapabilities ( string url ) throws ioexception {	Provide a method for getting the capabilities document.
@ override public long length ( ) {	Returns the size of the dataset, in bytes.
@ override public date lastmodified ( ) { s3objectsummary objectsummary = objectsummarycache . getifpresent ( s3uri ) ; if ( objectsummary != null ) { return objectsummary . getlastmodified ( ) ; } objectmetadata metadata = threddss3client . getobjectmetadata ( s3uri ) ; if ( metadata != null ) { return metadata . getlastmodified ( ) ; } else {	Returns the date that the dataset was last modified.
public static void returnfile ( httpservlet servlet , string contentpath , string path , httpservletrequest req , httpservletresponse res , string contenttype ) throws ioexception { string filename = servletutil . formfilename ( contentpath , path ) ; log . debug ( str_ + filename + str_ ) ;	Write a file to the response stream.
public static void returnstring ( string contents , httpservletresponse res ) throws ioexception { try { servletoutputstream out = res . getoutputstream ( ) ; io . copy ( new bytearrayinputstream ( contents . getbytes ( cdm . utf8charset ) ) , out ) ; } catch ( ioexception e ) { log . error ( str_ , e ) ; res . senderror ( httpservletresponse . sc_not_found , str_ + e . getmessage ( ) ) ; } }	Send given content string as the HTTP response.
public static int setresponsecontentlength ( httpservletresponse response , string s ) throws unsupportedencodingexception { int length = s . getbytes ( response . getcharacterencoding ( ) ) . length ; response . setcontentlength ( length ) ; return length ; }	Set the proper content length for the string.
public static uri getrequesturi ( httpservletrequest req ) { try { return new uri ( getrequestbase ( req ) ) ; } catch ( urisyntaxexception e ) { e . printstacktrace ( ) ; return null ; } }	The request base as a URI.
public static string getrequestpath ( httpservletrequest req ) { stringbuilder buff = new stringbuilder ( ) ; if ( req . getservletpath ( ) != null ) buff . append ( req . getservletpath ( ) ) ; if ( req . getpathinfo ( ) != null ) buff . append ( req . getpathinfo ( ) ) ; return buff . tostring ( ) ; }	servletPath + pathInfo.
public static string getrequest ( httpservletrequest req ) { string query = req . getquerystring ( ) ; return getrequestbase ( req ) + ( query == null ? str_ : str_ + query ) ; }	The entire request including query string.
public static string getparameterignorecase ( httpservletrequest req , string paramname ) { enumeration e = req . getparameternames ( ) ; while ( e . hasmoreelements ( ) ) { string s = ( string ) e . nextelement ( ) ; if ( s . equalsignorecase ( paramname ) ) return req . getparameter ( s ) ; } return null ; }	Return the value of the given parameter for the given request.
public void save ( ) { if ( catlistbox != null ) catlistbox . save ( ) ; if ( prefs != null ) { if ( filechooser != null ) filechooser . save ( ) ; if ( catgenfilechooser != null ) catgenfilechooser . save ( ) ; prefs . putint ( hdivider , split . getdividerlocation ( ) ) ; } }	Save persistent state.
public int writedirectory ( httpservletresponse res , file dir , string path ) throws ioexception {	Write a file directory.
public bitcounteruncompressed makenested ( datadescriptor subkey , int n , int row , int replicationcountsize ) { if ( subcounters == null ) subcounters = new hashmap < datadescriptor , bitcounteruncompressed [ ] > ( num_ ) ;	Track nested Tables.
int countbits ( int startbit ) { countbits = replicationcountsize ; this . startbit = new int [ nrows ] ; for ( int i = num_ ; i < nrows ; i ++ ) { this . startbit [ i ] = startbit + countbits ; if ( debug ) system . out . println ( str_ + i + str_ + this . startbit [ i ] ) ; for ( datadescriptor nd : parent . subkeys ) { bitcounteruncompressed [ ] bitcounter = ( subcounters == null ) ? null : subcounters . get ( nd ) ; if ( bitcounter == null )	total bits of this table and all subtables.
public void appendline ( string line ) { if ( count >= nlines ) { try { int remove = math . max ( removeincr , count - nlines ) ;	Append this line to the bottom of the JTextArea.A newline is added and JTextArea is scrolled to bottom;remove lines at top if needed.
public document makestationcollectiondocument ( latlonrect bb , string [ ] names ) throws ioexception { list < dsgfeaturecollection > list = fdp . getpointfeaturecollectionlist ( ) ; dsgfeaturecollection fc = list . get ( num_ ) ;	Create an XML document for the stations in this dataset, possible subsetted by bb.Must be a station dataset.
public document getcapabilitiesdocument ( ) { element rootelem = new element ( str_ ) ; document doc = new document ( rootelem ) ; if ( null != path ) { rootelem . setattribute ( str_ , path ) ; element elem = new element ( str_ ) ; featuretype ft = fdp . getfeaturetype ( ) ; elem . setattribute ( str_ , ft . tostring ( ) . tolowercase ( ) ) ; string url = path . replace ( str_ , ft . tostring ( ) . tolowercase ( ) + str_ ) ; elem . setattribute ( str_ , url ) ; rootelem . addcontent ( elem ) ; } list < dsgfeaturecollection > list = fdp . getpointfeaturecollectionlist ( ) ; dsgfeaturecollection fc = list . get ( num_ ) ;	Create the capabilities XML document for this dataset.
@ nullable synchronized record getrecordat ( subsetparams coords ) { int [ ] want = new int [ getrank ( ) ] ; int count = num_ ; int runidx = - num_ ; for ( coordinate coord : getcoordinates ( ) ) { int idx = - num_ ; switch ( coord . gettype ( ) ) { case runtime : calendardate runtimecooord = coords . getruntime ( ) ; idx = coord . getindex ( runtimecooord ) ; runidx = idx ; break ; case timeintv : double [ ] timeintv = coords . gettimeoffsetintv ( ) ; idx = coord . getindex ( new timecoordintvvalue ( ( int ) timeintv [ num_ ] , ( int ) timeintv [ num_ ] ) ) ; break ; case time : double timeoffset = coords . gettimeoffset ( ) ;	coord based record finding. note only one record at a time.
public coordinate getcoordinate ( int index ) { int grpindex = coordindex . get ( index ) ; return group . coords . get ( grpindex ) ; }	get the ith coordinate.
public void additem ( object item ) { if ( item == null ) return ; for ( int i = num_ ; i < getitemcount ( ) ; i ++ ) { if ( item . equals ( getitemat ( i ) ) ) { if ( i == num_ ) { setselectedindex ( num_ ) ; return ;	Add the item to the top of the list.
@ exceptionhandler ( throwable . class ) public responseentity < string > handle ( throwable ex ) throws throwable {	LOOK this could be a problem.
public int step ( int firstpos , int lastpos ) { for ( int i = lastpos - num_ ; i >= firstpos ; i -- ) {	return -1 if we have completed.
@ nullable public static map < integer , string > getncepgenprocess ( ) { if ( genprocessmap != null ) return genprocessmap ; string path = str_ ; try ( inputstream is = gribresourcereader . getinputstream ( path ) ) { saxbuilder builder = new saxbuilder ( ) ; org . jdom2 . document doc = builder . build ( is ) ; element root = doc . getrootelement ( ) ; hashmap < integer , string > result = new hashmap < > ( num_ ) ; list < element > params = root . getchildren ( str_ ) ; for ( element elem1 : params ) { int code = integer . parseint ( elem1 . getattributevalue ( str_ ) ) ; string desc = elem1 . getchildtext ( str_ ) ; result . put ( code , desc ) ; } return collections . unmodifiablemap ( result ) ;	public so can be called from Grib2.
public static featuretype iscdmrfendpoint ( string endpoint ) throws ioexception { httpsession httpclient = httpfactory . newsession ( endpoint ) ; string url = endpoint + str_ ;	all CdmrFeatureDatasets must return their featureType - use as a fail-fast test of the endpoint.
public void sethasvalue ( int type ) { this . type = type ; if ( debug ) { system . out . println ( str_ + ( char ) sw + str_ + type + str_ + set + str_ + val ) ; } }	Set the value type of the option switch to the type passed.
public static grib1gds factory ( int center , int gridnumber ) { if ( center == num_ ) { return factoryncep ( gridnumber ) ; } else throw new illegalargumentexception ( str_ + gridnumber + str_ + center ) ; }	Constructs a Grib1Gds object from a pds and predefined tables.
static public long copyb ( inputstream in , outputstream out , int buffersize ) throws ioexception { long totalbytesread = num_ ; int done = num_ , next = num_ ; byte [ ] buffer = new byte [ buffersize ] ; while ( bool_ ) { int n = in . read ( buffer ) ; if ( n == - num_ ) break ; out . write ( buffer , num_ , n ) ; totalbytesread += n ; if ( showcopy ) { done += n ; if ( done > num_ * num_ * next ) { system . out . println ( next + str_ ) ; next ++ ; } } } out . flush ( ) ; return totalbytesread ; }	copy all bytes from in to out, specify buffer size.
static public string readcontents ( inputstream is , string charset ) throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream ( num_ * default_file_buffersize ) ; io . copy ( is , bout ) ; return bout . tostring ( charset ) ; }	Read the contents from the inputStream and place into a String,with any error messages put in the return String.
static public byte [ ] readcontentstobytearray ( inputstream is ) throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream ( num_ * default_file_buffersize ) ; io . copy ( is , bout ) ; return bout . tobytearray ( ) ; }	Read the contents from the inputStream and place into a byte array,with any error messages put in the return String.
static public void writecontents ( string contents , outputstream os ) throws ioexception { bytearrayinputstream bin = new bytearrayinputstream ( contents . getbytes ( cdm . utf8charset ) ) ; io . copy ( bin , os ) ; }	Wite the contents from the String to a Stream,.
static public void copyfileb ( file filein , outputstream out , int buffersize ) throws ioexception { try ( fileinputstream fin = new fileinputstream ( filein ) ) { inputstream in = new bufferedinputstream ( fin ) ; io . copyb ( in , out , buffersize ) ; } }	copy file to output stream, specify internal buffer size.
static public long copyrafb ( ucar . unidata . io . randomaccessfile raf , long offset , long length , outputstream out , byte [ ] buffer ) throws ioexception { int buffersize = buffer . length ; long want = length ; raf . seek ( offset ) ; while ( want > num_ ) { int len = ( int ) math . min ( want , buffersize ) ; int bytesread = raf . read ( buffer , num_ , len ) ; if ( bytesread <= num_ ) break ; out . write ( buffer , num_ , bytesread ) ; want -= bytesread ; } out . flush ( ) ; return length - want ; }	Copy part of a RandomAccessFile to output stream, specify internal buffer size.
static public void copydirtree ( string fromdirname , string todirname ) throws ioexception { file fromdir = new file ( fromdirname ) ; file todir = new file ( todirname ) ; if ( ! fromdir . exists ( ) ) return ; if ( ! todir . exists ( ) ) { if ( ! todir . mkdirs ( ) ) { throw new ioexception ( str_ + todir ) ; } } file [ ] files = fromdir . listfiles ( ) ; if ( files != null ) for ( file f : files ) { if ( f . isdirectory ( ) ) copydirtree ( f . getabsolutepath ( ) , todir . getabsolutepath ( ) + str_ + f . getname ( ) ) ; else copyfile ( f . getabsolutepath ( ) , todir . getabsolutepath ( ) + str_ + f . getname ( ) ) ; } }	Copy an entire directory tree.
static public byte [ ] readfiletobytearray ( string filename ) throws ioexception { try ( fileinputstream fin = new fileinputstream ( filename ) ) { inputstream in = new bufferedinputstream ( fin ) ; return readcontentstobytearray ( in ) ; } }	Read the file and place contents into a byte array,with any error messages put in the return String.
static public string readfile ( string filename ) throws ioexception { try ( fileinputstream fin = new fileinputstream ( filename ) ) { inputstreamreader reader = new inputstreamreader ( fin , cdm . utf8charset ) ; stringwriter swriter = new stringwriter ( num_ ) ; unsynchronizedbufferedwriter writer = new unsynchronizedbufferedwriter ( swriter ) ; writer . write ( reader ) ; return swriter . tostring ( ) ; } }	Read the contents from the named file and place into a String, assuming UTF-8 encoding.
static public void writetofile ( string contents , file file ) throws ioexception { try ( fileoutputstream fout = new fileoutputstream ( file ) ) { outputstreamwriter fw = new outputstreamwriter ( fout , cdm . utf8charset ) ; unsynchronizedbufferedwriter writer = new unsynchronizedbufferedwriter ( fw ) ; writer . write ( contents ) ; writer . flush ( ) ; } }	Write String contents to a file, using UTF-8 encoding.
static public void writetofile ( string contents , string fileoutname ) throws ioexception { writetofile ( contents , new file ( fileoutname ) ) ; }	Write contents to a file, using UTF-8 encoding.
static public long writetofile ( inputstream in , string fileoutname ) throws ioexception { try ( fileoutputstream fout = new fileoutputstream ( fileoutname ) ) { outputstream out = new bufferedoutputstream ( fout ) ; return io . copy ( in , out ) ; } finally { if ( null != in ) in . close ( ) ; } }	copy input stream to file.
public void parseexceptionhandler ( parseexception pe , httpservletresponse response ) {	Turns a ParseException into a OPeNDAP DAP2 error and sends it to the client.
public void dap2exceptionhandler ( dap2exception de , httpservletresponse response ) {	Sends a OPeNDAP DAP2 error to the client.
public void badurl ( httpservletrequest request , httpservletresponse response ) throws exception { if ( debug . isset ( str_ ) ) { log . debug ( str_ ) ; }	Sends an html document to the client explaining that they have used apoorly formed URL and then the help page...
public void dogetcatalog ( reqstate rs ) throws exception { rs . getresponse ( ) . setheader ( str_ , getserverversion ( ) ) ; rs . getresponse ( ) . setcontenttype ( str_ ) ; rs . getresponse ( ) . setheader ( str_ , str_ ) ; printwriter pw = new printwriter ( new outputstreamwriter ( rs . getresponse ( ) . getoutputstream ( ) , util . utf8 ) ) ; printcatalog ( rs , pw ) ; pw . flush ( ) ; rs . getresponse ( ) . setstatus ( httpservletresponse . sc_ok ) ; }	Handler for OPeNDAP catalog.xml requests.
protected void printcatalog ( reqstate rs , printwriter os ) throws ioexception { os . println ( str_ ) ; os . println ( str_ + getserverversion ( ) ) ; }	to be overridden by servers that implement catalogs.
protected void printstatus ( printwriter os ) { os . println ( str_ + getserverversion ( ) + str_ ) ; os . println ( str_ + hitcounter + str_ ) ; if ( track ) { int n = prarr . size ( ) ; int pending = num_ ; stringbuilder preqs = new stringbuilder ( ) ; for ( int i = num_ ; i < n ; i ++ ) { reqstate rs = ( reqstate ) prarr . get ( i ) ; requestdebug reqd = ( requestdebug ) rs . getuserobject ( ) ; if ( ! reqd . done ) { preqs . append ( str_ ) ; preqs . append ( str_ ) ; preqs . append ( reqd . reqno ) ; preqs . append ( str_ ) ; preqs . append ( reqd . threaddesc ) ; preqs . append ( str_ ) ; preqs . append ( rs . tostring ( ) ) ; preqs . append ( str_ ) ; pending ++ ; } } os . println ( str_ + pending + str_ ) ; os . println ( preqs . tostring ( ) ) ; } }	to be overridden by servers that implement status report.
private void printbadurlpage ( printwriter pw ) { pw . println ( str_ ) ; pw . println ( str_ ) ; pw . println ( str_ ) ; pw . println ( str_ ) ; pw . println ( str_ ) ; pw . println ( str_ ) ; pw . println ( str_ ) ; }	Prints the Bad URL Page page to the passed PrintWriter.
public calendardate getreferencedate ( ) { return calendardate . of ( null , year , month , day , hour , minute , second ) ; }	reference reference or base time as Dare.
private array readvlendata ( variable v , section section , datastorage datastorage ) throws ioexception , invalidrangeexception { raf . seek ( datastorage . filepos ) ; int nelems = readvint ( raf ) ; array [ ] result = new array [ nelems ] ; for ( int elem = num_ ; elem < nelems ; elem ++ ) { int dsize = readvint ( raf ) ; byte [ ] data = new byte [ dsize ] ; raf . readfully ( data ) ; array dataarray = array . factory ( v . getdatatype ( ) , ( int [ ] ) null , bytebuffer . wrap ( data ) ) ; result [ elem ] = dataarray ; }	lOOK probably desnt work.
static public ncmlcollectionreader readncml ( string ncmlstring , formatter errlog ) throws ioexception { stringreader reader = new stringreader ( ncmlstring ) ; org . jdom2 . document doc ; try { saxbuilder builder = new saxbuilder ( ) ; if ( debugurl ) system . out . println ( str_ + ncmlstring + str_ ) ; doc = builder . build ( new stringreader ( ncmlstring ) ) ; } catch ( jdomexception e ) { throw new ioexception ( e . getmessage ( ) ) ; } if ( debugxml ) system . out . println ( str_ ) ; return readxml ( doc , errlog , null ) ; }	Read an NcML file from a String, and construct a NcmlCollectionReader from its scan or scanFmrc element.
static public ncmlcollectionreader open ( string ncmllocation , formatter errlog ) throws ioexception { if ( ! ncmllocation . startswith ( str_ ) && ! ncmllocation . startswith ( str_ ) ) ncmllocation = str_ + ncmllocation ; url url = new url ( ncmllocation ) ; org . jdom2 . document doc ; try { saxbuilder builder = new saxbuilder ( ) ; if ( debugurl ) system . out . println ( str_ + url + str_ ) ; doc = builder . build ( url ) ; } catch ( jdomexception e ) { throw new ioexception ( e . getmessage ( ) ) ; } if ( debugxml ) system . out . println ( str_ ) ; return readxml ( doc , errlog , ncmllocation ) ; }	Read an NcML file from a URL location, and construct a NcmlCollectionReader from its scan or scanFmrc element.
static public string allow ( string x , string allowchars , char replacechar ) { boolean ok = bool_ ; for ( int pos = num_ ; pos < x . length ( ) ; pos ++ ) { char c = x . charat ( pos ) ; if ( ! ( character . isletterordigit ( c ) || ( num_ <= allowchars . indexof ( c ) ) ) ) { ok = bool_ ; break ; } } if ( ok ) return x ;	Replace any char not alphanumeric or in allowChars by replaceChar.
public static string cleanup ( byte [ ] h ) { byte [ ] bb = new byte [ h . length ] ; int count = num_ ; for ( byte b : h ) { if ( b >= num_ && b < num_ ) bb [ count ++ ] = b ; } return new string ( bb , num_ , count , cdm . utf8charset ) ; }	Delete any non-printable characters.
static public string filter ( string x , string okchars ) { boolean ok = bool_ ; for ( int pos = num_ ; pos < x . length ( ) ; pos ++ ) { char c = x . charat ( pos ) ; if ( ! ( character . isletterordigit ( c ) || ( num_ <= okchars . indexof ( c ) ) ) ) { ok = bool_ ; break ; } } if ( ok ) { return x ; }	Remove any char not alphanumeric or in okChars.
static public string filter7bits ( string s ) { if ( s == null ) return null ; char [ ] bo = new char [ s . length ( ) ] ; int count = num_ ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( ( c < num_ ) && ( c > num_ ) || ( ( c == str_ ) || ( c == str_ ) ) ) { bo [ count ++ ] = c ; } } return new string ( bo , num_ , count ) ; }	Remove all but printable ascii.
static public string makevalidcdmobjectname ( string name ) { name = name . trim ( ) ;	transform embedded space to "_".
static public int match ( string s1 , string s2 ) { int i = num_ ; while ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { if ( s1 . charat ( i ) != s2 . charat ( i ) ) { break ; } i ++ ; } return i ; }	Count number of chars that match in two strings, starting from front.
public static string padleft ( string s , int desiredlength , string padstring ) { while ( s . length ( ) < desiredlength ) { s = padstring + s ; } return s ; }	Pad the given string with padString on the left up to the given length.
public static string padright ( string s , int desiredlength , string padstring ) { stringbuilder ret = new stringbuilder ( s ) ; while ( ret . length ( ) < desiredlength ) { ret . append ( padstring ) ; } return ret . tostring ( ) ; }	Pad the given string with padString on the right up to the given length.
static public string remove ( string s , string sub ) { int len = sub . length ( ) ; int pos ; while ( num_ <= ( pos = s . indexof ( sub ) ) ) { s = s . substring ( num_ , pos ) + s . substring ( pos + len ) ; } return s ; }	Remove all occurrences of the substring sub in the string s.
static public string remove ( string s , int c ) { if ( num_ > s . indexof ( c ) ) {	Remove all occurrences of the character c in the string s.
static public string removefromend ( string s , int c ) { if ( num_ > s . indexof ( c ) )	Remove all occurrences of the character c at the end of s.
static public string collapsewhitespace ( string s ) { int len = s . length ( ) ; stringbuilder b = new stringbuilder ( len ) ; for ( int i = num_ ; i < len ; i ++ ) { char c = s . charat ( i ) ; if ( ! character . iswhitespace ( c ) ) { b . append ( c ) ; } else { b . append ( str_ ) ; while ( ( i + num_ < len ) && character . iswhitespace ( s . charat ( i + num_ ) ) ) { i ++ ;	Collapse continuous whitespace into one single " ".
static public string replace ( string s , char out , string in ) { if ( s . indexof ( out ) < num_ ) { return s ; }	Replace any char "out" in s with "in".
static public string replace ( string x , char [ ] replacechar , string [ ] replacewith ) {	Replace all occurrences of any char in replaceChar with corresponding String in replaceWith.
public static string replace ( string string , string pattern , string value ) { if ( pattern . length ( ) == num_ ) return string ; if ( ! string . contains ( pattern ) ) return string ;	Replaces all occurrences of "pattern" in "string" with "value".
static public string substitute ( string original , string match , string subst ) { string s = original ; int pos ; while ( num_ <= ( pos = s . indexof ( match ) ) ) { stringbuilder sb = new stringbuilder ( s ) ; s = sb . replace ( pos , pos + match . length ( ) , subst ) . tostring ( ) ; } return s ; }	Find all occurrences of the "match" in original, and substitute the "subst" string.
static public string substitute ( string original , string [ ] match , string [ ] subst ) { boolean ok = bool_ ; for ( string amatch : match ) { if ( original . contains ( amatch ) ) { ok = bool_ ; break ; } } if ( ok ) { return original ; }	Find all occurences of match strings in original, and substitute the correspondingsubst string.
static public void remove ( stringbuilder sb , string out ) { int i = num_ ; while ( i < sb . length ( ) ) { int c = sb . charat ( i ) ; boolean ok = bool_ ; for ( int j = num_ ; j < out . length ( ) ; j ++ ) { if ( out . charat ( j ) == c ) { sb . delete ( i , i + num_ ) ; ok = bool_ ; break ; } } if ( ok ) i ++ ; } }	Remove any of the characters in out from sb.
static public void unreplace ( stringbuilder sb , string out , char in ) { int pos ; while ( num_ <= ( pos = sb . indexof ( out ) ) ) { sb . setcharat ( pos , in ) ; sb . delete ( pos + num_ , pos + out . length ( ) ) ; } }	Replace any String "out" in sb with char "in".
static public void replace ( stringbuilder sb , string out , string in ) { for ( int i = num_ ; i < sb . length ( ) ; i ++ ) { int c = sb . charat ( i ) ; for ( int j = num_ ; j < out . length ( ) ; j ++ ) { if ( out . charat ( j ) == c ) sb . setcharat ( i , in . charat ( j ) ) ; } } }	Replace any of the characters from out with corresponding character from in.
static public void substitute ( stringbuilder sbuff , string match , string subst ) { int pos , fromindex = num_ ; int substlen = subst . length ( ) ; int matchlen = match . length ( ) ; while ( num_ <= ( pos = sbuff . indexof ( match , fromindex ) ) ) { sbuff . replace ( pos , pos + matchlen , subst ) ; fromindex = pos + substlen ;	Find all occurences of the "match" in original, and substitute the "subst" string,directly into the original.
static public string trim ( string s , int bad ) { int len = s . length ( ) ; int st = num_ ; while ( ( st < len ) && ( s . charat ( st ) == bad ) ) { st ++ ; } while ( ( st < len ) && ( s . charat ( len - num_ ) == bad ) ) { len -- ; } return ( ( st > num_ ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; }	Remove bad char from beginning or end of string.
@ subscribe public void processevent ( collectionupdateevent event ) { if ( ! config . collectionname . equals ( event . getcollectionname ( ) ) ) return ;	called by eventBus, this is where the trigger comes in.
protected state checkstate ( ) throws ioexception { state localstate ; synchronized ( lock ) { if ( first ) { firstinit ( ) ; updatecollection ( state , config . updateconfig . updatetype ) ;	A request has come in, check that the state has been initialized.this is called from the request thread.
protected void update ( collectionupdatetype force ) throws ioexception {	Collection was changed, update internal objects.called by CollectionUpdater, trigger via handleCollectionEvent, so in a quartz scheduler thread.
@ override public java . util . list < invdataset > getdatasets ( ) { read ( ) ; return useproxy ? proxy . getdatasets ( ) : super . getdatasets ( ) ; }	Get a list of all the nested datasets.
public void release ( ) { datasets = new java . util . arraylist < > ( ) ; proxy = null ; useproxy = bool_ ; init = bool_ ; }	Release resources - undo the read of the catalog.
static public structuredatadeep copy ( structuredata sdata , structuremembers members ) { arraystructurebb abb = copytoarraybb ( sdata , members , byteorder . big_endian ) ; return new structuredatadeep ( abb ) ; }	Make deep copy from sdata to another StructureData object whose data is self contained.
static public arraystructurebb copytoarraybb ( arraystructure as , byteorder bo , boolean canonical ) throws ioexception { if ( ! canonical && as . getclass ( ) . equals ( arraystructurebb . class ) ) {	Make deep copy from an ArrayStructure to a ArrayStructureBB whose data is contained in a ByteBuffer.
static public arraystructurebb copytoarraybb ( structure s , arraystructure as , byteorder bo ) throws ioexception { structuremembers sm = s . makestructuremembers ( ) ; arraystructurebb abb = new arraystructurebb ( sm , as . getshape ( ) ) ; arraystructurebb . setoffsets ( sm ) ; if ( bo != null ) { bytebuffer bb = abb . getbytebuffer ( ) ; bb . order ( bo ) ; } try ( structuredataiterator iter = as . getstructuredataiterator ( ) ) { while ( iter . hasnext ( ) ) copytoarraybb ( iter . next ( ) , abb ) ; } return abb ; }	Make deep copy to an ArrayStructureBB whose data is contained in a ByteBuffer.Use the order of the members in the given Structure; skip copying any not in the Structure.
static public arraystructurebb copytoarraybb ( structuredata sdata ) { return copytoarraybb ( sdata , new structuremembers ( sdata . getstructuremembers ( ) ) , byteorder . big_endian ) ; }	Make deep copy from a StructureData to a ArrayStructureBB whose data is contained in a ByteBuffer.
static public arraystructurebb copytoarraybb ( structuredata sdata , structuremembers sm , byteorder bo ) { int size = sm . getstructuresize ( ) ; bytebuffer bb = bytebuffer . allocate ( size ) ;	Make deep copy from a StructureData to a ArrayStructureBB whose data is contained in a ByteBuffer.
@ override public double getforecasttimeintervalsizeinhours ( grib2pds pds ) { grib2pds . pdsinterval pdsintv = ( grib2pds . pdsinterval ) pds ;	Only use in GribVariable to decide on variable identity when intvMerge = false.By returning a constant, we dont intvMerge = false.Problem is we cant reconstruct interval length without reference time, which is not in the pds.
public coordinateaxis1d section ( range r ) throws invalidrangeexception { section section = new section ( ) . appendrange ( r ) ; coordinateaxis1d result = ( coordinateaxis1d ) section ( section ) ; int len = r . length ( ) ;	Create a new CoordinateAxis1D as a section of this CoordinateAxis1D.
static public tableanalyzer factory ( tableconfigurer tc , featuretype wantfeaturetype , netcdfdataset ds ) throws ioexception {	Create a TableAnalyser for this dataset with the given TableConfigurer.
private void analyze ( featuretype wantfeaturetype ) throws ioexception {	Make a NestedTable object for the dataset.
public boolean sync ( ) { try { if ( ! mcgridreader . init ( ) ) { return bool_ ; } gridindex index = mcgridreader . getgridindex ( ) ;	Sync and extend.
public static double [ ] getgaussianlatitudes ( string type , int start , int num ) throws illegalargumentexception { double [ ] basearray = null ; start -- ;	Get the latitude values for the given type.
static public long swaplong ( byte [ ] b , int offset ) {	Returns the long resulting from reversing 8 bytes at a specifiedoffset in a byte array.
static public float swapfloat ( byte [ ] b , int offset ) { int accum = num_ ; for ( int shiftby = num_ , i = offset ; shiftby < num_ ; shiftby += num_ , i ++ ) accum |= ( b [ i ] & num_ ) << shiftby ; return float . intbitstofloat ( accum ) ; }	Returns the float resulting from reversing 4 bytes at a specifiedoffset in a byte array.
static public char swapchar ( byte [ ] b , int offset ) {	Returns the char resulting from swapping 2 bytes at a specifiedoffset in a byte array.
protected void findcoordinateaxes ( netcdfdataset ds ) {	The attribute "coordinates" is an alias for _CoordinateAxes.
protected boolean addparameter2 ( coordinatetransform rs , string paramname , netcdffile ds , attributecontainer v , string attname , boolean readdata ) { string varname ; if ( null == ( varname = v . findattvalueignorecase ( attname , null ) ) ) { parseinfo . format ( str_ , attname ) ; return bool_ ; } varname = varname . trim ( ) ; variable datavar ; if ( null == ( datavar = ds . findvariable ( varname ) ) ) { parseinfo . format ( str_ , varname ) ; return bool_ ; } if ( readdata ) { array data ; try { data = datavar . read ( ) ; } catch ( ioexception e ) { parseinfo . format ( str_ , varname , e . getmessage ( ) ) ; return bool_ ; } double [ ] vals = ( double [ ] ) data . get1djavaarray ( datatype . double ) ; rs . addparameter ( new parameter ( paramname , vals ) ) ; } else rs . addparameter ( new parameter ( paramname , varname ) ) ; return bool_ ; }	Add a Parameter to a CoordinateTransform.
public group commonparent ( group other ) { if ( isparent ( other ) ) return this ; if ( other . isparent ( this ) ) return other ; while ( ! other . isparent ( this ) ) other = other . getparentgroup ( ) ; return other ; }	Get the common parent of this and the other group.Cant fail, since the root group is always a parent of any 2 groups.
public boolean isparent ( group other ) { while ( ( other != this ) && ( other . getparentgroup ( ) != null ) ) other = other . getparentgroup ( ) ; return ( other == this ) ; }	Is this a parent of the other Group?.
public void setparentgroup ( group parent ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; super . setparentgroup ( parent == null ? ncfile . getrootgroup ( ) : parent ) ; }	Set the Group's parent Group.
public void adddimension ( dimension dim ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( ! dim . isshared ( ) ) { throw new illegalargumentexception ( str_ ) ; } if ( finddimensionlocal ( dim . getshortname ( ) ) != null ) throw new illegalargumentexception ( str_ + dim . getshortname ( ) + str_ + getshortname ( ) ) ; dimensions . add ( dim ) ; dim . setgroup ( this ) ; }	Adds the specified shared dimension to this group.
public boolean adddimensionifnotexists ( dimension dim ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( ! dim . isshared ( ) ) { throw new illegalargumentexception ( str_ ) ; } if ( finddimensionlocal ( dim . getshortname ( ) ) != null ) return bool_ ; dimensions . add ( dim ) ; dim . setgroup ( this ) ; return bool_ ; }	Adds the specified shared dimension to this group, but only if another dimension with the same name doesn'talready exist.
public void addgroup ( group g ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( findgroup ( g . getshortname ( ) ) != null ) throw new illegalargumentexception ( str_ + g . getshortname ( ) + str_ + getshortname ( ) ) ; groups . add ( g ) ; g . setparentgroup ( this ) ;	Add a nested Group.
public void addenumeration ( enumtypedef e ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( e == null ) return ; e . setparentgroup ( this ) ; enumtypedefs . add ( e ) ; }	Add an Enumeration.
public void addvariable ( variable v ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( v == null ) return ; if ( findvariable ( v . getshortname ( ) ) != null ) {	Add a Variable.
public boolean removedimension ( string dimname ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; for ( int i = num_ ; i < dimensions . size ( ) ; i ++ ) { dimension d = dimensions . get ( i ) ; if ( dimname . equals ( d . getshortname ( ) ) ) { dimensions . remove ( d ) ; return bool_ ; } } return bool_ ; }	remove a Dimension using its name, in this group only.
public group makerelativegroup ( netcdffile ncf , string path , boolean ignorelast ) { path = path . trim ( ) ; path = path . replace ( str_ , str_ ) ; boolean isabsolute = ( path . charat ( num_ ) == str_ ) ; if ( isabsolute ) path = path . substring ( num_ ) ;	Create groups to ensure path is defined.
private string convertddsaliasfieldstodasaliasfields ( string attribute ) throws malformedaliasexception { string prefix = str_ ; vector anames = tokenizealiasfield ( attribute ) ;	This method just makes sure that the attribute field in each Aliases resolves correctlyif there ends up being a "looseEnds" Attribute Table at the top level.
public void printdas ( printwriter pw ) { das mydas = null ; try { mydas = this . getdas ( ) ; mydas . print ( pw ) ; } catch ( dasexception dase ) { pw . println ( str_ + str_ + dase . getmessage ( ) ) ; } }	Print a DAS constructed from this DDS and it's BaseType variables.
public basetype getvariable ( string name ) throws nosuchvariableexception { stack s = new stack ( ) ; s = search ( name , s ) ; return ( basetype ) s . pop ( ) ; }	Returns a reference to the named variable.
public void writegrid ( griddataset dataset , griddatatype grid , array data , boolean greyscale ) throws ioexception { gridcoordsystem gcs = grid . getcoordinatesystem ( ) ; if ( ! gcs . isregularspatial ( ) ) { throw new illegalargumentexception ( str_ + grid . getfullname ( ) ) ; } coordinateaxis1d xaxis = ( coordinateaxis1d ) gcs . getxhorizaxis ( ) ; coordinateaxis1d yaxis = ( coordinateaxis1d ) gcs . getyhorizaxis ( ) ;	Write GridDatatype data to the geotiff file.
private arrayfloat replacemissingvalues ( ismissingevaluator grid , array data , mamath . minmax dataminmax ) { float minvalue = ( float ) ( dataminmax . min - num_ ) ; arrayfloat floatarray = ( arrayfloat ) array . factory ( datatype . float , data . getshape ( ) ) ; indexiterator dataiter = data . getindexiterator ( ) ; indexiterator floatiter = floatarray . getindexiterator ( ) ; while ( dataiter . hasnext ( ) ) { float v = dataiter . getfloatnext ( ) ; if ( grid . ismissing ( ( double ) v ) ) { v = minvalue ; } floatiter . setfloatnext ( v ) ; } return floatarray ; }	Replace missing values with dataMinMax.min - 1.0; return a floating point data array.
private arraybyte replacemissingvaluesandscale ( ismissingevaluator grid , array data , mamath . minmax dataminmax ) { double scale = num_ / ( dataminmax . max - dataminmax . min ) ; arraybyte bytearray = ( arraybyte ) array . factory ( datatype . byte , data . getshape ( ) ) ; indexiterator dataiter = data . getindexiterator ( ) ; indexiterator resultiter = bytearray . getindexiterator ( ) ; byte bv ; while ( dataiter . hasnext ( ) ) { double v = dataiter . getdoublenext ( ) ; if ( grid . ismissing ( v ) ) { bv = num_ ; } else { int iv = ( int ) ( ( v - dataminmax . min ) * scale + num_ ) ; bv = ( byte ) ( iv & num_ ) ; } resultiter . setbytenext ( bv ) ; } return bytearray ; }	Replace missing values with 0; scale other values between 1 and 255, return a byte data array.
private double geoshiftgetxstart ( array lon , double inc ) { index ilon = lon . getindex ( ) ; int [ ] lonshape = lon . getshape ( ) ; indexiterator loniter = lon . getindexiterator ( ) ; double xlon = num_ ; latlonpoint p0 = new latlonpointimpl ( num_ , lon . getfloat ( ilon . set ( num_ ) ) ) ; latlonpoint pn = new latlonpointimpl ( num_ , lon . getfloat ( ilon . set ( lonshape [ num_ ] - num_ ) ) ) ; xlon = p0 . getlongitude ( ) ; while ( loniter . hasnext ( ) ) { float l = loniter . getfloatnext ( ) ; latlonpoint pn = new latlonpointimpl ( num_ , l ) ; if ( pn . getlongitude ( ) < xlon ) { xlon = pn . getlongitude ( ) ; } } if ( p0 . getlongitude ( ) == pn . getlongitude ( ) ) { xlon = xlon - inc ; } return xlon ; }	LOOK WTF ?? is this the seam crossing ??.
public void writegrid ( georeferencedarray array , boolean greyscale ) throws ioexception { coveragecoordsys gcs = array . getcoordsysfordata ( ) ; if ( ! gcs . isregularspatial ( ) ) throw new illegalargumentexception ( str_ + array . getcoveragename ( ) ) ; projection proj = gcs . getprojection ( ) ; coveragecoordaxis1d xaxis = ( coveragecoordaxis1d ) gcs . getxaxis ( ) ; coveragecoordaxis1d yaxis = ( coveragecoordaxis1d ) gcs . getyaxis ( ) ;	Write GridCoverage data to the geotiff file.
public void write ( httpservletresponse hsr ) throws ioexception { printwriter xmlresponse = hsr . getwriter ( ) ; xmlresponse . append ( str_ ) ; xmlresponse . append ( str_ + str_ + str_ ) ; xmlresponse . append ( str_ ) ; if ( locator != null ) xmlresponse . append ( str_ + locator + str_ ) ; xmlresponse . append ( str_ + exceptioncode + str_ ) ; xmlresponse . append ( str_ + text + str_ ) ; xmlresponse . append ( str_ ) ; xmlresponse . append ( str_ ) ; }	Given the information on construction, writes the necessary exception information.
private static file maketopindexfilefromconfig ( featurecollectionconfig config ) { formatter errlog = new formatter ( ) ; collectionspecparser specp = config . getcollectionspecparser ( errlog ) ; string name = stringutil2 . replace ( config . collectionname , str_ , str_ ) ;	This is only used for the top level GribCollection.
public static gribcollectiontype gettype ( randomaccessfile raf ) throws ioexception { string magic ; raf . seek ( num_ ) ; magic = raf . readstring ( grib2collectionwriter . magic_start . getbytes ( cdm . utf8charset ) . length ) ; switch ( magic ) { case grib2collectionwriter . magic_start : return gribcollectiontype . grib2 ; case grib1collectionwriter . magic_start : return gribcollectiontype . grib1 ; case grib2partitionbuilder . magic_start : return gribcollectiontype . partition2 ; case grib1partitionbuilder . magic_start : return gribcollectiontype . partition1 ; } return gribcollectiontype . none ; }	Find out what kind of index this is.
public static boolean updategribcollection ( featurecollectionconfig config , collectionupdatetype updatetype , logger logger ) throws ioexception { if ( logger == null ) logger = classlogger ; long start = system . currenttimemillis ( ) ; formatter errlog = new formatter ( ) ; collectionspecparser specp = config . getcollectionspecparser ( errlog ) ; path rootpath = paths . get ( specp . getrootdir ( ) ) ; boolean isgrib1 = config . type == featurecollectiontype . grib1 ; boolean changed ; if ( config . ptype == featurecollectionconfig . partitiontype . none || config . ptype == featurecollectionconfig . partitiontype . all ) { try ( collectionabstract dcm = new collectionpathmatcher ( config , specp , logger ) ) { changed = updategribcollection ( isgrib1 , dcm , updatetype , featurecollectionconfig . partitiontype . none , logger , errlog ) ; } } else if ( config . ptype == featurecollectionconfig . partitiontype . timeperiod ) { try ( timepartition tp = new timepartition ( config , specp , logger ) ) { changed = updatetimepartition ( isgrib1 , tp , updatetype , logger ) ; } } else {	Update Grib Collection if needed.
private static boolean updateleafcollection ( boolean isgrib1 , featurecollectionconfig config , collectionupdatetype updatetype , boolean istop , logger logger , path dirpath ) throws ioexception { if ( config . ptype == featurecollectionconfig . partitiontype . file ) { return updatefilepartition ( isgrib1 , config , updatetype , istop , logger , dirpath ) ; } else { formatter errlog = new formatter ( ) ; collectionspecparser specp = config . getcollectionspecparser ( errlog ) ; try ( directorycollection dcm = new directorycollection ( config . collectionname , dirpath , istop , config . olderthan , logger ) ) { dcm . putauxinfo ( featurecollectionconfig . aux_config , config ) ; if ( specp . getfilter ( ) != null ) dcm . setstreamfilter ( new streamfilter ( specp . getfilter ( ) , specp . getfilteronname ( ) ) ) ; boolean changed = updategribcollection ( isgrib1 , dcm , updatetype , featurecollectionconfig . partitiontype . directory , logger , errlog ) ; logger . debug ( str_ , changed , dirpath ) ; return changed ; } } }	Update all the gbx indices in one directory, and the ncx index for that directory.
private static gribcollectionimmutable opengribcollectionfromdatafile ( boolean isgrib1 , randomaccessfile dataraf , featurecollectionconfig config , collectionupdatetype updatetype , formatter errlog , org . slf4j . logger logger ) throws ioexception { string filename = dataraf . getlocation ( ) ; file datafile = new file ( filename ) ; mfile mfile = new mfileos ( datafile ) ; return opengribcollectionfromdatafile ( isgrib1 , mfile , updatetype , config , errlog , logger ) ; }	Open a grib collection from a single grib1 or grib2 file.Create the gbx9 and ncx2 files if needed.
@ nullable public static gribcollectionimmutable opengribcollectionfromdatafile ( boolean isgrib1 , mfile mfile , collectionupdatetype updatetype , featurecollectionconfig config , formatter errlog , org . slf4j . logger logger ) throws ioexception { mcollection dcm = new collectionsinglefile ( mfile , logger ) ; dcm . putauxinfo ( featurecollectionconfig . aux_config , config ) ; if ( isgrib1 ) { grib1collectionbuilder builder = new grib1collectionbuilder ( dcm . getcollectionname ( ) , dcm , logger ) ;	from a single file, read in the index, create if it doesnt exist; return null on failure.
static boolean urlmatch ( url pattern , url url ) { int relation ; if ( pattern == null ) return ( url == null ) ; if ( ! ( url . gethost ( ) . endswith ( pattern . gethost ( ) ) ) ) return bool_ ;	Match has different semantics than urlCompare.
static synchronized public void add ( string key , string value , string url ) { if ( key == null ) return ; if ( ! initialized ) rc . initialize ( ) ; triple t = new triple ( key , value , url ) ; dfaltrc . insert ( t ) ;	Allow users to add to the default rc.
static synchronized public string find ( string key , string url ) { if ( key == null ) return null ; if ( ! initialized ) rc . initialize ( ) ; triple t = dfaltrc . lookup ( key , url ) ; return ( t == null ? null : t . value ) ; }	Allow users to search the default rc.
static void setwellknown ( ) { if ( dfaltrc . triplestore . size ( ) == num_ ) return ;	Record some well known parameters.
public triple insert ( triple t ) { if ( t . key == null ) return null ; list < triple > list = triplestore . get ( t . key ) ; if ( list == null ) list = new arraylist < triple > ( ) ; triple prev = addtriple ( list , t ) ; triplestore . put ( t . key , list ) ; return prev ; }	Allow for external loading.
public list < dataset > getdatasetslocal ( ) { list < dataset > datasets = ( list < dataset > ) flds . get ( dataset . datasets ) ; return datasets == null ? new arraylist < > ( num_ ) : datasets ; }	Get top level datasets contained directly in this catalog.Do not dereference catRefs.
public dataset finddatasetbyname ( string name ) { for ( dataset ds : getdatasets ( ) ) { if ( ds . getname ( ) . equals ( name ) ) return ds ; dataset result = ds . finddatasetbyname ( name ) ; if ( result != null ) return result ; } return null ; }	Look though all datasets here or under here. do not go into catrefs.
public void setprojection ( projectionimpl project ) { displayproject = project ; if ( featsetlist == null ) return ; iterator iter = featsetlist . iterator ( ) ; while ( iter . hasnext ( ) ) { featureset fs = ( featureset ) iter . next ( ) ; fs . newprojection = bool_ ; } }	Sets new projection for subsequent drawing.
protected iterator getshapes ( java . awt . graphics2d g , affinetransform normal2device ) { long starttime = system . currenttimemillis ( ) ; if ( featsetlist == null ) { initfeatsetlist ( ) ; assert ! featsetlist . isempty ( ) ; }	we have to deal with both projections and resolution-dependence.
private arraylist makeshapes ( iterator featlist ) { shape shape ; arraylist shapelist = new arraylist ( ) ; projectionimpl dataproject = getdataprojection ( ) ; if ( debug . isset ( str_ ) ) { system . out . println ( str_ + displayproject ) ; } while ( featlist . hasnext ( ) ) { abstractgisfeature feature = ( abstractgisfeature ) featlist . next ( ) ; if ( dataproject . islatlon ( ) )	make an ArrayList of Shapes from the given featureList and current display Projection.
public final int compareto ( string string ) { return getid ( ) . length ( ) >= string . length ( ) ? getid ( ) . comparetoignorecase ( string ) : getid ( ) . comparetoignorecase ( string . substring ( num_ , getid ( ) . length ( ) ) ) ; }	Compares this PrefixName with a string.
public boolean startprogressmonitortask ( progressmonitortask pmt ) { if ( busy ) return bool_ ; busy = bool_ ; this . task = pmt ; iscancelled = bool_ ; count = num_ ; seticon ( icon [ num_ ] ) ;	The given task is run in a background thread.Progress is indicated once a second.You cannot call this method again till the task is completed.
private boolean needsupdate ( collectionupdatetype ff , file collectionindexfile ) throws ioexception { long collectionlastmodified = collectionindexfile . lastmodified ( ) ; set < string > newfileset = new hashset < > ( ) ; for ( mcollection dcm : partitionmanager . makepartitions ( collectionupdatetype . test ) ) { string partitionindexfilename = stringutil2 . replace ( dcm . getindexfilename ( gribcdmindex . ncx_suffix ) , str_ , str_ ) ; file partitionindexfile = gribindexcache . getexistingfileorcache ( partitionindexfilename ) ; if ( partitionindexfile == null )	LOOK need an option to only scan latest last partition or something.
static public void normalize ( enscoord result , list < enscoord > eclist ) { list < enscoord > extra = new arraylist < > ( ) ; for ( enscoord ec : eclist ) { if ( ! result . equalsdata ( ec ) ) {	Extend result with all the values in the list of EnsCoord.
public void setobject ( int index , object value ) { if ( sdata == null ) sdata = new structuredata [ nelems ] ; sdata [ index ] = ( structuredata ) value ; }	Set the index-th StructureData of this ArrayStructure.
public structuredata getstructuredata ( int index ) { if ( sdata == null ) sdata = new structuredata [ nelems ] ; if ( index >= sdata . length ) throw new illegalargumentexception ( index + str_ + sdata . length ) ; if ( sdata [ index ] == null ) sdata [ index ] = makestructuredata ( this , index ) ; return sdata [ index ] ; }	Get the index-th StructureData of this ArrayStructure.
protected void copystructures ( int recnum , structuremembers . member m , indexiterator result ) { array data = getarray ( recnum , m ) ; indexiterator dataiter = data . getindexiterator ( ) ; while ( dataiter . hasnext ( ) ) result . setobjectnext ( dataiter . getobjectnext ( ) ) ; }	member data is itself a structure, and may be an array of structures.
public object getscalarobject ( int recno , structuremembers . member m ) { datatype datatype = m . getdatatype ( ) ; if ( datatype == datatype . double ) { return getscalardouble ( recno , m ) ; } else if ( datatype == datatype . float ) { return getscalarfloat ( recno , m ) ; } else if ( datatype . getprimitiveclasstype ( ) == byte . class ) { return getscalarbyte ( recno , m ) ; } else if ( datatype . getprimitiveclasstype ( ) == short . class ) { return getscalarshort ( recno , m ) ; } else if ( datatype . getprimitiveclasstype ( ) == int . class ) { return getscalarint ( recno , m ) ; } else if ( datatype . getprimitiveclasstype ( ) == long . class ) { return getscalarlong ( recno , m ) ; } else if ( datatype == datatype . char ) { return getscalarstring ( recno , m ) ; } else if ( datatype == datatype . string ) { return getscalarstring ( recno , m ) ; } else if ( datatype == datatype . structure ) { return getscalarstructure ( recno , m ) ; } else if ( datatype == datatype . opaque ) { arrayobject data = ( arrayobject ) m . getdataarray ( ) ; return data . getobject ( recno * m . getsize ( ) ) ;	Get member data array of any type as an Object, eg, Float, Double, String, StructureData etc.
public double convertscalardouble ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) == datatype . double ) return getscalardouble ( recnum , m ) ; if ( m . getdatatype ( ) == datatype . float ) return ( double ) getscalarfloat ( recnum , m ) ; object o = getscalarobject ( recnum , m ) ; if ( o instanceof number ) return ( ( number ) o ) . doublevalue ( ) ; throw new forbiddenconversionexception ( str_ + m . getdatatype ( ) + str_ ) ; }	Get scalar value as a double, with conversion as needed.
public int convertscalarint ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) == datatype . int || m . getdatatype ( ) == datatype . uint ) return getscalarint ( recnum , m ) ; if ( m . getdatatype ( ) == datatype . short ) return ( int ) getscalarshort ( recnum , m ) ; if ( m . getdatatype ( ) == datatype . ushort ) return datatype . unsignedshorttoint ( getscalarshort ( recnum , m ) ) ; if ( m . getdatatype ( ) == datatype . byte ) return ( int ) getscalarbyte ( recnum , m ) ; if ( m . getdatatype ( ) == datatype . ubyte ) return ( int ) datatype . unsignedbytetoshort ( getscalarbyte ( recnum , m ) ) ; if ( m . getdatatype ( ) == datatype . long || m . getdatatype ( ) == datatype . ulong ) return ( int ) getscalarlong ( recnum , m ) ; object o = getscalarobject ( recnum , m ) ; if ( o instanceof number ) return ( ( number ) o ) . intvalue ( ) ; throw new forbiddenconversionexception ( str_ + m . getdatatype ( ) + str_ ) ; }	Get scalar value as an int, with conversion as needed.
public float getscalarfloat ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) != datatype . float ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; array data = m . getdataarray ( ) ; return data . getfloat ( recnum * m . getsize ( ) ) ;	Get scalar member data of type float.
public byte getscalarbyte ( int recnum , structuremembers . member m ) { if ( ! ( m . getdatatype ( ) . getprimitiveclasstype ( ) == byte . class ) ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; array data = m . getdataarray ( ) ; return data . getbyte ( recnum * m . getsize ( ) ) ;	Get scalar member data of type byte.
public short getscalarshort ( int recnum , structuremembers . member m ) { if ( ! ( m . getdatatype ( ) . getprimitiveclasstype ( ) == short . class ) ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; array data = m . getdataarray ( ) ; return data . getshort ( recnum * m . getsize ( ) ) ;	Get scalar member data of type short.
public char getscalarchar ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) != datatype . char ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; array data = m . getdataarray ( ) ; return data . getchar ( recnum * m . getsize ( ) ) ;	Get scalar member data of type char.
public string getscalarstring ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) == datatype . char ) { arraychar data = ( arraychar ) m . getdataarray ( ) ; return data . getstring ( recnum ) ; } if ( m . getdatatype ( ) == datatype . string ) { array data = m . getdataarray ( ) ; return ( string ) data . getobject ( recnum ) ; } throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; }	Get member data of type String or char.
public arraystructure getarraystructure ( int recnum , structuremembers . member m ) { if ( ( m . getdatatype ( ) != datatype . structure ) && ( m . getdatatype ( ) != datatype . sequence ) ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; if ( m . getdatatype ( ) == datatype . sequence ) return getarraysequence ( recnum , m ) ; arraystructure array = ( arraystructure ) m . getdataarray ( ) ; int count = m . getsize ( ) ; structuredata [ ] this_sdata = new structuredata [ count ] ; for ( int i = num_ ; i < count ; i ++ ) this_sdata [ i ] = array . getstructuredata ( recnum * count + i ) ;	Get member data of type array of Structure.
public arraysequence getarraysequence ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) != datatype . sequence ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ;	Get member data of type ArraySequence.
public arrayobject getarrayobject ( int recnum , structuremembers . member m ) { if ( m . getdatatype ( ) != datatype . opaque ) throw new illegalargumentexception ( str_ + m . getdatatype ( ) + str_ ) ; arrayobject array = ( arrayobject ) m . getdataarray ( ) ; return ( arrayobject ) array . getobject ( recnum ) ;	Get member data of type ArrayObject.
static protected long minmax ( long value , long min , long max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; }	Peg a value to either the min or maxdepending on sign.
protected object eval ( dapvariable var , dapsequence seq , datacursor record , ceast expr ) throws dapexception { switch ( expr . sort ) { case constant : return expr . value ; case segment : return fieldvalue ( var , seq , record , expr . name ) ; case expr : object lhs = eval ( var , seq , record , expr . lhs ) ; object rhs = ( expr . rhs == null ? null : eval ( var , seq , record , expr . rhs ) ) ; if ( rhs != null ) switch ( expr . op ) { case lt : return compare ( lhs , rhs ) < num_ ; case le : return compare ( lhs , rhs ) <= num_ ; case gt : return compare ( lhs , rhs ) > num_ ; case ge : return compare ( lhs , rhs ) >= num_ ; case eq : return lhs . equals ( rhs ) ; case neq : return ! lhs . equals ( rhs ) ; case req : return lhs . tostring ( ) . matches ( rhs . tostring ( ) ) ; case and : return ( ( boolean ) lhs ) && ( ( boolean ) rhs ) ; } else switch ( expr . op ) { case not : return ! ( ( boolean ) lhs ) ; } } throw new dapexception ( str_ ) ; }	Evaluate a filter with respect to a Sequence record.Assumes the filter has been canonicalized so thatthe lhs is a variable.
public string toconstraintstring ( ) { stringbuilder buf = new stringbuilder ( ) ; boolean first = bool_ ; for ( int i = num_ ; i < segments . size ( ) ; i ++ ) { segment seg = segments . get ( i ) ; if ( ! seg . var . istoplevel ( ) ) continue ; if ( ! first ) buf . append ( str_ ) ; first = bool_ ; dumpvar ( seg , buf , bool_ ) ; } return buf . tostring ( ) ; }	Convert the view to a constraint string suitablefor use in a URL, except not URL encoded.
public boolean references ( dapnode node ) { boolean isref = bool_ ; switch ( node . getsort ( ) ) { case dimension : dapdimension dim = this . redef . get ( ( dapdimension ) node ) ; if ( dim == null ) dim = ( dapdimension ) node ; isref = this . dimrefs . contains ( dim ) ; break ; case enumeration : isref = ( this . enums . contains ( ( dapenumeration ) node ) ) ; break ; case variable : isref = ( findvariableindex ( ( dapvariable ) node ) >= num_ ) ; break ; case group : case dataset : isref = ( this . groups . contains ( ( dapgroup ) node ) ) ; break ; default : break ; } return isref ; }	Reference X match.
protected boolean matches ( dapvariable var , dapsequence seq , datacursor rec , ceast filter ) throws dapexception { object value = eval ( var , seq , rec , filter ) ; return ( ( boolean ) value ) ; }	Evaluate a filter with respect to a Sequence record.
protected int expansioncount ( dapstructure struct ) { int count = num_ ; for ( dapvariable field : struct . getfields ( ) ) { if ( findvariableindex ( field ) >= num_ ) count ++ ; } return count ; }	Count the number of fields of a structure thatalready in this view.
protected void computeenums ( ) { for ( int i = num_ ; i < variables . size ( ) ; i ++ ) { dapvariable var = variables . get ( i ) ; if ( var . getsort ( ) != dapsort . variable ) continue ; daptype daptype = var . getbasetype ( ) ; if ( ! daptype . isenumtype ( ) ) continue ; if ( ! this . enums . contains ( ( dapenumeration ) daptype ) ) this . enums . add ( ( dapenumeration ) daptype ) ; } }	Walk all the included variables and accumulatethe referenced enums.
protected void computegroups ( ) {	Walk all the included declarationsand accumulate the set of referenced groups.
static public ceconstraint compile ( string sce , dapdataset dmr ) throws dapexception {	Static Utility for compiling a constraint string.
@ override public boolean isvalidfile ( randomaccessfile raf ) throws ioexception { if ( raf instanceof httprandomaccessfile ) {	accept grib2 or ncx files.
private void makeactionssystem ( ) { abstractaction cleardebugflagsaction = new abstractaction ( ) { public void actionperformed ( actionevent e ) { } } ; bamutil . setactionproperties ( cleardebugflagsaction , null , str_ , bool_ , str_ , - num_ ) ; }	actions that are system-wide.
public int getbyteorder ( int kmachn ) { if ( ( kmachn == mtvax ) || ( kmachn == mtultx ) || ( kmachn == mtalph ) || ( kmachn == mtlnux ) || ( kmachn == mtigph ) ) { return randomaccessfile . little_endian ; } return randomaccessfile . big_endian ; }	Get the byte order for the machine type.
void setbyteorder ( ) { string arch = system . getproperty ( str_ ) ; if ( arch . equals ( str_ ) ||	LOOK WTF ??Set the machine type for this system.
public key findkey ( string name ) { if ( keys == null ) { return null ; }	Find a key with the given name.
public dmfileheaderinfo findfileheader ( string name ) { if ( ( fileheaderinfo == null ) || fileheaderinfo . isempty ( ) ) { return null ; } for ( dmfileheaderinfo fhi : fileheaderinfo ) { if ( name . equals ( fhi . kfhnam ) ) { return fhi ; } } return null ; }	Find the file header with this name.
public float [ ] getfileheader ( string name ) throws ioexception { dmfileheaderinfo fh = findfileheader ( name ) ; if ( ( fh == null ) || ( fh . kfhtyp != mdreal ) ) { return null ; } int knt = fileheaderinfo . indexof ( fh ) ;	Read in the values for the file header.
public void printparts ( ) { if ( parts == null ) { return ; } for ( int i = num_ ; i < parts . size ( ) ; i ++ ) { system . out . println ( str_ + i + str_ ) ; system . out . println ( parts . get ( i ) ) ; } }	Print the part information.
public int getdatapointer ( int irow , int icol , string partname ) { int ipoint = - num_ ; if ( ( irow < num_ ) || ( irow > dmlabel . krow ) || ( icol < num_ ) || ( icol > dmlabel . kcol ) ) { system . out . println ( str_ + irow + str_ + icol ) ; return ipoint ; } int iprt = getpartnumber ( partname ) ; if ( iprt == num_ ) { system . out . println ( str_ ) ; return ipoint ; }	Get the pointer to the data. Taken from DM_RDTR.
public float dm_rflt ( int word ) throws ioexception { if ( rf == null ) { throw new ioexception ( str_ ) ; } if ( dmlabel == null ) { throw new ioexception ( str_ ) ; } rf . seek ( getoffset ( word ) ) ; if ( needtoswap ) {	Read a float.
public string dm_rstr ( int isword , int nchar ) throws ioexception { if ( rf == null ) { throw new ioexception ( str_ ) ; } rf . seek ( getoffset ( isword ) ) ; return rf . readstring ( nchar ) ; }	Read a String.
public float [ ] dm_unpk ( dmpart part , int [ ] ibitst ) { int nparms = part . kparms ; int nwordp = part . kwordp ; int npack = ( ibitst . length - num_ ) / nwordp + num_ ; if ( npack * nwordp != ibitst . length ) {	Unpack an array of packed integers.
protected static string getbits ( int b ) { formatter s = new formatter ( ) ; for ( int i = num_ ; i >= num_ ; i -- ) { if ( ( b & ( num_ << i ) ) != num_ ) { s . format ( str_ ) ; } else { s . format ( str_ ) ; } if ( i % num_ == num_ ) { s . format ( str_ ) ; } } return s . tostring ( ) ; }	Get a bit string for an integer.
public static void writetochannel ( netcdffile ncfile , writablebytechannel wbc ) throws ioexception , invalidrangeexception { dataoutputstream stream = new dataoutputstream ( new bufferedoutputstream ( channels . newoutputstream ( wbc ) , num_ ) ) ;	Write ncfile to a WritableByteChannel.
private void parsebase ( element e , string indent ) throws dasexception , nosuchtypeexception , badsemanticsexception { parselevel ++ ; string type = e . getname ( ) ; if ( type . equals ( str_ ) ) {	This method recursively travels through the DOM tree, locatingBaseType derived nodes and placing them in the DDS.
private void parsegrid ( element gridelement , string indent ) throws dasexception , nosuchtypeexception , badsemanticsexception { parselevel ++ ;	Grids are unusual examples of DConstructor and require specialhandling when parsing.
private void parsealiases ( element e , string indent ) throws dasexception { parselevel ++ ; string subindent = indent + str_ ; if ( _debug ) system . out . println ( indent + str_ ) ; if ( _debug ) system . out . println ( subindent + str_ + currentbt . gettypename ( ) + str_ + currentbt . getclearname ( ) ) ;	Parse all of the Alias tags in this element of the XML document.Add each one to the correct Attribute Table.
private list < datadescriptor > decode ( list < short > keydesc , bufrtablelookup lookup ) { if ( keydesc == null ) return null ; list < datadescriptor > keys = new arraylist < datadescriptor > ( ) ; for ( short id : keydesc ) { datadescriptor dd = new datadescriptor ( id , lookup ) ; keys . add ( dd ) ; if ( dd . f == num_ ) { tabled . descriptor tdd = lookup . getdescriptortabled ( dd . fxy ) ; if ( tdd == null || tdd . getsequence ( ) == null ) { dd . bad = bool_ ; } else { dd . name = tdd . getname ( ) ; dd . subkeys = decode ( tdd . getsequence ( ) , lookup ) ; } } } return keys ; }	convert ids to DataDescriptors, expand table D.
private list < datadescriptor > replicate ( list < datadescriptor > keys ) { list < datadescriptor > tree = new arraylist < datadescriptor > ( ) ; iterator < datadescriptor > dkiter = keys . iterator ( ) ; while ( dkiter . hasnext ( ) ) { datadescriptor dk = dkiter . next ( ) ; if ( dk . f == num_ ) { dk . subkeys = new arraylist < datadescriptor > ( ) ; dk . replication = dk . y ;	look for replication, move replicated items into subtree.
public string getdatasetfilename ( ) { string s = getencodedname ( ) ; system . out . println ( s ) ; return ( s ) ; }	Get the dataset filename.
public string getcffeaturetype ( ) { if ( gemreader . getfilesubtype ( ) . equals ( gempaksurfacefilereader . ship ) ) { return cf . featuretype . point . tostring ( ) ; } return cf . featuretype . timeseries . tostring ( ) ; }	Get the CF feature type.
public static boolean nearlyequalsabs ( float a , float b , float maxabsdiff ) { return absolutedifference ( a , b ) <= math . abs ( maxabsdiff ) ; }	Check if two numbers are nearly equal with given absolute tolerance.
@ override public boolean references ( dapnode node ) { switch ( node . getsort ( ) ) { case dimension : case enumeration : case variable : case group : case dataset : return bool_ ; default : break ; } return bool_ ; }	Selected consult or iterator overrides for efficiency.
public final unit parse ( final string spec ) throws nosuchunitexception , unitparseexception , specificationexception , unitdbexception , prefixdbexception , unitsystemexception { synchronized ( mutex ) { return parse ( spec , unitdbmanager . instance ( ) ) ; } }	Parses a unit specification.
private boolean istiled ( variable v ) { for ( dimension d : v . getdimensions ( ) ) { for ( range r : section . getranges ( ) ) { if ( d . getshortname ( ) . equals ( r . getname ( ) ) ) return bool_ ; } } return bool_ ; }	a variable is tiled if any of its dimensions are tiled.
public coordinatetimeabstract makebestfromcomplete ( ) { int [ ] best = new int [ time2runtime . length ] ; int last = - num_ ; int count = num_ ; for ( int i = num_ ; i < time2runtime . length ; i ++ ) { int time = time2runtime [ i ] ; if ( time >= last ) { last = time ; best [ i ] = time ; count ++ ; } else { best [ i ] = - num_ ; } } return makebestfromcomplete ( best , count ) ; }	Implements coverting a "complete best" to a "monotonic best".The reftime is not allowed to decrease.
public projectionrect [ ] latlontoprojrect ( latlonrect latlonr ) { double lat0 = latlonr . getlowerleftpoint ( ) . getlatitude ( ) ; double height = math . abs ( latlonr . getupperrightpoint ( ) . getlatitude ( ) - lat0 ) ; double width = latlonr . getwidth ( ) ; double lon0 = latlonpointimpl . lonnormal ( latlonr . getlowerleftpoint ( ) . getlongitude ( ) , centerlon ) ; double lon1 = latlonpointimpl . lonnormal ( latlonr . getupperrightpoint ( ) . getlongitude ( ) , centerlon ) ; projectionrect [ ] rects = new projectionrect [ ] { new projectionrect ( ) , new projectionrect ( ) } ; if ( lon0 < lon1 ) { rects [ num_ ] . setrect ( lon0 , lat0 , width , height ) ; rects [ num_ ] = null ; } else { double y = centerlon + num_ - lon0 ; rects [ num_ ] . setrect ( lon0 , lat0 , y , height ) ; rects [ num_ ] . setrect ( lon1 - width + y , lat0 , width - y , height ) ; } return rects ; }	Split a latlon rectangle to the equivalent ProjectionRectusing this LatLonProjection to split it at the seam if needed.
private void showtimeseriesall ( java . util . list < logreader . log > logs ) { timeseries bytessentdata = new timeseries ( str_ , minute . class ) ; timeseries timetookdata = new timeseries ( str_ , minute . class ) ; timeseries nreqdata = new timeseries ( str_ , minute . class ) ; string intervals = str_ ;	construct the TImeSeries plot for the list of logs passed in.
static public map < string , attribute > makemap ( list < attribute > atts ) { int size = ( atts == null ) ? num_ : atts . size ( ) ; map < string , attribute > result = new hashmap < > ( size ) ; if ( atts == null ) return result ; for ( attribute att : atts ) result . put ( att . getshortname ( ) , att ) ; return result ; }	Turn a list into a map.
public array getvalues ( ) { if ( values == null && svalue != null ) { values = array . factory ( datatype . string , new int [ ] { num_ } ) ; values . setobject ( values . getindex ( ) , svalue ) ; } return values ; }	Get the value as an Array.
public number getnumericvalue ( int index ) { if ( ( index < num_ ) || ( index >= nelems ) ) return null ;	Retrieve a numeric value by index.
protected void writecdl ( formatter f , boolean strict , string parentname ) { if ( strict && ( isstring ( ) || this . getenumtype ( ) != null ) )	Write CDL representation into f.
private void setstringvalue ( string val ) { if ( val == null ) throw new illegalargumentexception ( str_ ) ;	set the value as a String, trimming trailing zeroes.
public void setvalues ( array arr ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( arr == null ) { datatype = datatype . string ; return ; } if ( arr . getelementtype ( ) == char . class ) {	set the values from an Array.
public void scan ( ) throws ioexception { if ( state == num_ ) throw new illegalstateexception ( str_ ) ; if ( state >= num_ ) throw new illegalstateexception ( str_ ) ; state = num_ ;	Scan the collection and gather information on contained datasets.
public invcatalogimpl generateproxydsresolvercatalog ( proxydatasethandler pdh ) { if ( state != num_ ) throw new illegalstateexception ( str_ ) ; if ( ! proxydshandlers . containsvalue ( pdh ) ) throw new illegalargumentexception ( str_ ) ;	Generate the catalog for a resolver request of the given ProxyDatasetHandler.
void schedulewrite ( message m ) { q . add ( m ) ; if ( ! isscheduled . getandset ( bool_ ) ) { executor . submit ( this ) ; } }	put a message on the queue, schedule writing if not already scheduled.
private void setthreddsdatatype ( thredds . client . catalog . dataset invdataset , string wants ) { if ( invdataset == null ) return ; boolean wantsviewer = wants . equals ( str_ ) ; boolean wantscoordsys = wants . equals ( str_ ) ; try {	Jump to the appropriate tab based on datatype of InvDataset.
private void jumptothreddsdatatype ( thredds . client . catalog . access invaccess ) { if ( invaccess == null ) { return ; } thredds . client . catalog . service s = invaccess . getservice ( ) ; if ( s . gettype ( ) == servicetype . httpserver ) { downloadfile ( invaccess . getstandardurlname ( ) ) ; return ; } if ( s . gettype ( ) == servicetype . wms ) { openwmsdataset ( invaccess . getstandardurlname ( ) ) ; return ; } if ( s . gettype ( ) == servicetype . cdmrfeature ) { opencoveragedataset ( invaccess . getwrappedurlname ( ) ) ; return ; } thredds . client . catalog . dataset ds = invaccess . getdataset ( ) ; if ( ds . getfeaturetype ( ) == null ) {	jump to the appropriate tab based on datatype of InvAccess.
private static void preparegui ( ) { final string osname = system . getproperty ( str_ ) . tolowercase ( ) ; final boolean ismacos = osname . startswith ( str_ ) ; if ( ismacos ) { system . setproperty ( str_ , str_ ) ;	Set look-and-feel.
private static void createtoolsframe ( ) {	Must call this method on the event thread.
static public string makename ( list < coordinateaxis > axes ) { list < coordinateaxis > axessorted = new arraylist < > ( axes ) ; collections . sort ( axessorted , new coordinateaxis . axiscomparator ( ) ) ; stringbuilder buff = new stringbuilder ( ) ; for ( int i = num_ ; i < axessorted . size ( ) ; i ++ ) { coordinateaxis axis = axessorted . get ( i ) ; if ( i > num_ ) buff . append ( str_ ) ; buff . append ( axis . getfullnameescaped ( ) ) ; } return buff . tostring ( ) ; }	Create standard name from list of axes. Sort the axes first.
private coordinateaxis lesserrank ( coordinateaxis a1 , coordinateaxis a2 ) { if ( a1 == null ) return a2 ; return ( a1 . getrank ( ) <= a2 . getrank ( ) ) ? a1 : a2 ; }	prefer smaller ranks, in case more than one.
public coordinateaxis findaxis ( axistype type ) { coordinateaxis result = null ; for ( coordinateaxis axis : coordaxes ) { axistype axistype = axis . getaxistype ( ) ; if ( ( axistype != null ) && ( axistype == type ) ) result = lesserrank ( result , axis ) ; } return result ; }	Find the CoordinateAxis that has the given AxisType.If more than one, return the one with lesser rank.
public projectionct getprojectionct ( ) { for ( coordinatetransform ct : coordtrans ) { if ( ct instanceof projectionct ) return ( projectionct ) ct ; } return null ; }	Find the first ProjectionCT from the list of CoordinateTransforms.
public boolean isgeoxy ( ) { if ( ( xaxis == null ) || ( yaxis == null ) ) return bool_ ; return null != getprojection ( ) && ! ( projection instanceof latlonprojection ) ; }	true if it has X and Y CoordinateAxis, and a CoordTransform Projection.
public boolean isregular ( ) { for ( coordinateaxis axis : coordaxes ) { if ( ! ( axis instanceof coordinateaxis1d ) ) return bool_ ; if ( ! ( ( coordinateaxis1d ) axis ) . isregular ( ) ) return bool_ ; } return bool_ ; }	true if all axes are CoordinateAxis1D and are regular.
public static boolean issubset ( collection < dimension > subset , collection < dimension > set ) { for ( dimension d : subset ) { if ( ! ( set . contains ( d ) ) ) return bool_ ; } return bool_ ; }	Test if all the Dimensions in subset are in set.
public boolean containsaxes ( list < coordinateaxis > wantaxes ) { for ( coordinateaxis ca : wantaxes ) { if ( ! containsaxis ( ca . getfullname ( ) ) ) return bool_ ; } return bool_ ; }	Do we have all the axes in the list?.
public boolean containsaxis ( string axisname ) { for ( coordinateaxis ca : coordaxes ) { if ( ca . getfullname ( ) . equals ( axisname ) ) return bool_ ; } return bool_ ; }	Do we have the named axis?.
public boolean containsdomain ( list < dimension > wantdimensions ) { for ( dimension d : wantdimensions ) { if ( ! domain . contains ( d ) ) return bool_ ; } return bool_ ; }	Do we have all the dimensions in the list?.
public boolean containsaxistypes ( list < axistype > wantaxes ) { for ( axistype wantaxistype : wantaxes ) { if ( ! containsaxistype ( wantaxistype ) ) return bool_ ; } return bool_ ; }	Do we have all the axes types in the list?.
public boolean containsaxistype ( axistype wantaxistype ) { for ( coordinateaxis ca : coordaxes ) { if ( ca . getaxistype ( ) == wantaxistype ) return bool_ ; } return bool_ ; }	Do we have an axes of the given type?.
public dapnode clonedag ( clonemap map ) throws clonenotsupportedexception { dapnode node = ( dapnode ) super . clone ( ) ;	This procedure does the actual recursive clone.
public object getselectedbean ( ) { int viewrowindex = jtable . getselectedrow ( ) ; if ( viewrowindex < num_ ) return null ; int modelrowindex = jtable . convertrowindextomodel ( viewrowindex ) ; return ( modelrowindex < num_ ) || ( modelrowindex >= beans . size ( ) ) ? null : beans . get ( modelrowindex ) ; }	Get the currently selected bean, or null if none selected.
public list getselectedbeans ( ) { arraylist < object > list = new arraylist < > ( ) ; int [ ] viewrowindices = jtable . getselectedrows ( ) ; for ( int viewrowindex : viewrowindices ) { int modelrowindex = jtable . convertrowindextomodel ( viewrowindex ) ; list . add ( beans . get ( modelrowindex ) ) ; if ( debugselected ) system . out . println ( str_ + modelrowindex + str_ + beans . get ( modelrowindex ) ) ; } return list ; }	Get the currently selected beans. Use this for multiple selection.
public arraylist < object > getselectedcells ( ) { arraylist < object > list = new arraylist < > ( ) ; int [ ] viewrowindices = jtable . getselectedrows ( ) ; int [ ] viewcolumnindices = jtable . getselectedcolumns ( ) ; for ( int i = num_ ; i < viewrowindices . length ; i ++ ) for ( int j = num_ ; i < viewcolumnindices . length ; j ++ ) { int modelrowindex = jtable . convertrowindextomodel ( viewrowindices [ i ] ) ; int modelcolumnindex = jtable . convertcolumnindextomodel ( viewcolumnindices [ j ] ) ; list . add ( model . getvalueat ( modelrowindex , modelcolumnindex ) ) ; } return list ; }	Get the currently selected cells.Use this for multiple row selection, when columnSelection is on.
public void setselectedbean ( object bean ) { if ( bean == null ) return ; int modelrowindex = beans . indexof ( bean ) ; int viewrowindex = jtable . convertrowindextoview ( modelrowindex ) ; if ( viewrowindex >= num_ ) jtable . getselectionmodel ( ) . setselectioninterval ( viewrowindex , viewrowindex ) ; makerowvisible ( viewrowindex ) ; }	Set which row is selected.
protected void restorestate ( ) { if ( store == null ) { return ; } arraylist propcolobjs = ( arraylist ) store . getbean ( str_ , new arraylist ( ) ) ; hidabletablecolumnmodel tablecolumnmodel = ( hidabletablecolumnmodel ) jtable . getcolumnmodel ( ) ; int newviewindex = num_ ; for ( object propcolobj : propcolobjs ) { propertycol propcol = ( propertycol ) propcolobj ; try { int currentviewindex = tablecolumnmodel . getcolumnindex ( propcol . getname ( ) ) ;	Restore state from PreferencesExt.
public static unknownunit create ( string name ) throws nameexception { unknownunit unit ; name = name . tolowercase ( ) ; synchronized ( map ) { unit = map . get ( name ) ; if ( unit == null ) { unit = new unknownunit ( name ) ; map . put ( unit . getname ( ) , unit ) ; map . put ( unit . getplural ( ) , unit ) ; } } return unit ; }	Factory method for constructing an unknown unit from a name.
@ override public void close ( ) throws ioexception { if ( closed ) return ; closed = bool_ ; try { consume ( ) ; } finally { super . close ( ) ; } if ( method != null ) method . close ( ) ; }	Closes this input stream and releases any system resources associatedwith the stream; closes the method also.
private boolean isextra ( variable v ) { return v != null && extras != null && extras . contains ( v ) ; }	Has v already been added to the set of extra variables?.
private boolean iscoordinate ( variable v ) { if ( v == null ) return bool_ ; string name = v . getshortname ( ) ; return ( latve != null && latve . axisname . equals ( name ) ) || ( lonve != null && lonve . axisname . equals ( name ) ) || ( altve != null && altve . axisname . equals ( name ) ) || ( stnaltve != null && stnaltve . axisname . equals ( name ) ) || ( timeve != null && timeve . axisname . equals ( name ) ) || ( nomtimeve != null && nomtimeve . axisname . equals ( name ) ) ; }	Is v a coordinate axis for this feature type?.
private coordvarextractor findcoordinateaxis ( table . coordname coordname , table t , int nestinglevel ) { if ( t == null ) return null ; string axisname = t . findcoordinatevariablename ( coordname ) ; if ( axisname != null ) { variableds v = t . findvariable ( axisname ) ; if ( v != null ) return new coordvarextractorvariable ( v , axisname , nestinglevel ) ; if ( t . extrajoins != null ) { for ( join j : t . extrajoins ) { v = j . findvariable ( axisname ) ; if ( v != null ) return new coordvarextractorvariable ( v , axisname , nestinglevel ) ; } }	find a coord axis of the given type in the table and its parents.
private void adddatavariables ( list < variablesimpleif > list , table t ) { if ( t . parent != null ) adddatavariables ( list , t . parent ) ; for ( variablesimpleif col : t . cols . values ( ) ) { if ( t . nondatavars . contains ( col . getfullname ( ) ) ) continue ; if ( t . nondatavars . contains ( col . getshortname ( ) ) ) continue ;	use recursion so that parent variables come first.
void addparentjoin ( cursor cursor ) throws ioexception { int level = cursor . currentindex ; table t = gettable ( level ) ; if ( t . extrajoins != null ) { list < structuredata > sdata = new arraylist < > ( num_ ) ; sdata . add ( cursor . tabledata [ level ] ) ; for ( join j : t . extrajoins ) { sdata . add ( j . getjoindata ( cursor ) ) ; } cursor . tabledata [ level ] = structuredatafactory . make ( sdata . toarray ( new structuredata [ sdata . size ( ) ] ) ) ;	add table join to this cursor level.
stationfeature makestation ( structuredata stationdata ) { if ( stnve . ismissing ( stationdata ) ) return null ; string stationname = stnve . getcoordvalueasstring ( stationdata ) ; string stationdesc = ( stndescve == null ) ? str_ : stndescve . getcoordvalueasstring ( stationdata ) ; string stnwmoid = ( wmove == null ) ? str_ : wmove . getcoordvalueasstring ( stationdata ) ; double lat = latve . getcoordvalue ( stationdata ) ; double lon = lonve . getcoordvalue ( stationdata ) ; double elev = ( stnaltve == null ) ? double . nan : stnaltve . getcoordvalue ( stationdata ) ;	also called from StandardPointFeatureIterator.
public nodemap < cdmnode , dapnode > create ( ) throws dapexception {	Do the conversion and return a NodeMaprepresenting the conversion.
static public simpleunit factory ( string name ) { try { return factorywithexceptions ( name ) ; } catch ( exception e ) { if ( debugparse ) system . out . println ( str_ + name + str_ + e ) ; return null ; } }	Create a SimpleUnit from the given name, catch Exceptions.
static public simpleunit factorywithexceptions ( string name ) throws unitexception { unitformat format = unitformatmanager . instance ( ) ; unit uu = format . parse ( name ) ;	Create a SimpleUnit from the given name, allow Exceptions.
static public boolean iscompatiblewithexceptions ( string unitstring1 , string unitstring2 ) throws unitexception { unitformat format = unitformatmanager . instance ( ) ; unit uu1 = format . parse ( unitstring1 ) ; unit uu2 = format . parse ( unitstring2 ) ; return uu1 . iscompatible ( uu2 ) ; }	Return true if unitString1 is convertible to unitString2.
static public boolean isdateunit ( ucar . units . unit uu ) { boolean ok = uu . iscompatible ( datereferenceunit ) ; if ( ! ok ) return bool_ ; try { uu . getconverterto ( datereferenceunit ) ; return bool_ ; } catch ( conversionexception e ) { return bool_ ; } }	Return true if this ucar.units.Unit is a Date.
static public boolean istimeunit ( string unitstring ) { simpleunit su = factory ( unitstring ) ; return su != null && istimeunit ( su . getunit ( ) ) ; }	Return true if the given unit is a time Unit, eg "seconds".
static public double getconversionfactor ( string inputunitstring , string outputunitstring ) throws illegalargumentexception { simpleunit inputunit = simpleunit . factory ( inputunitstring ) ; simpleunit outputunit = simpleunit . factory ( outputunitstring ) ; return inputunit . convertto ( num_ , outputunit ) ; }	Get the conversion factor to convert inputUnit to outputUnit.
public double convertto ( double value , simpleunit outputunit ) throws illegalargumentexception { try { return uu . convertto ( value , outputunit . getunit ( ) ) ; } catch ( conversionexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } }	Convert given value of this unit to the new unit.
public boolean isunknownunit ( ) { ucar . units . unit uu = getunit ( ) ; if ( uu instanceof ucar . units . unknownunit ) return bool_ ; if ( uu instanceof ucar . units . derivedunit ) return isunknownunit ( ( ucar . units . derivedunit ) uu ) ; if ( uu instanceof ucar . units . scaledunit ) { ucar . units . scaledunit scu = ( ucar . units . scaledunit ) uu ; unit u = scu . getunit ( ) ; if ( u instanceof ucar . units . unknownunit ) return bool_ ; if ( u instanceof ucar . units . derivedunit ) return isunknownunit ( ( ucar . units . derivedunit ) u ) ; } return bool_ ; }	Is this an instance of an UnknownUnit?.
public double getvalue ( ) { if ( ! ( uu instanceof scaledunit ) ) return double . nan ; scaledunit offset = ( scaledunit ) uu ; return offset . getscale ( ) ; }	Extract the value, can only be called for ScaledUnit.
public toplevelclause newrelopclause ( int operator , subclause lhs , list rhs ) throws dap2serversideexception { return new relopclause ( operator , lhs , rhs ) ; }	Generates a clause which which compares subclauses, using one of therelative operators supported by the Operator class.
public toplevelclause newboolfunctionclause ( string functionname , list children ) throws dap2serversideexception , nosuchfunctionexception { boolfunction function = functionlibrary . getboolfunction ( functionname ) ; if ( function == null ) { if ( functionlibrary . getbtfunction ( functionname ) != null ) { throw new nosuchfunctionexception ( str_ + functionname + str_ + str_ + str_ ) ; } else { throw new nosuchfunctionexception ( str_ + functionname + str_ ) ; } } return new boolfunctionclause ( function , children ) ; }	Generates a clause which invokes a function that returns aboolean value.
public subclause newbtfunctionclause ( string functionname , list children ) throws dap2serversideexception , nosuchfunctionexception { btfunction function = functionlibrary . getbtfunction ( functionname ) ; if ( function == null ) { if ( functionlibrary . getboolfunction ( functionname ) != null ) { throw new nosuchfunctionexception ( str_ + functionname + str_ + str_ ) ; } else { throw new nosuchfunctionexception ( str_ + functionname + str_ ) ; } } return new btfunctionclause ( function , children ) ; }	Generates a clause which invokes a function that returns aBaseType.
public static java . awt . image . bufferedimage makegrayscaleimage ( array ma , ismissingevaluator misseval ) { if ( ma . getrank ( ) < num_ ) return null ; if ( ma . getrank ( ) == num_ ) ma = ma . reduce ( ) ; if ( ma . getrank ( ) == num_ ) ma = ma . slice ( num_ , num_ ) ;	Adapt a rank 2 array into a java.awt.image.BufferedImage.If passed a rank 3 array, take first 2D slice.
public int crawl ( invcatalogimpl cat , canceltask task , printwriter out , object context ) { if ( out != null ) out . println ( str_ + cat . getcreatefrom ( ) ) ; countcatrefs = num_ ; for ( invdataset ds : cat . getdatasets ( ) ) { if ( type == type . all ) crawldataset ( ds , task , out , context , bool_ ) ; else crawldirectdatasets ( ds , task , out , context , bool_ ) ; if ( ( task != null ) && task . iscancel ( ) ) break ; } return num_ + countcatrefs ; }	Crawl a catalog thats already been opened.When you get to a dataset containing leaf datasets, do all, only the first, or a randomly chosen one.
public void crawldataset ( invdataset ds , canceltask task , printwriter out , object context , boolean release ) { boolean iscatref = ( ds instanceof invcatalogref ) ; if ( filter != null && filter . skipall ( ds ) ) { if ( iscatref && release ) ( ( invcatalogref ) ds ) . release ( ) ; return ; } boolean isdatascan = ds . findproperty ( str_ ) != null ; if ( iscatref ) { invcatalogref catref = ( invcatalogref ) ds ; if ( out != null ) out . println ( str_ + catref . geturi ( ) + str_ + ds . getname ( ) + str_ ) ; countcatrefs ++ ; if ( ! listen . getcatalogref ( catref , context ) ) { if ( release ) catref . release ( ) ; return ; } } if ( ! iscatref || isdatascan ) listen . getdataset ( ds , context ) ;	Crawl this dataset recursively, return all datasets.
public void crawldirectdatasets ( invdataset ds , canceltask task , printwriter out , object context , boolean release ) { boolean iscatref = ( ds instanceof invcatalogref ) ; if ( filter != null && filter . skipall ( ds ) ) { if ( iscatref && release ) ( ( invcatalogref ) ds ) . release ( ) ; return ; } if ( iscatref ) { invcatalogref catref = ( invcatalogref ) ds ; if ( out != null ) out . println ( str_ + catref . geturi ( ) + str_ + ds . getname ( ) + str_ ) ; countcatrefs ++ ; if ( ! listen . getcatalogref ( catref , context ) ) { if ( release ) catref . release ( ) ; return ; } }	Crawl this dataset recursively. Only send back direct datasets.
public static file getfileorcache ( string filelocation ) { file result = getexistingfileorcache ( filelocation ) ; if ( result != null ) return result ; return getdiskcache2 ( ) . getfile ( filelocation ) ; }	Get index file, may be in cache directory, may not exist.
public static file getexistingfileorcache ( string filelocation ) { file result = getdiskcache2 ( ) . getexistingfileorcache ( filelocation ) ; if ( result == null && grib . debuggbxindexonly && filelocation . endswith ( str_ ) ) {	Looking for an existing file, in cache or not.
static public void setdebugleaks ( boolean b ) { if ( b ) { count_openfiles . set ( num_ ) ; maxopenfiles . set ( num_ ) ; allfiles = new hashset < > ( num_ ) ; } debugleaks = b ; }	Debugging, do not use in production.Set counters to zero, set debugging on.
static public list < string > getallfiles ( ) { if ( null == allfiles ) return null ; list < string > result = new arraylist < > ( ) ; result . addall ( allfiles ) ; collections . sort ( result ) ; return result ; }	Debugging, do not use.
public synchronized void close ( ) throws ioexception { if ( cache != null ) { if ( cachestate > num_ ) { if ( cachestate == num_ ) { cachestate = num_ ; if ( cache . release ( this ) )	Close the file, and release any associated system resources.
public void seek ( long pos ) throws ioexception { if ( pos < num_ ) throw new java . io . ioexception ( str_ ) ;	Set the position in the file for the next read or write.
public void flush ( ) throws ioexception { if ( buffermodified ) { file . seek ( bufferstart ) ; file . write ( buffer , num_ , datasize ) ;	Copy the contents of the buffer to the disk.
public int read ( ) throws ioexception {	Read a byte of data from the file, blocking until data isavailable.
public final void readshort ( short [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { pa [ start + i ] = readshort ( ) ; } }	Read an array of shorts.
public final int readintunbuffered ( long pos ) throws ioexception { byte [ ] bb = new byte [ num_ ] ; read_ ( pos , bb , num_ , num_ ) ; int ch1 = bb [ num_ ] & num_ ; int ch2 = bb [ num_ ] & num_ ; int ch3 = bb [ num_ ] & num_ ; int ch4 = bb [ num_ ] & num_ ; if ( ( ch1 | ch2 | ch3 | ch4 ) < num_ ) { throw new eofexception ( ) ; } if ( bigendian ) { return ( ( ch1 << num_ ) + ( ch2 << num_ ) + ( ch3 << num_ ) + ( ch4 ) ) ; } else { return ( ( ch4 << num_ ) + ( ch3 << num_ ) + ( ch2 << num_ ) + ( ch1 ) ) ; } }	Read an integer at the given position, bypassing all buffering.
public final void readint ( int [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { pa [ start + i ] = readint ( ) ; } }	Read an array of ints.
public final void readlong ( long [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { pa [ start + i ] = readlong ( ) ; } }	Read an array of longs.
public final void readfloat ( float [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { pa [ start + i ] = float . intbitstofloat ( readint ( ) ) ; } }	Read an array of floats.
public final void readdouble ( double [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { pa [ start + i ] = double . longbitstodouble ( readlong ( ) ) ; } }	Read an array of doubles.
public string readstring ( int nbytes ) throws ioexception { byte [ ] data = new byte [ nbytes ] ; readfully ( data ) ; return new string ( data , cdm . utf8charset ) ; }	Read a String of known length.
public string readstringmax ( int nbytes ) throws ioexception { byte [ ] b = new byte [ nbytes ] ; readfully ( b ) ; int count ; for ( count = num_ ; count < nbytes ; count ++ ) if ( b [ count ] == num_ ) break ; return new string ( b , num_ , count , cdm . utf8charset ) ; }	Read a String of max length, zero terminate.
public final void writeboolean ( boolean [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writeboolean ( pa [ start + i ] ) ; } }	Write an array of booleans.
public final void writeshort ( short [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writeshort ( pa [ start + i ] ) ; } }	Write an array of shorts.
public final void writechar ( char [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writechar ( pa [ start + i ] ) ; } }	Write an array of chars.
public final void writeint ( int [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writeint ( pa [ start + i ] ) ; } }	Write an array of ints.
public final void writelong ( long [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writelong ( pa [ start + i ] ) ; } }	Write an array of longs.
public final void writefloat ( float [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writefloat ( pa [ start + i ] ) ; } }	Write an array of floats.
public final void writedouble ( double [ ] pa , int start , int n ) throws ioexception { for ( int i = num_ ; i < n ; i ++ ) { writedouble ( pa [ start + i ] ) ; } }	Write an array of doubles.
public final void writebytes ( string s ) throws ioexception { int len = s . length ( ) ; for ( int i = num_ ; i < len ; i ++ ) { write ( ( byte ) s . charat ( i ) ) ; } }	Writes the string to the file as a sequence of bytes.
public final void writebytes ( char b [ ] , int off , int len ) throws ioexception { for ( int i = off ; i < len ; i ++ ) { write ( ( byte ) b [ i ] ) ; } }	Writes the character array to the file as a sequence of bytes.
public boolean searchforward ( kmpmatch match , int maxbytes ) throws ioexception { long start = getfilepointer ( ) ; long last = ( maxbytes < num_ ) ? length ( ) : math . min ( length ( ) , start + maxbytes ) ; long needtoscan = last - start ;	Search forward from the current pos, looking for a match.
public void appendquery ( stringbuffer sbuff , arraylist values ) { if ( template != null ) appendqueryfromtemplate ( sbuff , values ) ; else appendqueryfromparamvalue ( sbuff , values ) ; }	Create the selector result string, and append.
static public mcollection factory ( featurecollectionconfig config , path topdir , boolean istop , indexreader indexreader , string suffix , org . slf4j . logger logger ) throws ioexception { directorybuilder builder = new directorybuilder ( config . collectionname , topdir . tostring ( ) , suffix ) ; directorypartition dpart = new directorypartition ( config , topdir , istop , indexreader , suffix , logger ) ; if ( ! builder . isleaf ( indexreader ) ) {	returns a DirectoryPartition or DirectoryCollection.
public boolean findindex ( ) throws ioexception { path indexpath = paths . get ( dir . tostring ( ) , partitionname + suffix ) ; if ( files . exists ( indexpath ) ) { this . index = indexpath ; basicfileattributes attr = files . readattributes ( indexpath , basicfileattributes . class ) ; this . indexlastmodified = attr . lastmodifiedtime ( ) ; this . indexsize = attr . size ( ) ; return bool_ ; } return bool_ ; }	Find the index file, using its canonical name.
private boolean isleaf ( indexreader indexreader ) throws ioexception { if ( partitionstatus == partitionstatus . unknown ) { int countdir = num_ , countfile = num_ , count = num_ ; try ( directorystream < path > dirstream = files . newdirectorystream ( dir ) ) { iterator < path > iterator = dirstream . iterator ( ) ; while ( iterator . hasnext ( ) && count ++ < num_ ) { path p = iterator . next ( ) ; basicfileattributes attr = files . readattributes ( p , basicfileattributes . class ) ; if ( attr . isdirectory ( ) ) countdir ++ ; else countfile ++ ; } } partitionstatus = ( countfile > countdir ) ? partitionstatus . isleaf : partitionstatus . isdirectorypartition ; } return partitionstatus == partitionstatus . isleaf ; }	Scans first 100 files to decide if its a leaf.
public list < directorybuilder > constructchildren ( indexreader indexreader , collectionupdatetype forcecollection ) throws ioexception { if ( childrenconstructed ) return children ; if ( index != null && forcecollection == collectionupdatetype . nocheck ) {	Find all children directories.
private void scanforchildren ( ) { if ( debug ) system . out . printf ( str_ , dir ) ; int count = num_ ; try ( directorystream < path > ds = files . newdirectorystream ( dir ) ) { for ( path p : ds ) { basicfileattributes attr = files . readattributes ( p , basicfileattributes . class ) ; if ( attr . isdirectory ( ) ) { children . add ( new directorybuilder ( topcollectionname , p , attr , suffix ) ) ; if ( debug && ( ++ count % num_ == num_ ) ) system . out . printf ( str_ , count ) ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( debug ) system . out . printf ( str_ , count ) ; childrenconstructed = bool_ ; }	Scan for subdirectories, make each into a DirectoryBuilder and add as a child.
public list < mfile > readfilesfromindex ( indexreader indexreader ) throws ioexception { list < mfile > result = new arraylist < > ( num_ ) ; if ( index == null ) return result ; indexreader . readmfiles ( index , result ) ; return result ; }	read the list of files from the index.
public list < ucar . nc2 . dt . griddataset . gridset > getgridsets ( ) { return new arraylist < ucar . nc2 . dt . griddataset . gridset > ( gridsethash . values ( ) ) ; }	Return GridDatatype objects grouped by GridCoordSys.
public filecacheable acquire ( filefactory factory , dataseturl durl , ucar . nc2 . util . canceltask canceltask ) throws ioexception { return acquire ( factory , durl . trueurl , durl , - num_ , canceltask , null ) ; }	Acquire a FileCacheable, and lock it so no one else can use it.call FileCacheable.close when done.
private void remove ( cacheelement . cachefile want ) { want . remove ( ) ; files . remove ( want . ncfile ) ; try { want . ncfile . setfilecache ( null ) ;	LOOK should you remove the entire CacheElement ?.
@ override public void eject ( object hashkey ) { if ( disabled . get ( ) ) return ;	Remove all instances of object from the cache.
@ override public boolean release ( filecacheable ncfile ) throws ioexception { if ( ncfile == null ) return bool_ ; if ( disabled . get ( ) ) { ncfile . setfilecache ( null ) ;	Release the file. This unlocks it, updates its lastAccessed date.Normally applications need not call this, just close the file as usual.The FileCacheable has to do tricky stuff.
private static int int4 ( int a , int b , int c , int d ) {	Convert 4 bytes into a signed integer.
private cacheelement updateincache ( cacheelement elem ) { if ( shadowcache . firstkey ( ) == elem ) return elem ; elem . updateaccessed ( ) ; cacheelement prev = shadowcache . put ( elem , elem ) ;	get CacheElement specified by hashKey.
public synchronized void clearcache ( boolean force ) { list < cacheelement . cachefile > deletelist = new arraylist < > ( num_ * cache . size ( ) ) ; if ( force ) { cache . clear ( ) ;	Remove all cache entries.
void makeverticaltransform ( griddataset gds , formatter parseinfo ) { if ( vt != null ) return ;	we have to delay making these, since we dont identify the dimensions specifically until now.
@ override public boolean isgloballon ( ) { if ( ! islatlon ) return bool_ ; if ( ! ( horizxaxis instanceof coordinateaxis1d ) ) return bool_ ; coordinateaxis1d lon = ( coordinateaxis1d ) horizxaxis ; double first = lon . getcoordedge ( num_ ) ; double last = lon . getcoordedge ( ( int ) lon . getsize ( ) ) ; double min = math . min ( first , last ) ; double max = math . max ( first , last ) ; return ( max - min ) >= num_ ; }	Is this a global coverage over longitude ?.
@ override public boolean iszpositive ( ) { if ( vertzaxis == null ) return bool_ ; if ( vertzaxis . getpositive ( ) != null ) { return vertzaxis . getpositive ( ) . equalsignorecase ( ucar . nc2 . constants . cf . positive_up ) ; } if ( vertzaxis . getaxistype ( ) == axistype . height ) return bool_ ; return vertzaxis . getaxistype ( ) != axistype . pressure ; }	true if increasing z coordinate values means "up" in altitude.
@ override public int [ ] findxyindexfromcoord ( double x_coord , double y_coord , int [ ] result ) { if ( result == null ) result = new int [ num_ ] ; if ( ( horizxaxis instanceof coordinateaxis1d ) && ( horizyaxis instanceof coordinateaxis1d ) ) { result [ num_ ] = ( ( coordinateaxis1d ) horizxaxis ) . findcoordelement ( x_coord ) ; result [ num_ ] = ( ( coordinateaxis1d ) horizyaxis ) . findcoordelement ( y_coord ) ; return result ; } else if ( ( horizxaxis instanceof coordinateaxis2d ) && ( horizyaxis instanceof coordinateaxis2d ) ) { if ( g2d == null ) g2d = new gridcoordinate2d ( ( coordinateaxis2d ) horizyaxis , ( coordinateaxis2d ) horizxaxis ) ; int [ ] result2 = new int [ num_ ] ; boolean found = g2d . findcoordelement ( y_coord , x_coord , result2 ) ; if ( found ) { result [ num_ ] = result2 [ num_ ] ; result [ num_ ] = result2 [ num_ ] ; } else { result [ num_ ] = - num_ ; result [ num_ ] = - num_ ; } return result ; }	Given a point in x,y coordinate space, find the x,y index in the coordinate system.
@ override public int [ ] findxyindexfromcoordbounded ( double x_coord , double y_coord , int [ ] result ) { if ( result == null ) result = new int [ num_ ] ; if ( ( horizxaxis instanceof coordinateaxis1d ) && ( horizyaxis instanceof coordinateaxis1d ) ) { result [ num_ ] = ( ( coordinateaxis1d ) horizxaxis ) . findcoordelementbounded ( x_coord ) ; result [ num_ ] = ( ( coordinateaxis1d ) horizyaxis ) . findcoordelementbounded ( y_coord ) ; return result ; } else if ( ( horizxaxis instanceof coordinateaxis2d ) && ( horizyaxis instanceof coordinateaxis2d ) ) { if ( g2d == null ) g2d = new gridcoordinate2d ( ( coordinateaxis2d ) horizyaxis , ( coordinateaxis2d ) horizxaxis ) ; int [ ] result2 = new int [ num_ ] ; g2d . findcoordelement ( y_coord , x_coord , result2 ) ;	Given a point in x,y coordinate space, find the x,y index in the coordinate system.If outside the range, the closest point is returned, eg, 0 or n-1 depending on if the coordinate is too small or too large.
@ override public int [ ] findxyindexfromlatlon ( double lat , double lon , int [ ] result ) { projection dataprojection = getprojection ( ) ; projectionpoint pp = dataprojection . latlontoproj ( new latlonpointimpl ( lat , lon ) , new projectionpointimpl ( ) ) ; return findxyindexfromcoord ( pp . getx ( ) , pp . gety ( ) , result ) ; }	Given a lat,lon point, find the x,y index in the coordinate system.
@ override public int [ ] findxyindexfromlatlonbounded ( double lat , double lon , int [ ] result ) { projection dataprojection = getprojection ( ) ; projectionpoint pp = dataprojection . latlontoproj ( new latlonpointimpl ( lat , lon ) , new projectionpointimpl ( ) ) ; return findxyindexfromcoordbounded ( pp . getx ( ) , pp . gety ( ) , result ) ; }	Given a lat,lon point, find the x,y index in the coordinate system.If outside the range, the closest point is returned.
protected int getitempos ( ) { if ( nitems < num_ ) return - arrow_size ;	return slider indicator position for currently selected item.
protected int getitem ( int pixel ) { if ( nitems < num_ ) return num_ ; int eff_width = b . width - num_ * arrow_size ;	return item selected by this pixel position.
public void iterateovermfilecollection ( visitor visit ) throws ioexception { if ( debug ) system . out . printf ( str_ , collectiondir ) ; int count = num_ ; try ( directorystream < path > ds = files . newdirectorystream ( collectiondir , new mystreamfilter ( ) ) ) { for ( path p : ds ) { try { basicfileattributes attr = files . readattributes ( p , basicfileattributes . class ) ; if ( ! attr . isdirectory ( ) ) visit . consume ( new mfileos7 ( p ) ) ; if ( debug ) system . out . printf ( str_ , count ++ ) ; } catch ( ioexception ioe ) {	this idiom keeps the iterator from escaping, so that we can use try-with-resource, and ensure DirectoryStream closes. like++.
public void getremotefiles ( final canceltask _cancel ) { this . cancel = _cancel ; string urls = config . getserverprefix ( ) + str_ + type + str_ ; ta . append ( string . format ( str_ , urls ) ) ; string contents = null ; try ( httpmethod method = httpfactory . get ( session , urls ) ) { int statuscode = method . execute ( ) ; if ( statuscode == num_ ) contents = method . getresponseasstring ( ) ; if ( ( contents == null ) || ( contents . length ( ) == num_ ) ) { ta . append ( string . format ( str_ , urls ) ) ; return ; } else { ta . append ( string . format ( str_ , urls , contents ) ) ; } } catch ( throwable t ) { ta . append ( string . format ( str_ , urls , t . getmessage ( ) ) ) ; t . printstacktrace ( ) ; return ; }	copy remote files to localDir.
@ override public string getsubcentername ( int center , int subcenter ) { switch ( subcenter ) { case num_ : return null ; case num_ : return str_ ; case num_ : return str_ ; } return super . getsubcentername ( center , subcenter ) ; }	LOOK maybe combine grib1, grib2 and bufr ??.
public static calendarperiod . field fromunitstring ( string udunit ) { udunit = udunit . trim ( ) ; udunit = udunit . tolowercase ( ) ; if ( udunit . equals ( str_ ) ) return field . second ; if ( udunit . equals ( str_ ) ) return field . millisec ;	Convert a period string into a CalendarPeriod.Field.
public static calendarperiod of ( int value , field field ) { calendarperiod want = new calendarperiod ( value , field ) ; if ( cache == null ) return want ; calendarperiod got = cache . getifpresent ( want ) ; if ( got != null ) return got ; cache . put ( want , want ) ; return want ; }	minimize memory use by interning. wacko shit in GribPartitionBuilder TimeCoordinate, whoduhthunk?.
public static calendarperiod of ( string udunit ) { int value ; string units ; string [ ] split = stringutil2 . splitstring ( udunit ) ; if ( split . length == num_ ) { value = num_ ; units = split [ num_ ] ; } else if ( split . length == num_ ) { try { value = integer . parseint ( split [ num_ ] ) ; } catch ( throwable t ) { return null ; } units = split [ num_ ] ; } else return null ; calendarperiod . field unit = calendarperiod . fromunitstring ( units ) ; return calendarperiod . of ( value , unit ) ; }	Convert a udunit period string into a CalendarPeriod.
public int subtract ( calendardate start , calendardate end ) { long diff = end . getdifferenceinmsecs ( start ) ; int thislen = millisecs ( ) ; if ( ( diff % thislen != num_ ) ) log . warn ( str_ ) ; return ( int ) ( diff / thislen ) ; }	Subtract two dates, return difference in units of this period.If not even, will round down and log a warning.
public double getconvertfactor ( calendarperiod from ) { if ( field == calendarperiod . field . month || field == calendarperiod . field . year ) { log . warn ( str_ ) ; } return ( double ) from . millisecs ( ) / millisecs ( ) ; }	Get the conversion factor of the other CalendarPeriod to this one.
public double getvalueinmillisecs ( ) { if ( field == calendarperiod . field . month ) return num_ * num_ * num_ * num_ * num_ * value ; else if ( field == calendarperiod . field . year ) return num_ * num_ * num_ * num_ * num_ * value ; else return millisecs ( ) ; }	Get the duration in milliseconds -+.
public int getoffset ( calendardate start , calendardate end ) { if ( start . equals ( end ) ) return num_ ; long start_millis = start . getdatetime ( ) . getmillis ( ) ; long end_millis = end . getdatetime ( ) . getmillis ( ) ;	start + offset = end.
public boolean sync ( ) throws ioexception { if ( ( gemreader . getinitfilesize ( ) < raf . length ( ) ) && extendindex ) { gemreader . init ( bool_ ) ; gridindex index = gemreader . getgridindex ( ) ;	Sync the file.
private void inittables ( ) { try { gempakgridparametertable . addparameters ( str_ ) ; gempakgridparametertable . addparameters ( str_ ) ; } catch ( exception e ) { system . out . println ( str_ ) ; } }	Initialize the parameter tables.
private boolean put ( datarootext daterootext ) { map . put ( daterootext . getpath ( ) , daterootext ) ; return treeset . add ( daterootext . getpath ( ) ) ; }	Add a dataRootExt to in-memory tree.
public string findlongestpathmatch ( string reqpath ) { sortedset < string > tail = treeset . tailset ( reqpath ) ; if ( tail . isempty ( ) ) return null ; string after = tail . first ( ) ; if ( reqpath . startswith ( after ) )	Find the longest path match.
public dataroot finddataroot ( string reqpath ) { string path = findlongestpathmatch ( reqpath ) ; if ( path == null ) return null ; datarootext datarootext = map . get ( path ) ; if ( datarootext == null ) { logger . error ( str_ , path ) ; return null ; } return convert2dataroot ( datarootext ) ; }	Find the longest DataRoot match.
public @ nonnull dataroot convert2dataroot ( datarootext datarootext ) { dataroot dataroot = datarootext . getdataroot ( ) ; if ( dataroot != null ) return dataroot ;	convert a dataRootExt to a dataRoot.
public calendardaterange getcalendardaterange ( calendar cal ) { if ( daterange == null ) return null ; if ( cal . equals ( calendar . getdefault ( ) ) ) return daterange ;	return requested CalendarDateRange.
public list < integer > reindex ( list < coordinate > coords ) { list < integer > result = new arraylist < > ( ) ; for ( coordinate coord : coords ) { coordinate sub = swap . get ( coord ) ; coordinate use = ( sub == null ) ? coord : sub ; integer idx = indexmap . get ( use ) ;	redo the variables against the shared coordinates.
static public netcdffilewriter createnew ( version version , string location , nc4chunking chunker ) throws ioexception { return new netcdffilewriter ( version , location , bool_ , chunker ) ; }	Create a new Netcdf file, with fill mode true.
public group addgroup ( group parent , string name ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; if ( parent == null ) return ncfile . getrootgroup ( ) ; group result = new group ( ncfile , parent , name ) ; parent . addgroup ( result ) ; return result ; }	Add a Group to the file.
public enumtypedef addtypedef ( group g , enumtypedef td ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; if ( ! version . isextendedmodel ( ) ) throw new illegalargumentexception ( str_ + version ) ; g . addenumeration ( td ) ; return td ; }	Add a EnumTypedef to the file.
public attribute deletegroupattribute ( group g , string attname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; if ( g == null ) g = ncfile . getrootgroup ( ) ; attribute att = g . findattribute ( attname ) ; if ( null == att ) return null ; g . remove ( att ) ; return att ; }	Delete a group Attribute.
public attribute renamegroupattribute ( group g , string oldname , string newname ) { if ( ! definemode ) throw new unsupportedoperationexception ( str_ ) ; if ( ! isvalidobjectname ( newname ) ) { string newnewname = createvalidobjectname ( newname ) ; log . warn ( str_ + newname + str_ + newnewname ) ; newname = newnewname ; } if ( g == null ) g = ncfile . getrootgroup ( ) ; attribute att = g . findattribute ( oldname ) ; if ( null == att ) return null ; g . remove ( att ) ; att = new attribute ( newname , att . getvalues ( ) ) ; g . addattribute ( att ) ; return att ; }	Rename a group Attribute.
public structure addrecordstructure ( ) { if ( version != version . netcdf3 ) return null ; boolean ok = ( boolean ) ncfile . sendiospmessage ( netcdffile . iosp_message_add_record_structure ) ; if ( ! ok ) throw new illegalstateexception ( str_ ) ; return ( structure ) ncfile . findvariable ( str_ ) ; }	For netcdf3 only, take all unlimited variables and make them into a structure.
public void abort ( ) throws java . io . ioexception { if ( spiw != null ) { spiw . close ( ) ; spiw = null ; } }	Abort writing to this file.
public void writeproperties ( printwriter out ) throws ioexception { if ( p == null ) p = beanparser . getparser ( o . getclass ( ) ) ; p . writeproperties ( o , out ) ; }	write XML using the bean properties of the contained object.
public threddsmetadata extract ( dataset threddsdataset ) throws ioexception { threddsmetadata metadata = new threddsmetadata ( ) ; map < string , object > flds = metadata . getflds ( ) ; try ( datafactory . result result = new datafactory ( ) . openfeaturedataset ( threddsdataset , null ) ) { if ( result . fatalerror ) { logger . warn ( str_ , result . errlog ) ; return null ; } if ( result . featuretype . iscoveragefeaturetype ( ) ) { griddataset griddataset = ( griddataset ) result . featuredataset ;	extract info from underlying feature dataset.
@ override protected unit mydivideinto ( final unit that ) throws operationexception { return that instanceof offsetunit ? getunit ( ) . divideinto ( ( ( offsetunit ) that ) . getunit ( ) ) : getunit ( ) . divideinto ( that ) ; }	Divide this unit into another unit.
public double toderivedunit ( final double amount ) throws conversionexception { if ( ! ( _unit instanceof derivableunit ) ) { throw new conversionexception ( this , getderivedunit ( ) ) ; } return ( ( derivableunit ) getunit ( ) ) . toderivedunit ( amount + getoffset ( ) ) ; }	Converts a value in this unit to the equivalent value in the convertiblederived unit.
public double fromderivedunit ( final double amount ) throws conversionexception { if ( ! ( _unit instanceof derivableunit ) ) { throw new conversionexception ( getderivedunit ( ) , this ) ; } return ( ( derivableunit ) getunit ( ) ) . fromderivedunit ( amount ) - getoffset ( ) ; }	Converts a value in the convertible derived unit to the equivalent valuein this unit.
public array convertnestedvariable ( ucar . nc2 . variable v , list < range > section , dodsv datav , boolean flatten ) throws ioexception , dap2exception { array data = converttopvariable ( v , section , datav ) ; if ( flatten ) { arraystructure as = ( arraystructure ) data ;	Convert a DataDDS into an Array for a Structure member variable.
public array converttopvariable ( ucar . nc2 . variable v , list < range > section , dodsv datav ) throws ioexception , dap2exception { array data = convert ( datav ) ;	Convert a DataDDS into an Array for a top level variable, ie not a Structure member variable.
public array convert ( dodsv datav ) throws ioexception , dap2exception {	Convert a DataDDS into an Array.
static synchronized public void closeall ( ) { list < metadatamanager > closedatabases = new arraylist < > ( opendatabases ) ; for ( metadatamanager mm : closedatabases ) { if ( debug ) system . out . println ( str_ + mm . collectionname ) ; mm . close ( ) ; } opendatabases = new arraylist < > ( ) ;	this is called on TDS shutdown and reinit.
private synchronized void opendatabase ( ) { if ( database != null ) return ; databaseconfig dbconfig = new databaseconfig ( ) ; dbconfig . setreadonly ( readonly ) ; dbconfig . setallowcreate ( ! readonly ) ; if ( ! readonly ) dbconfig . setdeferredwrite ( bool_ ) ; database = myenv . opendatabase ( null , collectionname , dbconfig ) ; opendatabases . add ( this ) ; }	assumes only one open at a time; could have MetadataManagers share open databases.
static org . joda . time . period converttoperiod ( int value , string udunit ) { if ( udunit . endswith ( str_ ) ) udunit = udunit . substring ( num_ , udunit . length ( ) - num_ ) ; switch ( udunit ) { case str_ : return period . millis ( value ) ; case str_ : return period . seconds ( value ) ; case str_ : return period . minutes ( value ) ; case str_ : case str_ : return period . hours ( value ) ; case str_ : return period . days ( value ) ; case str_ : return period . weeks ( value ) ; case str_ : return period . months ( value ) ; case str_ : return period . years ( value ) ; } throw new illegalargumentexception ( str_ + udunit + str_ ) ; }	Convert a time udunit string.
public void ensurecapacity ( long mincapacity ) { if ( array . length < mincapacity ) {	This ensures that the capacity is at least 'minCapacity'.
public string get ( int index ) { if ( index >= size ) throw new illegalargumentexception ( erddapstring2 . error + str_ + index + str_ + size + str_ ) ; return array [ index ] ; }	This gets a specified element.
public invcatalogimpl makecatalogfordirectory ( string orgpath , uri caturi ) { if ( log . isdebugenabled ( ) ) { log . debug ( str_ + caturi ) ; log . debug ( str_ + orgpath ) ; log . debug ( str_ + rootpath ) ; log . debug ( str_ + scanlocation ) ; }	Try to build a catalog for the given path by scanning the locationassociated with this InvDatasetScan.
public invcatalogimpl makeproxydsresolvercatalog ( string path , uri baseuri ) { if ( path == null ) return null ; if ( path . endswith ( str_ ) ) return null ;	Try to build a catalog for the given resolver path by scanning thelocation associated with this InvDatasetScan.
private datatype getcoordinatetype ( ) { list < dataset > nesteddatasets = getdatasets ( ) ; datasetouterdimension first = ( datasetouterdimension ) nesteddatasets . get ( num_ ) ; return first . isstringvalued ? datatype . string : datatype . double ; }	What is the data type of the aggregation coordinate ?.
@ nullable public static grib2pds factory ( int template , byte [ ] input ) { switch ( template ) { case num_ : return new grib2pds0 ( input ) ; case num_ : return new grib2pds1 ( input ) ; case num_ : return new grib2pds2 ( input ) ; case num_ : return new grib2pds5 ( input ) ; case num_ : return new grib2pds6 ( input ) ; case num_ : return new grib2pds8 ( input ) ; case num_ : return new grib2pds9 ( input ) ; case num_ : return new grib2pds10 ( input ) ; case num_ : return new grib2pds11 ( input ) ; case num_ : return new grib2pds12 ( input ) ; case num_ : return new grib2pds15 ( input ) ; case num_ : return new grib2pds30 ( input ) ; case num_ : return new grib2pds31 ( input ) ; case num_ : return new grib2pds48 ( input ) ; case num_ : return new grib2pds61 ( input ) ; default : log . warn ( str_ + template ) ; return null ; } }	Factory for Grib2Pds.
protected calendardate calctime ( int startindex ) { int year = gribnumbers . int2 ( getoctet ( startindex ++ ) , getoctet ( startindex ++ ) ) ; int month = getoctet ( startindex ++ ) ; int day = getoctet ( startindex ++ ) ; int hour = getoctet ( startindex ++ ) ; int minute = getoctet ( startindex ++ ) ; int second = getoctet ( startindex ++ ) ; if ( ( year == num_ ) && ( month == num_ ) && ( day == num_ ) && ( hour == num_ ) && ( minute == num_ ) && ( second == num_ ) ) return calendardate . unknown ;	null means use refTime.
double applyscalefactor ( int scale , int value ) { return ( ( scale == num_ ) || ( scale == num_ ) || ( value == num_ ) ) ? value : value * math . pow ( num_ , - scale ) ; }	Apply scale factor to value, return a double result.
private void parselocalconcept ( string filename , string conceptname ) throws ioexception { try ( inputstream is = new fileinputstream ( filename ) ) { addlocalconcept ( is , conceptname ) ; } }	Parse the localConcept files needed to create grib1 tables for use by the CDM.
private void addlocalconcept ( inputstream is , string conceptname ) throws ioexception { try ( bufferedreader br = new bufferedreader ( new inputstreamreader ( is , encoding ) ) ) { string line = br . readline ( ) ; while ( ! line . startswith ( str_ ) ) line = br . readline ( ) ;	Add the information from a localConcept file to super HashMap localConcepts.
private string cleanline ( string linein ) { string lineout ; lineout = linein . replaceall ( str_ , str_ ) ; lineout = lineout . replaceall ( str_ , str_ ) ; lineout = lineout . replaceall ( str_ , str_ ) ; return lineout . trim ( ) ; }	clean the string representation of a line in the localConceptfile.
private void storeconcept ( string tableversion , string parameternumber , string key , string value ) { hashmap < string , hashmap < string , string > > tmptable ; if ( localconcepts . containskey ( tableversion ) ) { tmptable = localconcepts . get ( tableversion ) ; if ( tmptable . containskey ( parameternumber ) ) { hashmap < string , string > tmpparam = tmptable . get ( parameternumber ) ; if ( ! tmpparam . containskey ( key ) ) { tmpparam . put ( key , value ) ; } else { system . out . println ( str_ + key + str_ + value ) ; } } else { hashmap < string , string > tmpparam = new hashmap < > ( num_ ) ; tmpparam . put ( key , value ) ; tmptable . put ( parameternumber , tmpparam ) ; } } else { tmptable = new hashmap < > ( ) ; hashmap < string , string > tmpparam = new hashmap < > ( num_ ) ; tmpparam . put ( key , value ) ; tmptable . put ( parameternumber , tmpparam ) ; } localconcepts . put ( tableversion , tmptable ) ; }	Store localConcept information in super HashMap localConcepts.
private void writegrib1tables ( ) throws ioexception { simpledateformat dateformat = new simpledateformat ( str_ ) ; calendar cal = calendar . getinstance ( ) ; string writedate = dateformat . format ( cal . gettime ( ) ) ; string grib1info ; list < string > tablenums = new arraylist < > ( ) ; hashmap < string , string > paraminfo ; path dir = paths . get ( ecmwflocalconceptsloc . replace ( str_ , str_ ) ) ; for ( string tablenum : localconcepts . keyset ( ) ) { tablenums . add ( tablenum ) ; string filename = str_ + tablenum + str_ ; system . out . println ( str_ + filename ) ; path newfile = dir . resolve ( filename ) ; files . deleteifexists ( newfile ) ; files . createfile ( newfile ) ; try ( bufferedwriter writer = files . newbufferedwriter ( newfile , encoding ) ) { writer . write ( str_ + this . getclass ( ) . getcanonicalname ( ) + str_ + writedate ) ; writer . newline ( ) ; for ( string paramnum : localconcepts . get ( tablenum ) . keyset ( ) ) { paraminfo = localconcepts . get ( tablenum ) . get ( paramnum ) ; string shortname = paraminfo . get ( shortname_id ) ; string description = paraminfo . get ( description_id ) ; string units = paraminfo . get ( unit_id ) ; grib1info = paramnum + str_ + shortname + str_ + description + str_ + units + str_ ; writer . write ( grib1info ) ; writer . newline ( ) ; } } } writelookuptablefile ( tablenums , dir , writedate ) ; }	Write out grib1 tables based on localConcepts files - these are the tablesthat the CDM will read.
private void writelookuptablefile ( list < string > tablenums , path dir , string writedate ) throws ioexception { system . out . println ( str_ ) ; collections . sort ( tablenums ) ; path lookuptablereg = dir . resolve ( str_ ) ; files . deleteifexists ( lookuptablereg ) ; files . createfile ( lookuptablereg ) ; try ( bufferedwriter writer = files . newbufferedwriter ( lookuptablereg , encoding ) ) { writer . write ( str_ + this . getclass ( ) . getcanonicalname ( ) + str_ + writedate ) ; writer . newline ( ) ; for ( string tn : tablenums ) { string tablename = str_ + tn + str_ ; string reg = str_ + tn + str_ + tablename ; writer . write ( reg ) ; writer . newline ( ) ; } } }	Write the lookupTables.txt file, which basically registers all of the new grib1 tableswith the CDM.
private void showlocalconcepts ( ) { for ( string tablenum : localconcepts . keyset ( ) ) { for ( string paramnum : localconcepts . get ( tablenum ) . keyset ( ) ) { for ( string key : localconcepts . get ( tablenum ) . get ( paramnum ) . keyset ( ) ) { system . out . println ( key + str_ + localconcepts . get ( tablenum ) . get ( paramnum ) . get ( key ) ) ; } } } }	Quick prinout to System.out of the different parameter metadata fields.
public static void main ( string [ ] args ) { ecmwflocalconcepts ec = new ecmwflocalconcepts ( ) ; try { ec . writegrib1tables ( ) ; system . out . println ( str_ ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	Generate grib1 tables for the CDM based on the localConcept files from ECMWF GRIB-API.
public static datasetsourcetype gettype ( string name ) { if ( name == null ) return null ; return ( ( datasetsourcetype ) hash . get ( name ) ) ; }	Find the DatasetSourceType that matches this name.
public invdataset expand ( ) throws ioexception {	Crawl this DatasetSource and generate a new InvCatalog, return thetop-level InvDataset.Each object found on the DatasetSource becomes an InvDataset if it isaccepted by at least one DatasetFilter.
public invcatalog fullexpand ( ) throws ioexception { logger . debug ( str_ , this . getname ( ) ) ; invdataset topds = this . expand ( ) ; invcatalog generatedcat = topds . getparentcatalog ( ) ;	Crawl this DatasetSource and generate a new InvCatalog with all datasetsnamed, sorted, and organized as defined by this DatasetSource, return thenewly generated InvCatalog.
private void namedatasets ( invdatasetimpl datasetcontainer ) { if ( this . getdatasetnamerlist ( ) . isempty ( ) ) return ; if ( this . isflatten ( ) ) { logger . debug ( str_ ) ; this . namedatasetlist ( datasetcontainer ) ; } else { logger . debug ( str_ + str_ ) ; invdatasetimpl curds = null ; for ( int j = num_ ; j < datasetcontainer . getdatasets ( ) . size ( ) ; j ++ ) { curds = ( invdatasetimpl ) datasetcontainer . getdatasets ( ) . get ( j ) ; this . namedatasettree ( curds ) ; } } return ; }	Use the list of dsNamers to name the given list of datasets.
private void namedatasetlist ( invdatasetimpl dataset ) {	Name the datasets contained in the given dataset.The given dataset contains a flat list of datasets.
private void namedatasettree ( invdatasetimpl dataset ) {	Name the datasets in the given dataset hierarchy using thisDatasetSource's list of datasetNamers.
public void loadpictureimd ( url imageurl , double rotation ) { tools . log ( str_ + imageurl . tostring ( ) ) ; if ( sourcepicture != null ) sourcepicture . removelistener ( this ) ; sourcepicture = new sourcepicture ( ) ; sourcepicture . addlistener ( this ) ; setstatus ( loading , str_ + imageurl . tostring ( ) ) ; scaleafterload = bool_ ; sourcepicture . loadpicture ( imageurl , rotation ) ; }	Synchroneous method to load the image.It should only be called by something which is a thread itself such as the HtmlDistillerThread.Since this intended for large batch operations this bypasses the cache.
public void stoploadingexcept ( url url ) { if ( sourcepicture != null ) { boolean iscurrentlyloading = sourcepicture . stoploadingexcept ( url ) ; if ( ! iscurrentlyloading ) {	stops all picture loading except if the Url we desire is being loaded.
public void sourcestatuschange ( int statuscode , string statusmessage , sourcepicture sp ) {	method that is invoked by the SourcePictureListener interface.
public void sourceloadprogressnotification ( int statuscode , int percentage ) { enumeration e = scalablepicturestatuslisteners . elements ( ) ; while ( e . hasmoreelements ( ) ) { ( ( scalablepicturelistener ) e . nextelement ( ) ) . sourceloadprogressnotification ( statuscode , percentage ) ; } }	pass on the update on the loading Progress to the listening objects.
public void createscaledpictureinthread ( int priority ) { setstatus ( scaling , str_ ) ; scalethread t = new scalethread ( this ) ; t . setpriority ( priority ) ; t . start ( ) ; }	method that creates the scaled image in the background in it's own thread.
public dimension getscaledsize ( ) { if ( scaledpicture != null ) return new dimension ( scaledpicture . getwidth ( ) , scaledpicture . getheight ( ) ) ; else return new dimension ( num_ , num_ ) ; }	return the size of the scaled image or Zero if there is none.
public string getscaledsizestring ( ) { if ( scaledpicture != null ) return integer . tostring ( scaledpicture . getwidth ( ) ) + str_ + integer . tostring ( scaledpicture . getheight ( ) ) ; else return str_ ; }	return the size of the scaled image as a neatly formatted text or Zero if there is none.
public list < string > getmergedparts ( ) { list < string > list = new arraylist < > ( num_ ) ; list . add ( sndt ) ; return list ; }	Get the list of merged parts in this file.
private string makeheader ( gempakstation stn , string date ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( str_ ) ; builder . append ( stringutil2 . padright ( ( stn . getstid ( ) . trim ( ) + stn . getstd2 ( ) . trim ( ) ) , num_ ) ) ; builder . append ( str_ ) ; builder . append ( str_ ) ; builder . append ( format . i ( stn . getstnm ( ) , num_ ) ) ; builder . append ( str_ ) ; builder . append ( str_ ) ; builder . append ( date ) ; builder . append ( str_ ) ; builder . append ( str_ ) ; builder . append ( format . d ( stn . getlatitude ( ) , num_ ) ) ; builder . append ( str_ ) ; builder . append ( str_ ) ; builder . append ( format . d ( stn . getlongitude ( ) , num_ ) ) ; builder . append ( str_ ) ; builder . append ( str_ ) ; builder . append ( format . d ( stn . getaltitude ( ) , num_ ) ) ; builder . append ( str_ ) ; return builder . tostring ( ) ; }	Make the header for the text report.
private list < string > sn_ckua ( ) { list < string > types = new arraylist < > ( ) ; boolean above = bool_ ; boolean done = bool_ ; string parttocheck ; while ( ! done ) {	This subroutine checks the parts in a sounding data set for theunmerged data types.
private boolean checkforvalidgroup ( string parttocheck , string [ ] params ) { dmpart part = getpart ( parttocheck ) ; if ( part == null ) { return bool_ ; } int i = num_ ; for ( dmparam parm : part . params ) { if ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) { return bool_ ; } } return bool_ ; }	Check for valid groups.
static public void setrootdirectory ( string cachedir ) { if ( ! cachedir . endswith ( str_ ) ) cachedir = cachedir + str_ ; root = stringutil2 . replace ( cachedir , str_ , str_ ) ;	Set the cache root directory.
static public void makerootdirectory ( ) { file dir = new file ( root ) ; if ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) throw new illegalstateexception ( str_ + root + str_ ) ; checkexist = bool_ ; }	Make sure that the current root directory exists.
static public file getcachefile ( string filelocation ) { file f = new file ( makecachepath ( filelocation ) ) ; if ( f . exists ( ) ) { if ( ! f . setlastmodified ( system . currenttimemillis ( ) ) ) logger . warn ( str_ + f . getpath ( ) ) ; } if ( ! checkexist ) { file dir = f . getparentfile ( ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) logger . warn ( str_ + dir . getpath ( ) ) ; checkexist = bool_ ; } return f ; }	Get a file in the cache.File may or may not exist.
static public void cleancache ( date cutoff , stringbuilder sbuff ) { if ( sbuff != null ) sbuff . append ( str_ ) . append ( cutoff ) . append ( str_ ) ; file dir = new file ( root ) ; file [ ] children = dir . listfiles ( ) ; if ( children == null ) return ; for ( file file : children ) { date lastmod = new date ( file . lastmodified ( ) ) ; if ( lastmod . before ( cutoff ) ) { boolean ret = file . delete ( ) ; if ( sbuff != null ) { sbuff . append ( str_ ) . append ( file ) . append ( str_ ) . append ( lastmod ) . append ( str_ ) ; if ( ! ret ) sbuff . append ( str_ ) . append ( file ) . append ( str_ ) ; } } } }	Remove all files with date < cutoff.
static public void cleancache ( long maxbytes , comparator < file > filecomparator , stringbuilder sbuff ) { if ( sbuff != null ) sbuff . append ( str_ ) . append ( maxbytes ) . append ( str_ ) . append ( root ) . append ( str_ ) ; file dir = new file ( root ) ; long total = num_ , total_delete = num_ ; file [ ] files = dir . listfiles ( ) ; if ( files != null ) { list < file > filelist = arrays . aslist ( files ) ; collections . sort ( filelist , filecomparator ) ; for ( file file : filelist ) { if ( file . length ( ) + total > maxbytes ) { total_delete += file . length ( ) ; if ( sbuff != null ) sbuff . append ( str_ ) . append ( file ) . append ( str_ ) . append ( file . length ( ) ) . append ( str_ ) ; if ( ! file . delete ( ) && sbuff != null ) sbuff . append ( str_ ) . append ( file ) . append ( str_ ) ; } else { total += file . length ( ) ; } } } if ( sbuff != null ) { sbuff . append ( str_ ) . append ( total_delete ) . append ( str_ ) ; sbuff . append ( str_ ) . append ( total ) . append ( str_ ) ; } }	Remove files if needed to make cache have less than maxBytes bytes file sizes.This will remove files in sort order defined by fileComparator.The first files in the sort order are kept, until the max bytes is exceeded, then they are deleted.
static public boolean isbufrtable ( short fxy ) { int f = ( fxy & num_ ) > > num_ ; int x = ( fxy & num_ ) > > num_ ; int y = ( fxy & num_ ) ; return ( f == num_ ) && ( x == num_ ) && ( y < num_ ) ; }	contains a BUFR table entry.
static public coordinateaxis factory ( netcdfdataset ncd , variableds vds ) { if ( ( vds . getrank ( ) == num_ ) || ( vds . getrank ( ) == num_ ) || ( vds . getrank ( ) == num_ && vds . getdatatype ( ) == datatype . char ) ) { return new coordinateaxis1d ( ncd , vds ) ; } else if ( vds . getrank ( ) == num_ ) return new coordinateaxis2d ( ncd , vds ) ; else return new coordinateaxis ( ncd , vds ) ; }	Create a coordinate axis from an existing Variable.
public coordinateaxis copynocache ( ) { coordinateaxis axis = new coordinateaxis ( ncd , getparentgroup ( ) , getshortname ( ) , getdatatype ( ) , getdimensionsstring ( ) , getunitsstring ( ) , getdescription ( ) ) ;	Make a copy, with an independent cache.
public boolean isnumeric ( ) { return ( getdatatype ( ) != datatype . char ) && ( getdatatype ( ) != datatype . string ) && ( getdatatype ( ) != datatype . structure ) ; }	Does the axis have numeric values.
public void getinfo ( formatter buf ) { buf . format ( str_ , getnameanddimensions ( ) ) ; buf . format ( str_ , getunitsstring ( ) ) ; if ( axistype != null ) { buf . format ( str_ , axistype . tostring ( ) ) ; } buf . format ( str_ , getdescription ( ) ) ;	Get a string representation.
public ucar . nc2 . time . calendar getcalendarfromattribute ( ) { attribute cal = findattribute ( cf . calendar ) ; string s = ( cal == null ) ? null : cal . getstringvalue ( ) ; if ( s == null ) {	needed by time coordinates.
public void setlist ( arraylist rowlist ) { this . list = rowlist ; if ( list . size ( ) > num_ ) jtable . setrowselectioninterval ( num_ , num_ ) ; else jtable . clearselection ( ) ; model . sort ( ) ; jtable . revalidate ( ) ; }	Replace the rowList with this one.
public tablerow getselected ( ) { if ( list . size ( ) == num_ ) return null ; int sel = jtable . getselectedrow ( ) ; if ( sel >= num_ ) return ( tablerow ) list . get ( sel ) ; else return null ; }	Get the currently selected row.
public void incrselected ( boolean increment ) { if ( list . size ( ) == num_ ) return ; int curr = jtable . getselectedrow ( ) ; if ( increment && ( curr < list . size ( ) - num_ ) ) setselected ( curr + num_ ) ; else if ( ! increment && ( curr > num_ ) ) setselected ( curr - num_ ) ; }	Increment or decrement the current selection by one row.
public int [ ] getmodelindex ( ) { int [ ] modelindex = new int [ colname . length ] ; tablecolumnmodel tcm = jtable . getcolumnmodel ( ) ; for ( int i = num_ ; i < colname . length ; i ++ ) { tablecolumn tc = tcm . getcolumn ( i ) ; modelindex [ i ] = tc . getmodelindex ( ) ; } return modelindex ; }	for each column, get the model index.
private void setselectedindex ( int idx ) { if ( zaxis == null ) return ; eventok = bool_ ; currentidx = idx ; slider . setvalue ( world2slider ( zaxis . getcoordvalue ( currentidx ) ) ) ; eventok = bool_ ; }	set current value - no event.
static private void quicksort ( string a [ ] , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; string mid ; if ( hi0 > lo0 ) {	Internal recursive method to perform Quick Sort on name array.
static private void swap ( string a [ ] , int i , int j ) { string t ; t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; }	Private method to swap two elements in the array.
static public mfileos getexistingfile ( string filename ) { if ( filename == null ) return null ; file file = new file ( filename ) ; if ( file . exists ( ) ) return new mfileos ( file ) ; return null ; }	Make MFileOS if file exists, otherwise return null.
private double [ ] rotate ( double [ ] lonlat , double rot1 , double rot2 , double s ) { double e = math . toradians ( lonlat [ num_ ] - rot1 ) ;	Tor's transform algorithm renamed to rotate for clarity.
static public xmlstore createfromfile ( string filename , xmlstore storeddefaults ) throws java . io . ioexception { file prefsfile = new file ( filename ) ;	Create an XMLStore reading from the specified filename.
static public xmlstore createfrominputstream ( inputstream is1 , inputstream is2 , xmlstore storeddefaults ) throws java . io . ioexception { if ( debugwhichstore ) system . out . println ( str_ + is1 ) ; return new xmlstore ( is1 , is2 , storeddefaults ) ; }	Create an XMLStore reading from an input stream.
static public xmlstore createfromresource ( string resourcename , xmlstore storeddefaults ) throws java . io . ioexception {	Create a read-only XMLStore reading from the specified resource, opened as a Resource stream using theXMLStore ClassLoader.
static public string makestandardfilename ( string appname , string storename ) {	Convenience routine for creating an XMLStore file in a standard place.
public void save ( ) throws java . io . ioexception { if ( prefsfile == null ) throw new unsupportedoperationexception ( str_ ) ;	Save the current state of the Preferences tree to disk, using theoriginal filename.
public void save ( outputstream out ) throws java . io . ioexception { outputexceptionmessage = null ;	Save the current state of the Preferences tree to the given OutputStream.
protected void writeatomicvariable ( datacursor data , serialwriter dst ) throws ioexception { dapvariable template = ( dapvariable ) data . gettemplate ( ) ; assert ( this . ce . references ( template ) ) ; daptype basetype = template . getbasetype ( ) ;	Write out an atomic variable.
protected void writestructure ( datacursor data , serialwriter dst ) throws ioexception { dapvariable template = ( dapvariable ) data . gettemplate ( ) ; dapstructure ds = ( dapstructure ) template . getbasetype ( ) ; assert ( this . ce . references ( template ) ) ; list < slice > slices = ce . getconstrainedslices ( template ) ; odometer odom = odometer . factory ( slices ) ; while ( odom . hasnext ( ) ) { index index = odom . next ( ) ; datacursor [ ] instance = ( datacursor [ ] ) data . read ( index ) ; writestructure1 ( instance [ num_ ] , dst ) ; } }	Write out a scalar or array structure instance.
protected void writestructure1 ( datacursor instance , serialwriter dst ) throws ioexception { assert instance . getscheme ( ) == datacursor . scheme . structure ; dapvariable template = ( dapvariable ) instance . gettemplate ( ) ; assert ( this . ce . references ( template ) ) ; dapstructure ds = ( dapstructure ) template . getbasetype ( ) ; list < dapvariable > fields = ds . getfields ( ) ; for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { dapvariable field = fields . get ( i ) ; if ( ! this . ce . references ( field ) ) continue ;	Write out a single structure instance.
protected void writesequence ( datacursor data , serialwriter dst ) throws ioexception { dapvariable template = ( dapvariable ) data . gettemplate ( ) ; dapsequence ds = ( dapsequence ) template . getbasetype ( ) ; assert ( this . ce . references ( template ) ) ; list < slice > slices = ce . getconstrainedslices ( template ) ; odometer odom = odometer . factory ( slices ) ; if ( bool_ ) while ( odom . hasnext ( ) ) { index index = odom . next ( ) ; datacursor [ ] instance = ( datacursor [ ] ) data . read ( index ) ; writesequence1 ( instance [ num_ ] , dst ) ; } else { datacursor [ ] instances = ( datacursor [ ] ) data . read ( slices ) ; for ( int i = num_ ; i < instances . length ; i ++ ) { writesequence1 ( instances [ i ] , dst ) ; } } }	Write out a single or array sequence instance.
protected void writerecord ( datacursor record , serialwriter dst ) throws ioexception { dapvariable template = ( dapvariable ) record . gettemplate ( ) ; dapsequence seq = ( dapsequence ) template . getbasetype ( ) ; list < dapvariable > fields = seq . getfields ( ) ; for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { dapvariable field = fields . get ( i ) ; if ( ! this . ce . references ( field ) ) continue ;	Write out a single Record instance.
static public boolean isvalidfile ( ucar . unidata . io . randomaccessfile raf ) throws ioexception { raf . seek ( num_ ) ; if ( ! raf . searchforward ( matcher , num_ * num_ ) ) return bool_ ;	is this a valid BUFR file.
public string getwmoid ( ) { string wmoid = str_ ; if ( ! ( stnm == gempakconstants . imissd ) ) { wmoid = string . valueof ( ( int ) ( stnm / num_ ) ) ; } return wmoid ; }	Get the WMO Station ID as a string.
int readrown ( datainputstream ds , int n ) { if ( n > nrec ) return - num_ ; try { ds . readfully ( field , num_ , desc . fieldlength ) ; } catch ( java . io . ioexception e ) { return - num_ ; } switch ( desc . type ) { case str_ : case str_ : character [ n ] = new string ( field , cdm . utf8charset ) ; break ; case str_ : numeric [ n ] = double . valueof ( new string ( field , cdm . utf8charset ) ) ; break ; case str_ : if ( desc . fieldlength == num_ ) { numeric [ n ] = ( double ) swap . swapfloat ( field , num_ ) ; } else { numeric [ n ] = swap . swapdouble ( field , num_ ) ; } break ; case str_ : switch ( field [ num_ ] ) { case str_ : case str_ : case str_ : case str_ : logical [ n ] = bool_ ; break ; default : logical [ n ] = bool_ ; break ; } default : return - num_ ; } return num_ ; }	Method to read an entry from the data stream.
public object getdata ( int i ) { switch ( type ) { case type_char : return character [ i ] ; case type_numeric : return numeric [ i ] ; case type_boolean : return logical [ i ] ; } return null ; }	Method to retrieve data for this field.
private float [ ] getdata0 ( randomaccessfile raf , grib2drs . type0 gdrs ) throws ioexception { int nb = gdrs . numberofbits ; int d = gdrs . decimalscalefactor ; float dd = ( float ) java . lang . math . pow ( ( double ) num_ , ( double ) d ) ; float r = gdrs . referencevalue ; int e = gdrs . binaryscalefactor ; float ee = ( float ) java . lang . math . pow ( num_ , ( double ) e ) ;	Grid point data - simple packing.
private float [ ] getdata41 ( randomaccessfile raf , grib2drs . type0 gdrs ) throws ioexception { int nb = gdrs . numberofbits ; int d = gdrs . decimalscalefactor ; float dd = ( float ) java . lang . math . pow ( ( double ) num_ , ( double ) d ) ; float r = gdrs . referencevalue ; int e = gdrs . binaryscalefactor ; float ee = ( float ) java . lang . math . pow ( num_ , ( double ) e ) ;	Code taken from esupport ticket ZVT-415274.
static public void makefile ( string location , ucar . nc2 . dt . griddataset gds , list < string > gridlist , latlonrect llbb , calendardaterange range ) throws ioexception , invalidrangeexception { cfgridwriter writer = new cfgridwriter ( ) ; writer . makefile ( location , gds , gridlist , llbb , range , bool_ , num_ , num_ , num_ ) ; }	Write a netcdf-3 file from a subset of a grid dataset.
public long makegridfilesizeestimate ( ucar . nc2 . dt . griddataset gds , list < string > gridlist , latlonrect llbb , int horizstride , range zrange , calendardaterange daterange , int stride_time , boolean addlatlon ) throws ioexception , invalidrangeexception { return makeortestsize ( null , gds , gridlist , llbb , horizstride , zrange , daterange , stride_time , addlatlon , bool_ , netcdffilewriter . version . netcdf3 ) ; }	Write a netcdf-3 file from a subset of a grid dataset, as long as it doesnt exceed a certain file size.
public void makefile ( string location , ucar . nc2 . dt . griddataset gds , list < string > gridlist , latlonrect llbb , calendardaterange range , boolean addlatlon , int horizstride , int stride_z , int stride_time ) throws ioexception , invalidrangeexception { makefile ( location , gds , gridlist , llbb , horizstride , null , range , stride_time , addlatlon , netcdffilewriter . version . netcdf3 ) ; }	Write a CF compliant Netcdf-3 file from any gridded dataset.
public void setstations ( java . util . list < ucar . unidata . geoloc . station > stns ) { stations = new arraylist < stationui > ( stns . size ( ) ) ; stationhash . clear ( ) ; for ( int i = num_ ; i < stns . size ( ) ; i ++ ) { ucar . unidata . geoloc . station s = ( ucar . unidata . geoloc . station ) stns . get ( i ) ; stationui sui = new stationui ( s ) ;	Set the list of stations.
public void setselectedstation ( string name ) { stationui sui = ( stationui ) stationhash . get ( name ) ; if ( sui != null ) { setselectedstation ( sui ) ; } }	set selected station based on the sttion id.
public ucar . unidata . geoloc . station pick ( point2d pickpt ) { if ( world2normal == null || pickpt == null || stations . isempty ( ) ) return null ; world2normal . transform ( pickpt , ptn ) ;	Find station that contains this point.
public ucar . unidata . geoloc . station pickclosest ( point2d pickpt ) { if ( world2normal == null || pickpt == null || stations . isempty ( ) ) return null ; world2normal . transform ( pickpt , ptn ) ;	Find station closest to this point.
public ucar . unidata . geoloc . station getselectedstation ( ) { return ( selected != null ) ? selected . ddstation : null ; }	Get the selected station.
public string getprojname ( int type ) { string projname ; switch ( type ) { case pseudo_mercator : case pseudo_mercator_general : projname = str_ ; break ; case ps_or_lambert_conic : projname = ( vals [ num_ ] == vals [ num_ ] ) ? str_ : str_ ; break ; case equidistant : projname = str_ ; break ; case lambert_conformal_tangent : projname = str_ ; break ; default : projname = str_ + type ; } return projname ; }	Get the name for the projection type.
public list getstations ( ucar . unidata . geoloc . latlonrect boundingbox ) throws ioexception { return typical . getstations ( boundingbox ) ; }	Get all the Stations within a bounding box.
public ucar . unidata . geoloc . station getstation ( string name ) { return typical . getstation ( name ) ; }	Find a Station by name.
public dataiterator getdataiterator ( ucar . unidata . geoloc . station s ) throws ioexception { return new stationdataiterator ( s ) ; }	Get all data for this Station.
public dataiterator getdataiterator ( ucar . unidata . geoloc . station s , date start , date end ) throws ioexception { return new stationdatedataiterator ( s , start , end ) ; }	Get data for this Station within the specified date range.
public void readdata ( randomaccessfile raf , string abbrev , range gaterange , indexiterator ii ) throws ioexception { long offset = rayoffset ; offset += ( getdataoffset ( abbrev ) * num_ - num_ ) ; raf . seek ( offset ) ; byte [ ] b2 = new byte [ num_ ] ; int datacount = getgatecount ( abbrev ) ; byte [ ] data = new byte [ datacount * num_ ] ; raf . readfully ( data ) ; for ( int gateidx : gaterange ) { if ( gateidx >= datacount ) ii . setshortnext ( uf_header2 . missing ) ; else { b2 [ num_ ] = data [ gateidx * num_ ] ; b2 [ num_ ] = data [ gateidx * num_ + num_ ] ; short value = getshort ( b2 , num_ ) ; ii . setshortnext ( value ) ; } } }	Read data from this ray.
public double dot ( mavector v ) { if ( nelems != v . getnelems ( ) ) throw new illegalargumentexception ( str_ + nelems + str_ + v . getnelems ( ) ) ; double sum = num_ ; for ( int k = num_ ; k < nelems ; k ++ ) sum += getdouble ( k ) * v . getdouble ( k ) ; return sum ; }	Dot product of 2 vectors.
public double norm ( ) { double sum = num_ ; for ( int k = num_ ; k < nelems ; k ++ ) { double val = getdouble ( k ) ; sum += val * val ; } return math . sqrt ( sum ) ; }	Get the L2 norm of this vector.
public void normalize ( ) { double norm = norm ( ) ; if ( norm <= num_ ) return ; for ( int k = num_ ; k < nelems ; k ++ ) { double val = getdouble ( k ) ; setdouble ( k , val / norm ) ; } }	Normalize this vector, so it has norm = 1.0.
private void setservices ( iterable < datasetbuilder > dsiter ) { for ( datasetbuilder dsb : dsiter ) { for ( service s : dsb . getservices ( ) ) { addservice ( s ) ; } setservices ( dsb . getdatasets ( ) ) ;	pull services out of the datasets and into the catalog.
public grib1parameter getparameter ( int id ) { if ( parameters == null ) { parameters = readparametertable ( ) ; } return parameters . get ( id ) ; }	Get the parameter with id.
public grib1parameter getlocalparameter ( int id ) { if ( parameters == null ) { parameters = readparametertable ( ) ; } return parameters . get ( id ) ; }	Get the parameter with id, but dont look in default table.
public void addname ( final string name , final double value ) throws prefixexistsexception { final prefix prefix = new prefixname ( name , value ) ; nameset . add ( prefix ) ; }	Adds a prefix to the database by name.
public void addsymbol ( final string symbol , final double value ) throws prefixexistsexception { final prefix prefix = new prefixsymbol ( symbol , value ) ; symbolset . add ( prefix ) ; valuemap . put ( new double ( value ) , prefix ) ; }	Adds a prefix symbol to the database.
private static prefix getprefix ( final string string , final set < prefix > set ) { for ( final iterator < prefix > iter = set . iterator ( ) ; iter . hasnext ( ) ; ) { final prefix prefix = iter . next ( ) ; final int comp = prefix . compareto ( string ) ; if ( comp == num_ ) { return prefix ; } if ( comp > num_ ) { break ; } } return null ; }	Returns the prefix from the given set with the given identifier.
protected boolean emailok ( threddsmetadata . source p ) { string email = p . getemail ( ) ; return email . indexof ( str_ ) >= num_ ;	check its an acceptable form of email.
public double getparameter ( string name ) { double val = ( double ) parameters . get ( name . tolowercase ( ) ) ; if ( val == null ) { throw new illegalargumentexception ( str_ + name ) ; } return val . doublevalue ( ) ; }	Get the value of the projection parameter.
public long calccrc ( ) { long crc ; if ( rawdata == null ) crc = predefinedgriddefinitioncenter << num_ + predefinedgriddefinition ; else { crc32 crc32 = new crc32 ( ) ; crc32 . update ( rawdata ) ; crc = crc32 . getvalue ( ) ; } return crc ; }	Calculate the CRC of the entire byte array.
public final boolean isthin ( ) { if ( rawdata == null ) return bool_ ; int octet5 = getoctet ( num_ ) ; int nv = getoctet ( num_ ) ; return ( octet5 != num_ ) && ( nv == num_ || nv == num_ ) ; }	is a "thin" grid.
@ override public int fieldindex ( string name ) throws dapexception { dapstructure ds ; if ( gettemplate ( ) . getsort ( ) . iscompound ( ) ) ds = ( dapstructure ) gettemplate ( ) ; else if ( gettemplate ( ) . getsort ( ) . isvar ( ) && ( ( ( dapvariable ) gettemplate ( ) ) . getbasetype ( ) . getsort ( ) . iscompound ( ) ) ) ds = ( dapstructure ) ( ( dapvariable ) gettemplate ( ) ) . getbasetype ( ) ; else throw new dapexception ( str_ ) ; int i = ds . indexbyname ( name ) ; if ( i < num_ ) throw new dapexception ( str_ + name ) ; return i ; }	Selected DataCursor API overrides.
public static string gettimetypename ( int timerangeindicator ) { string timerange ; switch ( timerangeindicator ) { case num_ : timerange = str_ ; break ;	code table 5 - 2010 edition of WMO manual on codes.
public string gettimecoord ( ) { if ( isinterval ( ) ) { int [ ] intv = getinterval ( ) ; return intv [ num_ ] + str_ + intv [ num_ ] ; } return integer . tostring ( getforecasttime ( ) ) ; }	A string representation of the time coordinate, whether its an interval or not.
public void setnext ( polygon next ) { if ( next instanceof cfpolygon ) { setnext ( ( cfpolygon ) next ) ; } else this . next = next ; }	Sets the next polygon which make up the multipolygon which this polygon is a part of.If next is a CFPolygon, automatically connects the other polygon to this polygon as well.
public void setprev ( polygon prev ) { if ( prev instanceof cfpolygon ) { setprev ( ( cfpolygon ) prev ) ; } else this . prev = prev ; }	Sets the previous polygon which makes up the multipolygon which this polygon is a part of.If prev is a CFPolygon, automatically connect the other polygon to this polygon as well.
public string findproperty ( string name ) { invproperty result = null ; for ( invproperty p : properties ) { if ( p . getname ( ) . equals ( name ) ) result = p ; } return ( result == null ) ? null : result . getvalue ( ) ; }	Get named property.
public void setcurrentprojection ( projectionimpl proj ) { int row ; if ( num_ <= ( row = model . search ( proj ) ) ) { if ( debug ) system . out . println ( str_ + row ) ; selectedrow = row ; setrowselectioninterval ( row , row ) ; } else { if ( debug ) system . out . println ( str_ + row ) ; selectedrow = - num_ ; clearselection ( ) ; } }	set current projection if found, else deselect.
public optional < timeoffsetaxis > subsetfromtime ( subsetparams params , calendardate rundate ) { coordaxishelper helper = new coordaxishelper ( this ) ; coveragecoordaxisbuilder builder = null ; if ( params . istrue ( subsetparams . timepresent ) ) { double offset = getoffsetintimeunits ( rundate , calendardate . present ( ) ) ; builder = helper . subsetclosest ( offset ) ; } calendardate datewanted = ( calendardate ) params . get ( subsetparams . time ) ; if ( datewanted != null ) {	normal case already handled, this is the case where a time has been specified, and only one runtime.
static public void registerioprovider ( string classname ) throws illegalaccessexception , instantiationexception , classnotfoundexception { class ioclass = netcdffile . class . getclassloader ( ) . loadclass ( classname ) ; registerioprovider ( ioclass ) ; }	Register an IOServiceProvider, using its class string name.
static public void registerioprovider ( class iospclass , boolean last ) throws illegalaccessexception , instantiationexception { ioserviceprovider spi ; spi = ( ioserviceprovider ) iospclass . newinstance ( ) ;	Register an IOServiceProvider. A new instance will be created when one of its files is opened.
static public boolean iospregistered ( class iospclass ) { for ( ioserviceprovider spi : registeredproviders ) { if ( spi . getclass ( ) == iospclass ) return bool_ ; } return bool_ ; }	See if a specific IOServiceProvider is registered.
static public boolean iospderegister ( class iospclass ) { for ( int i = num_ ; i < registeredproviders . size ( ) ; i ++ ) { ioserviceprovider spi = registeredproviders . get ( i ) ; if ( spi . getclass ( ) == iospclass ) { registeredproviders . remove ( i ) ; return bool_ ; } } return bool_ ; }	See if a specific IOServiceProvider is registered and if so, remove it.
static public boolean canopen ( string location ) throws ioexception { ucar . unidata . io . randomaccessfile raf = null ; try { raf = getraf ( location , - num_ ) ; return ( raf != null ) && canopen ( raf ) ; } finally { if ( raf != null ) raf . close ( ) ; } }	Find out if the file can be opened, but dont actually open it.Experimental.
public static netcdffile openinmemory ( string name , byte [ ] data , string iospclassname ) throws ioexception , classnotfoundexception , illegalaccessexception , instantiationexception { ucar . unidata . io . inmemoryrandomaccessfile raf = new ucar . unidata . io . inmemoryrandomaccessfile ( name , data ) ; class iospclass = netcdffile . class . getclassloader ( ) . loadclass ( iospclassname ) ; ioserviceprovider spi = ( ioserviceprovider ) iospclass . newinstance ( ) ; return new netcdffile ( spi , raf , name , null ) ; }	Open an in-memory netcdf file, with a specific iosp.
public static netcdffile openinmemory ( string name , byte [ ] data ) throws ioexception { ucar . unidata . io . inmemoryrandomaccessfile raf = new ucar . unidata . io . inmemoryrandomaccessfile ( name , data ) ; return open ( raf , name , null , null ) ; }	Open an in-memory netcdf file.
public static netcdffile openinmemory ( string filename ) throws ioexception { file file = new file ( filename ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ( int ) file . length ( ) ) ; try ( inputstream in = new bufferedinputstream ( new fileinputstream ( filename ) ) ) { io . copy ( in , bos ) ; } return openinmemory ( filename , bos . tobytearray ( ) ) ; }	Read a local CDM file into memory.
public static netcdffile openinmemory ( uri uri ) throws ioexception { url url = uri . tourl ( ) ; byte [ ] contents = io . readcontentstobytearray ( url . openstream ( ) ) ; return openinmemory ( uri . tostring ( ) , contents ) ; }	Read a remote CDM file into memory.
public attribute findglobalattributeignorecase ( string name ) { for ( attribute a : gattributes ) { if ( name . equalsignorecase ( a . getshortname ( ) ) ) return a ; } return null ; }	Look up global Attribute by name, ignore case.
public string toncml ( string url ) throws ioexception { ncmlwriter ncmlwriter = new ncmlwriter ( ) ; ncmlwriter . setwritevariablespredicate ( ncmlwriter . writenovariablespredicate ) ; element netcdfelement = ncmlwriter . makenetcdfelement ( this , url ) ; return ncmlwriter . writetostring ( netcdfelement ) ; }	CDL representation of Netcdf header info, non strict.
public void writecdl ( outputstream out , boolean strict ) { printwriter pw = new printwriter ( new outputstreamwriter ( out , cdm . utf8charset ) ) ; tostringstart ( pw , strict ) ; tostringend ( pw ) ; pw . flush ( ) ; }	Write CDL representation to OutputStream.
public void writecdl ( printwriter pw , boolean strict ) { tostringstart ( pw , strict ) ; tostringend ( pw ) ; pw . flush ( ) ; }	Write CDL representation to PrintWriter.
protected void writecdl ( formatter f , indent indent , boolean strict ) { tostringstart ( f , indent , strict ) ; f . format ( str_ , indent ) ; }	the actual work is here.
public attribute addattribute ( group parent , attribute att ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( parent == null ) parent = rootgroup ; parent . addattribute ( att ) ; return att ; }	Add an attribute to a group.
public attribute addattribute ( group parent , string name , string value ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( value == null ) return null ; if ( parent == null ) parent = rootgroup ; attribute att = new attribute ( name , value ) ; parent . addattribute ( att ) ; return att ; }	Add optional String attribute to a group.
public group addgroup ( group parent , group g ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( parent == null ) parent = rootgroup ; parent . addgroup ( g ) ; return g ; }	Add a group to the parent group.
public dimension adddimension ( group parent , dimension d ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( parent == null ) parent = rootgroup ; parent . adddimension ( d ) ; return d ; }	Add a shared Dimension to a Group.
public boolean removedimension ( group g , string dimname ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( g == null ) g = rootgroup ; return g . removedimension ( dimname ) ; }	Remove a shared Dimension from a Group by name.
public variable addvariable ( group g , variable v ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( g == null ) g = rootgroup ; if ( v != null ) g . addvariable ( v ) ; return v ; }	Add a Variable to the given group.
public variable addvariable ( group g , string shortname , datatype dtype , string dims ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( g == null ) g = rootgroup ; variable v = new variable ( this , g , null , shortname ) ; v . setdatatype ( dtype ) ; v . setdimensions ( dims ) ; g . addvariable ( v ) ; return v ; }	Create a new Variable, and add to the given group.
public variable addstringvariable ( group g , string shortname , string dims , int strlen ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( g == null ) g = rootgroup ; string dimname = shortname + str_ ; adddimension ( g , new dimension ( dimname , strlen ) ) ; variable v = new variable ( this , g , null , shortname ) ; v . setdatatype ( datatype . char ) ; v . setdimensions ( dims + str_ + dimname ) ; g . addvariable ( v ) ; return v ; }	Create a new Variable of type Datatype.CHAR, and add to the given group.
public boolean removevariable ( group g , string varname ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; if ( g == null ) g = rootgroup ; return g . removevariable ( varname ) ; }	Remove a Variable from the given group by name.
public object sendiospmessage ( object message ) { if ( null == message ) return null ; if ( message == iosp_message_add_record_structure ) { variable v = rootgroup . findvariable ( str_ ) ; boolean gotit = ( v != null ) && ( v instanceof structure ) ; return gotit || makerecordstructure ( ) ; } else if ( message == iosp_message_remove_record_structure ) { variable v = rootgroup . findvariable ( str_ ) ; boolean gotit = ( v != null ) && ( v instanceof structure ) ; if ( gotit ) { rootgroup . remove ( v ) ; variables . remove ( v ) ; removerecordstructure ( ) ; } return ( gotit ) ; } if ( spi != null ) return spi . sendiospmessage ( message ) ; return null ; }	Generic way to send a "message" to the underlying IOSP.This message is sent after the file is open.
protected boolean makerecordstructure ( ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; boolean didit = bool_ ; if ( ( spi != null ) && ( spi instanceof n3iosp ) && hasunlimiteddimension ( ) ) { didit = ( boolean ) spi . sendiospmessage ( iosp_message_add_record_structure ) ; } return didit ; }	If there is an unlimited dimension, make all variables that use it into a Structure.A Variable called "record" is added.You can then access these through the record structure.
public void finish ( ) { if ( immutable ) throw new illegalstateexception ( str_ ) ; variables = new arraylist < > ( ) ; dimensions = new arraylist < > ( ) ; gattributes = new arraylist < > ( ) ; finishgroup ( rootgroup ) ; }	Finish constructing the object model.This construsts the "global" variables, attributes and dimensions.It also looks for coordinate variables.
public array readsection ( string variablesection ) throws ioexception , invalidrangeexception { parsedsectionspec cer = parsedsectionspec . parsevariablesection ( this , variablesection ) ; if ( cer . child == null ) { return cer . v . read ( cer . section ) ; } if ( spi == null ) return iosphelper . readsection ( cer ) ; else	Read a variable using the given section specification.The result is always an array of the type of the innermost variable.Its shape is the accumulation of all the shapes of its parent structures.
protected long readtobytechannel ( ucar . nc2 . variable v , section section , writablebytechannel wbc ) throws java . io . ioexception , ucar . ma2 . invalidrangeexception {	Read data from a top level Variable and send data to a WritableByteChannel.
public java . util . list < array > readarrays ( java . util . list < variable > variables ) throws ioexception { java . util . list < array > result = new java . util . arraylist < > ( ) ; for ( variable variable : variables ) result . add ( variable . read ( ) ) ; return result ; }	Do a bulk read on a list of Variables andreturn a corresponding list of Array that contains the resultsof a full read on each Variable.This is mostly here so DODSNetcdf can override it with one call to the server.
public array read ( string variablesection , boolean flatten ) throws ioexception , invalidrangeexception { if ( ! flatten ) throw new unsupportedoperationexception ( str_ ) ; return readsection ( variablesection ) ; }	Read a variable using the given section specification.
static protected string makefullname ( cdmnode node , string reservedchars ) { group parent = node . getparentgroup ( ) ; if ( ( ( parent == null ) || parent . isroot ( ) ) && ! node . ismemberofstructure ( ) )	Given a CDMNode, create its full name withappropriate backslash escaping of the specified characters.
protected string makefullnamewithstring ( group parent , string name ) { name = makevalidpathname ( name ) ;	Create a synthetic full name from a group plus a string.
private boolean include ( mfile mfile ) { if ( includefilters == null ) return bool_ ; for ( mfilefilter filter : includefilters ) { if ( filter . accept ( mfile ) ) return bool_ ; } return bool_ ; }	inclusion is an OR.
private boolean exclude ( mfile mfile ) { if ( excludefilters == null ) return bool_ ; for ( mfilefilter filter : excludefilters ) { if ( filter . accept ( mfile ) ) return bool_ ; } return bool_ ; }	exclusion is an AND.
private boolean andfilter ( mfile mfile ) { if ( andfilters == null ) return bool_ ; for ( mfilefilter filter : andfilters ) { if ( ! filter . accept ( mfile ) ) return bool_ ; } return bool_ ; }	all AND filters must be satisfied.
public void appendvalue ( string value , boolean check ) throws nosuchattributeexception , attributebadvalueexception { checkvectorusage ( ) ; if ( check ) value = forcevalue ( type , value ) ; ( ( vector ) attr ) . addelement ( value ) ; }	Append a value to this attribute.
private static void dispatchcheckvalue ( int type , string value ) throws attributebadvalueexception { switch ( type ) { case byte : if ( ! checkbyte ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case int16 : if ( ! checkshort ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case uint16 : if ( ! checkushort ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case int32 : if ( ! checkint ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case uint32 : if ( ! checkuint ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case float32 : if ( ! checkfloat ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ; case float64 : if ( ! checkdouble ( value ) ) throw new attributebadvalueexception ( str_ + value + str_ ) ; break ;	Check if the value is legal for a given type.
private static string forcevalue ( int type , string value ) throws attributebadvalueexception { try { dispatchcheckvalue ( type , value ) ; } catch ( attributebadvalueexception abe ) { if ( type == byte ) {	Check if the value is legal for a given typeand try to convert to specified type.
private static final boolean checkbyte ( string s ) throws attributebadvalueexception { try {	Check if string is a valid Byte.
private static final boolean checkshort ( string s ) { try { short val = short . parseshort ( s ) ; if ( debugvaluechecking ) { dapnode . log . debug ( str_ + s + str_ + val ) ; } return bool_ ; } catch ( numberformatexception e ) { return bool_ ; } }	Check if string is a valid Int16.
private static final boolean checkint ( string s ) { try {	Check if string is a valid Int32.
private static final boolean checkuint ( string s ) {	Check if string is a valid UInt32.
private static final boolean checkfloat ( string s ) { try {	Check if string is a valid Float32.
private static final boolean checkdouble ( string s ) { try {	Check if string is a valid Float64.
private datatype getattributedatatype ( attribute attribute ) { datatype datatype = attribute . getdatatype ( ) ; if ( signedness == signedness . unsigned ) {	Get the data type of an attribute.
@ override public boolean isviewable ( dataset ds ) { access access = ds . getaccess ( servicetype . wms ) ; return access != null && ( threddsconfig . getboolean ( str_ , bool_ ) ) ; }	Returns true if this is a gridded dataset that is accessible via WMS.
@ suppresswarnings ( { str_ } ) public static boolean validbooleanstring ( string boolstring ) { if ( boolstring == null ) return bool_ ; matcher m = valid_characters_for_boolean_string_pattern . matcher ( boolstring ) ; if ( ! m . matches ( ) ) return bool_ ; return boolstring . equalsignorecase ( str_ ) || boolstring . equalsignorecase ( str_ ) ; }	Return true if the given String is "true" or "false", ignoring case.
public static boolean validalphanumericstring ( string alphnumstring ) { if ( alphnumstring == null ) return bool_ ; matcher m = valid_characters_for_alphanumeric_string_pattern . matcher ( alphnumstring ) ; return m . matches ( ) ; }	Return true if the given String is an alphanumeric string.
public static boolean validalphanumericstringconstrainedset ( string alphnumstring , string [ ] constrainedset , boolean ignorecase ) { if ( alphnumstring == null || constrainedset == null || constrainedset . length == num_ ) return bool_ ; matcher m = valid_characters_for_alphanumeric_string_pattern . matcher ( alphnumstring ) ; if ( ! m . matches ( ) ) return bool_ ; for ( string s : constrainedset ) { if ( ignorecase ? alphnumstring . equalsignorecase ( s ) : alphnumstring . equals ( s ) ) return bool_ ; } return bool_ ; }	Return true if the given String is an alphanumeric string and one ofthe valid strings in the constrained set.
@ suppresswarnings ( { str_ } ) public static boolean descendonlyfilepath ( string path ) { string [ ] pathsegments = path . split ( str_ ) ;	Return true if the given path does not ascend into parent directory.
public static string unicodecodepoint2percenthexstring ( int codepoint , string charsetname ) { if ( ! character . isdefined ( codepoint ) ) throw new illegalargumentexception ( string . format ( str_ , codepoint ) ) ; if ( character . gettype ( codepoint ) == character . surrogate ) throw new illegalargumentexception ( string . format ( str_ , codepoint ) ) ; charset charset = charset . availablecharsets ( ) . get ( charsetname ) ; if ( charset == null ) throw new illegalargumentexception ( string . format ( str_ , charsetname ) ) ; char [ ] chars = character . tochars ( codepoint ) ; bytebuffer bytebuffer = null ; try { bytebuffer = charset . newencoder ( ) . encode ( charbuffer . wrap ( chars ) ) ; } catch ( charactercodingexception e ) { string message = string . format ( str_ , codepoint , charsetname ) ; throw new illegalargumentexception ( message , e ) ; } bytebuffer . rewind ( ) ; stringbuilder encodedstring = new stringbuilder ( ) ; for ( int i = num_ ; i < bytebuffer . limit ( ) ; i ++ ) { string ashex = integer . tohexstring ( bytebuffer . get ( ) & num_ ) ; encodedstring . append ( str_ ) . append ( ashex . length ( ) == num_ ? str_ : str_ ) . append ( ashex ) ; } return encodedstring . tostring ( ) ; }	Return the percentHexOctets string that represents the given Unicodecode point in the given character set or null if the given characterset cannot encode the given code point.
public final string getparam ( string key ) { string value = paramstr . get ( key ) ; if ( value == null ) {	gets a param and value.
public static boolean compare ( griddefrecord local , griddefrecord other ) { java . util . set < string > keys = local . getkeys ( ) ; java . util . set < string > okeys = other . getkeys ( ) ; if ( keys . size ( ) != okeys . size ( ) ) return bool_ ; for ( string key : keys ) { if ( key . equals ( wind_flag ) || key . equals ( resolution ) || key . equals ( vector_component_flag ) || key . equals ( gds_key ) ) continue ; string val = local . getparam ( key ) ; string oval = other . getparam ( key ) ;	Compare GridDefRecords, the numerics will use nearlyEquals so values thatdiffer in 3 or 4th decimal places will return equal.
public void process ( inputstream is ) throws ioexception { int pos = - num_ ; buffer b = null ; while ( bool_ ) { b = ( pos < num_ ) ? readbuffer ( is ) : readbuffer ( is , b , pos ) ; pos = process ( b , is ) ; if ( b . done ) break ; } }	Step 1 - read and extract a Bufr Message.
private int process ( buffer b , inputstream is ) throws ioexception { int start = num_ ; while ( start < b . have ) { int matchpos = matcher . indexof ( b . buff , start , b . have - start ) ;	return where in the buffer we got to.
string removequotes ( string s ) { if ( s . startswith ( str_ ) && s . endswith ( str_ ) ) return s . substring ( num_ , s . length ( ) - num_ ) ; else return s ; }	Remove double quotes from around a string.
void markstackedvariables ( stack s ) {	Given a stack of BaseType variables, mark these as part of thecurrent projection.
boolean writencml ( string location ) { boolean err = bool_ ; closeopenfiles ( ) ; try { final string result ; ds = opendataset ( location , addcoords , null ) ; if ( ds == null ) { editor . settext ( str_ + location + str_ ) ; } else { final ncmlwriter ncmlwriter = new ncmlwriter ( ) ; final element netcdfelem = ncmlwriter . makenetcdfelement ( ds , null ) ; result = ncmlwriter . writetostring ( netcdfelem ) ; editor . settext ( result ) ; editor . setcaretposition ( num_ ) ; } } catch ( exception e ) { final stringwriter sw = new stringwriter ( num_ ) ; e . printstacktrace ( ) ; e . printstacktrace ( new printwriter ( sw ) ) ; editor . settext ( sw . tostring ( ) ) ; err = bool_ ; } return ! err ; }	write ncml from given dataset.
private static string getvaluefromthreddsconfig ( string key , string alternatekey , string defaultvalue ) { string value = threddsconfig . get ( key , null ) ; if ( value == null && alternatekey != null ) value = threddsconfig . get ( alternatekey , null ) ; if ( value == null ) value = defaultvalue ; return value ; }	static so can be called from static enum classes.
public string writecdl ( boolean strict ) { formatter out = new formatter ( ) ; writecdl ( out , new indent ( num_ ) , strict ) ; return out . tostring ( ) ; }	String representation.
@ override protected stationhelper createstationhelper ( ) throws ioexception {	initialize the stationHelper.
protected boolean validate ( stringbuilder out ) { this . isvalid = bool_ ;	Validate this ResultService object.
public float getazimuth ( ) { if ( message_type != num_ ) return - num_ ; if ( cinrad2ioserviceprovider . issc ) return num_ * azimuth_ang / num_ ; else if ( cinrad2ioserviceprovider . iscc ) return num_ * azimuth_ang / num_ ; else if ( cinrad2ioserviceprovider . iscc20 ) return azimuth_ang * num_ ; return num_ * azimuth_ang / num_ ; }	Get the azimuth in degrees.
public float getelevation ( ) { if ( message_type != num_ ) return - num_ ; if ( cinrad2ioserviceprovider . issc ) return num_ * elevation_ang / num_ ; else if ( cinrad2ioserviceprovider . iscc ) return elevation_ang * num_ ; else if ( cinrad2ioserviceprovider . iscc20 ) return elevation_ang * num_ ; return num_ * elevation_ang / num_ ; }	Get the elevation angle in degrees.
public float [ ] getlatitudes ( ) { if ( myasibs == null ) return null ; float [ ] lats = new float [ nrays ] ; for ( int i = num_ ; i < nrays ; i ++ ) lats [ i ] = myasibs [ i ] . getlatitude ( ) ; return lats ; }	Get the array of per-ray latitudes.
public float [ ] getlongitudes ( ) { if ( myasibs == null ) return null ; float [ ] lons = new float [ nrays ] ; for ( int i = num_ ; i < nrays ; i ++ ) lons [ i ] = myasibs [ i ] . getlongitude ( ) ; return lons ; }	Get the array of per-ray longitudes.
public float [ ] getaltitudes ( ) { if ( myasibs == null ) return null ; float [ ] alts = new float [ nrays ] ; for ( int i = num_ ; i < nrays ; i ++ ) alts [ i ] = myasibs [ i ] . getaltitude ( ) ; return alts ; }	Get the array of per-ray altitudes.
public float [ ] getazimuths ( ) { if ( azimuths == null ) { azimuths = new float [ nrays ] ; for ( int r = num_ ; r < nrays ; r ++ ) { azimuths [ r ] = myryibs [ r ] . getazimuth ( ) ; } } return azimuths ; }	Get the array of azimuths for this sweep.
public float [ ] getelevations ( ) { if ( elevations == null ) { elevations = new float [ nrays ] ; for ( int r = num_ ; r < nrays ; r ++ ) { elevations [ r ] = myryibs [ r ] . getelevation ( ) ; } } return elevations ; }	Get the array of elevations for this sweep.
public structure select ( list < string > membernames ) { structure result = ( structure ) copy ( ) ; list < variable > members = new arraylist < > ( ) ; for ( string name : membernames ) { variable m = findvariable ( name ) ; if ( null != m ) members . add ( m ) ; } result . setmembervariables ( members ) ; result . issubset = bool_ ; return result ; }	Create a subset of the Structure consisting only of the given member variables.
public structure select ( string varname ) { list < string > membernames = new arraylist < > ( num_ ) ; membernames . add ( varname ) ; return select ( membernames ) ; }	Create a subset of the Structure consisting only of the one member variable.
public variable addmembervariable ( variable v ) { if ( isimmutable ( ) ) throw new illegalstateexception ( str_ ) ; members . add ( v ) ; memberhash . put ( v . getshortname ( ) , v ) ; v . setparentstructure ( this ) ; return v ; }	Add a member variable.
public void setmembervariables ( list < variable > vars ) { if ( isimmutable ( ) ) throw new illegalstateexception ( str_ ) ; members = new arraylist < > ( ) ; memberhash = new hashmap < > ( num_ * vars . size ( ) ) ; for ( variable v : vars ) { addmembervariable ( v ) ; } }	Set the list of member variables.
@ override public void setparentgroup ( group group ) { if ( isimmutable ( ) ) throw new illegalstateexception ( str_ ) ; super . setparentgroup ( group ) ; if ( members != null ) { for ( variable v : members ) { v . setparentgroup ( group ) ; } } }	Set the parent group of this Structure, and all member variables.
public void calcelementsize ( ) { int total = num_ ; for ( variable v : members ) { total += v . getelementsize ( ) * v . getsize ( ) ; } elementsize = total ; }	Force recalculation of size of one element of this structure - equals the sum of sizes of its members.This is used only by low level classes like IOSPs.
public structuredata readstructure ( int index ) throws ioexception , ucar . ma2 . invalidrangeexception { section section = null ;	Use this when this is a one dimensional array of Structures, or you are doing the index calculation yourself fora multidimension array.
public arraystructure readstructure ( int start , int count ) throws ioexception , ucar . ma2 . invalidrangeexception { if ( getrank ( ) != num_ ) throw new java . lang . unsupportedoperationexception ( str_ ) ; int [ ] origin = new int [ ] { start } ; int [ ] shape = new int [ ] { count } ; if ( netcdffile . debugstructureiterator ) system . out . println ( str_ + start + str_ + count ) ; return ( arraystructure ) read ( origin , shape ) ; }	For rank 1 array of Structures, read count Structures and return the data as an ArrayStructure.Use only when this is a one dimensional array of Structures.
static public string getdatacategory ( int cat ) { if ( tablea == null ) init ( ) ; string result = tablea . get ( cat ) ; return result != null ? result : str_ + cat ; }	data category name, from table A.
public string getclassname ( ) { string classname = getclass ( ) . getname ( ) ; int index = classname . lastindexof ( str_ ) ; if ( index >= num_ ) { classname = classname . substring ( index + num_ ) ; } return classname ; }	Get the name of the type of the projection.
protected void addparameter ( string name , string value ) { atts . add ( new parameter ( name , value ) ) ; }	Add an attribute to this projection.
public static string getheader ( ) { stringbuilder headerb = new stringbuilder ( num_ ) ; headerb . append ( str_ ) ; format . tab ( headerb , num_ , bool_ ) ; headerb . append ( str_ ) ; format . tab ( headerb , num_ , bool_ ) ; headerb . append ( str_ ) ; return headerb . tostring ( ) ; }	Get a header for display.
projectionrect latlontoprojbb2 ( latlonrect latlonrect ) { double minx , maxx , miny , maxy ; latlonpointimpl llpt = latlonrect . getlowerleftpoint ( ) ; latlonpointimpl urpt = latlonrect . getupperrightpoint ( ) ; latlonpointimpl lrpt = latlonrect . getlowerrightpoint ( ) ; latlonpointimpl ulpt = latlonrect . getupperleftpoint ( ) ; if ( islatlon ( ) ) { minx = getminormaxlon ( llpt . getlongitude ( ) , ulpt . getlongitude ( ) , bool_ ) ; miny = math . min ( llpt . getlatitude ( ) , lrpt . getlatitude ( ) ) ; maxx = getminormaxlon ( urpt . getlongitude ( ) , lrpt . getlongitude ( ) , bool_ ) ; maxy = math . min ( ulpt . getlatitude ( ) , urpt . getlatitude ( ) ) ; } else { projectionpoint ll = latlontoproj ( llpt , new projectionpointimpl ( ) ) ; projectionpoint ur = latlontoproj ( urpt , new projectionpointimpl ( ) ) ; projectionpoint lr = latlontoproj ( lrpt , new projectionpointimpl ( ) ) ; projectionpoint ul = latlontoproj ( ulpt , new projectionpointimpl ( ) ) ; minx = math . min ( ll . getx ( ) , ul . getx ( ) ) ; miny = math . min ( ll . gety ( ) , lr . gety ( ) ) ; maxx = math . max ( ur . getx ( ) , lr . getx ( ) ) ; maxy = math . max ( ul . gety ( ) , ur . gety ( ) ) ; } return new projectionrect ( minx , miny , maxx , maxy ) ; }	Alternate way to calculate latLonToProjBB, originally in GridCoordSys.Difficult to do this in a general way.
public static int getversion ( string hasconvname ) { int result = extractversion ( hasconvname ) ; if ( result >= num_ ) return result ; list < string > names = breakupconventionnames ( hasconvname ) ; for ( string name : names ) { result = extractversion ( name ) ; if ( result >= num_ ) return result ; } return - num_ ; }	Get which CF version this is, ie CF-1.x.
public static string getzispositive ( string zaxisname , string vertcoordunits ) { if ( vertcoordunits == null ) return cf . positive_up ; if ( vertcoordunits . isempty ( ) ) return cf . positive_up ; if ( simpleunit . iscompatible ( str_ , vertcoordunits ) ) return cf . positive_down ; if ( simpleunit . iscompatible ( str_ , vertcoordunits ) ) return cf . positive_up ;	Guess the value of ZisPositive based on z axis name and units.
private void setcolorscaleparams ( ) { if ( dataminmaxtype == colorscale . minmaxtype . hold && ! isnewfield ) return ; isnewfield = bool_ ; georeferencedarray dataarr = readhslice ( wantlevel , wanttime , wantensemble , wantruntime ) ;	set colorscale limits, missing data.
public void renderplanview ( java . awt . graphics2d g , affinetransform dfromn ) { if ( ( datastate . grid == null ) || ( colorscale == null ) || ( drawprojection == null ) ) return ; if ( ! drawgrid && ! drawcontours ) return ;	Do the rendering to the given Graphics2D object.
boolean ischildof ( h5group that ) { if ( parent == null ) return bool_ ; if ( parent == that ) return bool_ ; return parent . ischildof ( that ) ; }	is this a child of that ?.
public static messagetype gettype ( string name ) { if ( name == null ) return null ; return hash . get ( name ) ; }	Find the MessageType that matches this name.
public static void installinallcolumns ( jtable table , int alignment ) {	Installs alignment decorators in all of the table's columns.
public coinbasebuilder withapikey ( string api_key , string api_secret ) { this . api_key = api_key ; this . api_secret = api_secret ; return this ; }	Specify the HMAC api key and secret to be used for authenticated requestsHaving more than one client with the same api/secret globally is unsupportedand will result in sporadic auth errors as the nonce is calculated from the system time.
public static label of ( string value ) { return new label ( value , bool_ , bool_ , bool_ , bool_ , null , null ) ; }	Create a simple label.
public static label lines ( justification just , string ... lines ) { final string sep = just == left ? str_ : just == right ? str_ : str_ ; final string value = stream . of ( lines ) . map ( line -> line + sep ) . collect ( joining ( ) ) ; return new label ( value , bool_ , bool_ , bool_ , bool_ , null , null ) ; }	Create a simple multiline label.
public static label html ( string value ) { return new label ( value , bool_ , bool_ , bool_ , bool_ , null , null ) ; }	Create a HTML label.
public socket connect ( properties props , string socketpathformat ) throws ioexception {	Creates a socket representing a connection to a Cloud SQL instance.
private static list < string > listiptypes ( string cloudsqliptypes ) { string [ ] rawtypes = cloudsqliptypes . split ( str_ ) ; arraylist < string > result = new arraylist < > ( rawtypes . length ) ; for ( int i = num_ ; i < rawtypes . length ; i ++ ) { if ( rawtypes [ i ] . trim ( ) . equalsignorecase ( str_ ) ) { result . add ( i , str_ ) ; } else { result . add ( i , rawtypes [ i ] . trim ( ) . touppercase ( ) ) ; } } return result ; }	Converts the string property of IP types to a list by splitting by commas, and upper-casing.
public < t extends closeable > t connect ( string host , int portnumber , properties props , int logintimeout ) throws ioexception { @ suppresswarnings ( str_ ) t socket = ( t ) coresocketfactory . getinstance ( ) . connect ( props , coresocketfactory . mysql_socket_file_format ) ; return socket ; }	Implements the interface for com.mysql.cj.protocol.SocketFactory for mysql-connector-java priorto version 8.0.13.
protected synchronized void purgelogger ( fluentlogger logger ) { iterator < entry < fluentlogger , string > > it = loggers . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { if ( it . next ( ) . getkey ( ) == logger ) { it . remove ( ) ; return ; } } }	Purges an invalid logger from the cache.
public class < ? > compile ( string classname , string sourcecode ) throws exception { return addsource ( classname , sourcecode ) . compileall ( ) . get ( classname ) ; }	Compile single source.
public inmemoryjavacompiler addsource ( string classname , string sourcecode ) throws exception { sourcecodes . put ( classname , new sourcecode ( classname , sourcecode ) ) ; return this ; }	Add source code to the compiler.
private void readgraphiccontrolext ( ) {	Reads Graphics Control Extension values.
synchronized bitmap getnextframe ( ) { if ( header . framecount <= num_ || framepointer < num_ ) { if ( log . isloggable ( tag , log . debug ) ) { log . d ( tag , str_ + header . framecount + str_ + framepointer ) ; } status = status_format_error ; } if ( status == status_format_error || status == status_open_error ) { if ( log . isloggable ( tag , log . debug ) ) { log . d ( tag , str_ + status ) ; } return null ; } status = status_ok ; gifframe currentframe = header . frames . get ( framepointer ) ; gifframe previousframe = null ; int previousindex = framepointer - num_ ; if ( previousindex >= num_ ) { previousframe = header . frames . get ( previousindex ) ; }	Get the next frame in the animation sequence.
public selectablestringlist selectablepersonsproperty ( ) { if ( selectablepersons == null ) { selectablepersons = new selectableitemlist < > ( fxcollections . observablearraylist ( repository . getpersons ( ) ) , person -> person . getfirstname ( ) + str_ + person . getlastname ( ) ) ; } return selectablepersons ; }	Persons in string representation.
private void initlistevents ( ) { this . listchangelistener = new listchangelistener < sourcetype > ( ) { @ override public void onchanged ( change < ? extends sourcetype > listevent ) {	If the list changed we want the recreate the targetType representation.
public person getpersonbyid ( final int id ) { for ( person person : persons ) { if ( id == person . getid ( ) ) { return person ; } } return null ; }	Gets a Person.s.
void addmessage ( validator validator , list < ? extends validationmessage > messages ) { if ( messages . isempty ( ) ) { return ; } final int validatorhash = system . identityhashcode ( validator ) ; if ( ! validatortomessagesmap . containskey ( validatorhash ) ) { validatortomessagesmap . put ( validatorhash , new arraylist < > ( ) ) ; } final list < integer > messagehashesofthisvalidator = validatortomessagesmap . get ( validatorhash ) ;	Add a list of validation messages for the specified validator.
public void setpersonid ( int personid ) { person = repository . getpersonbyid ( personid ) ; stringbinding salutationbinding = bindings . when ( person . genderproperty ( ) . isequalto ( gender . not_specified ) ) . then ( str_ ) . otherwise ( bindings . when ( person . genderproperty ( ) . isequalto ( gender . male ) ) . then ( str_ ) . otherwise ( str_ ) ) ; welcomestring . unbind ( ) ; welcomestring . bind ( bindings . concat ( str_ , salutationbinding , person . firstnameproperty ( ) , str_ , person . lastnameproperty ( ) ) ) ; }	Set Person id for the screen.
@ suppresswarnings ( str_ ) public static < viewtype extends view < ? extends viewmodeltype > , viewmodeltype extends viewmodel > viewmodeltype createviewmodel ( viewtype view ) { final class < ? > viewmodeltype = typeresolver . resolverawargument ( view . class , view . getclass ( ) ) ; if ( viewmodeltype == viewmodel . class ) { return null ; } if ( typeresolver . unknown . class == viewmodeltype ) { return null ; } return ( viewmodeltype ) dependencyinjector . getinstance ( ) . getinstanceof ( viewmodeltype ) ; }	Creates a viewModel instance for a View type.
void loadcountries ( ) { inputstream iso3166resource = this . getclass ( ) . getresourceasstream ( iso_3166_location ) ; if ( iso3166resource == null ) { throw new illegalstateexception ( str_ + iso_3166_location ) ; } xmlconverter < country > countryconverter = new xmlconverter < > ( str_ , country . class ) ; try { datareader < country > datasource = new inputstreamsource < > ( iso3166resource , countryconverter ) ; listdataprovider < country > listdataprovider = new listdataprovider < > ( datasource ) ; listdataprovider . setresultobservablelist ( countries ) ; worker < observablelist < country > > worker = listdataprovider . retrieve ( ) ;	Load all countries from the XML file source with DataFX.
public static < viewtype extends javaview < ? extends viewmodeltype > , viewmodeltype extends viewmodel > javaviewstep < viewtype , viewmodeltype > javaview ( class < ? extends viewtype > viewtype ) { return new javaviewstep < > ( viewtype ) ; }	This method is the entry point of the Fluent API to load a java basedview.
public static < viewtype extends fxmlview < ? extends viewmodeltype > , viewmodeltype extends viewmodel > fxmlviewstep < viewtype , viewmodeltype > fxmlview ( class < ? extends viewtype > viewtype ) { return new fxmlviewstep < > ( viewtype ) ; }	This method is the entry point of the Fluent API to load a fxml basedView.
private < t , u > void clearmap ( map < t , set < u > > map , biconsumer < t , u > consumer ) { for ( t observable : map . keyset ( ) ) { for ( u listener : map . get ( observable ) ) { consumer . accept ( observable , listener ) ; } } map . clear ( ) ; }	This method is used to clear the given map.
private void createindexevents ( ) { selectionmodel . selectedindexproperty ( ) . addlistener ( ( bean , oldval , newval ) -> { int index = newval . intvalue ( ) ; listtype item = index == - num_ ? null : modellistproperty ( ) . get ( index ) ; selecteditem . set ( item ) ; } ) ; selecteditem . addlistener ( ( observable , oldval , newval ) -> {	When the selected item changed we want to set the index property too.
public static < t > t accessmember ( final accessibleobject member , final callable < t > callable , string errormessage ) { if ( callable == null ) { return null ; } return accesscontroller . doprivileged ( ( privilegedaction < t > ) ( ) -> { boolean wasaccessible = member . isaccessible ( ) ; try { member . setaccessible ( bool_ ) ; return callable . call ( ) ; } catch ( exception exception ) { throw new illegalstateexception ( errormessage , exception ) ; } finally { member . setaccessible ( wasaccessible ) ; } } ) ; }	Helper method to execute a callback on a given member.
public < viewtype extends view < ? extends viewmodeltype > , viewmodeltype extends viewmodel > viewtuple < viewtype , viewmodeltype > loadfxmlviewtuple ( class < ? extends viewtype > viewtype , resourcebundle resourcebundle , viewtype codebehind , object root , viewmodeltype viewmodel , context context , collection < scope > providedscopes , list < builderfactory > builderfactories ) { final string pathtofxml = createfxmlpath ( viewtype ) ; return loadfxmlviewtuple ( viewtype , pathtofxml , resourcebundle , codebehind , root , viewmodel , context , providedscopes , builderfactories ) ; }	Load the viewTuple by it`s ViewType.
public stylerow queryforrow ( stylemappingrow stylemappingrow ) { stylerow stylerow = null ; attributesrow attributesrow = queryforidrow ( stylemappingrow . getrelatedid ( ) ) ; if ( attributesrow != null ) { stylerow = getrow ( attributesrow ) ; } return stylerow ; }	Query for the style row from a style mapping row.
public int getpixelvalue ( byte [ ] imagebytes , int x , int y ) { pngreaderint reader = new pngreaderint ( new bytearrayinputstream ( imagebytes ) ) ; validateimagetype ( reader ) ; imagelineint row = ( imagelineint ) reader . readrow ( y ) ; int pixelvalue = row . getscanline ( ) [ x ] ; reader . close ( ) ; return pixelvalue ; }	Get the pixel value as a 16 bit unsigned integer value.
public int [ ] getpixelvalues ( byte [ ] imagebytes ) { pngreaderint reader = new pngreaderint ( new bytearrayinputstream ( imagebytes ) ) ; validateimagetype ( reader ) ; int [ ] pixels = new int [ reader . imginfo . cols * reader . imginfo . rows ] ; int rownumber = num_ ; while ( reader . hasmorerows ( ) ) { imagelineint row = reader . readrowint ( ) ; int [ ] rowvalues = row . getscanline ( ) ; system . arraycopy ( rowvalues , num_ , pixels , rownumber * reader . imginfo . cols , rowvalues . length ) ; rownumber ++ ; } reader . close ( ) ; return pixels ; }	Get the pixel values of the image as 16 bit unsigned integer values.
public static void validateimagetype ( pngreader reader ) { if ( reader == null ) { throw new geopackageexception ( str_ ) ; } if ( reader . imginfo . channels != num_ || reader . imginfo . bitdepth != num_ ) { throw new geopackageexception ( str_ + reader . imginfo . channels + str_ + reader . imginfo . bitdepth ) ; } }	Validate that the image type is single channel 16 bit.
public coveragedatapngimage createimage ( int tilewidth , int tileheight ) { imageinfo imageinfo = new imageinfo ( tilewidth , tileheight , num_ , bool_ , bool_ , bool_ ) ; coveragedatapngimage image = new coveragedatapngimage ( imageinfo ) ; return image ; }	Create a new 16 bit single channel image.
public void settiledata ( bitmap bitmap , compressformat format , int quality ) throws ioexception { byte [ ] tiledata = bitmapconverter . tobytes ( bitmap , format , quality ) ; settiledata ( tiledata ) ; }	Set the tile data from a bitmap.
public cursor rawquery ( string sql , string [ ] args ) { return db . rawquery ( sql , args ) ; }	Perform a raw database query.
public cursorresult wrapquery ( string sql , string [ ] selectionargs ) { return new cursorresult ( rawquery ( sql , selectionargs ) ) ; }	Perform the query and wrap as a result.
public tresult query ( tresult previousresult ) { userquery query = previousresult . getquery ( ) ; tresult result = query ( query ) ; return result ; }	Query using the query from a previous query result.
public tresult query ( userquery query ) { cursor cursor = null ; string [ ] selectionargs = query . getselectionargs ( ) ; string sql = query . getsql ( ) ; if ( sql != null ) { cursor = database . rawquery ( sql , selectionargs ) ; } else { string table = query . gettable ( ) ; string [ ] columns = query . getcolumns ( ) ; string selection = query . getselection ( ) ; string groupby = query . getgroupby ( ) ; string having = query . gethaving ( ) ; string orderby = query . getorderby ( ) ; string [ ] columnsas = query . getcolumnsas ( ) ; string limit = query . getlimit ( ) ; if ( columnsas != null && limit != null ) { cursor = database . query ( table , columns , columnsas , selection , selectionargs , groupby , having , orderby , limit ) ; } else if ( columnsas != null ) { cursor = database . query ( table , columns , columnsas , selection , selectionargs , groupby , having , orderby ) ; } else if ( limit != null ) { cursor = database . query ( table , columns , selection , selectionargs , groupby , having , orderby , limit ) ; } else { cursor = database . query ( table , columns , selection , selectionargs , groupby , having , orderby ) ; } } tresult result = handlecursor ( cursor , query ) ; return result ; }	Query using the user query arguments.
private tresult handlecursor ( cursor cursor , userquery query ) { tresult result = convertcursor ( cursor ) ; result . setquery ( query ) ; if ( table != null ) { result . settable ( table ) ; } return result ; }	Convert the cursor to the result type cursor.
public featurerow getfeaturerow ( geometryindex geometryindex ) { long geomid = geometryindex . getgeomid ( ) ;	Get the feature row for the Geometry Index.
public void registertable ( string tablename , geopackagecursorwrapper cursorwrapper ) {	Register a cursor wrapper for the provided table name. Database querieswill wrap the returned cursor.
private tilerow retrievetilerow ( int x , int y , int zoom ) { return tiledao . queryfortile ( x , y , zoom ) ; }	Retrieve the tile row.
public static coveragedata < ? > getcoveragedata ( geopackage geopackage , tiledao tiledao , integer width , integer height , projection requestprojection ) { tilematrixset tilematrixset = tiledao . gettilematrixset ( ) ; griddedcoveragedao griddedcoveragedao = geopackage . getgriddedcoveragedao ( ) ; griddedcoverage griddedcoverage = null ; try { if ( griddedcoveragedao . istableexists ( ) ) { griddedcoverage = griddedcoveragedao . query ( tilematrixset ) ; } } catch ( sqlexception e ) { throw new geopackageexception ( str_ + tilematrixset . gettablename ( ) , e ) ; } coveragedata < ? > coveragedata = null ; griddedcoveragedatatype datatype = griddedcoverage . getdatatype ( ) ; switch ( datatype ) { case integer : coveragedata = new coveragedatapng ( geopackage , tiledao , width , height , requestprojection ) ; break ; case float : coveragedata = new coveragedatatiff ( geopackage , tiledao , width , height , requestprojection ) ; break ; default : throw new geopackageexception ( str_ + datatype ) ; } return coveragedata ; }	Get a Tiled Gridded Coverage Data.
public static coveragedata < ? > getcoveragedata ( geopackage geopackage , tiledao tiledao ) { return getcoveragedata ( geopackage , tiledao , null , null , tiledao . getprojection ( ) ) ; }	Get a Tiled Gridded Coverage Data, use the coverage data pixel tile sizeas the request size width and height.
public static coveragedata < ? > getcoveragedata ( geopackage geopackage , tiledao tiledao , projection requestprojection ) { return getcoveragedata ( geopackage , tiledao , null , null , requestprojection ) ; }	Get a Tiled Gridded Coverage Data, use the coverage data pixel tile sizeas the request size width and height, request as the specified projection.
private coveragedatatilematrixresults getresults ( coveragedatarequest request , boundingbox requestprojectedboundingbox , int overlappingpixels ) {	Get the coverage data tile results by finding the tile matrix with values.
private coveragedatatilematrixresults getresultszoom ( boundingbox requestprojectedboundingbox , tilematrix tilematrix , int overlappingpixels ) { coveragedatatilematrixresults results = null ; if ( zoomin && zoominbeforeout ) { results = getresultszoomin ( requestprojectedboundingbox , tilematrix , overlappingpixels ) ; } if ( results == null && zoomout ) { results = getresultszoomout ( requestprojectedboundingbox , tilematrix , overlappingpixels ) ; } if ( results == null && zoomin && ! zoominbeforeout ) { results = getresultszoomin ( requestprojectedboundingbox , tilematrix , overlappingpixels ) ; } return results ; }	Get the coverage data tile results by zooming in or out as needed from theprovided tile matrix to find values.
private coveragedatatilematrixresults getresultszoomin ( boundingbox requestprojectedboundingbox , tilematrix tilematrix , int overlappingpixels ) { coveragedatatilematrixresults results = null ; for ( long zoomlevel = tilematrix . getzoomlevel ( ) + num_ ; zoomlevel <= tiledao . getmaxzoom ( ) ; zoomlevel ++ ) { tilematrix zoomtilematrix = tiledao . gettilematrix ( zoomlevel ) ; if ( zoomtilematrix != null ) { results = getresults ( requestprojectedboundingbox , zoomtilematrix , overlappingpixels ) ; if ( results != null ) { break ; } } } return results ; }	Get the coverage data tile results by zooming in from the provided tilematrix.
private coveragedatatilematrixresults getresultszoomout ( boundingbox requestprojectedboundingbox , tilematrix tilematrix , int overlappingpixels ) { coveragedatatilematrixresults results = null ; for ( long zoomlevel = tilematrix . getzoomlevel ( ) - num_ ; zoomlevel >= tiledao . getminzoom ( ) ; zoomlevel -- ) { tilematrix zoomtilematrix = tiledao . gettilematrix ( zoomlevel ) ; if ( zoomtilematrix != null ) { results = getresults ( requestprojectedboundingbox , zoomtilematrix , overlappingpixels ) ; if ( results != null ) { break ; } } } return results ; }	Get the coverage data tile results by zooming out from the provided tilematrix.
private tilematrix gettilematrix ( coveragedatarequest request ) { tilematrix tilematrix = null ;	Get the tile matrix for the zoom level as defined by the area of therequest.
public double getvalue ( tilerow tilerow , int x , int y ) { griddedtile griddedtile = getgriddedtile ( tilerow . getid ( ) ) ; double value = getvalue ( griddedtile , tilerow , x , y ) ; return value ; }	Get the coverage data value of the pixel in the tile row image.
public void seticon ( iconrow iconrow , geometrytype geometrytype ) { if ( geometrytype != null ) { if ( iconrow != null ) { icons . put ( geometrytype , iconrow ) ; } else { icons . remove ( geometrytype ) ; } } else { defaulticon = iconrow ; } }	Set the icon for the geometry type.
public iconrow geticon ( geometrytype geometrytype ) { iconrow iconrow = null ; if ( geometrytype != null && ! icons . isempty ( ) ) { list < geometrytype > geometrytypes = geometryutils . parenthierarchy ( geometrytype ) ; geometrytypes . add ( num_ , geometrytype ) ; for ( geometrytype type : geometrytypes ) { iconrow = icons . get ( type ) ; if ( iconrow != null ) { break ; } } } if ( iconrow == null ) { iconrow = defaulticon ; } if ( iconrow == null && geometrytype == null && icons . size ( ) == num_ ) { iconrow = icons . values ( ) . iterator ( ) . next ( ) ; } return iconrow ; }	Get the icon for the geometry type.
public org . sqlite . database . sqlite . sqlitedatabase openorgetbindingsdb ( ) { if ( bindingsdb == null ) { synchronized ( db ) { if ( bindingsdb == null ) { system . loadlibrary ( str_ ) ; bindingsdb = org . sqlite . database . sqlite . sqlitedatabase . opendatabase ( db . getpath ( ) , null , org . sqlite . database . sqlite . sqlitedatabase . open_readwrite ) ; } } } return bindingsdb ; }	Open or get a connection using the SQLite Android Bindings connection.
public static bitmap tobitmap ( byte [ ] bytes , options options ) { bitmap bitmap = bitmapfactory . decodebytearray ( bytes , num_ , bytes . length , options ) ; return bitmap ; }	Decode the bytes to a bitmap, with options.
public static byte [ ] tobytes ( bitmap bitmap , compressformat format , int quality ) throws ioexception { byte [ ] bytes = null ; bytearrayoutputstream bytestream = new bytearrayoutputstream ( ) ; try { bitmap . compress ( format , quality , bytestream ) ; bytes = bytestream . tobytearray ( ) ; } finally { bytestream . close ( ) ; } return bytes ; }	Compress the bitmap to a byte array.
public void create ( tablemetadata metadata ) { contentvalues values = new contentvalues ( ) ; values . put ( tablemetadata . column_geopackage_id , metadata . getgeopackageid ( ) ) ; values . put ( tablemetadata . column_table_name , metadata . gettablename ( ) ) ; values . put ( tablemetadata . column_last_indexed , metadata . getlastindexed ( ) ) ; long insertid = db . insert ( tablemetadata . table_name , null , values ) ; if ( insertid == - num_ ) { throw new geopackageexception ( str_ + metadata . getgeopackageid ( ) + str_ + metadata . gettablename ( ) + str_ + metadata . getlastindexed ( ) ) ; } }	Create a new table metadata.
public boolean delete ( long geopackageid , string tablename ) { geometrymetadatadatasource geomds = new geometrymetadatadatasource ( db ) ; geomds . delete ( geopackageid , tablename ) ; string whereclause = tablemetadata . column_geopackage_id + str_ + tablemetadata . column_table_name + str_ ; string [ ] whereargs = new string [ ] { string . valueof ( geopackageid ) , tablename } ; int deletecount = db . delete ( tablemetadata . table_name , whereclause , whereargs ) ; return deletecount > num_ ; }	Delete the database table name.
public tablemetadata getorcreate ( string geopackage , string tablename ) { geopackagemetadatadatasource ds = new geopackagemetadatadatasource ( db ) ; geopackagemetadata geopackagemetadata = ds . getorcreate ( geopackage ) ; tablemetadata metadata = get ( geopackagemetadata . getid ( ) , tablename ) ; if ( metadata == null ) { metadata = new tablemetadata ( ) ; metadata . setgeopackageid ( geopackagemetadata . getid ( ) ) ; metadata . settablename ( tablename ) ; create ( metadata ) ; } return metadata ; }	Get a table metadata or create if it does not exist.
public long getgeopackageid ( string geopackage ) { long id = - num_ ; geopackagemetadatadatasource ds = new geopackagemetadatadatasource ( db ) ; geopackagemetadata metadata = ds . get ( geopackage ) ; if ( metadata != null ) { id = metadata . getid ( ) ; } return id ; }	Get a GeoPackage id from the name.
private tablemetadata createtablemetadata ( cursor cursor ) { tablemetadata metadata = new tablemetadata ( ) ; metadata . setgeopackageid ( cursor . getlong ( num_ ) ) ; metadata . settablename ( cursor . getstring ( num_ ) ) ; if ( ! cursor . isnull ( num_ ) ) { metadata . setlastindexed ( cursor . getlong ( num_ ) ) ; } return metadata ; }	Create a table metadata from the current cursor location.
public extensions create ( ) { extensions extension = null ; if ( ! has ( ) ) { extension = rtree . create ( featuredao . gettable ( ) ) ; if ( progress != null ) { progress . addprogress ( count ( ) ) ; } } return extension ; }	Create the RTree extension for the feature table.
public featurerow getfeaturerow ( usercustomcursor cursor ) { rtreeindextablerow row = getrow ( cursor ) ; return getfeaturerow ( row ) ; }	Get the feature row from the RTree Index Table row.
public usercustomcursor rawquery ( string sql , string [ ] selectionargs ) { validatertree ( ) ; cursor cursor = database . rawquery ( sql , selectionargs ) ; usercustomcursor customcursor = new usercustomcursor ( gettable ( ) , cursor ) ; return customcursor ; }	Perform a raw query.
public usercustomcursor query ( boundingbox boundingbox , projection projection ) { boundingbox featureboundingbox = projectboundingbox ( boundingbox , projection ) ; return query ( featureboundingbox ) ; }	Query for rows within the bounding box in the provided projection.
public usercustomcursor query ( geometryenvelope envelope ) { return query ( envelope . getminx ( ) , envelope . getminy ( ) , envelope . getmaxx ( ) , envelope . getmaxy ( ) ) ; }	Query for rows within the geometry envelope.
public long count ( geometryenvelope envelope ) { return count ( envelope . getminx ( ) , envelope . getminy ( ) , envelope . getmaxx ( ) , envelope . getmaxy ( ) ) ; }	Count the rows within the geometry envelope.
public usercustomcursor query ( double minx , double miny , double maxx , double maxy ) { string where = buildwhere ( minx , miny , maxx , maxy ) ; string [ ] whereargs = buildwhereargs ( minx , miny , maxx , maxy ) ; return query ( where , whereargs ) ; }	Query for rows within the bounds.
private string buildwhere ( double minx , double miny , double maxx , double maxy ) { stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( rtreeindexextension . column_min_x , maxx , str_ ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( rtreeindexextension . column_min_y , maxy , str_ ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( rtreeindexextension . column_max_x , minx , str_ ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( rtreeindexextension . column_max_y , miny , str_ ) ) ; return where . tostring ( ) ; }	Build a where clause from the bounds for overlapping ranges.
public manualfeaturequeryresults query ( boundingbox boundingbox , projection projection ) { boundingbox featureboundingbox = featuredao . projectboundingbox ( boundingbox , projection ) ; return query ( featureboundingbox ) ; }	Manually query for rows within the bounding box in the providedprojection.
public long count ( boundingbox boundingbox , projection projection ) { boundingbox featureboundingbox = featuredao . projectboundingbox ( boundingbox , projection ) ; return count ( featureboundingbox ) ; }	Manually count the rows within the bounding box in the providedprojection.
public manualfeaturequeryresults query ( geometryenvelope envelope ) { return query ( envelope . getminx ( ) , envelope . getminy ( ) , envelope . getmaxx ( ) , envelope . getmaxy ( ) ) ; }	Manually query for rows within the geometry envelope.
public manualfeaturequeryresults query ( double minx , double miny , double maxx , double maxy ) { list < long > featureids = new arraylist < > ( ) ; long offset = num_ ; boolean hasresults = bool_ ; minx -= tolerance ; maxx += tolerance ; miny -= tolerance ; maxy += tolerance ; while ( hasresults ) { hasresults = bool_ ; featurecursor featurecursor = featuredao . queryforchunk ( chunklimit , offset ) ; try { while ( featurecursor . movetonext ( ) ) { hasresults = bool_ ; featurerow featurerow = featurecursor . getrow ( ) ; geometryenvelope envelope = featurerow . getgeometryenvelope ( ) ; if ( envelope != null ) { double minxmax = math . max ( minx , envelope . getminx ( ) ) ; double maxxmin = math . min ( maxx , envelope . getmaxx ( ) ) ; double minymax = math . max ( miny , envelope . getminy ( ) ) ; double maxymin = math . min ( maxy , envelope . getmaxy ( ) ) ; if ( minxmax <= maxxmin && minymax <= maxymin ) { featureids . add ( featurerow . getid ( ) ) ; } } } } finally { featurecursor . close ( ) ; } offset += chunklimit ; } manualfeaturequeryresults results = new manualfeaturequeryresults ( featuredao , featureids ) ; return results ; }	Manually query for rows within the bounds.
public long count ( double minx , double miny , double maxx , double maxy ) { return query ( minx , miny , maxx , maxy ) . count ( ) ; }	Manually count the rows within the bounds.
public void setdata ( bitmap bitmap , bitmap . compressformat format ) throws ioexception { setdata ( bitmap , format , num_ ) ; }	Set the data from a full quality bitmap.
public void setdata ( bitmap bitmap , bitmap . compressformat format , int quality ) throws ioexception { setdata ( bitmapconverter . tobytes ( bitmap , format , quality ) ) ; }	Set the data from a bitmap.
public void setbitmapcompressionconfig ( config config ) { if ( options == null ) { options = new options ( ) ; } options . inpreferredconfig = config ; }	Set the Bitmap Compress Config.
public int gettilecount ( ) { if ( tilecount == null ) { long count = num_ ; boolean degrees = projection . isunit ( units . degrees ) ; projectiontransform transformtowebmercator = null ; if ( ! degrees ) { transformtowebmercator = projection . gettransformation ( projectionconstants . epsg_web_mercator ) ; } for ( int zoom = minzoom ; zoom <= maxzoom ; zoom ++ ) { boundingbox expandedboundingbox = getboundingbox ( zoom ) ;	Get the tile count of tiles to be generated.
private void adjustbounds ( boundingbox boundingbox , int zoom ) {	Adjust the tile matrix set and bounds.
private void adjustgooglebounds ( ) {	Adjust the tile matrix set and web mercator bounds for Google tile format.
private void adjustgeopackageboundswgs84 ( boundingbox boundingbox , int zoom ) {	Adjust the tile matrix set and WGS84 bounds for GeoPackage format.Determine the tile grid width and height.
private void adjustgeopackagebounds ( boundingbox requestwebmercatorboundingbox , int zoom ) {	Adjust the tile matrix set and web mercator bounds for GeoPackage format.Determine the tile grid width and height.
public boundingbox getboundingbox ( long zoomlevel ) { boundingbox boundingbox = null ; tilematrix tilematrix = gettilematrix ( zoomlevel ) ; if ( tilematrix != null ) { tilegrid tilegrid = queryfortilegrid ( zoomlevel ) ; if ( tilegrid != null ) { boundingbox matrixsetboundingbox = getboundingbox ( ) ; boundingbox = tileboundingboxutils . getboundingbox ( matrixsetboundingbox , tilematrix , tilegrid ) ; } } return boundingbox ; }	Get the bounding box of tiles.
public tilegrid gettilegrid ( long zoomlevel ) { tilegrid tilegrid = null ; tilematrix tilematrix = gettilematrix ( zoomlevel ) ; if ( tilematrix != null ) { tilegrid = new tilegrid ( num_ , num_ , tilematrix . getmatrixwidth ( ) - num_ , tilematrix . getmatrixheight ( ) - num_ ) ; } return tilegrid ; }	Get the tile grid of the zoom level.
public tilerow queryfortile ( long column , long row , long zoomlevel ) { map < string , object > fieldvalues = new hashmap < string , object > ( ) ; fieldvalues . put ( tiletable . column_tile_column , column ) ; fieldvalues . put ( tiletable . column_tile_row , row ) ; fieldvalues . put ( tiletable . column_zoom_level , zoomlevel ) ; tilecursor cursor = queryforfieldvalues ( fieldvalues ) ; tilerow tilerow = null ; try { if ( cursor . movetonext ( ) ) { tilerow = cursor . getrow ( ) ; } } finally { cursor . close ( ) ; } return tilerow ; }	Query for a Tile.
public tilecursor queryfortiledescending ( long zoomlevel ) { return queryforeq ( tiletable . column_zoom_level , zoomlevel , null , null , tiletable . column_tile_row + str_ + tiletable . column_tile_column + str_ ) ; }	Query for Tiles at a zoom level in descending row and column order.
public long getclosestzoomlevel ( double length ) { long zoomlevel = tiledaoutils . getclosestzoomlevel ( widths , heights , tilematrices , length ) ; return zoomlevel ; }	Get the closest zoom level for the provided width and height in thedefault units.
public long getapproximatezoomlevel ( double length ) { long zoomlevel = tiledaoutils . getapproximatezoomlevel ( widths , heights , tilematrices , length ) ; return zoomlevel ; }	Get the approximate zoom level for the provided length in the defaultunits.
public tilegrid queryfortilegrid ( long zoomlevel ) { string where = buildwhere ( tiletable . column_zoom_level , zoomlevel ) ; string [ ] whereargs = buildwhereargs ( new object [ ] { zoomlevel } ) ; integer minx = min ( tiletable . column_tile_column , where , whereargs ) ; integer maxx = max ( tiletable . column_tile_column , where , whereargs ) ; integer miny = min ( tiletable . column_tile_row , where , whereargs ) ; integer maxy = max ( tiletable . column_tile_row , where , whereargs ) ; tilegrid tilegrid = null ; if ( minx != null && maxx != null && miny != null && maxy != null ) { tilegrid = new tilegrid ( minx , miny , maxx , maxy ) ; } return tilegrid ; }	Query for the bounding.
public int deletetile ( long column , long row , long zoomlevel ) { stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( tiletable . column_zoom_level , zoomlevel ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( tiletable . column_tile_column , column ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( tiletable . column_tile_row , row ) ) ; string [ ] whereargs = buildwhereargs ( new object [ ] { zoomlevel , column , row } ) ; int deleted = delete ( where . tostring ( ) , whereargs ) ; return deleted ; }	Delete a Tile.
public int count ( long zoomlevel ) { string where = buildwhere ( tiletable . column_zoom_level , zoomlevel ) ; string [ ] whereargs = buildwhereargs ( zoomlevel ) ; return count ( where , whereargs ) ; }	Count of Tiles at a zoom level.
public boolean isgoogletiles ( ) {	Determine if the tiles are in the Google tile coordinate format.
public float getpixelvalue ( byte [ ] imagebytes , int x , int y ) { tiffimage tiffimage = tiffreader . readtiff ( imagebytes ) ; filedirectory directory = tiffimage . getfiledirectory ( ) ; validateimagetype ( directory ) ; rasters rasters = directory . readrasters ( ) ; float pixelvalue = rasters . getfirstpixelsample ( x , y ) . floatvalue ( ) ; return pixelvalue ; }	Get the pixel value as a float from the image and the coordinate.
public float [ ] getpixelvalues ( byte [ ] imagebytes ) { tiffimage tiffimage = tiffreader . readtiff ( imagebytes ) ; filedirectory directory = tiffimage . getfiledirectory ( ) ; validateimagetype ( directory ) ; rasters rasters = directory . readrasters ( ) ; float [ ] pixels = new float [ rasters . getwidth ( ) * rasters . getheight ( ) ] ; for ( int y = num_ ; y < rasters . getheight ( ) ; y ++ ) { for ( int x = num_ ; x < rasters . getwidth ( ) ; x ++ ) { int index = rasters . getsampleindex ( x , y ) ; pixels [ index ] = rasters . getpixelsample ( num_ , x , y ) . floatvalue ( ) ; } } return pixels ; }	Get the pixel values of the image as floats.
public static void validateimagetype ( filedirectory directory ) { if ( directory == null ) { throw new geopackageexception ( str_ ) ; } int samplesperpixel = directory . getsamplesperpixel ( ) ; integer bitspersample = null ; if ( directory . getbitspersample ( ) != null && ! directory . getbitspersample ( ) . isempty ( ) ) { bitspersample = directory . getbitspersample ( ) . get ( num_ ) ; } integer sampleformat = null ; if ( directory . getsampleformat ( ) != null && ! directory . getsampleformat ( ) . isempty ( ) ) { sampleformat = directory . getsampleformat ( ) . get ( num_ ) ; } if ( samplesperpixel != samples_per_pixel || bitspersample == null || bitspersample != bits_per_sample || sampleformat == null || sampleformat != tiffconstants . sample_format_float ) { throw new geopackageexception ( str_ + samplesperpixel + str_ + bitspersample + str_ + sampleformat ) ; } }	Validate that the image type.
public coveragedatatiffimage createimage ( int tilewidth , int tileheight ) { rasters rasters = new rasters ( tilewidth , tileheight , num_ , bits_per_sample , tiffconstants . sample_format_float ) ; int rowsperstrip = rasters . calculaterowsperstrip ( tiffconstants . planar_configuration_chunky ) ; filedirectory filedirectory = new filedirectory ( ) ; filedirectory . setimagewidth ( tilewidth ) ; filedirectory . setimageheight ( tileheight ) ; filedirectory . setbitspersample ( bits_per_sample ) ; filedirectory . setcompression ( tiffconstants . compression_no ) ; filedirectory . setphotometricinterpretation ( tiffconstants . photometric_interpretation_black_is_zero ) ; filedirectory . setsamplesperpixel ( samples_per_pixel ) ; filedirectory . setrowsperstrip ( rowsperstrip ) ; filedirectory . setplanarconfiguration ( tiffconstants . planar_configuration_chunky ) ; filedirectory . setsampleformat ( tiffconstants . sample_format_float ) ; filedirectory . setwriterasters ( rasters ) ; coveragedatatiffimage image = new coveragedatatiffimage ( filedirectory ) ; return image ; }	Create a new image.
public void setpixelvalue ( coveragedatatiffimage image , int x , int y , float pixelvalue ) { image . getrasters ( ) . setfirstpixelsample ( x , y , pixelvalue ) ; }	Set the pixel value into the image.
private geopackage getoropen ( string name , boolean writable , boolean cache ) { geopackage geopackage = get ( name ) ; if ( geopackage == null ) { geopackage = manager . open ( name , writable ) ; if ( cache ) { add ( geopackage ) ; } } return geopackage ; }	Get the cached GeoPackage or open and cache the GeoPackage.
private trow getcurrentrow ( ) { trow row = null ; if ( table != null ) { int [ ] columntypes = new int [ table . columncount ( ) ] ; object [ ] values = new object [ table . columncount ( ) ] ; boolean valid = bool_ ; for ( tcolumn column : table . getcolumns ( ) ) { int index = column . getindex ( ) ; int columntype = gettype ( index ) ; if ( column . isprimarykey ( ) && columntype == field_type_null ) { valid = bool_ ; } columntypes [ index ] = columntype ; values [ index ] = getvalue ( column ) ; } row = getrow ( columntypes , values ) ; if ( ! valid ) { invalidpositions . add ( getposition ( ) ) ; row . setvalid ( bool_ ) ; } } return row ; }	Get the current row.
private boolean movetonextinvalid ( ) { boolean hasnext = bool_ ;	Move to the next position of invalid rows to requery.
public list < stylemappingrow > querybybasefeatureid ( long id ) { list < stylemappingrow > rows = new arraylist < > ( ) ; usercustomcursor cursor = querybybaseid ( id ) ; try { while ( cursor . movetonext ( ) ) { rows . add ( getrow ( cursor ) ) ; } } finally { cursor . close ( ) ; } return rows ; }	Query for style mappings by base id.
public int deletebybaseid ( long id , geometrytype geometrytype ) { string geometrytypename = null ; if ( geometrytype != null ) { geometrytypename = geometrytype . getname ( ) ; } stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( stylemappingtable . column_base_id , id ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( stylemappingtable . column_geometry_type_name , geometrytypename ) ) ; list < object > wherearguments = new arraylist < > ( ) ; wherearguments . add ( id ) ; if ( geometrytypename != null ) { wherearguments . add ( geometrytypename ) ; } string [ ] whereargs = buildwhereargs ( wherearguments ) ; int deleted = delete ( where . tostring ( ) , whereargs ) ; return deleted ; }	Delete by base is and geometry type.
public static rect getrectangle ( long width , long height , boundingbox boundingbox , boundingbox boundingboxsection ) { rectf rectf = getfloatrectangle ( width , height , boundingbox , boundingboxsection ) ; rect rect = new rect ( math . round ( rectf . left ) , math . round ( rectf . top ) , math . round ( rectf . right ) , math . round ( rectf . bottom ) ) ; return rect ; }	Get a rectangle using the tile width, height, bounding box, and thebounding box section within the outer box to build the rectangle from.
public static rectf getroundedfloatrectangle ( long width , long height , boundingbox boundingbox , boundingbox boundingboxsection ) { rect rect = getrectangle ( width , height , boundingbox , boundingboxsection ) ; rectf rectf = new rectf ( rect ) ; return rectf ; }	Get a rectangle with rounded floating point boundaries using the tile width,height, bounding box, and the bounding box section within the outer boxto build the rectangle from.
private list < string > deletemissingdatabases ( list < string > databases ) { list < string > filesexist = new arraylist < > ( ) ; for ( string database : databases ) { if ( exists ( database ) ) { filesexist . add ( database ) ; } } return filesexist ; }	Delete all databases that do not exist or the database file does not exist.
private void createandclosegeopackage ( geopackagedatabase db ) { geopackageconnection connection = new geopackageconnection ( db ) ;	Create the required GeoPackage application id and tables in the newly created and open database connection.
private boolean isvalid ( string database , boolean validateheader , boolean validateintegrity ) { boolean valid = bool_ ; if ( exists ( database ) ) { geopackagecursorfactory cursorfactory = new geopackagecursorfactory ( ) ; string path = null ; sqlitedatabase sqlite ; geopackagemetadata metadata = getgeopackagemetadata ( database ) ; if ( metadata != null && metadata . isexternal ( ) ) { path = metadata . getexternalpath ( ) ; try { sqlite = sqlitedatabase . opendatabase ( path , cursorfactory , sqlitedatabase . open_readwrite | sqlitedatabase . no_localized_collators ) ; } catch ( exception e ) { sqlite = sqlitedatabase . opendatabase ( path , cursorfactory , sqlitedatabase . open_readonly | sqlitedatabase . no_localized_collators ) ; } } else { path = context . getdatabasepath ( database ) . getabsolutepath ( ) ; sqlite = context . openorcreatedatabase ( database , context . mode_private , cursorfactory ) ; } try { valid = ( ! validateheader || isdatabaseheadervalid ( sqlite ) ) && ( ! validateintegrity || sqlite . isdatabaseintegrityok ( ) ) ; } catch ( exception e ) { log . e ( geopackagemanagerimpl . class . getsimplename ( ) , str_ , e ) ; } finally { sqlite . close ( ) ; } } return valid ; }	Validate the GeoPackage database.
private void validatedatabaseandcloseonerror ( sqlitedatabase sqlitedatabase , boolean validateheader , boolean validateintegrity ) { validatedatabase ( sqlitedatabase , validateheader , validateintegrity , bool_ , bool_ ) ; }	Validate the database and close when validation fails.
private void validatedatabaseandclose ( sqlitedatabase sqlitedatabase , boolean validateheader , boolean validateintegrity ) { validatedatabase ( sqlitedatabase , validateheader , validateintegrity , bool_ , bool_ ) ; }	Validate the database and close it.
private void validatedatabase ( sqlitedatabase sqlitedatabase , boolean validateheader , boolean validateintegrity , boolean close , boolean closeonerror ) { try { if ( validateheader ) { validatedatabaseheader ( sqlitedatabase ) ; } if ( validateintegrity ) { validatedatabaseintegrity ( sqlitedatabase ) ; } } catch ( exception e ) { if ( closeonerror ) { sqlitedatabase . close ( ) ; } throw e ; } if ( close ) { sqlitedatabase . close ( ) ; } }	Validate the database header and integrity.
private void validatedatabaseheader ( sqlitedatabase sqlitedatabase ) { boolean validheader = isdatabaseheadervalid ( sqlitedatabase ) ; if ( ! validheader ) { throw new geopackageexception ( str_ + sqlitedatabase . getpath ( ) ) ; } }	Validate the header of the database file to verify it is a sqlite database.
private boolean isdatabaseheadervalid ( sqlitedatabase sqlitedatabase ) { boolean validheader = bool_ ; fileinputstream fis = null ; try { fis = new fileinputstream ( sqlitedatabase . getpath ( ) ) ; byte [ ] headerbytes = new byte [ num_ ] ; if ( fis . read ( headerbytes ) == num_ ) { bytereader bytereader = new bytereader ( headerbytes ) ; string header = bytereader . readstring ( headerbytes . length ) ; string headerprefix = header . substring ( num_ , geopackageconstants . sqlite_header_prefix . length ( ) ) ; validheader = headerprefix . equalsignorecase ( geopackageconstants . sqlite_header_prefix ) ; } } catch ( exception e ) { log . e ( geopackagemanagerimpl . class . getsimplename ( ) , str_ , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( ioexception e ) {	Determine if the header of the database file is valid.
private void addinternaldatabases ( collection < string > databases ) { string [ ] databasearray = context . databaselist ( ) ; for ( string database : databasearray ) { if ( ! istemporary ( database ) && ! database . equalsignorecase ( geopackagemetadatadb . database_name ) ) { databases . add ( database ) ; } } }	Add all internal databases to the collection.
private void addexternaldatabases ( collection < string > databases ) {	Add all external databases to the collection.
private boolean importgeopackage ( string database , boolean override , inputstream geopackagestream , geopackageprogress progress ) { try { if ( exists ( database ) ) { if ( override ) { if ( ! delete ( database ) ) { throw new geopackageexception ( str_ + database ) ; } } else { throw new geopackageexception ( str_ + database ) ; } }	Import the GeoPackage stream.
private geopackagemetadata getgeopackagemetadata ( string database ) { geopackagemetadata metadata = null ; geopackagemetadatadb metadatadb = new geopackagemetadatadb ( context ) ; metadatadb . open ( ) ; try { geopackagemetadatadatasource datasource = new geopackagemetadatadatasource ( metadatadb ) ; metadata = datasource . get ( database ) ; } finally { metadatadb . close ( ) ; } return metadata ; }	Get the GeoPackage metadata.
private geopackagemetadata getgeopackagemetadataatexternalpath ( string path ) { geopackagemetadata metadata = null ; geopackagemetadatadb metadatadb = new geopackagemetadatadb ( context ) ; metadatadb . open ( ) ; try { geopackagemetadatadatasource datasource = new geopackagemetadatadatasource ( metadatadb ) ; metadata = datasource . getexternalatpath ( path ) ; } finally { metadatadb . close ( ) ; } return metadata ; }	Get the GeoPackage metadata of the database at the external path.
public long create ( geometrymetadata metadata ) { contentvalues values = new contentvalues ( ) ; values . put ( geometrymetadata . column_geopackage_id , metadata . getgeopackageid ( ) ) ; values . put ( geometrymetadata . column_table_name , metadata . gettablename ( ) ) ; values . put ( geometrymetadata . column_id , metadata . getid ( ) ) ; values . put ( geometrymetadata . column_min_x , metadata . getminx ( ) ) ; values . put ( geometrymetadata . column_max_x , metadata . getmaxx ( ) ) ; values . put ( geometrymetadata . column_min_y , metadata . getminy ( ) ) ; values . put ( geometrymetadata . column_max_y , metadata . getmaxy ( ) ) ; values . put ( geometrymetadata . column_min_z , metadata . getminz ( ) ) ; values . put ( geometrymetadata . column_max_z , metadata . getmaxz ( ) ) ; values . put ( geometrymetadata . column_min_m , metadata . getminm ( ) ) ; values . put ( geometrymetadata . column_max_m , metadata . getmaxm ( ) ) ; long insertid = db . insert ( geometrymetadata . table_name , null , values ) ; if ( insertid == - num_ ) { throw new geopackageexception ( str_ + metadata . getgeopackageid ( ) + str_ + metadata . gettablename ( ) + str_ + metadata . getid ( ) ) ; } metadata . setid ( insertid ) ; return insertid ; }	Create a new geometry metadata.
public geometrymetadata populate ( long geopackageid , string tablename , long geomid , geometryenvelope envelope ) { geometrymetadata metadata = new geometrymetadata ( ) ; metadata . setgeopackageid ( geopackageid ) ; metadata . settablename ( tablename ) ; metadata . setid ( geomid ) ; metadata . setminx ( envelope . getminx ( ) ) ; metadata . setmaxx ( envelope . getmaxx ( ) ) ; metadata . setminy ( envelope . getminy ( ) ) ; metadata . setmaxy ( envelope . getmaxy ( ) ) ; if ( envelope . hasz ( ) ) { metadata . setminz ( envelope . getminz ( ) ) ; metadata . setmaxz ( envelope . getmaxz ( ) ) ; } if ( envelope . hasm ( ) ) { metadata . setminm ( envelope . getminm ( ) ) ; metadata . setmaxm ( envelope . getmaxm ( ) ) ; } return metadata ; }	Populate a new geometry metadata from an envelope.
public int delete ( long geopackageid ) { string whereclause = geometrymetadata . column_geopackage_id + str_ ; string [ ] whereargs = new string [ ] { string . valueof ( geopackageid ) } ; int deletecount = db . delete ( geometrymetadata . table_name , whereclause , whereargs ) ; return deletecount ; }	Delete geometry metadata by database.
public boolean createorupdate ( geometrymetadata metadata ) { boolean success = bool_ ; if ( exists ( metadata ) ) { success = update ( metadata ) ; } else { create ( metadata ) ; success = bool_ ; } return success ; }	Create the geometry metadata or update if it already exists.
public boolean update ( geometrymetadata metadata ) { string whereclause = geometrymetadata . column_geopackage_id + str_ + geometrymetadata . column_table_name + str_ + geometrymetadata . column_id + str_ ; string [ ] whereargs = new string [ ] { string . valueof ( metadata . getgeopackageid ( ) ) , metadata . gettablename ( ) , string . valueof ( metadata . getid ( ) ) } ; contentvalues values = new contentvalues ( ) ; values . put ( geometrymetadata . column_min_x , metadata . getminx ( ) ) ; values . put ( geometrymetadata . column_max_x , metadata . getmaxx ( ) ) ; values . put ( geometrymetadata . column_min_y , metadata . getminy ( ) ) ; values . put ( geometrymetadata . column_max_y , metadata . getmaxy ( ) ) ; values . put ( geometrymetadata . column_min_z , metadata . getminz ( ) ) ; values . put ( geometrymetadata . column_max_z , metadata . getmaxz ( ) ) ; values . put ( geometrymetadata . column_min_m , metadata . getminm ( ) ) ; values . put ( geometrymetadata . column_max_m , metadata . getmaxm ( ) ) ; int updatecount = db . update ( geometrymetadata . table_name , values , whereclause , whereargs ) ; return updatecount > num_ ; }	Update the geometry metadata.
public int count ( string geopackage , string tablename , boundingbox boundingbox ) { return count ( getgeopackageid ( geopackage ) , tablename , boundingbox ) ; }	Query for all table geometry metadata count matching the bounding box in the same projection.
public static geometrymetadata creategeometrymetadata ( cursor cursor ) { geometrymetadata metadata = new geometrymetadata ( ) ; metadata . setgeopackageid ( cursor . getlong ( num_ ) ) ; metadata . settablename ( cursor . getstring ( num_ ) ) ; metadata . setid ( cursor . getlong ( num_ ) ) ; metadata . setminx ( cursor . getdouble ( num_ ) ) ; metadata . setmaxx ( cursor . getdouble ( num_ ) ) ; metadata . setminy ( cursor . getdouble ( num_ ) ) ; metadata . setmaxy ( cursor . getdouble ( num_ ) ) ; if ( ! cursor . isnull ( num_ ) ) { metadata . setminz ( cursor . getdouble ( num_ ) ) ; } if ( ! cursor . isnull ( num_ ) ) { metadata . setmaxz ( cursor . getdouble ( num_ ) ) ; } if ( ! cursor . isnull ( num_ ) ) { metadata . setminm ( cursor . getdouble ( num_ ) ) ; } if ( ! cursor . isnull ( num_ ) ) { metadata . setmaxm ( cursor . getdouble ( num_ ) ) ; } return metadata ; }	Create a geometry metadata from the current cursor location.
public int update ( contentvalues values , string whereclause , string [ ] whereargs ) { return db . update ( gettablename ( ) , values , whereclause , whereargs ) ; }	Update all rows matching the where clause with the provided values.
private bitmap drawtile ( int tilewidth , int tileheight , string text ) {	Draw a tile with the provided text label in the middle.
public list < simpleattributesrow > getrows ( list < long > ids ) { list < simpleattributesrow > simpleattributesrows = new arraylist < > ( ) ; for ( long id : ids ) { usercustomrow usercustomrow = queryforidrow ( id ) ; if ( usercustomrow != null ) { simpleattributesrows . add ( getrow ( usercustomrow ) ) ; } } return simpleattributesrows ; }	Get the simple attributes rows that exist with the provided ids.
private cursor integritycheck ( cursor cursor ) { if ( cursor . movetonext ( ) ) { string value = cursor . getstring ( num_ ) ; if ( value . equals ( str_ ) ) { cursor . close ( ) ; cursor = null ; } } return cursor ; }	Check the cursor returned from the integrity check to see if things are "ok".
public usermappingdao getmappingdao ( string tablename ) { usermappingdao usermappingdao = new usermappingdao ( getuserdao ( tablename ) ) ; usermappingdao . registercursorwrapper ( getgeopackage ( ) ) ; return usermappingdao ; }	Get a User Mapping DAO from a table name.
public simpleattributesdao getsimpleattributesdao ( string tablename ) { simpleattributesdao simpleattributesdao = new simpleattributesdao ( getuserdao ( tablename ) ) ; simpleattributesdao . registercursorwrapper ( getgeopackage ( ) ) ; setcontents ( simpleattributesdao . gettable ( ) ) ; return simpleattributesdao ; }	Get a related simple attributes table DAO.
public list < long > getmappingsforbase ( extendedrelation extendedrelation , long baseid ) { return getmappingsforbase ( extendedrelation . getmappingtablename ( ) , baseid ) ; }	Get the related id mappings for the base id.
public list < long > getmappingsforrelated ( extendedrelation extendedrelation , long relatedid ) { return getmappingsforrelated ( extendedrelation . getmappingtablename ( ) , relatedid ) ; }	Get the base id mappings for the related id.
public boolean hasmapping ( string tablename , long baseid , long relatedid ) { boolean has = bool_ ; usermappingdao usermappingdao = getmappingdao ( tablename ) ; usercustomcursor cursor = usermappingdao . querybyids ( baseid , relatedid ) ; try { has = cursor . getcount ( ) > num_ ; } finally { cursor . close ( ) ; } return has ; }	Determine if the base id and related id mapping exists.
protected int count ( usercustomcursor cursor ) { int count = num_ ; try { count = cursor . getcount ( ) ; } finally { cursor . close ( ) ; } return count ; }	Get the count of the cursor and close it.
public void registercursorwrapper ( geopackage geopackage ) { geopackage . registercursorwrapper ( gettablename ( ) , new geopackagecursorwrapper ( ) { @ override public cursor wrapcursor ( cursor cursor ) { return new usercustomcursor ( gettable ( ) , cursor ) ; } } ) ; }	Register the cursor wrapper into the GeoPackage.
public static usercustomdao readtable ( geopackage geopackage , string tablename ) { usercustomconnection userdb = new usercustomconnection ( geopackage . getconnection ( ) ) ; final usercustomtable usercustomtable = usercustomtablereader . readtable ( geopackage . getconnection ( ) , tablename ) ; usercustomdao dao = new usercustomdao ( geopackage . getname ( ) , geopackage . getconnection ( ) , userdb , usercustomtable ) ; dao . registercursorwrapper ( geopackage ) ; return dao ; }	Read the database table and create a DAO.
public geopackagetile gettile ( boundingbox requestboundingbox ) { geopackagetile tile = null ;	Get the tile from the request bounding box in the request projection.
private bitmap drawtile ( tilematrix tilematrix , tilecursor tileresults , boundingbox requestprojectedboundingbox , int tilewidth , int tileheight ) {	Draw the tile from the tile results.
private bitmap reprojecttile ( bitmap tile , int requestedtilewidth , int requestedtileheight , boundingbox requestboundingbox , projectiontransform transformrequesttotiles , boundingbox tilesboundingbox ) { final double requestedwidthunitsperpixel = ( requestboundingbox . getmaxlongitude ( ) - requestboundingbox . getminlongitude ( ) ) / requestedtilewidth ; final double requestedheightunitsperpixel = ( requestboundingbox . getmaxlatitude ( ) - requestboundingbox . getminlatitude ( ) ) / requestedtileheight ; final double tilesdistancewidth = tilesboundingbox . getmaxlongitude ( ) - tilesboundingbox . getminlongitude ( ) ; final double tilesdistanceheight = tilesboundingbox . getmaxlatitude ( ) - tilesboundingbox . getminlatitude ( ) ; final int width = tile . getwidth ( ) ; final int height = tile . getheight ( ) ;	Reproject the tile to the requested projection.
private tilecursor retrievetileresults ( boundingbox projectedrequestboundingbox , tilematrix tilematrix ) { tilecursor tileresults = null ; if ( tilematrix != null ) {	Get the tile row results of tiles needed to draw the requested bounding box tile.
public void calculatedrawoverlap ( ) { if ( pointicon != null ) { heightoverlap = this . density * pointicon . getheight ( ) ; widthoverlap = this . density * pointicon . getwidth ( ) ; } else { heightoverlap = this . density * pointradius ; widthoverlap = this . density * pointradius ; } float linepainthalfstroke = this . density * linestrokewidth / num_ ; heightoverlap = math . max ( heightoverlap , linepainthalfstroke ) ; widthoverlap = math . max ( widthoverlap , linepainthalfstroke ) ; float polygonpainthalfstroke = this . density * polygonstrokewidth / num_ ; heightoverlap = math . max ( heightoverlap , polygonpainthalfstroke ) ; widthoverlap = math . max ( widthoverlap , polygonpainthalfstroke ) ; if ( featuretablestyles != null && featuretablestyles . has ( ) ) {	Call after making changes to the point icon, point radius, or paint stroke widths.Determines the pixel overlap between tiles.
public void setdensity ( float density ) { this . density = density ; linepaint . setstrokewidth ( this . density * linestrokewidth ) ; polygonpaint . setstrokewidth ( this . density * polygonstrokewidth ) ; featurepaintcache . clear ( ) ; }	Set the density.
public void setlinepaint ( paint linepaint ) { if ( linepaint == null ) { throw new assertionerror ( str_ ) ; } this . linepaint = linepaint ; setlinestrokewidth ( linepaint . getstrokewidth ( ) ) ; }	Set the line paint.
public void setpolygonpaint ( paint polygonpaint ) { if ( polygonpaint == null ) { throw new assertionerror ( str_ ) ; } this . polygonpaint = polygonpaint ; setpolygonstrokewidth ( polygonpaint . getstrokewidth ( ) ) ; }	Set the polygon paint.
public byte [ ] drawtilebytes ( int x , int y , int zoom ) { bitmap bitmap = drawtile ( x , y , zoom ) ; byte [ ] tiledata = null ;	Draw the tile and get the bytes from the x, y, and zoom level.
public bitmap drawtile ( int x , int y , int zoom ) { bitmap bitmap ; if ( isindexquery ( ) ) { bitmap = drawtilequeryindex ( x , y , zoom ) ; } else { bitmap = drawtilequeryall ( x , y , zoom ) ; } return bitmap ; }	Draw a tile bitmap from the x, y, and zoom level.
public bitmap drawtilequeryindex ( int x , int y , int zoom ) {	Draw a tile bitmap from the x, y, and zoom level by querying features in the tile location.
public long queryindexedfeaturescount ( int x , int y , int zoom ) {	Query for feature result count in the x, y, and zoom.
public long queryindexedfeaturescount ( boundingbox webmercatorboundingbox ) {	Query for feature result count in the bounding box.
public featureindexresults queryindexedfeatures ( int x , int y , int zoom ) {	Query for feature results in the x, y, and zoom level by querying features in the tile location.
public featureindexresults queryindexedfeatures ( boundingbox webmercatorboundingbox ) {	Query for feature results in the bounding box.
public bitmap drawtilequeryall ( int x , int y , int zoom ) { boundingbox boundingbox = tileboundingboxutils . getwebmercatorboundingbox ( x , y , zoom ) ; bitmap bitmap = null ;	Draw a tile bitmap from the x, y, and zoom level by querying all features. This couldbe very slow if there are a lot of features.
protected list < point > simplifypoints ( double simplifytolerance , list < point > points ) { list < point > simplifiedpoints = null ; if ( simplifygeometries ) {	When the simplify tolerance is set, simplify the points to a similarcurve with fewer points.
protected paint getpointpaint ( featurestyle featurestyle ) { paint paint = getfeaturestylepaint ( featurestyle , featuredrawtype . circle ) ; if ( paint == null ) { paint = pointpaint ; } return paint ; }	Get the point paint for the feature style, or return the default paint.
protected paint getlinepaint ( featurestyle featurestyle ) { paint paint = getfeaturestylepaint ( featurestyle , featuredrawtype . stroke ) ; if ( paint == null ) { paint = linepaint ; } return paint ; }	Get the line paint for the feature style, or return the default paint.
protected paint getpolygonpaint ( featurestyle featurestyle ) { paint paint = getfeaturestylepaint ( featurestyle , featuredrawtype . stroke ) ; if ( paint == null ) { paint = polygonpaint ; } return paint ; }	Get the polygon paint for the feature style, or return the default paint.
protected paint getpolygonfillpaint ( featurestyle featurestyle ) { paint paint = null ; boolean hasstylecolor = bool_ ; if ( featurestyle != null ) { stylerow style = featurestyle . getstyle ( ) ; if ( style != null ) { if ( style . hasfillcolor ( ) ) { paint = getstylepaint ( style , featuredrawtype . fill ) ; } else { hasstylecolor = style . hascolor ( ) ; } } } if ( paint == null && ! hasstylecolor && fillpolygon ) { paint = polygonfillpaint ; } return paint ; }	Get the polygon fill paint for the feature style, or return the default paint.
private paint getfeaturestylepaint ( featurestyle featurestyle , featuredrawtype drawtype ) { paint paint = null ; if ( featurestyle != null ) { stylerow style = featurestyle . getstyle ( ) ; if ( style != null && style . hascolor ( ) ) { paint = getstylepaint ( style , drawtype ) ; } } return paint ; }	Get the feature style paint from cache, or create and cache it.
private paint getstylepaint ( stylerow style , featuredrawtype drawtype ) { paint paint = featurepaintcache . getpaint ( style , drawtype ) ; if ( paint == null ) { color color = null ; style paintstyle = null ; float strokewidth = null ; switch ( drawtype ) { case circle : color = style . getcolorordefault ( ) ; paintstyle = style . fill ; break ; case stroke : color = style . getcolorordefault ( ) ; paintstyle = style . stroke ; strokewidth = this . density * ( float ) style . getwidthordefault ( ) ; break ; case fill : color = style . getfillcolor ( ) ; paintstyle = style . fill ; strokewidth = this . density * ( float ) style . getwidthordefault ( ) ; break ; default : throw new geopackageexception ( str_ + drawtype ) ; } paint stylepaint = new paint ( ) ; stylepaint . setantialias ( bool_ ) ; stylepaint . setstyle ( paintstyle ) ; stylepaint . setcolor ( color . getcolorwithalpha ( ) ) ; if ( strokewidth != null ) { stylepaint . setstrokewidth ( strokewidth ) ; } synchronized ( featurepaintcache ) { paint = featurepaintcache . getpaint ( style , drawtype ) ; if ( paint == null ) { featurepaintcache . setpaint ( style , drawtype , stylepaint ) ; paint = stylepaint ; } } } return paint ; }	Get the style paint from cache, or create and cache it.
public paint getpaint ( stylerow stylerow , featuredrawtype type ) { return getpaint ( stylerow . getid ( ) , type ) ; }	Get the paint for the style row and draw type.
public paint getpaint ( long styleid , featuredrawtype type ) { paint paint = null ; featurepaint featurepaint = getfeaturepaint ( styleid ) ; if ( featurepaint != null ) { paint = featurepaint . getpaint ( type ) ; } return paint ; }	Get the paint for the style row id and draw type.
public bitmap put ( iconrow iconrow , bitmap bitmap ) { return put ( iconrow . getid ( ) , bitmap ) ; }	Cache the icon bitmap for the icon row.
public static contentvalues quotewrap ( contentvalues values ) { contentvalues quotevalues = null ; if ( values != null ) { map < string , object > quotemap = new hashmap < > ( ) ; for ( map . entry < string , object > value : values . valueset ( ) ) { quotemap . put ( coresqlutils . quotewrap ( value . getkey ( ) ) , value . getvalue ( ) ) ; } parcel parcel = parcel . obtain ( ) ; parcel . writemap ( quotemap ) ; parcel . setdataposition ( num_ ) ; quotevalues = contentvalues . creator . createfromparcel ( parcel ) ; parcel . recycle ( ) ; } return quotevalues ; }	Wrap the content values names in quotes.
public bitmap createbitmap ( ) { bitmap bitmap = null ; canvas canvas = null ; for ( int layer = num_ ; layer < num_ ; layer ++ ) { bitmap layerbitmap = layeredbitmap [ layer ] ; if ( layerbitmap != null ) { if ( bitmap == null ) { bitmap = layerbitmap ; canvas = layeredcanvas [ layer ] ; } else { canvas . drawbitmap ( layerbitmap , new matrix ( ) , null ) ; layerbitmap . recycle ( ) ; } layeredbitmap [ layer ] = null ; layeredcanvas [ layer ] = null ; } } return bitmap ; }	Create the final bitmap from the layers, resets the layers.
public void recycle ( ) { for ( int layer = num_ ; layer < num_ ; layer ++ ) { bitmap bitmap = layeredbitmap [ layer ] ; if ( bitmap != null ) { bitmap . recycle ( ) ; layeredbitmap [ layer ] = null ; layeredcanvas [ layer ] = null ; } } }	Recycle the layered bitmaps.
private bitmap getbitmap ( int layer ) { bitmap bitmap = layeredbitmap [ layer ] ; if ( bitmap == null ) { createbitmapandcanvas ( layer ) ; bitmap = layeredbitmap [ layer ] ; } return bitmap ; }	Get the bitmap for the layer index.
private canvas getcanvas ( int layer ) { canvas canvas = layeredcanvas [ layer ] ; if ( canvas == null ) { createbitmapandcanvas ( layer ) ; canvas = layeredcanvas [ layer ] ; } return canvas ; }	Get the canvas for the layer index.
private void createbitmapandcanvas ( int layer ) { layeredbitmap [ layer ] = bitmap . createbitmap ( tilewidth , tileheight , bitmap . config . argb_8888 ) ; layeredcanvas [ layer ] = new canvas ( layeredbitmap [ layer ] ) ; }	Create a new empty Bitmap and Canvas.
private stylemappingdao getmappingdao ( string tableprefix , string featuretable ) { string tablename = tableprefix + featuretable ; stylemappingdao dao = null ; if ( geopackage . istable ( tablename ) ) { dao = new stylemappingdao ( relatedtables . getuserdao ( tablename ) ) ; } return dao ; }	Get a Style Mapping DAO from a table name.
public styledao getstyledao ( ) { styledao styledao = null ; if ( geopackage . istable ( styletable . table_name ) ) { attributesdao attributesdao = getgeopackage ( ) . getattributesdao ( styletable . table_name ) ; styledao = new styledao ( attributesdao ) ; relatedtables . setcontents ( styledao . gettable ( ) ) ; } return styledao ; }	Get a style DAO.
public icondao geticondao ( ) { icondao icondao = null ; if ( geopackage . istable ( icontable . table_name ) ) { icondao = new icondao ( relatedtables . getuserdao ( icontable . table_name ) ) ; relatedtables . setcontents ( icondao . gettable ( ) ) ; } return icondao ; }	Get a icon DAO.
public featurestyles gettablefeaturestyles ( string featuretable ) { featurestyles featurestyles = null ; long id = contentsid . getid ( featuretable ) ; if ( id != null ) { styles styles = gettablestyles ( featuretable , id ) ; icons icons = gettableicons ( featuretable , id ) ; if ( styles != null || icons != null ) { featurestyles = new featurestyles ( styles , icons ) ; } } return featurestyles ; }	Get the feature table default feature styles.
public styles gettablestyles ( string featuretable ) { styles styles = null ; long id = contentsid . getid ( featuretable ) ; if ( id != null ) { styles = gettablestyles ( featuretable , id ) ; } return styles ; }	Get the feature table default styles.
public stylerow gettablestyle ( string featuretable , geometrytype geometrytype ) { stylerow stylerow = null ; styles tablestyles = gettablestyles ( featuretable ) ; if ( tablestyles != null ) { stylerow = tablestyles . getstyle ( geometrytype ) ; } return stylerow ; }	Get the style of the feature table and geometry type.
public icons gettableicons ( string featuretable ) { icons icons = null ; long id = contentsid . getid ( featuretable ) ; if ( id != null ) { icons = gettableicons ( featuretable , id ) ; } return icons ; }	Get the feature table default icons.
public iconrow gettableicon ( string featuretable , geometrytype geometrytype ) { iconrow iconrow = null ; icons tableicons = gettableicons ( featuretable ) ; if ( tableicons != null ) { iconrow = tableicons . geticon ( geometrytype ) ; } return iconrow ; }	Get the icon of the feature table and geometry type.
public featurestyles getfeaturestyles ( featurerow featurerow ) { return getfeaturestyles ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) ) ; }	Get the feature styles for the feature row.
public featurestyles getfeaturestyles ( string featuretable , long featureid ) { styles styles = getstyles ( featuretable , featureid ) ; icons icons = geticons ( featuretable , featureid ) ; featurestyles featurestyles = null ; if ( styles != null || icons != null ) { featurestyles = new featurestyles ( styles , icons ) ; } return featurestyles ; }	Get the feature styles for the feature table and feature id.
public styles getstyles ( featurerow featurerow ) { return getstyles ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) ) ; }	Get the styles for the feature row.
public icons geticons ( featurerow featurerow ) { return geticons ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) ) ; }	Get the icons for the feature row.
private styles getstyles ( long featureid , stylemappingdao mappingdao ) { styles styles = null ; if ( mappingdao != null ) { styledao styledao = getstyledao ( ) ; if ( styledao != null ) { list < stylemappingrow > stylemappingrows = mappingdao . querybybasefeatureid ( featureid ) ; if ( ! stylemappingrows . isempty ( ) ) { for ( stylemappingrow stylemappingrow : stylemappingrows ) { stylerow stylerow = styledao . queryforrow ( stylemappingrow ) ; if ( stylerow != null ) { if ( styles == null ) { styles = new styles ( ) ; } styles . setstyle ( stylerow , stylemappingrow . getgeometrytype ( ) ) ; } } } } } return styles ; }	Get the styles for feature id from the style mapping dao.
private icons geticons ( long featureid , stylemappingdao mappingdao ) { icons icons = null ; if ( mappingdao != null ) { icondao icondao = geticondao ( ) ; if ( icondao != null ) { list < stylemappingrow > stylemappingrows = mappingdao . querybybasefeatureid ( featureid ) ; if ( ! stylemappingrows . isempty ( ) ) { for ( stylemappingrow stylemappingrow : stylemappingrows ) { iconrow iconrow = icondao . queryforrow ( stylemappingrow ) ; if ( iconrow != null ) { if ( icons == null ) { icons = new icons ( ) ; } icons . seticon ( iconrow , stylemappingrow . getgeometrytype ( ) ) ; } } } } } return icons ; }	Get the icons for feature id from the icon mapping dao.
public void settablefeaturestyles ( string featuretable , featurestyles featurestyles ) { if ( featurestyles != null ) { settablestyles ( featuretable , featurestyles . getstyles ( ) ) ; settableicons ( featuretable , featurestyles . geticons ( ) ) ; } else { deletetablefeaturestyles ( featuretable ) ; } }	Set the feature table default feature styles.
public void settablestyles ( string featuretable , styles styles ) { deletetablestyles ( featuretable ) ; if ( styles != null ) { if ( styles . getdefault ( ) != null ) { settablestyledefault ( featuretable , styles . getdefault ( ) ) ; } for ( entry < geometrytype , stylerow > style : styles . getstyles ( ) . entryset ( ) ) { settablestyle ( featuretable , style . getkey ( ) , style . getvalue ( ) ) ; } } }	Set the feature table default styles.
public void settableicons ( string featuretable , icons icons ) { deletetableicons ( featuretable ) ; if ( icons != null ) { if ( icons . getdefault ( ) != null ) { settableicondefault ( featuretable , icons . getdefault ( ) ) ; } for ( entry < geometrytype , iconrow > icon : icons . geticons ( ) . entryset ( ) ) { settableicon ( featuretable , icon . getkey ( ) , icon . getvalue ( ) ) ; } } }	Set the feature table default icons.
public void setfeaturestyles ( featurerow featurerow , featurestyles featurestyles ) { setfeaturestyles ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) , featurestyles ) ; }	Set the feature styles for the feature row.
public void setfeaturestyles ( string featuretable , long featureid , featurestyles featurestyles ) { if ( featurestyles != null ) { setstyles ( featuretable , featureid , featurestyles . getstyles ( ) ) ; seticons ( featuretable , featureid , featurestyles . geticons ( ) ) ; } else { deletestyles ( featuretable , featureid ) ; deleteicons ( featuretable , featureid ) ; } }	Set the feature styles for the feature table and feature id.
public void setstyles ( featurerow featurerow , styles styles ) { setstyles ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) , styles ) ; }	Set the styles for the feature row.
public void setstyles ( string featuretable , long featureid , styles styles ) { deletestyles ( featuretable , featureid ) ; if ( styles != null ) { if ( styles . getdefault ( ) != null ) { setstyledefault ( featuretable , featureid , styles . getdefault ( ) ) ; } for ( entry < geometrytype , stylerow > style : styles . getstyles ( ) . entryset ( ) ) { setstyle ( featuretable , featureid , style . getkey ( ) , style . getvalue ( ) ) ; } } }	Set the styles for the feature table and feature id.
public void setstyle ( featurerow featurerow , stylerow style ) { setstyle ( featurerow , featurerow . getgeometrytype ( ) , style ) ; }	Set the style of the feature row.
public void setstyledefault ( featurerow featurerow , stylerow style ) { setstyle ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) , null , style ) ; }	Set the default style of the feature row.
public void setstyledefault ( string featuretable , long featureid , stylerow style ) { setstyle ( featuretable , featureid , null , style ) ; }	Set the default style of the feature.
public void seticons ( featurerow featurerow , icons icons ) { seticons ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) , icons ) ; }	Set the icons for the feature row.
public void seticons ( string featuretable , long featureid , icons icons ) { deleteicons ( featuretable , featureid ) ; if ( icons != null ) { if ( icons . getdefault ( ) != null ) { seticondefault ( featuretable , featureid , icons . getdefault ( ) ) ; } for ( entry < geometrytype , iconrow > icon : icons . geticons ( ) . entryset ( ) ) { seticon ( featuretable , featureid , icon . getkey ( ) , icon . getvalue ( ) ) ; } } }	Set the icons for the feature table and feature id.
public void seticon ( featurerow featurerow , iconrow icon ) { seticon ( featurerow , featurerow . getgeometrytype ( ) , icon ) ; }	Set the icon of the feature row.
public void seticondefault ( featurerow featurerow , iconrow icon ) { seticon ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) , null , icon ) ; }	Set the default icon of the feature row.
public void seticondefault ( string featuretable , long featureid , iconrow icon ) { seticon ( featuretable , featureid , null , icon ) ; }	Set the default icon of the feature.
private long getorinsertstyle ( stylerow style ) { long styleid ; if ( style . hasid ( ) ) { styleid = style . getid ( ) ; } else { styledao styledao = getstyledao ( ) ; styleid = styledao . create ( style ) ; } return styleid ; }	Get the style id, either from the existing style or by inserting a newone.
private long getorinserticon ( iconrow icon ) { long iconid ; if ( icon . hasid ( ) ) { iconid = icon . getid ( ) ; } else { icondao icondao = geticondao ( ) ; iconid = icondao . create ( icon ) ; } return iconid ; }	Get the icon id, either from the existing icon or by inserting a new one.
private void insertstylemapping ( stylemappingdao mappingdao , long baseid , long relatedid , geometrytype geometrytype ) { stylemappingrow row = mappingdao . newrow ( ) ; row . setbaseid ( baseid ) ; row . setrelatedid ( relatedid ) ; row . setgeometrytype ( geometrytype ) ; mappingdao . insert ( row ) ; }	Insert a style mapping row.
public void deletetablestyle ( string featuretable , geometrytype geometrytype ) { deletetablemapping ( gettablestylemappingdao ( featuretable ) , featuretable , geometrytype ) ; }	Delete the feature table style for the geometry type.
public void deletetableicon ( string featuretable , geometrytype geometrytype ) { deletetablemapping ( gettableiconmappingdao ( featuretable ) , featuretable , geometrytype ) ; }	Delete the feature table icon for the geometry type.
private void deletetablemappings ( stylemappingdao mappingdao , string featuretable ) { if ( mappingdao != null ) { long featurecontentsid = contentsid . getid ( featuretable ) ; if ( featurecontentsid != null ) { mappingdao . deletebybaseid ( featurecontentsid ) ; } } }	Delete the table style mappings.
private void deletetablemapping ( stylemappingdao mappingdao , string featuretable , geometrytype geometrytype ) { if ( mappingdao != null ) { long featurecontentsid = contentsid . getid ( featuretable ) ; if ( featurecontentsid != null ) { mappingdao . deletebybaseid ( featurecontentsid , geometrytype ) ; } } }	Delete the table style mapping with the geometry type value.
private void deletemapping ( stylemappingdao mappingdao , long featureid , geometrytype geometrytype ) { if ( mappingdao != null ) { mappingdao . deletebybaseid ( featureid , geometrytype ) ; } }	Delete the style mapping with the geometry type value.
public list < long > getalltablestyleids ( string featuretable ) { list < long > styleids = null ; stylemappingdao mappingdao = gettablestylemappingdao ( featuretable ) ; if ( mappingdao != null ) { styleids = mappingdao . uniquerelatedids ( ) ; } return styleids ; }	Get all the unique style row ids the table maps to.
public list < long > getalltableiconids ( string featuretable ) { list < long > iconids = null ; stylemappingdao mappingdao = gettableiconmappingdao ( featuretable ) ; if ( mappingdao != null ) { iconids = mappingdao . uniquerelatedids ( ) ; } return iconids ; }	Get all the unique icon row ids the table maps to.
public list < long > getallstyleids ( string featuretable ) { list < long > styleids = null ; stylemappingdao mappingdao = getstylemappingdao ( featuretable ) ; if ( mappingdao != null ) { styleids = mappingdao . uniquerelatedids ( ) ; } return styleids ; }	Get all the unique style row ids the features map to.
public list < long > getalliconids ( string featuretable ) { list < long > iconids = null ; stylemappingdao mappingdao = geticonmappingdao ( featuretable ) ; if ( mappingdao != null ) { iconids = mappingdao . uniquerelatedids ( ) ; } return iconids ; }	Get all the unique icon row ids the features map to.
public byte [ ] getimagebytes ( ) { byte [ ] bytes = null ; if ( imagebytes != null ) { bytes = imagebytes ; } else if ( outputstream != null ) { bytes = outputstream . tobytearray ( ) ; } return bytes ; }	Get the image bytes.
public void flushstream ( ) { if ( outputstream != null ) { if ( imagebytes == null ) { imagebytes = outputstream . tobytearray ( ) ; } try { outputstream . close ( ) ; } catch ( ioexception e ) { log . w ( coveragedatapngimage . class . getsimplename ( ) , str_ , e ) ; } } }	Flush the output stream and set the image bytes, close the stream.
public int getpixel ( int x , int y ) { int pixel = - num_ ; if ( pixels == null ) { readpixels ( ) ; } if ( pixels != null ) { pixel = pixels [ y ] [ x ] ; } else { throw new geopackageexception ( str_ ) ; } return pixel ; }	Get the pixel at the coordinate.
private void readpixels ( ) { if ( reader != null ) { pixels = new int [ reader . imginfo . rows ] [ reader . imginfo . cols ] ; int rowcount = num_ ; while ( reader . hasmorerows ( ) ) { imagelineint row = reader . readrowint ( ) ; int [ ] columnvalues = new int [ reader . imginfo . cols ] ; system . arraycopy ( row . getscanline ( ) , num_ , columnvalues , num_ , columnvalues . length ) ; pixels [ rowcount ++ ] = columnvalues ; } reader . close ( ) ; } }	Read all the pixels from the image.
private boolean drawfeature ( int zoom , boundingbox boundingbox , boundingbox expandedboundingbox , projectiontransform transform , featuretilecanvas canvas , featurerow row ) { boolean drawn = bool_ ; try { geopackagegeometrydata geomdata = row . getgeometry ( ) ; if ( geomdata != null ) { geometry geometry = geomdata . getgeometry ( ) ; if ( geometry != null ) { geometryenvelope envelope = geomdata . getorbuildenvelope ( ) ; boundingbox geometryboundingbox = new boundingbox ( envelope ) ; boundingbox transformedboundingbox = geometryboundingbox . transform ( transform ) ; if ( expandedboundingbox . intersects ( transformedboundingbox , bool_ ) ) { double simplifytolerance = tileboundingboxutils . tolerancedistance ( zoom , tilewidth , tileheight ) ; drawn = drawshape ( simplifytolerance , boundingbox , transform , canvas , row , geometry ) ; } } } } catch ( exception e ) { log . e ( defaultfeaturetiles . class . getsimplename ( ) , str_ + featuredao . gettablename ( ) , e ) ; } return drawn ; }	Draw the feature on the canvas.
private boolean drawlinepath ( featuretilecanvas canvas , path path , featurestyle featurestyle ) { canvas linecanvas = canvas . getlinecanvas ( ) ; paint pathpaint = getlinepaint ( featurestyle ) ; linecanvas . drawpath ( path , pathpaint ) ; return bool_ ; }	Draw the line path on the canvas.
private boolean drawpolygonpath ( featuretilecanvas canvas , path path , featurestyle featurestyle ) { canvas polygoncanvas = canvas . getpolygoncanvas ( ) ; paint fillpaint = getpolygonfillpaint ( featurestyle ) ; if ( fillpaint != null ) { path . setfilltype ( path . filltype . even_odd ) ; polygoncanvas . drawpath ( path , fillpaint ) ; } paint pathpaint = getpolygonpaint ( featurestyle ) ; polygoncanvas . drawpath ( path , pathpaint ) ; return bool_ ; }	Draw the path on the canvas.
private void addlinestring ( double simplifytolerance , boundingbox boundingbox , projectiontransform transform , path path , linestring linestring ) { list < point > points = linestring . getpoints ( ) ; if ( points . size ( ) >= num_ ) {	Add the linestring to the path.
private void addpolygon ( double simplifytolerance , boundingbox boundingbox , projectiontransform transform , path path , polygon polygon ) { list < linestring > rings = polygon . getrings ( ) ; if ( ! rings . isempty ( ) ) {	Add the polygon on the canvas.
public featurecache getcache ( string tablename ) { featurecache cache = tablecache . get ( tablename ) ; if ( cache == null ) { cache = new featurecache ( maxcachesize ) ; tablecache . put ( tablename , cache ) ; } return cache ; }	Get or create a feature row cache for the table name.
public featurerow remove ( featurerow featurerow ) { return remove ( featurerow . gettable ( ) . gettablename ( ) , featurerow . getid ( ) ) ; }	Remove the cached feature row.
public void clearandresize ( int maxcachesize ) { setmaxcachesize ( maxcachesize ) ; for ( featurecache cache : tablecache . values ( ) ) { cache . clearandresize ( maxcachesize ) ; } }	Clear and resize all caches and update the max cache size.
public styles getcachedtablestyles ( ) { styles styles = cachedtablefeaturestyles . getstyles ( ) ; if ( styles == null ) { synchronized ( cachedtablefeaturestyles ) { styles = cachedtablefeaturestyles . getstyles ( ) ; if ( styles == null ) { styles = gettablestyles ( ) ; if ( styles == null ) { styles = new styles ( ) ; } cachedtablefeaturestyles . setstyles ( styles ) ; } } } if ( styles . isempty ( ) ) { styles = null ; } return styles ; }	Get the cached table styles, querying and caching if needed.
public icons getcachedtableicons ( ) { icons icons = cachedtablefeaturestyles . geticons ( ) ; if ( icons == null ) { synchronized ( cachedtablefeaturestyles ) { icons = cachedtablefeaturestyles . geticons ( ) ; if ( icons == null ) { icons = gettableicons ( ) ; if ( icons == null ) { icons = new icons ( ) ; } cachedtablefeaturestyles . seticons ( icons ) ; } } } if ( icons . isempty ( ) ) { icons = null ; } return icons ; }	Get the cached table icons, querying and caching if needed.
public rtreeindextabledao gettabledao ( featuredao featuredao ) { geopackageconnection connection = getgeopackage ( ) . getconnection ( ) ; usercustomconnection userdb = new usercustomconnection ( connection ) ; usercustomtable usercustomtable = getrtreetable ( featuredao . gettable ( ) ) ; usercustomdao usercustomdao = new usercustomdao ( geopackage . getname ( ) , connection , userdb , usercustomtable ) ; return new rtreeindextabledao ( this , usercustomdao , featuredao ) ; }	Get a RTree Index Table DAO for the feature dao.
public void setwidth ( double width ) { if ( width != null && width < num_ ) { throw new geopackageexception ( str_ + width ) ; } setvalue ( getwidthcolumnindex ( ) , width ) ; }	Set the width.
public void setheight ( double height ) { if ( height != null && height < num_ ) { throw new geopackageexception ( str_ + height ) ; } setvalue ( getheightcolumnindex ( ) , height ) ; }	Set the height.
public double [ ] getderiveddimensions ( ) { double width = getwidth ( ) ; double height = getheight ( ) ; if ( width == null || height == null ) { bitmapfactory . options options = getdatabounds ( ) ; int datawidth = options . outwidth ; int dataheight = options . outheight ; if ( width == null ) { width = ( double ) datawidth ; if ( height != null ) { width *= ( height / dataheight ) ; } } if ( height == null ) { height = ( double ) dataheight ; if ( width != null ) { height *= ( width / datawidth ) ; } } } return new double [ ] { width , height } ; }	Get the derived width and height from the values and icon data, scaled asneeded.
public static float tiledensity ( float density , int tilewidth , int tileheight ) { return tiledensity ( density , math . min ( tilewidth , tileheight ) ) ; }	Get the tile density based upon the display density scale and tile dimensions.
private void readblobvalue ( userrow row , usercolumn column ) { bytearrayoutputstream bytestream = new bytearrayoutputstream ( ) ; try { byte [ ] blobchunk = new byte [ ] { num_ } ; for ( int i = num_ ; blobchunk . length > num_ ; i += chunk_size ) { if ( i > num_ ) { bytestream . write ( blobchunk ) ; } blobchunk = new byte [ ] { } ; string query = str_ + coresqlutils . quotewrap ( column . getname ( ) ) + str_ + i + str_ + chunk_size + str_ + coresqlutils . quotewrap ( dao . gettablename ( ) ) + str_ + coresqlutils . quotewrap ( row . getpkcolumn ( ) . getname ( ) ) + str_ + row . getid ( ) ; cursor blobcursor = dao . getdatabaseconnection ( ) . getdb ( ) . rawquery ( query , null ) ; try { if ( blobcursor . movetonext ( ) ) { blobchunk = blobcursor . getblob ( num_ ) ; } } finally { blobcursor . close ( ) ; } } byte [ ] blob = bytestream . tobytearray ( ) ; row . setvalue ( column . getindex ( ) , blob ) ; } catch ( ioexception e ) { log . e ( userinvalidcursor . class . getsimplename ( ) , str_ + dao . gettablename ( ) + str_ + column . getname ( ) + str_ + getposition ( ) , e ) ; } finally { ioutils . closequietly ( bytestream ) ; } }	Read the blob column value in chunks.
public static usercustomtable readtable ( geopackageconnection connection , string tablename ) { usercustomtablereader tablereader = new usercustomtablereader ( tablename ) ; usercustomtable customtable = tablereader . readtable ( new usercustomwrapperconnection ( connection ) ) ; return customtable ; }	Read the table.
public color getcolorordefault ( ) { color color = getcolor ( ) ; if ( color == null ) { color = new color ( ) ; } return color ; }	Get the color or default value.
private string validatecolor ( string color ) { string validated = color ; if ( color != null ) { if ( ! color . startswith ( str_ ) ) { validated = str_ + color ; } if ( ! colorpattern . matcher ( validated ) . matches ( ) ) { throw new geopackageexception ( str_ + color ) ; } validated = validated . touppercase ( ) ; } return validated ; }	Validate and adjust the color value.
private color createcolor ( string hexcolor , double opacity ) { color color = null ; if ( hexcolor != null || opacity != null ) { color = new color ( ) ; if ( hexcolor != null ) { color . setcolor ( hexcolor ) ; } if ( opacity != null ) { color . setopacity ( opacity . floatvalue ( ) ) ; } } return color ; }	Create a color from the hex color and opacity.
public static geopackagemanager getmanager ( context context ) { thread . currentthread ( ) . setcontextclassloader ( geopackagemanager . class . getclassloader ( ) ) ; return new geopackagemanagerimpl ( context ) ; }	Get a GeoPackage Manager.
public void setprogress ( geopackageprogress progress ) { featuretableindex . setprogress ( progress ) ; featureindexer . setprogress ( progress ) ; rtreeindextabledao . setprogress ( progress ) ; }	Set the GeoPackage Progress.
public int index ( boolean force , list < featureindextype > types ) { int count = num_ ; for ( featureindextype type : types ) { int typecount = index ( type , force ) ; count = math . max ( count , typecount ) ; } return count ; }	Index the feature tables for the index types.
public boolean index ( featurerow row , list < featureindextype > types ) { boolean indexed = bool_ ; for ( featureindextype type : types ) { if ( index ( type , row ) ) { indexed = bool_ ; } } return indexed ; }	Index the feature row for the index types.This method assumes that indexing has been completed andmaintained as the last indexed time is updated.
public boolean deleteindex ( collection < featureindextype > types ) { boolean deleted = bool_ ; for ( featureindextype type : types ) { if ( deleteindex ( type ) ) { deleted = bool_ ; } } return deleted ; }	Delete the feature index from the index types.
public boolean deleteindex ( featurerow row , list < featureindextype > types ) { boolean deleted = bool_ ; for ( featureindextype type : types ) { if ( deleteindex ( type , row ) ) { deleted = bool_ ; } } return deleted ; }	Delete the feature index for the feature row from the index types.
public boolean deleteindex ( long geomid , list < featureindextype > types ) { boolean deleted = bool_ ; for ( featureindextype type : types ) { if ( deleteindex ( type , geomid ) ) { deleted = bool_ ; } } return deleted ; }	Delete the feature index for the geometry id from the index types.
public boolean deleteindex ( featureindextype type , long geomid ) { if ( type == null ) { throw new geopackageexception ( str_ ) ; } boolean deleted = bool_ ; switch ( type ) { case geopackage : deleted = featuretableindex . deleteindex ( geomid ) > num_ ; break ; case metadata : deleted = featureindexer . deleteindex ( geomid ) ; break ; case rtree :	Delete the feature index for the geometry id.
public boolean isindexed ( ) { boolean indexed = bool_ ; for ( featureindextype type : indexlocationqueryorder ) { indexed = isindexed ( type ) ; if ( indexed ) { break ; } } return indexed ; }	Determine if the feature table is indexed.
public list < featureindextype > getindexedtypes ( ) { list < featureindextype > indexed = new arraylist < > ( ) ; for ( featureindextype type : indexlocationqueryorder ) { if ( isindexed ( type ) ) { indexed . add ( type ) ; } } return indexed ; }	Get the indexed types that are currently indexed.
public featureindexresults query ( ) { featureindexresults results = null ; switch ( getindexedtype ( ) ) { case geopackage : long count = featuretableindex . count ( ) ; closeableiterator < geometryindex > geometryindices = featuretableindex . query ( ) ; results = new featureindexgeopackageresults ( featuretableindex , count , geometryindices ) ; break ; case metadata : cursor geometrymetadata = featureindexer . query ( ) ; results = new featureindexmetadataresults ( featureindexer , geometrymetadata ) ; break ; case rtree : usercustomcursor cursor = rtreeindextabledao . queryforall ( ) ; results = new featureindexrtreeresults ( rtreeindextabledao , cursor ) ; break ; default : featurecursor featurecursor = featuredao . queryforall ( ) ; results = new featureindexfeatureresults ( featurecursor ) ; } return results ; }	Query for all feature index results.
public long count ( ) { long count = num_ ; switch ( getindexedtype ( ) ) { case geopackage : count = featuretableindex . count ( ) ; break ; case metadata : count = featureindexer . count ( ) ; break ; case rtree : count = rtreeindextabledao . count ( ) ; break ; default : count = manualfeaturequery . countwithgeometries ( ) ; } return count ; }	Query for all feature index count.
public boundingbox getboundingbox ( ) { boundingbox bounds = null ; switch ( getindexedtype ( ) ) { case geopackage : bounds = featuretableindex . getboundingbox ( ) ; break ; case metadata : bounds = featureindexer . getboundingbox ( ) ; break ; case rtree : bounds = rtreeindextabledao . getboundingbox ( ) ; break ; default : bounds = manualfeaturequery . getboundingbox ( ) ; } return bounds ; }	Query for the feature index bounds.
public featureindexresults query ( boundingbox boundingbox , projection projection ) { featureindexresults results = null ; switch ( getindexedtype ( ) ) { case geopackage : long count = featuretableindex . count ( boundingbox , projection ) ; closeableiterator < geometryindex > geometryindices = featuretableindex . query ( boundingbox , projection ) ; results = new featureindexgeopackageresults ( featuretableindex , count , geometryindices ) ; break ; case metadata : cursor geometrymetadata = featureindexer . query ( boundingbox , projection ) ; results = new featureindexmetadataresults ( featureindexer , geometrymetadata ) ; break ; case rtree : usercustomcursor cursor = rtreeindextabledao . query ( boundingbox , projection ) ; results = new featureindexrtreeresults ( rtreeindextabledao , cursor ) ; break ; default : results = manualfeaturequery . query ( boundingbox , projection ) ; } return results ; }	Query for feature index results within the bounding box inthe provided projection.
private featureindextype getindexedtype ( ) { featureindextype indextype = featureindextype . none ;	Get the indexed type or throw an error if not indexed.
public static file getinternalfile ( context context , string filepath ) { file internalfile = null ; if ( filepath != null ) { internalfile = new file ( context . getfilesdir ( ) , filepath ) ; } else { internalfile = context . getfilesdir ( ) ; } return internalfile ; }	Get the internal storage file for the file path.
public static string getinternalfilepath ( context context , string filepath ) { return getinternalfile ( context , filepath ) . getabsolutepath ( ) ; }	Get the internal storage patch for the file path.
public geometrytype getgeometrytype ( ) { geometrytype geometrytype = null ; string geometrytypename = getgeometrytypename ( ) ; if ( geometrytypename != null ) { geometrytype = geometrytype . fromname ( geometrytypename ) ; } return geometrytype ; }	Get the geometry type.
public void setgeometrytype ( geometrytype geometrytype ) { string geometrytypename = null ; if ( geometrytype != null ) { geometrytypename = geometrytype . getname ( ) ; } setvalue ( getgeometrytypenamecolumnindex ( ) , geometrytypename ) ; }	Set the geometry type.
private boolean hasboundingbox ( string url ) { string replacedurl = replaceboundingbox ( url , boundingbox ) ; boolean hasboundingbox = ! replacedurl . equals ( url ) ; return hasboundingbox ; }	Determine if the url has bounding box variables.
private string replacexyz ( string url , int z , long x , long y ) { url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_z ) , string . valueof ( z ) ) ; url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_x ) , string . valueof ( x ) ) ; url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_y ) , string . valueof ( y ) ) ; return url ; }	Replace x, y, and z in the url.
private boolean hasxyz ( string url ) { string replacedurl = replacexyz ( url , num_ , num_ , num_ ) ; boolean hasxyz = ! replacedurl . equals ( url ) ; return hasxyz ; }	Determine if the url has x, y, or z variables.
private string replaceboundingbox ( string url , int z , long x , long y ) { boundingbox boundingbox = tileboundingboxutils . getprojectedboundingbox ( projection , x , y , z ) ; url = replaceboundingbox ( url , boundingbox ) ; return url ; }	Replace the bounding box coordinates in the url.
private string replaceboundingbox ( string url , boundingbox boundingbox ) { url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_min_lat ) , string . valueof ( boundingbox . getminlatitude ( ) ) ) ; url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_max_lat ) , string . valueof ( boundingbox . getmaxlatitude ( ) ) ) ; url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_min_lon ) , string . valueof ( boundingbox . getminlongitude ( ) ) ) ; url = url . replaceall ( context . getstring ( r . string . tile_generator_variable_max_lon ) , string . valueof ( boundingbox . getmaxlongitude ( ) ) ) ; return url ; }	Replace the url parts with the bounding box.
public geopackagegeometrydata getgeometry ( ) { geopackagegeometrydata geometry = null ; int columnindex = gettable ( ) . getgeometrycolumnindex ( ) ; int type = gettype ( columnindex ) ; if ( type != field_type_null ) { byte [ ] geometrybytes = getblob ( columnindex ) ; if ( geometrybytes != null ) { geometry = new geopackagegeometrydata ( geometrybytes ) ; } } return geometry ; }	Get the geometry.
private boolean index ( long geopackageid , featurerow row , boolean possibleupdate ) { boolean indexed = bool_ ; geopackagegeometrydata geomdata = row . getgeometry ( ) ; if ( geomdata != null ) {	Index the feature row.
private void updatelastindexed ( geopackagemetadatadb db , long geopackageid ) { long indexedtime = ( new date ( ) ) . gettime ( ) ; tablemetadatadatasource ds = new tablemetadatadatasource ( db ) ; if ( ! ds . updatelastindexed ( geopackageid , featuredao . gettablename ( ) , indexedtime ) ) { throw new geopackageexception ( str_ + geopackageid + str_ + featuredao . gettablename ( ) + str_ + indexedtime ) ; } }	Update the least indexed time.
public boolean deleteindex ( ) { tablemetadatadatasource tablemetadatadatasource = new tablemetadatadatasource ( db ) ; boolean deleted = tablemetadatadatasource . delete ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) ) ; return deleted ; }	Delete the feature table index.
public boolean deleteindex ( long geomid ) { boolean deleted = geometrymetadatadatasource . delete ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) , geomid ) ; return deleted ; }	Delete the index for the geometry id.
public boolean isindexed ( ) { boolean indexed = bool_ ; date lastindexed = getlastindexed ( ) ; if ( lastindexed != null ) { contents contents = featuredao . getgeometrycolumns ( ) . getcontents ( ) ; date lastchange = contents . getlastchange ( ) ; indexed = lastindexed . equals ( lastchange ) || lastindexed . after ( lastchange ) ; } return indexed ; }	Determine if the database table is indexed after database modifications.
public cursor query ( ) { cursor cursor = geometrymetadatadatasource . query ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) ) ; return cursor ; }	Query for all Geometry Metadata.
public cursor query ( boundingbox boundingbox ) { cursor cursor = geometrymetadatadatasource . query ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) , boundingbox ) ; return cursor ; }	Query for Geometry Metadata within the bounding box, projectedcorrectly.
public int count ( boundingbox boundingbox ) { int count = geometrymetadatadatasource . count ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) , boundingbox ) ; return count ; }	Query for Geometry Metadata count within the bounding box, projectedcorrectly.
public cursor query ( geometryenvelope envelope ) { cursor cursor = geometrymetadatadatasource . query ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) , envelope ) ; return cursor ; }	Query for Geometry Metadata within the Geometry Envelope.
public int count ( geometryenvelope envelope ) { int count = geometrymetadatadatasource . count ( featuredao . getdatabase ( ) , featuredao . gettablename ( ) , envelope ) ; return count ; }	Query for Geometry Metadata count within the Geometry Envelope.
public cursor query ( boundingbox boundingbox , projection projection ) { boundingbox featureboundingbox = getfeatureboundingbox ( boundingbox , projection ) ; cursor cursor = query ( featureboundingbox ) ; return cursor ; }	Query for Geometry Metadata within the bounding box inthe provided projection.
public long count ( boundingbox boundingbox , projection projection ) { boundingbox featureboundingbox = getfeatureboundingbox ( boundingbox , projection ) ; long count = count ( featureboundingbox ) ; return count ; }	Query for Geometry Metadata count within the bounding box inthe provided projection.
private boundingbox getfeatureboundingbox ( boundingbox boundingbox , projection projection ) { projectiontransform projectiontransform = projection . gettransformation ( featuredao . getprojection ( ) ) ; boundingbox featureboundingbox = boundingbox . transform ( projectiontransform ) ; return featureboundingbox ; }	Get the bounding box in the feature projection from the bounding box inthe provided projection.
public geometrymetadata getgeometrymetadata ( cursor cursor ) { geometrymetadata geometrymetadata = geometrymetadatadatasource . creategeometrymetadata ( cursor ) ; return geometrymetadata ; }	Get the Geometry Metadata for the current place in the cursor.
public featurerow getfeaturerow ( cursor cursor ) { geometrymetadata geometrymetadata = getgeometrymetadata ( cursor ) ; featurerow featurerow = getfeaturerow ( geometrymetadata ) ; return featurerow ; }	Get the feature row for the current place in the cursor.
public featurerow getfeaturerow ( geometrymetadata geometrymetadata ) { long geomid = geometrymetadata . getid ( ) ;	Get the feature row for the Geometry Metadata.
public list < tiledao > gettiledaosforfeaturetable ( string featuretable ) { list < tiledao > tiledaos = new arraylist < tiledao > ( ) ; list < string > tiletables = gettiletablesforfeaturetable ( featuretable ) ; for ( string tiletable : tiletables ) { if ( geopackage . istiletable ( tiletable ) ) { tiledao tiledao = geopackage . gettiledao ( tiletable ) ; tiledaos . add ( tiledao ) ; } } return tiledaos ; }	Query for the tile tables linked to a feature table and return tile DAOsto those tables.
public list < featuredao > getfeaturedaosfortiletable ( string tiletable ) { list < featuredao > featuredaos = new arraylist < featuredao > ( ) ; list < string > featuretables = getfeaturetablesfortiletable ( tiletable ) ; for ( string featuretable : featuretables ) { if ( geopackage . isfeaturetable ( featuretable ) ) { featuredao featuredao = geopackage . getfeaturedao ( featuretable ) ; featuredaos . add ( featuredao ) ; } } return featuredaos ; }	Query for the feature tables linked to a tile table and return featureDAOs to those tables.
private static boundingbox getboundingbox ( geopackage geopackage , featuretiles featuretiles , boundingbox boundingbox , projection projection ) { string tablename = featuretiles . getfeaturedao ( ) . gettablename ( ) ; boolean manualquery = boundingbox == null ; boundingbox featureboundingbox = geopackage . getboundingbox ( projection , tablename , manualquery ) ; if ( featureboundingbox != null ) { if ( boundingbox == null ) { boundingbox = featureboundingbox ; } else { boundingbox = boundingbox . overlap ( featureboundingbox ) ; } } if ( boundingbox != null ) { boundingbox = featuretiles . expandboundingbox ( boundingbox , projection ) ; } return boundingbox ; }	Get the bounding box for the feature tile generator, from the providedand from the feature table.
public usercustomcursor querybyids ( long baseid , long relatedid ) { return query ( buildwhereids ( baseid , relatedid ) , buildwhereidsargs ( baseid , relatedid ) ) ; }	Query by both base id and related id.
public list < long > uniquebaseids ( ) { return querysinglecolumntypedresults ( str_ + coresqlutils . quotewrap ( usermappingtable . column_base_id ) + str_ + coresqlutils . quotewrap ( gettablename ( ) ) , null ) ; }	Get the unique base ids.
public list < long > uniquerelatedids ( ) { return querysinglecolumntypedresults ( str_ + coresqlutils . quotewrap ( usermappingtable . column_related_id ) + str_ + coresqlutils . quotewrap ( gettablename ( ) ) , null ) ; }	Get the unique related ids.
public int deletebybaseid ( long baseid ) { stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( usermappingtable . column_base_id , baseid ) ) ; string [ ] whereargs = buildwhereargs ( new object [ ] { baseid } ) ; int deleted = delete ( where . tostring ( ) , whereargs ) ; return deleted ; }	Delete user mappings by base id.
public int deletebyrelatedid ( long relatedid ) { stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( usermappingtable . column_related_id , relatedid ) ) ; string [ ] whereargs = buildwhereargs ( new object [ ] { relatedid } ) ; int deleted = delete ( where . tostring ( ) , whereargs ) ; return deleted ; }	Delete user mappings by related id.
public int deletebyids ( long baseid , long relatedid ) { return delete ( buildwhereids ( baseid , relatedid ) , buildwhereidsargs ( baseid , relatedid ) ) ; }	Delete user mappings by both base id and related id.
private string buildwhereids ( long baseid , long relatedid ) { stringbuilder where = new stringbuilder ( ) ; where . append ( buildwhere ( usermappingtable . column_base_id , baseid ) ) ; where . append ( str_ ) ; where . append ( buildwhere ( usermappingtable . column_related_id , relatedid ) ) ; return where . tostring ( ) ; }	Build the where ids clause.
public void create ( geopackagemetadata metadata ) { contentvalues values = new contentvalues ( ) ; values . put ( geopackagemetadata . column_name , metadata . getname ( ) ) ; values . put ( geopackagemetadata . column_external_path , metadata . getexternalpath ( ) ) ; long insertid = db . insert ( geopackagemetadata . table_name , null , values ) ; if ( insertid == - num_ ) { throw new geopackageexception ( str_ + metadata . getname ( ) + str_ + metadata . getexternalpath ( ) ) ; } metadata . setid ( insertid ) ; }	Create a new GeoPackage metadata.
public boolean delete ( string database ) { geopackagemetadata metadata = get ( database ) ; if ( metadata != null ) { tablemetadatadatasource tableds = new tablemetadatadatasource ( db ) ; tableds . delete ( metadata . getid ( ) ) ; } string whereclause = geopackagemetadata . column_name + str_ ; string [ ] whereargs = new string [ ] { database } ; int deletecount = db . delete ( geopackagemetadata . table_name , whereclause , whereargs ) ; return deletecount > num_ ; }	Delete the database.
public boolean rename ( geopackagemetadata metadata , string newname ) { boolean renamed = rename ( metadata . getname ( ) , newname ) ; if ( renamed ) { metadata . setname ( newname ) ; } return renamed ; }	Rename the GeoPackage metadata to the new name.
public boolean rename ( string name , string newname ) { string whereclause = geopackagemetadata . column_name + str_ ; string [ ] whereargs = new string [ ] { name } ; contentvalues values = new contentvalues ( ) ; values . put ( geopackagemetadata . column_name , newname ) ; int updatecount = db . update ( geopackagemetadata . table_name , values , whereclause , whereargs ) ; return updatecount > num_ ; }	Rename the GeoPackage name to the new name.
public list < geopackagemetadata > getall ( ) { list < geopackagemetadata > allmetadata = new arraylist < geopackagemetadata > ( ) ; cursor cursor = db . query ( geopackagemetadata . table_name , geopackagemetadata . columns , null , null , null , null , null ) ; try { while ( cursor . movetonext ( ) ) { geopackagemetadata metadata = creategeopackagemetadata ( cursor ) ; allmetadata . add ( metadata ) ; } } finally { cursor . close ( ) ; } return allmetadata ; }	Get all GeoPackage metadata.
public geopackagemetadata get ( string database ) { geopackagemetadata metadata = null ; string selection = geopackagemetadata . column_name + str_ ; string [ ] selectionargs = new string [ ] { database } ; cursor cursor = db . query ( geopackagemetadata . table_name , geopackagemetadata . columns , selection , selectionargs , null , null , null ) ; try { if ( cursor . movetonext ( ) ) { metadata = creategeopackagemetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get GeoPackage metadata by name.
public geopackagemetadata get ( long id ) { geopackagemetadata metadata = null ; string selection = geopackagemetadata . column_id + str_ ; string [ ] selectionargs = new string [ ] { string . valueof ( id ) } ; cursor cursor = db . query ( geopackagemetadata . table_name , geopackagemetadata . columns , selection , selectionargs , null , null , null ) ; try { if ( cursor . movetonext ( ) ) { metadata = creategeopackagemetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get GeoPackage metadata by id.
public geopackagemetadata getorcreate ( string geopackage ) { geopackagemetadata metadata = get ( geopackage ) ; if ( metadata == null ) { metadata = new geopackagemetadata ( ) ; metadata . setname ( geopackage ) ; create ( metadata ) ; } return metadata ; }	Get GeoPackage metadata or create it if it does not exist.
public boolean isexternal ( string database ) { geopackagemetadata metadata = get ( database ) ; return get ( database ) != null && metadata . getexternalpath ( ) != null ; }	Determine if the GeoPackage is external.
public geopackagemetadata getexternalatpath ( string path ) { geopackagemetadata metadata = null ; string selection = geopackagemetadata . column_external_path + str_ ; string [ ] selectionargs = new string [ ] { path } ; cursor cursor = db . query ( geopackagemetadata . table_name , geopackagemetadata . columns , selection , selectionargs , null , null , null ) ; try { if ( cursor . movetonext ( ) ) { metadata = creategeopackagemetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get external GeoPackage metadata by external path.
public list < string > getmetadatawherenamelike ( string like , string sortcolumn ) { return getmetadatawherenamelike ( like , sortcolumn , bool_ ) ; }	Get metadata where the name is like.
public list < string > getmetadatawherenamenotlike ( string notlike , string sortcolumn ) { return getmetadatawherenamelike ( notlike , sortcolumn , bool_ ) ; }	Get metadata where the name is not like.
private list < string > getmetadatawherenamelike ( string like , string sortcolumn , boolean notlike ) { list < string > names = new arraylist < > ( ) ; stringbuilder where = new stringbuilder ( geopackagemetadata . column_name ) ; if ( notlike ) { where . append ( str_ ) ; } where . append ( str_ ) ; string [ ] whereargs = new string [ ] { like } ; cursor cursor = db . query ( geopackagemetadata . table_name , new string [ ] { geopackagemetadata . column_name } , where . tostring ( ) , whereargs , null , null , sortcolumn ) ; try { while ( cursor . movetonext ( ) ) { names . add ( cursor . getstring ( num_ ) ) ; } } finally { cursor . close ( ) ; } return names ; }	Get metadata where the name is like or not like.
private geopackagemetadata creategeopackagemetadata ( cursor cursor ) { geopackagemetadata metadata = new geopackagemetadata ( ) ; metadata . setid ( cursor . getlong ( num_ ) ) ; metadata . setname ( cursor . getstring ( num_ ) ) ; metadata . setexternalpath ( cursor . getstring ( num_ ) ) ; return metadata ; }	Create a GeoPackage metadata from the current cursor location.
public view onviewcreated ( view view , context context , attributeset attrs ) { if ( view == null ) { return null ; } view = onviewcreatedinternal ( view , context , attrs ) ; for ( onviewcreatedlistener listener : otherlisteners ) { if ( listener != null ) { view = listener . onviewcreated ( view , context , attrs ) ; } } return view ; }	Handle the created view.
private void addparallaxview ( view view , int pageindex ) { if ( view instanceof viewgroup ) {	attach attributes in tag.
@ override protected view oncreateview ( string name , attributeset attrs ) throws classnotfoundexception {	The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.BUT only for none CustomViews.Basically if this method doesn't inflate the View nothing probably will.
private view createcustomviewinternal ( view parent , view view , string name , context context , attributeset attrs ) {	Nasty method to inflate custom layouts that haven't been handled else where.
protected void subappend ( cyclicbuffer < iloggingevent > cb , iloggingevent event ) { if ( includecallerdata ) { event . getcallerdata ( ) ; } event . preparefordeferredprocessing ( ) ; cb . add ( event ) ; }	Perform SMTPAppender specific appending actions, mainly adding the event toa cyclic buffer.
private url findconfigfilefromsystemproperties ( boolean updatestatus ) { string logbackconfigfile = optionhelper . getsystemproperty ( config_file_property ) ; if ( logbackconfigfile != null ) { url result = null ; try { file file = new file ( logbackconfigfile ) ; if ( file . exists ( ) && file . isfile ( ) ) { if ( updatestatus ) { statusonresourcesearch ( logbackconfigfile , this . classloader , logbackconfigfile ) ; } result = file . touri ( ) . tourl ( ) ; } else { result = new url ( logbackconfigfile ) ; } return result ; } catch ( malformedurlexception e ) {	Finds a configuration file by system property.
private url getresource ( string filename , classloader myclassloader , boolean updatestatus ) { url url = myclassloader . getresource ( filename ) ; if ( updatestatus ) { string resourcepath = null ; if ( url != null ) { resourcepath = filename ; } statusonresourcesearch ( filename , myclassloader , resourcepath ) ; } return url ; }	Uses the given classloader to search for a resource.
public void autoconfig ( ) throws joranexception { statuslistenerconfighelper . installifasked ( loggercontext ) ; new androidcontextutil ( ) . setupproperties ( loggercontext ) ; boolean verbose = bool_ ; boolean configured = bool_ ; joranconfigurator configurator = new joranconfigurator ( ) ; configurator . setcontext ( loggercontext ) ;	Configures logback with the first configuration found in the following search path.If no configuration found, nothing is done and logging is disabled.
private void statusonresourcesearch ( string resourcename , classloader classloader , string path ) { statusmanager sm = loggercontext . getstatusmanager ( ) ; if ( path == null ) { sm . add ( new infostatus ( str_ + resourcename + str_ , loggercontext ) ) ; } else { sm . add ( new infostatus ( str_ + resourcename + str_ + path + str_ , loggercontext ) ) ; } }	Adds a status message for the result of the resource search.
private string socketaddresstostring ( socketaddress address ) { string addr = address . tostring ( ) ; int i = addr . indexof ( str_ ) ; if ( i >= num_ ) { addr = addr . substring ( i + num_ ) ; } return addr ; }	Converts a socket address to a reasonable display string.
static public executorservice newexecutorservice ( ) { return new threadpoolexecutor ( coreconstants . core_pool_size , coreconstants . max_pool_size , num_ , timeunit . milliseconds , new synchronousqueue < runnable > ( ) , thread_factory ) ; }	Creates an executor service suitable for use by logback components.
public static < e > void startconverters ( converter < e > head ) { converter < e > c = head ; while ( c != null ) {	Start converters in the chain of converters.
@ override protected void subappend ( e event ) {	This method differentiates RollingFileAppender from its super class.
public void addsubstitutionproperty ( string key , string value ) { if ( key == null || value == null ) { return ; }	Add a property to the properties of this execution context.
public string getproperty ( string key ) { string v = propertiesmap . get ( key ) ; if ( v != null ) { return v ; } else { return context . getproperty ( key ) ; } }	If a key is found in propertiesMap then return it.
public converter < e > compile ( final node top , map < string , string > convertermap ) { compiler < e > compiler = new compiler < e > ( top , convertermap ) ; compiler . setcontext ( context ) ;	When the parsing step is done, the Node list can be transformed into aconverter chain.
node t ( ) throws scanexception { token t = getcurenttoken ( ) ; expectnotnull ( t , str_ ) ; switch ( t . gettype ( ) ) { case token . literal : advancetokenpointer ( ) ; return new node ( node . literal , t . getvalue ( ) ) ; case token . percent : advancetokenpointer ( ) ;	T = LITERAL | '%' C | '%' FORMAT_MODIFIER C.
public string toregexforfixeddate ( date date ) { stringbuilder buf = new stringbuilder ( ) ; converter < object > p = headtokenconverter ; while ( p != null ) { if ( p instanceof literalconverter ) { buf . append ( p . convert ( null ) ) ; } else if ( p instanceof integertokenconverter ) { buf . append ( filefinder . regexescapepath ( str_ ) ) ; } else if ( p instanceof datetokenconverter ) { datetokenconverter < object > dtc = ( datetokenconverter < object > ) p ; if ( dtc . isprimary ( ) ) { buf . append ( p . convert ( date ) ) ; } else { buf . append ( filefinder . regexescapepath ( dtc . toregex ( ) ) ) ; } } p = p . getnext ( ) ; } return buf . tostring ( ) ; }	Given date, convert this instance to a regular expression.Used to compute sub-regex when the pattern has both %d and %i, and thedate is known.
public void begin ( interpretationcontext ec , string name , attributes attributes ) {	Instantiates an evaluator of the given class and sets its name.
@ suppresswarnings ( str_ ) public void end ( interpretationcontext ec , string e ) { if ( inerror ) { return ; } if ( evaluator instanceof lifecycle ) { ( ( lifecycle ) evaluator ) . start ( ) ; addinfo ( str_ + evaluator . getname ( ) + str_ ) ; } object o = ec . peekobject ( ) ; if ( o != evaluator ) { addwarn ( str_ ) ; } else { ec . popobject ( ) ; try { map < string , eventevaluator < ? > > evaluatormap = ( map < string , eventevaluator < ? > > ) context . getobject ( coreconstants . evaluator_map ) ; if ( evaluatormap == null ) { adderror ( str_ ) ; } else { evaluatormap . put ( evaluator . getname ( ) , evaluator ) ; } } catch ( exception ex ) { adderror ( str_ + evaluator + str_ , ex ) ; } } }	Once the children elements are also parsed, now is the time to activate theevaluator options.
public void init ( loggercontext defaultloggercontext , object key ) throws classnotfoundexception , nosuchmethodexception , instantiationexception , illegalaccessexception , invocationtargetexception { if ( this . key == null ) { this . key = key ; } else if ( this . key != key ) { throw new illegalaccessexception ( str_ ) ; } string contextselectorstr = optionhelper . getsystemproperty ( classicconstants . logback_context_selector ) ; if ( contextselectorstr == null ) { contextselector = new defaultcontextselector ( defaultloggercontext ) ; } else if ( contextselectorstr . equals ( str_ ) ) { throw new runtimeexception ( str_ ) ; } else { contextselector = dynamicalcontextselector ( defaultloggercontext , contextselectorstr ) ; } }	FOR INTERNAL USE. This method is intended for use by StaticLoggerBinder.
static contextselector dynamicalcontextselector ( loggercontext defaultloggercontext , string contextselectorstr ) throws classnotfoundexception , securityexception , nosuchmethodexception , illegalargumentexception , instantiationexception , illegalaccessexception , invocationtargetexception { class < ? > contextselectorclass = loader . loadclass ( contextselectorstr ) ; constructor cons = contextselectorclass . getconstructor ( new class [ ] { loggercontext . class } ) ; return ( contextselector ) cons . newinstance ( defaultloggercontext ) ; }	Instantiate the context selector class designated by the user.
public void setupproperties ( loggercontext context ) {	Sets properties for use in configs.
public string getmountedexternalstoragedirectorypath ( ) { string path = null ; string state = environment . getexternalstoragestate ( ) ; if ( state . equals ( environment . media_mounted ) || state . equals ( environment . media_mounted_read_only ) ) { path = abspath ( environment . getexternalstoragedirectory ( ) ) ; } return path ; }	Gets the path to the external storage directory only ifmounted.
public string getdatabasedirectorypath ( ) { return this . context != null && this . context . getdatabasepath ( str_ ) != null ? this . context . getdatabasepath ( str_ ) . getparent ( ) : str_ ; }	Returns the absolute path to the directory on the Androidfilesystem where databases are stored for the current application.
private string getabsolutefilepath ( string filename ) {	Gets the absolute path to the filename, starting from the app's"files" directory, if it is not already an absolute path.
public boolean evaluate ( iloggingevent event ) throws nullpointerexception , evaluationexception { return event . getlevel ( ) . levelint >= level . error_int ; }	Return true if event passed as parameter has level ERROR or higher, returnsfalse otherwise.
public string getdiscriminatingvalue ( iloggingevent event ) {	Return the value associated with an MDC entry designated by the Keyproperty.
private void updatemaskifnecessary ( long now ) { final long timeelapsedsincelastmaskupdatecheck = now - lastmaskcheck ; lastmaskcheck = now ; if ( timeelapsedsincelastmaskupdatecheck < mask_increase_threshold && ( mask < max_mask ) ) { mask = ( mask << num_ ) | num_ ; } else if ( timeelapsedsincelastmaskupdatecheck > mask_decrease_threshold ) { mask = mask > > > num_ ; } }	update the mask so as to execute change detection code about once every 100 to 8000 milliseconds.
public filterreply getfilterchaindecision ( e event ) { final filter < e > [ ] filterarrray = filterlist . astypedarray ( ) ; final int len = filterarrray . length ; for ( int i = num_ ; i < len ; i ++ ) { final filterreply r = filterarrray [ i ] . decide ( event ) ; if ( r == filterreply . deny || r == filterreply . accept ) { return r ; } }	Loop through the filters in the list.
private keymanager [ ] createkeymanagers ( contextaware context ) throws nosuchproviderexception , nosuchalgorithmexception , unrecoverablekeyexception , keystoreexception { if ( getkeystore ( ) == null ) return null ; keystore keystore = getkeystore ( ) . createkeystore ( ) ; context . addinfo ( str_ + keystore . gettype ( ) + str_ + keystore . getprovider ( ) + str_ + getkeystore ( ) . getlocation ( ) ) ; keymanagerfactory kmf = getkeymanagerfactory ( ) . createkeymanagerfactory ( ) ; context . addinfo ( str_ + kmf . getalgorithm ( ) + str_ + kmf . getprovider ( ) + str_ ) ; char [ ] passphrase = getkeystore ( ) . getpassword ( ) . tochararray ( ) ; kmf . init ( keystore , passphrase ) ; return kmf . getkeymanagers ( ) ; }	Creates key managers using the receiver's key store configuration.
private trustmanager [ ] createtrustmanagers ( contextaware context ) throws nosuchproviderexception , nosuchalgorithmexception , keystoreexception { if ( gettruststore ( ) == null ) return null ; keystore truststore = gettruststore ( ) . createkeystore ( ) ; context . addinfo ( str_ + truststore . gettype ( ) + str_ + truststore . getprovider ( ) + str_ + gettruststore ( ) . getlocation ( ) ) ; trustmanagerfactory tmf = gettrustmanagerfactory ( ) . createtrustmanagerfactory ( ) ; context . addinfo ( str_ + tmf . getalgorithm ( ) + str_ + tmf . getprovider ( ) + str_ ) ; tmf . init ( truststore ) ; return tmf . gettrustmanagers ( ) ; }	Creates trust managers using the receiver's trust store configuration.
private keystorefactorybean keystorefromsystemproperties ( string property ) { if ( system . getproperty ( property ) == null ) return null ; keystorefactorybean keystore = new keystorefactorybean ( ) ; keystore . setlocation ( locationfromsystemproperty ( property ) ) ; keystore . setprovider ( system . getproperty ( property + str_ ) ) ; keystore . setpassword ( system . getproperty ( property + str_ ) ) ; keystore . settype ( system . getproperty ( property + str_ ) ) ; return keystore ; }	Constructs a key store factory bean using JSSE system properties.
private string locationfromsystemproperty ( string name ) { string location = system . getproperty ( name ) ; if ( location != null && ! location . startswith ( str_ ) ) { location = str_ + location ; } return location ; }	Constructs a resource location from a JSSE system property.
public static url urlforresource ( string location ) throws malformedurlexception , filenotfoundexception { if ( location == null ) { throw new nullpointerexception ( str_ ) ; } url url = null ; if ( ! location . matches ( scheme_pattern ) ) { url = loader . getresourcebyselfclassloader ( location ) ; } else if ( location . startswith ( classpath_scheme ) ) { string path = location . substring ( classpath_scheme . length ( ) ) ; if ( path . startswith ( str_ ) ) { path = path . substring ( num_ ) ; } if ( path . length ( ) == num_ ) { throw new malformedurlexception ( str_ ) ; } url = loader . getresourcebyselfclassloader ( path ) ; } else { url = new url ( location ) ; } if ( url == null ) { throw new filenotfoundexception ( location ) ; } return url ; }	Converts a string describing the location of a resource into a URL object.
public boolean chainhandlesthrowable ( converter < iloggingevent > head ) { converter < iloggingevent > c = head ; while ( c != null ) { if ( c instanceof throwablehandlingconverter ) { return bool_ ; } c = c . getnext ( ) ; } return bool_ ; }	This method computes whether a chain of converters handles exceptions ornot.
protected void stop ( ) { addinfo ( str_ ) ; context hookcontext = getcontext ( ) ; if ( hookcontext instanceof contextbase ) { contextbase context = ( contextbase ) hookcontext ; context . stop ( ) ; } }	Default method for stopping the Logback context.
public static void printincaseoferrorsorwarnings ( context context , long threshold ) { if ( context == null ) { throw new illegalargumentexception ( str_ ) ; } statusmanager sm = context . getstatusmanager ( ) ; if ( sm == null ) { ps . println ( str_ + context . getname ( ) + str_ ) ; } else { statusutil statusutil = new statusutil ( context ) ; if ( statusutil . gethighestlevel ( threshold ) >= errorstatus . warn ) { print ( sm , threshold ) ; } } }	Print the contents of the context status, but only if they containwarnings or errors occurring later then the threshold.
public static void printiferrorsoccured ( context context ) { if ( context == null ) { throw new illegalargumentexception ( str_ ) ; } statusmanager sm = context . getstatusmanager ( ) ; if ( sm == null ) { ps . println ( str_ + context . getname ( ) + str_ ) ; } else { statusutil statusutil = new statusutil ( context ) ; if ( statusutil . gethighestlevel ( num_ ) == errorstatus . error ) { print ( sm ) ; } } }	Print the contents of the context statuses, but only if they containerrors.
public static void print ( context context , long threshold ) { if ( context == null ) { throw new illegalargumentexception ( str_ ) ; } statusmanager sm = context . getstatusmanager ( ) ; if ( sm == null ) { ps . println ( str_ + context . getname ( ) + str_ ) ; } else { print ( sm , threshold ) ; } }	Print context's status data with a timestamp higher than the threshold.
private entry < c > getfromeithermap ( string key ) { entry < c > entry = livemap . get ( key ) ; if ( entry != null ) return entry ; else { return lingerersmap . get ( key ) ; } }	Get an entry from the liveMap, if not found search the lingerersMap.
public void endoflife ( string key ) { entry < c > entry = livemap . remove ( key ) ; if ( entry == null ) return ; lingerersmap . put ( key , entry ) ; }	Mark component identified by 'key' as having reached its end-of-life.
public static formatinfo valueof ( string str ) throws illegalargumentexception { if ( str == null ) { throw new nullpointerexception ( str_ ) ; } formatinfo fi = new formatinfo ( ) ; int indexofdot = str . indexof ( str_ ) ; string minpart = null ; string maxpart = null ; if ( indexofdot != - num_ ) { minpart = str . substring ( num_ , indexofdot ) ; if ( indexofdot + num_ == str . length ( ) ) { throw new illegalargumentexception ( str_ + str + str_ ) ; } else { maxpart = str . substring ( indexofdot + num_ ) ; } } else { minpart = str ; } if ( minpart != null && minpart . length ( ) > num_ ) { int min = integer . parseint ( minpart ) ; if ( min >= num_ ) { fi . min = min ; } else { fi . min = - min ; fi . leftpad = bool_ ; } } if ( maxpart != null && maxpart . length ( ) > num_ ) { int max = integer . parseint ( maxpart ) ; if ( max >= num_ ) { fi . max = max ; } else { fi . max = - max ; fi . lefttruncate = bool_ ; } } return fi ; }	This method is used to parse a string such as "5", ".7", "5.7" or "-5.7" intoa FormatInfo.
public void rename ( string src , string target ) throws rolloverfailure { if ( src . equals ( target ) ) { addwarn ( str_ + src + str_ ) ; return ; } file srcfile = new file ( src ) ; if ( srcfile . exists ( ) ) { file targetfile = new file ( target ) ; createmissingtargetdirsifnecessary ( targetfile ) ; addinfo ( str_ + srcfile + str_ + targetfile + str_ ) ; boolean result = srcfile . renameto ( targetfile ) ; if ( ! result ) { addwarn ( str_ + srcfile + str_ + targetfile + str_ ) ; boolean areondifferentvolumes = areondifferentvolumes ( srcfile , targetfile ) ; if ( boolean . true . equals ( areondifferentvolumes ) ) { addwarn ( str_ + src + str_ + target + str_ ) ; renamebycopying ( src , target ) ; return ; } else { addwarn ( str_ + rollingfileappender . class . getsimplename ( ) + str_ ) ; addwarn ( str_ + renaming_error_url ) ; } } } else { throw new rolloverfailure ( str_ + src + str_ ) ; } }	A relatively robust file renaming method which in case of failure due tosrc and target being on different volumes, falls back ontorenaming by copying.
boolean areondifferentvolumes ( file srcfile , file targetfile ) throws rolloverfailure { if ( ! envutil . isjdk7orhigher ( ) ) { return bool_ ; }	Attempts tp determine whether both files are on different volumes.
public static string getenv ( string key ) { try { return system . getenv ( key ) ; } catch ( securityexception e ) { return null ; } }	Lookup a key from the environment.
public static string getandroidsystemproperty ( string key ) { try { return systempropertiesproxy . getinstance ( ) . get ( key , null ) ; } catch ( illegalargumentexception e ) { return null ; } }	Gets an Android system property.
public void setmdcpropertymap ( map < string , string > map ) { if ( mdcpropertymap != null ) { throw new illegalstateexception ( str_ ) ; } this . mdcpropertymap = map ; }	Set the MDC map for this event.
private string outputmdcforallkeys ( map < string , string > mdcpropertymap ) { stringbuilder buf = new stringbuilder ( ) ; boolean first = bool_ ; for ( map . entry < string , string > entry : mdcpropertymap . entryset ( ) ) { if ( first ) { first = bool_ ; } else { buf . append ( str_ ) ; }	if no key is specified, return all the values present in the MDC, in the format "k1=v1, k2=v2, ...".
public static stacktraceelement [ ] extract ( throwable t , string fqnofinvokingclass , final int maxdepth , list < string > frameworkpackagelist ) { if ( t == null ) { return null ; } stacktraceelement [ ] stearray = t . getstacktrace ( ) ; stacktraceelement [ ] callerdataarray ; int found = line_na ; for ( int i = num_ ; i < stearray . length ; i ++ ) { if ( isinframeworkspace ( stearray [ i ] . getclassname ( ) , fqnofinvokingclass , frameworkpackagelist ) ) {	Extract caller data information as an array based on a Throwable passed asparameter.
private static boolean isinframeworkspacelist ( string currentclass , list < string > frameworkpackagelist ) { if ( frameworkpackagelist == null ) return bool_ ; for ( string s : frameworkpackagelist ) { if ( currentclass . startswith ( s ) ) return bool_ ; } return bool_ ; }	Is currentClass present in the list of packages considered part of the logging framework?.
public void add ( status newstatus ) {	Add a new status object.
public boolean add ( statuslistener listener ) { synchronized ( statuslistenerlistlock ) { if ( listener instanceof onconsolestatuslistener ) { boolean alreadypresent = checkforpresence ( statuslistenerlist , listener . getclass ( ) ) ; if ( alreadypresent ) { return bool_ ; } } statuslistenerlist . add ( listener ) ; } return bool_ ; }	This implementation does not allow duplicate installations of OnConsoleStatusListener.
list < action > lookupimplicitaction ( elementpath elementpath , attributes attributes , interpretationcontext ec ) { int len = implicitactions . size ( ) ; for ( int i = num_ ; i < len ; i ++ ) { implicitaction ia = ( implicitaction ) implicitactions . get ( i ) ; if ( ia . isapplicable ( elementpath , attributes , ec ) ) { list < action > actionlist = new arraylist < action > ( num_ ) ; actionlist . add ( ia ) ; return actionlist ; } } return null ; }	Check if any implicit actions are applicable.
list < action > getapplicableactionlist ( elementpath elementpath , attributes attributes ) { list < action > applicableactionlist = rulestore . matchactions ( elementpath ) ;	Return the list of applicable patterns for this.
public void setclassloader ( classloader cl ) throws classnotfoundexception , securityexception , nosuchmethodexception { if ( cl == null ) cl = this . getclass ( ) . getclassloader ( ) ; systemproperties = cl . loadclass ( str_ ) ; getstring = systemproperties . getmethod ( str_ , new class [ ] { string . class , string . class } ) ; getboolean = systemproperties . getmethod ( str_ , new class [ ] { string . class , boolean . class } ) ; }	Sets the classloader to lookup the class for android.os.SystemProperties.
public string get ( string key , string def ) throws illegalargumentexception { if ( systemproperties == null || getstring == null ) return null ; string ret = null ; try { ret = ( string ) getstring . invoke ( systemproperties , new object [ ] { key , def } ) ; } catch ( illegalargumentexception e ) { throw e ; } catch ( exception e ) { }	Get the value for the given key in the Android system properties.
static public string decapitalize ( string name ) { if ( name == null || name . length ( ) == num_ ) { return name ; } else { string nm = name . substring ( num_ , num_ ) . tolowercase ( locale . us ) ; if ( name . length ( ) > num_ ) { nm += name . substring ( num_ ) ; } return nm ; } }	Converts a name string's first letter to lowercase.
static public methoddescriptor [ ] getmethoddescriptors ( class < ? > clazz ) { arraylist < methoddescriptor > methods = new arraylist < methoddescriptor > ( ) ; for ( method m : clazz . getmethods ( ) ) { methods . add ( new methoddescriptor ( m . getname ( ) , m ) ) ; } return methods . toarray ( new methoddescriptor [ num_ ] ) ; }	Gets a class's method descriptors.
static public propertydescriptor [ ] getpropertydescriptors ( class < ? > clazz ) { final string setter_prefix = str_ ; final string getter_prefix = str_ ; final int len_prefix = setter_prefix . length ( ) ; map < string , propertydescriptor > map = new hashmap < string , propertydescriptor > ( ) ; for ( method m : clazz . getmethods ( ) ) { propertydescriptor pd = null ; string mname = m . getname ( ) ; boolean isget = mname . startswith ( getter_prefix ) && ( mname . length ( ) > len_prefix ) ; boolean isset = mname . startswith ( setter_prefix ) && ( mname . length ( ) > len_prefix ) ; if ( isget || isset ) { string propname = decapitalize ( mname . substring ( len_prefix ) ) ; pd = map . get ( propname ) ; if ( pd == null ) { pd = new propertydescriptor ( propname ) ; map . put ( propname , pd ) ; } class < ? > [ ] parmtypes = m . getparametertypes ( ) ; if ( isset ) { if ( parmtypes . length == num_ ) {	Gets a class's property descriptors.
public void start ( ) { int errors = num_ ; if ( this . encoder == null ) { addstatus ( new errorstatus ( str_ + name + str_ , this ) ) ; errors ++ ; } if ( this . outputstream == null ) { addstatus ( new errorstatus ( str_ + name + str_ , this ) ) ; errors ++ ; }	Checks that requires parameters are set and if everything is in order,activates this appender.
static public void addonconsolelistenerinstance ( context context , onconsolestatuslistener onconsolestatuslistener ) { onconsolestatuslistener . setcontext ( context ) ; boolean effectivelyadded = context . getstatusmanager ( ) . add ( onconsolestatuslistener ) ; if ( effectivelyadded ) { onconsolestatuslistener . start ( ) ; } }	This utility method adds a new OnConsoleStatusListener to the contextpassed as parameter.
public void end ( interpretationcontext ec , string name ) { if ( inerror ) { return ; } object o = ec . peekobject ( ) ; if ( o != definer ) { addwarn ( str_ + propertyname + str_ ) ; } else { addinfo ( str_ + propertyname + str_ ) ; ec . popobject ( ) ;	Now property definer is initialized by all properties and we can putproperty value to context.
public string getdiscriminatingvalue ( iloggingevent event ) { string contextname = event . getloggercontextvo ( ) . getname ( ) ; if ( contextname == null ) { return defaultvalue ; } else { return contextname ; } }	Return the name of the current context name as found in the logging event.
protected boolean isdiscardable ( iloggingevent event ) { level level = event . getlevel ( ) ; return level . toint ( ) <= level . info_int ; }	Events of level TRACE, DEBUG and INFO are deemed to be discardable.
@ override public void begin ( interpretationcontext ic , string name , attributes attributes ) throws actionexception { hook = null ; inerror = bool_ ; string classname = attributes . getvalue ( class_attribute ) ; if ( optionhelper . isempty ( classname ) ) { classname = defaultshutdownhook . class . getname ( ) ; addinfo ( str_ + classname + str_ ) ; } try { addinfo ( str_ + classname + str_ ) ; hook = ( shutdownhookbase ) optionhelper . instantiatebyclassname ( classname , shutdownhookbase . class , context ) ; hook . setcontext ( context ) ; ic . pushobject ( hook ) ; } catch ( exception e ) { inerror = bool_ ; adderror ( str_ + classname + str_ , e ) ; throw new actionexception ( e ) ; } }	Instantiates a shutdown hook of the given class and sets its name.The hook thus generated is placed in the {.
@ override public void end ( interpretationcontext ic , string name ) throws actionexception { if ( inerror ) { return ; } object o = ic . peekobject ( ) ; if ( o != hook ) { addwarn ( str_ ) ; } else { ic . popobject ( ) ; thread hookthread = new thread ( hook , str_ + context . getname ( ) + str_ ) ; addinfo ( str_ ) ; context . putobject ( coreconstants . shutdown_hook_thread , hookthread ) ; runtime . getruntime ( ) . addshutdownhook ( hookthread ) ; } }	Once the children elements are also parsed, now is the time to activate theshutdown hook options.
private string [ ] enabledprotocols ( string [ ] supportedprotocols , string [ ] defaultprotocols ) { if ( enabledprotocols == null ) {	Gets the set of enabled protocols based on the configuration.
private string [ ] enabledciphersuites ( string [ ] supportedciphersuites , string [ ] defaultciphersuites ) { if ( enabledciphersuites == null ) {	Gets the set of enabled cipher suites based on the configuration.
private string [ ] includedstrings ( string [ ] defaults , string included , string excluded ) { list < string > values = new arraylist < string > ( defaults . length ) ; values . addall ( arrays . aslist ( defaults ) ) ; if ( included != null ) { stringcollectionutil . retainmatching ( values , stringtoarray ( included ) ) ; } if ( excluded != null ) { stringcollectionutil . removematching ( values , stringtoarray ( excluded ) ) ; } return values . toarray ( new string [ values . size ( ) ] ) ; }	Applies include and exclude patterns to an array of default string valuesto produce an array of strings included by the patterns.
static public scope stringtoscope ( string scopestr ) { if ( scope . system . tostring ( ) . equalsignorecase ( scopestr ) ) return scope . system ; if ( scope . context . tostring ( ) . equalsignorecase ( scopestr ) ) return scope . context ; return scope . local ; }	Convert a string into a scope.
static public void setproperties ( interpretationcontext ic , properties props , scope scope ) { switch ( scope ) { case local : ic . addsubstitutionproperties ( props ) ; break ; case context : contextutil cu = new contextutil ( ic . getcontext ( ) ) ; cu . addproperties ( props ) ; break ; case system : optionhelper . setsystemproperties ( ic , props ) ; } }	Add all the properties found in the argument named 'props' to anInterpretationContext.
public void addappender ( appender < e > newappender ) { if ( newappender == null ) { throw new illegalargumentexception ( str_ ) ; } appenderlist . addifabsent ( newappender ) ; }	Attach an appender. If the appender is already in the list in won't beadded again.
public boolean detachappender ( appender < e > appender ) { if ( appender == null ) { return bool_ ; } boolean result ; result = appenderlist . remove ( appender ) ; return result ; }	Remove the appender passed as parameter form the list of attachedappenders.
public boolean detachappender ( string name ) { if ( name == null ) { return bool_ ; } boolean removed = bool_ ; for ( appender < e > a : appenderlist ) { if ( name . equals ( ( a ) . getname ( ) ) ) { removed = appenderlist . remove ( a ) ; break ; } } return removed ; }	Remove the appender with the name passed as parameter form the list ofappenders.
private synchronized void handleparentlevelchange ( int newparentlevelint ) {	This method is invoked by parent logger to let this logger know that theprent's levelInt changed.
public void callappenders ( iloggingevent event ) { int writes = num_ ; for ( logger l = this ; l != null ; l = l . parent ) { writes += l . appendlooponappenders ( event ) ; if ( ! l . additive ) { break ; } }	Invoke all the appenders of this logger.
public boolean detachappender ( appender < iloggingevent > appender ) { if ( aai == null ) { return bool_ ; } return aai . detachappender ( appender ) ; }	Remove the appender passed as parameter form the list of appenders.
logger createchildbylastnamepart ( final string lastpart ) { int i_index = loggernameutil . getfirstseparatorindexof ( lastpart ) ; if ( i_index != - num_ ) { throw new illegalargumentexception ( str_ + lastpart + str_ + coreconstants . dot + str_ ) ; } if ( childrenlist == null ) { childrenlist = new copyonwritearraylist < logger > ( ) ; } logger childlogger ; if ( this . isrootlogger ( ) ) { childlogger = new logger ( lastpart , this , this . loggercontext ) ; } else { childlogger = new logger ( name + coreconstants . dot + lastpart , this , this . loggercontext ) ; } childrenlist . add ( childlogger ) ; childlogger . effectivelevelint = this . effectivelevelint ; return childlogger ; }	Create a child of this logger by suffix, that is, the part of the nameextending this logger.
private filterreply callturbofilters ( marker marker , level level ) { return loggercontext . getturbofilterchaindecision_0_3ormore ( marker , this , level , null , null , null ) ; }	Method that calls the attached TurboFilter objects based on the logger andthe level.It is used by isYYYEnabled() methods.It returns the typical FilterReply values: ACCEPT, NEUTRAL or DENY.
public void log ( org . slf4j . event . loggingevent slf4jevent ) { level level = level . fromlocationawareloggerinteger ( slf4jevent . getlevel ( ) . toint ( ) ) ; filterandlog_0_or3plus ( fqcn , slf4jevent . getmarker ( ) , level , slf4jevent . getmessage ( ) , slf4jevent . getargumentarray ( ) , slf4jevent . getthrowable ( ) ) ; }	Support SLF4J interception during initialization as introduced in SLF4J version 1.7.15.
public socket call ( ) throws interruptedexception { usedefaultsformissingfields ( ) ; socket socket = createsocket ( ) ; while ( socket == null && ! thread . currentthread ( ) . isinterrupted ( ) ) { thread . sleep ( delaystrategy . nextdelay ( ) ) ; socket = createsocket ( ) ; } return socket ; }	Loops until the desired connection is established and returns the resulting connector.
static public boolean createmissingparentdirectories ( file file ) { file parent = file . getparentfile ( ) ; if ( parent == null ) {	Creates the parent directories of a file.
public integer tointeger ( ) { switch ( levelint ) { case all_int : return all_integer ; case trace_int : return trace_integer ; case debug_int : return debug_integer ; case info_int : return info_integer ; case warn_int : return warn_integer ; case error_int : return error_integer ; case off_int : return off_integer ; default : throw new illegalstateexception ( str_ + levelstr + str_ + levelint + str_ ) ; } }	Convert a Level to an Integer object.
public static level tolevel ( int val , level defaultlevel ) { switch ( val ) { case all_int : return all ; case trace_int : return trace ; case debug_int : return debug ; case info_int : return info ; case warn_int : return warn ; case error_int : return error ; case off_int : return off ; default : return defaultlevel ; } }	Convert an integer passed as argument to a Level.
public static set < url > getresourceoccurrencecount ( string resource , classloader classloader ) throws ioexception {	Compute the number of occurrences a resource can be found by a classloader.
public static url getresource ( string resource , classloader classloader ) { try { return classloader . getresource ( resource ) ; } catch ( throwable t ) { return null ; } }	Search for a resource using the classloader passed as parameter.
public static classloader getclassloaderofobject ( object o ) { if ( o == null ) { throw new nullpointerexception ( str_ ) ; } return getclassloaderofclass ( o . getclass ( ) ) ; }	Get the class loader of the object passed as argument.
public static classloader getclassloaderasprivileged ( final class < ? > clazz ) { if ( ! has_get_class_loader_permission ) return null ; else return accesscontroller . doprivileged ( new privilegedaction < classloader > ( ) { public classloader run ( ) { return clazz . getclassloader ( ) ; } } ) ; }	Returns the class loader of clazz in an access privileged section.
public static classloader getclassloaderofclass ( final class < ? > clazz ) { classloader cl = clazz . getclassloader ( ) ; if ( cl == null ) { return classloader . getsystemclassloader ( ) ; } else { return cl ; } }	Return the class loader which loaded the class passed as argument.
@ override public void start ( ) { if ( ( this . encoder == null ) || ( this . encoder . getlayout ( ) == null ) ) { adderror ( str_ + name + str_ ) ; return ; }	Checks that required parameters are set, and if everything is in order,activates this appender.
protected string gettag ( iloggingevent event ) {	Gets the logcat tag string of a logging event.
public void begin ( interpretationcontext ec , string localname , attributes attributes ) { if ( str_ . equals ( localname ) ) { addwarn ( str_ ) ; } string name = attributes . getvalue ( name_attribute ) ; string value = attributes . getvalue ( value_attribute ) ; string scopestr = attributes . getvalue ( scope_attribute ) ; scope scope = actionutil . stringtoscope ( scopestr ) ; if ( checkfileattributesanity ( attributes ) ) { string file = attributes . getvalue ( file_attribute ) ; file = ec . subst ( file ) ; try { fileinputstream istream = new fileinputstream ( file ) ; loadandsetproperties ( ec , istream , scope ) ; } catch ( filenotfoundexception e ) { adderror ( str_ + file + str_ ) ; } catch ( ioexception e1 ) { adderror ( str_ + file + str_ , e1 ) ; } } else if ( checkresourceattributesanity ( attributes ) ) { string resource = attributes . getvalue ( resource_attribute ) ; resource = ec . subst ( resource ) ; url resourceurl = loader . getresourcebyselfclassloader ( resource ) ; if ( resourceurl == null ) { adderror ( str_ + resource + str_ ) ; } else { try { inputstream istream = resourceurl . openstream ( ) ; loadandsetproperties ( ec , istream , scope ) ; } catch ( ioexception e ) { adderror ( str_ + resource + str_ , e ) ; } } } else if ( checkvaluenameattributessanity ( attributes ) ) { value = regularescapeutil . basicescape ( value ) ;	Set a new property for the execution context by name, value pair, or addsall the properties found in the given file.
public static int getseparatorindexof ( string name , int fromindex ) { int dotindex = name . indexof ( coreconstants . dot , fromindex ) ; int dollarindex = name . indexof ( coreconstants . dollar , fromindex ) ; if ( dotindex == - num_ && dollarindex == - num_ ) return - num_ ; if ( dotindex == - num_ ) return dollarindex ; if ( dollarindex == - num_ ) return dotindex ; return dotindex < dollarindex ? dotindex : dollarindex ; }	Get the position of the separator character, if any, starting at position'fromIndex'.
public boolean evaluate ( iloggingevent event ) throws nullpointerexception , evaluationexception { marker eventsmarker = event . getmarker ( ) ; if ( eventsmarker == null ) { return bool_ ; } for ( string markerstr : markerlist ) { if ( eventsmarker . contains ( markerstr ) ) { return bool_ ; } } return bool_ ; }	Return true if event passed as parameter contains one of the specifieduser-markers.
protected string getclientthreadname ( socket socket ) { return string . format ( locale . us , str_ , socket . getremotesocketaddress ( ) ) ; }	Returns a name to identify each client thread.
static public boolean areonsamefilestore ( file a , file b ) throws rolloverfailure { if ( ! a . exists ( ) ) { throw new illegalargumentexception ( str_ + a + str_ ) ; } if ( ! b . exists ( ) ) { throw new illegalargumentexception ( str_ + b + str_ ) ; }	This method assumes that both files a and b exists.
protected void append ( e eventobject ) { if ( ! checkentryconditions ( ) ) { return ; } string key = discriminator . getdiscriminatingvalue ( eventobject ) ; long now = system . currenttimemillis ( ) ; final cyclicbuffer < e > cb = cbtracker . getorcreate ( key , now ) ; subappend ( cb , eventobject ) ; try { if ( eventevaluator . evaluate ( eventobject ) ) {	Perform SMTPAppender specific appending actions, delegating some of them toa subclass and checking if the event triggers an e-mail to be sent.
protected void sendbuffer ( cyclicbuffer < e > cb , e lasteventobject ) {	Send the contents of the cyclic buffer as an e-mail message.
public void addmdcvaluelevelpair ( mdcvaluelevelpair mdcvaluelevelpair ) { if ( valuelevelmap . containskey ( mdcvaluelevelpair . getvalue ( ) ) ) { adderror ( mdcvaluelevelpair . getvalue ( ) + str_ ) ; } else { valuelevelmap . put ( mdcvaluelevelpair . getvalue ( ) , mdcvaluelevelpair . getlevel ( ) ) ; } }	Add a new MDCValuePair.
@ suppresswarnings ( str_ ) dynamicconverter < e > createconverter ( simplekeywordnode kn ) { string keyword = ( string ) kn . getvalue ( ) ; string converterclassstr = ( string ) convertermap . get ( keyword ) ; if ( converterclassstr != null ) { try { return ( dynamicconverter < e > ) optionhelper . instantiatebyclassname ( converterclassstr , dynamicconverter . class , context ) ; } catch ( exception e ) { adderror ( str_ + converterclassstr + str_ + keyword + str_ , e ) ; return null ; } } else { adderror ( str_ + keyword + str_ ) ; return null ; } }	Attempt to create a converter using the information found in'converterMap'.
@ suppresswarnings ( str_ ) compositeconverter < e > createcompositeconverter ( compositenode cn ) { string keyword = ( string ) cn . getvalue ( ) ; string converterclassstr = ( string ) convertermap . get ( keyword ) ; if ( converterclassstr != null ) { try { return ( compositeconverter < e > ) optionhelper . instantiatebyclassname ( converterclassstr , compositeconverter . class , context ) ; } catch ( exception e ) { adderror ( str_ + converterclassstr + str_ + keyword + str_ , e ) ; return null ; } } else { adderror ( str_ + keyword + str_ ) ; return null ; } }	Attempt to create a converter using the information found in'compositeConverterMap'.
protected void determinecompressionmode ( ) { if ( filenamepatternstr . endswith ( str_ ) ) { addinfo ( str_ ) ; compressionmode = compressionmode . gz ; } else if ( filenamepatternstr . endswith ( str_ ) ) { addinfo ( str_ ) ; compressionmode = compressionmode . zip ; } else { addinfo ( str_ ) ; compressionmode = compressionmode . none ; } }	Given the FileNamePattern string, this method determines the compressionmode depending on last letters of the fileNamePatternStr.
public final void doconfigure ( url url ) throws joranexception { inputstream in = null ; try { informcontextofurlusedforconfiguration ( getcontext ( ) , url ) ; urlconnection urlconnection = url . openconnection ( ) ;	Configures logback with the configuration XML read from a file,located at the given URL.
public final void doconfigure ( file file ) throws joranexception { fileinputstream fis = null ; try { url url = file . touri ( ) . tourl ( ) ; informcontextofurlusedforconfiguration ( getcontext ( ) , url ) ; fis = new fileinputstream ( file ) ;	Configures logback with the configuration XML read from a given file.
public final void doconfigure ( inputstream inputstream ) throws joranexception { try { doconfigure ( new inputsource ( inputstream ) ) ; } finally { try { inputstream . close ( ) ; } catch ( ioexception ioe ) { string errmsg = str_ ; adderror ( errmsg , ioe ) ; throw new joranexception ( errmsg , ioe ) ; } } }	Configures logback with the configuraiton XML read from an input stream,and then closes the stream.
protected void buildinterpreter ( ) { rulestore rs = new simplerulestore ( context ) ; addinstancerules ( rs ) ; this . interpreter = new interpreter ( context , rs , initialelementpath ( ) ) ; interpretationcontext interpretationcontext = interpreter . getinterpretationcontext ( ) ; interpretationcontext . setcontext ( context ) ; addimplicitrules ( interpreter ) ; adddefaultnestedcomponentregistryrules ( interpretationcontext . getdefaultnestedcomponentregistry ( ) ) ; }	Builds a generic configuration-XML interpreter.
private final void doconfigure ( final inputsource inputsource ) throws joranexception { long threshold = system . currenttimemillis ( ) ;	Configures logback with the configuration XML read from an input source.
public void doconfigure ( final list < saxevent > eventlist ) throws joranexception { buildinterpreter ( ) ;	Configures logback with SAX events of configuration XML.
public string getproperty ( string key ) { if ( context_name_key . equals ( key ) ) return getname ( ) ; return ( string ) this . propertymap . get ( key ) ; }	Given a key, return the corresponding property value.
public void setname ( string name ) throws illegalstateexception { if ( name != null && name . equals ( this . name ) ) { return ;	The context name can be set only if it is not already set, or if thecurrent name is the default context name, namely "default", or if thecurrent name and the old name are the same.
static public boolean contexthasstatuslistener ( context context ) { statusmanager sm = context . getstatusmanager ( ) ; if ( sm == null ) return bool_ ; list < statuslistener > listeners = sm . getcopyofstatuslistenerlist ( ) ; if ( listeners == null || listeners . size ( ) == num_ ) return bool_ ; else return bool_ ; }	Returns true if the StatusManager associated with the context passedas parameter has one or more StatusListener instances registered.
public long timeoflastreset ( ) { list < status > statuslist = sm . getcopyofstatuslist ( ) ; if ( statuslist == null ) return - num_ ; int len = statuslist . size ( ) ; for ( int i = len - num_ ; i >= num_ ; i -- ) { status s = statuslist . get ( i ) ; if ( coreconstants . reset_msg_prefix . equals ( s . getmessage ( ) ) ) { return s . getdate ( ) ; } } return - num_ ; }	Return the time of last reset. -1 if last reset time could not be found.
@ override public void start ( ) { int errorcount = num_ ; try { parser < e > p = new parser < e > ( pattern ) ; p . setcontext ( getcontext ( ) ) ; node t = p . parse ( ) ; this . head = p . compile ( t , geteffectiveconvertermap ( ) ) ; converterutil . startconverters ( this . head ) ; } catch ( scanexception ex ) { adderror ( str_ , ex ) ; errorcount ++ ; } if ( errorcount == num_ ) { super . started = bool_ ; } }	Parses the pattern and creates the Converter linked list.
public map < string , string > geteffectiveconvertermap ( ) { map < string , string > effectivemap = new hashmap < string , string > ( ) ;	Returns a map where the default converter map is merged with the mapcontained in the context.
@ override public string getfileheader ( ) { stringbuilder sbuf = new stringbuilder ( ) ; sbuf . append ( str_ ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; sbuf . append ( title ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; cssbuilder . addcss ( sbuf ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; sbuf . append ( line_separator ) ; return sbuf . tostring ( ) ; }	Returns appropriate HTML headers.
@ override public string getfilefooter ( ) { stringbuilder sbuf = new stringbuilder ( ) ; sbuf . append ( line_separator ) ; sbuf . append ( str_ ) ; return sbuf . tostring ( ) ; }	Returns the appropriate HTML footers.
@ suppresswarnings ( str_ ) public void begin ( interpretationcontext ec , string localname , attributes attributes ) throws actionexception {	Instantiates an appender of the given class and sets its name.The appender thus generated is placed in the {.
public void end ( interpretationcontext ec , string name ) { if ( inerror ) { return ; } if ( appender instanceof lifecycle ) { ( ( lifecycle ) appender ) . start ( ) ; } object o = ec . peekobject ( ) ; if ( o != appender ) { addwarn ( str_ + appender . getname ( ) + str_ ) ; } else { ec . popobject ( ) ; } }	Once the children elements are also parsed, now is the time to activate theappender options.
private collection < t > copyclients ( ) { clientslock . lock ( ) ; try { collection < t > copy = new arraylist < t > ( clients ) ; return copy ; } finally { clientslock . unlock ( ) ; } }	Creates a copy of the collection of all clients that are presentlybeing tracked by the server.
private void addclient ( t client ) { clientslock . lock ( ) ; try { clients . add ( client ) ; } finally { clientslock . unlock ( ) ; } }	Adds a client to the collection of those being tracked by the server.
private void removeclient ( t client ) { clientslock . lock ( ) ; try { clients . remove ( client ) ; } finally { clientslock . unlock ( ) ; } }	Removes a client from the collection of those being tracked by the server.
public map < string , string > getcopyofcontextmap ( ) { map < string , string > hashmap = copyonthreadlocal . get ( ) ; if ( hashmap == null ) { return null ; } else { return new hashmap < string , string > ( hashmap ) ; } }	Return a copy of the current thread's context map.
public static method getvalueofmethod ( class < ? > type ) { try { return type . getmethod ( coreconstants . value_of , sting_class_parameter ) ; } catch ( nosuchmethodexception e ) { return null ; } catch ( securityexception e ) { return null ; } }	returned value may be null and in most cases it is null.
public filterreply getturbofilterchaindecision ( final marker marker , final logger logger , final level level , final string format , final object [ ] params , final throwable t ) { final int size = size ( ) ;	Loop through the filters in the chain.
static public boolean isandroidos ( ) { string osname = optionhelper . getsystemproperty ( str_ ) ; string root = optionhelper . getenv ( str_ ) ; string data = optionhelper . getenv ( str_ ) ; return osname != null && osname . contains ( str_ ) && root != null && root . contains ( str_ ) && data != null && data . contains ( str_ ) ; }	Heuristically determines whether the current OS is Android.
void init ( ) { try { try { new contextinitializer ( defaultloggercontext ) . autoconfig ( ) ; } catch ( joranexception je ) { util . report ( str_ , je ) ; }	Package access for testing purposes.
public static file [ ] filesinfoldermatchingstemregex ( file file , final string stemregex ) { if ( file == null ) { return new file [ num_ ] ; } if ( ! file . exists ( ) || ! file . isdirectory ( ) ) { return new file [ num_ ] ; } return file . listfiles ( new filenamefilter ( ) { public boolean accept ( file dir , string name ) { return name . matches ( stemregex ) ; } } ) ; }	Return the set of files matching the stemRegex as found in 'directory'.
private void retrospectiveprint ( ) { if ( context == null ) return ; long now = system . currenttimemillis ( ) ; statusmanager sm = context . getstatusmanager ( ) ; list < status > statuslist = sm . getcopyofstatuslist ( ) ; for ( status status : statuslist ) { long timestampofstatusmesage = status . getdate ( ) ; if ( iselapsedtimelongerthanthreshold ( now , timestampofstatusmesage ) ) { print ( status ) ; } } }	Print status messages retrospectively.
public file getdatabasefile ( string filename ) { file dbfile = null ; if ( filename != null && filename . trim ( ) . length ( ) > num_ ) { dbfile = new file ( filename ) ; } if ( dbfile == null || dbfile . isdirectory ( ) ) { dbfile = new file ( new androidcontextutil ( ) . getdatabasepath ( str_ ) ) ; } return dbfile ; }	Gets a file object from a file path to a SQLite database.
private void clearexpiredlogs ( sqlitedatabase db ) { if ( lastcheckexpired ( this . maxhistory , this . lastcleanuptime ) ) { this . lastcleanuptime = this . clock . currenttimemillis ( ) ; this . getlogcleaner ( ) . performlogcleanup ( db , this . maxhistory ) ; } }	Removes expired logs from the database.
private boolean lastcheckexpired ( duration expiry , long lastcleanuptime ) { boolean isexpired = bool_ ; if ( expiry != null && expiry . getmilliseconds ( ) > num_ ) { final long now = this . clock . currenttimemillis ( ) ; final long timediff = now - lastcleanuptime ; isexpired = ( lastcleanuptime <= num_ ) || ( timediff >= expiry . getmilliseconds ( ) ) ; } return isexpired ; }	Determines whether it's time to clear expired logs.
private long subappend ( iloggingevent event , sqlitestatement insertstatement ) throws sqlexception { bindloggingevent ( insertstatement , event ) ; bindloggingeventarguments ( insertstatement , event . getargumentarray ( ) ) ;	Inserts the main details of a log event into the database.
private void secondarysubappend ( iloggingevent event , long eventid ) throws sqlexception { map < string , string > mergedmap = mergepropertymaps ( event ) ; insertproperties ( mergedmap , eventid ) ; if ( event . getthrowableproxy ( ) != null ) { insertthrowable ( event . getthrowableproxy ( ) , eventid ) ; } }	Updates an existing row of an event with the secondary details of the event.This includes MDC properties and any exception information.
private void bindloggingevent ( sqlitestatement stmt , iloggingevent event ) throws sqlexception { stmt . bindlong ( timestmp_index , event . gettimestamp ( ) ) ; stmt . bindstring ( formatted_message_index , event . getformattedmessage ( ) ) ; stmt . bindstring ( logger_name_index , event . getloggername ( ) ) ; stmt . bindstring ( level_string_index , event . getlevel ( ) . tostring ( ) ) ; stmt . bindstring ( thread_name_index , event . getthreadname ( ) ) ; stmt . bindlong ( reference_flag_index , computereferencemask ( event ) ) ; }	Binds the main details of a log event to a SQLite statement's parameters.
private string asstringtruncatedto254 ( object o ) { string s = null ; if ( o != null ) { s = o . tostring ( ) ; } if ( s != null && s . length ( ) > num_ ) { s = s . substring ( num_ , num_ ) ; } return s == null ? str_ : s ; }	Gets the first 254 characters of an object's string representation.
private static short computereferencemask ( iloggingevent event ) { short mask = num_ ; int mdcpropsize = num_ ; if ( event . getmdcpropertymap ( ) != null ) { mdcpropsize = event . getmdcpropertymap ( ) . keyset ( ) . size ( ) ; } int contextpropsize = num_ ; if ( event . getloggercontextvo ( ) . getpropertymap ( ) != null ) { contextpropsize = event . getloggercontextvo ( ) . getpropertymap ( ) . size ( ) ; } if ( mdcpropsize > num_ || contextpropsize > num_ ) { mask = properties_exist ; } if ( event . getthrowableproxy ( ) != null ) { mask |= exception_exists ; } return mask ; }	Computes the reference mask for a logging event, includingflags to indicate whether MDC properties or exception infois available for the event.
private map < string , string > mergepropertymaps ( iloggingevent event ) { map < string , string > mergedmap = new hashmap < string , string > ( ) ;	Merges a log event's properties with the properties of the logger context.The context properties are first in the map, and then the event's propertiesare appended.
private void insertexception ( sqlitestatement stmt , string txt , short i , long eventid ) throws sqlexception { stmt . bindlong ( num_ , eventid ) ; stmt . bindlong ( num_ , i ) ; stmt . bindstring ( num_ , txt ) ; stmt . executeinsert ( ) ; }	Inserts an exception into the logging_exceptions table.
public int getprefixmatchlength ( elementpath p ) { if ( p == null ) { return num_ ; } int lsize = this . partlist . size ( ) ; int rsize = p . partlist . size ( ) ;	Returns the number of "prefix" components that this pattern has in commonwith the pattern p passed as parameter.
public synchronized int geteffectivelevel ( ) { int result = level ; int efflevel ; iterator it = iterator ( ) ; status s ; while ( it . hasnext ( ) ) { s = ( status ) it . next ( ) ; efflevel = s . geteffectivelevel ( ) ; if ( efflevel > result ) { result = efflevel ; } } return result ; }	different status objects lying on the same cycle.
private boolean isunequivocallyinstantiable ( class < ? > clazz ) { if ( clazz . isinterface ( ) ) { return bool_ ; }	Can the given clazz instantiable with certainty?.
@ override protected hashmap < string , string > childvalue ( hashmap < string , string > parentvalue ) { if ( parentvalue == null ) { return null ; } else { return new hashmap < string , string > ( parentvalue ) ; } }	Child threads should get a copy of the parent's hashmap.
@ override protected void processinclude ( interpretationcontext ic , url url ) throws joranexception { inputstream in = openurl ( url ) ; try { if ( in != null ) {	Processes an include.
private inputstream openurl ( url url ) { try { return url . openstream ( ) ; } catch ( ioexception e ) { optionalwarning ( str_ + url . tostring ( ) + str_ , e ) ; return null ; } }	Opens the given URL, logging any exceptions.
private void trimheadandtail ( saxeventrecorder recorder ) { list < saxevent > saxeventlist = recorder . getsaxeventlist ( ) ; if ( saxeventlist . size ( ) == num_ ) { return ; } boolean includedtagfound = bool_ ; boolean configtagfound = bool_ ;	Removes the head tag and tail tag if they are named either"included" or "configuration".
protected boolean shouldstart ( ) { serversocket serversocket = null ; try { serversocket = getserversocketfactory ( ) . createserversocket ( getport ( ) , getbacklog ( ) , getinetaddress ( ) ) ; serverlistener < remoteappenderclient > listener = createserverlistener ( serversocket ) ; runner = createserverrunner ( listener , getcontext ( ) . getscheduledexecutorservice ( ) ) ; runner . setcontext ( getcontext ( ) ) ; return bool_ ; } catch ( exception ex ) { adderror ( str_ + ex , ex ) ; closeutil . closequietly ( serversocket ) ; return bool_ ; } }	Starts the server.
public boolean istransient ( ) { throwable cause = getcause ( ) ; if ( cause == null ) { return isservererror ( statuscode ) ; } else if ( cause instanceof algoliaexception ) { return ( ( algoliaexception ) cause ) . istransient ( ) ; } else if ( cause instanceof ioexception ) { return bool_ ; } else { return bool_ ; } }	Test whether this error is transient.
private void setdefaulthosts ( ) { list < string > fallbackhosts = arrays . aslist ( str_ , str_ , str_ ) ; collections . shuffle ( fallbackhosts ) ; list < string > hosts = new arraylist < > ( fallbackhosts . size ( ) + num_ ) ; hosts . add ( str_ ) ; hosts . addall ( fallbackhosts ) ; string [ ] hostsarray = hosts . toarray ( new string [ hosts . size ( ) ] ) ; setreadhosts ( hostsarray ) ; setwritehosts ( hostsarray ) ; }	Set the default hosts for Algolia Places.
private synchronized void ensurelocalindex ( ) { if ( localindex == null ) { localindex = new localindex ( getclient ( ) . getrootdatadir ( ) . getabsolutepath ( ) , getclient ( ) . getapplicationid ( ) , getrawindexname ( ) ) ; } }	Lazy instantiate the local index.
public void sync ( ) { if ( getdataselectionqueries ( ) . length == num_ ) { throw new illegalstateexception ( str_ ) ; } synchronized ( this ) { if ( syncing ) return ; syncing = bool_ ; } getclient ( ) . localbuildexecutorservice . submit ( new runnable ( ) { @ override public void run ( ) { _sync ( ) ; } } ) ; }	Launch a sync.If a sync is already running, this call is ignored.
public void syncifneeded ( ) { long currentdate = system . currenttimemillis ( ) ; if ( currentdate - mirrorsettings . getlastsyncdate ( ) . gettime ( ) > delaybetweensyncs || mirrorsettings . getqueriesmodificationdate ( ) . compareto ( mirrorsettings . getlastsyncdate ( ) ) > num_ ) { sync ( ) ; } }	Launch a sync only if the data is obsolete.The data is obsolete if the last successful sync is older than the delay between syncs, or if the data selectionqueries have been changed in the meantime.
public jsonobject waittask ( string taskid , long timetowait ) throws algoliaexception { try { while ( bool_ ) { jsonobject obj = client . getrequest ( str_ + encodedindexname + str_ + urlencoder . encode ( taskid , str_ ) , null , bool_ , null ) ; if ( obj . getstring ( str_ ) . equals ( str_ ) ) { return obj ; } try { thread . sleep ( timetowait >= max_time_ms_to_wait ? max_time_ms_to_wait : timetowait ) ; } catch ( interruptedexception e ) { continue ; } final long newtimeout = timetowait * num_ ; timetowait = ( newtimeout <= num_ || newtimeout >= max_time_ms_to_wait ) ? max_time_ms_to_wait : newtimeout ; } } catch ( jsonexception e ) { throw new algoliaexception ( e . getmessage ( ) ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }	Wait the publication of a task on the server.All server task are asynchronous and you can check with this method that the task is published.
private jsonobject listindexesofflinesync ( ) throws algoliaexception { try { final string rootdatapath = getrootdatadir ( ) . getabsolutepath ( ) ; final file appdir = getappdir ( ) ; final file [ ] directories = appdir . listfiles ( new filefilter ( ) { @ override public boolean accept ( file pathname ) { return pathname . isdirectory ( ) ; } } ) ; jsonobject response = new jsonobject ( ) ; jsonarray items = new jsonarray ( ) ; if ( directories != null ) { for ( file directory : directories ) { final string name = directory . getname ( ) ; if ( hasofflinedata ( name ) ) { items . put ( new jsonobject ( ) . put ( str_ , name ) ) ;	List existing offline indices.**Note:** This applies both to {.
private static string _tochararray ( inputstream stream ) throws ioexception { inputstreamreader is = new inputstreamreader ( stream , str_ ) ; stringbuilder builder = new stringbuilder ( ) ; char [ ] buf = new char [ num_ ] ; int l = num_ ; while ( l >= num_ ) { builder . append ( buf , num_ , l ) ; l = is . read ( buf ) ; } is . close ( ) ; return builder . tostring ( ) ; }	Reads the InputStream as UTF-8.
private static byte [ ] _tobytearray ( inputstream stream ) throws algoliaexception { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; int read ; byte [ ] buffer = new byte [ num_ ] ; try { while ( ( read = stream . read ( buffer , num_ , buffer . length ) ) != - num_ ) { out . write ( buffer , num_ , read ) ; } out . flush ( ) ; return out . tobytearray ( ) ; } catch ( ioexception e ) { throw new algoliaexception ( str_ + e . getmessage ( ) ) ; } }	Reads the InputStream into a byte array.
private static void consumequietly ( final httpurlconnection connection ) { try { int read = num_ ; while ( read != - num_ ) { read = connection . getinputstream ( ) . read ( ) ; } connection . getinputstream ( ) . close ( ) ; read = num_ ; while ( read != - num_ ) { read = connection . geterrorstream ( ) . read ( ) ; } connection . geterrorstream ( ) . close ( ) ; connection . disconnect ( ) ; } catch ( ioexception e ) {	Ensures that the entity content is fully consumed and the content stream, if exists,is closed.
private list < string > hoststhatareup ( list < string > hosts ) { list < string > uphosts = new arraylist < > ( ) ; for ( string host : hosts ) { if ( isuporcouldberetried ( host ) ) { uphosts . add ( host ) ; } } return uphosts . isempty ( ) ? hosts : uphosts ; }	Get the hosts that are not considered down in a given list.
public @ nonnull placesquery settype ( type type ) { if ( type == null ) { set ( key_type , null ) ; } else { switch ( type ) { case city : set ( key_type , str_ ) ; break ; case country : set ( key_type , str_ ) ; break ; case address : set ( key_type , str_ ) ; break ; case bus_stop : set ( key_type , str_ ) ; break ; case train_station : set ( key_type , str_ ) ; break ; case town_hall : set ( key_type , str_ ) ; break ; case airport : set ( key_type , str_ ) ; break ; } } return this ; }	Set the type of place to search for.
public void start ( ) { if ( started ) { throw new illegalstateexception ( ) ; } started = bool_ ; request = index . browseasync ( query , requestoptions , completionhandler ) ; }	Start the iteration.
public v put ( k key , v value ) { v previous = null ; synchronized ( this ) { long timeout = system . currenttimemillis ( ) + timeunit . milliseconds . convert ( expirationtimeout , expirationtimeunit ) ; final pair < v , long > previouspair = lrucache . put ( key , new pair < > ( value , timeout ) ) ; if ( previouspair != null ) { previous = previouspair . first ; } } return previous ; }	Puts a value in the cache, computing an expiration time.
synchronized public v get ( k key ) { final pair < v , long > cachepair = lrucache . get ( key ) ; if ( cachepair != null && cachepair . first != null ) { if ( cachepair . second > system . currenttimemillis ( ) ) { return cachepair . first ; } else { lrucache . remove ( key ) ; } } return null ; }	Get a value from the cache.
public void awaitcompletion ( ) { for ( thread thread : threads ) { try { thread . join ( ) ; } catch ( interruptedexception e ) { throw rethrow ( e ) ; } } if ( caughtexception != null ) { throw rethrow ( caughtexception ) ; } }	Waits for all threads to finish.If {.
public static void report ( string testid , throwable cause ) { if ( cause == null ) { logger . fatal ( str_ ) ; return ; } long exceptioncount = failure_id . incrementandget ( ) ; if ( exceptioncount > max_exception_count ) { logger . warn ( str_ + exceptioncount + str_ + str_ , cause ) ; return ; } logger . warn ( str_ + exceptioncount + str_ , cause ) ; string targetfilename = exceptioncount + str_ ; file dir = getuserdir ( ) ; file tmpfile = new file ( dir , targetfilename + str_ ) ; try { if ( ! tmpfile . createnewfile ( ) ) { throw new ioexception ( str_ + tmpfile . getabsolutepath ( ) ) ; } } catch ( ioexception e ) { logger . fatal ( str_ , e ) ; return ; } writetext ( testid + new_line + throwabletostring ( cause ) , tmpfile ) ; file file = new file ( dir , targetfilename ) ; logger . info ( file . getabsolutepath ( ) ) ; rename ( tmpfile , file ) ; }	Writes the cause to file.
public static void copydirectory ( file src , file target ) { checknotnull ( src , str_ ) ; checknotnull ( target , str_ ) ; file [ ] files = src . listfiles ( ) ; if ( files == null ) { return ; } for ( file srcfile : files ) { if ( srcfile . isdirectory ( ) ) { file targetchild = new file ( target , srcfile . getname ( ) ) ; ensureexistingdirectory ( targetchild ) ; copydirectory ( srcfile , targetchild ) ; } else { copyfiletodirectory ( srcfile , target ) ; } } }	Copies a directory recursively.
public simulatorproperties init ( file file ) { if ( file == null ) {	Initializes the SimulatorProperties with additional properties.
public static < e > e getstaticfieldvalue ( class clazz , string fieldname , class fieldtype ) { field field = getfield ( clazz , fieldname , fieldtype ) ; if ( field == null ) { throw new reflectionexception ( format ( str_ , clazz . getname ( ) , fieldname ) ) ; } field . setaccessible ( bool_ ) ; return getfieldvalue0 ( null , field , clazz . getname ( ) , fieldname ) ; }	Gets the value for a static field.
public static method getmethodbyname ( class clazz , string methodname ) { for ( method method : clazz . getdeclaredmethods ( ) ) { if ( method . getname ( ) . equals ( methodname ) ) { return method ; } } return null ; }	Searches a method by name.
public static string formatpercentage ( long value , long basevalue ) { double percentage = ( basevalue > num_ ? ( one_hundred * value ) / basevalue : num_ ) ; return formatdouble ( percentage , percentage_format_length ) ; }	Formats a percentage of two numbers and adds padding to the left.
public static string formatdouble ( double number , int length ) { return padleft ( format ( locale . us , str_ , number ) , length ) ; }	Formats a double number and adds padding to the left.Very inefficient implementation, but a lot easier than to deal with the formatting API.
public static string formatlong ( long number , int length ) { return padleft ( format ( locale . us , str_ , number ) , length ) ; }	Formats a long number and adds padding to the left.Very inefficient implementation, but a lot easier than to deal with the formatting API.
private void writejsonstring ( byte [ ] b ) throws ioexception { context . write ( ) ; transport . write ( quote ) ; int len = b . length ; for ( int i = num_ ; i < len ; i ++ ) { if ( ( b [ i ] & num_ ) >= num_ ) { if ( b [ i ] == backslash [ num_ ] ) { transport . write ( backslash ) ; transport . write ( backslash ) ; } else { transport . write ( b , i , num_ ) ; } } else { tmpbuf [ num_ ] = json_char_table [ b [ i ] ] ; if ( tmpbuf [ num_ ] == num_ ) { transport . write ( b , i , num_ ) ; } else if ( tmpbuf [ num_ ] > num_ ) { transport . write ( backslash ) ; transport . write ( tmpbuf , num_ , num_ ) ; } else { transport . write ( escseq ) ; tmpbuf [ num_ ] = hexchar ( ( byte ) ( b [ i ] > > num_ ) ) ; tmpbuf [ num_ ] = hexchar ( b [ i ] ) ; transport . write ( tmpbuf , num_ , num_ ) ; } } } transport . write ( quote ) ; }	Write the bytes in array buf as a Json characters, escaping as needed.
private void writejsoninteger ( long num ) throws ioexception { context . write ( ) ; string str = long . tostring ( num ) ; boolean escapenum = context . escapenum ( ) ; if ( escapenum ) { transport . write ( quote ) ; } try { byte [ ] buf = str . getbytes ( str_ ) ; transport . write ( buf ) ; } catch ( unsupportedencodingexception e ) { throw new assertionerror ( e ) ; } if ( escapenum ) { transport . write ( quote ) ; } }	wrapped in quotes to output as a Json string.
private void writejsondouble ( double num ) throws ioexception { context . write ( ) ; string str = double . tostring ( num ) ; boolean special = bool_ ; switch ( str . charat ( num_ ) ) { case str_ :	context dictates escaping, write out as Json string.
private string readjsonnumericchars ( ) throws ioexception { stringbuilder strbld = new stringbuilder ( ) ; while ( bool_ ) { byte ch = reader . peek ( ) ; if ( ! isjsonnumeric ( ch ) ) { break ; } strbld . append ( ( char ) reader . read ( ) ) ; } return strbld . tostring ( ) ; }	not do a complete regex check to validate that this is actually a number.
private long readjsoninteger ( ) throws ioexception { context . read ( ) ; if ( context . escapenum ( ) ) { readjsonsyntaxchar ( quote ) ; } string str = readjsonnumericchars ( ) ; if ( context . escapenum ( ) ) { readjsonsyntaxchar ( quote ) ; } try { return long . valueof ( str ) ; } catch ( numberformatexception ex ) { throw new protocolexception ( str_ ) ; } }	Read in a Json number.
private double readjsondouble ( ) throws ioexception { context . read ( ) ; if ( reader . peek ( ) == quote [ num_ ] ) { bytestring str = readjsonstring ( bool_ ) ; double dub = double . valueof ( str . utf8 ( ) ) ; if ( ! context . escapenum ( ) && ! double . isnan ( dub ) && ! double . isinfinite ( dub ) ) {	when expected or if wrapped in quotes when not expected.
private bytestring readjsonbase64 ( ) throws ioexception { bytestring str = readjsonstring ( bool_ ) ; return bytestring . decodebase64 ( str . utf8 ( ) ) ; }	Read in a Json string containing base-64 encoded data and decode it.
protected final object execute ( methodcall < ? > methodcall ) throws exception { if ( ! running . get ( ) ) { throw new illegalstateexception ( str_ ) ; } try { return invokerequest ( methodcall ) ; } catch ( serverexception e ) { throw e . thriftexception ; } }	When invoked by a derived instance, sends the given call to the server.
final object invokerequest ( methodcall < ? > call ) throws exception { boolean isoneway = call . calltypeid == tmessagetype . oneway ; int sid = seqid . incrementandget ( ) ; protocol . writemessagebegin ( call . name , call . calltypeid , sid ) ; call . send ( protocol ) ; protocol . writemessageend ( ) ; protocol . flush ( ) ; if ( isoneway ) {	Send the given call to the server.
protected void enqueue ( methodcall < ? > methodcall ) { if ( ! running . get ( ) ) { throw new illegalstateexception ( str_ ) ; } if ( ! pendingcalls . offer ( methodcall ) ) {	When invoked by a derived instance, places the given call in a queue tobe sent to the server.
public static ifile getresourcefromfspath ( string location ) { return activator . getdefault ( ) . getworkspace ( ) . getroot ( ) . getfileforlocation ( new path ( location ) ) ; }	Resolves a file system location to an Eclipse workspace resource.
public static void updatedecoration ( ) { final iworkbench workbench = activator . getdefault ( ) . getworkbench ( ) ; workbench . getdisplay ( ) . syncexec ( new runnable ( ) { public void run ( ) { idecoratormanager manager = workbench . getdecoratormanager ( ) ; manager . update ( guvnordecorator . decorator_id ) ; } } ) ; }	Causes the platform to update Guvnor decoration notions.
public static void refreshrepositoryview ( ) { iworkbenchwindow activewindow = activator . getdefault ( ) . getworkbench ( ) . getactiveworkbenchwindow ( ) ;	Causes the Repository view to refresh, if it is open.
public static resourcehistoryview getresourcehistoryview ( ) throws exception { iworkbenchwindow activewindow = activator . getdefault ( ) . getworkbench ( ) . getactiveworkbenchwindow ( ) ;	Tries to find the Resource History view, attempting to open it if necessary.
public static void openeditor ( string contents , string name ) { iworkbenchwindow window = platformui . getworkbench ( ) . getactiveworkbenchwindow ( ) ; istorage storage = new stringstorage ( contents , name ) ; istorageeditorinput input = new stringinput ( storage ) ; iworkbenchpage page = window . getactivepage ( ) ; ieditordescriptor desc = platformui . getworkbench ( ) . geteditorregistry ( ) . getdefaulteditor ( name ) ;	Opens a read-only, in-memory editor.
public static void reportauthenticationfailure ( ) { display display = platformui . getworkbench ( ) . getdisplay ( ) ; display . asyncexec ( new runnable ( ) { public void run ( ) { display display = display . getcurrent ( ) ; shell shell = display . getactiveshell ( ) ; messagedialog . openerror ( shell , messages . getstring ( str_ ) ,	Convenience method for reporting log in failure.
public authpromptresults promptforauthentication ( final string server ) { display display = platformui . getworkbench ( ) . getdisplay ( ) ; authpromptrunnable op = new authpromptrunnable ( server ) ; display . syncexec ( op ) ; return op . getresults ( ) ; }	Prompts for user name and password for a given Guvnor repository.
private control createdefaultpage ( formtoolkit kit ) { form form = kit . createform ( book ) ; composite body = form . getbody ( ) ; gridlayout layout = new gridlayout ( num_ , bool_ ) ; body . setlayout ( layout ) ; link hlink = new link ( body , swt . none ) ; hlink . settext ( str_ ) ; hlink . setbackground ( book . getdisplay ( ) . getsystemcolor ( swt . color_list_background ) ) ; griddata gd = new griddata ( swt . left , swt . fill , bool_ , bool_ ) ; hlink . setlayoutdata ( gd ) ; hlink . addselectionlistener ( new selectionadapter ( ) { public void widgetselected ( selectionevent e ) {	Creates a page displayed when there are no servers defined.
protected void startthread ( ) { if ( animationactive ) return ; stopanimation = bool_ ; final display display = treeviewer == null ? display . getdefault ( ) : treeviewer . getcontrol ( ) . getdisplay ( ) ; final int sleep = num_ ; final runnable [ ] animator = new runnable [ num_ ] ; animator [ num_ ] = new runnable ( ) { public void run ( ) { if ( ! stopanimation ) { try { int size = num_ ; string [ ] servers ; synchronized ( starting ) { size = starting . size ( ) ; servers = new string [ size ] ; starting . toarray ( servers ) ; } for ( int i = num_ ; i < size ; i ++ ) { iserver server = servercore . findserver ( servers [ i ] ) ; if ( server != null ) {	Start the animation thread.
public void setiskeepallalive ( boolean iskeepallalive ) { element child = getfirstchild ( root , childnames ) ; boolean isalreadykeepallalive = bool_ ; if ( isdavelement ( child , str_ ) )	Sets whether this propertybehavior is in the "keep all alive" form ornot.
public void setisomit ( boolean isomit ) { element child = getfirstchild ( root , childnames ) ; boolean isalreadyomit = isdavelement ( child , str_ ) ;	Sets whether this propertybehavior is in the "omit" form or not.
public owner setowner ( ) { element owner = setchild ( root , str_ , childnames , bool_ ) ;	Creates and sets an owner element on this activelock and returns aneditor on it.
public void addconditionfactor ( conditionfactor factor ) throws webdavexception { if ( conditionfactors . contains ( factor ) ) throw new webdavexception ( iresponse . sc_bad_request , policy . bind ( str_ ) ) ;	Add a ConditionFactor to a ConditionTerm.
public static conditionterm create ( streamtokenizer tokenizer ) throws webdavexception { conditionterm term = new conditionterm ( ) ; try { int token = tokenizer . ttype ; if ( token == str_ ) token = tokenizer . nexttoken ( ) ; else throw new webdavexception ( iresponse . sc_bad_request , policy . bind ( str_ , string . valueof ( token ) , str_ ) ) ;	Create a ConditionTerm by parsing the given If header as defined bysection 9.4 in the WebDAV spec.
public boolean matches ( conditionterm conditionterm ) { int numberofitemstomatch = num_ ; boolean match = bool_ ; enumeration factors = getconditionfactors ( ) ; while ( match && factors . hasmoreelements ( ) ) { conditionfactor factor = ( conditionfactor ) factors . nextelement ( ) ; if ( factor . not ( ) ) { match = ! conditionterm . contains ( factor ) ; } else { match = conditionterm . contains ( factor ) ; numberofitemstomatch ++ ; } } match = match && numberofitemstomatch == conditionterm . numberoffactors ( ) ; return match ; }	See if this ConditionTerm matches the given ConditionTerm.
public static reader getdslcontent ( string rulesource , iresource input ) throws coreexception { string dslfilename = finddslconfigname ( rulesource , input ) ; if ( dslfilename == null ) { return null ; } iresource res = finddslresource ( input , dslfilename ) ; if ( res instanceof ifile ) { ifile dslconf = ( ifile ) res ; if ( dslconf . exists ( ) ) { return new inputstreamreader ( dslconf . getcontents ( ) ) ; } } return null ; }	Get a reader to the DSL contents.
private void loadconfig ( ifile input ) { iresource res = finddslresource ( input , dslconfigname ) ; if ( res instanceof ifile ) { ifile dslconf = ( ifile ) res ; if ( dslconf . exists ( ) ) { inputstream stream = null ; try { stream = dslconf . getcontents ( ) ; readconfig ( stream ) ; valid = bool_ ; } catch ( exception e ) { throw new illegalstateexception ( str_ + e . getmessage ( ) + str_ ) ; } finally { closestream ( stream ) ; } } } }	This does the hunting around the projec to find the .dsl file.
void readconfig ( inputstream stream ) throws ioexception , coreexception { dsltokenizedmappingfile file = new dsltokenizedmappingfile ( ) ; file . parseandload ( new inputstreamreader ( stream ) ) ; dslmapping grammar = file . getmapping ( ) ; list < dslmappingentry > conditions = grammar . getentries ( dslmappingentry . condition ) ; list < dslmappingentry > consequences = grammar . getentries ( dslmappingentry . consequence ) ; conditionproposals = buildproposals ( conditions ) ; consequenceproposals = buildproposals ( consequences ) ; dsltree . buildtree ( grammar ) ; }	This will load in the DSL config file, using the DSLMapping from drools-compiler.
public menu getmenu ( control parent ) { setmenu ( new menu ( parent ) ) ; final shell shell = parent . getshell ( ) ; addprojectwizard ( menu , shell ) ; addrulewizard ( menu , shell ) ; adddslwizard ( menu , shell ) ; adddtwizard ( menu , shell ) ; return menu ; }	Return a menu which launches the various wizards.
public responsebody addresponse ( ) { element response = addchild ( root , str_ , childnames , bool_ ) ;	Creates and adds a response element to this multistatus and returnsan editor on it.
public void addhref ( string href ) { string encodedhref = encodehref ( href ) ; if ( isduplicate ( encodedhref ) ) return ; appendchild ( root , str_ , encodedhref ) ;	Adds the given href to the end of the set of hrefs.
public void inserthrefbefore ( string newhref , string refhref ) { string refhrefencoded = encodehref ( refhref ) ; string newhrefencoded = encodehref ( newhref ) ; if ( isduplicate ( newhrefencoded ) ) return ; element child = getfirstchild ( root , str_ ) ;	Inserts the given newHref before the given refHref in the set ofhrefs.
public void removehref ( string href ) { string encodedhref = encodehref ( href ) ; element child = getfirstchild ( root , str_ ) ;	Remove the given href from the set of hrefs.
public propstat addpropstat ( ) { element firsthref = getfirstchild ( root , str_ ) ;	Creates and adds a propstat element on this response and returns aneditor on it.
public string gethref ( ) throws malformedelementexception { string href = getchildtext ( root , str_ , bool_ ) ;	Returns this response's first href.
public string getstatus ( ) throws malformedelementexception { element status = getfirstchild ( root , str_ ) ;	Returns this response's status.
public static ijavastackframe getstackframe ( ivalue value ) throws coreexception { istatushandler handler = getstackframeprovider ( ) ; if ( handler != null ) { ijavastackframe stackframe = ( ijavastackframe ) handler . handlestatus ( fgneedstackframe , value ) ; if ( stackframe != null ) { return stackframe ; } } idebugtarget target = value . getdebugtarget ( ) ; ijavadebugtarget javatarget = ( ijavadebugtarget ) target . getadapter ( ijavadebugtarget . class ) ; if ( javatarget != null ) { ithread [ ] threads = javatarget . getthreads ( ) ; for ( int i = num_ ; i < threads . length ; i ++ ) { ithread thread = threads [ i ] ; if ( thread . issuspended ( ) ) { return ( ijavastackframe ) thread . gettopstackframe ( ) ; } } } return null ; }	Return the current stack frame context, or a valid stack frame for thegiven value.
private boolean issubtypeof ( string class1 , string class2 ) { if ( class1 == null || class2 == null ) { return bool_ ; } class1 = converttononprimitiveclass ( class1 ) ; class2 = converttononprimitiveclass ( class2 ) ;	Returns true if the first class is the same or a subtype of the secondclass.
public static boolean containsproposal ( final collection < icompletionproposal > proposals , string newproposal ) { for ( icompletionproposal prop : proposals ) { string displaystring = prop . getdisplaystring ( ) ; string [ ] existings = displaystring . split ( str_ ) ; if ( existings . length == num_ ) { continue ; } string [ ] newproposals = newproposal . split ( str_ ) ; if ( newproposals . length == num_ ) { continue ; } if ( existings [ num_ ] . equals ( newproposals [ num_ ] ) ) { return bool_ ; } } return bool_ ; }	Attempt to compare proposals of different types based on the tokenized display string.
public void reset ( ) throws ioexception { if ( file == null ) { ( ( bytearrayinputstream ) is ) . reset ( ) ; } else { if ( fos != null ) { while ( skip ( num_ ) > num_ ) ; fos . close ( ) ; fos = null ; if ( length == - num_ ) { length = totalbytesread ; } } is . close ( ) ; is = new fileinputstream ( file ) ; } totalbytesread = num_ ; }	Resets the stream to its beginning so it can be read again.
protected void createactions ( ) { super . createactions ( ) ; iaction a = new textoperationaction ( ruleeditormessages . getresourcebundle ( ) , str_ , this , isourceviewer . contentassist_proposals ) ; a . setactiondefinitionid ( itexteditoractiondefinitionids . content_assist_proposals ) ; setaction ( str_ , a ) ; a = new textoperationaction ( ruleeditormessages . getresourcebundle ( ) , str_ , this , isourceviewer . contentassist_context_information ) ;	For user triggered content assistance.
public void addconnection ( connection conn ) { if ( conn == null || conn . getsource ( ) == conn . gettarget ( ) ) { throw new illegalargumentexception ( ) ; } if ( conn . getsource ( ) == this ) { sourceconnections . add ( conn ) ; firepropertychange ( source_connections_prop , null , conn ) ; } else if ( conn . gettarget ( ) == this ) { targetconnections . add ( conn ) ; firepropertychange ( target_connections_prop , null , conn ) ; } }	Add an incoming or outgoing connection to this vertex.
public object getpropertyvalue ( object propertyid ) { if ( xpos_prop . equals ( propertyid ) ) { return integer . tostring ( location . x ) ; } if ( ypos_prop . equals ( propertyid ) ) { return integer . tostring ( location . y ) ; } if ( height_prop . equals ( propertyid ) ) { return integer . tostring ( size . height ) ; } if ( width_prop . equals ( propertyid ) ) { return integer . tostring ( size . width ) ; } return null ; }	Return the property value for the given propertyId, or null.
public void removeconnection ( connection conn ) { if ( conn == null ) { throw new illegalargumentexception ( ) ; } if ( conn . getsource ( ) == this ) { sourceconnections . remove ( conn ) ; firepropertychange ( source_connections_prop , null , conn ) ; } else if ( conn . gettarget ( ) == this ) { targetconnections . remove ( conn ) ; firepropertychange ( target_connections_prop , null , conn ) ; } }	Remove an incoming or outgoing connection from this vertex.
public void setlocation ( point newlocation ) { if ( newlocation == null ) { throw new illegalargumentexception ( ) ; } location . setlocation ( newlocation ) ; firepropertychange ( location_prop , null , location ) ; }	Set the Location of this vertex.
public void setpropertyvalue ( object propertyid , object value ) { if ( xpos_prop . equals ( propertyid ) ) { int x = integer . parseint ( ( string ) value ) ; setlocation ( new point ( x , location . y ) ) ; } else if ( ypos_prop . equals ( propertyid ) ) { int y = integer . parseint ( ( string ) value ) ; setlocation ( new point ( location . x , y ) ) ; } else if ( height_prop . equals ( propertyid ) ) { int height = integer . parseint ( ( string ) value ) ; setsize ( new dimension ( size . width , height ) ) ; } else if ( width_prop . equals ( propertyid ) ) { int width = integer . parseint ( ( string ) value ) ; setsize ( new dimension ( width , size . height ) ) ; } }	Set the property value for the given property id.
public void setsize ( dimension newsize ) { if ( newsize != null ) { size . setsize ( newsize ) ; firepropertychange ( size_prop , null , size ) ; } }	Set the Size of this vertex.Will not update the size if newSize is null.
public static string dumpconstraints ( final constraint [ ] constraints ) { if ( constraints == null ) { return null ; } final stringbuffer buffer = new stringbuffer ( ) ; for ( int i = num_ , length = constraints . length ; i < length ; i ++ ) { buffer . append ( constraints [ i ] . tostring ( ) + str_ ) ; } return buffer . tostring ( ) ; }	Constructs constraints string.
public lockentry addlockentry ( ) { element lockentry = addchild ( root , str_ , childnames , bool_ ) ;	Creates a new lockentry and adds it to this supported lock.
public boolean addchild ( basevertex vertex ) { if ( vertex != null && vertices . add ( vertex ) ) { firepropertychange ( prop_child_added , null , vertex ) ; return bool_ ; } return bool_ ; }	Add new BaseVertex to the graph.
public boolean removechild ( basevertex vertex ) { if ( vertex != null && vertices . remove ( vertex ) ) { firepropertychange ( prop_child_removed , null , vertex ) ; return bool_ ; } return bool_ ; }	Remove a vertex from this graph.
public void start ( bundlecontext context ) throws exception { super . start ( context ) ; ipreferencestore preferencestore = getpreferencestore ( ) ; usecachepreference = preferencestore . getboolean ( idroolsconstants . cache_parsed_rules ) ; preferencestore . addpropertychangelistener ( new ipropertychangelistener ( ) { public void propertychange ( propertychangeevent event ) { if ( idroolsconstants . cache_parsed_rules . equals ( event . getproperty ( ) ) ) { usecachepreference = ( ( boolean ) event . getnewvalue ( ) ) . booleanvalue ( ) ; if ( ! usecachepreference ) { clearcache ( ) ; } } } } ) ; }	This method is called upon plug-in activation.
public void stop ( bundlecontext context ) throws exception { super . stop ( context ) ; plugin = null ; resourcebundle = null ; parsedrules = null ; compiledrules = null ; processinfos = null ; processinfosbyid = null ; for ( color color : colors . values ( ) ) { color . dispose ( ) ; } }	This method is called when the plug-in is stopped.
public static string getresourcestring ( string key ) { resourcebundle bundle = droolseclipseplugin . getdefault ( ) . getresourcebundle ( ) ; try { return ( bundle != null ) ? bundle . getstring ( key ) : key ; } catch ( missingresourceexception e ) { return key ; } }	Returns the string from the plugin's resource bundle,or 'key' if not found.
public resourcebundle getresourcebundle ( ) { try { if ( resourcebundle == null ) resourcebundle = resourcebundle . getbundle ( str_ ) ; } catch ( missingresourceexception x ) { resourcebundle = null ; } return resourcebundle ; }	Returns the plugin's resource bundle,.
public formcolors getrulebuilderformcolors ( display display ) { if ( rulebuilderformcolors == null ) { rulebuilderformcolors = new formcolors ( display ) ; rulebuilderformcolors . markshared ( ) ; } return rulebuilderformcolors ; }	Form Colors, default colors for now.
public void setdatetime ( string date ) { string [ ] patterns = { rfc_1123_pattern , iso_8601_utc_pattern , iso_8601_utc_millis_pattern , iso_8601_pattern , iso_8601_millis_pattern , rfc_850_pattern , asctime_pattern } ; for ( int i = num_ ; i < patterns . length ; i ++ ) { if ( setdatetime ( date , patterns [ i ] ) ) break ; } }	Do nothing if date format is not supported.
protected boolean setdatetime ( string date , string pattern ) { boolean datechanged = bool_ ; dateformat . applypattern ( pattern ) ; try { setdatetime ( dateformat . parse ( date ) ) ; } catch ( parseexception e ) { datechanged = bool_ ; } return datechanged ; }	Do nothing if date format is not supported.
public static istatus error ( final string message , final throwable thr ) { return new status ( istatus . error , plugin_id , num_ , message , thr ) ; }	Utility to create an error status for this plug-in.
public static void logerror ( final string message , final throwable thr ) { getdefault ( ) . getlog ( ) . log ( error ( message , thr ) ) ; }	Utility method to log errors in the Egit plugin.
protected void addfield ( fieldeditor editor ) { if ( fields == null ) { fields = new arraylist < fieldeditor > ( ) ; }	Adds the given field editor to this page.
protected void adjustgridlayout ( ) { int numcolumns = calcnumberofcolumns ( ) ; ( ( gridlayout ) fieldeditorparent . getlayout ( ) ) . numcolumns = numcolumns ; if ( fields != null ) { for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { fieldeditor fieldeditor = fields . get ( i ) ; fieldeditor . fillintogrid ( fieldeditorparent , numcolumns ) ; } } }	Adjust the layout of the field editors so that they are properly aligned.
protected void applyfont ( ) { if ( fields != null ) { iterator < fieldeditor > e = fields . iterator ( ) ; while ( e . hasnext ( ) ) { fieldeditor pe = e . next ( ) ;	Applys the font to the field editors managed by this page.
private int calcnumberofcolumns ( ) { int result = num_ ; if ( fields != null ) { iterator < fieldeditor > e = fields . iterator ( ) ; while ( e . hasnext ( ) ) { fieldeditor pe = e . next ( ) ; result = math . max ( result , pe . getnumberofcontrols ( ) ) ; } } return result ; }	Calculates the number of columns needed to host all field editors.
protected void initialize ( ) { if ( fields != null ) { iterator < fieldeditor > e = fields . iterator ( ) ; while ( e . hasnext ( ) ) { fieldeditor pe = e . next ( ) ; pe . setpage ( this ) ; pe . setpropertychangelistener ( this ) ; pe . setpreferencestore ( getpreferencestore ( ) ) ; pe . load ( ) ; } } }	Initializes all field editors.
public void firepropertychangeevent ( object source , string name , object oldvalue , object newvalue ) { propertychangeevent event = new propertychangeevent ( source , name , oldvalue , newvalue ) ; object [ ] listeners = flisteners . getlisteners ( ) ; for ( int i = num_ ; i < listeners . length ; i ++ ) ( ( ipropertychangelistener ) listeners [ i ] ) . propertychange ( event ) ; }	Fires a property change event with the given source, property name, old and new value.
public void setactiveeditor ( ieditorpart part ) { super . setactiveeditor ( part ) ; if ( part instanceof drlruleeditor2 ) { drlruleeditor2 p = ( drlruleeditor2 ) part ; p . setzoomcombocontributionitem ( zitem ) ; p . setzoominaction ( zoomin ) ; p . setzoomoutaction ( zoomout ) ; } }	In addition to .
public void contributetotoolbar ( itoolbarmanager toolbarmanager ) { super . contributetotoolbar ( toolbarmanager ) ; toolbarmanager . add ( new separator ( ) ) ; string [ ] zoomstrings = new string [ ] { zoommanager . fit_all , zoommanager . fit_height , zoommanager . fit_width } ; zitem = new zoomcombocontributionitem ( getpage ( ) , zoomstrings ) ; zitem . setzoommanager ( null ) ; zitem . setvisible ( bool_ ) ; zoomin = new zoominaction2 ( ) ; zoomin . setenabled ( bool_ ) ; zoomout = new zoomoutaction2 ( ) ; zoomout . setenabled ( bool_ ) ; toolbarmanager . add ( zitem ) ; toolbarmanager . add ( zoomin ) ; toolbarmanager . add ( zoomout ) ; }	Adds Zoom-related contributions.
private void determinedialect ( string backtext ) { dialect = null ; boolean mvel = mvel_dialect_pattern . matcher ( backtext ) . matches ( ) ; boolean java = java_dialect_pattern . matcher ( backtext ) . matches ( ) ; if ( mvel ) { dialect = mvel_dialect ; } else if ( java ) { dialect = java_dialect ; } }	especially when parsing incomplete rules.
protected icontext newcontext ( icontext usercontext , ilocator locator ) throws malformedurlexception { assert . isnotnull ( usercontext ) ; assert . isnotnull ( locator ) ; icontext context = davfactory . newcontext ( usercontext ) ; if ( locator . getlabel ( ) != null ) context . setlabel ( locator . getlabel ( ) ) ; return context ; }	Returns a new context that is based on the given context.
public void dosave ( iprogressmonitor monitor ) { fileeditorinput input = ( fileeditorinput ) geteditorinput ( ) ; file outputfile = input . getfile ( ) . getlocation ( ) . tofile ( ) ; savefile ( monitor , outputfile , input ) ; }	for the sort field.
private void createtablelisteners ( ) {	Setup table listeners for GUI events.
public void put ( string url , object value ) throws malformedurlexception { assert . isnotnull ( url ) ; assert . isnotnull ( value ) ; put ( new url ( url ) , value ) ; }	Maps the given URL to the given value in this table.
private void put ( urlkey url , object value ) { assert . isnotnull ( url ) ; assert . isnotnull ( value ) ;	Maps the specified URL to the given value in this table.
public node addtoken ( string token ) { node newnode = new node ( token ) ;	The method will create a new Node instance and try to add it asa child node.
public node addchild ( node n ) { if ( ! this . children . containskey ( n . gettoken ( ) ) ) { this . children . put ( n . gettoken ( ) , n ) ; n . setparent ( this ) ; return n ; } else { return ( node ) this . children . get ( n . gettoken ( ) ) ; } }	The method will check to see if a Node with the same string tokenalready exists.
void setfile ( ifile file , int offset , int length ) { this . file = file ; this . offset = offset ; this . length = length ; }	be used directly. Use DroolsModelBuilder instead.
public void addcondition ( condition condition ) throws webdavexception {	Add a Condition to this Precondition.
public void addstatetokencondition ( string resourceuri , string statetoken ) throws webdavexception { condition condition = new condition ( resourceuri ) ; conditionterm term = new conditionterm ( ) ; term . addconditionfactor ( new statetoken ( statetoken ) ) ; condition . addconditionterm ( term ) ; addcondition ( condition ) ; }	Add a condition created from the given URI and state token.
public boolean matches ( condition condition ) { boolean match = bool_ ; enumeration conditions = getconditions ( ) ; while ( ! match && conditions . hasmoreelements ( ) ) { condition existingcondition = ( condition ) conditions . nextelement ( ) ; match = existingcondition . matches ( condition ) ; } return match ; }	See if this Precondition contains a matching Condition.
public prop getprop ( ) throws malformedelementexception { element prop = getfirstchild ( root , str_ ) ;	Returns this propstat's prop.
public string getstatus ( ) throws malformedelementexception { string status = getchildtext ( root , str_ , bool_ ) ;	Returns this propstat's status.
public prop setprop ( ) { element prop = setchild ( root , str_ , childnames , bool_ ) ;	Creates and sets a new prop on this propstat and returns an editor onit.
public string getlastline ( string backtext ) { bufferedreader breader = new bufferedreader ( new stringreader ( backtext ) ) ; string last = str_ ; string line = null ; try { while ( ( line = breader . readline ( ) ) != null ) {	because of how the backText works, we need to get the last line, so thatwe can pass it to the DSLUtility.
public string getlastnondashline ( string backtext ) { bufferedreader breader = new bufferedreader ( new stringreader ( backtext ) ) ; string last = str_ ; string line = null ; try { while ( ( line = breader . readline ( ) ) != null ) {	Returns the last line that doesn't start with a dash.
public static string bind ( string id , string binding ) { return bind ( id , new string [ ] { binding } ) ; }	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given string.
public static string bind ( string id , string binding1 , string binding2 ) { return bind ( id , new string [ ] { binding1 , binding2 } ) ; }	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given strings.
public static string bind ( string id , string [ ] bindings ) { if ( id == null ) return str_ ;	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given string values.
private void createprocess ( ijavaproject project , iprogressmonitor monitor , string exampletype ) throws coreexception , ioexception {	Create the sample process file.
private void createprocesssamplejunit ( ijavaproject project , string exampletype , iprogressmonitor monitor ) throws javamodelexception , ioexception { string s = str_ + exampletype + str_ ; iruntime runtime = startpage . getruntime ( ) ; if ( runtime . getversion ( ) . getmajor ( ) == num_ ) { s += str_ ; } else { s += str_ ; } ifolder folder = project . getproject ( ) . getfolder ( str_ ) ; ipackagefragmentroot packagefragmentroot = project . getpackagefragmentroot ( folder ) ; ipackagefragment packagefragment = packagefragmentroot . createpackagefragment ( str_ , bool_ , monitor ) ; inputstream inputstream = getclass ( ) . getclassloader ( ) . getresourceasstream ( s ) ; packagefragment . createcompilationunit ( str_ , new string ( fileutils . readstream ( inputstream ) ) , bool_ , monitor ) ; }	Create the sample process junit test file.
@ override public string getruntimeid ( ) { ipreferencestore store = org . kie . eclipse . activator . getdefault ( ) . getpreferencestore ( ) ; string value = store . getstring ( getkieversionpreferencekey ( ) ) ; return value ; }	Return the version number of the KIE Workbench that is installed on thegiven server.
public void visitrete ( final rete rete ) { this . rootvertex = ( retevertex ) this . visitednodes . get ( dotid ( rete ) ) ; if ( this . rootvertex == null ) { this . rootvertex = new retevertex ( rete ) ; this . visitednodes . put ( dotid ( rete ) , this . rootvertex ) ; } this . graph . addchild ( this . rootvertex ) ; this . parentvertex = this . rootvertex ; for ( entrypointnode node : rete . getentrypointnodes ( ) . values ( ) ) { visit ( node ) ; } }	Rete visits each of its ObjectTypeNodes.
private void visitnode ( final object node ) { object realnode = node ; if ( node instanceof objecthashmap . objectentry ) { objecthashmap . objectentry entry = ( objecthashmap . objectentry ) node ; realnode = entry . getvalue ( ) ; } visit ( realnode ) ; }	Helper method to ensure nodes are not visited more than once.
private static string dotid ( final object object ) { return integer . tohexstring ( system . identityhashcode ( object ) ) . touppercase ( ) ; }	The identity hashCode for the given object is used as its unique DOTidentifier.
public prop addremove ( ) { element remove = appendchild ( root , str_ ) ;	Adds a remove to the given propertyupdate and returns an editor onits prop.
public prop addset ( ) { element set = appendchild ( root , str_ ) ;	Adds a set to the given propertyupdate and returns an editor on itsprop.
public ilocator newlocator ( string resourceurl , string label ) { return locatorfactory . newlocator ( resourceurl , label ) ; }	Answer a new resource locator that identifies a particularserver resource by it's URL and label.
public ipresentationreconciler getpresentationreconciler ( isourceviewer sourceviewer ) { presentationreconciler reconciler = new presentationreconciler ( ) ;	Define reconciler - this has to be done for each partition.Currently there are 3 partitions, Inside rule, outside rule and inside comment.
public boolean sameas ( object obj ) { if ( obj == null || ! ( obj instanceof status ) ) return bool_ ; status other = ( status ) obj ; if ( other . code != code || ! other . message . equals ( message ) ) return bool_ ; return other . extendedstatus . equals ( extendedstatus ) ; }	Answers whether the receiver and the argument are consideredidentical.
public boolean contains ( conditionterm term ) {	Does this Condition contain the given ConditionTerm?.
public static conditionfactor create ( streamtokenizer tokenizer ) throws webdavexception { statetoken statetoken = new statetoken ( ) ; try { int token = tokenizer . ttype ; if ( token == str_ ) token = tokenizer . nexttoken ( ) ; else throw new webdavexception ( iresponse . sc_bad_request , policy . bind ( str_ , string . valueof ( token ) , str_ ) ) ;	Create a StateToken by parsing the given If header as defined bysection 9.4 in the WebDAV spec.
protected void addpages ( ) { try { texteditor = new drlruleeditor ( ) { public void close ( boolean save ) { super . close ( save ) ; drlruleeditor2 . this . close ( save ) ; } protected void setpartname ( string partname ) { super . setpartname ( partname ) ; drlruleeditor2 . this . setpartname ( partname ) ; } } ; reteviewer = new reteviewer ( texteditor ) ; int text = addpage ( texteditor , geteditorinput ( ) ) ; int rete = addpage ( reteviewer , geteditorinput ( ) ) ; setpagetext ( text , str_ ) ; setpagetext ( rete , str_ ) ; texteditor . getdocumentprovider ( ) . getdocument ( geteditorinput ( ) ) . adddocumentlistener ( new idocumentlistener ( ) { public void documentabouttobechanged ( documentevent event ) { } public void documentchanged ( documentevent event ) { reteviewer . firedocumentchanged ( ) ; } } ) ; } catch ( partinitexception e ) { droolseclipseplugin . log ( e ) ; } }	Adds Text Editor for rules and Rete graph viewer.
protected string httpdelete ( string request ) throws ioexception { string host = getkieresturl ( ) ; url url = new url ( host + str_ + request ) ; activator . println ( str_ + url . tostring ( ) ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setrequestmethod ( str_ ) ; conn . setrequestproperty ( str_ , str_ ) ; sethttpcredentials ( conn ) ; string response = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) . readline ( ) ; activator . println ( str_ + response ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_accepted ) { throw new ioexception ( str_ + conn . getresponsecode ( ) ) ; } jsonobject jo = jsonobject . readfrom ( response ) ; string status = jo . get ( str_ ) . asstring ( ) ; if ( status != null && ! status . isempty ( ) ) { if ( ! str_ . equals ( status ) ) throw new ioexception ( str_ + status ) ; } string jobid = jo . get ( str_ ) . asstring ( ) ; if ( jobid != null && ! jobid . isempty ( ) ) return jobid ; return response ; }	Send an HTTP DELETE request to the KIE console.
protected string httppost ( string request , jsonobject body ) throws ioexception , runtimeexception { string host = getkieresturl ( ) ; url url = new url ( host + str_ + request ) ; activator . println ( str_ + url . tostring ( ) + str_ + body ) ; httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( body != null ) ; conn . setrequestmethod ( str_ ) ; conn . setrequestproperty ( str_ , str_ ) ; sethttpcredentials ( conn ) ; if ( body != null ) { java . io . outputstream os = conn . getoutputstream ( ) ; writer writer = new outputstreamwriter ( os , str_ ) ; body . writeto ( writer ) ; writer . close ( ) ; os . flush ( ) ; } string response = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) . readline ( ) ; activator . println ( str_ + response ) ; if ( conn . getresponsecode ( ) != httpurlconnection . http_accepted ) { throw new ioexception ( str_ + conn . getresponsecode ( ) ) ; } jsonobject jo = jsonobject . readfrom ( response ) ; string status = jo . get ( str_ ) . asstring ( ) ; if ( status != null && ! status . isempty ( ) ) { if ( ! str_ . equals ( status ) ) throw new ioexception ( str_ + status ) ; } string jobid = jo . get ( str_ ) . asstring ( ) ; if ( jobid != null && ! jobid . isempty ( ) ) return jobid ; return response ; }	Send an HTTP POST request to the KIE console.
public string getjobstatus ( final string jobid , final string title ) throws ioexception , interruptedexception { final atomicreference < string > ar = new atomicreference < string > ( ) ; iworkbench wb = platformui . getworkbench ( ) ; iprogressservice ps = wb . getprogressservice ( ) ; try { ps . busycursorwhile ( new irunnablewithprogress ( ) { public void run ( iprogressmonitor pm ) throws interruptedexception { pm . begintask ( str_ + jobid + str_ + title , status_request_timeout ) ; pm . subtask ( title ) ; long starttime = system . currenttimemillis ( ) ; long stoptime = starttime ; do { try {	Sends a job status request to the KIE Server.
@ suppresswarnings ( str_ ) public void execute ( iprogressmonitor monitor ) { try { pulloperation . execute ( monitor ) ; results . putall ( pulloperation . getresults ( ) ) ; } catch ( coreexception e ) { if ( e . getstatus ( ) . getseverity ( ) == istatus . cancel ) results . putall ( pulloperation . getresults ( ) ) ; else reponode . handleexception ( ( throwable ) e ) ; } }	Starts this operation synchronously.
private void handlepullresults ( final map < repository , object > resultsmap ) { if ( taskstowaitfor . decrementandget ( ) == num_ && ! results . isempty ( ) ) showresults ( ) ; }	Post-process the pull results, allowing the user to deal with uncommittedchanges and re-pull if the initial pull failed because of these changes.
public jsonarray set ( int index , string value ) { values . set ( index , valueof ( value ) ) ; return this ; }	Replaces the element at the specified position in this array with the JSON representation ofthe specified string.
public activelock addactivelock ( ) { element activelock = addchild ( root , str_ , childnames , bool_ ) ;	Creates and adds a new activelock on this lockdiscovery and returnsan editor on it.
protected static void filterproposalsonprefix ( string prefix , list < icompletionproposal > props ) { if ( prefix != null && prefix . trim ( ) . length ( ) > num_ ) { iterator < icompletionproposal > iterator = props . iterator ( ) ; string prefixlc = prefix . tolowercase ( ) ; while ( iterator . hasnext ( ) ) { icompletionproposal item = iterator . next ( ) ; string content = item . getdisplaystring ( ) . tolowercase ( ) ; if ( ! content . tolowercase ( ) . startswith ( prefixlc ) ) { iterator . remove ( ) ; } } } }	Filter out the proposals whose content does not start with the given prefix.
protected string readbackwards ( int documentoffset , idocument doc ) throws badlocationexception { int startpart = doc . getpartition ( documentoffset ) . getoffset ( ) ; string prefix = doc . get ( startpart , documentoffset - startpart ) ; return prefix ; }	Read some text from behind the cursor position.This provides context to both filter what is shown basedon what the user has typed in, and also to provide more information for thelist of suggestions based on context.
public static rowlist calculatereterows ( basevertex root ) { rowlist rowlist = new rowlist ( ) ; rowlist . add ( num_ , root ) ; int currow = num_ ; final set < basevertex > seenvertices = new hashset < basevertex > ( ) ; seenvertices . add ( root ) ; while ( currow < rowlist . getdepth ( ) ) { final list < basevertex > rowvertices = rowlist . get ( currow ) . getvertices ( ) ; for ( final iterator < basevertex > rownodeiter = rowvertices . iterator ( ) ; rownodeiter . hasnext ( ) ; ) { final basevertex rownode = rownodeiter . next ( ) ; final list < connection > edges = rownode . getsourceconnections ( ) ; for ( final iterator < connection > edgeiter = edges . iterator ( ) ; edgeiter . hasnext ( ) ; ) { final connection edge = edgeiter . next ( ) ; final basevertex destnode = edge . getopposite ( rownode ) ; if ( ! seenvertices . contains ( destnode ) ) { rowlist . add ( currow + num_ , destnode ) ; seenvertices . add ( destnode ) ; } } seenvertices . add ( rownode ) ; } ++ currow ; } rowlist . optimize ( ) ; return rowlist ; }	Calculates layouting for provided graph.
private editpart getpartforelement ( object modelelement ) { if ( modelelement instanceof retegraph ) { return new diagrameditpart ( ) ; } if ( modelelement instanceof basevertex ) { return new vertexeditpart ( ) ; } if ( modelelement instanceof connection ) { return new connectioneditpart ( ) ; } droolseclipseplugin . log ( new exception ( str_ + ( ( modelelement != null ) ? modelelement . getclass ( ) . getname ( ) : str_ ) ) ) ; return null ; }	Maps object to EditPart.
public static imagedescriptor getimagedescriptor ( string path ) { jbpmeclipseplugin plugin = getdefault ( ) ; imageregistry reg = plugin . getimageregistry ( ) ; imagedescriptor des = reg . getdescriptor ( path ) ; if ( des == null ) { des = abstractuiplugin . imagedescriptorfromplugin ( str_ , path ) ; reg . put ( path , des ) ; } return des ; }	Returns an image descriptor for the image file at the givenplug-in relative path.Uses the plug ins image registry to "cache" it.
public final static void declareregistryimage ( string key , string path ) { imagedescriptor desc = imagedescriptor . getmissingimagedescriptor ( ) ; try { desc = imagedescriptor . createfromurl ( makeiconfileurl ( path ) ) ; } catch ( malformedurlexception e ) { droolseclipseplugin . log ( e ) ; } imageregistry . put ( key , desc ) ; }	Declare an Image in the registry table.
public void add ( final int depth , final basevertex vertex ) { if ( this . rows . size ( ) < ( depth + num_ ) ) { final int addrows = depth - this . rows . size ( ) + num_ ; for ( int i = num_ ; i < addrows ; ++ i ) { this . rows . add ( new row ( ( depth - addrows ) + i ) ) ; } } ( ( row ) this . rows . get ( depth ) ) . add ( vertex ) ; }	Adds new vertex to specified depth.
public int getrow ( final basevertex vertex ) { final int numrows = this . rows . size ( ) ; for ( int i = num_ ; i < numrows ; ++ i ) { if ( ( ( row ) this . rows . get ( i ) ) . contains ( vertex ) ) { return i ; } } return - num_ ; }	Finds specified vertex from the rows.
public int getwidth ( ) { int width = num_ ; for ( final iterator < row > rowiter = this . rows . iterator ( ) ; rowiter . hasnext ( ) ; ) { final row row = rowiter . next ( ) ; final int rowwidth = row . getwidth ( ) ; if ( rowwidth > width ) { width = rowwidth ; } } return width ; }	Finds the longest row width.
public void dump ( ) { final int numrows = this . rows . size ( ) ; for ( int i = num_ ; i < numrows ; ++ i ) { system . err . println ( i + str_ + get ( i ) . getvertices ( ) ) ; } }	Dumps all row vertices to System.err.
public void optimize ( ) { final int numrows = this . rows . size ( ) ; for ( int i = num_ ; i < numrows ; ++ i ) { get ( i ) . optimize ( ) ; } }	Optimizes all rows for optimal presentation.
protected void initializegraphicalviewer ( ) { zoommanager zoommanager = rooteditpart . getzoommanager ( ) ;	Loads Rete model and initializes zoom manager.
public void drawgraph ( retegraph newgraph ) { layermanager manager = ( layermanager ) getgraphicalviewer ( ) . geteditpartregistry ( ) . get ( layermanager . id ) ; connectionlayer connlayer = ( connectionlayer ) manager . getlayer ( layerconstants . connection_layer ) ;	Draws graph.
public droolslinebreakpoint getdroolsbreakpoint ( string source ) { if ( source == null ) { return null ; } iterator < ibreakpoint > iterator = getbreakpoints ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { ijavabreakpoint element = ( ijavabreakpoint ) iterator . next ( ) ; if ( element instanceof droolslinebreakpoint && ( ( droolslinebreakpoint ) element ) . getdialectname ( ) . equals ( str_ ) ) { droolslinebreakpoint l = ( droolslinebreakpoint ) element ; try { int matchline = l . getlinenumber ( ) ; string matchsource = l . getrulename ( ) ; if ( source . equals ( matchsource ) || l . getfilerulemappings ( ) . containskey ( source ) ) { return l ; } } catch ( coreexception e ) { logerror ( e ) ; } } } return null ; }	Tries to find a match for the provided breakpoint information from the list of registered breakpoints.For stepping and possibly other purposes it returns also a breakpoint for cases where exactly the same line was not found.If breakpoint is not found for line at source then it takes the first line that is above thespecified line at the same file.
public void sethref ( string href ) { assert . isnotnull ( href ) ; setchild ( root , str_ , encodehref ( href ) , childnames , bool_ ) ;	Sets this baseline control elment description to the given href.
public boolean cantalkdav ( ) throws davexception { iresponse response = null ; try {	Return a boolean value indicating whether or not the server for this resourceis DAV compliant.
public void copy ( ilocator destination , string depth , boolean overwrite , collection propertynames ) throws davexception {	Make a copy of this resource and place it at the location specifiedby the given destination locator.
protected void examinemultistatusresponse ( iresponse response ) throws davexception {	If the given response contains a multistatus body, the bodies status'are checked for errors.
protected urltable extractpropstats ( multistatus multistatus ) throws ioexception , malformedelementexception {	Helper method to extract the property status response froma multi status reponse, and populate a URLTable with theresults.
public responseinputstream getcontent ( ) throws davexception { iresponse response = null ; try { response = davclient . get ( locator , newcontext ( ) ) ; examineresponse ( response ) ; } catch ( ioexception e ) { closeresponse ( response ) ; throw new systemexception ( e ) ; } return new responseinputstream ( response ) ; }	Return the content of this resource as an input stream.
public enumeration getlocks ( ) throws davexception { lockdiscovery lockdiscovery = null ; try { element element = getproperty ( dav_lock_discovery ) . getproperty ( ) ; lockdiscovery = new lockdiscovery ( element ) ; return lockdiscovery . getactivelocks ( ) ; } catch ( webdavexception exception ) { if ( exception . getstatuscode ( ) == iresponse . sc_not_found ) return new emptyenumeration ( ) ; throw exception ; } catch ( malformedelementexception elemexception ) { throw new systemexception ( elemexception ) ; } }	Return an Enumeration over ActiveLocks which lists the locks currentlyheld on this resource.
public propertystatus getproperty ( qualifiedname propertyname ) throws davexception { collection names = new hashset ( ) ; names . add ( propertyname ) ; urltable result = getproperties ( names , icontext . depth_zero ) ; url url = null ; try { url = new url ( locator . getresourceurl ( ) ) ; } catch ( malformedurlexception e ) { throw new systemexception ( e ) ; } hashtable proptable = ( hashtable ) result . get ( url ) ; if ( proptable == null ) throw new davexception ( policy . bind ( str_ , url . toexternalform ( ) ) ) ;	Return the property status for the property with the given name.
public icontext head ( ) throws davexception { iresponse response = null ; try { response = davclient . head ( locator , newcontext ( ) ) ; examineresponse ( response ) ; return response . getcontext ( ) ; } catch ( ioexception exception ) { throw new systemexception ( exception ) ; } finally { closeresponse ( response ) ; } }	Return the header from a message send to the server.
public locktoken lock ( boolean isshared , string depth , int timeout , string owner ) throws davexception {	Lock this resource using the specified parameters.
public void move ( ilocator destination , boolean overwrite , enumeration names ) throws davexception { icontext context = newcontext ( ) ; context . setoverwrite ( overwrite ) ; document document = newdocument ( ) ; propertybehavior propertybehavior = propertybehavior . create ( document ) ; if ( names == null ) { propertybehavior . setiskeepallalive ( bool_ ) ; } else { while ( names . hasmoreelements ( ) ) { object obj = names . nextelement ( ) ; assert . istrue ( obj instanceof qualifiedname , policy . bind ( str_ ) ) ;	Move this resource to the location specified by the given locator.If a resource already exists at the destination and the overwriteboolean is true, then write over top of the existing resource.
protected ilocator protectedcheckin ( ) throws davexception { iresponse response = null ; try { response = davclient . checkin ( locator , newcontext ( ) , null ) ; examineresponse ( response ) ; string versionurl = response . getcontext ( ) . getlocation ( ) ; return davclient . getdavfactory ( ) . newstablelocator ( versionurl ) ; } catch ( ioexception e ) { throw new systemexception ( e ) ; } finally { closeresponse ( response ) ; } }	Check in the receiver and answer a new Locator on theresulting version resource.
public void refreshlock ( locktoken locktoken , int timeout ) throws davexception {	Refresh the lock on this resource with the given lock token.
public void removeproperties ( collection propertynames ) throws davexception { assert . isnotnull ( propertynames ) ;	Remove the properties with the given names, from this resource.
public void removeproperty ( qualifiedname propertyname ) throws davexception { collection propertynames = new vector ( num_ ) ; propertynames . add ( propertyname ) ; removeproperties ( propertynames ) ; }	Remove the property with the given name from this resource.
public void setcontent ( string contenttype , inputstream input ) throws davexception { iresponse response = null ; try { icontext context = newcontext ( ) ; context . setcontenttype ( contenttype ) ; response = davclient . put ( locator , context , input ) ; examineresponse ( response ) ; } catch ( ioexception e ) { throw new systemexception ( e ) ; } finally { closeresponse ( response ) ; } }	Set the content of this resource to be the data stored in the giveninput stream.
public void setproperties ( collection properties ) throws davexception { assert . isnotnull ( properties ) ;	Set the given properties on this resource.
public void setproperty ( element property ) throws davexception { collection properties = new vector ( num_ ) ; properties . add ( property ) ; setproperties ( properties ) ; }	Set the given property on this resource.
public void unlock ( locktoken token ) throws davexception {	Unlock this resource with the given lock token.
public void update ( ilocator version ) throws davexception { document document = newdocument ( ) ; update . createversion ( document , version . getresourceurl ( ) ) ; iresponse response = null ; try { response = davclient . update ( locator , newcontext ( ) , document ) ; examineresponse ( response ) ; } catch ( ioexception e ) { throw new systemexception ( e ) ; } finally { closeresponse ( response ) ; } }	Perform an UPDATE on the receiver to set the version itis based upon.
public void versioncontrol ( ) throws davexception { iresponse response = null ; try { response = davclient . versioncontrol ( locator , newcontext ( ) , null ) ; examineresponse ( response ) ; } catch ( ioexception e ) { throw new systemexception ( e ) ; } finally { closeresponse ( response ) ; } }	Bring the receiver under version control.
public void delete ( boolean mustexist ) throws davexception { iresponse response = null ; try { response = davclient . delete ( locator , newcontext ( ) ) ; if ( ! mustexist && ( response . getstatuscode ( ) == iresponse . sc_not_found ) ) return ; examineresponse ( response ) ; examinemultistatusresponse ( response ) ; } catch ( ioexception exception ) { throw new systemexception ( exception ) ; } finally { closeresponse ( response ) ; } }	Delete this resource from the repository, optionally succeedingin the delete if the resource was not found on the server.
protected void examinestatuscode ( int code , string message ) throws webdavexception { if ( code >= num_ && code <= num_ ) throw new redirectionexception ( code , message ) ; if ( code >= num_ && code <= num_ ) throw new clientexception ( code , message ) ; if ( code >= num_ && code <= num_ ) throw new serverexception ( code , message ) ; }	Check the given status code and throw a WebDAVexception if the code indicates failure.
protected boolean propertyhaschild ( qualifiedname propertyname , qualifiedname childname ) throws davexception {	This is a helper method to check to see if the resource has aproperty with the given name that in turn has a child with agiven name.
public void write ( outputstream os ) throws ioexception { if ( requestbodywriter == null ) { if ( inputread ) { is . reset ( ) ; inputread = bool_ ; } super . write ( os ) ; } else { requestbodywriter . writerequestbody ( os ) ; } }	Writes this request's body to the given output stream.
public static string tohex ( byte [ ] arr ) { stringbuffer buf = new stringbuffer ( ) ; for ( int i = num_ ; i < arr . length ; ++ i ) { buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( arr [ i ] & num_ ) ) ; } return buf . tostring ( ) ; }	Converts the given byte array to its equivalent hexadecimal stringand returns the result.
public static string tohex ( int [ ] arr ) { stringbuffer buf = new stringbuffer ( ) ; for ( int i = num_ ; i < arr . length ; ++ i ) { buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] > > num_ ) & num_ ) ) ; buf . append ( integer . tohexstring ( ( arr [ i ] ) & num_ ) ) ; } return buf . tostring ( ) ; }	Converts the given int array to its equivalent hexadecimal stringand returns the result.
public void setisallprop ( boolean isallprop ) { element child = getfirstchild ( root , childnames ) ; boolean isalreadyallprop = isdavelement ( child , str_ ) ;	Sets whether this propfind is in the "all prop" form.
public void setispropname ( boolean ispropname ) { element child = getfirstchild ( root , childnames ) ; boolean isalreadypropname = isdavelement ( child , str_ ) ;	Sets whether this propfind is in the "prop name" form.
public prop setprop ( ) { assert . istrue ( getfirstchild ( root , new string [ ] { str_ , str_ } ) == null ) ;	Creates and sets a new prop on this propfind and returns an editor onit.
public static string striplastword ( string prefix ) { if ( str_ . equals ( prefix ) ) { return prefix ; } if ( prefix . charat ( prefix . length ( ) - num_ ) == str_ ) { return str_ ; } else { char [ ] c = prefix . tochararray ( ) ; int start = num_ ; for ( int i = c . length - num_ ; i >= num_ ; i -- ) { if ( character . iswhitespace ( c [ i ] ) || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ || c [ i ] == str_ ) { start = i + num_ ; break ; } } prefix = prefix . substring ( start , prefix . length ( ) ) ; return prefix ; } }	Looks behind, gets stuff after the white space.
public void update ( ) { treeviewer viewer = gettreeviewer ( ) ; if ( viewer != null ) { control control = viewer . getcontrol ( ) ; if ( control != null && ! control . isdisposed ( ) ) { initrules ( ) ; populatepackagetreenode ( ) ; viewer . refresh ( ) ; control . setredraw ( bool_ ) ; viewer . expandtolevel ( num_ ) ; control . setredraw ( bool_ ) ; } } }	Updates the outline page.
public void write ( outputstream os ) throws ioexception { assert . istrue ( ! inputread ) ; assert . istrue ( ! hasinputstream ) ; int bytesread = num_ ; int totalbytesread = num_ ; byte [ ] buffer = bufferpool . getbuffer ( ) ; long contentlength = getcontentlength ( ) ; try { while ( bytesread != - num_ && ( contentlength == - num_ || contentlength > totalbytesread ) ) { if ( contentlength == - num_ ) { bytesread = is . read ( buffer ) ; } else { bytesread = is . read ( buffer , num_ , ( int ) math . min ( buffer . length , contentlength - totalbytesread ) ) ; } if ( bytesread == - num_ ) { if ( contentlength >= num_ ) { throw new ioexception ( policy . bind ( str_ ) ) ;	Writes this messages body to the given output stream.
public synchronized void stepover ( ) throws debugexception {	I don't see the need for any of this custom stepOver stuff, why is it here?.
protected void markparseerrors ( list < droolsbuildmarker > markers , list < baseknowledgebuilderresultimpl > parsererrors ) { for ( iterator < baseknowledgebuilderresultimpl > iter = parsererrors . iterator ( ) ; iter . hasnext ( ) ; ) { object error = iter . next ( ) ; if ( error instanceof parsererror ) { parsererror err = ( parsererror ) error ; markers . add ( new droolsbuildmarker ( err . getmessage ( ) , err . getrow ( ) ) ) ; } else if ( error instanceof knowledgebuilderresult ) { knowledgebuilderresult res = ( knowledgebuilderresult ) error ; int [ ] errorlines = res . getlines ( ) ; markers . add ( new droolsbuildmarker ( res . getmessage ( ) , errorlines != null && errorlines . length > num_ ? errorlines [ num_ ] : - num_ ) ) ; } else if ( error instanceof expanderexception ) { expanderexception exc = ( expanderexception ) error ;	This will create markers for parse errors.
public void skipwhitespace ( ) { while ( pos < s . length ( ) && character . iswhitespace ( s . charat ( pos ) ) ) ++ pos ; }	Skips the next sequence of white space in s.
public static boolean addresourcetoguvnor ( string reploc , string targetloc , ifile selectedfile ) { boolean res = bool_ ; try { string fullpath = targetloc + selectedfile . getname ( ) ; iwebdavclient client = webdavservercache . getwebdavclient ( reploc ) ; if ( client == null ) { client = webdavclientfactory . createclient ( new url ( reploc ) ) ; webdavservercache . cachewebdavclient ( reploc , client ) ; } try {	Adds a resource to Guvnor.
public static void commitfilechanges ( ifile selectedfile ) { try { guvnormetadataprops props = guvnormetadatautils . getguvnormetadata ( selectedfile ) ; iwebdavclient client = webdavservercache . getwebdavclient ( props . getrepository ( ) ) ; if ( client == null ) { client = webdavclientfactory . createclient ( new url ( props . getrepository ( ) ) ) ; webdavservercache . cachewebdavclient ( props . getrepository ( ) , client ) ; } resourceproperties remoteprops = null ; try { remoteprops = client . queryproperties ( props . getfullpath ( ) ) ; } catch ( webdavexception wde ) { if ( wde . geterrorcode ( ) != iresponse . sc_unauthorized ) {	Commits changes to Guvnor.
public int getage ( ) { string agestring = get ( age ) ; return ( agestring == null ) ? - num_ : integer . parseint ( agestring ) ; }	Get the sender's estimate of the time since the response was generated.Return the int value for the AGE key.
public long getcontentlength ( ) { string lengthstring = get ( content_length ) ; return ( lengthstring == null ) ? - num_ : long . parselong ( lengthstring ) ; }	Get the content length in bytes of the entity body.Return the value for the CONTENT_LENGTH key.Returns -1 if the Content-Length has not been set.
public int getmaxforwards ( ) { string s = get ( max_forwards ) ; return s == null ? - num_ : integer . parseint ( s ) ; }	Return the integer value for the MAX_FORWARDS key.
public boolean getoverwrite ( ) { string overwritestring = get ( overwrite ) ; return overwritestring == null ? bool_ : overwritestring . equalsignorecase ( str_ ) ;	Get the flag that indicates if copy or move should overwritean existing destination.
public boolean getpassthrough ( ) { string s = get ( passthrough ) ; return s == null ? bool_ : s . equalsignorecase ( str_ ) ;	Return the boolean value for the PASSTHROUGH key.
public int gettimeout ( ) { string timeoutstring = get ( timeout ) ; if ( timeoutstring == null ) return - num_ ; if ( timeoutstring . equalsignorecase ( depth_infinity ) ) return - num_ ; if ( timeoutstring . regionmatches ( bool_ , num_ , str_ , num_ , num_ ) )	Get the lock timeout value.
public void put ( string key , string value ) { contextkey ckey = new contextkey ( key ) ; if ( ( value == null ) || ( value . length ( ) == num_ ) ) properties . remove ( ckey ) ; else properties . put ( ckey , value ) ; }	Put the given key-value pair into the context.
public void settimeout ( int value ) { if ( value == - num_ ) put ( timeout , str_ ) ;	Set the lock timeout value in seconds.
protected bufferedreader opendslfile ( string filename ) { try { filereader reader = new filereader ( filename ) ; bufferedreader breader = new bufferedreader ( reader ) ; return breader ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return null ; } }	method will create a BufferedReader to read the file.
protected void parsefile ( bufferedreader reader ) { string line = null ; try { while ( ( line = reader . readline ( ) ) != null ) { section section = getsection ( line ) ; string nl = stripheadingandcode ( line ) ; string objname = this . getobjmetadata ( nl ) ; nl = this . stripobjmetadata ( nl ) ; addentry ( section , nl , objname ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	method will use the BufferedReader to read the contents of the file.It calls other methods to parse the line and build the tree.
protected string getobjmetadata ( string text ) { if ( text . startswith ( str_ ) ) { return text . substring ( num_ , text . lastindexof ( str_ ) ) ; } else { return str_ ; } }	Method will return just the object metadata.
protected string stripobjmetadata ( string text ) { if ( text . startswith ( str_ ) ) { return text . substring ( text . lastindexof ( str_ ) + num_ ) ; } else { return text ; } }	method will strip the metadata from the text string.
public void addtokens ( string [ ] tokens , node rootnode ) { node thenode = rootnode ; for ( int i = num_ ; i < tokens . length ; i ++ ) { node newnode = thenode . addtoken ( tokens [ i ] ) ; thenode = newnode ; } }	method adds the token to root.
public node [ ] getconditionchildren ( string text ) { node thenode = this . rootcond ; if ( text . length ( ) > num_ ) { stringtokenizer tokenz = new stringtokenizer ( text ) ; this . last = this . current ; while ( tokenz . hasmoretokens ( ) ) { string strtk = tokenz . nexttoken ( ) ; node ch = thenode . getchild ( strtk ) ;	the method will tokenize the text and try to findthe node that matches and return the children.
public node [ ] getchildren ( string obj , string text ) { node thenode = this . rootcond . getchild ( obj ) ; if ( thenode == null ) { for ( node child : this . rootcond . getchildren ( ) ) { string tokentext = child . gettoken ( ) ; if ( tokentext != null ) { int index = tokentext . indexof ( str_ ) ; if ( index != - num_ ) { string substring = tokentext . substring ( num_ , index ) ; if ( obj != null && obj . startswith ( substring ) ) { thenode = child ; } } } } } if ( thenode != null && text . length ( ) > num_ ) { stringtokenizer tokenz = new stringtokenizer ( text ) ; this . last = this . current ; while ( tokenz . hasmoretokens ( ) ) { string strtk = tokenz . nexttoken ( ) ; node ch = thenode . getchild ( strtk ) ;	the method expects the caller to pass the object.
public void addchildtolist ( node n , string prefix , arraylist < string > list ) { if ( n . getchildren ( ) . size ( ) > num_ ) { for ( node child : n . getchildren ( ) ) { if ( prefix != null && str_ . equals ( child . gettoken ( ) ) ) { if ( ! list . contains ( prefix ) ) { list . add ( prefix ) ; } return ; } string text = ( prefix == null ? str_ : prefix + str_ ) + child . gettoken ( ) ;	method will prepend the parent text to the child and generatethe possible combinations in text format.
public void printtree ( ) { system . out . println ( str_ ) ; for ( node n : rootcond . getchildren ( ) ) { printnode ( n ) ; } }	The method will print the DSLTree to System.out in text format.
protected void printnode ( node n ) { printtabs ( n . getdepth ( ) ) ; system . out . println ( str_ + n . gettoken ( ) + str_ ) ; for ( node c : n . getchildren ( ) ) { printnode ( c ) ; } }	method will print the node and then iterate over the children.
protected void printtabs ( int count ) { for ( int idx = num_ ; idx < count ; idx ++ ) { system . out . print ( tab ) ; } }	Method will print n number of tabs.
public static jsonvalue readfrom ( string text ) { try { return new jsonparser ( text ) . parse ( ) ; } catch ( ioexception exception ) {	Reads a JSON value from the given string.
public static imagedescriptor getimagedescriptor ( string id ) { imagedescriptor retval = getdefault ( ) . getimageregistry ( ) . getdescriptor ( id ) ; if ( retval == null ) { retval = loadimagedescriptor ( id ) ; getdefault ( ) . getimageregistry ( ) . put ( id , retval ) ; } return retval ; }	Returns an image descriptor for the image file at the givenplug-in relative path.
public response invoke ( request request ) throws ioexception { assert . isnotnull ( request ) ; try { open ( ) ; url resourceurl = request . getresourceurl ( ) ; url originserverurl = new url ( resourceurl . getprotocol ( ) , resourceurl . gethost ( ) , resourceurl . getport ( ) , str_ ) ;	Sends the given request to the server and returns the server'sresponse.
public void setrequestheaderfield ( string fieldname , string fieldvalue ) { assert . isnotnull ( fieldname ) ; assert . isnotnull ( fieldvalue ) ; endrequest ( ) ; requestheader . addfield ( fieldname , fieldvalue ) ; }	Sets the request header value associated with the given field.
private void createrulesamplelauncher ( ijavaproject project ) throws javamodelexception , ioexception { version version = startpage . getruntime ( ) . getversion ( ) ; if ( version . getmajor ( ) == num_ ) { createprojectjavafile ( project , str_ , str_ ) ; } else if ( version . getmajor ( ) == num_ ) { createprojectjavafile ( project , str_ , str_ ) ; } else if ( version . getmajor ( ) >= num_ ) { createprojectjavafile ( project , str_ , str_ ) ; } }	Create the sample rule launcher file.
private void createrule ( ijavaproject project , iprogressmonitor monitor ) throws coreexception { if ( startpage . getruntime ( ) . getversion ( ) . getmajor ( ) >= num_ ) { fileutils . createfolder ( project , str_ , monitor ) ; createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } else { createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } }	Create the sample rule file.
private void createruleflow ( ijavaproject project , iprogressmonitor monitor ) throws coreexception { version version = startpage . getruntime ( ) . getversion ( ) ; if ( version . getmajor ( ) == num_ ) { createprojectfile ( project , monitor , str_ , str_ , str_ ) ; createprojectfile ( project , monitor , str_ , str_ , str_ ) ; createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } else if ( version . getmajor ( ) == num_ && version . getminor ( ) == num_ ) { createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } else if ( version . getmajor ( ) == num_ ) { createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } else { fileutils . createfolder ( project , str_ , monitor ) ; createprojectfile ( project , monitor , str_ , str_ , str_ ) ; } }	Create the sample RuleFlow file.
private void createruleflowsamplelauncher ( ijavaproject project ) throws javamodelexception , ioexception { string s ; version version = startpage . getruntime ( ) . getversion ( ) ; if ( version . getmajor ( ) == num_ ) { s = str_ ; } else if ( version . getmajor ( ) == num_ && version . getminor ( ) == num_ ) { s = str_ ; } else if ( version . getmajor ( ) == num_ ) { s = str_ ; } else { s = str_ ; } createprojectjavafile ( project , s , str_ ) ; }	Create the sample RuleFlow launcher file.
public list < iinstallableunit > getselectedius ( ) { list < iinstallableunit > result = new arraylist < iinstallableunit > ( ) ; for ( object o : getcheckedelements ( ) ) { if ( o instanceof iutreeitem ) { iutreeitem item = ( iutreeitem ) o ; if ( item . parent != null ) result . add ( item . iu ) ; } } return result ; }	Returns only the installable units that are features, ignoring feature groups.
public void createimage ( outputstream stream , int format ) { swtgraphics g = null ; gc gc = null ; image image = null ; layermanager layermanager = ( layermanager ) getgraphicalviewer ( ) . geteditpartregistry ( ) . get ( layermanager . id ) ; ifigure figure = layermanager . getlayer ( layerconstants . printable_layers ) ; rectangle r = figure . getbounds ( ) ; try { image = new image ( display . getdefault ( ) , r . width , r . height ) ; gc = new gc ( image ) ; g = new swtgraphics ( gc ) ; g . translate ( r . x * - num_ , r . y * - num_ ) ; figure . paint ( g ) ; imageloader imageloader = new imageloader ( ) ; imageloader . data = new imagedata [ ] { image . getimagedata ( ) } ; imageloader . save ( stream , format ) ; } catch ( throwable t ) { droolseclipseplugin . log ( t ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( gc != null ) { gc . dispose ( ) ; } if ( image != null ) { image . dispose ( ) ; } } }	Writes the content of this editor to the given stream.Possible formats are for example SWT.IMAGE_BMP, IMAGE_GIF,IMAGE_JPEG, IMAGE_PNG.
public string getfieldname ( ) { alphanodefieldconstraint constraint = this . node . getconstraint ( ) ; if ( constraint instanceof mvelconstraint ) { mvelconstraint mvelconstraint = ( mvelconstraint ) constraint ; internalreadaccessor accessor = mvelconstraint . getfieldextractor ( ) ; if ( accessor instanceof classfieldreader ) { return ( ( classfieldreader ) accessor ) . getfieldname ( ) ; } } return null ; }	Constraint has field extractor and this method is returning fieldNameit.
public string getevaluator ( ) { alphanodefieldconstraint constraint = this . node . getconstraint ( ) ; if ( constraint instanceof mvelconstraint ) { mvelconstraint mvelconstraint = ( mvelconstraint ) constraint ; return mvelconstraint . tostring ( ) ; } return null ; }	Constraint's evaluator string.
public string getvalue ( ) { alphanodefieldconstraint constraint = this . node . getconstraint ( ) ; if ( constraint instanceof mvelconstraint ) { mvelconstraint mvelconstraint = ( mvelconstraint ) constraint ; fieldvalue field = mvelconstraint . getfield ( ) ; return field != null ? field . tostring ( ) : null ; } return null ; }	Constraint field string.
private void addguvnorresourceproperties ( resourceproperties props , string filename , string resource ) throws exception { if ( props == null ) { return ; } iresponse response = null ; try { string path = resource . substring ( num_ , resource . lastindexof ( str_ ) ) ; string apiver = changetoapicall ( path ) ; properties guvprops = new properties ( ) ; response = getresourceinputstream ( apiver ) ; guvprops . load ( response . getinputstream ( ) ) ; string val = guvprops . getproperty ( filename ) ; if ( val != null ) { stringtokenizer tokens = new stringtokenizer ( val , str_ ) ;	Adds Guvnor-specific resource properties to the collection.
public void baselinecontrol ( ilocator baseline ) throws davexception { assert . isnotnull ( baseline ) ;	Create a new version-controlled configuration on the given baseline.
public void bind ( string member , ilocator source ) throws davexception { bind ( member , source , bool_ ) ; }	Binds the given member in this collection to the resource identifiedby the given source locator.
public ilocator getmember ( string membername ) { assert . istrue ( locator . getlabel ( ) == null ) ; assert . istrue ( ! locator . isstable ( ) ) ; string parentname = locator . getresourceurl ( ) ; string childname ; if ( parentname . endswith ( str_ ) )	Return the locator of the member of this collection, with the givenname.
public void optimize ( ) { final list < basevertex > sorted = new arraylist < basevertex > ( this . vertices ) ; collections . sort ( sorted , new comparator < basevertex > ( ) { public int compare ( final basevertex v1 , final basevertex v2 ) { int v1outdegree = v1 . getsourceconnections ( ) . size ( ) ; int v2outdegree = v2 . getsourceconnections ( ) . size ( ) ; if ( v1outdegree < v2outdegree ) { return num_ ; } if ( v1outdegree > v2outdegree ) { return - num_ ; } return num_ ; } } ) ; final linkedlist < basevertex > optimized = new linkedlist < basevertex > ( ) ; boolean front = bool_ ; for ( final iterator < basevertex > vertexiter = sorted . iterator ( ) ; vertexiter . hasnext ( ) ; ) { final basevertex vertex = vertexiter . next ( ) ; if ( front ) { optimized . addfirst ( vertex ) ; } else { optimized . addlast ( vertex ) ; } front = ! front ; } this . vertices = optimized ; }	Optimizing vertices for optimal presentation.
private void initializecontrols ( ) { if ( originalfile != null ) { resourcegroup . setcontainerfullpath ( originalfile . getparent ( ) . getfullpath ( ) ) ; string filename = originalfile . getname ( ) ; int index = filename . lastindexof ( str_ ) ; if ( index != - num_ ) { filename = filename . substring ( num_ , index ) ; } filename += str_ ; resourcegroup . setresource ( filename ) ; } else if ( originalname != null ) { resourcegroup . setresource ( originalname ) ; } setdialogcomplete ( validatepage ( ) ) ; }	Initializes the controls of this dialog.
private boolean validatepage ( ) { if ( ! resourcegroup . areallvaluesvalid ( ) ) { if ( ! resourcegroup . getresource ( ) . equals ( str_ ) ) {	Returns whether this page's visual components all contain valid values.
public static entitytag generateentitytag ( ) { string xx = basetime + str_ + integer . tohexstring ( thread . currentthread ( ) . hashcode ( ) ) ;	Construct a unique EntityTag.
public basevertex getopposite ( basevertex vertex ) {	Gets opposite of specified vertex.Returning null if specified not does not belong into this connection.
private boolean validate_otps ( list < string > otps , namecallback namecb ) throws loginexception { boolean validated = bool_ ; for ( string otp : otps ) { log . trace ( str_ , otp ) ; verificationresponse ykr ; try { ykr = this . yc . verify ( otp ) ; } catch ( yubicoverificationexception e ) { log . warn ( str_ , e ) ; throw new loginexception ( str_ + e . getmessage ( ) ) ; } catch ( yubicovalidationfailure e ) { log . warn ( str_ , e ) ; throw new loginexception ( str_ + e . getmessage ( ) ) ; } if ( ykr != null ) { log . trace ( str_ , otp , ykr . getstatus ( ) . tostring ( ) ) ; if ( ykr . getstatus ( ) == responsestatus . ok ) { string publicid = yubicoclient . getpublicid ( otp ) ; log . info ( str_ , publicid ) ; if ( is_right_user ( namecb . getname ( ) , publicid ) ) { this . principals . add ( new yubikeyprincipal ( publicid , this . idrealm ) ) ; validated = bool_ ; } } else { log . debug ( str_ , ykr . getstatus ( ) . tostring ( ) ) ; } } } return validated ; }	Try to validate all the OTPs provided.
private boolean is_right_user ( string username , string publicid ) { log . debug ( str_ , publicid , username ) ; return this . ykmap . is_right_user ( username , publicid ) ; }	After validation of an OTP, check that it came from a YubiKey that actuallybelongs to the user trying to authenticate.
private string get_username_for_id ( string publicid , string filename ) throws filenotfoundexception { scanner sc = null ; file file = new file ( filename ) ; try { sc = new scanner ( file ) ; while ( sc . hasnextline ( ) ) { string line = sc . nextline ( ) ; if ( line . startswith ( str_ + publicid + str_ ) ) { string ykuser = line . split ( str_ ) [ num_ ] . trim ( ) ; return ykuser ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return null ; }	Given publicId "vvcccccfhc", scans filename for a line like "yk.vvcccccfhc.user = alice"and returns "alice" if found.
private void add_yubikey_to_user ( string publicid , string username , string filename ) { try { file file = new file ( filename ) ; filewriter writer = new filewriter ( file , bool_ ) ; writer . write ( str_ + publicid + str_ + username + system . getproperty ( str_ ) ) ; writer . close ( ) ; } catch ( ioexception ex ) { log . error ( str_ , filename , ex ) ; } }	Stores an association between username and YubiKey publicId in filename.
boolean verify_otp ( string username , string otp ) { try { string authstring = username + str_ + otp ; string authstringenc = base64 . encodebase64urlsafestring ( authstring . getbytes ( ) ) ; bufferedreader in = attemptauthentication ( authstringenc ) ; string inputline ; while ( ( inputline = in . readline ( ) ) != null ) { if ( inputline . contains ( expectedoutput ) ) { return bool_ ; } } } catch ( exception ex ) { log . error ( str_ , ex ) ; } return bool_ ; }	Access protectedUrl using userName and otp for basic auth.Check if what we get back contains expectedOutput.
public void clearpassword ( ) { for ( char pw [ ] : this . secrets ) { for ( int i = num_ ; i < pw . length ; i ++ ) { pw [ i ] = num_ ; } } this . secrets = new arraylist < char [ ] > ( ) ; }	Tries to clear all the passwords from memory.
public static string getpublicid ( string otp ) { if ( ( otp == null ) || ( otp . length ( ) < otp_min_len ) ) {	Extract the public ID of a YubiKey from an OTP it generated.
public static boolean isvalidotpformat ( string otp ) { if ( otp == null ) { return bool_ ; } int len = otp . length ( ) ; for ( char c : otp . tochararray ( ) ) { if ( c < num_ || c > num_ ) { return bool_ ; } } return otp_min_len <= len && len <= otp_max_len ; }	Determines whether a given OTP is of the correct lengthand only contains printable characters, as per the recommendation.
public evaluation create ( simplenode node , object source ) { return create ( node , source , bool_ ) ; }	Returns an Evaluation that contains the node, source and whether itis a set operation.
public evaluation create ( simplenode node , object source , boolean setoperation ) {	Returns an Evaluation that contains the node, source and whether itis a set operation.
public static void clearcache ( ) { _methodparametertypescache . clear ( ) ; _ctorparametertypescache . clear ( ) ; _propertydescriptorcache . clear ( ) ; _constructorcache . clear ( ) ; _staticmethodcache . clear ( ) ; _instancemethodcache . clear ( ) ; _invokepermissioncache . clear ( ) ; _fieldcache . clear ( ) ; _superclasses . clear ( ) ; _declaredmethods [ num_ ] . clear ( ) ; _declaredmethods [ num_ ] . clear ( ) ; _methodaccesscache . clear ( ) ; _methodpermcache . clear ( ) ; }	Clears all of the cached reflection information normally usedto improve the speed of expressions that operate on the same classesor are executed multiple times.
public static boolean isjdk15 ( ) { if ( _jdkchecked ) return _jdk15 ; try { class . forname ( str_ ) ; _jdk15 = bool_ ; } catch ( exception e ) { } _jdkchecked = bool_ ; return _jdk15 ; }	Checks if the current jvm is java language >= 1.5 compatible.
public static string getpackagename ( object o ) { return ( o == null ) ? null : getclasspackagename ( o . getclass ( ) ) ; }	Returns the package name of the object's class.
public static string getclasspackagename ( class c ) { string s = c . getname ( ) ; int i = s . lastindexof ( str_ ) ; return ( i < num_ ) ? null : s . substring ( num_ , i ) ; }	Returns the package name of the class given.
public static string getuniquedescriptor ( object object , boolean fullyqualified ) { stringbuffer result = new stringbuffer ( ) ; if ( object != null ) { if ( object instanceof proxy ) { class interfaceclass = object . getclass ( ) . getinterfaces ( ) [ num_ ] ; result . append ( getclassname ( interfaceclass , fullyqualified ) ) ; result . append ( str_ ) ; object = proxy . getinvocationhandler ( object ) ; } result . append ( getclassname ( object , fullyqualified ) ) ; result . append ( str_ ) ; result . append ( getpointerstring ( object ) ) ; } else { result . append ( null_object_string ) ; } return new string ( result ) ; }	Returns a unique descriptor string that includes the object's class and a unique integeridentifier.
public static final class getargclass ( object arg ) { if ( arg == null ) return null ; class c = arg . getclass ( ) ; if ( c == boolean . class ) return boolean . type ; else if ( c . getsuperclass ( ) == number . class ) { if ( c == integer . class ) return integer . type ; if ( c == double . class ) return double . type ; if ( c == byte . class ) return byte . type ; if ( c == long . class ) return long . type ; if ( c == float . class ) return float . type ; if ( c == short . class ) return short . type ; } else if ( c == character . class ) return character . type ; return c ; }	Gets the class for a method argument that is appropriate for looking up methods byreflection, by looking for the standard primitive wrapper classes and exchanging for themtheir underlying primitive class objects.
public static final boolean ismorespecific ( class [ ] classes1 , class [ ] classes2 ) { for ( int index = num_ , count = classes1 . length ; index < count ; ++ index ) { class c1 = classes1 [ index ] , c2 = classes2 [ index ] ; if ( c1 == c2 ) continue ; else if ( c1 . isprimitive ( ) ) return bool_ ; else if ( c1 . isassignablefrom ( c2 ) ) return bool_ ; else if ( c2 . isassignablefrom ( c1 ) ) return bool_ ; }	Tells whether the first array of classes is more specific than the second.
public static final object getmethodvalue ( ognlcontext context , object target , string propertyname , boolean checkaccessandexistence ) throws ognlexception , illegalaccessexception , nosuchmethodexception , introspectionexception { object result = null ; method m = getgetmethod ( context , ( target == null ) ? null : target . getclass ( ) , propertyname ) ; if ( m == null ) m = getreadmethod ( ( target == null ) ? null : target . getclass ( ) , propertyname , null ) ; if ( checkaccessandexistence ) { if ( ( m == null ) || ! context . getmemberaccess ( ) . isaccessible ( context , target , m , propertyname ) ) { result = notfound ; } } if ( result == null ) { if ( m != null ) { try { result = invokemethod ( target , m , noarguments ) ; } catch ( invocationtargetexception ex ) { throw new ognlexception ( propertyname , ex . gettargetexception ( ) ) ; } } else { throw new nosuchmethodexception ( propertyname ) ; } } return result ; }	If the checkAccessAndExistence flag is true this method will check to see if the methodexists and if it is accessible according to the context's MemberAccess.
public static map getpropertydescriptors ( class targetclass ) throws introspectionexception , ognlexception { map result ; if ( ( result = ( map ) _propertydescriptorcache . get ( targetclass ) ) == null ) { synchronized ( _propertydescriptorcache ) { if ( ( result = ( map ) _propertydescriptorcache . get ( targetclass ) ) == null ) { propertydescriptor [ ] pda = introspector . getbeaninfo ( targetclass ) . getpropertydescriptors ( ) ; result = new hashmap ( num_ ) ; for ( int i = num_ , icount = pda . length ; i < icount ; i ++ ) {	This method returns the property descriptors for the given class as a Map.
public static propertydescriptor getpropertydescriptorfromarray ( class targetclass , string name ) throws introspectionexception { propertydescriptor result = null ; propertydescriptor [ ] pda = getpropertydescriptorsarray ( targetclass ) ; for ( int i = num_ , icount = pda . length ; ( result == null ) && ( i < icount ) ; i ++ ) { if ( pda [ i ] . getname ( ) . compareto ( name ) == num_ ) { result = pda [ i ] ; } } return result ; }	Gets the property descriptor with the given name for the target class given.
public static method getreadmethod ( class target , string name ) { return getreadmethod ( target , name , null ) ; }	Finds the best possible match for a method on the specified target class with a matchingname.
public char readchar ( ) throws java . io . ioexception { if ( inbuf > num_ ) { -- inbuf ; if ( ++ bufpos == bufsize ) bufpos = num_ ; return buffer [ bufpos ] ; } char c ; if ( ++ bufpos == available ) adjustbuffsize ( ) ; if ( ( buffer [ bufpos ] = c = readbyte ( ) ) == str_ ) { updatelinecolumn ( c ) ; int backslashcnt = num_ ; for ( ; ; )	Read a character.
final public void projection ( ) throws parseexception { astproject jjtn000 = new astproject ( jjtproject ) ; boolean jjtc000 = bool_ ; jjtree . opennodescope ( jjtn000 ) ; try { jj_consume_token ( num_ ) ; expression ( ) ; jj_consume_token ( num_ ) ; } catch ( throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearnodescope ( jjtn000 ) ; jjtc000 = bool_ ; } else { jjtree . popnode ( ) ; } if ( jjte000 instanceof runtimeexception ) { { if ( bool_ ) throw ( runtimeexception ) jjte000 ; } } if ( jjte000 instanceof parseexception ) { { if ( bool_ ) throw ( parseexception ) jjte000 ; } } { if ( bool_ ) throw ( error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closenodescope ( jjtn000 , bool_ ) ; } } }	Apply an expression to all elements of a collection, creating a new collectionas the result.
final public void selectall ( ) throws parseexception { astselect jjtn000 = new astselect ( jjtselect ) ; boolean jjtc000 = bool_ ; jjtree . opennodescope ( jjtn000 ) ; try { jj_consume_token ( num_ ) ; jj_consume_token ( num_ ) ; expression ( ) ; jj_consume_token ( num_ ) ; } catch ( throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearnodescope ( jjtn000 ) ; jjtc000 = bool_ ; } else { jjtree . popnode ( ) ; } if ( jjte000 instanceof runtimeexception ) { { if ( bool_ ) throw ( runtimeexception ) jjte000 ; } } if ( jjte000 instanceof parseexception ) { { if ( bool_ ) throw ( parseexception ) jjte000 ; } } { if ( bool_ ) throw ( error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closenodescope ( jjtn000 , bool_ ) ; } } }	Apply a boolean expression to all elements of a collection, creating a new collectioncontaining those elements for which the expression returned true.
public static long longvalue ( object value ) throws numberformatexception { if ( value == null ) return num_ ; class c = value . getclass ( ) ; if ( c . getsuperclass ( ) == number . class ) return ( ( number ) value ) . longvalue ( ) ; if ( c == boolean . class ) return ( ( boolean ) value ) . booleanvalue ( ) ? num_ : num_ ; if ( c == character . class ) return ( ( character ) value ) . charvalue ( ) ; return long . parselong ( stringvalue ( value , bool_ ) ) ; }	Evaluates the given object as a long integer.
public static double doublevalue ( object value ) throws numberformatexception { if ( value == null ) return num_ ; class c = value . getclass ( ) ; if ( c . getsuperclass ( ) == number . class ) return ( ( number ) value ) . doublevalue ( ) ; if ( c == boolean . class ) return ( ( boolean ) value ) . booleanvalue ( ) ? num_ : num_ ; if ( c == character . class ) return ( ( character ) value ) . charvalue ( ) ; string s = stringvalue ( value , bool_ ) ; return ( s . length ( ) == num_ ) ? num_ : double . parsedouble ( s ) ; }	Evaluates the given object as a double-precision floating-point number.
public static biginteger bigintvalue ( object value ) throws numberformatexception { if ( value == null ) return biginteger . valueof ( num_ ) ; class c = value . getclass ( ) ; if ( c == biginteger . class ) return ( biginteger ) value ; if ( c == bigdecimal . class ) return ( ( bigdecimal ) value ) . tobiginteger ( ) ; if ( c . getsuperclass ( ) == number . class ) return biginteger . valueof ( ( ( number ) value ) . longvalue ( ) ) ; if ( c == boolean . class ) return biginteger . valueof ( ( ( boolean ) value ) . booleanvalue ( ) ? num_ : num_ ) ; if ( c == character . class ) return biginteger . valueof ( ( ( character ) value ) . charvalue ( ) ) ; return new biginteger ( stringvalue ( value , bool_ ) ) ; }	Evaluates the given object as a BigInteger.
public static bigdecimal bigdecvalue ( object value ) throws numberformatexception { if ( value == null ) return bigdecimal . valueof ( num_ ) ; class c = value . getclass ( ) ; if ( c == bigdecimal . class ) return ( bigdecimal ) value ; if ( c == biginteger . class ) return new bigdecimal ( ( biginteger ) value ) ; if ( c == boolean . class ) return bigdecimal . valueof ( ( ( boolean ) value ) . booleanvalue ( ) ? num_ : num_ ) ; if ( c == character . class ) return bigdecimal . valueof ( ( ( character ) value ) . charvalue ( ) ) ; return new bigdecimal ( stringvalue ( value , bool_ ) ) ; }	Evaluates the given object as a BigDecimal.
public static string stringvalue ( object value , boolean trim ) { string result ; if ( value == null ) { result = ognlruntime . null_string ; } else { result = value . tostring ( ) ; if ( trim ) { result = result . trim ( ) ; } } return result ; }	Evaluates the given object as a String and trims it if the trim flag is true.
public static int getnumerictype ( object value ) { if ( value != null ) { class c = value . getclass ( ) ; if ( c == integer . class ) return int ; if ( c == double . class ) return double ; if ( c == boolean . class ) return bool ; if ( c == byte . class ) return byte ; if ( c == character . class ) return char ; if ( c == short . class ) return short ; if ( c == long . class ) return long ; if ( c == float . class ) return float ; if ( c == biginteger . class ) return bigint ; if ( c == bigdecimal . class ) return bigdec ; } return nonnumeric ; }	Returns a constant from the NumericTypes interface that represents the numeric type of thegiven object.
public static object convertvalue ( object value , class totype ) { return convertvalue ( value , totype , bool_ ) ; }	Returns the value converted numerically to the given class type This method also detects whenarrays are being converted and converts the components of one array to the type of the other.
public static int getintvalue ( object value ) { try { if ( value == null ) return - num_ ; if ( number . class . isinstance ( value ) ) { return ( ( number ) value ) . intvalue ( ) ; } string str = string . class . isinstance ( value ) ? ( string ) value : value . tostring ( ) ; return integer . parseint ( str ) ; } catch ( throwable t ) { throw new runtimeexception ( str_ + value + str_ , t ) ; } }	Converts the specified value to a primitive integer value.
public static int getnumerictype ( int t1 , int t2 , boolean canbenonnumeric ) { if ( t1 == t2 ) return t1 ; if ( canbenonnumeric && ( t1 == nonnumeric || t2 == nonnumeric || t1 == char || t2 == char ) ) return nonnumeric ; if ( t1 == nonnumeric ) t1 = double ;	Returns the constant from the NumericTypes interface that best expresses the type of anoperation, which can be either numeric or not, on the two given types.
public static int getnumerictype ( object v1 , object v2 , boolean canbenonnumeric ) { return getnumerictype ( getnumerictype ( v1 ) , getnumerictype ( v2 ) , canbenonnumeric ) ; }	Returns the constant from the NumericTypes interface that best expresses the type of anoperation, which can be either numeric or not, on the two given objects.
public static number newinteger ( int type , long value ) { switch ( type ) { case bool : case char : case int : return new integer ( ( int ) value ) ; case float : if ( ( long ) ( float ) value == value ) { return new float ( ( float ) value ) ; }	Returns a new Number object of an appropriate type to hold the given integer value.
public evaluation popevaluation ( ) { evaluation result ; result = _currentevaluation ; setcurrentevaluation ( result . getparent ( ) ) ; if ( _currentevaluation == null ) { setlastevaluation ( getkeeplastevaluation ( ) ? result : null ) ; setrootevaluation ( null ) ; setcurrentnode ( null ) ; } return result ; }	Pops the current Evaluation off of the top of the stack.
protected string generateognlgetter ( ctclass clazz , ctmethod valuegetter , ctfield node ) throws exception { string body = str_ + node . getname ( ) + str_ ; valuegetter . setbody ( body ) ; clazz . addmethod ( valuegetter ) ; return body ; }	Fail safe getter creation when normal compilation fails.
protected string generateognlsetter ( ctclass clazz , ctmethod valuesetter , ctfield node ) throws exception { string body = node . getname ( ) + str_ ; valuesetter . setbody ( body ) ; clazz . addmethod ( valuesetter ) ; return body ; }	Fail safe setter creation when normal compilation fails.
protected void flattentree ( ) { boolean shouldflatten = bool_ ; int newsize = num_ ; for ( int i = num_ ; i < _children . length ; ++ i ) if ( _children [ i ] . getclass ( ) == getclass ( ) ) { shouldflatten = bool_ ; newsize += _children [ i ] . jjtgetnumchildren ( ) ; } else ++ newsize ; if ( shouldflatten ) { node [ ] newchildren = new node [ newsize ] ; int j = num_ ; for ( int i = num_ ; i < _children . length ; ++ i ) { node c = _children [ i ] ; if ( c . getclass ( ) == getclass ( ) ) { for ( int k = num_ ; k < c . jjtgetnumchildren ( ) ; ++ k ) newchildren [ j ++ ] = c . jjtgetchild ( k ) ; } else newchildren [ j ++ ] = c ; } if ( j != newsize ) throw new error ( str_ + j + str_ + newsize ) ; _children = newchildren ; } }	This method may be called from subclasses' jjtClose methods.
public void init ( simplenode node , object source , boolean setoperation ) { this . node = node ; this . source = source ; this . setoperation = setoperation ; result = null ; exception = null ; parent = null ; next = null ; previous = null ; firstchild = null ; lastchild = null ; }	Reinitializes this Evaluation to the parameters specified.
private char escapechar ( ) { int ofs = image . length ( ) - num_ ; switch ( image . charat ( ofs ) ) { case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; case str_ : return str_ ; }	Converts an escape sequence into a character value.
public static void setroot ( map context , object root ) { context . put ( ognlcontext . root_context_key , root ) ; }	Sets the root object to use for all expressions in the given context - doesn't necessarily replaceroot object instances explicitly passed in to other expression resolving methods on this class.
public static object getvalue ( string expression , map context , object root ) throws ognlexception { return getvalue ( expression , context , root , null ) ; }	Evaluates the given OGNL expression to extract a value from the given root object in a givencontext.
public static void setvalue ( expressionaccessor expression , ognlcontext context , object root , object value ) { expression . set ( context , root , value ) ; }	Sets the value given using the pre-compiled expression on the specified rootobject.
public static void setvalue ( object tree , object root , object value ) throws ognlexception { setvalue ( tree , createdefaultcontext ( root ) , root , value ) ; }	Evaluates the given OGNL expression tree to insert a value into the object graph rooted atthe given root object.
public static boolean isconstant ( string expression , map context ) throws ognlexception { return isconstant ( parseexpression ( expression ) , context ) ; }	Checks if the specified expression represents a constant expression.
public static string getdefaultwatchserviceid ( ) { string result = str_ ; string osname = system . getproperty ( str_ ) ; if ( osname != null ) { osname = osname . tolowercase ( locale . english ) ; if ( osname . contains ( str_ ) || osname . contains ( str_ ) ) { result = isatleastjava7 ( ) ? str_ : str_ ; } else if ( osname . contains ( str_ ) ) { result = str_ ; } } return result ; }	Returns default watch service identifier based on operating system.
@ override public synchronized object reload ( ) { object result = null ; try { boolean reloadrequired = buildlink . build ( ) ; if ( reloadrequired ) { int version = ++ classloaderversion ; string name = str_ + version + str_ ; currentapplicationclassloader = new delegatedresourcesclassloader ( name , tourls ( outputdirectories ) , baseloader ) ; result = currentapplicationclassloader ; } } catch ( malformedurlexception e ) { throw new unexpectedexception ( str_ , e ) ;	Contrary to its name, this doesn't necessarily reload the app.
protected archiver getarchiver ( string archivername ) throws nosucharchiverexception { archiver result = archivermanager . getarchiver ( archivername ) ; result . setduplicatebehavior ( archiver . duplicates_fail ) ;	Returns preconfigured archiver.
protected void checkarchiverforproblems ( archiver archiver ) { for ( resourceiterator iter = archiver . getresources ( ) ; iter . hasnext ( ) ; ) { iter . next ( ) ; } }	Check for potential "Duplicate file" exception before archive processing starts.
protected string readfileasstring ( file file ) throws ioexception { fileinputstream is = new fileinputstream ( file ) ; try { byte [ ] buffer = new byte [ num_ ] ; int len = is . read ( buffer ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; while ( len != - num_ ) { out . write ( buffer , num_ , len ) ; len = is . read ( buffer ) ; } return charsetname != null ? new string ( out . tobytearray ( ) , charsetname ) : new string ( out . tobytearray ( ) ) ; } finally { is . close ( ) ; } }	Reads the content of the file to a string.
protected project createproject ( ) { final project antproject = new project ( ) ; final projecthelper helper = projecthelper . getprojecthelper ( ) ; antproject . addreference ( projecthelper . projecthelper_reference , helper ) ; helper . getimportstack ( ) . addelement ( str_ ) ;	Creates and configures Ant project for Java task.
protected void addsystemproperty ( java java , string propertyname , string propertyvalue ) { environment . variable syspropplayhome = new environment . variable ( ) ; syspropplayhome . setkey ( propertyname ) ; syspropplayhome . setvalue ( propertyvalue ) ; java . addsysproperty ( syspropplayhome ) ; }	Adds string type system property to Ant Java task.
protected void addsystemproperty ( java java , string propertyname , file propertyvalue ) { environment . variable syspropplayhome = new environment . variable ( ) ; syspropplayhome . setkey ( propertyname ) ; syspropplayhome . setfile ( propertyvalue ) ; java . addsysproperty ( syspropplayhome ) ; }	Adds file type system property to Ant Java task.
private void changedirectory ( final file dir ) { if ( dir == null ) { debug ( str_ ) ; } else if ( ! dir . isdirectory ( ) ) { debug ( str_ ) ; } else { final file [ ] contents = dir . listfiles ( ) ; if ( contents != null ) { int numdirectories = num_ ; for ( final file f : contents ) { if ( f . isdirectory ( ) ) { numdirectories ++ ; } } mfilesindir = new file [ numdirectories ] ; mfilenames . clear ( ) ; for ( int i = num_ , counter = num_ ; i < numdirectories ; counter ++ ) { if ( contents [ counter ] . isdirectory ( ) ) { mfilesindir [ i ] = contents [ counter ] ; mfilenames . add ( contents [ counter ] . getname ( ) ) ; i ++ ; } } arrays . sort ( mfilesindir ) ; collections . sort ( mfilenames ) ; mselecteddir = dir ; mtxtvselectedfolder . settext ( dir . getabsolutepath ( ) ) ; mlistdirectoriesadapter . notifydatasetchanged ( ) ; mfileobserver = createfileobserver ( dir . getabsolutepath ( ) ) ; mfileobserver . startwatching ( ) ; debug ( str_ , dir . getabsolutepath ( ) ) ; } else { debug ( str_ ) ; } } refreshbuttonstate ( ) ; }	Change the directory that is currently being displayed.
private void refreshbuttonstate ( ) { final activity activity = getactivity ( ) ; if ( activity != null && mselecteddir != null ) { mbtnconfirm . setenabled ( isvalidfile ( mselecteddir ) ) ; getactivity ( ) . invalidateoptionsmenu ( ) ; } }	Changes the state of the buttons depending on the currently selected fileor folder.
private fileobserver createfileobserver ( final string path ) { return new fileobserver ( path , fileobserver . create | fileobserver . delete | fileobserver . moved_from | fileobserver . moved_to ) { @ override public void onevent ( final int event , final string path ) { debug ( str_ , event ) ; final activity activity = getactivity ( ) ; if ( activity != null ) { activity . runonuithread ( new runnable ( ) { @ override public void run ( ) { refreshdirectory ( ) ; } } ) ; } } } ; }	Sets up a FileObserver to watch the current directory.
private void returnselectedfolder ( ) { if ( mselecteddir != null ) { debug ( str_ , mselecteddir . getabsolutepath ( ) ) ; mlistener . foreach ( new unitfunction < onfragmentinteractionlistener > ( ) { @ override public void apply ( final onfragmentinteractionlistener f ) { f . onselectdirectory ( mselecteddir . getabsolutepath ( ) ) ; } } ) ; } else { mlistener . foreach ( new unitfunction < onfragmentinteractionlistener > ( ) { @ override public void apply ( final onfragmentinteractionlistener f ) { f . oncancelchooser ( ) ; } } ) ; } }	Returns the selected folder as a result to the activity the fragment's attached to.
private int createfolder ( ) { if ( mnewdirectoryname != null && mselecteddir != null && mselecteddir . canwrite ( ) ) { final file newdir = new file ( mselecteddir , mnewdirectoryname ) ; if ( newdir . exists ( ) ) { return r . string . create_folder_error_already_exists ; } else { final boolean result = newdir . mkdir ( ) ; if ( result ) { return r . string . create_folder_success ; } else { return r . string . create_folder_error ; } } } else if ( mselecteddir != null && ! mselecteddir . canwrite ( ) ) { return r . string . create_folder_error_no_write_access ; } else { return r . string . create_folder_error ; } }	Creates a new folder in the current directory with the nameCREATE_DIRECTORY_NAME.
private boolean isvalidfile ( final file file ) { return ( file != null && file . isdirectory ( ) && file . canread ( ) && ( mconfig . allowreadonlydirectory ( ) || file . canwrite ( ) ) ) ; }	Returns true if the selected file or directory would be valid selection.
public void startbackgroundjob ( int msgid , runnable runnable ) {	Start a background job showing a progress bar as long as the job runs.This seems contradictory but with background job we mean one that runs offthe ui thread to prevent an ANR.We still have to wait for the processing to be done because we need the result.
private void startlist ( boolean isorderedlist , attributes attributes ) { boolean isindentation = isindentation ( attributes ) ; paragraphtype newtype = isindentation && isorderedlist ? paragraphtype . indentation_ol : isindentation && ! isorderedlist ? paragraphtype . indentation_ul : isorderedlist ? paragraphtype . numbering : paragraphtype . bullet ; accumulatedparagraphstyle currentstyle = mparagraphstyles . isempty ( ) ? null : mparagraphstyles . peek ( ) ; if ( currentstyle == null ) {	Handles OL and UL start tags.
private void endlist ( boolean orderedlist ) { if ( ! mparagraphstyles . isempty ( ) ) { accumulatedparagraphstyle style = mparagraphstyles . peek ( ) ; paragraphtype type = style . gettype ( ) ; if ( ( orderedlist && ( type . isnumbering ( ) || type == paragraphtype . indentation_ol ) ) || ( ! orderedlist && ( type . isbullet ( ) || type == paragraphtype . indentation_ul ) ) ) {	Handles OL and UL end tags.
void handlemotion ( int edge , float dx , float dy ) { rect r = computelayout ( ) ; if ( edge == grow_none ) { return ; } else if ( edge == move ) {	The "edge" parameter specifies which edges the user is dragging.
public rect getcroprect ( ) { return new rect ( ( int ) mcroprect . left , ( int ) mcroprect . top , ( int ) mcroprect . right , ( int ) mcroprect . bottom ) ; }	Returns the cropping rectangle in image space.
private rect computelayout ( ) { rectf r = new rectf ( mcroprect . left , mcroprect . top , mcroprect . right , mcroprect . bottom ) ; mmatrix . maprect ( r ) ; return new rect ( math . round ( r . left ) , math . round ( r . top ) , math . round ( r . right ) , math . round ( r . bottom ) ) ; }	Maps the cropping rectangle from image space to screen space.
void register ( rtedittextlistener listener , rtmediafactory < rtimage , rtaudio , rtvideo > mediafactory ) { mlistener = listener ; mmediafactory = mediafactory ; }	This needs to be called before anything else because we need the mediafactory.
private void addspanwatcher ( ) { spannable spannable = gettext ( ) ; if ( spannable . getspans ( num_ , spannable . length ( ) , getclass ( ) ) != null ) { spannable . setspan ( this , num_ , spannable . length ( ) , spanned . span_inclusive_inclusive ) ; } }	Add a SpanWatcher for the Changeable implementation.
@ suppresslint ( str_ ) @ override public final view getview ( int position , view convertview , viewgroup parent ) { view spinnerview = minflater . inflate ( mspinnerid , parent , bool_ ) ; mparent = parent ; textview spinnertitleview = ( textview ) spinnerview . findviewbyid ( r . id . title ) ; updatespinnertitle ( spinnertitleview ) ; return spinnerview ; }	This method returns the spinner view.
@ suppresslint ( str_ ) @ override public view getdropdownview ( int position , view convertview , viewgroup parent ) { spinneritem spinneritem = mitems . get ( position ) ; spinneritem . setonchangedlistener ( this , position ) ;	Returns the spinner entry view.
public rthtml < rtimage , rtaudio , rtvideo > convert ( final spanned text , rtformat . html rtformat ) { mtext = text ; mrtformat = rtformat ; mout = new stringbuilder ( ) ; mimages = new arraylist < > ( ) ; mparagraphstyles . clear ( ) ;	Converts a spanned text to HTML.
private void withinparagraph ( final spanned text , int start , int end ) {	Convert a spanned text within a paragraph.
public static file createuniquefile ( file targetfolder , string originalfile , boolean keeporiginal ) { string mimetype = mimetypemap . getsingleton ( ) . getmimetypefromextension ( originalfile ) ; return createuniquefile ( targetfolder , originalfile , mimetype , keeporiginal ) ; }	Creates a file with a non-conflicting file name in a specified folder based on an existing file name.
public static string determineoriginalfile ( context context , uri uri ) throws illegalargumentexception { string originalfile = null ; if ( uri != null ) {	Retrieve local file path for an arbitrary Uri.
public string namespace ( string name , boolean attribute ) { int colon = name . indexof ( str_ ) ; if ( colon == - num_ ) { return attribute ? str_ : theschema . geturi ( ) ; } string prefix = name . substring ( num_ , colon ) ; if ( prefix . equals ( str_ ) ) { return str_ ; } else { return ( str_ + prefix ) . intern ( ) ; } }	Return a namespace name from a Qname.
public string localname ( string name ) { int colon = name . indexof ( str_ ) ; if ( colon == - num_ ) { return name ; } else { return name . substring ( colon + num_ ) . intern ( ) ; } }	Return a local name from a Qname.
public void setattribute ( attributesimpl atts , string name , string type , string value ) { if ( name . equals ( str_ ) || name . startswith ( str_ ) ) { return ; } ; string namespace = namespace ( name , bool_ ) ; string localname = localname ( name ) ; int i = atts . getindex ( name ) ; if ( i == - num_ ) { name = name . intern ( ) ; if ( type == null ) type = str_ ; if ( ! type . equals ( str_ ) ) value = normalize ( value ) ; atts . addattribute ( namespace , localname , name , type , value ) ; } else { if ( type == null ) type = atts . gettype ( i ) ; if ( ! type . equals ( str_ ) ) value = normalize ( value ) ; atts . setattribute ( i , namespace , localname , name , type , value ) ; } }	Sets an attribute and its value into an AttributesImpl object.
public void setattribute ( string name , string type , string value ) { setattribute ( theatts , name , type , value ) ; }	Sets an attribute and its value into this element type.
static string getfontname ( string filepath ) { ttfrandomaccessfile in = null ; try { randomaccessfile file = new randomaccessfile ( filepath , str_ ) ; in = new ttfrandomaccessfile ( file ) ; return getttffontname ( in , filepath ) ; } catch ( ioexception e ) { return null ;	Retrieve the file name for a system font.
static string getfontname ( assetmanager assets , string filepath ) { ttfassetinputstream in = null ; try { inputstream file = assets . open ( filepath , assetmanager . access_random ) ; in = new ttfassetinputstream ( file ) ; return getttffontname ( in , filepath ) ; } catch ( filenotfoundexception e ) { return null ;	Retrieve the file name for a font in the asset folder.
private void neednewbuffer ( int newcount ) { if ( currentbufferindex < buffers . size ( ) - num_ ) {	Makes a new buffer available either by allocatinga new one or re-cycling an existing one.
@ override public void write ( byte [ ] b , int off , int len ) { if ( ( off < num_ ) || ( off > b . length ) || ( len < num_ ) || ( ( off + len ) > b . length ) || ( ( off + len ) < num_ ) ) { throw new indexoutofboundsexception ( ) ; } else if ( len == num_ ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int inbufferpos = count - filledbuffersum ; while ( remaining > num_ ) { int part = math . min ( remaining , currentbuffer . length - inbufferpos ) ; system . arraycopy ( b , off + len - remaining , currentbuffer , inbufferpos , part ) ; remaining -= part ; if ( remaining > num_ ) { neednewbuffer ( newcount ) ; inbufferpos = num_ ; } } count = newcount ; } }	Write the bytes to byte array.
@ override public synchronized void write ( int b ) { int inbufferpos = count - filledbuffersum ; if ( inbufferpos == currentbuffer . length ) { neednewbuffer ( count + num_ ) ; inbufferpos = num_ ; } currentbuffer [ inbufferpos ] = ( byte ) b ; count ++ ; }	Write a byte to byte array.
public synchronized int write ( inputstream in ) throws ioexception { int readcount = num_ ; int inbufferpos = count - filledbuffersum ; int n = in . read ( currentbuffer , inbufferpos , currentbuffer . length - inbufferpos ) ; while ( n != - num_ ) { readcount += n ; inbufferpos += n ; count += n ; if ( inbufferpos == currentbuffer . length ) { neednewbuffer ( currentbuffer . length ) ; inbufferpos = num_ ; } n = in . read ( currentbuffer , inbufferpos , currentbuffer . length - inbufferpos ) ; } return readcount ; }	Writes the entire contents of the specified input stream to thisbyte stream.
public synchronized void writeto ( outputstream out ) throws ioexception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; out . write ( buf , num_ , c ) ; remaining -= c ; if ( remaining == num_ ) { break ; } } }	Writes the entire contents of this byte stream to thespecified output stream.
public synchronized byte [ ] tobytearray ( ) { int remaining = count ; if ( remaining == num_ ) { return empty_byte_array ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = num_ ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , num_ , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == num_ ) { break ; } } return newbuf ; }	Gets the curent contents of this byte stream as a byte array.The result is independent of this stream.
@ override public void setfontsize ( int size ) { if ( mfontsize != null ) { if ( size <= num_ ) { mfontsizeadapter . updatespinnertitle ( str_ ) ; mfontsizeadapter . setselecteditem ( num_ ) ; mfontsize . setselection ( num_ ) ; } else { size = helper . convertsptopx ( size ) ; mfontsizeadapter . updatespinnertitle ( integer . tostring ( size ) ) ; for ( int pos = num_ ; pos < mfontsizeadapter . getcount ( ) ; pos ++ ) { fontsizespinneritem item = mfontsizeadapter . getitem ( pos ) ; if ( size == item . getfontsize ( ) ) { mfontsizeadapter . setselecteditem ( pos ) ; mfontsize . setselection ( pos ) ; break ; } } } } }	Set the text size.
public static string separatorstounix ( string path ) { if ( path == null || path . indexof ( windows_separator ) == - num_ ) { return path ; } return path . replace ( windows_separator , unix_separator ) ; }	Converts all separators to the Unix separator of forward slash.
private void recomputefocus ( motionevent event ) { for ( int i = num_ ; i < mhighlightviews . size ( ) ; i ++ ) { highlightview hv = mhighlightviews . get ( i ) ; hv . setfocus ( bool_ ) ; hv . invalidate ( ) ; } for ( int i = num_ ; i < mhighlightviews . size ( ) ; i ++ ) { highlightview hv = mhighlightviews . get ( i ) ; int edge = hv . gethit ( event . getx ( ) , event . gety ( ) ) ; if ( edge != highlightview . grow_none ) { if ( ! hv . hasfocus ( ) ) { hv . setfocus ( bool_ ) ; hv . invalidate ( ) ; } break ; } } invalidate ( ) ; }	hitting cropping rectangle.
private void ensurevisible ( highlightview hv ) { rect r = hv . mdrawrect ; int pandeltax1 = math . max ( num_ , mleft - r . left ) ; int pandeltax2 = math . min ( num_ , mright - r . right ) ; int pandeltay1 = math . max ( num_ , mtop - r . top ) ; int pandeltay2 = math . min ( num_ , mbottom - r . bottom ) ; int pandeltax = pandeltax1 != num_ ? pandeltax1 : pandeltax2 ; int pandeltay = pandeltay1 != num_ ? pandeltay1 : pandeltay2 ; if ( pandeltax != num_ || pandeltay != num_ ) { panby ( pandeltax , pandeltay ) ; } }	Pan the displayed image to make sure the cropping rectangle is visible.
private void centerbasedonhighlightview ( highlightview hv ) { rect drawrect = hv . mdrawrect ; float width = drawrect . width ( ) ; float height = drawrect . height ( ) ; float thiswidth = getwidth ( ) ; float thisheight = getheight ( ) ; float z1 = thiswidth / width * num_ ; float z2 = thisheight / height * num_ ; float zoom = math . min ( z1 , z2 ) ; zoom = zoom * this . getscale ( ) ; zoom = math . max ( num_ , zoom ) ; if ( ( math . abs ( zoom - getscale ( ) ) / zoom ) > num_ ) { float [ ] coordinates = new float [ ] { hv . mcroprect . centerx ( ) , hv . mcroprect . centery ( ) } ; getimagematrix ( ) . mappoints ( coordinates ) ; zoomto ( zoom , coordinates [ num_ ] , coordinates [ num_ ] , num_ ) ; } ensurevisible ( hv ) ; }	view's center and scale according to the cropping rectangle.
public void resetdocumentlocator ( string publicid , string systemid ) { thepublicid = publicid ; thesystemid = systemid ; thelastline = thelastcolumn = thecurrentline = thecurrentcolumn = num_ ; }	Reset document locator, supplying systemid and publicid.
public string validate ( string value ) { if ( value == null ) { return null ; } for ( int i = num_ ; i < patterns . length ; i ++ ) { matcher matcher = patterns [ i ] . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . groupcount ( ) ; if ( count == num_ ) { return matcher . group ( num_ ) ; } stringbuffer buffer = new stringbuffer ( ) ; for ( int j = num_ ; j < count ; j ++ ) { string component = matcher . group ( j + num_ ) ; if ( component != null ) { buffer . append ( component ) ; } } return buffer . tostring ( ) ; } } return null ; }	Validate a value against the set of regular expressionsreturning a String value of the aggregated groups.
@ suppresslint ( str_ ) public void elementtype ( string name , int model , int memberof , int flags ) { elementtype e = new elementtype ( name , model , memberof , flags , this ) ; theelementtypes . put ( name . tolowercase ( ) , e ) ; if ( memberof == m_root ) theroot = e ; }	Add or replace an element type for this schema.
public void attribute ( string elemname , string attrname , string type , string value ) { elementtype e = getelementtype ( elemname ) ; if ( e == null ) { throw new error ( str_ + attrname + str_ + elemname ) ; } e . setattribute ( attrname , type , value ) ; }	Add or replace a default attribute for an element type in this schema.
public void parent ( string name , string parentname ) { elementtype child = getelementtype ( name ) ; elementtype parent = getelementtype ( parentname ) ; if ( child == null ) { throw new error ( str_ + name + str_ + parentname ) ; } if ( parent == null ) { throw new error ( str_ + parentname + str_ + name ) ; } child . setparent ( parent ) ; }	Specify natural parent of an element in this schema.
@ suppresslint ( str_ ) public elementtype getelementtype ( string name ) { return ( elementtype ) ( theelementtypes . get ( name . tolowercase ( ) ) ) ; }	Get an ElementType by name.
public int getentity ( string name ) {	Get an entity value by name.
public static void cleanupparagraphs ( rtedittext editor , effect ... exclude ) { cleanupparagraphs ( editor , effects . alignment , exclude ) ; cleanupparagraphs ( editor , effects . indentation , exclude ) ; cleanupparagraphs ( editor , effects . bullet , exclude ) ; cleanupparagraphs ( editor , effects . number , exclude ) ; }	This important method makes sure that all paragraph effects are applied to whole paragraphs.While it's optimized for performance it's still an expensive operation so it shouldn't becalled too often.
public void applytoselection ( rtedittext editor , v value ) { selection selection = getselection ( editor ) ;	Apply this effect to the selection.If value is Null then the effect will be removed from the current selection.
protected boolean isvaliddomain ( string domain ) {	Returns true if the domain component of an email address is valid.
synchronized void executed ( rtedittext editor , operation op ) { stack < operation > undostack = getundostack ( editor ) ; stack < operation > redostack = getredostack ( editor ) ;	Call this when an operation is performed to add it to the undo stack.
synchronized void redo ( rtedittext editor ) { stack < operation > redostack = getredostack ( editor ) ; if ( ! redostack . empty ( ) ) { stack < operation > undostack = getundostack ( editor ) ; operation op = redostack . pop ( ) ; push ( op , undostack ) ; op . redo ( editor ) ; while ( ! redostack . empty ( ) && op . canmerge ( redostack . peek ( ) ) ) { op = redostack . pop ( ) ; push ( op , undostack ) ; op . redo ( editor ) ; } } }	Re-do the last undone operation for a specific rich text editor.
private static string replaceall ( string source , string search , string replace ) { if ( use_replace_all ) { return source . replaceall ( search , replace ) ; } else { pattern p = pattern . compile ( search ) ; matcher m = p . matcher ( source ) ; stringbuffer sb = new stringbuffer ( ) ; boolean atleastonefound = bool_ ; while ( m . find ( ) ) { m . appendreplacement ( sb , replace ) ; atleastonefound = bool_ ; } if ( atleastonefound ) { m . appendtail ( sb ) ; return sb . tostring ( ) ; } else { return source ; } } }	A memory optimized algorithm for String.replaceAll.
private synchronized threadstatus getorcreatethreadstatus ( thread t ) { threadstatus status = mthreadstatus . get ( t ) ; if ( status == null ) { status = new threadstatus ( ) ; mthreadstatus . put ( t , status ) ; } return status ; }	Get thread status and create one if specified.
private synchronized void setdecodingoptions ( thread t , bitmapfactory . options options ) { getorcreatethreadstatus ( t ) . moptions = options ; }	The following three methods are used to keep track ofBitmapFaction.Options used for decoding and cancelling.
public synchronized boolean canthreaddecoding ( thread t ) { threadstatus status = mthreadstatus . get ( t ) ; if ( status == null ) {	The following three methods are used to keep track of which thread isbeing disabled for bitmap decoding.
public bitmap decodefiledescriptor ( filedescriptor fd , bitmapfactory . options options ) { if ( options . mcancel ) { return null ; } thread thread = thread . currentthread ( ) ; if ( ! canthreaddecoding ( thread ) ) { return null ; } setdecodingoptions ( thread , options ) ; bitmap b = bitmapfactory . decodefiledescriptor ( fd , null , options ) ; removedecodingoptions ( thread ) ; return b ; }	The real place to delegate bitmap decoding to BitmapFactory.
public static sortedset < rttypeface > getfonts ( context context ) { map < string , string > assetfonts = getassetfonts ( context ) ; assetmanager assets = context . getresources ( ) . getassets ( ) ; for ( string fontname : assetfonts . keyset ( ) ) { string filepath = assetfonts . get ( fontname ) ; if ( ! all_fonts . contains ( fontname ) ) { try { typeface typeface = typeface . createfromasset ( assets , filepath ) ; all_fonts . add ( new rttypeface ( fontname , typeface ) ) ; } catch ( exception e ) {	Retrieve the fonts from the asset and the system folder.
private static map < string , string > getassetfonts ( context context ) { synchronized ( asset_fonts_by_name ) { if ( asset_fonts_by_name . isempty ( ) ) { assetmanager assets = context . getresources ( ) . getassets ( ) ; collection < string > fontfiles = assetindex . getassetindex ( context ) ; if ( fontfiles == null || fontfiles . isempty ( ) ) { fontfiles = listfontfiles ( context . getresources ( ) ) ; } for ( string filepath : fontfiles ) { if ( filepath . tolowercase ( locale . getdefault ( ) ) . endswith ( str_ ) ) { string fontname = ttfanalyzer . getfontname ( assets , filepath ) ; if ( fontname == null ) { fontname = getfilename ( filepath ) ; } asset_fonts_by_name . put ( fontname , filepath ) ; } } } return asset_fonts_by_name ; } }	Retrieve the fonts from the asset folder.
private static map < string , string > getsystemfonts ( ) { synchronized ( system_fonts_by_name ) { for ( string fontdir : font_dirs ) { file dir = new file ( fontdir ) ; if ( ! dir . exists ( ) ) continue ; file [ ] files = dir . listfiles ( ) ; if ( files == null ) continue ; for ( file file : files ) { string filepath = file . getabsolutepath ( ) ; if ( ! system_fonts_by_path . containskey ( filepath ) ) { string fontname = ttfanalyzer . getfontname ( file . getabsolutepath ( ) ) ; if ( fontname == null ) { fontname = getfilename ( filepath ) ; } system_fonts_by_path . put ( filepath , fontname ) ; system_fonts_by_name . put ( fontname , filepath ) ; } } } return system_fonts_by_name ; } }	Retrieve the fonts from the system folders.
private void setup ( ) { if ( theschema == null ) theschema = new htmlschema ( ) ; if ( thescanner == null ) thescanner = new htmlscanner ( ) ; if ( theautodetector == null ) { theautodetector = new autodetector ( ) { public reader autodetectingreader ( inputstream i ) { return new inputstreamreader ( i ) ; } } ; } thestack = new element ( theschema . getelementtype ( str_ ) , defaultattributes ) ; thepcdata = new element ( theschema . getelementtype ( str_ ) , defaultattributes ) ; thenewelement = null ; theattributename = null ; thepitarget = null ; thesaved = null ; theentity = num_ ; virginstack = bool_ ; thedoctypename = thedoctypepublicid = thedoctypesystemid = null ; }	Sets up instance variables that haven't been set by setFeature.
private reader getreader ( inputsource s ) throws saxexception , ioexception { reader r = s . getcharacterstream ( ) ; inputstream i = s . getbytestream ( ) ; string encoding = s . getencoding ( ) ; string publicid = s . getpublicid ( ) ; string systemid = s . getsystemid ( ) ; if ( r == null ) { if ( i == null ) i = getinputstream ( publicid , systemid ) ;	Buffer both the InputStream and the Reader.
private inputstream getinputstream ( string publicid , string systemid ) throws ioexception , saxexception { url basis = new url ( str_ , str_ , system . getproperty ( str_ ) + str_ ) ; url url = new url ( basis , systemid ) ; urlconnection c = url . openconnection ( ) ; return c . getinputstream ( ) ; }	Get an InputStream based on a publicid and a systemid.
@ override public void adup ( char [ ] buff , int offset , int length ) throws saxexception { if ( thenewelement != null && theattributename != null ) { thenewelement . setattribute ( theattributename , null , theattributename ) ; theattributename = null ; } }	needs to support chars past U+FFFF.
private string expandentities ( string src ) { int refstart = - num_ ; int len = src . length ( ) ; char [ ] dst = new char [ len ] ; int dstlen = num_ ; for ( int i = num_ ; i < len ; i ++ ) { char ch = src . charat ( i ) ; dst [ dstlen ++ ] = ch ; if ( ch == str_ && refstart == - num_ ) {	with a semicolon.
private int lookupentity ( char [ ] buff , int offset , int length ) { int result = num_ ; if ( length < num_ ) return result ;	deferring to the schema for named ones.
private void restart ( element e ) throws saxexception { while ( thesaved != null && thestack . cancontain ( thesaved ) && ( e == null || thesaved . cancontain ( e ) ) ) { element next = thesaved . next ( ) ; push ( thesaved ) ; thesaved = next ; } }	e is the next element to be started, if we know what it is.
private void pop ( ) throws saxexception { if ( thestack == null ) return ;	Pop the stack irrevocably.
private void restartablypop ( ) throws saxexception { element popped = thestack ; pop ( ) ; if ( restartelements && ( popped . flags ( ) & schema . f_restart ) != num_ ) { popped . anonymize ( ) ; popped . setnext ( thesaved ) ; thesaved = popped ; } }	Pop the stack restartably.
private string prefixof ( string name ) { int i = name . indexof ( str_ ) ; string prefix = str_ ; if ( i != - num_ ) prefix = name . substring ( num_ , i ) ; return prefix ; }	Get the prefix from a QName.
private boolean foreign ( string prefix , string namespace ) {	Return true if we have a foreign name.
private static string trimquotes ( string in ) { if ( in == null ) return in ; int length = in . length ( ) ; if ( length == num_ ) return in ; char s = in . charat ( num_ ) ; char e = in . charat ( length - num_ ) ; if ( s == e && ( s == str_ || s == str_ ) ) { in = in . substring ( num_ , in . length ( ) - num_ ) ; } return in ; }	If the String is quoted, trim the quotes.
private static string [ ] split ( string val ) throws illegalargumentexception { val = val . trim ( ) ; if ( val . length ( ) == num_ ) { return new string [ num_ ] ; } else { arraylist < string > l = new arraylist < string > ( ) ; int s = num_ ; int e = num_ ; boolean sq = bool_ ;	Recognises quotes around a phrase and doesn't split it.
private void rectify ( element e ) throws saxexception { element sp ; while ( bool_ ) { for ( sp = thestack ; sp != null ; sp = sp . next ( ) ) { if ( sp . cancontain ( e ) ) break ; } if ( sp != null ) break ; elementtype parenttype = e . parent ( ) ; if ( parenttype == null ) break ; element parent = new element ( parenttype , defaultattributes ) ;	so that the argument can be safely pushed.
public void onsaveinstancestate ( bundle outstate ) { outstate . putstring ( str_ , mtoolbarvisibility . name ( ) ) ; outstate . putboolean ( str_ , mtoolbarisvisible ) ; outstate . putint ( str_ , mactiveeditor ) ; if ( mlinkselection != null ) { outstate . putserializable ( str_ , mlinkselection ) ; } }	Called to retrieve per-instance state before being killed so that thestate can be restored in the constructor.
public void ondestroy ( boolean issaved ) { eventbus . getdefault ( ) . unregister ( this ) ; for ( rtedittext editor : meditors . values ( ) ) { editor . unregister ( ) ; editor . ondestroy ( issaved ) ; } meditors . clear ( ) ; for ( rttoolbar toolbar : mtoolbars . values ( ) ) { toolbar . removetoolbarlistener ( ) ; } mtoolbars . clear ( ) ; mrtapi = null ; }	Perform any final cleanup before the component is destroyed.
@ subscribe ( sticky = bool_ , threadmode = threadmode . main ) public void oneventmainthread ( mediaevent event ) { rtedittext editor = meditors . get ( mactiveeditor ) ; rtmedia media = event . getmedia ( ) ; if ( editor != null && media instanceof rtimage ) { insertimage ( editor , ( rtimage ) media ) ; eventbus . getdefault ( ) . removestickyevent ( event ) ; mactiveeditor = integer . max_value ; } }	Media file was picked -> process the result.
@ subscribe ( threadmode = threadmode . main ) public void oneventmainthread ( linkevent event ) { final string fragmenttag = event . getfragmenttag ( ) ; mrtapi . removefragment ( fragmenttag ) ; if ( ! event . wascancelled ( ) && id_01_link_fragment . equals ( fragmenttag ) ) { rtedittext editor = getactiveeditor ( ) ; if ( editor != null ) { link link = event . getlink ( ) ; string url = null ; if ( link != null && link . isvalid ( ) ) {	LinkFragment has closed -> process the result.
private void getproperbasematrix ( rotatebitmap bitmap , matrix matrix ) { float viewwidth = getwidth ( ) ; float viewheight = getheight ( ) ; float w = bitmap . getwidth ( ) ; float h = bitmap . getheight ( ) ; matrix . reset ( ) ;	Setup the base matrix so that the image is centered and scaled properly.
protected float maxzoom ( ) { if ( mbitmapdisplayed . getbitmap ( ) == null ) { return num_ ; } float fw = ( float ) mbitmapdisplayed . getwidth ( ) / ( float ) mthiswidth ; float fh = ( float ) mbitmapdisplayed . getheight ( ) / ( float ) mthisheight ; float max = math . max ( fw , fh ) * num_ ; return max ; }	rather than the current 1024x768, this should be changed down to 200%.
final public boolean existsinselection ( rtedittext editor ) { selection selection = getselection ( editor ) ; list < rtspan < v > > spans = getspans ( editor . gettext ( ) , selection , spancollectmode . span_flags ) ; return ! spans . isempty ( ) ; }	Check whether the effect exists in the currently selected text of the active RTEditText.
protected void findspans2remove ( spannable str , paragraph paragraph , paragraphspanprocessor < v > spanprocessor ) { list < rtspan < v > > spans = getspans ( str , paragraph , spancollectmode . exact ) ; spanprocessor . removespans ( spans , paragraph ) ; }	Find spans within that paragraph and add them to the ParagraphSpanProcessor to be removedonce the ParagraphSpanProcessor processes its spans.
public static boolean pickdirectory ( activity activity , file startpath , int requestcode ) { packagemanager packagemgr = activity . getpackagemanager ( ) ; for ( string [ ] intent : pick_directory_intents ) { string intentaction = intent [ num_ ] ; string uriprefix = intent [ num_ ] ; intent startintent = new intent ( intentaction ) . putextra ( str_ , activity . getstring ( r . string . save_as ) ) . setdata ( uri . parse ( uriprefix + startpath . getpath ( ) ) ) ; try { if ( startintent . resolveactivity ( packagemgr ) != null ) { activity . startactivityforresult ( startintent , requestcode ) ; return bool_ ; } } catch ( activitynotfoundexception e ) { shownofilepickererror ( activity , e ) ; } } return bool_ ; }	Tries to open a known file browsers to pick a directory.
private bitmap rotateimage ( bitmap src , float degree ) {	Thong added for rotate.
public void setoutput ( writer writer ) { if ( writer == null ) { output = new outputstreamwriter ( system . out ) ; } else { output = writer ; } }	Set a new output destination for the document.
private void write ( char c ) throws saxexception { try { output . write ( c ) ; } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	Write a raw character.
private void write ( string s ) throws saxexception { try { output . write ( s ) ; } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	Write a raw string.
private boolean booleanattribute ( string localname , string qname , string value ) { string name = localname ; if ( name == null ) { int i = qname . indexof ( str_ ) ; if ( i != - num_ ) name = qname . substring ( i + num_ , qname . length ( ) ) ; } if ( ! name . equals ( value ) ) return bool_ ; for ( int j = num_ ; j < booleans . length ; j ++ ) { if ( name . equals ( booleans [ j ] ) ) return bool_ ; } return bool_ ; }	Return true if the attribute is an HTML boolean from the above list.
private void writeescutf16 ( string s , int start , int length , boolean isattval ) throws saxexception { string substring = s . substring ( start , start + length ) ; write ( stringescapeutils . escapehtml4 ( substring ) ) ; }	Write an array of data characters with escaping.
@ suppresswarnings ( str_ ) private void writensdecls ( ) throws saxexception { enumeration < string > prefixes = ( enumeration < string > ) nssupport . getdeclaredprefixes ( ) ; while ( prefixes . hasmoreelements ( ) ) { string prefix = ( string ) prefixes . nextelement ( ) ; string uri = nssupport . geturi ( prefix ) ; if ( uri == null ) { uri = str_ ; } write ( str_ ) ; if ( str_ . equals ( prefix ) ) { write ( str_ ) ; } else { write ( str_ ) ; write ( prefix ) ; write ( str_ ) ; } writeescutf16 ( uri , num_ , uri . length ( ) , bool_ ) ; write ( str_ ) ; } }	Write out the list of Namespace declarations.
private void writename ( string uri , string localname , string qname , boolean iselement ) throws saxexception { string prefix = doprefix ( uri , qname , iselement ) ; if ( prefix != null && ! str_ . equals ( prefix ) ) { write ( prefix ) ; write ( str_ ) ; } if ( localname != null && ! str_ . equals ( localname ) ) { write ( localname ) ; } else { int i = qname . indexof ( str_ ) ; write ( qname . substring ( i + num_ , qname . length ( ) ) ) ; } }	Write an element or attribute name.
private static void createstreamifnotexists ( amazonkinesis kinesis , string streamname , int shardcount ) { performamazonactionwithretry ( str_ , ( ) -> { describestreamrequest describestreamrequest = new describestreamrequest ( ) . withstreamname ( streamname ) . withlimit ( num_ ) ; try { kinesis . describestream ( describestreamrequest ) ; } catch ( resourcenotfoundexception e ) { kinesis . createstream ( streamname , shardcount ) ; } return null ; } , default_retry_count , default_retry_duration_in_millis ) ; }	Create a stream if it does not already exist.
private static void waitstreamactivation ( amazonkinesis consumer , string streamname , long streamcreationtimeoutmillis ) { describestreamrequest describestreamrequest = new describestreamrequest ( ) . withstreamname ( streamname ) . withlimit ( num_ ) ; describestreamresult describestreamresult = null ; string streamstatus = null ; long endtime = system . currenttimemillis ( ) + streamcreationtimeoutmillis ; do { try { describestreamresult = consumer . describestream ( describestreamrequest ) ; streamstatus = describestreamresult . getstreamdescription ( ) . getstreamstatus ( ) ; if ( active_stream_status . equals ( streamstatus ) ) { break ; } thread . sleep ( num_ ) ; } catch ( resourcenotfoundexception | limitexceededexception ignored ) {	Waits that the stream has been created.
private static void completestoresnapshotwithmissinginstancesnapshots ( path targetstorespath ) { string transactionidregexalone = str_ ; string transactionidregexreplace = str_ ; pattern transactionidpattern = compile ( transactionidregexalone ) ; set < file > previoussnapshots = new hashset < > ( ) ; arrays . stream ( targetstorespath . resolve ( snapshot_directory_name ) . tofile ( ) . listfiles ( ) ) . sorted ( ) . foreach ( snapshot -> { set < string > snapshotnames = arrays . stream ( snapshot . listfiles ( ) ) . map ( file :: getname ) . collect ( toset ( ) ) ; previoussnapshots . stream ( ) . filter ( previoussnapshot -> ! snapshotnames . contains ( previoussnapshot . getname ( ) ) ) . foreach ( previoussnapshot -> { try { path targetpath = snapshot . topath ( ) . resolve ( previoussnapshot . getname ( ) ) ; path sourcepath = previoussnapshot . topath ( ) ; long count = counttransactionid ( transactionidpattern , sourcepath ) ; if ( count != num_ ) { throw new storeexception ( str_ , args -> args . add ( str_ , count ) ) ; } biginteger newtransactionid = new biginteger ( snapshot . getname ( ) ) ; replacetransactionidvalue ( transactionidregexreplace , sourcepath , targetpath , newtransactionid . tostring ( ) ) ; } catch ( ioexception e ) { throw new uncheckedioexception ( e ) ; } } ) ; previoussnapshots . clear ( ) ; previoussnapshots . addall ( arrays . stream ( snapshot . listfiles ( ) ) . collect ( toset ( ) ) ) ; } ) ; }	Complete snapshot N with lacking instance snapshots from snapshot N - 1.
private boolean waittheminimaldurationtoexecutethenextprovisioningrequest ( ) { if ( m_lastgetsharditeratorrequesttime != null ) { long delay = m_durationbetweenrequests . get ( ) - ( system . currenttimemillis ( ) - m_lastgetsharditeratorrequesttime ) ; if ( delay > num_ ) { try { thread . sleep ( delay ) ; } catch ( interruptedexception e ) { thread . currentthread ( ) . interrupt ( ) ; return bool_ ; } } } m_lastgetsharditeratorrequesttime = system . currenttimemillis ( ) ; return bool_ ; }	Wait that the minimum duration between two GetShardIteratorRequests has elapsed.
@ nullable private list < record > getrecords ( getrecordsrequest getrecordsrequest ) { return tryamazonaction ( str_ , ( ) -> { getrecordsresult getrecordsresult = m_kinesis . getrecords ( getrecordsrequest ) ; m_sharditerator = getrecordsresult . getnextsharditerator ( ) ; list < record > records = getrecordsresult . getrecords ( ) ; log . trace ( str_ , args -> args . add ( str_ , m_streamname ) . add ( str_ , records . size ( ) ) . add ( str_ , getrecordsresult . getmillisbehindlatest ( ) ) ) ; return records ; } , m_durationbetweenrequests ) . orelse ( list . of ( ) ) ; }	Retrieves records corresponding to the request.
public static < t > t performamazonactionwithretry ( string actionlabel , supplier < t > action , int retrylimit , int durationinmillis ) { int retrycount = num_ ; do { try { return action . get ( ) ; } catch ( limitexceededexception | provisionedthroughputexceededexception | kmsthrottlingexception e ) {	Handle retry for amazon quotas.
public static < t > optional < t > tryamazonaction ( string actionlabel , supplier < t > action , atomiclong durationbetweenrequests ) { try { return of ( action . get ( ) ) ; } catch ( limitexceededexception | provisionedthroughputexceededexception | kmsthrottlingexception e ) { int durationrandommodifier = num_ + random . nextint ( num_ ) ;	Try to perform an Amazon action and increase the duration between requests if some exception is exceeding resource usage exception is thrown.
static string checkbucketisaccessible ( amazons3 amazons3 , string bucketname ) { headbucketrequest headbucketrequest = new headbucketrequest ( bucketname ) ; try { amazons3 . headbucket ( headbucketrequest ) ; } catch ( amazonserviceexception e ) { throw new awss3exception ( str_ , args -> args . add ( str_ , bucketname ) , e ) ; } return bucketname ; }	Throws an exception if the bucket does not exist or is not readable.
optional < biginteger > loadstores ( function < string , entitystores > entitystoresbystorename , bifunction < serializablesnapshot , string , serializablesnapshot > snapshotpostprocessor ) { optional < biginteger > latestsnapshottxid ; try { latestsnapshottxid = m_snapshotstore . listsnapshots ( ) . stream ( ) . max ( biginteger :: compareto ) ; } catch ( ioexception e ) { throw new unrecoverablestoreexception ( str_ , e ) ; } latestsnapshottxid . ifpresent ( lasttx -> { log . info ( str_ , args -> args . add ( str_ , lasttx ) ) ; var postprocess = new snapshotpostprocessor ( snapshotpostprocessor ) ; try { flowable . frompublisher ( m_snapshotstore . createsnapshotreader ( lasttx ) )	Load the stores.
void triggerwildcardexpander ( final collection < file > allfiles , final wildcardcontext wildcardcontext ) throws ioexception { log . debug ( str_ , allfiles ) ; if ( allfiles . isempty ( ) ) { final string message = string . format ( str_ , wildcardcontext . getwildcard ( ) ) ; log . warn ( message ) ; throw new ioexception ( message ) ; } if ( wildcardexpanderhandler != null ) { try { wildcardexpanderhandler . apply ( allfiles ) ; } catch ( final ioexception e ) {	Uses the wildcardExpanderHandler to process all found files and directories.
private static string replace ( final string instring , final string oldpattern , final string newpattern ) { if ( ! haslength ( instring ) || ! haslength ( oldpattern ) || newpattern == null ) { return instring ; } final stringbuffer sbuf = new stringbuffer ( ) ;	Replace all occurrences of a substring within a string with another string.
private static string deleteany ( final string instring , final string charstodelete ) { if ( ! haslength ( instring ) || ! haslength ( charstodelete ) ) { return instring ; } final stringbuffer out = new stringbuffer ( ) ; for ( int i = num_ ; i < instring . length ( ) ; i ++ ) { final char c = instring . charat ( i ) ; if ( charstodelete . indexof ( c ) == - num_ ) { out . append ( c ) ; } } return out . tostring ( ) ; }	Delete any character in a given String.
public lintreport < t > addreport ( final resourcelintreport < t > resourcelintreport ) { validate . notnull ( resourcelintreport ) ; reports . add ( resourcelintreport ) ; return this ; }	Add a single lint report to underlying collection.
private void updatepropertieswithconfiguration ( final properties props , final string key ) { final filterconfig filterconfig = context . get ( ) . getfilterconfig ( ) ;	Add to properties a new key with value extracted either from filterConfig or from configurable properties file.This method helps to ensure backward compatibility of the filterConfig vs configProperties configuration.
private properties getconfigproperties ( ) { if ( configproperties == null ) { configproperties = newconfigproperties ( ) ; if ( additionalconfigproperties != null ) { configproperties . putall ( additionalconfigproperties ) ; } } return configproperties ; }	Use this method rather than accessing the field directly, because it will create a default one if none is provided.
private inputstream createautodetectedstream ( final string defaultfilename ) throws ioexception { try { validate . notnull ( wrofile , str_ ) ; if ( autodetectwrofile ) { final file file = new file ( wrofile . getparentfile ( ) , defaultfilename ) ; log . debug ( str_ + file ) ; return new fileinputstream ( file ) ; } log . debug ( str_ + wrofile ) ; return new fileinputstream ( wrofile ) ; } catch ( final filenotfoundexception e ) {	Handles the resource model auto detection.
private map < string , resourcepostprocessor > topostprocessors ( final map < string , resourcepreprocessor > preprocessorsmap ) { final map < string , resourcepostprocessor > map = new hashmap < string , resourcepostprocessor > ( ) ; for ( final entry < string , resourcepreprocessor > entry : preprocessorsmap . entryset ( ) ) { map . put ( entry . getkey ( ) , new processordecorator ( entry . getvalue ( ) ) ) ; } return map ; }	Creates a map of postProcessors form a map of preProcessors.
public string compile ( final string content , final string optionalargument ) { final rhinoscriptbuilder builder = initscriptbuilder ( ) ; final string argstr = createargstr ( optionalargument ) + createargstr ( getarguments ( ) ) ; final string compilescript = string . format ( str_ , getcompilecommand ( ) , wroutil . tojsmultilinestring ( content ) , argstr ) ; return ( string ) builder . evaluate ( compilescript , getcompilecommand ( ) ) ; }	Compiles the javascript template into plain javascript.
private void reloadcachewithnewvalue ( final long newvalue ) { final long newvalueasprimitive = newvalue == null ? getcacheupdateperiod ( ) : newvalue ; log . debug ( str_ , cacheupdateperiodlisteners . size ( ) ) ; for ( final propertychangelistener listener : cacheupdateperiodlisteners ) { final propertychangeevent event = new propertychangeevent ( this , str_ , getcacheupdateperiod ( ) , newvalueasprimitive ) ; listener . propertychange ( event ) ; } }	Notify all listeners about cachePeriod property changed.
private void reloadmodelwithnewvalue ( final long newvalue ) { final long newvalueasprimitive = newvalue == null ? getmodelupdateperiod ( ) : newvalue ; for ( final propertychangelistener listener : modelupdateperiodlisteners ) { final propertychangeevent event = new propertychangeevent ( this , str_ , getmodelupdateperiod ( ) , newvalueasprimitive ) ; listener . propertychange ( event ) ; } }	Notify all listeners about cachePeriod property changed.
private servletrequest getwrappedservletrequest ( final httpservletrequest request , final string location ) { final httpservletrequest wrappedrequest = new httpservletrequestwrapper ( request ) { @ override public string getrequesturi ( ) { return getcontextpath ( ) + location ; } @ override public string getpathinfo ( ) { return wroutil . getpathinfofromlocation ( this , location ) ; } @ override public string getservletpath ( ) { return wroutil . getservletpathfromlocation ( this , location ) ; } } ;	Build a wrapped servlet request which will be used for dispatching.
public static transformer < string > basenamesuffixtransformer ( final string suffix ) { return new transformer < string > ( ) { public string transform ( final string input ) { final string basename = filenameutils . getbasename ( input ) ; final string extension = filenameutils . getextension ( input ) ; return basename + suffix + str_ + extension ; } } ; }	Appends a suffix to the source baseName.
private void onerror ( final int sc , final string msg ) { log . debug ( str_ , sc , msg ) ; final outputstream emptystream = new bytearrayoutputstream ( ) ; printwriter = new printwriter ( emptystream ) ; servletoutputstream = new delegatingservletoutputstream ( emptystream ) ; }	Use an empty stream to avoid container writing unwanted message when a resource is missing.
@ override public void sendredirect ( final string location ) throws ioexception { try { log . debug ( str_ , location ) ; final inputstream is = externalresourcelocator . locate ( location ) ; ioutils . copy ( is , servletoutputstream ) ; is . close ( ) ; servletoutputstream . close ( ) ; } catch ( final ioexception e ) { log . warn ( str_ , e . getclass ( ) . getname ( ) , location ) ; throw e ; } }	By default, redirect does not allow writing to output stream its content.
private void processresource ( final group group , final resource resource ) { final urilocator urilocator = locatorfactory . getinstance ( resource . geturi ( ) ) ; if ( urilocator instanceof wildcardurilocatorsupport ) { final wildcardstreamlocator wildcardstreamlocator = ( ( wildcardurilocatorsupport ) urilocator ) . getwildcardstreamlocator ( ) ;	Process each resource and replace it with a collection of resources if it contains wildcard.
public function < collection < file > , void > createexpanderhandler ( final group group , final resource resource , final string basenamefolder ) { log . debug ( str_ , basenamefolder , resource ) ; return new function < collection < file > , void > ( ) { public void apply ( final collection < file > files ) { if ( basenamefolder == null ) {	create the handler which expand the resources containing wildcard.
public final inputstream locate ( final string uri ) throws ioexception { final urilocator urilocator = getinstance ( uri ) ; if ( urilocator == null ) { throw new wroruntimeexception ( str_ + uri ) ; } log . debug ( str_ , uri , urilocator . getclass ( ) . getsimplename ( ) ) ; return new autocloseinputstream ( urilocator . locate ( uri ) ) ; }	Locates an InputStream for the given uri.
private wroconfiguration createconfiguration ( ) {	Creates configuration by looking up in servletContext attributes.
private void registerchangelisteners ( ) { wroconfiguration . registercacheupdateperiodchangelistener ( new propertychangelistener ( ) { public void propertychange ( final propertychangeevent event ) {	Register property change listeners.
private void processrequest ( final httpservletrequest request , final httpservletresponse response ) throws servletexception , ioexception { setresponseheaders ( response ) ;	Perform actual processing.
public final void setconfiguration ( final wroconfiguration config ) { notnull ( config ) ; wroconfigurationfactory = new objectfactory < wroconfiguration > ( ) { public wroconfiguration create ( ) { return config ; } } ; }	Once set, this configuration will be used, instead of the one built by the factory.
private void identifyduplicategroupnames ( final collection < group > groups ) { log . debug ( str_ ) ; final list < string > groupnames = new arraylist < string > ( ) ; for ( final group group : groups ) { if ( groupnames . contains ( group . getname ( ) ) ) { throw new wroruntimeexception ( str_ + group . getname ( ) ) ; } groupnames . add ( group . getname ( ) ) ; } }	Identify duplicate group names.
public void merge ( final wromodel importedmodel ) { validate . notnull ( importedmodel , str_ ) ; log . debug ( str_ , importedmodel ) ; for ( final string groupname : new wromodelinspector ( importedmodel ) . getgroupnames ( ) ) { if ( new wromodelinspector ( this ) . getgroupnames ( ) . contains ( groupname ) ) { throw new wroruntimeexception ( str_ + groupname ) ; } final group importedgroup = new wromodelinspector ( importedmodel ) . getgroupbyname ( groupname ) ; addgroup ( importedgroup ) ; } }	Merge this model with another model.
public inputstream locate ( final string uri ) throws ioexception { final urilocator locator = getinstance ( uri ) ; if ( locator == null ) { return getdecoratedobject ( ) . locate ( uri ) ; } return locator . locate ( uri ) ; }	This implementation shows the problem with current design of locator implementation.
private string applypostprocessors ( final cachekey cachekey , final string content ) throws ioexception { final collection < resourcepostprocessor > processors = processorsfactory . getpostprocessors ( ) ; log . debug ( str_ , processors ) ; if ( processors . isempty ( ) ) { return content ; } final resource resource = resource . create ( cachekey . getgroupname ( ) , cachekey . gettype ( ) ) ; reader reader = new stringreader ( content . tostring ( ) ) ; writer writer = null ; for ( final resourcepostprocessor processor : processors ) { final resourcepreprocessor decoratedprocessor = decorateprocessor ( processor , cachekey . isminimize ( ) ) ; writer = new stringwriter ( ) ; decoratedprocessor . process ( resource , reader , writer ) ; reader = new stringreader ( writer . tostring ( ) ) ; } return writer . tostring ( ) ; }	Apply resourcePostProcessors.
private synchronized processordecorator decorateprocessor ( final resourcepostprocessor processor , final boolean minimize ) { final processordecorator decorated = new defaultprocessordecorator ( processor , minimize ) { @ override public void process ( final resource resource , final reader reader , final writer writer ) throws ioexception { try { callbackregistry . onbeforepostprocess ( ) ; super . process ( resource , reader , writer ) ; } finally { callbackregistry . onafterpostprocess ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }	This method is synchronized to ensure that processor is injected before it is being used by other thread.
private void doprocess ( final string requesturi , final reader reader , final writer writer ) throws ioexception { reader input = reader ; writer output = null ; log . debug ( str_ , requesturi ) ; try { final stopwatch stopwatch = new stopwatch ( ) ; final injector injector = injectorbuilder . create ( new basewromanagerfactory ( ) ) . build ( ) ; final list < resourcepreprocessor > processors = getprocessorslist ( ) ; if ( processors == null || processors . isempty ( ) ) { ioutils . copy ( reader , writer ) ; } else { for ( final resourcepreprocessor processor : processors ) { stopwatch . start ( str_ + processor . getclass ( ) . getsimplename ( ) ) ;	Applies configured processor on the intercepted stream.
public string [ ] splitoptions ( final string optionasstring ) { return optionasstring == null ? arrayutils . empty_string_array : optionasstring . split ( str_ ) ; }	Split multiple options into an array of options.
public properties load ( final inputstream inputstream ) throws ioexception { validate . notnull ( inputstream ) ; final string rawcontent = ioutils . tostring ( inputstream , charencoding . utf_8 ) ; parseproperties ( rawcontent . replaceall ( regex_comments , str_ ) ) ; return this . properties ; }	Load the properties from the stream.
private void parseproperties ( final string propertiesasstring ) {	parse the properties from the provided string containing a raw properties.
private wromanagerfactory createcustommanagerfactory ( ) throws mojoexecutionexception { wromanagerfactory factory = null ; try { final class < ? > wromanagerfactoryclass = thread . currentthread ( ) . getcontextclassloader ( ) . loadclass ( wromanagerfactory . trim ( ) ) ; factory = ( wromanagerfactory ) wromanagerfactoryclass . newinstance ( ) ; } catch ( final exception e ) { throw new mojoexecutionexception ( str_ + wromanagerfactory , e ) ; } return factory ; }	Creates a custom instance of Manager factory.
private void persistresourcefingerprints ( final list < string > groupnames ) { final wromodelinspector modelinspector = new wromodelinspector ( getmodel ( ) ) ; for ( final string groupname : groupnames ) { final group group = modelinspector . getgroupbyname ( groupname ) ; if ( group != null ) { for ( final resource resource : group . getresources ( ) ) { getresourcechangehandler ( ) . remember ( resource ) ; } } } }	Store digest for all resources contained inside the list of provided groups.
private boolean istargetgroup ( final group group ) { notnull ( group ) ; final string targetgroups = gettargetgroups ( ) ;	Check if the provided group is a target group.
protected final void extendpluginclasspath ( ) throws mojoexecutionexception {	Update the classpath.
protected inputstream getmodelresourceasstream ( ) throws ioexception { final servletcontext servletcontext = context . getservletcontext ( ) ;	Override this method, in order to provide different xml definition file name.
private wromanagerfactory initfactory ( final properties properties ) { wromanagerfactory factory = null ; final string wromanagerclassname = properties . getproperty ( configconstants . managerfactoryclassname . name ( ) ) ; if ( stringutils . isempty ( wromanagerclassname ) ) {	Initialized inner factory based on provided configuration.
public modeltransformerfactory settransformers ( final list < transformer < wromodel > > modeltransformers ) { validate . notnull ( modeltransformers ) ; this . modeltransformers = modeltransformers ; return this ; }	Set a list of transformers to apply on decorated model factory.
@ override public string compile ( final string content , final string name ) { final string precompiledfunction = super . compile ( content , str_ ) ; return string . format ( str_ , name , precompiledfunction ) ; }	visible for testing, the init of a HandlebarsJs template.
public string processandmerge ( final list < resource > resources , final boolean minimize ) throws ioexception { return processandmerge ( resources , processingcriteria . create ( processingtype . all , minimize ) ) ; }	Apply preProcessors on resources and merge them after all preProcessors are applied.
public string processandmerge ( final list < resource > resources , final processingcriteria criteria ) throws ioexception { notnull ( criteria ) ; log . debug ( str_ , criteria ) ; callbackregistry . onbeforemerge ( ) ; try { notnull ( resources ) ; log . debug ( str_ , resources ) ; final stringbuffer result = new stringbuffer ( ) ; if ( shouldruninparallel ( resources ) ) { result . append ( runinparallel ( resources , criteria ) ) ; } else { for ( final resource resource : resources ) { log . debug ( str_ , resource ) ; result . append ( applypreprocessors ( resource , criteria ) ) ; } } return result . tostring ( ) ; } finally { callbackregistry . onaftermerge ( ) ; } }	Apply preProcessors on resources and merge them.
private string runinparallel ( final list < resource > resources , final processingcriteria criteria ) throws ioexception { log . debug ( str_ ) ; final stringbuffer result = new stringbuffer ( ) ; final list < callable < string > > callables = new arraylist < callable < string > > ( ) ; for ( final resource resource : resources ) { callables . add ( new callable < string > ( ) { public string call ( ) throws exception { log . debug ( str_ , resource ) ; return applypreprocessors ( resource , criteria ) ; } } ) ; } final executorservice exec = getexecutorservice ( ) ; final list < future < string > > futures = new arraylist < future < string > > ( ) ; for ( final callable < string > callable : callables ) {	runs the pre processors in parallel.
private string applypreprocessors ( final resource resource , final processingcriteria criteria ) throws ioexception { final collection < resourcepreprocessor > processors = processorsfactory . getpreprocessors ( ) ; log . debug ( str_ , processors ) ; string resourcecontent = null ; try { resourcecontent = getresourcecontent ( resource ) ; } catch ( final ioexception e ) { log . debug ( str_ , resource ) ; if ( context . get ( ) . getconfig ( ) . isignoremissingresources ( ) ) { return stringutils . empty ; } else { log . error ( str_ , resource ) ; throw e ; } } if ( ! processors . isempty ( ) ) { writer writer = null ; for ( final resourcepreprocessor processor : processors ) { final resourcepreprocessor decoratedprocessor = decoratepreprocessor ( processor , criteria ) ; writer = new stringwriter ( ) ; final reader reader = new stringreader ( resourcecontent ) ;	Apply a list of preprocessors on a resource.
private synchronized resourcepreprocessor decoratepreprocessor ( final resourcepreprocessor processor , final processingcriteria criteria ) { final resourcepreprocessor decorated = new defaultprocessordecorator ( processor , criteria ) { @ override public void process ( final resource resource , final reader reader , final writer writer ) throws ioexception { try { callbackregistry . onbeforepreprocess ( ) ; super . process ( resource , reader , writer ) ; } finally { callbackregistry . onafterpreprocess ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }	Decorates preProcessor with mandatory decorators.This method is synchronized to ensure that processor is injected before it is being used by other thread.
public void persist ( ) { outputstream os = null ; try { os = new fileoutputstream ( fallbackstoragefile ) ; fallbackstorage . store ( os , str_ ) ; log . debug ( str_ , fallbackstoragefile ) ; } catch ( final ioexception e ) { log . warn ( str_ , fallbackstoragefile , e ) ; } finally { ioutils . closequietly ( os ) ; } }	Persist the fallbackStorage to the fallbackStorageFile.
private collection < field > getallfields ( final object object ) { final collection < field > fields = new arraylist < field > ( ) ; fields . addall ( arrays . aslist ( object . getclass ( ) . getdeclaredfields ( ) ) ) ;	Return all fields for given object, also those from the super classes.
public string rewrite ( final string cssuri , final string imageurl ) { notnull ( cssuri ) ; notnull ( imageurl ) ; if ( stringutils . isempty ( imageurl ) ) { return imageurl ; } if ( servletcontexturilocator . isvalid ( cssuri ) ) { if ( servletcontexturilocator . isvalid ( imageurl ) ) { return prependcontextpath ( imageurl ) ; }	Computes the url of the image to be replaced in a css resource.
private string computenewimagelocation ( final string cssuri , final string imageurl ) { log . debug ( str_ , cssuri , imageurl ) ; final string cleanimageurl = cleanimageurl ( imageurl ) ;	Concatenates cssUri and imageUrl after few changes are applied to both input parameters.
public basewromanagerfactory addmodeltransformer ( final transformer < wromodel > modeltransformer ) { if ( modeltransformers == null ) { modeltransformers = new arraylist < transformer < wromodel > > ( ) ; } this . modeltransformers . add ( modeltransformer ) ; return this ; }	Add a single model transformer.
public void serveprocessedbundle ( ) throws ioexception { final wroconfiguration configuration = context . getconfig ( ) ; final httpservletrequest request = context . getrequest ( ) ; final httpservletresponse response = context . getresponse ( ) ; outputstream os = null ; try { final cachekey cachekey = getsafecachekey ( request ) ; initaggregatedfolderpath ( request , cachekey . gettype ( ) ) ; final cachevalue cachevalue = cachestrategy . get ( cachekey ) ;	Write to stream the content of the processed resource bundle.
private void initaggregatedfolderpath ( final httpservletrequest request , final resourcetype type ) { if ( resourcetype . css == type && context . getaggregatedfolderpath ( ) == null ) { final string requesturi = request . getrequesturi ( ) ; final string cssfolder = stringutils . removeend ( requesturi , filenameutils . getname ( requesturi ) ) ; final string aggregatedfolder = stringutils . removestart ( cssfolder , request . getcontextpath ( ) ) ; log . debug ( str_ , aggregatedfolder ) ; context . get ( ) . setaggregatedfolderpath ( aggregatedfolder ) ; } }	Set the aggregatedFolderPath if required.
private map < string , string > extractvariables ( final string variablesbody ) { final map < string , string > map = new hashmap < string , string > ( ) ; final matcher m = pattern_variables_body . matcher ( variablesbody ) ; log . debug ( str_ ) ; while ( m . find ( ) ) { final string key = m . group ( num_ ) ; final string value = m . group ( num_ ) ; if ( map . containskey ( key ) ) { log . warn ( str_ , key , value ) ; } map . put ( key , value ) ; } return map ; }	Extract variables map from variables body.
private string parsecss ( final string css ) {	Parse css, find all defined variables & replace them.
private string replacevariables ( final string css , final map < string , string > variables ) { final stringbuffer sb = new stringbuffer ( ) ; final matcher m = pattern_variable_holder . matcher ( css ) ; while ( m . find ( ) ) { final string oldmatch = m . group ( ) ; final string variablename = m . group ( num_ ) ; final string variablevalue = variables . get ( variablename ) ; if ( variablevalue != null ) { final string newreplacement = oldmatch . replace ( oldmatch , variablevalue ) ; m . appendreplacement ( sb , newreplacement . trim ( ) ) ; } else { log . warn ( str_ + variablename + str_ ) ; } } m . appendtail ( sb ) ; return sb . tostring ( ) ; }	Replace variables from css with provided variables map.
private static resourcepreprocessor topreprocessor ( final resourcepostprocessor postprocessor ) { return new abstractprocessordecoratorsupport < resourcepostprocessor > ( postprocessor ) { public void process ( final resource resource , final reader reader , final writer writer ) throws ioexception { postprocessor . process ( reader , writer ) ; } @ override protected boolean isminimizeinternal ( ) { return isminimizeforprocessor ( postprocessor ) ; } @ override protected supportedresourcetype getsupportedresourcetypeinternal ( ) { return getsupportedresourcetypeforprocessor ( postprocessor ) ; } @ override public string tostring ( ) { return postprocessor . tostring ( ) ; } } ; }	Transforms a post processor into pre processor.
public final boolean iseligible ( final boolean minimize , final resourcetype searchedtype ) { validate . notnull ( searchedtype ) ; final supportedresourcetype supportedtype = getsupportedresourcetype ( ) ; final boolean istypesatisfied = supportedtype == null || ( supportedtype != null && searchedtype == supportedtype . value ( ) ) ; final boolean isminimizedsatisfied = minimize == bool_ || ! isminimize ( ) ; return istypesatisfied && isminimizedsatisfied ; }	Indicates if the processor is eligible for usage based on provided criteria.
private void dogzipresponse ( final httpservletrequest req , final httpservletresponse response , final filterchain chain ) throws ioexception , servletexception { log . debug ( str_ + req . getrequesturi ( ) ) ; response . setheader ( httpheader . content_encoding . tostring ( ) , str_ ) ; final bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; final countingoutputstream countingstream = new countingoutputstream ( new gzipoutputstream ( new bufferedoutputstream ( baos ) ) ) ;	Performs actual gzip of the filtered content.
public static pathpatternprocessordecorator include ( final object processor , final string ... patterns ) { return new pathpatternprocessordecorator ( processor , bool_ , patterns ) ; }	Decorates a processor which will be applied on provided patterns.
public static pathpatternprocessordecorator exclude ( final object processor , final string ... patterns ) { return new pathpatternprocessordecorator ( processor , bool_ , patterns ) ; }	Decorates a processor which will not be applied on provided patterns.
public static resourcechangehandler create ( final wromanagerfactory managerfactory , final log log ) { notnull ( managerfactory , str_ ) ; notnull ( log , str_ ) ; return new resourcechangehandler ( ) . setmanagerfactory ( managerfactory ) . setlog ( log ) ; }	Factory method which requires all mandatory fields.
public void remember ( final resource resource ) { final wromanager manager = getmanagerfactory ( ) . create ( ) ; final hashstrategy hashstrategy = manager . gethashstrategy ( ) ; final urilocatorfactory locatorfactory = manager . geturilocatorfactory ( ) ; if ( rememberedset . contains ( resource . geturi ( ) ) ) {	Will persist the information regarding the provided resource in some internal store.
private void foreachcssimportapply ( final function < string , changestatus > func , final resource resource , final reader reader ) throws ioexception { final resourcepreprocessor processor = createcssimportprocessor ( func ) ; injectorbuilder . create ( getmanagerfactory ( ) ) . build ( ) . inject ( processor ) ; processor . process ( resource , reader , new stringwriter ( ) ) ; }	Invokes the provided function for each detected css import.
private list < t > filter ( final collection < t > collection ) { final list < t > nullfreelist = new arraylist < t > ( ) ; if ( collection != null ) { for ( final t item : collection ) { if ( item != null ) { nullfreelist . add ( item ) ; } } } return nullfreelist ; }	This filtering is required, in order to ensure that no nulls are passed (which happens when using gson fordeserializing json collection.
public boolean isminimized ( final httpservletrequest request ) { validate . notnull ( request ) ; final string minimizeasstring = request . getparameter ( param_minimize ) ; return ! ( context . get ( ) . getconfig ( ) . isdebug ( ) && str_ . equalsignorecase ( minimizeasstring ) ) ; }	The minimization is can be switched off only in debug mode.
private list < resource > findimportedresources ( final string resourceuri , final string csscontent ) throws ioexception {	Find a set of imported resources inside a given resource.
private string computeabsoluteurl ( final string relativeresourceuri , final string importurl ) { final string folder = wroutil . getfullpath ( relativeresourceuri ) ;	Computes absolute url of the imported resource.
public static string createitemsasstring ( final string ... items ) { final stringbuffer sb = new stringbuffer ( ) ; for ( int i = num_ ; i < items . length ; i ++ ) { sb . append ( items [ i ] ) ; if ( i < items . length - num_ ) { sb . append ( token_delimiter ) ; } } return sb . tostring ( ) ; }	Creates a comma separated list of items.
private list < string > getaliaslist ( final string aliascsv ) { log . debug ( str_ , aliascsv ) ; final list < string > list = new arraylist < string > ( ) ; if ( ! stringutils . isempty ( aliascsv ) ) { final string [ ] tokens = aliascsv . split ( token_delimiter ) ; for ( final string token : tokens ) { list . add ( token . trim ( ) ) ; } } return list ; }	Creates a list of aliases based on provided string containing comma separated values of aliases.
private scriptableobject createcontext ( final scriptableobject initialscope ) { final context context = getcontext ( ) ; context . setoptimizationlevel ( - num_ ) ;	Initialize the context.
public object evaluate ( final reader reader , final string sourcename ) throws ioexception { notnull ( reader ) ; try { return evaluate ( ioutils . tostring ( reader ) , sourcename ) ; } finally { reader . close ( ) ; } }	Evaluates a script from a reader.
public object evaluate ( final string script , final string sourcename ) { notnull ( script ) ;	Evaluates a script.
public final void process ( ) throws ioexception {	Perform processing of the uri.
private boolean ishandlerrequest ( final httpservletrequest request ) { string apihandlervalue = request . getparameter ( path_api ) ; return path_handler . equals ( apihandlervalue ) && retrievecachekey ( request ) != null ; }	Checks if the provided url is a resource proxy request.
public static string createhandlerrequestpath ( final cachekey cachekey , final httpservletrequest request ) { final string handlerquerypath = getrequesthandlerpath ( cachekey . getgroupname ( ) , cachekey . gettype ( ) ) ; return request . getservletpath ( ) + handlerquerypath ; }	Computes the servlet context relative url to call this handler using a server-side invocation.
private string rename ( final string group , final inputstream input ) throws exception { try { final string newname = getmanagerfactory ( ) . create ( ) . getnamingstrategy ( ) . rename ( group , input ) ; groupnames . setproperty ( group , newname ) ; return newname ; } catch ( final ioexception e ) { throw new mojoexecutionexception ( str_ , e ) ; } }	Encodes a version using some logic.
private file computedestinationfolder ( final resourcetype resourcetype ) throws mojoexecutionexception { file folder = destinationfolder ; if ( resourcetype == resourcetype . js ) { if ( jsdestinationfolder != null ) { folder = jsdestinationfolder ; } } if ( resourcetype == resourcetype . css ) { if ( cssdestinationfolder != null ) { folder = cssdestinationfolder ; } } getlog ( ) . info ( str_ + folder ) ; if ( folder == null ) { throw new mojoexecutionexception ( str_ + resourcetype + str_ + str_ ) ; } if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } return folder ; }	Computes the destination folder based on resource type.
private void processgroup ( final string group , final file parentfoder ) throws exception { bytearrayoutputstream resultoutputstream = null ; inputstream resultinputstream = null ; try { getlog ( ) . info ( str_ + group ) ;	Process a single group.
public boolean checkchangeforgroup ( final string uri , final string groupname ) throws ioexception { notnull ( uri ) ; notnull ( groupname ) ; log . debug ( str_ , groupname , uri ) ; final resourcechangeinfo resourceinfo = changeinfomap . get ( uri ) ; if ( resourceinfo . ischeckrequiredforgroup ( groupname ) ) { final inputstream inputstream = locatorfactory . locate ( uri ) ; try { final string currenthash = hashstrategy . gethash ( inputstream ) ; resourceinfo . updatehashforgroup ( currenthash , groupname ) ; } finally { ioutils . closequietly ( inputstream ) ; } } return resourceinfo . ischanged ( groupname ) ; }	Check if an uri from a particular group has changed.
@ override public inputstream locate ( final string uri ) throws ioexception { validstate ( standalonecontext != null , str_ ) ; exception lastexception = null ; final string [ ] contextfolders = standalonecontext . getcontextfolders ( ) ; for ( final string contextfolder : contextfolders ) { try { return locatestreamwithcontextfolder ( uri , contextfolder ) ; } catch ( final ioexception e ) { lastexception = e ; log . debug ( str_ , uri , contextfolder ) ; } } final string exceptionmessage = string . format ( str_ , uri , arrays . tostring ( standalonecontext . getcontextfolders ( ) ) ) ; throw new ioexception ( exceptionmessage , lastexception ) ; }	This implementation will try to locate the provided resource inside contextFolder configured by standaloneContext.If a resource cannot be located, the next contextFolder from the list will be tried.
private genericobjectpool < t > createobjectpool ( final objectfactory < t > objectfactory ) { final genericobjectpool < t > pool = newobjectpool ( objectfactory ) ; notnull ( pool ) ; return pool ; }	Ensure that a not null pool will be created.
@ override public inputstream locatestream ( final string uri , final file folder ) throws ioexception { notnull ( folder ) ; final file jarpath = getjarfile ( folder ) ; if ( issupported ( jarpath ) ) { return locatestreamfromjar ( uri , jarpath ) ; } return super . locatestream ( uri , folder ) ; }	Finds the specified URI pattern inside a JAR file.
jarfile open ( final file jarfile ) throws ioexception { istrue ( jarfile . exists ( ) , str_ ) ; return new jarfile ( jarfile ) ; }	Opens the specified JAR file and returns a valid handle.
private string extractpath ( final string uri ) { return defaultwildcardstreamlocator . stripquerypath ( uri . replace ( prefix , stringutils . empty ) ) ; }	Replaces the protocol specific prefix and removes the query path if it exist, since it should not be accepted.
private boolean isminimized ( final httpservletrequest request ) { return context . getconfig ( ) . isminimizeenabled ( ) ? groupextractor . isminimized ( request ) : bool_ ; }	Uses isMinimizeEnabled configuration to compute minimize value.
public final simpleurilocatorfactory addlocator ( final urilocator ... locators ) { for ( final urilocator locator : locators ) { urilocators . add ( locator ) ; } return this ; }	Allow adding more than one uriLocators.
public static wromodelfactory decorate ( final wromodelfactory decorated , final list < transformer < wromodel > > modeltransformers ) { return decorated instanceof defaultwromodelfactorydecorator ? decorated : new defaultwromodelfactorydecorator ( decorated , modeltransformers ) ; }	Factory method which takes care of redundant decoration.
public void addrequire ( final string require ) { if ( require != null && require . trim ( ) . length ( ) > num_ ) { requires . add ( require . trim ( ) ) ; } }	Adds a ruby require to the ruby script to be run by this RubySassEngine.
public string process ( final string content ) { if ( isempty ( content ) ) { return stringutils . empty ; } try { synchronized ( this ) { return engineinitializer . get ( ) . eval ( buildupdatescript ( content ) ) . tostring ( ) ; } } catch ( final scriptexception e ) { throw new wroruntimeexception ( e . getmessage ( ) , e ) ; } }	Transforms a sass content into css using Sass ruby engine.
public void logsummary ( ) { final string message = totalfounderrors == num_ ? str_ : string . format ( str_ , totalfounderrors , totalresourceswitherrors ) ; log . info ( str_ ) ; log . info ( string . format ( str_ , totalresources ) ) ; log . info ( message ) ; log . info ( str_ ) ; }	Logs the summary as it was collected at this point.
public synchronized void onprocessingresource ( final resource resource ) { totalresources ++ ; log . debug ( str_ + resource . geturi ( ) ) ; if ( islogrequired ( ) ) { log . info ( str_ + gettotalresources ( ) + str_ + resource . geturi ( ) ) ; updatelastinvocation ( ) ; } }	A method which should be invoked on each new resource processing, having as a side effect an increment of thecounter holding the number of total processed resources.
private readwritelock getlockforkey ( final k key ) { final readwritelock lock = locks . putifabsent ( key , new reentrantreadwritelock ( ) ) ; return lock == null ? locks . get ( key ) : lock ; }	Ensure that the returned lock will never be null.
private process createprocess ( final file sourcefile ) throws ioexception { notnull ( sourcefile ) ; final string [ ] commandline = getcommandline ( sourcefile . getpath ( ) ) ; log . debug ( str_ , arrays . aslist ( commandline ) ) ; return new processbuilder ( commandline ) . redirecterrorstream ( bool_ ) . start ( ) ; }	Creates process responsible for running lessc shell command by reading the file content from the sourceFilePath.
private property [ ] parseproperties ( final string contents ) { final string [ ] parts = contents . split ( str_ ) ; final list < property > resultsaslist = new arraylist < property > ( ) ; for ( string part : parts ) { try {	Parses out the properties of a selector's body.
public taskinfo [ ] gettaskinfo ( ) { if ( ! this . keeptasklist ) { throw new unsupportedoperationexception ( str_ ) ; } return ( taskinfo [ ] ) this . tasklist . toarray ( new taskinfo [ this . tasklist . size ( ) ] ) ; }	Return an array of the data for tasks performed.
private string getcompilationcommand ( final string input ) { return string . format ( str_ , wroutil . tojsmultilinestring ( input ) , ecmascriptversion ) ; }	Creates compilation command for provided typescript input.
private void parseheader ( final string header ) { log . debug ( str_ , header ) ; final string headername = header . substring ( num_ , header . indexof ( str_ ) ) ; if ( ! headersmap . containskey ( headername ) ) { final string value = header . substring ( header . indexof ( str_ ) + num_ ) ; headersmap . put ( headername , stringutils . trim ( value ) ) ; } }	Parse header value & puts the found values in headersMap field.
private static void addnocacheheaders ( final map < string , string > map ) { map . put ( httpheader . pragma . tostring ( ) , str_ ) ; map . put ( httpheader . cache_control . tostring ( ) , str_ ) ; map . put ( httpheader . expires . tostring ( ) , str_ ) ; }	Populates the map with headers used to disable cache.
public static string getpathinfofromlocation ( final httpservletrequest request , final string location ) { if ( stringutils . isempty ( location ) ) { throw new illegalargumentexception ( str_ ) ; } final string contextpath = request . getcontextpath ( ) ; if ( contextpath != null ) { if ( startswithignorecase ( location , contextpath ) ) { return location . substring ( contextpath . length ( ) ) ; } else { return location ; } } final string noslash = location . substring ( num_ ) ; final int nextslash = noslash . indexof ( str_ ) ; if ( nextslash == - num_ ) { return str_ ; } return noslash . substring ( nextslash ) ; }	Retrieve pathInfo from a given location.
public static string getservletpathfromlocation ( final httpservletrequest request , final string location ) { return location . replace ( getpathinfofromlocation ( request , location ) , stringutils . empty ) ; }	Retrieve servletPath from a given location.
public static boolean matchesurl ( final httpservletrequest request , final string path ) { final pattern pattern = pattern . compile ( str_ + path + str_ , pattern . case_insensitive ) ; if ( request . getrequesturi ( ) != null ) { final matcher m = pattern . matcher ( request . getrequesturi ( ) ) ; return m . matches ( ) ; } return bool_ ; }	Utility used to verify that requestURI matches provided path.
public static string loadregexpwithkey ( final string key ) { inputstream stream = null ; try { stream = wroutil . class . getresourceasstream ( str_ ) ; final properties props = new regexpproperties ( ) . load ( stream ) ; return props . getproperty ( key ) ; } catch ( final ioexception e ) { throw new wroruntimeexception ( str_ + key + str_ , e ) ; } finally { closequietly ( stream ) ; } }	Load the regular expression stored in in regexp.properties resource file.
public static void safecopy ( final reader reader , final writer writer ) throws ioexception { try { ioutils . copy ( reader , writer ) ; } finally { ioutils . closequietly ( reader ) ; ioutils . closequietly ( writer ) ; } }	Copy and close the reader and writer streams.
public static file createtempfile ( final string extension ) { try { final string filename = string . format ( str_ , uuid . randomuuid ( ) . tostring ( ) , extension ) ; final file file = new file ( createtempdirectory ( ) , filename ) ; file . createnewfile ( ) ; return file ; } catch ( final ioexception e ) { throw wroruntimeexception . wrap ( e ) ; } }	Creates a temp file which has a certain extension.
public static final string cleanimageurl ( final string imageurl ) { notnull ( imageurl ) ; return imageurl . replace ( str_ , str_ ) . replace ( str_ , str_ ) . trim ( ) ; }	Cleans the image url by trimming result and removing \' or \" characters if such exists.
final void setattribute ( final attribute attribute , final object object ) { validate . notnull ( attribute ) ; log . debug ( str_ , attribute , object ) ; validate . istrue ( attribute . isvalid ( object ) , object + str_ + attribute ) ; servletcontext . setattribute ( getattributename ( attribute ) , object ) ; }	Sets the attribute into the servlet context.
public string generatedatauri ( final inputstream inputstream , final string filename ) throws ioexception { final stringwriter writer = new stringwriter ( ) ; final byte [ ] bytes = ioutils . tobytearray ( inputstream ) ; inputstream . close ( ) ; final string mimetype = getmimetype ( filename ) ;	Generate the dataUri as string associated to the passed InputStream with encoding & type based on providedfileName.
private void generatedatauri ( final byte [ ] bytes , final writer out , final string mimetype ) throws ioexception {	Generates a data URI from a byte array and outputs to the given writer.
public static void set ( final context context , final wroconfiguration config ) { notnull ( context ) ; notnull ( config ) ; context . setconfig ( config ) ; final string correlationid = generatecorrelationid ( ) ; correlation_id . set ( correlationid ) ; context_map . put ( correlationid , context ) ; }	Associate a context with the CURRENT request cycle.
public static void unset ( ) { final string correlationid = correlation_id . get ( ) ; if ( correlationid != null ) { context_map . remove ( correlationid ) ; } correlation_id . remove ( ) ; }	Remove context from the local thread.
public void check ( final cachekey cachekey , final callback callback ) { notnull ( cachekey ) ; log . debug ( str_ ) ; final stopwatch watch = new stopwatch ( ) ; watch . start ( str_ ) ; try { final group group = new wromodelinspector ( modelfactory . create ( ) ) . getgroupbyname ( cachekey . getgroupname ( ) ) ; if ( isgroupchanged ( group . collectresourcesoftype ( cachekey . gettype ( ) ) , callback ) ) { callback . ongroupchanged ( cachekey ) ; cachestrategy . put ( cachekey , null ) ; } resourcechangedetector . reset ( ) ; } catch ( final exception e ) { onexception ( e ) ; } finally { watch . stop ( ) ; log . debug ( str_ , watch . prettyprint ( ) ) ; } }	Check if resources from a group were changed.
protected void onexception ( final exception e ) {	Invoked when exception occurs.
private void checkresourcechange ( final resource resource , final group group , final callback callback , final atomicboolean ischanged ) throws exception { if ( ischanged ( resource , group . getname ( ) ) ) { ischanged . compareandset ( bool_ , bool_ ) ; callback . onresourcechanged ( resource ) ; lifecyclecallback . onresourcechanged ( resource ) ; } }	Will check if a given resource was changed and will invoke the appropriate callback.
public void updatehashforgroup ( final string hash , final string groupname ) { notnull ( groupname ) ; this . currenthash = hash ; if ( ischangedhash ( ) ) { log . debug ( str_ , groupname ) ;	Updates the hash associated with the resource for a give groupName.
public final boolean hasresourcesoftype ( final resourcetype resourcetype ) { notnull ( resourcetype , str_ ) ; for ( final resource resource : resources ) { if ( resourcetype . equals ( resource . gettype ( ) ) ) { return bool_ ; } } return bool_ ; }	Check if the group has at least one resource of some type.
private process createprocess ( final file sourcefile , final file destfile ) throws ioexception { notnull ( sourcefile ) ; final string [ ] commandline = getcommandline ( sourcefile . getpath ( ) , destfile . getpath ( ) ) ; log . debug ( str_ , arrays . aslist ( commandline ) ) ; final process process = new processbuilder ( commandline ) . redirecterrorstream ( bool_ ) . start ( ) ;	Creates process responsible for running tsc shell command by reading the file content from the sourceFilePath.
private collection < resource > parsegroup ( final element element ) { final string name = element . getattribute ( attr_group_name ) ; final string isabstractasstring = element . getattribute ( attr_group_abstract ) ; final boolean isabstractgroup = stringutils . isnotempty ( isabstractasstring ) && boolean . valueof ( isabstractasstring ) ; if ( groupsinprocess . contains ( name ) ) { throw new recursivegroupdefinitionexception ( str_ + name + str_ + groupsinprocess ) ; } log . debug ( str_ , name ) ; groupsinprocess . add ( name ) ;	Recursive method. Add the parsed element group to the group collection. If the group contains group-ref element,parse recursively this group.
protected group creategroup ( final element element ) { final string name = element . getattribute ( attr_group_name ) ; final group group = new group ( name ) ; final list < resource > resources = new arraylist < resource > ( ) ; final nodelist resourcenodelist = element . getchildnodes ( ) ; for ( int i = num_ ; i < resourcenodelist . getlength ( ) ; i ++ ) { final node node = resourcenodelist . item ( i ) ; if ( node instanceof element ) { final element resourceelement = ( element ) node ; parseresource ( resourceelement , resources ) ; } } group . setresources ( resources ) ; return group ; }	Creates a group and all its associated resources.
private void parseresource ( final element resourceelement , final collection < resource > resources ) { final string tagname = resourceelement . gettagname ( ) ; final string uri = resourceelement . gettextcontent ( ) ; if ( tag_group_ref . equals ( tagname ) ) {	Creates a resource from a given resourceElement.
private collection < resource > getresourcesforgroup ( final string groupname ) { final wromodelinspector modelinspector = new wromodelinspector ( model ) ; final group foundgroup = modelinspector . getgroupbyname ( groupname ) ; if ( foundgroup == null ) { final element groupelement = allgroupelements . get ( groupname ) ; if ( groupelement == null ) { throw new wroruntimeexception ( str_ + groupname ) ; } return parsegroup ( groupelement ) ; } return foundgroup . getresources ( ) ; }	Search for all resources for a group with a given name.
public static long stopnamedtimer ( string timername , int todoflags , long threadid ) { elktimer key = new elktimer ( timername , todoflags , threadid ) ; if ( registeredtimers . containskey ( key ) ) { return registeredtimers . get ( key ) . stop ( ) ; } else { return - num_ ; } }	Stop a timer of the given string name for the given thread.
public static elktimer getnamedtimer ( string timername , int todoflags ) { return getnamedtimer ( timername , todoflags , thread . currentthread ( ) . getid ( ) ) ; }	Get a timer of the given string name and todos for the current thread.
public static elktimer getnamedtimer ( string timername , int todoflags , long threadid ) { elktimer key = new elktimer ( timername , todoflags , threadid ) ; elktimer previous = registeredtimers . putifabsent ( key , key ) ; if ( previous != null ) { return previous ; }	Get a timer of the given string name for the given thread.
public void printstatistics ( ) { ruleapplicationfactory_ . getsaturationstatistics ( ) . print ( logger_ ) ; if ( logger_ . isdebugenabled ( ) ) { if ( aggregatedstats_ . jobssubmittedno > num_ ) logger_ . debug ( str_ , aggregatedstats_ . jobssubmittedno , aggregatedstats_ . jobsalreadydoneno , aggregatedstats_ . jobsprocessedno ) ; logger_ . debug ( str_ + aggregatedstats_ . locks ) ; } }	Print statistics about the saturation.
private void wakeupworkers ( ) { if ( ! workerswaiting_ ) { return ; } stopworkerslock_ . lock ( ) ; try { workerswaiting_ = bool_ ; therearecontextstoprocess_ . signalall ( ) ; } finally { stopworkerslock_ . unlock ( ) ; } }	waking up all workers waiting for new saturated contexts.
private void updateprocessedcounters ( int snapshotfinishedworkers ) { if ( isinterrupted ( ) ) { wakeupworkers ( ) ; return ; } if ( countstartedworkers_ . get ( ) > snapshotfinishedworkers ) { return ; } int snapshotcountjobssubmitted = countjobssubmittedupper_ . get ( ) ; int snapshotcountcontextnonsaturated = saturationstate_ . getcontextmarknonsaturatedcount ( ) ; int snapshotcountstartedworkers = countstartedworkers_ . get ( ) ; if ( snapshotcountstartedworkers > snapshotfinishedworkers ) { return ; } if ( updateifsmaller ( countcontextssaturatedlower_ , snapshotcountcontextnonsaturated ) ) { wakeupworkers ( ) ; } updateifsmaller ( countjobsprocessedlower_ , snapshotcountjobssubmitted ) ; }	Updates the counter for processed contexts and jobs.
private void updatefinishedcounters ( thisstatistics localstatistics ) throws interruptedexception { int snapshotjobsprocessed = countjobsprocessedlower_ . get ( ) ; for ( ; ; ) { int snapshotcountcontextssaturatedlower = countcontextssaturatedlower_ . get ( ) ; saturationstate_ . setcontextssaturated ( snapshotcountcontextssaturatedlower ) ; if ( saturationstate_ . getcontextsetsaturatedcount ( ) < snapshotcountcontextssaturatedlower ) { return ; } int updatedsnapshotjobsprocessed = countjobsprocessedlower_ . get ( ) ; if ( updatedsnapshotjobsprocessed == snapshotjobsprocessed ) { break ; } snapshotjobsprocessed = updatedsnapshotjobsprocessed ; } for ( ; ; ) { int snapshotjobsfinished = countjobsfinishedupper_ . get ( ) ; if ( snapshotjobsfinished >= snapshotjobsprocessed ) { break ; } if ( ! countjobsfinishedupper_ . compareandset ( snapshotjobsfinished , snapshotjobsfinished + num_ ) ) { continue ; }	Check if the counter for saturated contexts and processed jobs can beincreased and post-process the finished jobs.
private static boolean updateifsmaller ( atomicinteger counter , int value ) { for ( ; ; ) { int snapshotcoutner = counter . get ( ) ; if ( snapshotcoutner >= value ) return bool_ ; if ( counter . compareandset ( snapshotcoutner , value ) ) return bool_ ; } }	Update the counter to the value provided it is greater.
protected < p > o defaultvisit ( rule < p > rule , p premise , contextpremises premises , classinferenceproducer producer ) { if ( logger_ . istraceenabled ( ) ) { logger_ . trace ( str_ , premise , rule , premises ) ; } return null ; }	The default implementation of all methods.
private void instertintotaxonomy ( final indexedobjectproperty property ) { final map < indexedobjectproperty , elkobjectproperty > equivalent = collectequivalent ( property ) ; if ( equivalent == null ) {	Adds the specified object property into the taxonomy if it is not in ityet and sets its direct sub-properties if not set yet.
public synchronized void ensureloading ( ) throws elkexception { if ( ! isloadingfinished ( ) ) { if ( isincrementalmode ( ) ) { if ( ! stagemanager . incrementaladditionstage . iscompleted ( ) ) { complete ( stagemanager . incrementaladditionstage ) ; } } else { if ( ! stagemanager . contextinitializationstage . iscompleted ( ) ) { complete ( stagemanager . contextinitializationstage ) ; } } logger_ . trace ( str_ ) ; stagemanager . inputloadingstage . invalidaterecursive ( ) ;	Flushes index, if needed, and completes loading if there is new input.Incremental mode should be changed only during completing loading.
private void restoresaturation ( ) throws elkexception { ensureloading ( ) ; final boolean changed ; if ( isincrementalmode ( ) ) { changed = ! stagemanager . incrementaltaxonomycleaningstage . iscompleted ( ) ; complete ( stagemanager . incrementaltaxonomycleaningstage ) ; } else { changed = ! stagemanager . contextinitializationstage . iscompleted ( ) ; complete ( stagemanager . contextinitializationstage ) ; } if ( changed ) { stagemanager . consistencycheckingstage . invalidaterecursive ( ) ; } }	Ensures that saturation is restored and taxonomies are cleaned.
public synchronized boolean isinconsistent ( ) throws elkexception { restoreconsistencycheck ( ) ; if ( ! consistencycheckingstate . isinconsistent ( ) ) { incompleteness_ . log ( incompleteness_ . getincompletenessmonitorforclassification ( ) ) ; } return consistencycheckingstate . isinconsistent ( ) ; }	Check consistency of the current ontology, if this has not been done yet.
protected taxonomy < elkclass > restoretaxonomy ( ) throws elkinconsistentontologyexception , elkexception { ruleandconclusionstats . reset ( ) ;	Complete the taxonomy computation stage and the stages it depends on, ifit has not been done yet.
protected instancetaxonomy < elkclass , elknamedindividual > restoreinstancetaxonomy ( ) throws elkinconsistentontologyexception , elkexception { ruleandconclusionstats . reset ( ) ;	Completes instance taxonomy computation stage and the stages that itdepends on, if this has not been done yet.
public proof < ? extends entailmentinference > getevidence ( final boolean atmostone ) { return new proof < entailmentinference > ( ) { @ suppresswarnings ( str_ ) @ override public collection < ontologyinconsistencyentailmentinference > getinferences ( final object conclusion ) { if ( ! ontologyinconsistencyimpl . instance . equals ( conclusion ) ) { return collections . emptylist ( ) ; }	Explains why an ontology inconsistency is entailed.
@ override public boolean preexecute ( ) { if ( isinitialized_ ) return bool_ ; logger_ . trace ( str_ , this ) ; this . workerno = reasoner . getnumberofworkers ( ) ; return isinitialized_ = bool_ ; }	Initialize the parameters of the computation for this stage; this is thefirst thing to be done before stage is executed.
public void invalidaterecursive ( ) { queue < abstractreasonerstage > toinvalidate_ = new linkedlist < abstractreasonerstage > ( ) ; toinvalidate_ . add ( this ) ; abstractreasonerstage next ; while ( ( next = toinvalidate_ . poll ( ) ) != null ) { if ( next . invalidate ( ) ) { for ( abstractreasonerstage poststage : next . poststages_ ) { toinvalidate_ . add ( poststage ) ; } } } }	Invalidates this stage and all subsequent stages if not already done so.
collection < indexedindividual > gettoadd ( ) { if ( taxonomy_ == null ) {	Returns collection that contains at least all individuals that are inontology, but either are removed from taxonomy or their type nodes intaxonomy were removed.
collection < indexedindividual > gettoremove ( ) { if ( taxonomy_ == null ) {	Returns collection that contains at least all individuals that are intaxonomy, but either are removed from ontology or their context becamenot saturated.
private static unsupportedoperationexception unsupportedowlapimethod ( string method ) { string message = str_ + method + str_ ; loggerwrap . log ( logger_ , loglevel . warn , marker_unsupported_method_ , message ) ; return new unsupportedoperationexception ( message ) ; }	Logs a warning message for unsupported OWL API method.
static < e > void remove ( e [ ] d , int pos ) { for ( ; ; ) { int next = getmovedposition ( d , pos ) ; e moved = d [ pos ] = d [ next ] ; if ( moved == null ) return ;	Removes the element at the given position of the table shifting, ifnecessary, other elements so that all elements can be found by linearprobing.
static < k , v > void remove ( k [ ] k , v [ ] v , int pos ) { for ( ; ; ) { int next = getmovedposition ( k , pos ) ; k moved = k [ pos ] = k [ next ] ; v [ pos ] = v [ next ] ; if ( moved == null ) return ;	Removes the element at the given position of the table and thecorresponding value at the same position, shifting, if necessary, otherelements and values so that all elements can be found by linear probing.
static < e > int getmovedposition ( e [ ] d , int del ) { int j = del ; for ( ; ; ) { if ( ++ j == d . length ) j = num_ ;	Finds the position of the next element starting from the given positionthat would not be found by linear probing if the element at the givenposition are deleted.
static < e > boolean contains ( e [ ] d , object o ) { int pos = getposition ( d , o ) ; if ( d [ pos ] == null ) return bool_ ;	Tests if the set represented by given data array contains a given object.
static < e > boolean add ( e [ ] d , e e ) { int pos = getposition ( d , e ) ; if ( d [ pos ] == null ) { d [ pos ] = e ; return bool_ ; }	Adds the element to the set represented by given data array, if it didnot contain there already.
public final void checkoccurrencenumbers ( ) { if ( logger_ . istraceenabled ( ) ) logger_ . trace ( tostring ( ) + str_ + printoccurrencenumbers ( ) ) ; if ( positiveoccurrenceno < num_ || negativeoccurrenceno < num_ ) throw new elkunexpectedindexingexception ( tostring ( ) + str_ + printoccurrencenumbers ( ) ) ; }	verifies that occurrence numbers are not negative.
public synchronized void add ( classconclusiontimer timer ) { this . timecomposedsubsumers += timer . timecomposedsubsumers ; this . timedecomposedsubsumers += timer . timedecomposedsubsumers ; this . timebackwardlinks += timer . timebackwardlinks ; this . timeforwardlinks += timer . timeforwardlinks ; this . timecontradictions += timer . timecontradictions ; this . timepropagations += timer . timepropagations ; this . timedisjointsubsumers += timer . timedisjointsubsumers ; this . timecontextinitializations += timer . timecontextinitializations ; this . timesubcontextinitializations += timer . timesubcontextinitializations ; }	Adds all timers of the argument to the corresponding counters of thisobject.
public synchronized void add ( ruleapplicationtimer timer ) { timeowlthingcontextinitrule += timer . timeowlthingcontextinitrule ; timerootcontextinitializationrule += timer . timerootcontextinitializationrule ; timedisjointsubsumerfrommemberrule += timer . timedisjointsubsumerfrommemberrule ; timecontradictionfromnegationrule += timer . timecontradictionfromnegationrule ; timeobjectintersectionfromfirstconjunctrule += timer . timeobjectintersectionfromfirstconjunctrule ; timeobjectintersectionfromsecondconjunctrule += timer . timeobjectintersectionfromsecondconjunctrule ; timesuperclassfromsubclassrule += timer . timesuperclassfromsubclassrule ; timepropagationfromexistentialfillerrule += timer . timepropagationfromexistentialfillerrule ; timeobjectunionfromdisjunctrule += timer . timeobjectunionfromdisjunctrule ; timebackwardlinkchainfrombackwardlinkrule += timer . timebackwardlinkchainfrombackwardlinkrule ; timereflexivebackwardlinkcompositionrule += timer . timereflexivebackwardlinkcompositionrule ; timenonreflexivebackwardlinkcompositionrule += timer . timenonreflexivebackwardlinkcompositionrule ; timesubsumerbackwardlinkrule += timer . timesubsumerbackwardlinkrule ; timecontradictionoverbackwardlinkrule += timer . timecontradictionoverbackwardlinkrule ; timecontradictionpropagationrule += timer . timecontradictionpropagationrule ; timecontradictioncompositionrule += timer . timecontradictioncompositionrule ; timeindexedobjectintersectionofdecomposition += timer . timeindexedobjectintersectionofdecomposition ; timeindexedobjectsomevaluesfromdecomposition += timer . timeindexedobjectsomevaluesfromdecomposition ; timeindexedobjectcomplementofdecomposition += timer . timeindexedobjectcomplementofdecomposition ; timeindexedobjecthasselfdecomposition += timer . timeindexedobjecthasselfdecomposition ; timecontradictionfromowlnothingrule += timer . timecontradictionfromowlnothingrule ; timesubsumerpropagationrule += timer . timesubsumerpropagationrule ; timepropagationinitializationrule += timer . timepropagationinitializationrule ; timebackwardlinkfromforwardlinkrule += timer . timebackwardlinkfromforwardlinkrule ; timecomposedfromdecomposedsubsumerrule += timer . timecomposedfromdecomposedsubsumerrule ; timeindexedclassdecompositionrule += timer . timeindexedclassdecompositionrule ; timeindexedclassfromdefinitionrule += timer . timeindexedclassfromdefinitionrule ; timeequivalentclassfirstfromsecondrule += timer . timeequivalentclassfirstfromsecondrule ; timeequivalentclasssecondfromfirstrule += timer . timeequivalentclasssecondfromfirstrule ; }	Add the values the corresponding values of the given timer.
private static < k , v > v putkeyvalue ( k [ ] keys , v [ ] values , k key , v value ) { int pos = linearprobing . getposition ( keys , key ) ; if ( keys [ pos ] == null ) { keys [ pos ] = key ; values [ pos ] = value ; return null ; }	Associates the given key with the given value in the map defined by thekeys and value arrays.
private static < k , v > v removeentry ( k [ ] keys , v [ ] values , object key ) { int pos = linearprobing . getposition ( keys , key ) ; if ( keys [ pos ] == null ) return null ;	Remove the entry in the keys and values such that the key of the entry isequal to the given object according to the equality function.
private void enlarge ( ) { int oldcapacity = keys . length ; if ( oldcapacity == linearprobing . maximum_capacity ) throw new illegalargumentexception ( str_ + linearprobing . maximum_capacity ) ; k oldkeys [ ] = keys ; v oldvalues [ ] = values ; int newcapacity = oldcapacity << num_ ; @ suppresswarnings ( str_ ) k newkeys [ ] = ( k [ ] ) new object [ newcapacity ] ; @ suppresswarnings ( str_ ) v newvalues [ ] = ( v [ ] ) new object [ newcapacity ] ; for ( int i = num_ ; i < oldcapacity ; i ++ ) { k key = oldkeys [ i ] ; if ( key != null ) putkeyvalue ( newkeys , newvalues , key , oldvalues [ i ] ) ; } this . keys = newkeys ; this . values = newvalues ; }	Increasing the capacity of the map.
private void shrink ( ) { int oldcapacity = keys . length ; if ( oldcapacity <= linearprobing . default_initial_capacity ) return ; k oldkeys [ ] = keys ; v oldvalues [ ] = values ; int newcapacity = oldcapacity > > num_ ; @ suppresswarnings ( str_ ) k newkeys [ ] = ( k [ ] ) new object [ newcapacity ] ; @ suppresswarnings ( str_ ) v newvalues [ ] = ( v [ ] ) new object [ newcapacity ] ; for ( int i = num_ ; i < oldcapacity ; i ++ ) { k key = oldkeys [ i ] ; if ( key != null ) putkeyvalue ( newkeys , newvalues , key , oldvalues [ i ] ) ; } this . keys = newkeys ; this . values = newvalues ; }	Decreasing the capacity of the map.
public void saveconfiguration ( file configondisk , baseconfiguration config ) throws configurationexception , ioexception { inputstream stream = null ; baseconfiguration loadedconfig = null ; properties diskprops = new properties ( ) ; try { stream = new fileinputstream ( configondisk ) ; loadedconfig = getconfiguration ( stream , str_ , config . getclass ( ) ) ;	Not a thread-safe method.
protected static void printdeclarations ( taxonomy < elkclass > classtaxonomy , elkobject . factory objectfactory , appendable writer ) throws ioexception { list < elkclass > classes = new arraylist < elkclass > ( classtaxonomy . getnodes ( ) . size ( ) * num_ ) ; for ( taxonomynode < elkclass > classnode : classtaxonomy . getnodes ( ) ) { for ( elkclass clazz : classnode ) { if ( ! clazz . getiri ( ) . equals ( predefinedelkiris . owl_thing ) && ! clazz . getiri ( ) . equals ( predefinedelkiris . owl_nothing ) ) { classes . add ( clazz ) ; } } } collections . sort ( classes , class_comparator ) ; for ( elkclass clazz : classes ) { elkdeclarationaxiom decl = objectfactory . getdeclarationaxiom ( clazz ) ; owlfunctionalstyleprinter . append ( writer , decl , bool_ ) ; writer . append ( str_ ) ; } }	Prints class declarations.
public static < t extends elkentity , i extends elkentity , tn extends generictypenode < t , i , tn , in > , in extends genericinstancenode < t , i , tn , in > > set < ? extends in > getallinstancenodes ( final generictypenode < t , i , tn , in > node ) { return taxonomynodeutils . collectfromallreachable ( node . getdirectsubnodes ( ) , node . getdirectinstancenodes ( ) , new operations . functor < generictypenode < t , i , tn , in > , set < ? extends generictypenode < t , i , tn , in > > > ( ) { @ override public set < ? extends tn > apply ( final generictypenode < t , i , tn , in > node ) { return node . getdirectsubnodes ( ) ; } } , new operations . functor < generictypenode < t , i , tn , in > , set < ? extends in > > ( ) { @ override public set < ? extends in > apply ( final generictypenode < t , i , tn , in > node ) { return node . getdirectinstancenodes ( ) ; } } ) ; }	Returns all instance nodes of the specified type node and all itssub-nodes.
@ override public void clear ( ) { modcount ++ ; e [ ] tab = buckets ; for ( int i = num_ ; i < tab . length ; i ++ ) tab [ i ] = null ; size = num_ ; }	Removes all entries from this set.
public static int combinelisthash ( int ... hashes ) { int hash = num_ ; for ( int h : hashes ) { hash += h ; hash += ( hash << num_ ) ; hash ^= ( hash > > num_ ) ; } hash += ( hash << num_ ) ; hash ^= ( hash > > num_ ) ; hash += ( hash << num_ ) ; return hash ; }	Combine many hash codes into one in a way that depends on their order.The current implementation is based on the Jenkins One-at-a-Time hash,see http://www.burtleburtle.net/bob/hash/doobs.html and alsohttp://en.wikipedia.org/wiki/Jenkins_hash_function.
public static int copy ( inputstream input , outputstream output ) throws ioexception { byte [ ] buffer = new byte [ buffer_size ] ; bufferedinputstream in = new bufferedinputstream ( input , buffer_size ) ; bufferedoutputstream out = new bufferedoutputstream ( output , buffer_size ) ; int count = num_ , n = num_ ; try { while ( ( n = in . read ( buffer , num_ , buffer_size ) ) != - num_ ) { out . write ( buffer , num_ , n ) ; count += n ; } out . flush ( ) ; } finally { ioutils . closequietly ( in ) ; ioutils . closequietly ( out ) ; } return count ; }	Copies bytes from the input stream to the output stream.
public incompletenessmonitor getreasonerincompletenessmonitor ( final incompletenessmonitor ... additionalmonitors ) { final list < incompletenessmonitor > monitors = new arraylist < incompletenessmonitor > ( additionalmonitors . length + num_ ) ; monitors . add ( getincompletenessduetostatedaxiomsmonitor ( ) ) ; monitors . addall ( arrays . aslist ( additionalmonitors ) ) ; return new delegatingincompletenessmonitor ( monitors ) { @ override public boolean lognewincompletenessreasons ( final logger logger ) { final boolean result = super . lognewincompletenessreasons ( logger ) ; if ( result ) { loggerwrap . log ( logger , loglevel . warn , marker_ , str_ ) ; } return result ; } } ; }	Combines the provided partial incompleteness monitors into the top-levelmonitor for reasoning tasks.
protected static < t extends elkentity > void processtaxomomy ( final taxonomy < t > taxonomy , final appendable writer ) throws ioexception { final elkobject . factory factory = new elkobjectentityrecyclingfactory ( ) ;	Process a taxonomy and write a normalized serialization.
public synchronized boolean submit ( i input ) throws interruptedexception { if ( termination || isinterrupted ( ) ) return bool_ ; buffer_ . put ( input ) ; return bool_ ; }	Submitting a new input for processing.
public static void append ( appendable appender , elkobject elkobject ) throws ioexception { append ( appender , elkobject , bool_ ) ; }	Printing an ELK Object through an appender.
private querystate marknotcomputed ( final indexedclassexpression queryclass ) { final querystate state = indexed_ . get ( queryclass ) ; if ( state == null || ! state . iscomputed ) { return null ; } state . iscomputed = bool_ ; if ( state . node != null ) { removeallrelated ( queryclass , state . node ) ; state . node = null ; } return state ; }	If the specified query was added to the index, this method marks it asnot-computed and deletes the query results.
@ override public synchronized void adddirecttypenode ( final utn typenode ) { logger_ . trace ( str_ , this , typenode ) ; directtypenodes_ . add ( typenode ) ; }	Add a direct super-class node.
protected static void checkchainmatch ( final elksubobjectpropertyexpression fullchain , final int startpos ) {	some methods for checking correctness of arguments.
public static < i , o > set < o > map ( final set < ? extends i > input , final functorex < i , o > functor ) { return new abstractset < o > ( ) { @ override public iterator < o > iterator ( ) { return new mapiterator < i , o > ( input . iterator ( ) , functor ) ; } @ override public boolean contains ( object o ) { i element = functor . deapply ( o ) ; return element == null ? bool_ : input . contains ( element ) ; } @ override public int size ( ) { return input . size ( ) ; } } ; }	A simple second-order map function for sets.
public boolean add ( int s , e e ) { if ( e == null ) throw new nullpointerexception ( ) ; int mask = ( num_ << s ) ; int oldmask = addmask ( logs , data , masks , e , mask ) ; int newmask = oldmask | mask ; if ( newmask == oldmask ) return bool_ ; else if ( oldmask == num_ && ++ occupied == linearprobing . getuppersize ( data . length ) ) enlarge ( ) ; sizes [ s ] ++ ; return bool_ ; }	Inserts a given element into the given slice.
public boolean remove ( int s , object o ) { if ( o == null ) throw new nullpointerexception ( ) ; int mask = num_ << s ; int oldmask = removemask ( logs , data , masks , o , mask ) ; int newmask = oldmask & ~ mask ; if ( newmask == oldmask ) return bool_ ;	Removes the given object from the given slice.
public synchronized void add ( classconclusioncounter counter ) { this . countsubclassinclusiondecomposed += counter . countsubclassinclusiondecomposed ; this . countsubclassinclusioncomposed += counter . countsubclassinclusioncomposed ; this . countbackwardlink += counter . countbackwardlink ; this . countforwardlink += counter . countforwardlink ; this . countcontradiction += counter . countcontradiction ; this . countpropagation += counter . countpropagation ; this . countdisjointsubsumer += counter . countdisjointsubsumer ; this . countcontextinitialization += counter . countcontextinitialization ; this . countsubcontextinitialization += counter . countsubcontextinitialization ; }	Adds all counters of the argument to the corresponding counters of thisobject.
public static void logmemoryusage ( logger logger , loglevel priority ) { if ( loggerwrap . isenabledfor ( logger , priority ) ) {	Log the current total memory usage with the specified priority.
public synchronized void setconfigurationoptions ( reasonerconfiguration config ) { this . workerno_ = config . getparameterasint ( reasonerconfiguration . num_of_working_threads ) ; setallowincrementalmode ( config . getparameterasboolean ( reasonerconfiguration . incremental_mode_allowed ) ) ; }	This supposed to be the central place where the reasoner gets itsconfiguration options.
public synchronized boolean shutdown ( long timeout , timeunit unit ) throws interruptedexception { boolean success = bool_ ; if ( success ) { logger_ . info ( str_ ) ; } else { logger_ . error ( str_ ) ; } return success ; }	Tries to shut down the reasoner within the specified time.
public void printheader ( ) { printseparator ( ) ; addpadding ( str_ , headerparams_ ) ; logger_ . debug ( string . format ( headerformat_ , headerparams_ ) ) ; printseparator ( ) ; }	Prints the heading together with the separators.
public void print ( object ... values ) { addpadding ( str_ , values ) ; logger_ . debug ( string . format ( valuesformat_ , values ) ) ; }	Formats and the given values, adding padding symbols if necessary.
static string getstring ( char c , int n ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < n ; i ++ ) { sb . append ( c ) ; } return sb . tostring ( ) ; }	Creates a string of the given length consisting of the given character.
public synchronized void add ( rulecounter counter ) { countowlthingcontextinitrule += counter . countowlthingcontextinitrule ; countrootcontextinitializationrule += counter . countrootcontextinitializationrule ; countdisjointsubsumerfrommemberrule += counter . countdisjointsubsumerfrommemberrule ; countcontradictionfromnegationrule += counter . countcontradictionfromnegationrule ; countobjectintersectionfromfirstconjunctrule += counter . countobjectintersectionfromfirstconjunctrule ; countobjectintersectionfromsecondconjunctrule += counter . countobjectintersectionfromsecondconjunctrule ; countsuperclassfromsubclassrule += counter . countsuperclassfromsubclassrule ; countpropagationfromexistentialfillerrule += counter . countpropagationfromexistentialfillerrule ; countobjectunionfromdisjunctrule += counter . countobjectunionfromdisjunctrule ; countbackwardlinkchainfrombackwardlinkrule += counter . countbackwardlinkchainfrombackwardlinkrule ; countsubsumerbackwardlinkrule += counter . countsubsumerbackwardlinkrule ; countcontradictionoverbackwardlinkrule += counter . countcontradictionoverbackwardlinkrule ; countcontradictionpropagationrule += counter . countcontradictionpropagationrule ; countcontradictioncompositionrule += counter . countcontradictioncompositionrule ; countnonreflexivebackwardlinkcompositionrule += counter . countnonreflexivebackwardlinkcompositionrule ; countindexedobjectintersectionofdecomposition += counter . countindexedobjectintersectionofdecomposition ; countindexedobjectsomevaluesfromdecomposition += counter . countindexedobjectsomevaluesfromdecomposition ; countindexedobjectcomplementofdecomposition += counter . countindexedobjectcomplementofdecomposition ; countindexedobjecthasselfdecomposition += counter . countindexedobjecthasselfdecomposition ; countcontradictionfromowlnothingrule += counter . countcontradictionfromowlnothingrule ; countsubsumerpropagationrule += counter . countsubsumerpropagationrule ; countreflexivebackwardlinkcompositionrule += counter . countreflexivebackwardlinkcompositionrule ; countpropagationinitializationrule += counter . countpropagationinitializationrule ; countbackwardlinkfromforwardlinkrule += counter . countbackwardlinkfromforwardlinkrule ; countcomposedfromdecomposedsubsumerrule += counter . countcomposedfromdecomposedsubsumerrule ; countindexedclassdecompositionrule += counter . countindexedclassdecompositionrule ; countindexedclassfromdefinitionrule += counter . countindexedclassfromdefinitionrule ; countequivalentclassfirstfromsecondrule += counter . countequivalentclassfirstfromsecondrule ; countequivalentclasssecondfromfirstrule += counter . countequivalentclasssecondfromfirstrule ; }	Add the values the corresponding values of the given counter.
private void writeresource ( xhtmlwriter writer , object object ) { if ( object == null ) { return ; } try { if ( object instanceof resource ) { resource < ? > resource = ( resource < ? > ) object ; writer . beginlistitem ( ) ; writeresource ( writer , resource . getcontent ( ) ) ; writer . writelinks ( resource . getlinks ( ) ) ; writer . endlistitem ( ) ; } else if ( object instanceof resources ) { resources < ? > resources = ( resources < ? > ) object ;	Recursively converts object to xhtml data.
@ override public actioninputparameter getactioninputparameter ( string name ) { actioninputparameter ret = requestparams . get ( name ) ; if ( ret == null ) { ret = pathvariables . get ( name ) ; } if ( ret == null ) { for ( actioninputparameter annotatedparameter : getinputparameters ( ) ) {	Gets input parameter info which is part of the URL mapping, be it request parameters, path variables or requestbody attributes.
propertydescriptor getpropertydescriptorforpropertypath ( string propertypath , class < ? > propertytype ) { int pos = propertyaccessorutils . getfirstnestedpropertyseparatorindex ( propertypath ) ;	Recursively navigate to return a BeanWrapper for the nested property path.
@ override public map < string , actioninputparameter > getrequiredparameters ( ) { map < string , actioninputparameter > ret = new hashmap < string , actioninputparameter > ( ) ; for ( map . entry < string , actioninputparameter > entry : requestparams . entryset ( ) ) { actioninputparameter annotatedparameter = entry . getvalue ( ) ; if ( annotatedparameter . isrequired ( ) ) { ret . put ( entry . getkey ( ) , annotatedparameter ) ; } } for ( map . entry < string , actioninputparameter > entry : pathvariables . entryset ( ) ) { actioninputparameter annotatedparameter = entry . getvalue ( ) ; ret . put ( entry . getkey ( ) , annotatedparameter ) ; }	Determines action input parameters for required url variables.
public static boolean issinglevaluetype ( class < ? > clazz ) { boolean ret ; if ( isnumber ( clazz ) || isboolean ( clazz ) || isstring ( clazz ) || isenum ( clazz ) || isdate ( clazz ) || iscalendar ( clazz ) || iscurrency ( clazz ) ) { ret = bool_ ; } else { ret = bool_ ; } return ret ; }	Determines if the given class holds only one data item.
public void addrel ( string rel ) { assert . haslength ( rel ) ; linkparams . add ( rel . paramname , rel ) ; }	The relation type of the link.
public void settype ( string mediatype ) { if ( mediatype != null ) linkparams . set ( type . paramname , mediatype ) ; else linkparams . remove ( type . paramname ) ; }	The "type" parameter, when present, is a hint indicating what the media type of the result of dereferencing thelink should be.
public void addhreflang ( string hreflang ) { assert . haslength ( hreflang ) ; linkparams . add ( hreflang . paramname , hreflang ) ; }	The "hreflang" parameter, when present, is a hint indicating what the language of the result of dereferencing thelink should be.
public void addrev ( string rev ) { assert . haslength ( rev ) ; linkparams . add ( rev . paramname , rev ) ; }	The "rev" parameter has been used in the past to indicate that the semantics of the relationship are in thereverse direction.
public void addlinkparam ( string paramname , string ... values ) { assert . notempty ( values ) ; for ( string value : values ) { assert . haslength ( value ) ; linkparams . add ( paramname , value ) ; } }	Adds link-extension params, i.e.
@ override public affordance expand ( map < string , ? extends object > arguments ) { uritemplate template = new uritemplate ( partialuritemplate . ascomponents ( ) . tostring ( ) ) ; string expanded = template . expand ( arguments ) . toasciistring ( ) ; return new affordance ( expanded , linkparams , actiondescriptors ) ; }	Expands template variables, arguments must satisfy all required template variables, unsatisfied optionalarguments will be removed.
@ jsonignore public list < string > getrels ( ) { final list < string > rels = linkparams . get ( rel . paramname ) ; return rels == null ? collections . < string > emptylist ( ) : collections . unmodifiablelist ( rels ) ; }	Allows to retrieve all rels defined for this affordance.
@ jsonignore public list < string > getrevs ( ) { final list < string > revs = linkparams . get ( rev . paramname ) ; return revs == null ? collections . < string > emptylist ( ) : collections . unmodifiablelist ( revs ) ; }	Retrieves all revs for this affordance.
@ jsonignore public boolean hasunsatisfiedrequiredvariables ( ) { for ( actiondescriptor actiondescriptor : actiondescriptors ) { map < string , actioninputparameter > requiredparameters = actiondescriptor . getrequiredparameters ( ) ; for ( actioninputparameter annotatedparameter : requiredparameters . values ( ) ) { if ( ! annotatedparameter . hasvalue ( ) ) { return bool_ ; } } } return bool_ ; }	Determines if the affordance has unsatisfied required variables.
public string getvalueformatted ( ) { string ret ; if ( value == null ) { ret = null ; } else { ret = ( string ) conversionservice . convert ( value , typedescriptor , typedescriptor . valueof ( string . class ) ) ; } return ret ; }	The value of the parameter at sample invocation time, formatted according to conversion configuration.
@ override public boolean ishidden ( string property ) { annotation [ ] paramannotations = methodparameter . getparameterannotations ( ) ; input inputannotation = methodparameter . getparameterannotation ( input . class ) ; return inputannotation != null && arraycontains ( inputannotation . hidden ( ) , property ) ; }	Determines if request body input parameter has a hidden input property.
private boolean containspropertyincludevalue ( string property ) { return arraycontains ( inputannotation . readonly ( ) , property ) || arraycontains ( inputannotation . hidden ( ) , property ) || arraycontains ( inputannotation . include ( ) , property ) ; }	Find out if property is included by searching through all annotations.
private boolean hasexplicitorimplicitpropertyincludevalue ( ) {	Has any explicit include value or might have implicit includes because there is a hidden or readOnly flag.
public boolean isrequired ( ) { boolean ret ; if ( isrequestbody ( ) ) { ret = requestbody . required ( ) ; } else if ( isrequestparam ( ) ) { ret = ! ( isdefined ( requestparam . defaultvalue ( ) ) || ! requestparam . required ( ) ) ; } else if ( isrequestheader ( ) ) { ret = ! ( isdefined ( requestheader . defaultvalue ( ) ) || ! requestheader . required ( ) ) ; } else { ret = bool_ ; } return ret ; }	Is this action input parameter required, based on the presence of a default value, the parameter annotations andthe kind of input parameter.
public string getdefaultvalue ( ) { string ret ; if ( isrequestparam ( ) ) { ret = isdefined ( requestparam . defaultvalue ( ) ) ? requestparam . defaultvalue ( ) : null ; } else if ( isrequestheader ( ) ) { ret = ! ( valueconstants . default_none . equals ( requestheader . defaultvalue ( ) ) ) ? requestheader . defaultvalue ( ) : null ; } else { ret = null ; } return ret ; }	Determines default value of request param or request header, if available.
@ override public string getparametername ( ) { string ret = null ; if ( requestparam != null ) { string requestparamname = requestparam . value ( ) ; if ( ! requestparamname . isempty ( ) ) ret = requestparamname ; } if ( pathvariable != null ) { string pathvariablename = pathvariable . value ( ) ; if ( ! pathvariablename . isempty ( ) ) ret = pathvariablename ; } if ( ret == null ) { string parametername = methodparameter . getparametername ( ) ; if ( parametername == null ) { methodparameter . initparameternamediscovery ( new localvariabletableparameternamediscoverer ( ) ) ; ret = methodparameter . getparametername ( ) ; } else { ret = parametername ; } } return ret ; }	Gets request parameter name of this action input parameter.
private string getexposedpropertyorparamname ( actioninputparameter inputparameter ) { final expose expose = inputparameter . getannotation ( expose . class ) ; string property ; if ( expose != null ) { property = expose . value ( ) ; } else { property = inputparameter . getparametername ( ) ; } return property ; }	Gets exposed property or parameter name.
public string getvocab ( mixinsource mixinsource , object bean , class < ? > mixinclass ) { if ( proxyunwrapper != null ) { bean = proxyunwrapper . unwrapproxy ( bean ) ; }	Gets vocab for given bean.
public string getquery ( ) { stringbuilder query = new stringbuilder ( ) ; if ( querytail . length ( ) > num_ ) { if ( queryhead . length ( ) == num_ ) { query . append ( str_ ) . append ( querytail ) . append ( str_ ) ; } else if ( queryhead . length ( ) > num_ ) { query . append ( queryhead ) . append ( str_ ) . append ( querytail ) . append ( str_ ) ; } } else { query . append ( queryhead ) ; } return query . tostring ( ) ; }	Query consisting of expanded parameters and unexpanded parameters.
private void appendform ( affordance affordance , actiondescriptor actiondescriptor ) throws ioexception { string formname = actiondescriptor . getactionname ( ) ; requestmethod httpmethod = requestmethod . valueof ( actiondescriptor . gethttpmethod ( ) ) ;	Appends form and squashes non-GET or POST to POST.
private void inputbutton ( type type , string value ) throws ioexception { write ( str_ ) ; write ( type . tostring ( ) ) ; write ( str_ ) ; write ( str_ ) ; write ( str_ ) ; quote ( ) ; write ( value ) ; quote ( ) ; write ( str_ ) ; }	Classic submit or reset button.
private void appendinputorselect ( actioninputparameter parentinputparameter , string paramname , actioninputparameter childinputparameter , object [ ] possiblevalues ) throws ioexception { if ( possiblevalues . length > num_ ) { if ( childinputparameter . isarrayorcollection ( ) ) {	Appends simple input or select, depending on availability of possible values.
public affordancebuilder and ( affordancebuilder affordancebuilder ) { for ( actiondescriptor actiondescriptor : affordancebuilder . actiondescriptors ) { this . actiondescriptors . add ( actiondescriptor ) ; } return this ; }	Adds actionDescriptors of the given AffordanceBuilder to this affordanceBuilder.
public partialuritemplatecomponents ascomponents ( ) { return geturitemplatecomponents ( collections . < string , object > emptymap ( ) , collections . < string > emptylist ( ) ) ; }	Returns the template as uri components, without variable expansion.
public partialuritemplatecomponents stripoptionalvariables ( list < actiondescriptor > actiondescriptors ) { return geturitemplatecomponents ( collections . < string , object > emptymap ( ) , getrequiredargnames ( actiondescriptors ) ) ; }	Strips all variables which are not required by any of the given action descriptors.
public ubernode getfirstbyname ( string name ) {	Gets first child of this uber node having the given name attribute.
public ubernode getfirstbyrel ( string rel ) {	Gets first child of this uber node having the given rel attribute.
@ override public iterator < ubernode > iterator ( ) { return new iterator < ubernode > ( ) { int index = num_ ; @ override public void remove ( ) { throw new unsupportedoperationexception ( str_ ) ; } @ override public ubernode next ( ) { index = findnextchildwithdata ( ) ; return data . get ( index ++ ) ; } @ override public boolean hasnext ( ) { return findnextchildwithdata ( ) != - num_ ; } private int findnextchildwithdata ( ) { for ( int i = index ; i < data . size ( ) ; i ++ ) { if ( ! data . get ( i ) . getdata ( ) . isempty ( ) ) { return i ; } } return - num_ ; } } ; }	Allows iterating over children of this uber node which have a data attribute.
@ suppresswarnings ( str_ ) public static < k , v > persistenthashmap < k , v > ofeq ( equator < k > eq , iterable < map . entry < k , v > > es ) { if ( es == null ) { return empty ( eq ) ; } mutablehashmap < k , v > map = emptymutable ( eq ) ; for ( map . entry < k , v > entry : es ) { if ( entry != null ) { map . assoc ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return map . immutable ( ) ; }	Returns a new PersistentHashMap of the given keys and their paired values, skipping any nullEntries.
public static < k extends comparable < k > , v > persistenttreemap < k , v > of ( iterable < map . entry < k , v > > es ) { if ( es == null ) { return empty ( ) ; } persistenttreemap < k , v > map = new persistenttreemap < > ( equator . defaultcomparator ( ) , null , num_ ) ; for ( map . entry < k , v > entry : es ) { if ( entry != null ) { map = map . assoc ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return map ; }	Returns a new PersistentTreeMap of the given comparable keys and their paired values, skippingany null Entries.
public static < k , v > persistenttreemap < k , v > empty ( comparator < ? super k > c ) { return new persistenttreemap < > ( c , null , num_ ) ; }	Returns a new empty PersistentTreeMap that will use the specified comparator.
@ override public imsortedset < entry < k , v > > entryset ( ) {	Returns a view of the mappings contained in this map.
@ override public k lastkey ( ) { unentry < k , v > max = last ( ) ; if ( max == null ) { throw new nosuchelementexception ( str_ ) ; } return max . getkey ( ) ; }	Returns the last key in this map or throws a NoSuchElementException if the map is empty.
@ suppresswarnings ( str_ ) private static < h > h _fold ( iterable source , operation [ ] ops , int opidx , h ident , fn2 reducer ) { object ret = ident ;	than lazily evaluated and cached linked-list, Sequence model.
@ override public xform < a > dropwhile ( fn1 < ? super a , boolean > predicate ) { if ( predicate == null ) { throw new illegalargumentexception ( str_ ) ; } return new dropwhiledesc < > ( this , predicate ) ; }	The number of items to drop from the beginning of the output.
@ override public < b > b fold ( b ident , fn2 < ? super b , ? super a , b > reducer ) { if ( reducer == null ) { throw new illegalargumentexception ( str_ ) ; }	Provides a way to collect the results of the transformation.
public static < k , v > tuple2 < k , v > of ( map . entry < k , v > entry ) {	Map.Entry factory method.
@ suppresswarnings ( str_ ) public < r > r match ( fn1 < a , r > fa , fn1 < b , r > fb , fn1 < c , r > fc ) { if ( sel == num_ ) { return fa . apply ( ( a ) item ) ; } else if ( sel == num_ ) { return fb . apply ( ( b ) item ) ; } else { return fc . apply ( ( c ) item ) ; } }	If sel is managed correctly, it ensures that the cast is accurate.
public static imlist < class > registerclasses ( class ... cs ) { if ( cs == null ) { throw new illegalargumentexception ( str_ ) ; } if ( cs . length == num_ ) { throw new illegalargumentexception ( str_ ) ; } for ( class c : cs ) { if ( c == null ) { throw new illegalargumentexception ( str_ ) ; } } arrayholder < class > ah = new arrayholder < > ( cs ) ; imlist < class > registeredtypes ; synchronized ( lock . instance ) { registeredtypes = typemap . get ( ah ) ; if ( registeredtypes == null ) { imlist < class > veccs = vec ( cs ) ; typemap . put ( ah , veccs ) ; registeredtypes = veccs ; } }	Use this to prevent duplicate runtime types.
@ override public e get ( int i ) { e [ ] node = leafnodearrayfor ( i ) ; return node [ i & low_bits ] ; }	Returns the item specified by the given index.
@ suppresswarnings ( str_ ) @ override public persistentvector < e > append ( e val ) {	Inserts a new item at the end of the Vecsicle.
@ override public persistentvector < e > concat ( iterable < ? extends e > items ) { return ( persistentvector < e > ) imlist . super . concat ( items ) ; }	Efficiently adds items to the end of this PersistentVector.
@ safevarargs public static < t > mutableset < t > mutableset ( t ... items ) { mutableset < t > ret = persistenthashset . emptymutable ( ) ; if ( items == null ) { return ret ; } for ( t t : items ) { ret . put ( t ) ; } return ret ; }	Returns a new MutableSet of the values.
@ safevarargs public static < t > mutablelist < t > mutablevec ( t ... items ) { mutablelist < t > ret = persistentvector . emptymutable ( ) ; if ( items == null ) { return ret ; } for ( t t : items ) { ret . append ( t ) ; } return ret ; }	Returns a MutableVector of the given items.
@ safevarargs public static < t > imset < t > set ( t ... items ) { if ( ( items == null ) || ( items . length < num_ ) ) { return persistenthashset . empty ( ) ; } return persistenthashset . of ( arrays . aslist ( items ) ) ; }	Returns a new PersistentHashSet of the values.
@ safevarargs static public < t > imlist < t > vec ( t ... items ) { if ( ( items == null ) || ( items . length < num_ ) ) { return persistentvector . empty ( ) ; } return mutablevec ( items ) . immutable ( ) ; }	Returns a new PersistentVector of the given items.
@ safevarargs public static < t > unmoditerable < t > xformarray ( t ... items ) { return xform . of ( arrays . aslist ( items ) ) ; }	If you need to wrap a regular Java array outside this project to performa transformation on it, this method is the most convenient, efficient way to do so.
public static stringbuilder indentspace ( int len ) { stringbuilder sb = new stringbuilder ( ) ; if ( len < num_ ) { return sb ; } while ( len > spaces_length_minus_one ) { sb . append ( spaces [ spaces_length_minus_one ] ) ; len = len - spaces_length_minus_one ; } return sb . append ( spaces [ len ] ) ; }	Creates a new StringBuilder with the given number of spaces and returns it.
public static < t > string arraystring ( t [ ] items ) { stringbuilder sb = new stringbuilder ( str_ ) ; boolean isfirst = bool_ ; for ( t item : items ) { if ( isfirst ) { isfirst = bool_ ; } else { sb . append ( str_ ) ; } if ( item instanceof string ) { sb . append ( str_ ) . append ( item ) . append ( str_ ) ; } else { sb . append ( item ) ; } } return sb . append ( str_ ) . tostring ( ) ; }	There is Arrays.toString, but this is intended to produce Cymling code some day.
public static < t > lazyref < t > of ( fn0 < t > producer ) { if ( producer == null ) { throw new illegalargumentexception ( str_ ) ; } return new lazyref < > ( producer ) ; }	Construct a LazyRef from the given initialization function.
public synchronized t applyex ( ) {	This whole method is synchronized on the advice of Goetz2006 p. 347.
public static < t > t [ ] insertintoarrayat ( t item , t [ ] items , int idx , class < t > tclass ) {	Returns a new array one longer than the given one, with the specified item inserted at the specified index.
public static < t > t [ ] arraycopy ( t [ ] items , int length , class < t > tclass ) {	Returns a new array containing the first n items of the given array.
private void suspendifassoaciatedwiththread ( ) throws systemexception {	Some operations require that the transaction be suspended.
private void beforeasyncoperation ( ) throws illegalstateexception , securityexception { try { int status = transaction . getstatus ( ) ; if ( asyncoperationinitiated . getandset ( bool_ ) || ( status != status . status_active && status != status . status_marked_rollback ) ) { throw new illegalstateexception ( str_ + status ) ; } suspendifassoaciatedwiththread ( ) ; } catch ( systemexception e ) { throw new illegalstateexception ( e ) ; } }	Verifies if the wrapped transaction is active and if dissociates it fromthe thread if needed.
public list < servicecomponentimpl > buildcomponents ( string servicedescriptorfilename , jarfile deployableunitjar ) throws deploymentexception {	Builds a service component contained in the specified du jar file, with the specified and adds it to the specified deployable unit.
static private void validatedirectory ( file adirectory ) throws filenotfoundexception { if ( adirectory == null ) { throw new illegalargumentexception ( str_ ) ; } if ( ! adirectory . exists ( ) ) { throw new filenotfoundexception ( str_ + adirectory ) ; } if ( ! adirectory . isdirectory ( ) ) { throw new illegalargumentexception ( str_ + adirectory ) ; } if ( ! adirectory . canread ( ) ) { throw new illegalargumentexception ( str_ + adirectory ) ; } }	Directory is valid if it exists, does not represent a file, and can be read.
public static void createinheritancelink ( ctclass concreteclass , ctclass superclass ) { if ( superclass == null ) return ; try { concreteclass . setsuperclass ( superclass ) ; logger . trace ( concreteclass . getname ( ) + str_ + superclass . getname ( ) + str_ ) ; } catch ( cannotcompileexception cce ) { cce . printstacktrace ( ) ; } }	Create the inheritance link with the sbb absract class provided by thesbb developer.
public static void copymethods ( ctclass source , ctclass destination , ctclass [ ] exceptions ) { copymethods ( source . getdeclaredmethods ( ) , destination , exceptions ) ; }	Copy declared methods from one class to another.
public static void copymethods ( ctmethod [ ] methods , ctclass destination , ctclass [ ] exceptions ) { ctmethod methodcopy = null ; for ( ctmethod method : methods ) { try { methodcopy = new ctmethod ( method , destination , null ) ; if ( exceptions != null ) { try { methodcopy . setexceptiontypes ( exceptions ) ; } catch ( notfoundexception e ) { throw new sleeexception ( e . getmessage ( ) , e ) ; } } destination . addmethod ( methodcopy ) ; } catch ( cannotcompileexception e ) { throw new sleeexception ( e . getmessage ( ) , e ) ; } } }	Copy methods to a class.
private void removesbbentitywithcurrentclassloader ( final sbbentity sbbentity ) {	Removes the specified sbb entity but without changing to sbb's classloader first.
public boolean getnotificationsenabled ( string paramname ) { boolean arenotificationsenabled = paramnames . get ( paramname ) ; if ( ! isslee11 ) { if ( arenotificationsenabled == null || arenotificationsenabled . booleanvalue ( ) ) {	Indicates if notifications are enabled for the specified parameter name.
public set < string > getreferencedraentitylinkswhichnotexists ( servicecomponent servicecomponent ) { set < string > result = new hashset < string > ( ) ; set < string > ralinknames = sleecontainer . getresourcemanagement ( ) . getlinknamesset ( ) ; for ( string ralink : servicecomponent . getresourceadaptorentitylinks ( componentrepositoryimpl ) ) { if ( ! ralinknames . contains ( ralink ) ) { result . add ( ralink ) ; } } return result ; }	Retrieves the set of ra entity link names referenced by the servicecomponen, which do not exist.
public void installservice ( final servicecomponent servicecomponent ) throws exception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + servicecomponent ) ; }	Install a service into SLEE.
public void uninstallservice ( final servicecomponent servicecomponent ) throws systemexception , unrecognizedserviceexception , instancenotfoundexception , mbeanregistrationexception , nullpointerexception , unrecognizedresourceadaptorentityexception , managementexception , invalidstateexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + servicecomponent . getserviceid ( ) ) ; } if ( servicecomponent . getservicestate ( ) . isstopping ( ) ) {	uninstall a service.
public boolean israentitylinknamereferenced ( string ralinkname ) { if ( ralinkname == null ) { throw new nullpointerexception ( str_ ) ; } boolean b = bool_ ; try { b = transactionmanager . requiretransaction ( ) ; for ( serviceid serviceid : componentrepositoryimpl . getserviceids ( ) ) { servicecomponent servicecomponent = componentrepositoryimpl . getcomponentbyid ( serviceid ) ; if ( servicecomponent . getservicestate ( ) != servicestate . inactive && servicecomponent . getresourceadaptorentitylinks ( componentrepositoryimpl ) . contains ( ralinkname ) ) { return bool_ ; } } return bool_ ; } finally { try { transactionmanager . requiretransactionend ( b , bool_ ) ; } catch ( throwable ex ) { throw new sleeexception ( ex . getmessage ( ) , ex ) ; } } }	Verifies if the specified ra entity link name is referenced by a noninactive service.
public synchronized string [ ] getusageparametersets ( sbbid sbbid ) throws nullpointerexception , unrecognizedsbbexception , invalidargumentexception , managementexception { if ( sbbid == null ) throw new nullpointerexception ( str_ ) ;	This method returns a list containing the names of the named SBB usageparameter sets that belong to the SBB specified by the sbbID argument andthe Service represented by the ServiceUsageMBean object.
public synchronized void resetallusageparameters ( ) throws managementexception { try {	Resets the usage parameters of all SBBs within the Service represented bythe ServiceUsageMBean object.
public void displayresult ( ) {	Method to display result of operation.
protected string unfoldarray ( string prefix , object [ ] array , propertyeditor editor ) {	Default implementation.
void execute ( final activityhandle realhandle , final activityhandle refhandle , final fireableeventtype eventtype , final object event , final address address , final receivableservice receivableservice , final int eventflags ) throws activityisendingexception , fireeventexception , sleeexception , unrecognizedactivityhandleexception { final sleetransaction tx = super . suspendtransaction ( ) ; try { sleeendpoint . _fireevent ( realhandle , refhandle , eventtype , event , address , receivableservice , eventflags , tx ) ; } finally { if ( tx != null ) { super . resumetransaction ( tx ) ; } } }	Executes a non transacted fire event operation.
public void bindname ( object ach , string name ) throws namealreadyboundexception { final node node = getnode ( ) ; if ( node . haschild ( name ) ) { throw new namealreadyboundexception ( str_ ) ; } else { node . addchild ( fqn . fromelements ( name ) ) . put ( cache_node_map_key , ach ) ; } }	Binds the specified aci name with the specified activity context handle.
public object unbindname ( string name ) throws namenotboundexception { final node node = getnode ( ) ; final node childnode = node . getchild ( name ) ; if ( childnode == null ) { throw new namenotboundexception ( str_ ) ; } else { final object ach = childnode . get ( cache_node_map_key ) ; node . removechild ( name ) ; return ach ; } }	Unbinds the specified aci name with the specified activity context id.
public object lookupname ( string name ) { final node childnode = getnode ( ) . getchild ( name ) ; if ( childnode == null ) { return null ; } else { return childnode . get ( cache_node_map_key ) ; } }	Lookup of the activity context id bound to the specified aci name.
public map getnamebindings ( ) { map result = new hashmap ( ) ; node childnode = null ; object name = null ; for ( object obj : getnode ( ) . getchildren ( ) ) { childnode = ( node ) obj ; name = childnode . getfqn ( ) . getlastelement ( ) ; result . put ( name , childnode . get ( cache_node_map_key ) ) ; } return result ; }	Retrieves a map of the bindings. Key is the aci name and Value is the activity context handle.
public result next ( activitycontext ac , eventcontext sleeevent , set < sbbentityid > sbbentitiesthathandledcurrentevent , sleecontainer sleecontainer ) { sbbentityid sbbentityid = null ; sbbentity sbbentity = null ; evententrydescriptor mevententry = null ;	Retrieves the next sbb entity to handle the event.
public boolean ishigherlevel ( tracelevel other ) throws nullpointerexception { if ( other == null ) throw new nullpointerexception ( str_ ) ; return this . level < other . level ; }	Determine if this TraceLevel object represents a level that is higher than some otherTraceLevel object.
private void extractjar ( jarfile jarfile , file dstdir ) throws deploymentexception {	This method will extract all the files in the jar file.
private void pipestream ( inputstream is , outputstream os ) throws ioexception { synchronized ( buffer ) { try { for ( int bytesread = is . read ( buffer ) ; bytesread != - num_ ; bytesread = is . read ( buffer ) ) os . write ( buffer , num_ , bytesread ) ; is . close ( ) ; os . close ( ) ; } catch ( ioexception ioe ) { try { is . close ( ) ; } catch ( exception ioexc ) { } try { os . close ( ) ; } catch ( exception ioexc ) { } throw ioe ; } } }	Pipes data from the input stream into the output stream.
@ suppresswarnings ( str_ ) public object putobject ( object key , object value ) { return getnode ( ) . put ( key , value ) ; }	Puts an object in cache data.
public boolean attachsbbentity ( sbbentityid sbbentityid ) { final node node = getattachedsbbsnode ( bool_ ) ; if ( ! node . haschild ( sbbentityid ) ) { node . addchild ( fqn . fromelements ( sbbentityid ) ) ; return bool_ ; } else { return bool_ ; } }	Tries to attaches an sbb entity.
public boolean detachsbbentity ( sbbentityid sbbentityid ) { final node node = getattachedsbbsnode ( bool_ ) ; return node != null ? node . removechild ( sbbentityid ) : bool_ ; }	Detaches an sbb entity.
public boolean nosbbentitiesattached ( ) { final node node = getattachedsbbsnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) . isempty ( ) : bool_ ; }	Verifies if there at least one sbb entity attached.
@ suppresswarnings ( str_ ) public set < sbbentityid > getsbbentitiesattached ( ) { final node node = getattachedsbbsnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) : collections . emptyset ( ) ; }	Return a set with all sbb entities attached.
public boolean attachtimer ( timerid timerid ) { final node node = getattachedtimersnode ( bool_ ) ; if ( ! node . haschild ( timerid ) ) { node . addchild ( fqn . fromelements ( timerid ) ) ; return bool_ ; } else { return bool_ ; } }	Attaches a timer.
public boolean detachtimer ( timerid timerid ) { final node node = getattachedtimersnode ( bool_ ) ; return node != null ? node . removechild ( timerid ) : bool_ ; }	Detaches a timer.
public boolean notimersattached ( ) { final node node = getattachedtimersnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) . isempty ( ) : bool_ ; }	Verifies if there at least one timer attached.
public set getattachedtimers ( ) { final node node = getattachedtimersnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) : collections . emptyset ( ) ; }	Returns the set of timers attached to the ac.
public void namebound ( string name ) { final node node = getnamesboundnode ( bool_ ) ; if ( ! node . haschild ( name ) ) { node . addchild ( fqn . fromelements ( name ) ) ; } }	Adds the specified name to the set of names bound to the ac.
public boolean nameunbound ( string name ) { final node node = getnamesboundnode ( bool_ ) ; return node != null ? node . removechild ( name ) : bool_ ; }	Removes the specified name from the set of names bound to the ac.
public boolean nonamesbound ( ) { final node node = getnamesboundnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) . isempty ( ) : bool_ ; }	Verifies if there at least one name bound to the ac.
public set getnamesboundcopy ( ) { final node node = getnamesboundnode ( bool_ ) ; return node != null ? node . getchildrennames ( ) : collections . emptyset ( ) ; }	Returns the set of names bound to the ac.
@ suppresswarnings ( str_ ) public void setcmpattribute ( string attrname , object attrvalue ) { final node node = getcmpattributesnode ( bool_ ) ; node cmpnode = node . getchild ( attrname ) ; if ( cmpnode == null ) { cmpnode = node . addchild ( fqn . fromelements ( attrname ) ) ; } cmpnode . put ( cmp_attributes_node_map_key , attrvalue ) ; }	Sets the aci cmp attribute.
@ suppresswarnings ( str_ ) public object getcmpattribute ( string attrname ) { final node node = getcmpattributesnode ( bool_ ) ; if ( node == null ) { return null ; } else { final node cmpnode = node . getchild ( attrname ) ; if ( cmpnode != null ) { return cmpnode . get ( cmp_attributes_node_map_key ) ; } else { return null ; } } }	Retrieves the aci cmp attribute.
@ suppresswarnings ( str_ ) public map getcmpattributescopy ( ) { final node node = getcmpattributesnode ( bool_ ) ; if ( node == null ) { return collections . emptymap ( ) ; } else { map result = new hashmap ( ) ; node cmpnode = null ; for ( object obj : node . getchildren ( ) ) { cmpnode = ( node ) obj ; result . put ( cmpnode . getfqn ( ) . getlastelement ( ) , cmpnode . get ( cmp_attributes_node_map_key ) ) ; } return result ; } }	Retrieves a map copy of the aci attributes set.
private static mbeannotificationinfo [ ] initnotificationinfo ( ) { string [ ] notificationtypes = new string [ ] { profiletablenotification . usage_notification_type , resourceadaptorentitynotification . usage_notification_type , sbbnotification . usage_notification_type , subsystemnotification . usage_notification_type } ; return new mbeannotificationinfo [ ] { new mbeannotificationinfo ( notificationtypes , usagenotification . class . getname ( ) , str_ ) } ; }	Initiates the notification info for usage mbeans.
public void sendusagenotification ( long value , long seqno , string usageparametersetname , string usageparametername , boolean iscounter ) { usagenotificationmanagermbeanimpl notificationmanager = parent . getusagenotificationmanagermbean ( notificationsource ) ; if ( notificationmanager == null || notificationmanager . getnotificationsenabled ( usageparametername ) ) {	Send the notification.
private file downloadremotedu ( url duurl , file deploymentroot ) throws exception { inputstream in = null ; outputstream out = null ; try {	Downloads a remote DU to a local folder.
public void updatedeployedcomponents ( ) { try {	Updates the list of components already deployed to SLEE.
public void installdeployableunit ( deployableunit du ) throws exception {	Method for installing a Deployable Unit into SLEE.
public void uninstalldeployableunit ( deployableunit du ) throws exception {	Method for uninstalling a Deployable Unit into SLEE.
private void processinternalundeploy ( deployableunit du ) throws exception {	Sets the DU as not installed and remove it from waiting list if present there.Also, tries to undeploy DU's waiting for dependencies to be removed.
public string showstatus ( ) {	Method for showing current status of the Deployment Manager.
public boolean isloggable ( logrecord record ) { logger logger = getlogger ( record ) ; if ( record . getthrown ( ) != null ) { logwiththrowable ( logger , record ) ; } else { logwithoutthrowable ( logger , record ) ; } return bool_ ; }	If the message should be logged, convert the JDK 1.4LogRecord to a Log4J message.
private logger getlogger ( logrecord record ) { string loggername = record . getloggername ( ) ; logger logger = loggercache . get ( loggername ) ; if ( logger == null ) { logger = logger . getlogger ( loggername ) ; loggercache . put ( loggername , logger ) ; } return logger ; }	get the Log4J logger corresponding to the java.util.logger.LogRecord.
public set < sbbentityid > getsbbentities ( ) { final node node = getnode ( ) ; if ( node == null ) { return collections . emptyset ( ) ; } hashset < sbbentityid > result = new hashset < sbbentityid > ( ) ; serviceid serviceid = null ; for ( object obj : node . getchildrennames ( ) ) { serviceid = ( serviceid ) obj ; for ( sbbentityid sbbentityid : getrootsbbentityids ( serviceid ) ) { result . add ( sbbentityid ) ; collectsbbentities ( sbbentityid , result ) ; } } return result ; }	Retrieves a set containing sbb entity ids in the factorycache data.
private permissions getpermissions ( permissions permissions , final codesource cs , principal [ ] principals ) { list < policyholderentry > entries = this . currentpolicy . get ( ) . policyholderentries ; for ( policyholderentry phe : entries ) {	generic, for all calls.
public string getcodesources ( ) { list < string > css = new arraylist < string > ( ) ; for ( policyholderentry phe : this . currentpolicy . get ( ) . policyholderentries ) { css . add ( phe . getcodesource ( ) . getlocation ( ) == null ? str_ : phe . getcodesource ( ) . getlocation ( ) . tostring ( ) ) ; } return arrays . tostring ( css . toarray ( ) ) ; }	Some methods to expose info about what is goign on.
public boolean profileexists ( string profilename ) { boolean result = component . getprofileentityframework ( ) . findprofile ( this . getprofiletablename ( ) , profilename ) != null ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + ( result ? str_ : str_ ) + str_ + this . getprofiletablename ( ) ) ; } return result ; }	Determines if profile is in back end storage == visible to othercompoenents than MBean, if null is passed as argumetn it must check forany other than defualt?.
public void remove ( boolean isuninstall ) throws sleeexception { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + profiletablename ) ; }	Triggers remove operation on this profile table.
public void updateconfigurationproperties ( configproperties properties ) throws invalidconfigurationexception , invalidstateexception { if ( ! component . getdescriptor ( ) . getsupportsactivereconfiguration ( ) && ( sleecontainer . getsleestate ( ) != sleestate . stopped ) && ( state == resourceadaptorentitystate . active || state == resourceadaptorentitystate . stopping ) ) { throw new invalidstateexception ( str_ ) ; } else { object . raconfigurationupdate ( properties ) ; } }	Updates the ra entity config properties.
@ suppresswarnings ( { str_ , str_ } ) public void sleerunning ( ) throws invalidstateexception {	Signals that the container is in RUNNING state.
public void sleestopping ( ) throws invalidstateexception , transactionrequiredlocalexception { if ( state != null && state . isactive ( ) ) { try { object . rastopping ( ) ; } catch ( throwable t ) { logger . error ( str_ , t ) ; } scheduleallactivitiesend ( ) ; } }	Signals that the container is in STOPPING state.
@ suppresswarnings ( { str_ , str_ } ) public void activate ( ) throws invalidstateexception { if ( ! this . state . isinactive ( ) ) { throw new invalidstateexception ( str_ + name + str_ + this . state ) ; } this . state = resourceadaptorentitystate . active ;	Activates the ra entity.
public void deactivate ( ) throws invalidstateexception , transactionrequiredlocalexception { if ( ! this . state . isactive ( ) ) { throw new invalidstateexception ( str_ + name + str_ + this . state ) ; } this . state = resourceadaptorentitystate . stopping ; if ( object . getstate ( ) == resourceadaptorobjectstate . active ) { object . rastopping ( ) ; }	Deactivates the ra entity.
private void scheduleallactivitiesend ( ) throws transactionrequiredlocalexception {	schedules the ending of all the entity activities, this is needed on raentity deactivation or slee container stop, once the process ends it willinvoke allActivitiesEnded to complete those processes.
public void remove ( ) throws invalidstateexception { if ( ! this . state . isinactive ( ) ) { throw new invalidstateexception ( str_ + name + str_ + this . state ) ; } object . raunconfigure ( ) ; if ( object . isfaulttolerant ( ) ) { object . unsetfaulttolerantresourceadaptorcontext ( ) ; ftresourceadaptorcontext . shutdown ( ) ; } object . unsetresourceadaptorcontext ( ) ; this . sleecontainer . gettracemanagement ( ) . deregisternotificationsource ( this . getnotificationsource ( ) ) ; state = null ; }	Removes the entity, it will unconfigure and unset the ra context, theentity object can not be reused.
public object getresourceadaptorinterface ( resourceadaptortypeid ratype ) { return object . getresourceadaptorinterface ( sleecontainer . getcomponentrepository ( ) . getcomponentbyid ( ratype ) . getdescriptor ( ) . getresourceadaptorinterface ( ) ) ; }	Retrieves the ra interface for this entity and the specified ra type.
public void serviceactive ( serviceid serviceid ) { try { receivableservice receivableservice = resourceadaptorcontext . getservicelookupfacility ( ) . getreceivableservice ( serviceid ) ; if ( receivableservice . getreceivableevents ( ) . length > num_ ) { object . serviceactive ( receivableservice ) ; } } catch ( throwable e ) { logger . warn ( str_ , e ) ; } }	Indicates a service was activated, the entity will forward thisnotification to the ra object.
activityhandle derreferactivityhandle ( activityhandle handle ) { activityhandle ah = null ; if ( resourcemanagement . gethandlereferencefactory ( ) != null && handle . getclass ( ) == activityhandlereference . class ) { activityhandlereference ahreference = ( activityhandlereference ) handle ; ah = resourcemanagement . gethandlereferencefactory ( ) . getactivityhandle ( ahreference ) ; } else { ah = handle ; } return ah ; }	if it is a handle reference it gets the referred handle.
public void activityended ( final activityhandle handle , int activityflags ) { logger . trace ( str_ + handle + str_ ) ; activityhandle ah = null ; if ( handle instanceof activityhandlereference ) {	Callback to notify the entity and possibly the ra object, informing activity handled ended.
public void raconfigurationupdate ( configproperties properties ) throws invalidconfigurationexception { if ( dotracelogs ) { logger . trace ( str_ + properties + str_ ) ; } verifyconfigproperties ( properties ) ; object . raconfigurationupdate ( configproperties ) ; }	Updates the ra configuration.
private void verifyconfigproperties ( configproperties newproperties ) throws invalidconfigurationexception { if ( dotracelogs ) { logger . trace ( str_ + newproperties + str_ ) ; }	Merges the current properties values with the new ones and uses the ra toverify the configuration.
public void rastopping ( ) throws invalidstateexception { if ( dotracelogs ) { logger . trace ( str_ ) ; } if ( state == resourceadaptorobjectstate . active ) { state = resourceadaptorobjectstate . stopping ; object . rastopping ( ) ; } else { throw new invalidstateexception ( str_ + state ) ; } }	Requests the stopping of the ra object.
public void rainactive ( ) throws invalidstateexception { if ( dotracelogs ) { logger . trace ( str_ ) ; } if ( state == resourceadaptorobjectstate . stopping ) { state = resourceadaptorobjectstate . inactive ; object . rainactive ( ) ; } else { throw new invalidstateexception ( str_ + state ) ; } }	Requests the deactivation of the ra object.
public void raunconfigure ( ) throws invalidstateexception { if ( dotracelogs ) { logger . trace ( str_ ) ; } if ( state == resourceadaptorobjectstate . inactive ) { state = resourceadaptorobjectstate . unconfigured ; object . raunconfigure ( ) ; } else { throw new invalidstateexception ( str_ + state ) ; } }	Unconfigures the ra object.
public void unsetresourceadaptorcontext ( ) throws invalidstateexception { if ( dotracelogs ) { logger . trace ( str_ ) ; } if ( state == resourceadaptorobjectstate . unconfigured ) { object . unsetresourceadaptorcontext ( ) ; state = null ; } else { throw new invalidstateexception ( str_ + state ) ; } }	Unsets the context of the ra object.
@ suppresswarnings ( str_ ) public void unsetfaulttolerantresourceadaptorcontext ( ) throws illegalargumentexception { if ( dotracelogs ) { logger . trace ( str_ ) ; } if ( isfaulttolerant ( ) ) { ( ( faulttolerantresourceadaptor < serializable , serializable > ) this . object ) . unsetfaulttolerantresourceadaptorcontext ( ) ; } else { throw new illegalargumentexception ( str_ ) ; } }	Unsets the ft context of the ra object.
private void buildprofileattributemap ( ) throws deploymentexception { hashmap < string , profileattribute > map = new hashmap < string , profileattribute > ( ) ; class < ? > cmpinterface = getprofilecmpinterfaceclass ( ) ; string attributegettermethodprefix = str_ ; for ( method method : cmpinterface . getmethods ( ) ) { if ( ! method . getdeclaringclass ( ) . equals ( object . class ) && method . getname ( ) . startswith ( attributegettermethodprefix ) ) { string attributename = method . getname ( ) . substring ( attributegettermethodprefix . length ( ) ) ; switch ( attributename . length ( ) ) { case num_ : throw new deploymentexception ( str_ + method . getname ( ) ) ; case num_ : attributename = attributename . tolowercase ( ) ; break ; default : attributename = attributename . substring ( num_ , num_ ) . tolowercase ( ) + attributename . substring ( num_ ) ; break ; } profileattributeimpl profileattribute = null ; try { profileattribute = new profileattributeimpl ( attributename , method . getreturntype ( ) ) ; } catch ( throwable e ) { throw new deploymentexception ( str_ + attributename + str_ + method . getreturntype ( ) + str_ , e ) ; } if ( isslee11 ( ) ) { for ( profilecmpfielddescriptor cmpfield : getdescriptor ( ) . getprofilecmpinterface ( ) . getcmpfields ( ) ) { if ( cmpfield . getcmpfieldname ( ) . equals ( attributename ) ) {	Builds the profile attribute map using the cmp interface class.
private void resume ( ) {	the real logic to resume the event context.
@ suppresswarnings ( str_ ) public set < activitycontexthandle > getactivitycontexthandles ( ) { final node node = getnode ( ) ; return node != null ? node . getchildrennames ( ) : collections . emptyset ( ) ; }	Retrieves a set containing all activity context handles in the factory'scache data.
public objectname getusagembean ( string paramsetname ) throws nullpointerexception , unrecognizedusageparametersetnameexception , managementexception { if ( paramsetname == null ) throw new nullpointerexception ( str_ ) ; return _getusagembean ( paramsetname ) ; }	Retrieves the object name for the usage param mbean with the specifiedname.
public boolean decorateabstractclass ( ) throws deploymentexception { classpool pool = component . getclasspool ( ) ; profileabstractclassdescriptor abstractclass = component . getdescriptor ( ) . getprofileabstractclass ( ) ; if ( abstractclass == null ) { return bool_ ; } string abstractclassname = abstractclass . getprofileabstractclassname ( ) ; try { ctclass = pool . get ( abstractclassname ) ; } catch ( notfoundexception nfe ) { throw new deploymentexception ( str_ + abstractclassname , nfe ) ; } decorateclassjndiaddtoenvironmentcalls ( ) ; if ( isabstractclassdecorated ) { try { string deploydir = component . getdeploymentdir ( ) . getabsolutepath ( ) ; ctclass . writefile ( deploydir ) ; ctclass . detach ( ) ;	Decorate the abstract Class.
public static void fireevent ( sbbentity sbbentity , eventtypeid eventtypeid , object eventobject , activitycontextinterface aci , address address ) { fireevent ( sbbentity , eventtypeid , eventobject , aci , address , null ) ; }	The logic to fire an event from an SLEE 1.0 Sbb.
public static void fireevent ( sbbentity sbbentity , eventtypeid eventtypeid , object eventobject , activitycontextinterface aci , address address , serviceid serviceid ) { if ( sleecontainer . getcongestioncontrol ( ) . refusefireevent ( ) ) { throw new sleeexception ( str_ ) ; }	The logic to fire an event from an SLEE 1.1 Sbb.
public static object getprofilecmpmethod ( sbbentity sbbentity , string getprofilecmpmethodname , profileid profileid ) throws unrecognizedprofiletablenameexception , unrecognizedprofilenameexception { getprofilecmpmethoddescriptor mgetprofilecmpmethod = sbbentity . getsbbcomponent ( ) . getdescriptor ( ) . getgetprofilecmpmethods ( ) . get ( getprofilecmpmethodname ) ; if ( mgetprofilecmpmethod == null ) throw new abstractmethoderror ( str_ ) ; if ( sbbentity . getsbbobject ( ) . getstate ( ) != sbbobjectstate . ready ) { throw new illegalstateexception ( str_ ) ; } profilemanagement sleeprofilemanager = sleecontainer . getsleeprofiletablemanager ( ) ; profiletable profiletable = sleeprofilemanager . getprofiletable ( profileid . getprofiletablename ( ) ) ; if ( ! profiletable . profileexists ( profileid . getprofilename ( ) ) ) { throw new unrecognizedprofilenameexception ( profileid . tostring ( ) ) ; } return profiletable . getprofile ( profileid . getprofilename ( ) ) . getprofilecmpslee10wrapper ( ) ; }	Retrieves a profile given the cmp method name and profile id.
public static map getabstractmethodsfromclass ( ctclass sbbabstractclass ) { hashmap abstractmethods = new hashmap ( ) ; ctmethod [ ] methods = sbbabstractclass . getdeclaredmethods ( ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { if ( modifier . isabstract ( methods [ i ] . getmodifiers ( ) ) ) { abstractmethods . put ( methods [ i ] . getname ( ) , methods [ i ] ) ; } } return abstractmethods ; }	Retrieve all abstract methods from a class.
public static map getinterfacemethodsfrominterface ( ctclass interfaceclass , map exceptmethods ) { hashmap interfacemethods = new hashmap ( ) ; ctmethod [ ] methods = interfaceclass . getdeclaredmethods ( ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { if ( exceptmethods . get ( methods [ i ] . getname ( ) ) == null ) { concreteclassgeneratorutils . logger . trace ( methods [ i ] . getname ( ) ) ; interfacemethods . put ( getmethodkey ( methods [ i ] ) , methods [ i ] ) ; } } map temp = getsuperclassesabstractmethodsfrominterface ( interfaceclass ) ; for ( iterator i = temp . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; if ( ! exceptmethods . containskey ( key ) ) { interfacemethods . put ( key , temp . get ( key ) ) ; } } return interfacemethods ; }	Retrieve all methods from an interface, including super interfaces, except the ones specified in the provided map.
public void createobjectpool ( final profiletableimpl profiletable , final sleetransactionmanager sleetransactionmanager ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + profiletable ) ; } createobjectpool ( profiletable ) ; if ( sleetransactionmanager != null ) {	Creates an object pool for the specified profile table.
public void removeobjectpool ( final profiletableimpl profiletable , final sleetransactionmanager sleetransactionmanager ) { transactionalaction action = new transactionalaction ( ) { public void execute ( ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + profiletable ) ; } removeobjectpool ( profiletable ) ; } } ; if ( sleetransactionmanager != null ) { sleetransactionmanager . gettransactioncontext ( ) . getaftercommitactions ( ) . add ( action ) ; } else { action . execute ( ) ; } }	Removes the object pool for the specified profile table.
public boolean issourceownerofalarm ( notificationsourcewrapper notificationsource , string alarmid ) { alarmplaceholder aph = this . alarmidtoalarm . get ( alarmid ) ; if ( aph == null ) return bool_ ; return aph . getnotificationsource ( ) . getnotificationsource ( ) . equals ( notificationsource . getnotificationsource ( ) ) ; }	NON MBEAN - used only internal, those methods are not exposed via jmx.
public string raisealarm ( notificationsourcewrapper notificationsource , string alarmtype , string instanceid , alarmlevel level , string message , throwable cause ) { synchronized ( notificationsource ) { if ( isalarmalive ( notificationsource , alarmtype , instanceid ) ) {	THis methods raises alarm.
public static object getusageparameterset ( profileobjectimpl profileobject , string name ) throws unrecognizedusageparametersetnameexception { if ( logger . isdebugenabled ( ) ) { logger . info ( str_ + name + str_ + profileobject ) ; } if ( name == null ) { throw new nullpointerexception ( str_ ) ; } profiletableimpl profiletable = profileobject . getprofiletable ( ) ; object result = profiletable . getprofiletableusagembean ( ) . getinstalledusageparameterset ( name ) ; if ( result == null ) { throw new unrecognizedusageparametersetnameexception ( ) ; } else { return result ; } }	Usage methods. Here we can be static for sure. Rest must be tested.
public javax . slee . management . eventtypedescriptor getspecsdescriptor ( ) { if ( specsdescriptor == null ) { specsdescriptor = new javax . slee . management . eventtypedescriptor ( geteventtypeid ( ) , getdeployableunit ( ) . getdeployableunitid ( ) , getdeploymentunitsource ( ) , descriptor . getlibraryrefs ( ) . toarray ( new libraryid [ descriptor . getlibraryrefs ( ) . size ( ) ] ) , getdescriptor ( ) . geteventclassname ( ) ) ; } return specsdescriptor ; }	Retrieves the JAIN SLEE specs event type descriptor.
public boolean accepts ( url deployableuniturl , string deployableunitname ) { deployableunitwrapper du = new deployableunitwrapper ( deployableuniturl , deployableunitname ) ; url url = du . geturl ( ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + url + str_ + deployableunitname + str_ ) ; } try { string fullpath = url . getfile ( ) ; string filename = fullpath . substring ( fullpath . lastindexof ( str_ ) + num_ , fullpath . length ( ) ) ;	Method for deciding whether or not to accept the file.
public void init ( url deployableuniturl , string deployableunitname ) throws deploymentexception { url url = deployableuniturl ; deployableunitwrapper du = new deployableunitwrapper ( deployableuniturl , deployableunitname ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + deployableuniturl + str_ + deployableunitname + str_ ) ; }	Initializer method for accepted files.
public void start ( url deployableuniturl , string deployableunitname ) throws deploymentexception { deployableunitwrapper du = new deployableunitwrapper ( deployableuniturl , deployableunitname ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + du . geturl ( ) + str_ + deployableunitname + str_ ) ; } try {	This is where the fun begins. Time to deploy!.
public void stop ( url deployableuniturl , string deployableunitname ) throws deploymentexception { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + deployableuniturl + str_ ) ; } deployableunitwrapper du = new deployableunitwrapper ( deployableuniturl , deployableunitname ) ; deployableunit realdu = null ; string filename = du . getfilename ( ) ; if ( ( realdu = deployableunits . get ( du . getfilename ( ) ) ) != null ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + realdu . getdeploymentinfoshortname ( ) ) ; } if ( ! isinundeploylist ( filename ) ) { addtoundeploylist ( filename ) ; } try {	Fun has ended. Time to undeploy.
public string showstatus ( ) throws deploymentexception { string output = str_ ; output += str_ ; for ( string key : deployableunits . keyset ( ) ) { output += str_ + key + str_ + deployableunits . get ( key ) + str_ ; for ( string ducomponent : deployableunits . get ( key ) . getcomponents ( ) ) { output += str_ + ducomponent + str_ ; } } output += str_ ; for ( string key : toaccept . keyset ( ) ) { output += str_ + key + str_ + toaccept . get ( key ) + str_ ; } output += str_ ; for ( string undeploy : undeploys ) { output += str_ + undeploy + str_ ; } output += str_ ; output += sleecontainerdeployer . getdeploymentmanager ( ) . showstatus ( ) ; return output ; }	MBean operation for getting Deployer status.
protected void executeaftercommitactions ( ) { if ( aftercommitactions != null ) { if ( trace ) { logger . trace ( str_ ) ; } executeactions ( aftercommitactions , trace ) ; aftercommitactions = null ; } }	Executes actions scheduled after commit succeeds.
protected void executeaftercommitpriorityactions ( ) { if ( aftercommitpriorityactions != null ) { if ( trace ) { logger . trace ( str_ ) ; } executeactions ( aftercommitpriorityactions , trace ) ; aftercommitpriorityactions = null ; } }	Executes actions scheduled to run first after commit succeeds.
protected void executeafterrollbackactions ( ) { if ( afterrollbackactions != null ) { if ( trace ) { logger . trace ( str_ ) ; } executeactions ( afterrollbackactions , trace ) ; afterrollbackactions = null ; } }	Executes actions scheduled for after a rollback.
protected void executebeforecommitactions ( ) { if ( beforecommitactions != null ) { if ( trace ) { logger . trace ( str_ ) ; } executeactions ( beforecommitactions , trace ) ; beforecommitactions = null ; } }	Executes actions scheduled for before commit.
protected void executebeforecommitpriorityactions ( ) { if ( beforecommitpriorityactions != null ) { if ( trace ) { logger . trace ( str_ ) ; } executeactions ( beforecommitpriorityactions , trace ) ; beforecommitpriorityactions = null ; } }	Executes actions scheduled for before commit at first.
public string [ ] getdefinedtracernames ( ) { set < string > names = new hashset < string > ( ) ; for ( tracerimpl t : this . tracers . values ( ) ) { if ( t . isexplicitlysettracerlevel ( ) ) names . add ( t . gettracername ( ) ) ; } if ( names . isempty ( ) ) return new string [ num_ ] ; return names . toarray ( new string [ names . size ( ) ] ) ; }	This method returns tracer names that have been defined explicitly viasetTraceLevel from TraceMBean.
public tracer createtracer ( string tracername , boolean requestedbysource ) { tracerimpl tparent = null ; tracerimpl t = tracers . get ( tracername ) ; if ( t == null ) { string [ ] split = tracername . split ( str_ ) ; string currentname = str_ ; for ( string s : split ) { if ( tparent == null ) {	This method can be called multiple times.
public void removereplicatedata ( ) { if ( replicateddatawithfailover != null ) { replicateddatawithfailover . remove ( ) ; replicateddatawithfailover = null ; } if ( replicateddata != null ) { replicateddata . remove ( ) ; replicateddata = null ; } }	Removes all replicated data.
public void process ( sleecomponentwithusageparametersinterface component ) throws deploymentexception { classpool classpool = component . getclasspool ( ) ; string deploymentdir = component . getdeploymentdir ( ) . getabsolutepath ( ) ; class < ? > usageparametersinterface = component . getusageparametersinterface ( ) ; if ( usageparametersinterface != null ) { try {	Generates classes for a slee component, which defines usage parameters.
public sbbobjectpoolimpl getobjectpool ( serviceid serviceid , sbbid sbbid ) { return pools . get ( new objectpoolmapkey ( serviceid , sbbid ) ) ; }	Retrieves the object pool for the specified sbb and service.
public void createobjectpool ( final serviceid serviceid , final sbbcomponent sbbcomponent , final sleetransactionmanager sleetransactionmanager ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + serviceid + str_ + sbbcomponent ) ; } createobjectpool ( serviceid , sbbcomponent ) ; if ( sleetransactionmanager != null && sleetransactionmanager . gettransactioncontext ( ) != null ) {	Creates an object pool for the specified service and sbb.
void execute ( final activityhandle handle ) throws unrecognizedactivityhandleexception { final sleetransaction tx = super . suspendtransaction ( ) ; try { sleeendpoint . _endactivity ( handle , tx ) ; } finally { if ( tx != null ) { super . resumetransaction ( tx ) ; } } }	Executes a non transacted End Activity operation.
activitycontexthandle _startactivity ( activityhandle handle , int activityflags , final sleetransaction barriertx ) { activitycontext ac = null ; if ( raentity . gethandlereferencefactory ( ) != null && ! activityflags . hassleemaymarshal ( activityflags ) ) { final activityhandlereference reference = raentity . gethandlereferencefactory ( ) . createactivityhandlereference ( handle ) ; try {	Start activity logic, independent of transaction management.
void _endactivity ( activityhandle handle , final sleetransaction barriertx ) throws unrecognizedactivityhandleexception { final activitycontexthandle ach = new resourceadaptoractivitycontexthandleimpl ( raentity , handle ) ;	End activity logic independent of transaction management.
private void checkfireeventpreconditions ( activityhandle handle , fireableeventtype eventtype , object event ) throws nullpointerexception , illegaleventexception , illegalstateexception { if ( event == null ) throw new nullpointerexception ( str_ ) ; if ( handle == null ) throw new nullpointerexception ( str_ ) ; if ( eventtype == null ) { throw new nullpointerexception ( str_ ) ; } final eventtypecomponent eventtypecomponent = componentrepository . getcomponentbyid ( eventtype . geteventtype ( ) ) ; if ( eventtypecomponent == null ) { throw new illegaleventexception ( str_ ) ; } if ( ! eventtypecomponent . geteventtypeclass ( ) . isassignablefrom ( event . getclass ( ) ) ) { throw new illegaleventexception ( str_ ) ; } if ( eventtype . getclass ( ) != fireableeventtypeimpl . class ) { throw new illegaleventexception ( str_ ) ; } if ( raentity . getallowedeventtypes ( ) != null && ! raentity . getallowedeventtypes ( ) . contains ( eventtype . geteventtype ( ) ) ) { throw new illegaleventexception ( str_ + eventtype . geteventtype ( ) + str_ ) ; } }	Checks that fire event methods can be invoked.
void _fireevent ( activityhandle realhandle , activityhandle refhandle , fireableeventtype eventtype , object event , address address , receivableservice receivableservice , int eventflags , final sleetransaction barriertx ) throws activityisendingexception , sleeexception { final activitycontexthandle ach = new resourceadaptoractivitycontexthandleimpl ( raentity , refhandle ) ;	Event firing logic independent of transaction management.
public class generatesbblocalobjectconcreteclass ( ) {	Generate the Sbb Local Object Class.
protected void makegetter ( ) { if ( fieldclass . equals ( boolean . class ) || fieldclass . equals ( boolean . class ) ) { super . operationname = str_ + this . beanfieldname ; } else { super . operationname = str_ + this . beanfieldname ; } }	User should overide it to provide different name, for instance for boolean \"is\" prefix.
protected object convert ( string optarg ) throws securityexception , nosuchmethodexception , illegalargumentexception , instantiationexception , illegalaccessexception , invocationtargetexception , commandexception { if ( fieldclass . isprimitive ( ) ) {	This method is called to convert optArg from string form, if no conversion is needed it should return passed object.
public final void setprofileid ( string profiletablename , string profilename ) throws nullpointerexception , illegalargumentexception { if ( profiletablename == null ) throw new nullpointerexception ( str_ ) ; if ( profilename == null ) throw new nullpointerexception ( str_ ) ; if ( profiletablename . indexof ( str_ ) >= num_ ) throw new illegalargumentexception ( str_ ) ; this . profiletablename = profiletablename ; this . profilename = profilename ; this . address = null ; }	Set the profile table and profile referenced by this profile identifier to newvalues.
private string extractmessage ( string result ) {	protected DeployableUnitsCard deployableUnitsCard;.
public boolean contains ( object object ) { if ( ! ( object instanceof sbblocalobject ) ) return bool_ ; final sbblocalobjectimpl sbblocal = ( sbblocalobjectimpl ) object ; final sbbentityid sbbentityid = sbblocal . getsbbentityid ( ) ; if ( ! idbelongstochildrelation ( sbbentityid ) ) { return bool_ ; } return new sbbentitycachedata ( sbbentityid , sleecontainer . getcluster ( ) . getmobicentscache ( ) ) . exists ( ) ; }	The contains method. This method returns true if the SBB entityrepresented by the SBB local object specified by the input argument is amember of this child relation. If the method argument is not an SBB localobject, is an invalid SBB local object, or is an SBB local object whoseunderlying SBB entity is not a member of this child relation, then thismethod returns false.
@ suppresswarnings ( str_ ) public boolean containsall ( collection c ) { if ( c == null ) throw new nullpointerexception ( str_ ) ; for ( iterator it = c . iterator ( ) ; it . hasnext ( ) ; ) { if ( ! contains ( it . next ( ) ) ) { return bool_ ; } } if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + c + str_ ) ; } return bool_ ; }	This method returns true if all SBB entities represented by the SBB localobjects in the collection specified by the input argument are members ofthis child relation.
@ suppresswarnings ( str_ ) public boolean removeall ( collection c ) { boolean flag = bool_ ; if ( c == null ) throw new nullpointerexception ( str_ ) ; for ( iterator it = c . iterator ( ) ; it . hasnext ( ) ; ) { flag &= this . remove ( it . next ( ) ) ; } return flag ; }	Removing an SBB entity from a child relation initiates a cascadingremoval of the SBB entity tree rooted by the SBB entity, similar toinvoking the remove method on an SBB local object that represents the SBBentity.
public boolean ishigherlevel ( level other ) throws nullpointerexception { if ( other == null ) throw new nullpointerexception ( str_ ) ; return this . level < other . level ; }	Determine if this Level object represents a level that is higher or more severethat some other Level object.
private object readresolve ( ) throws streamcorruptedexception { if ( level == level_off ) return off ; if ( level == level_severe ) return severe ; if ( level == level_warning ) return warning ; if ( level == level_info ) return info ; if ( level == level_config ) return config ; if ( level == level_fine ) return fine ; if ( level == level_finer ) return finer ; if ( level == level_finest ) return finest ; throw new streamcorruptedexception ( str_ ) ; }	Resolve deserialisation references so that the singleton property of eachenumerated object is preserved.
public void clean ( ) { for ( classpath classpath : classpaths ) { classpool . removeclasspath ( classpath ) ; } for ( string classmade : classesmade ) { try { classpool . get ( classmade ) . detach ( ) ; } catch ( notfoundexception e ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + classmade + str_ , e ) ; } } } }	cleans up the class pool cache.
@ suppresswarnings ( str_ ) public static void addprofilecall ( profileobjectimpl po ) throws sleeexception { sleetransactionmanager sleetransactionmanager = sleecontainer . gettransactionmanager ( ) ; try { if ( sleetransactionmanager . gettransaction ( ) == null ) { return ; } } catch ( systemexception se ) { throw new sleeexception ( str_ , se ) ; } string key = makekey ( po ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + key + str_ ) ; } final transactioncontext txcontext = sleetransactionmanager . gettransactioncontext ( ) ; profilecallrecordertransactiondata data = ( profilecallrecordertransactiondata ) txcontext . getdata ( ) . get ( transaction_context_key ) ;	Adds call to this profile.
public profileobjectimpl getprofile ( string profilename ) throws transactionrequiredlocalexception , sleeexception { map txdata = gettxdata ( ) ; profiletransactionid key = new profiletransactionid ( profilename , profiletable . getprofiletablename ( ) ) ; profileobjectimpl value = ( profileobjectimpl ) txdata . get ( key ) ; if ( value == null ) { profileobjectpool pool = profiletable . getprofilemanagement ( ) . getobjectpoolmanagement ( ) . getobjectpool ( profiletable . getprofiletablename ( ) ) ; value = pool . borrowobject ( ) ; passivateprofileobjectontxend ( profiletable . getsleecontainer ( ) . gettransactionmanager ( ) , value , pool ) ; try { value . profileactivate ( profilename ) ; } catch ( unrecognizedprofilenameexception e ) { value . invalidateobject ( ) ; pool . invalidateobject ( value ) ; return null ; } txdata . put ( key , value ) ; } return value ; }	Retrieves a profile object for the table and specified profile name,there is only one profile object per profile entity per transaction.
public static void passivateprofileobjectontxend ( sleetransactionmanager txmanager , final profileobjectimpl profileobject , final profileobjectpool pool ) { transactionalaction afterrollbackaction = new transactionalaction ( ) { public void execute ( ) { profileobject . invalidateobject ( ) ; pool . returnobject ( profileobject ) ; } } ; transactionalaction beforecommitaction = new transactionalaction ( ) { public void execute ( ) { if ( profileobject . getstate ( ) == profileobjectstate . ready ) { if ( ! profileobject . getprofileentity ( ) . isremove ( ) ) { profileobject . fireaddorupdatedeventifneeded ( ) ; profileobject . profilepassivate ( ) ; } else { profileobject . profileremove ( bool_ , bool_ ) ; } pool . returnobject ( profileobject ) ; } } } ; final transactioncontext txcontext = txmanager . gettransactioncontext ( ) ; txcontext . getafterrollbackactions ( ) . add ( afterrollbackaction ) ; txcontext . getbeforecommitactions ( ) . add ( beforecommitaction ) ; }	Adds transactional actions to the active transaction to passivate aprofile object.
public void setastext ( string text ) { if ( text == null || text . equals ( str_ ) ) { super . setvalue ( new componentid [ num_ ] ) ; } else { java . util . arraylist results = new java . util . arraylist ( ) ;	Set the element as text value, parse it and setValue.The separator is CID_SEPARATOR.
public class generateactivitycontextinterfaceconcreteclass ( ) throws deploymentexception { string tmpclassname = concreteclassgeneratorutils . concrete_activity_interface_class_name_prefix + activitycontextinterfacename + concreteclassgeneratorutils . concrete_activity_interface_class_name_suffix ; concreteactivitycontextinterface = pool . makeclass ( tmpclassname ) ; ctclass sbbactivitycontextinterface = null ; try { activitycontextinterface = pool . get ( activitycontextinterfacename ) ; sbbactivitycontextinterface = pool . get ( sbbactivitycontextinterfaceimpl . class . getname ( ) ) ; } catch ( notfoundexception nfe ) { throw new deploymentexception ( str_ + activitycontextinterfacename , nfe ) ; }	Generate the Activity Context Interface Class.
private void generateconcretemethods ( map interfacemethods ) { if ( interfacemethods == null ) return ; iterator it = interfacemethods . values ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { ctmethod interfacemethod = ( ctmethod ) it . next ( ) ; if ( interfacemethod != null	Generates the concrete methods of the class It generates a specificmethod implementation for the javax.slee.ActivityContextInterface methodsfor the methods coming from the ActivityContextInterface developer thecall is routed to the base asbtract class.
public void setdataattribute ( string key , object newvalue ) { cachedata . setcmpattribute ( key , newvalue ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + getactivitycontexthandle ( ) + str_ + key + str_ + newvalue ) ; } }	Set a shared data item for the ACI.
public void addnamebinding ( string aciname ) { cachedata . namebound ( aciname ) ; if ( acreferenceshandler != null ) { acreferenceshandler . namereferencecreated ( ) ; } }	add a naming binding to this activity context.
private void removenamingbindings ( ) { activitycontextnamingfacility acf = sleecontainer . getactivitycontextnamingfacility ( ) ; for ( object obj : cachedata . getnamesboundcopy ( ) ) { string aciname = ( string ) obj ; try { acf . removename ( aciname ) ; } catch ( exception e ) { logger . warn ( str_ + aciname + str_ + getactivitycontexthandle ( ) , e ) ; } } }	This is called to release all the name bindings after the activity endevent is delivered to the sbb.
public boolean removenamebinding ( string aciname ) { boolean removed = cachedata . nameunbound ( aciname ) ; if ( removed && acreferenceshandler != null ) { acreferenceshandler . namereferenceremoved ( ) ; } return removed ; }	Add the given name to the set of activity context names that we are boundto.
public boolean attachtimer ( timerid timerid ) { if ( cachedata . attachtimer ( timerid ) ) { if ( acreferenceshandler != null ) { acreferenceshandler . timerreferencecreated ( ) ; } return bool_ ; } else { return bool_ ; } }	attach the given timer to the current activity context.
private void removefromtimers ( ) { timerfacility timerfacility = sleecontainer . gettimerfacility ( ) ;	End Event has been delivered on the Activity Context.
public boolean attachsbbentity ( sbbentityid sbbentityid ) { boolean attached = cachedata . attachsbbentity ( sbbentityid ) ; if ( attached ) { if ( acreferenceshandler != null ) { acreferenceshandler . sbbereferencecreated ( bool_ ) ; } } if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + sbbentityid + str_ + getactivitycontexthandle ( ) + str_ + attached ) ; } return attached ; }	attach an sbb entity to this AC.
public void detachsbbentity ( sbbentityid sbbentityid ) throws javax . slee . transactionrequiredlocalexception { boolean detached = cachedata . detachsbbentity ( sbbentityid ) ; if ( detached && acreferenceshandler != null && ! isending ( ) ) { acreferenceshandler . sbbereferenceremoved ( ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + sbbentityid + str_ + getactivitycontexthandle ( ) ) ; } } }	Detach the sbb entity.
public set < sbbentityid > getsortedsbbattachmentset ( set < sbbentityid > excludeset ) { final set < sbbentityid > sbbattachementset = cachedata . getsbbentitiesattached ( ) ; set < sbbentityid > result = new hashset < sbbentityid > ( ) ; for ( sbbentityid sbbentityid : sbbattachementset ) { if ( ! excludeset . contains ( sbbentityid ) ) { result . add ( sbbentityid ) ; } } if ( result . size ( ) > num_ ) { result = sleecontainer . getsbbentityfactory ( ) . sortbypriority ( result ) ; } return result ; }	get an ordered copy of the set of SBBs attached to this ac.
public void endactivity ( ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + getactivitycontexthandle ( ) ) ; } if ( cachedata . setending ( bool_ ) ) { fireevent ( sleecontainer . geteventcontextfactory ( ) . createactivityendeventcontext ( this , new activityendeventunreferencedcallback ( getactivitycontexthandle ( ) , factory ) ) , sleecontainer . gettransactionmanager ( ) . gettransactioncontext ( ) ) ; } }	Ends the activity context.
public void addcomponent ( deployablecomponent dc ) { if ( logger . istraceenabled ( ) ) logger . trace ( str_ + dc . getcomponentkey ( ) ) ;	Adder method for a Deployable Component.
public collection < string > getexternaldependencies ( ) {	Method for obtaining the external dependencies for this DU, if any.
public boolean hasdependenciessatisfied ( boolean showmissing ) {	Method for checking if the DU has all the dependencies needed to be deployed.
public boolean hasduplicates ( ) { arraylist < string > duplicates = new arraylist < string > ( ) ;	Method for checking if this DU contains any component that is already deployed.
public collection < managementaction > getinstallactions ( ) { arraylist < managementaction > iactions = new arraylist < managementaction > ( ) ;	Getter for the Install Actions.
public collection < managementaction > getuninstallactions ( ) { collection < managementaction > uactions = new arraylist < managementaction > ( uninstallactions ) ;	Getter for the Uninstall Actions.
private boolean hasreferringdu ( ) throws exception {	Method for checking if this DU components are referred by any others.
public static void close ( string profiletablename , string profilename ) { final objectname objectname = getobjectname ( profiletablename , profilename ) ; if ( sleecontainer . getmbeanserver ( ) . isregistered ( objectname ) ) { runnable r = new runnable ( ) { public void run ( ) { try { sleecontainer . getmbeanserver ( ) . invoke ( objectname , str_ , new object [ ] { } , new string [ ] { } ) ; } catch ( throwable e ) { logger . error ( e . getmessage ( ) , e ) ; } } } ; thread t = new thread ( r ) ; t . start ( ) ; } }	Closes and unregisters the mbean for the specified profile, if exists.
public static objectname getobjectname ( string profiletablename , string profilename ) {	Retrieves the JMX ObjectName for a profile, given its profile name andprofile table name.
private void writemode ( ) throws sleeexception , managementexception { if ( ! isprofilewriteable ( ) ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + str_ + this . profiletable . getprofiletablename ( ) ) ; }	Moves to the write mode, using specified object.
protected void beforesetcmpfield ( ) throws managementexception , invalidstateexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } if ( isprofilewriteable ( ) ) { try { sleecontainer . gettransactionmanager ( ) . resume ( transaction ) ; } catch ( throwable e ) { throw new managementexception ( e . getmessage ( ) , e ) ; } } else { throw new invalidstateexception ( ) ; } }	Logic to execute before invoking a cmp setter method on the mbean.
protected void aftersetcmpfield ( ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } try { sleecontainer . gettransactionmanager ( ) . suspend ( ) ; } catch ( throwable e ) { throw new managementexception ( e . getmessage ( ) , e ) ; } }	Logic to execute after invoking a cmp setter method on the mbean.
protected boolean beforegetcmpfield ( ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } return beforenonsetcmpfield ( ) ; }	Logic to execute before invoking a cmp getter method on the mbean.
protected void aftergetcmpfield ( boolean activatedtransaction ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + activatedtransaction + str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } afternonsetcmpfield ( activatedtransaction ) ; }	Logic to execute after invoking a cmp getter method on the mbean.
protected boolean beforemanagementmethodinvocation ( ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } jndimanagement = sleecontainer . getjndimanagement ( ) ; jndimanagement . pushjndicontext ( profiletable . getprofilespecificationcomponent ( ) ) ; return beforenonsetcmpfield ( ) ; }	Logic to execute before invoking a management method on the mbean.
protected void aftermanagementmethodinvocation ( boolean activatedtransaction ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + activatedtransaction + str_ + profilename + str_ + profiletable . getprofiletablename ( ) ) ; } afternonsetcmpfield ( activatedtransaction ) ; jndimanagement . popjndicontext ( ) ; }	Logic to execute after invoking a management method on the mbean.
private void deletepath ( file path ) { if ( path . isdirectory ( ) ) { file [ ] files = path . listfiles ( ) ; if ( files != null ) { for ( file file : files ) { deletepath ( file ) ; } } } path . delete ( ) ; }	deletes the whole path, going through directories.
protected void createdefaultconstructor ( ) throws deploymentexception { ctconstructor defaultconstructor = new ctconstructor ( null , sbbconcreteclass ) ;	Create a default constructor on the Sbb Concrete Class.
private void createdefaultusageparametergetter ( ctclass sbbconcrete ) throws deploymentexception { string methodname = str_ ; ctmethod method = ( ctmethod ) abstractmethods . get ( methodname ) ; if ( method == null ) { method = ( ctmethod ) superclassesabstractmethods . get ( methodname ) ; } if ( method != null ) { try {	Create a default usage parameter getter and setter.
private void createsbbentitygetterandsetter ( ctclass sbbconcrete ) throws deploymentexception { try { ctmethod getsbbentity = ctnewmethod . make ( str_ + sbbentity . class . getname ( ) + str_ , sbbconcrete ) ; getsbbentity . setmodifiers ( modifier . public ) ; sbbconcrete . addmethod ( getsbbentity ) ; ctmethod setsbbentity = ctnewmethod . make ( str_ + sbbentity . class . getname ( ) + str_ + str_ + str_ + str_ , sbbconcrete ) ; setsbbentity . setmodifiers ( modifier . public ) ; sbbconcrete . addmethod ( setsbbentity ) ; } catch ( exception e ) { throw new deploymentexception ( e . getmessage ( ) , e ) ; } }	Create a method to retrive the entity from the SbbObject.
protected void createfireeventmethods ( collection < evententrydescriptor > mevententries ) { if ( mevententries == null ) return ; for ( evententrydescriptor mevententry : mevententries ) { if ( mevententry . isfired ( ) ) { string methodname = str_ + mevententry . geteventname ( ) ; ctmethod method = ( ctmethod ) abstractmethods . get ( methodname ) ; if ( method == null ) { method = ( ctmethod ) superclassesabstractmethods . get ( methodname ) ; } if ( method != null ) { try {	Create the implementation of the fire event methods.
protected void creategetsbbactivitycontextinterfacemethod ( ctclass activitycontextinterface , class < ? > concreteactivitycontextinterfaceclass ) throws deploymentexception { string methodtoadd = str_ + activitycontextinterface . getname ( ) + str_ + str_ + str_ + illegalstateexception . class . getname ( ) + str_ + str_ + sbbobjectstate . class . getname ( ) + str_ + illegalstateexception . class . getname ( ) + str_ + str_ + concreteactivitycontextinterfaceclass . getname ( ) + str_ + str_ + concreteactivitycontextinterfaceclass . getname ( ) + str_ + activitycontextinterface . class . getname ( ) + str_ + str_ + str_ ; ctmethod methodtest ; try { methodtest = ctnewmethod . make ( methodtoadd , sbbconcreteclass ) ; sbbconcreteclass . addmethod ( methodtest ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + methodtoadd + str_ ) ; } } catch ( cannotcompileexception e ) { throw new deploymentexception ( e . getmessage ( ) , e ) ; } }	Create the narrow method to get the activity context interface.
protected final void add ( queryexpression expr ) throws nullpointerexception , illegalargumentexception { if ( expr == null ) throw new nullpointerexception ( str_ ) ;	Add a query expression to this composite expression.
public static synchronized void bind ( string key , object target ) throws namealreadyboundexception { if ( wrappermap . containskey ( key ) == bool_ ) throw new namealreadyboundexception ( key + str_ ) ; wrappermap . put ( key , target ) ; }	Place an object into the NonSerializableFactory namespace for subsequentaccess by getObject.
public static synchronized void rebind ( name name , object target ) throws namingexception { rebind ( name , target , bool_ ) ; }	A convience method that simplifies the process of rebinding anon-zerializable object into a JNDI context.
public boolean decorateabstractsbb ( ) throws deploymentexception { classpool pool = component . getclasspool ( ) ; string sbbabstractclassname = component . getdescriptor ( ) . getsbbabstractclass ( ) . getsbbabstractclassname ( ) ; try { sbbabstractclass = pool . get ( sbbabstractclassname ) ; } catch ( notfoundexception nfe ) { throw new deploymentexception ( str_ + sbbabstractclassname , nfe ) ; }	Decorate the abstract sbb Class.
public void invokeandreturnvoid ( sbbconcrete proxy , string methodname , object [ ] args , class < ? > [ ] argtypes ) throws exception { invokeandreturnobject ( proxy , methodname , args , argtypes ) ; }	Invokers for the simple types.
private string getrealfieldname ( string fieldname ) { string realfieldname = sbbcomponent . getdescriptor ( ) . getactivitycontextattributealiases ( ) . get ( fieldname ) ; if ( realfieldname == null ) {	Computes the real aci data field name.
public void setfieldvalue ( string fieldname , object value ) { string realfieldname = getrealfieldname ( fieldname ) ; aciimpl . getactivitycontext ( ) . setdataattribute ( realfieldname , value ) ; }	Sets an sbb aci data field value.
public object getfieldvalue ( string fieldname , class < ? > returntype ) { string realfieldname = getrealfieldname ( fieldname ) ; object value = aciimpl . getactivitycontext ( ) . getdataattribute ( realfieldname ) ; if ( value == null ) { if ( returntype . isprimitive ( ) ) { if ( returntype . equals ( integer . type ) ) { return integer . valueof ( num_ ) ; } else if ( returntype . equals ( boolean . type ) ) { return boolean . false ; } else if ( returntype . equals ( long . type ) ) { return long . valueof ( num_ ) ; } else if ( returntype . equals ( double . type ) ) { return double . valueof ( num_ ) ; } else if ( returntype . equals ( float . type ) ) { return float . valueof ( num_ ) ; } } } return value ; }	Retrieves an sbb aci data field value.
private void profileinitialize ( string profilename ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + this + str_ + profilename ) ; } if ( this . state != profileobjectstate . pooled ) { throw new sleeexception ( this . tostring ( ) ) ; } if ( profilename == null ) {	initialize state from default profile.
public void unsetprofilecontext ( ) { if ( logger . istraceenabled ( ) ) { logger . trace ( str_ + this ) ; } if ( state == profileobjectstate . pooled && profileconcreteclassinfo . isinvokeunsetprofilecontext ( ) ) { final classloader oldclassloader = sleecontainerutils . getcurrentthreadclassloader ( ) ; try { final classloader cl = profiletable . getprofilespecificationcomponent ( ) . getclassloader ( ) ; if ( system . getsecuritymanager ( ) != null ) { accesscontroller . doprivileged ( new privilegedaction < object > ( ) { public object run ( ) { thread . currentthread ( ) . setcontextclassloader ( cl ) ; return null ; } } ) ; } else { thread . currentthread ( ) . setcontextclassloader ( cl ) ; } if ( isslee11 ) { try { profileconcrete . unsetprofilecontext ( ) ; } catch ( runtimeexception e ) { runtimeexceptiononprofileinvocation ( e ) ; } } profilecontext . setprofileobject ( null ) ; state = profileobjectstate . does_not_exist ; } finally { if ( system . getsecuritymanager ( ) != null ) { accesscontroller . doprivileged ( new privilegedaction < object > ( ) { public object run ( ) { thread . currentthread ( ) . setcontextclassloader ( oldclassloader ) ; return null ; } } ) ; } else { thread . currentthread ( ) . setcontextclassloader ( oldclassloader ) ; } } } }	Invoked when pool removes object.
public profilelocalobject getprofilelocalobject ( ) { final class < ? > profilelocalobjectconcreteclass = profiletable . getprofilespecificationcomponent ( ) . getprofilelocalobjectconcreteclass ( ) ; profilelocalobject profilelocalobject = null ; if ( profilelocalobjectconcreteclass == null ) { profilelocalobject = new profilelocalobjectimpl ( this ) ; } else { try { profilelocalobject = ( profilelocalobject ) profilelocalobjectconcreteclass . getconstructor ( profileobjectimpl . class ) . newinstance ( this ) ; } catch ( throwable e ) { throw new sleeexception ( e . getmessage ( ) , e ) ; } } return profilelocalobject ; }	Retrieves the local representation for this profile object.
public void fireaddorupdatedeventifneeded ( ) { if ( state == profileobjectstate . ready ) { if ( profileentity . isdirty ( ) ) {	Fires a profile added or updated event if the profile object state is ready and the persistent state is dirty.
public abstractprofilecmpslee10wrapper getprofilecmpslee10wrapper ( ) { if ( profilecmpslee10wrapper == null ) { try { profilecmpslee10wrapper = ( abstractprofilecmpslee10wrapper ) profiletable . getprofilespecificationcomponent ( ) . getprofilecmpslee10wrapperclass ( ) . getconstructor ( profileobjectimpl . class ) . newinstance ( this ) ; } catch ( throwable e ) { throw new sleeexception ( e . getmessage ( ) , e ) ; } } return profilecmpslee10wrapper ; }	Retrieves the profile cmp slee 1.0 wrapper for this profile object.
public static ctclass createclass ( string classname , string [ ] interfaces ) throws exception { if ( classname == null ) { throw new nullpointerexception ( str_ ) ; } ctclass clazz = classpool . makeclass ( classname ) ; if ( interfaces != null && interfaces . length > num_ ) { clazz . setinterfaces ( classpool . get ( interfaces ) ) ; } return clazz ; }	Creates a class with the desired name and linked to the mentioned interfaces.
public static void createinheritancelink ( ctclass concreteclass , string superclassname ) { if ( superclassname != null && superclassname . length ( ) >= num_ ) { try { concreteclass . setsuperclass ( classpool . get ( superclassname ) ) ; } catch ( cannotcompileexception e ) { e . printstacktrace ( ) ; } catch ( notfoundexception e ) { e . printstacktrace ( ) ; } } }	Create the inheritance link with the absract class provided by the developer.
private static void addmembervaluestoannotation ( annotation annotation , constpool cp , linkedhashmap < string , object > membervalues ) {	Private method to add member values to annotation.
protected activitycontextinterface getaci ( object activity ) throws nullpointerexception , unrecognizedactivityexception , factoryexception { if ( activity == null ) { throw new nullpointerexception ( str_ ) ; } activityhandle handle = null ; for ( resourceadaptorentity raentity : sleecontainer . getresourcemanagement ( ) . getresourceadaptorentitiespertype ( resourceadaptortypeid ) ) { handle = raentity . getresourceadaptorobject ( ) . getactivityhandle ( activity ) ; if ( handle != null ) { activitycontexthandle ach = new resourceadaptoractivitycontexthandleimpl ( raentity , handle ) ; activitycontext ac = sleecontainer . getactivitycontextfactory ( ) . getactivitycontext ( ach ) ; if ( ac != null ) { return ac . getactivitycontextinterface ( ) ; } break ; } } throw new unrecognizedactivityexception ( activity . tostring ( ) ) ; }	This method returns the aci for the specified activity, if exists, itshould be invoked by each impl of methods of an ra type aci factory.
public classpool getclasspool ( ) { if ( classpool == null ) { if ( classloader == null ) { throw new illegalstateexception ( str_ ) ; } classpool = new classpool ( ) ;	Retrieves the component javassist class pool.
public void setdeployableunit ( deployableunit deployableunit ) throws alreadydeployedexception { if ( this . deployableunit != null ) { throw new illegalstateexception ( str_ + this . deployableunit ) ; } this . deployableunit = deployableunit ; if ( ! addtodeployableunit ( ) ) { throw new alreadydeployedexception ( str_ + getcomponentid ( ) ) ; } }	Specifies the the Deployable Unit this component belongs. This methodalso sets the reverse relation, adding the component to the deployableunit.
public void undeployed ( ) { classloader = null ; if ( classloaderdomain != null ) { classloaderdomain . clear ( ) ; classloaderdomain = null ; } if ( classpool != null ) { classpool . clean ( ) ; classpool = null ; } if ( permissions != null ) { permissions . clear ( ) ; permissions = null ; } }	Indicates that the component was undeployed and thus should clean up any resources.
void execute ( final activityhandle handle , final int activityflags , boolean suspendactivity ) throws sleeexception { final sleetransaction tx = super . suspendtransaction ( ) ; activitycontexthandle ach = null ; try { ach = sleeendpoint . _startactivity ( handle , activityflags , suspendactivity ? tx : null ) ; } finally { if ( tx != null ) { super . resumetransaction ( tx ) ;	Executes a non transacted start activity operation.
public static class checkinterfaces ( class classorinterfacewithinterfaces , string interfacesearched ) { class returnvalue = null ; if ( classorinterfacewithinterfaces . getname ( ) . compareto ( interfacesearched ) == num_ ) { return classorinterfacewithinterfaces ; }	Searches for provided interface in passed Class object - it can be classor interface.
public static map < string , method > getallinterfacesmethods ( class xinterfaceclass , set < string > ignore ) { hashmap < string , method > abstractmethods = new hashmap < string , method > ( ) ; method [ ] methods = null ; class [ ] superinterfaces ; superinterfaces = xinterfaceclass . getinterfaces ( ) ; for ( class superinterface : superinterfaces ) { if ( ! ignore . contains ( superinterface . getname ( ) ) ) abstractmethods . putall ( getallinterfacesmethods ( superinterface , ignore ) ) ; } methods = xinterfaceclass . getdeclaredmethods ( ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { abstractmethods . put ( getmethodkey ( methods [ i ] ) , methods [ i ] ) ; } return abstractmethods ; }	Returns methods of this interface and all super interfaces.
public static void checktracername ( string tracername , notificationsource notificationsource ) throws illegalargumentexception { if ( tracername . compareto ( str_ ) == num_ ) {	This checks if tracer name is ok. It must not be null;.
public static collection < profilelocalobject > handle ( profiletableimpl profiletable , string queryname , object [ ] arguments ) throws nullpointerexception , transactionrequiredlocalexception , sleeexception , unrecognizedquerynameexception , attributetypemismatchexception , invalidargumentexception { return profiletable . getprofilesbystaticquery ( queryname , arguments ) ; }	Method that does lookup and creates PLOs.
private file createtempdudeploymentdir ( file deploymentroot , deployableunitid deployableunitid ) { try {	Creates the directory that will be used for unpacking the child jars fora given DU.
@ suppresswarnings ( str_ ) private entitymanager getentitymanager ( ) { if ( txdatakey == null ) { txdatakey = new stringbuilder ( str_ ) . append ( component . getprofilespecificationid ( ) ) . tostring ( ) ; } final transactioncontext txcontext = sleetransactionmanager . gettransactioncontext ( ) ;	Retrieves the entity manager for the current tx and the framework profilespec.
public void start ( ) throws invalidstateexception , managementexception { try {	Start the SLEE container.
public static classloader switchsafelyclassloader ( final classloader cl , final profileobject po ) { classloader _cl = null ; if ( system . getsecuritymanager ( ) != null ) { _cl = ( classloader ) accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { return _switchsafelyclassloader ( cl , po ) ; } } ) ; } else { _cl = _switchsafelyclassloader ( cl , po ) ; } return _cl ; }	This method depending if SecurityManger is present switches class loader using priviledged action,this is requried as some action may be initiated by unsecure domains.
public static object makesafeproxycall ( final object proxy , final string methodtocallname , final class [ ] signature , final object [ ] values ) throws privilegedactionexception {	Its used to embed calls in AccessController in case of insturmented code, cause javassist does not support anonmous inner class.
protected void checktransaction ( ) throws illegalstateexception { try { if ( ! sleecontainer . gettransactionmanager ( ) . gettransaction ( ) . equals ( this . transaction ) ) { throw new illegalstateexception ( ) ; } } catch ( systemexception e ) { throw new illegalstateexception ( ) ; } }	Verifies that the current transaction is still the one used to create the object.
private static string tottl ( string lastaccess , long timeout ) { long ttl = timeout - ( ( system . currenttimemillis ( ) - long . parselong ( lastaccess ) ) / num_ ) ; return ttl . tostring ( ) ; }	Calculates the Activity TTL.
boolean isprofileclassvisible ( ) { try { thread . currentthread ( ) . getcontextclassloader ( ) . loadclass ( profileafteraction . getclass ( ) . getname ( ) ) ; return bool_ ; } catch ( throwable e ) { return bool_ ; } }	Verifies if the specified class can be loaded by current thread class loader.
profileobjectimpl getprofileobjectvalidincurrenttransaction ( profileentity profileentity ) throws transactionrequiredlocalexception {	Retrieves a local object valid for thus current transaction.
public list < string > getloggernames ( string regex ) throws managementconsoleexception { try { return ( list < string > ) this . mbeanserver . invoke ( logmgmtmbeanname , str_ , new object [ ] { regex } , new string [ ] { str_ } ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new managementconsoleexception ( sleemanagementmbeanutils . domessage ( e ) ) ; } }	SImilar to LoggingMXBean, return list of available loggers.
public void resetloggerlevels ( ) throws managementconsoleexception { try { this . mbeanserver . invoke ( logmgmtmbeanname , str_ , null , null ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new managementconsoleexception ( sleemanagementmbeanutils . domessage ( e ) ) ; } }	Resets all loggers level to default one.
public void clearloggers ( string name ) throws managementconsoleexception { try { this . mbeanserver . invoke ( logmgmtmbeanname , str_ , new object [ ] { name } , new string [ ] { str_ } ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new managementconsoleexception ( sleemanagementmbeanutils . domessage ( e ) ) ; } }	Removes all loggers under certain branch.
public boolean addlogger ( string name , level level ) throws nullpointerexception , managementconsoleexception { try { return ( ( boolean ) this . mbeanserver . invoke ( logmgmtmbeanname , str_ , new object [ ] { name , level } , new string [ ] { str_ , str_ } ) ) . booleanvalue ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new managementconsoleexception ( sleemanagementmbeanutils . domessage ( e ) ) ; } }	Tries to add logger if it doesnt exist.
public boolean removehandler ( string loggername , string handlername ) throws managementconsoleexception { try { return ( ( boolean ) this . mbeanserver . invoke ( logmgmtmbeanname , str_ , new object [ ] { loggername , handlername } , new string [ ] { str_ , str_ } ) ) . booleanvalue ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new managementconsoleexception ( sleemanagementmbeanutils . domessage ( e ) ) ; } }	Tries to remove handler from logger.
private string tracernametolog4jloggername ( string tracername , notificationsource notificationsource ) { final stringbuilder sb = new stringbuilder ( str_ ) . append ( notificationsource . tostring ( ) ) ; if ( ! tracername . equals ( root_tracer_name ) ) { sb . append ( str_ ) . append ( tracername ) ; } return sb . tostring ( ) ; }	Generates the log4j logger name for the tracer with specified named and notification source.
void synclevelwithlog4j ( ) {	syncs the slee tracer level with the one that related logger has in log4j.
private void assignlog4jlevel ( level log4jlevel ) { if ( log4jlevel == null ) { return ; } if ( log4jlevel == level . debug ) { level = tracelevel . fine ; } else if ( log4jlevel == level . info ) { level = tracelevel . info ; } else if ( log4jlevel == level . warn ) { level = tracelevel . warning ; } else if ( log4jlevel == level . error ) { level = tracelevel . severe ; } else if ( log4jlevel == level . trace ) { level = tracelevel . finest ; } else if ( log4jlevel == level . off ) { level = tracelevel . off ; } }	assigns the equiv log4j level to the tracer.
void resetcacheflags ( boolean resetchilds ) { if ( istraceable ( tracelevel . finest ) ) { finestenabled = bool_ ; finerenabled = bool_ ; fineenabled = bool_ ; configenabled = bool_ ; infoenabled = bool_ ; warningenabled = bool_ ; severeenabled = bool_ ; } else { finestenabled = bool_ ; if ( istraceable ( tracelevel . finer ) ) { finerenabled = bool_ ; fineenabled = bool_ ; configenabled = bool_ ; infoenabled = bool_ ; warningenabled = bool_ ; severeenabled = bool_ ; } else { finerenabled = bool_ ; if ( istraceable ( tracelevel . fine ) ) { fineenabled = bool_ ; configenabled = bool_ ; infoenabled = bool_ ; warningenabled = bool_ ; severeenabled = bool_ ; } else { fineenabled = bool_ ; if ( istraceable ( tracelevel . config ) ) { configenabled = bool_ ; infoenabled = bool_ ; warningenabled = bool_ ; severeenabled = bool_ ; } else { if ( istraceable ( tracelevel . info ) ) { infoenabled = bool_ ; warningenabled = bool_ ; severeenabled = bool_ ; } else { infoenabled = bool_ ; if ( istraceable ( tracelevel . warning ) ) { warningenabled = bool_ ; severeenabled = bool_ ; } else { warningenabled = bool_ ; if ( istraceable ( tracelevel . severe ) ) { severeenabled = bool_ ; } else { severeenabled = bool_ ; } } } } } } } if ( resetchilds ) {	manages the flags which cache if levels are enabled.
void sendnotification ( javax . slee . facilities . tracelevel level , string message , throwable t ) { if ( ! istraceable ( level ) ) { return ; } tracembean . sendnotification ( new tracenotification ( notificationsource . getnotificationsource ( ) . gettracenotificationtype ( ) , tracembean , notificationsource . getnotificationsource ( ) , gettracername ( ) , level , message , t , notificationsource . getnextsequence ( ) , system . currenttimemillis ( ) ) ) ; }	THis is internaly called, by 1.1 tracers.
public static void checktracername ( string tracername , notificationsource notificationsource ) throws nullpointerexception , invalidargumentexception { if ( tracername . equals ( str_ ) ) {	This checks if the specified tracer name is ok.
public static void writeobject ( objectoutputstream out , object vendordata ) throws ioexception {	Write the current object and vendor-specific data to the output stream.
public static object readobject ( objectinputstream in , boolean vendordatadeserializationenabled ) throws ioexception , classnotfoundexception {	Read the current object in the input stream from the stream, optionallydeserializing any vendor-specific data in the stream.
public void adddirectdependency ( urlclassloaderdomainimpl domain ) { if ( logger . istraceenabled ( ) ) logger . trace ( tostring ( ) + str_ + domain + str_ ) ; directdependencies . add ( domain ) ; }	Adds a direct dependency to this domain.
public list < urlclassloaderdomainimpl > getalldependencies ( ) { list < urlclassloaderdomainimpl > result = new arraylist < urlclassloaderdomainimpl > ( ) ; this . getalldependencies ( result ) ; return result ; }	Retrieves a flat list containing all dependencies for the domain, i.e., all direct dependencies and their own dependencies.
protected class < ? > findclasslocally ( string name ) throws classnotfoundexception { if ( logger . istraceenabled ( ) ) { logger . trace ( tostring ( ) + str_ + name ) ; } final boolean acquiredlock = acquiregloballock ( ) ; try { return findclasslocallylocked ( name ) ; } finally { if ( acquiredlock ) { releasegloballock ( ) ; } } }	Finds a class locally, i.e., in the URLs managed by the extendedURLClassLoader.
protected url findresourcelocally ( string name ) { if ( logger . istraceenabled ( ) ) logger . trace ( tostring ( ) + str_ + name ) ; return super . findresource ( name ) ; }	Finds a resource locally, i.e., in the URLs managed by the extendedURLClassLoader.
protected enumeration < url > findresourceslocally ( string name ) throws ioexception { if ( logger . istraceenabled ( ) ) logger . trace ( tostring ( ) + str_ + name ) ; return super . findresources ( name ) ; }	Finds resources locally, i.e., in the URLs managed by the extendedURLClassLoader.
private abstractprofilembeanimpl createandregisterprofilembean ( string profilename , profiletableimpl profiletable ) throws managementexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + profiletable + str_ + profilename + str_ ) ; } try { profilespecificationcomponent component = profiletable . getprofilespecificationcomponent ( ) ; constructor < ? > constructor = component . getprofilembeanconcreteimplclass ( ) . getconstructor ( class . class , string . class , profiletableimpl . class ) ; final abstractprofilembeanimpl profilembean = ( abstractprofilembeanimpl ) constructor . newinstance ( component . getprofilembeanconcreteinterfaceclass ( ) , profilename , profiletable ) ; profilembean . register ( ) ;	Creates and registers a profile mbean for the specified object.
void resumetransaction ( sleetransaction transaction ) throws sleeexception { if ( transaction != null ) { try { txmanager . resume ( transaction ) ; } catch ( throwable e ) { throw new sleeexception ( e . getmessage ( ) , e ) ; } } }	Resumes the specified tx.
public set < sbbid > getsbbids ( componentrepository componentrepository ) { set < sbbid > result = new hashset < sbbid > ( ) ; buildsbbtree ( descriptor . getrootsbbid ( ) , result , componentrepository ) ; return result ; }	Retrieves the set of sbbs used by this service.
public set < string > getresourceadaptorentitylinks ( componentrepository componentrepository ) { set < string > result = new hashset < string > ( ) ; for ( sbbid sbbid : getsbbids ( componentrepository ) ) { sbbcomponent sbbcomponent = componentrepository . getcomponentbyid ( sbbid ) ; for ( resourceadaptortypebindingdescriptor ratypebinding : sbbcomponent . getdescriptor ( ) . getresourceadaptortypebindings ( ) ) { for ( resourceadaptorentitybindingdescriptor raentitybinding : ratypebinding . getresourceadaptorentitybinding ( ) ) { result . add ( raentitybinding . getresourceadaptorentitylink ( ) ) ; } } } return result ; }	Retrieves the set of ra entity links referenced by the sbbs related with the service.
public void initslee ( ) throws invalidstateexception { if ( sleestate != null ) { throw new invalidstateexception ( str_ + sleestate + str_ ) ; }	Initiates the SLEE container.
public void shutdownslee ( ) throws invalidstateexception { if ( sleestate != sleestate . stopped ) { throw new invalidstateexception ( str_ + sleestate + str_ ) ; }	Shutdown of the SLEE container.
private void validatestatetransition ( sleestate oldstate , sleestate newstate ) throws invalidstateexception { if ( oldstate == sleestate . stopped ) { if ( newstate == sleestate . starting ) { return ; } } else if ( oldstate == sleestate . starting ) { if ( newstate == sleestate . running || newstate == sleestate . stopping ) { return ; } } else if ( oldstate == sleestate . running ) { if ( newstate == sleestate . stopping ) { return ; } } else if ( oldstate == sleestate . stopping ) { if ( newstate == sleestate . stopped ) { return ; } } throw new invalidstateexception ( str_ + oldstate + str_ + newstate ) ; }	Ensures the standard SLEE lifecycle.
private void generatenamedusageparametergetter ( ctclass profileconcreteclass ) { string methodname = str_ ; for ( ctmethod ctmethod : profileconcreteclass . getmethods ( ) ) { if ( ctmethod . getname ( ) . equals ( methodname ) ) { try {	Create a named usage parameter getter.
public updatequery set ( string fieldname , object value ) { string updatedfieldname = str_ + fieldname ; values . append ( fieldname ) . append ( str_ ) . append ( updatedfieldname ) . append ( str_ ) ; query . setargument ( updatedfieldname , value ) ; return this ; }	Set column to update.
public polyjdbc build ( ) { transactionmanager manager ; if ( datasource != null ) { manager = new datasourcetransactionmanager ( datasource ) ; } else { manager = new externaltransactionmanager ( connectionprovider ) ; } return new defaultpolyjdbc ( dialect , schemaname , new columntypemapper ( custommappings ) , manager ) ; }	Return new PolyJDBC instance.
public insertquery value ( string fieldname , object value ) { valuenames . append ( fieldname ) . append ( str_ ) ; values . append ( str_ ) . append ( fieldname ) . append ( str_ ) ; setargument ( fieldname , value ) ; return this ; }	Insert value into column of given name.
public < t > t run ( transactionwrapper < t > operation ) { queryrunner runner = null ; try { runner = queryrunnerfactory . create ( ) ; t result = operation . perform ( runner ) ; runner . commit ( ) ; return result ; } catch ( throwable throwable ) { thecloser . rollback ( runner ) ; throw new transactioninterruptedexception ( throwable ) ; } finally { thecloser . close ( runner ) ; } }	Run specified operations in safe transaction block.
@ jsoncreator public static regionrequest fromstring ( string str ) throws resolvingexception { if ( str . equals ( str_ ) ) { return new regionrequest ( ) ; } if ( str . equals ( str_ ) ) { return new regionrequest ( bool_ ) ; } matcher matcher = parse_pat . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolvingexception ( str_ + str ) ; } if ( matcher . group ( num_ ) == null ) { return new regionrequest ( integer . valueof ( matcher . group ( num_ ) ) , integer . valueof ( matcher . group ( num_ ) ) , integer . valueof ( matcher . group ( num_ ) ) , integer . valueof ( matcher . group ( num_ ) ) ) ; } else { return new regionrequest ( new bigdecimal ( matcher . group ( num_ ) ) , new bigdecimal ( matcher . group ( num_ ) ) , new bigdecimal ( matcher . group ( num_ ) ) , new bigdecimal ( matcher . group ( num_ ) ) ) ; } }	Parse an IIIF Image API compliant region request string.
public rectangle2d getregion ( ) { if ( isrelative ( ) ) { return new rectangle2d . double ( relativebox . x . doublevalue ( ) , relativebox . y . doublevalue ( ) , relativebox . w . doublevalue ( ) , relativebox . h . doublevalue ( ) ) ; } else { return absolutebox ; } }	Returns the requested region.
private string getontype ( deserializationcontext ctxt ) {	Get type for "on" values that are plain URIs by deducing the type from their parent.
public void setviewinghints ( list < viewinghint > viewinghints ) throws illegalargumentexception { for ( viewinghint hint : viewinghints ) { boolean supportshint = ( hint . gettype ( ) == viewinghint . type . other || this . getsupportedviewinghinttypes ( ) . contains ( hint . gettype ( ) ) ) ; if ( ! supportshint ) { throw new illegalargumentexception ( string . format ( str_ , this . gettype ( ) , hint . tostring ( ) ) ) ; } } this . viewinghints = viewinghints ; }	Set the viewing hints for this resource.
public resource addviewinghint ( viewinghint first , viewinghint ... rest ) throws illegalargumentexception { list < viewinghint > hints = this . viewinghints ; if ( hints == null ) { hints = new arraylist < > ( ) ; } hints . addall ( lists . aslist ( first , rest ) ) ; this . setviewinghints ( hints ) ; return this ; }	Add one or more viewing hints for this resource.
public void setrenderings ( list < othercontent > renderings ) throws illegalargumentexception { renderings . foreach ( this :: verifyrendering ) ; this . renderings = renderings ; }	Sets the renderings. All renderings must have both a profile and a format.
public resource addrendering ( othercontent first , othercontent ... rest ) { if ( renderings == null ) { this . renderings = new arraylist < > ( ) ; } list < othercontent > renderingstoadd = lists . aslist ( first , rest ) ; renderingstoadd . foreach ( this :: verifyrendering ) ; this . renderings . addall ( renderingstoadd ) ; return this ; }	Add one or more renderings.
public static imageapiprofile merge ( list < profile > profiles ) { return profiles . stream ( ) . filter ( imageapiprofile . class :: isinstance ) . map ( imageapiprofile . class :: cast ) . reduce ( new imageapiprofile ( ) , imageapiprofile :: merge ) ; }	Merge multiple profiles into one.
@ jsoncreator public static rotationrequest fromstring ( string str ) throws resolvingexception { matcher matcher = pattern . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolvingexception ( str_ + str ) ; } return new rotationrequest ( new bigdecimal ( matcher . group ( num_ ) ) , ! ( matcher . group ( num_ ) == null ) ) ; }	Parse a rotation request from an IIIF Image API compliant rotation string.
@ jsoncreator public static sizerequest fromstring ( string str ) throws resolvingexception { if ( str . equals ( str_ ) ) { return new sizerequest ( ) ; } if ( str . equals ( str_ ) ) { return new sizerequest ( bool_ ) ; } matcher matcher = parse_pat . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolvingexception ( str_ + str ) ; } if ( matcher . group ( num_ ) != null ) { if ( matcher . group ( num_ ) . equals ( str_ ) ) { return new sizerequest ( integer . valueof ( matcher . group ( num_ ) ) , integer . valueof ( matcher . group ( num_ ) ) , bool_ ) ; } else if ( matcher . group ( num_ ) . equals ( str_ ) ) { return new sizerequest ( new bigdecimal ( matcher . group ( num_ ) ) ) ; } } integer width = null ; integer height = null ; if ( matcher . group ( num_ ) != null ) { width = integer . parseint ( matcher . group ( num_ ) ) ; } if ( matcher . group ( num_ ) != null ) { height = integer . parseint ( matcher . group ( num_ ) ) ; } return new sizerequest ( width , height ) ; }	Parse an IIIF Image API compliant size request string.
protected void initializeadbconnection ( ) {	Initializes the AndroidDebugBridge and registers the DefaultHardwareDeviceManager with theAndroidDebugBridge device change listener.
public string getdump ( ) { pushautomator2device ( ) ; runtest ( ) ; string path = pulldump2pc ( ) ; string xml = str_ ; try { fileinputstream fileinputstream = new fileinputstream ( path ) ; @ suppresswarnings ( str_ ) bufferedreader in = new bufferedreader ( new inputstreamreader ( fileinputstream ) ) ; stringbuffer buffer = new stringbuffer ( ) ; string line = str_ ; while ( ( line = in . readline ( ) ) != null ) { buffer . append ( line ) ; } xml = buffer . tostring ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return xml ; }	get current android page's dump file.
public boolean handlepopbox ( string devicebrand ) { pushhandlegps2device ( ) ; commandline execommand = null ; if ( devicebrand . contains ( str_ ) ) { execommand = adbcommand ( str_ , str_ , str_ , str_ , str_ , str_ ) ; } else if ( devicebrand . contains ( str_ ) ) { execommand = adbcommand ( str_ , str_ , str_ , str_ , str_ , str_ ) ; } string output = executecommandquietly ( execommand ) ; log . debug ( str_ , output ) ; try {	try to click GPS Popup window.
private boolean pushhandlegps2device ( ) { inputstream io = abstractdevice . class . getresourceasstream ( str_ ) ; file dest = new file ( fileutils . gettempdirectory ( ) , str_ ) ; try { fileutils . copyinputstreamtofile ( io , dest ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } commandline pushcommand = adbcommand ( str_ , dest . getabsolutepath ( ) , str_ ) ; string outputpush = executecommandquietly ( pushcommand ) ; log . debug ( str_ , outputpush ) ; try {	Push handlePopBox.jar to android tmp folder.
public void cleantemp ( ) { commandline dumpcommand = adbcommand ( str_ , str_ , str_ , str_ ) ; executecommandquietly ( dumpcommand ) ; try {	clean file dump.xml, qian.xml, uidump.xml in tmp folder.
public string pulldump2pc ( ) { string serial = device . getserialnumber ( ) ; file dest = new file ( fileutils . gettempdirectory ( ) , serial + str_ ) ; string path = dest . getpath ( ) ; log . debug ( str_ , path ) ; commandline commandpull = adbcommand ( str_ , str_ , path ) ; string out = executecommandquietly ( commandpull ) ; log . debug ( str_ , out ) ; return path ; }	pull dump file from android device to pc.
public string getcrashlog ( ) { string crashlogfilename = null ; file crashlogfile = new file ( getexternalstoragepath ( ) , crashlogfilename ) ;	Get crash log from AUT.
public texteditor detabify ( final int tabwidth ) { replaceall ( pattern . compile ( str_ ) , new replacement ( ) { public string replacement ( matcher m ) { string linesofar = m . group ( num_ ) ; int width = linesofar . length ( ) ; stringbuilder replacement = new stringbuilder ( linesofar ) ; do { replacement . append ( str_ ) ; ++ width ; } while ( width % tabwidth != num_ ) ; return replacement . tostring ( ) ; } } ) ; return this ; }	Convert tabs to spaces.
public texteditor indent ( int spaces ) { stringbuilder sb = new stringbuilder ( spaces ) ; for ( int i = num_ ; i < spaces ; i ++ ) { sb . append ( str_ ) ; } return replaceall ( str_ , sb . tostring ( ) ) ; }	Introduce a number of spaces at the start of each line.
public collection < htmltoken > tokenizehtml ( ) { list < htmltoken > tokens = new arraylist < htmltoken > ( ) ; string nestedtags = nestedtagsregex ( num_ ) ; pattern p = pattern . compile ( str_ + str_ + str_ + str_ + str_ + nestedtags + str_ , pattern . case_insensitive ) ; matcher m = p . matcher ( text ) ; int lastpos = num_ ; while ( m . find ( ) ) { if ( lastpos < m . start ( ) ) { tokens . add ( htmltoken . text ( text . substring ( lastpos , m . start ( ) ) ) ) ; } tokens . add ( htmltoken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; lastpos = m . end ( ) ; } if ( lastpos < text . length ( ) ) { tokens . add ( htmltoken . text ( text . substring ( lastpos , text . length ( ) ) ) ) ; } return tokens ; }	Parse HTML tags, returning a Collection of HTMLToken objects.
public string markdown ( string txt ) { if ( txt == null ) { txt = str_ ; } texteditor text = new texteditor ( txt ) ;	Perform the conversion from Markdown to HTML.
private texteditor escapespecialcharswithintagattributes ( texteditor text ) { collection < htmltoken > tokens = text . tokenizehtml ( ) ; texteditor newtext = new texteditor ( str_ ) ; for ( htmltoken token : tokens ) { string value = token . gettext ( ) ; if ( token . istag ( ) ) { value = value . replaceall ( str_ , char_protector . encode ( str_ ) ) ; value = value . replaceall ( str_ , char_protector . encode ( str_ ) ) ; value = value . replaceall ( str_ , char_protector . encode ( str_ ) ) ; value = value . replaceall ( str_ , char_protector . encode ( str_ ) ) ; } newtext . append ( value ) ; } return newtext ; }	escape special charactersWithin tags -- meaning between -- encode [\ ` * _] so theydon't conflict with their use in Markdown for code, italics and strong.We're replacing each such character with its corresponding random stringvalue; this is likely overkill, but it should prevent us from collidingwith the escape values by accident.
final void addexception ( sqlexception exception ) { if ( ! ( exception instanceof sqltimeoutexception ) && ! ( exception instanceof sqltransactionrollbackexception ) ) { getorinit ( ) . offer ( exception ) ;	This method will be called when an operation invoked on a JDBC object throws an SQLException.It will accumulate a list of all non-transient SQL exceptions.
@ override public void close ( ) { if ( closed . getandset ( bool_ ) ) { return ; } for ( map . entry < statementmethod , statementholder > entry : statementcache . entryset ( ) ) { statementholder value = entry . getvalue ( ) ; statementcache . remove ( entry . getkey ( ) , value ) ; quietclose ( value . rawstatement ( ) ) ; } }	Closes this ClhmStatementCache and removes all entries from it.
private string findparentfqcn ( typeelement typeelement , set < string > parents ) { typemirror type ; while ( bool_ ) { type = typeelement . getsuperclass ( ) ; if ( type . getkind ( ) == typekind . none ) { return null ; } typeelement = ( typeelement ) ( ( declaredtype ) type ) . aselement ( ) ; if ( parents . contains ( typeelement . tostring ( ) ) ) { string packagename = getpackagename ( typeelement ) ; return packagename + str_ + getclassname ( typeelement , packagename ) ; } } }	Finds the parent barbershop type in the supplied set, if any.
void writetofiler ( filer filer ) throws ioexception { classname targetclassname = classname . get ( classpackage , targetclass ) ; typespec . builder barbershop = typespec . classbuilder ( classname ) . addmodifiers ( modifier . public ) . addtypevariable ( typevariablename . get ( str_ , targetclassname ) ) . addmethod ( generatestylemethod ( ) ) . addmethod ( generatecheckparentmethod ( ) ) ; if ( parentbarbershop == null ) { barbershop . addsuperinterface ( parameterizedtypename . get ( classname . get ( barber . ibarbershop . class ) , typevariablename . get ( str_ ) ) ) ; barbershop . addfield ( fieldspec . builder ( weakhashset . class , str_ , modifier . protected ) . initializer ( str_ , weakhashset . class ) . build ( ) ) ; } else { barbershop . superclass ( parameterizedtypename . get ( classname . bestguess ( parentbarbershop ) , typevariablename . get ( str_ ) ) ) ; } javafile javafile = javafile . builder ( classpackage , barbershop . build ( ) ) . build ( ) ; javafile . writeto ( filer ) ; }	Generates the class code and writes to a new source file.
public void writebitvector01divider ( bitvector01divider divider ) throws ioexception { dos . writeboolean ( divider . isfirst ( ) ) ; dos . writeboolean ( divider . iszerocounting ( ) ) ; }	Write BitVector01Divider to OutputStream.
public static void appendbitstrings ( bitvector bv , string [ ] bs ) { for ( string s : bs ) { if ( s . length ( ) != num_ ) throw new runtimeexception ( str_ + s . length ( ) ) ; for ( char c : s . tochararray ( ) ) { if ( c == str_ ) bv . append0 ( ) ; else if ( c == str_ ) bv . append1 ( ) ; else throw new runtimeexception ( str_ + c + str_ ) ; } } }	Append bits from bit string.
public void readfrom ( inputstream is ) throws ioexception { datainputstream dis = new datainputstream ( is ) ; first = dis . readboolean ( ) ; zerocounting = dis . readboolean ( ) ; }	Read data from InputStream.
protected static < type > list < type > getlist ( string path , string key , class < type > expectedclass , list < string > filters ) { stringbuilder temppath = new stringbuilder ( path ) ; temppath . append ( str_ ) ; for ( string filter : filters ) { temppath . append ( filter ) . append ( str_ ) ; } return getlist ( temppath . substring ( num_ , temppath . length ( ) - num_ ) , key , expectedclass ) ; }	Get the list of objects with a filter if there is anything that matches the filters.
private static synchronized void setklovreport ( ) { if ( extentreports == null ) {	When running cucumber tests in parallel Klov reporter should be attached only once, in order to avoid duplicate builds on klov server.
public static void addscreencapturefrompath ( string imagepath , string title ) throws ioexception { getcurrentstep ( ) . addscreencapturefrompath ( imagepath , title ) ; }	Adds the screenshot from the given path with the given title to the current step.
public static void setsysteminfo ( string key , string value ) { if ( systeminfokeymap . isempty ( ) || ! systeminfokeymap . containskey ( key ) ) { systeminfokeymap . put ( key , bool_ ) ; } if ( systeminfokeymap . get ( key ) ) { return ; } getextentreport ( ) . setsysteminfo ( key , value ) ; systeminfokeymap . put ( key , bool_ ) ; }	Sets the system information with the given key value pair.
public static selector select ( final string propname ) { return new selector ( propname , propname ) { @ override public void handlerow ( int index , map < string , object > row , object item , map < string , fieldaccess > fields ) { getpropertyvalueandputintorow ( row , item , fields ) ; } @ override public void handlestart ( collection < ? > results ) { } @ override public void handlecomplete ( list < map < string , object > > rows ) { } } ; }	Allows you to select a property or property path.
public static selector selectas ( final string propname , final string alias , final function transform ) { return new selector ( propname , alias ) { @ override public void handlerow ( int index , map < string , object > row , object item , map < string , fieldaccess > fields ) { if ( ! path && fields != null ) { row . put ( this . name , transform . apply ( fields . get ( this . name ) . getvalue ( item ) ) ) ; } else { row . put ( alias , transform . apply ( beanutils . atindex ( item , propname ) ) ) ; } } @ override public void handlestart ( collection < ? > results ) { } @ override public void handlecomplete ( list < map < string , object > > rows ) { } } ; }	Selects but allows having a different alias for the output.
public static list < annotationdata > extractvalidationannotationdata ( annotation [ ] annotations , set < string > allowedpackages ) { list < annotationdata > annotationslist = new arraylist < > ( ) ; for ( annotation annotation : annotations ) { annotationdata annotationdata = new annotationdata ( annotation , allowedpackages ) ; if ( annotationdata . isallowed ( ) ) { annotationslist . add ( annotationdata ) ; } } return annotationslist ; }	Create an annotation data list.
private static annotation [ ] extractallannotationsforproperty ( class < ? > clazz , string propertyname , boolean useread ) { try { annotation [ ] annotations = findpropertyannotations ( clazz , propertyname , useread ) ; if ( annotations . length == num_ ) { annotations = findpropertyannotations ( clazz . getsuperclass ( ) , propertyname , useread ) ; } return annotations ; } catch ( exception ex ) { return exceptions . handle ( annotation [ ] . class , sputs ( str_ , propertyname , str_ , clazz , str_ , useread ) , ex ) ; } }	Extract all annotation for a given property.Searches current class and if none found searchessuper class for annotation.
private static annotation [ ] findpropertyannotations ( class < ? > clazz , string propertyname , boolean useread ) throws introspectionexception { propertydescriptor propertydescriptor = getpropertydescriptor ( clazz , propertyname ) ; if ( propertydescriptor == null ) { return new annotation [ ] { } ; } method accessmethod = null ; if ( useread ) { accessmethod = propertydescriptor . getreadmethod ( ) ; } else { accessmethod = propertydescriptor . getwritemethod ( ) ; } if ( accessmethod != null ) { annotation [ ] annotations = accessmethod . getannotations ( ) ; return annotations ; } else { return new annotation [ ] { } ; } }	Find annotation given a particular property name and clazz.
private static propertydescriptor dogetpropertydescriptor ( final class < ? > type , final string propertyname ) { try { beaninfo beaninfo = introspector . getbeaninfo ( type ) ; propertydescriptor [ ] propertydescriptors = beaninfo . getpropertydescriptors ( ) ; for ( propertydescriptor pd : propertydescriptors ) { if ( pd . getname ( ) . equals ( propertyname ) ) { return pd ; } } class < ? > superclass = type . getsuperclass ( ) ; if ( superclass != null ) { return dogetpropertydescriptor ( superclass , propertyname ) ; } return null ; } catch ( exception ex ) { throw new runtimeexception ( str_ + propertyname + str_ + type , ex ) ; } }	This needs to be refactored and put into Reflection or something.
@ suppresswarnings ( str_ ) public static < t > t frommap ( map < string , object > map , class < t > clazz ) { return mapper . frommap ( map , clazz ) ; }	From map.
@ suppresswarnings ( str_ ) public static < t > t frommap ( map < string , object > map , class < t > clazz , string ... excludeproperties ) { set < string > ignoreprops = excludeproperties . length > num_ ? sets . set ( excludeproperties ) : null ; return new mappercomplex ( fieldaccessmode . field_then_property . create ( bool_ ) , ignoreprops , null , bool_ ) . frommap ( map , clazz ) ; }	fromMap converts a map into a java object.
public static map < string , object > tomap ( final object object , final string ... ignore ) { return tomap ( object , sets . set ( ignore ) ) ; }	Basic toMap to create an object into a map.
public static map < string , object > tomap ( final object object , set < string > ignore ) { return new mappercomplex ( ignore ) . tomap ( object ) ; }	This could be refactored to use core.TypeType class and it would run faster.Converts an object into a map.
map < string , object > dogetvalues ( annotation annotation ) { map < string , object > values = new hashmap < string , object > ( ) ; method [ ] methods = annotation . annotationtype ( ) . getdeclaredmethods ( ) ; final object [ ] noargs = ( object [ ] ) null ; for ( method method : methods ) { if ( method . getparametertypes ( ) . length == num_ ) { try { object value = method . invoke ( annotation , noargs ) ; if ( value instanceof enum ) { enum enumval = ( enum ) value ; value = enumval . name ( ) ; } values . put ( method . getname ( ) , value ) ; } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } } } return values ; }	Get the values from the annotation.We use reflection to turn the annotation into a simple HashMapof values.
protected compositevalidator createvalidator ( list < validatormetadata > validationmetadatalist ) { compositevalidator compositevalidator = new compositevalidator ( ) ;	Create the validator by looking it up in the ObjectRegistry and thenpopulating it with values from the meta-data list.
private list < fieldvalidator > lookupthelistofvalidatorsandinitializethemwithmetadataproperties ( list < validatormetadata > validationmetadatalist ) { list < fieldvalidator > validatorslist = new arraylist < > ( ) ; for ( validatormetadata validationmetadata : validationmetadatalist ) { fieldvalidator validator = lookupvalidatorinregistry ( validationmetadata . getname ( ) ) ; applyvalidationmetadatapropertiestovalidator ( validationmetadata , validator ) ; validatorslist . add ( validator ) ; } return validatorslist ; }	Lookup the list of validators for the current field and initialize themwith validation meta-data properties.
private fieldvalidator lookupvalidatorinregistry ( string validationmetadataname ) { map < string , object > applicationcontext = validationcontext . get ( ) . getobjectregistry ( ) ; exceptions . requirenonnull ( applicationcontext ) ; return ( fieldvalidator ) applicationcontext . get ( str_ + validationmetadataname ) ; }	This method looks up the validator in the registry.
private void applyvalidationmetadatapropertiestovalidator ( validatormetadata metadata , fieldvalidator validator ) { map < string , object > properties = metadata . getproperties ( ) ; ifpropertyblankremove ( properties , str_ ) ; ifpropertyblankremove ( properties , str_ ) ; beanutils . copyproperties ( validator , properties ) ; }	This method applies the properties from the validationMetaData to thevalidator uses Spring's BeanWrapperImpl.
private void ifpropertyblankremove ( map < string , object > properties , string property ) { object object = properties . get ( property ) ; if ( object == null ) { properties . remove ( property ) ; } else if ( object instanceof string ) { string string = ( string ) object ; if ( str_ . equals ( string . trim ( ) ) ) { properties . remove ( property ) ; } } }	Removes a property if it is null or an empty string.This allows the property to have a null or emtpy string in themeta-data but we don't copy it to the validator if the propertyis not set.
@ override public void tick ( long time ) { this . time . set ( time ) ; approxtime . set ( dates . utcnow ( ) ) ; }	Calculate utc time. This gets called every 20 mili-seconds or so.
@ override public int size ( ) { int size = num_ ; for ( simplecache < k , v > cache : cacheregions ) { size += cache . size ( ) ; } return size ; }	Get the size of the cache.This is not 100% accurate if cache is being concurrenly accessed.
private final int hash ( object k ) { int h = hashseed ; h ^= k . hashcode ( ) ; h ^= ( h > > > num_ ) ^ ( h > > > num_ ) ; return h ^ ( h > > > num_ ) ^ ( h > > > num_ ) ; }	Calculate the hash.
private boolean opendb ( file file , options options ) { try { database = jnidbfactory . factory . open ( file , options ) ; logger . info ( str_ ) ; return bool_ ; } catch ( ioexception ex1 ) { try { database = iq80dbfactory . factory . open ( file , options ) ; logger . info ( str_ ) ; return bool_ ; } catch ( ioexception ex2 ) { return exceptions . handle ( boolean . class , ex2 ) ; } } }	Opens the database.
@ override public void putall ( map < byte [ ] , byte [ ] > values ) { writebatch batch = database . createwritebatch ( ) ; try { for ( map . entry < byte [ ] , byte [ ] > entry : values . entryset ( ) ) { batch . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } if ( putallwritecount . addandget ( values . size ( ) ) > num_ ) { putallwritecount . set ( num_ ) ; database . write ( batch , flush ) ; } else { database . write ( batch , writeoptions ) ; } } finally { closebatch ( batch ) ; } }	Puts values into the key value store in batch mode.
@ override public void removeall ( iterable < byte [ ] > keys ) { writebatch batch = database . createwritebatch ( ) ; try { for ( byte [ ] key : keys ) { batch . delete ( key ) ; } database . write ( batch ) ; } finally { closebatch ( batch ) ; } }	Remove all of the keys passed.
@ override public keyvalueiterable < byte [ ] , byte [ ] > search ( byte [ ] startkey ) { final dbiterator iterator = database . iterator ( ) ; iterator . seek ( startkey ) ; return new keyvalueiterable < byte [ ] , byte [ ] > ( ) { @ override public void close ( ) { closeiterator ( iterator ) ; } @ override public iterator < entry < byte [ ] , byte [ ] > > iterator ( ) { return new iterator < entry < byte [ ] , byte [ ] > > ( ) { @ override public boolean hasnext ( ) { return iterator . hasnext ( ) ; } @ override public entry < byte [ ] , byte [ ] > next ( ) { map . entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; return new entry < > ( next . getkey ( ) , next . getvalue ( ) ) ; } @ override public void remove ( ) { iterator . remove ( ) ; } } ; } } ; }	Search to a certain location.
@ override public map < byte [ ] , byte [ ] > loadallbykeys ( collection < byte [ ] > keys ) { if ( keys == null || keys . size ( ) == num_ ) { return collections . empty_map ; } map < byte [ ] , byte [ ] > results = new linkedhashmap < > ( keys . size ( ) ) ; dbiterator iterator = null ; try { iterator = database . iterator ( ) ; iterator . seek ( keys . iterator ( ) . next ( ) ) ; while ( iterator . hasnext ( ) ) { final map . entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; results . put ( next . getkey ( ) , next . getvalue ( ) ) ; } } finally { try { if ( iterator != null ) { iterator . close ( ) ; } } catch ( ioexception e ) { exceptions . handle ( e ) ; } } return results ; }	Keys are expected to be sorted.
@ override public void close ( ) { try { flush ( ) ; database . close ( ) ; } catch ( exception e ) { exceptions . handle ( e ) ; } }	Close the database connection.
public static < t > double reduceby ( final double [ ] array , t object ) { if ( object . getclass ( ) . isanonymousclass ( ) ) { return reducebyr ( array , object ) ; } try { constantcallsite callsite = invoker . invokereducerlongintreturnlongmethodhandle ( object ) ; methodhandle methodhandle = callsite . dynamicinvoker ( ) ; try { double sum = num_ ; for ( double v : array ) { sum = ( double ) methodhandle . invokeexact ( sum , v ) ; } return sum ; } catch ( throwable throwable ) { return handle ( long . class , throwable , str_ ) ; } } catch ( exception ex ) { return reducebyr ( array , object ) ; } }	Reduce by functional support for int arrays.
private static < t > double reducebyr ( final double [ ] array , t object ) { try { method method = invoker . invokereducerlongintreturnlongmethod ( object ) ; double sum = num_ ; for ( double v : array ) { sum = ( double ) method . invoke ( object , sum , v ) ; } return sum ; } catch ( throwable throwable ) { return handle ( long . class , throwable , str_ ) ; } }	Fallback to reflection if the call-site will not work or did not work.
public static double variancedouble ( double [ ] values , final int start , final int length ) { double mean = mean ( values , start , length ) ; double temp = num_ ; for ( int index = start ; index < length ; index ++ ) { double a = values [ index ] ; temp += ( mean - a ) * ( mean - a ) ; } return temp / length ; }	Calculate Variance.
public static double meandouble ( long [ ] values , final int start , final int length ) { double mean = ( ( double ) sum ( values , start , length ) ) / ( ( double ) length ) ; return mean ; }	Used internally to avoid loss and rounding errors a bit.
public static object invokemethodfromobjectarg ( object object , methodaccess method , object args ) { return invokemethodfromobjectarg ( bool_ , null , null , object , method , args ) ; }	Invokes method from list or map depending on what the Object arg is.
public static double reduceby ( final float [ ] array , reduceby reduceby ) { double sum = num_ ; for ( float v : array ) { sum = reduceby . reduce ( sum , v ) ; } return sum ; }	A very fast reduce by.If performance is your thing, this seems to be as fast a plain for loop when benchmarking with JMH.
public static string euroutcsystemdatestring ( long timestamp ) { calendar calendar = calendar . getinstance ( ) ; calendar . settimeinmillis ( timestamp ) ; calendar . settimezone ( utc_time_zone ) ; int day = calendar . get ( calendar . day_of_month ) ; int month = calendar . get ( calendar . month ) ; int year = calendar . get ( calendar . year ) ; int hour = calendar . get ( calendar . hour_of_day ) ; int minute = calendar . get ( calendar . minute ) ; int second = calendar . get ( calendar . second ) ; charbuf buf = charbuf . create ( num_ ) ; buf . add ( str . zfill ( day , num_ ) ) . add ( str_ ) ; buf . add ( str . zfill ( month , num_ ) ) . add ( str_ ) ; buf . add ( year ) . add ( str_ ) ; buf . add ( str . zfill ( hour , num_ ) ) . add ( str_ ) ; buf . add ( str . zfill ( minute , num_ ) ) . add ( str_ ) ; buf . add ( str . zfill ( second , num_ ) ) . add ( str_ ) ; return buf . tostring ( ) ; }	Useful for generated file names and generated work directories.
public static boolean matches ( object obj , criteria ... exp ) { return objectfilter . and ( exp ) . test ( obj ) ; }	Does the object match this expression.An expression is a collection of criteria.
public static criterion notin ( final object name , final object ... values ) { return new criterion < object > ( name . tostring ( ) , operator . not_in , values ) { @ override public boolean resolve ( object owner ) { object fieldvalue = fieldvalue ( ) ; if ( value == null ) { return bool_ ; } return ! valueset ( ) . contains ( fieldvalue ) ; } } ; }	This has to convert values to field type.
public static criteria criteriafromlist ( list < ? > list ) { list < object > args = new arraylist ( list ) ; object o = atindex ( args , - num_ ) ; if ( ! ( o instanceof list ) ) { atindex ( args , - num_ , collections . singletonlist ( o ) ) ; } return ( criteria ) invoker . invokefromlist ( objectfilter . class , str_ , args ) ; }	Creates criteria from a list.
public static criteria criteriafromjson ( string json ) { return ( criteria ) invoker . invokefromobject ( objectfilter . class , str_ , fromjson ( json ) ) ; }	Converts a JSON string into a Criteria.
public boolean addarray ( double ... integers ) { if ( end + integers . length >= values . length ) { values = grow ( values , ( values . length + integers . length ) * num_ ) ; } system . arraycopy ( integers , num_ , values , end , integers . length ) ; end += integers . length ; return bool_ ; }	Add a new array to the list.
public static < t > t max ( t [ ] array ) { if ( array . length > num_ ) { sorting . sortdesc ( array ) ; return array [ num_ ] ; } else { return null ; } }	Gets the max item from the array.Sorts the list descending first.
public static < t > list < t > firstof ( list < t > list , int count , sort ... sorts ) { if ( list . size ( ) > num_ ) { sorting . sort ( list , sorts ) ; return lists . sliceof ( list , num_ , count ) ; } else { return null ; } }	From the sorts, this is the first few items.
public static < t > t lastof ( list < t > list , sort ... sorts ) { if ( list . size ( ) > num_ ) { sorting . sort ( list , sorts ) ; return list . get ( list . size ( ) - num_ ) ; } else { return null ; } }	Grabs the last items after the sort.
public static < t > list < t > lastof ( list < t > list , int count , sort ... sorts ) { if ( list . size ( ) > num_ ) { sorting . sort ( list , sorts ) ; return lists . endsliceof ( list , count * - num_ ) ; } else { return null ; } }	Grabs the last few items from the list.
public static < t > list < t > least ( list < t > list , int count ) { if ( list . size ( ) > num_ ) { sorting . sort ( list ) ; return lists . sliceof ( list , num_ , count ) ; } else { return null ; } }	Returns the least few.
public static < t > t min ( list < t > list ) { if ( list . size ( ) > num_ ) { sorting . sort ( list ) ; return list . get ( num_ ) ; } else { return null ; } }	Returns the min value using a natural sort.
public static < t > t min ( t [ ] array , string sortby ) { if ( array . length > num_ ) { sorting . sort ( array , sortby ) ; return array [ num_ ] ; } else { return null ; } }	Returns the min value of the object with the property given.
private void processarrayofmaps ( object newinstance , fieldaccess field , map < string , object > [ ] maps ) { list < map < string , object > > list = lists . list ( maps ) ; handlecollectionofmaps ( newinstance , field , list ) ; }	Processes an array of maps.
@ suppresswarnings ( str_ ) private void handlecollectionofmaps ( object newinstance , fieldaccess field , collection < map < string , object > > collectionofmaps ) { collection < object > newcollection = conversions . createcollection ( field . type ( ) , collectionofmaps . size ( ) ) ; class < ? > componentclass = field . getcomponentclass ( ) ; if ( componentclass != null ) { for ( map < string , object > mapcomponent : collectionofmaps ) { newcollection . add ( frommap ( mapcomponent , componentclass ) ) ; } field . setobject ( newinstance , newcollection ) ; } }	Processes an collection of maps.
@ override public object frommap ( map < string , object > map ) { string clazz = ( string ) map . get ( str_ ) ; class cls = reflection . loadclass ( clazz ) ; return frommap ( map , cls ) ; }	fromMap converts a map into a Java object.This version will see if there is a class parameter in the map, and dies if there is not.
@ override public value get ( key key ) { removethenaddkey ( key ) ; return map . get ( key ) ; }	Get the value at key.
public static string createtooltipwithnamespace ( final string namespace , final string fieldname , final resourcebundle bundle , final string tooltiptype ) { string tooltip = null ; try { try { tooltip = bundle . getstring ( namespace + str_ + fieldname + str_ + tooltiptype ) ; } catch ( missingresourceexception mre ) { tooltip = bundle . getstring ( fieldname + str_ + tooltiptype ) ; } } catch ( missingresourceexception mre ) { } return tooltip ; }	Get the tool tip.
public charsequence addhex ( final int decoded ) { int _location = location ; char [ ] _buffer = buffer ; int _capacity = capacity ; if ( num_ + _location > _capacity ) { _buffer = chr . grow ( _buffer ) ; _capacity = _buffer . length ; } _buffer [ _location ] = ( char ) encodenibbletohexasciicharbyte ( ( decoded > > num_ ) & num_ ) ; _location ++ ; _buffer [ _location ] = ( char ) encodenibbletohexasciicharbyte ( decoded & num_ ) ; ; _location ++ ; location = _location ; buffer = _buffer ; capacity = _capacity ; return this ; }	Turn a single bytes into two hex character representation.
private void processwritequeue ( ) throws interruptedexception { writestatus status = new writestatus ( ) ; while ( bool_ ) { datastorerequest operation = writeoperationsqueue . poll ( datastoreconfig . polltimeoutms ( ) , timeunit . milliseconds ) ; while ( operation != null ) { status . tracker . addcall ( operation , outputdataqueue ) ; writeoperationsbatch . add ( operation ) ; if ( writeoperationsbatch . size ( ) > datastoreconfig . processqueuemaxbatchsize ( ) ) { break ; } operation = writeoperationsqueue . poll ( ) ; } if ( writeoperationsbatch . size ( ) > num_ ) { try { status . writebatchsize . add ( writeoperationsbatch . size ( ) ) ; recievedwritebatch ( new arraylist < > ( writeoperationsbatch ) ) ; } finally { writeoperationsbatch . clear ( ) ; } } else { flushwritesifneeded ( ) ; } if ( status . writebatchsize . size ( ) > num_ ) { status . sendbatchsize ( source , outputdataqueue ) ; } } }	Called from worker thread.Processes the incoming queue for read and writes.
public void start ( ) { scheduledexecutorservice = executors . newscheduledthreadpool ( num_ , new threadfactory ( ) { @ override public thread newthread ( runnable runnable ) { thread thread = new thread ( runnable ) ; thread . setname ( str_ + source ) ; return thread ; } } ) ; future = scheduledexecutorservice . scheduleatfixedrate ( new runnable ( ) { @ override public void run ( ) { if ( stop . get ( ) ) { return ; } try { processwritequeue ( ) ; } catch ( interruptedexception ex ) {	Start up the queue handlers.
@ universal public static string atindex ( string str , int index , char c ) { return idx ( str , index , c ) ; }	Puts character at index.
@ universal public static string slc ( string str , int start ) { return faststringutils . nocopystringfromchars ( chr . slc ( faststringutils . tochararray ( str ) , start ) ) ; }	Gets slice of a string.
@ universal public static boolean in ( char [ ] chars , string str ) { return chr . in ( chars , faststringutils . tochararray ( str ) ) ; }	See if chars is in another string.
@ universal public static string add ( string str , char c ) { return faststringutils . nocopystringfromchars ( chr . add ( faststringutils . tochararray ( str ) , c ) ) ; }	Add a char to a string.
public static string addobjects ( object ... objects ) { int length = num_ ; for ( object obj : objects ) { if ( obj == null ) { continue ; } length += obj . tostring ( ) . length ( ) ; } charbuf builder = charbuf . createexact ( length ) ; for ( object str : objects ) { if ( str == null ) { continue ; } builder . add ( str . tostring ( ) ) ; } return builder . tostring ( ) ; }	Add many objects converted to strings together.Null are ignored so be careful.
public static string compact ( string str ) { return faststringutils . nocopystringfromchars ( chr . compact ( faststringutils . tochararray ( str ) ) ) ; }	Gets rid of null characters lurking in the string.
public static string [ ] split ( string str ) { char [ ] [ ] split = chr . split ( faststringutils . tochararray ( str ) ) ; return fromchararrayofarraytostringarray ( split ) ; }	Split a string.
public static string [ ] splitbyspace ( string str ) { char [ ] [ ] split = charscanner . splitbyspace ( faststringutils . tochararray ( str ) ) ; return fromchararrayofarraytostringarray ( split ) ; }	Split a string by space.
public static string [ ] splitbypipe ( string str ) { char [ ] [ ] split = charscanner . splitbypipe ( faststringutils . tochararray ( str ) ) ; return fromchararrayofarraytostringarray ( split ) ; }	Split a string by pipe.
public static string [ ] fromchararrayofarraytostringarray ( char [ ] [ ] split ) { string [ ] results = new string [ split . length ] ; char [ ] array ; for ( int index = num_ ; index < split . length ; index ++ ) { array = split [ index ] ; results [ index ] = array . length == num_ ? empty_string : faststringutils . nocopystringfromchars ( array ) ; } return results ; }	Convert arrays of chars to arrays of strings.
public static string camelcase ( string instr , boolean upper ) { char [ ] in = faststringutils . tochararray ( instr ) ; char [ ] out = chr . camelcase ( in , upper ) ; return faststringutils . nocopystringfromchars ( out ) ; }	Convert to camel case and pass upper or lower.
public static boolean insideof ( string start , string instr , string end ) { return chr . insideof ( faststringutils . tochararray ( start ) , faststringutils . tochararray ( instr ) , faststringutils . tochararray ( end ) ) ; }	Checks to see if a string is inside of another.
public static string underbarcase ( string instr ) { char [ ] in = faststringutils . tochararray ( instr ) ; char [ ] out = chr . underbarcase ( in ) ; return faststringutils . nocopystringfromchars ( out ) ; }	Convert to under bar case.
public static string num ( number count ) { if ( count == null ) { return str_ ; } if ( count instanceof double || count instanceof bigdecimal ) { string s = count . tostring ( ) ; if ( idx ( s , num_ ) == str_ && s . length ( ) > num_ ) { s = slc ( s , num_ , num_ ) ; return s ; } else { return s ; } } else if ( count instanceof integer || count instanceof long || count instanceof short || count instanceof biginteger ) { string s = count . tostring ( ) ; s = new stringbuilder ( s ) . reverse ( ) . tostring ( ) ; charbuf buf = charbuf . create ( s . length ( ) ) ; int index = num_ ; for ( char c : s . tochararray ( ) ) { index ++ ; buf . add ( c ) ; if ( index % num_ == num_ ) { buf . add ( str_ ) ; } } if ( buf . lastchar ( ) == str_ ) { buf . removelastchar ( ) ; } s = buf . tostring ( ) ; s = new stringbuilder ( s ) . reverse ( ) . tostring ( ) ; return s ; } return count . tostring ( ) ; }	Do a nice pretty print of a number.Add commas and such.
public static sort sorts ( sort ... sorts ) { if ( sorts == null || sorts . length == num_ ) { return null ; } sort main = sorts [ num_ ] ; for ( int index = num_ ; index < sorts . length ; index ++ ) { main . then ( sorts [ index ] ) ; } return main ; }	Helper method to create a Sort that is a composite of other sorts.
public void sort ( list list , map < string , fieldaccess > fields ) { collections . sort ( list , this . comparator ( fields ) ) ; }	Sort if you already know the reflection fields.
public comparator comparator ( map < string , fieldaccess > fields ) { if ( comparator == null ) { comparator = universalcomparator ( this . getname ( ) , fields , this . gettype ( ) , this . childcomparators ( fields ) ) ; } return comparator ; }	This is what really does the magic.
private list < comparator > childcomparators ( map < string , fieldaccess > fields ) { if ( this . comparators == null ) { this . comparators = new arraylist < > ( this . sorts . size ( ) + num_ ) ; for ( sort sort : sorts ) { comparator comparator = universalcomparator ( sort . getname ( ) , fields , sort . gettype ( ) , sort . childcomparators ( fields ) ) ; this . comparators . add ( comparator ) ; } } return this . comparators ; }	This creates a list of children comparators based on the child list.
public static < k , v > boolean valuein ( v value , map < k , v > map ) { return map . containsvalue ( value ) ; }	End universal methods.
public static boolean equalsordie ( int expected , int got ) { if ( expected != got ) { return die ( boolean . class , str_ , expected , str_ , got ) ; } return bool_ ; }	Checks to see if two values are the same.
public static boolean equalsordie ( int [ ] expected , int [ ] got ) { if ( expected . length != got . length ) { die ( str_ , expected . length , str_ , got . length ) ; } for ( int index = num_ ; index < expected . length ; index ++ ) { if ( expected [ index ] != got [ index ] ) { die ( str_ , index , str_ , expected [ index ] , str_ , got [ index ] ) ; } } return bool_ ; }	Checks to see if two arrays are equals.
public static int sum ( int [ ] values , int start , int length ) { long sum = num_ ; for ( int index = start ; index < length ; index ++ ) { sum += values [ index ] ; } if ( sum < integer . min_value ) { die ( str_ , sum ) ; } if ( sum > integer . max_value ) { die ( str_ , sum ) ; } return ( int ) sum ; }	SumProvides overflow protection.
public static int rounduptopowerof2 ( int number ) { int rounded = number >= num_ ? num_ : ( rounded = integer . highestonebit ( number ) ) != num_ ? ( integer . bitcount ( number ) > num_ ) ? rounded << num_ : rounded : num_ ; return rounded ; }	Round up to the nearest power of 2.
public static void sort ( list list , string sortby , map < string , fieldaccess > fields , boolean ascending ) { sort ( list , sortby , fields , ascending , bool_ ) ; }	This is the work horse.
public static void sort ( list list , string sortby , map < string , fieldaccess > fields , boolean ascending , boolean nullsfirst ) { try { if ( list == null || list . size ( ) == num_ ) { return ; } object o = list . get ( num_ ) ; if ( sortby . equals ( str_ ) ) { collections . sort ( list , thisuniversalcomparator ( ascending , nullsfirst ) ) ; return ; } final fieldaccess field = fields . get ( sortby ) ; if ( field != null ) { collections . sort ( list , sorting . universalcomparator ( field , ascending , nullsfirst ) ) ; } } catch ( exception ex ) { exceptions . handle ( ex , str_ , list , str_ , sortby , str_ , fields , str_ , ascending , str_ , nullsfirst ) ; } }	This is the work horse.
private void setfieldvaluefrommap ( final object parentobject , final fieldaccess field , final map mapinner ) { class < ? > fieldclasstype = field . type ( ) ; object value = null ; if ( ! typ . ismap ( fieldclasstype ) ) { if ( ! fieldclasstype . isinterface ( ) && ! typ . isabstract ( fieldclasstype ) ) { value = frommap ( mapinner , field . type ( ) ) ; } else { object oclassname = mapinner . get ( str_ ) ; if ( oclassname != null ) { value = frommap ( mapinner , reflection . loadclass ( oclassname . tostring ( ) ) ) ; } else { value = null ; } } } else if ( typ . ismap ( fieldclasstype ) ) { class keytype = ( class ) field . getparameterizedtype ( ) . getactualtypearguments ( ) [ num_ ] ; class valuetype = ( class ) field . getparameterizedtype ( ) . getactualtypearguments ( ) [ num_ ] ; set < map . entry > set = mapinner . entryset ( ) ; map newmap = new linkedhashmap ( ) ; for ( map . entry entry : set ) { object evalue = entry . getvalue ( ) ; object key = entry . getkey ( ) ; if ( evalue instanceof valuecontainer ) { evalue = ( ( valuecontainer ) evalue ) . tovalue ( ) ; } key = conversions . coerce ( keytype , key ) ; evalue = conversions . coerce ( valuetype , evalue ) ; newmap . put ( key , evalue ) ; } value = newmap ; } field . setvalue ( parentobject , value ) ; }	Inject a map into an object's field.
@ override public list < ? > tolist ( object object ) { typetype instancetype = typetype . getinstancetype ( object ) ; switch ( instancetype ) { case null : return lists . list ( ( object ) null ) ; case array : case array_int : case array_byte : case array_short : case array_float : case array_double : case array_long : case array_string : case array_object : return conversions . tolist ( object ) ; case instance : if ( reflection . respondsto ( object , str_ ) ) { return ( list < ? > ) reflection . invoke ( object , str_ ) ; } break ; } return lists . list ( object ) ; }	Convert an object to a list.
protected void createloadallversiondatasql ( string table ) { charbuf buf = charbuf . create ( num_ ) ; buf . add ( str_ ) ; buf . add ( table ) ; buf . add ( str_ ) ; buf . multiply ( str_ , this . loadkeycount ) ; buf . removelastchar ( ) ; buf . add ( str_ ) ; this . loadallversiondatabykeyssql = buf . tostring ( ) ; }	Create load all keys SQL.
@ universal public static < v > list < v > deepcopy ( list < v > list ) { if ( list instanceof linkedlist ) { return deepcopytolist ( list , new linkedlist < v > ( ) ) ; } else if ( list instanceof copyonwritearraylist ) { return deepcopytolist ( list , new copyonwritearraylist < v > ( ) ) ; } else { return deepcopy ( ( collection ) list ) ; } }	Clones each list item into a new instance with copied fields.It is like doing a clone operation.If the passed list is a LinkedList then the returned list will be aLinkedList.If the passed list is a CopyOnWriteArrayList then the returned list willbe a CopyOnWriteArrayList list.All other lists become ArrayList.
public static boolean hasstringfield ( final object value1 , final string name ) { class < ? > clz = value1 . getclass ( ) ; return classhasstringfield ( clz , name ) ; }	Checks to see if we have a string field.
public static boolean classhasstringfield ( class < ? > clz , string name ) { list < field > fields = reflection . getallfields ( clz ) ; for ( field field : fields ) { if ( field . gettype ( ) . equals ( typ . string ) && field . getname ( ) . equals ( name ) && ! modifier . isstatic ( field . getmodifiers ( ) ) && field . getdeclaringclass ( ) == clz ) { return bool_ ; } } return bool_ ; }	Checks to see if this class has a string field.
public static boolean classhasfield ( class < ? > clz , string name ) { list < field > fields = reflection . getallfields ( clz ) ; for ( field field : fields ) { if ( field . getname ( ) . equals ( name ) && ! modifier . isstatic ( field . getmodifiers ( ) ) && field . getdeclaringclass ( ) == clz ) { return bool_ ; } } return bool_ ; }	Checks to see if a class has a field.
public static string getfirstcomparableorprimitivefromclass ( class < ? > clz ) { list < field > fields = reflection . getallfields ( clz ) ; for ( field field : fields ) { if ( ( field . gettype ( ) . isprimitive ( ) || typ . iscomparable ( field . gettype ( ) ) && ! modifier . isstatic ( field . getmodifiers ( ) ) && field . getdeclaringclass ( ) == clz ) ) { return field . getname ( ) ; } } return null ; }	This can be used for default sort.
public static string getsortablefield ( object value1 ) { if ( value1 instanceof map ) { return getsortablefieldfrommap ( ( map < string , ? > ) value1 ) ; } else { return getsortablefieldfromclass ( value1 . getclass ( ) ) ; } }	Gets the first sortable fields found.
@ override public final int compareto ( cacheentry other ) { switch ( type ) { case lfu : return comparetolfu ( other ) ; case lru : return comparetolru ( other ) ; case fifo : return comparetofifo ( other ) ; default : die ( ) ; return num_ ; } }	Comparison of entries this determines what we will order the cache bywhich determines which type of cache it is.
private final int comparetime ( cacheentry other ) { if ( time > other . time ) {	Compare the time.
public static void sort ( list list , sort ... sorts ) { sort . sorts ( sorts ) . sort ( list ) ; }	Takes a list an an array or sorts.
public static void sort ( list list , string sortby , boolean ascending , boolean nullsfirst ) { if ( list == null || list . size ( ) == num_ ) { return ; } if ( sortby . equals ( str_ ) ) { collections . sort ( list , thisuniversalcomparator ( ascending , nullsfirst ) ) ; return ; } iterator iterator = list . iterator ( ) ; object object = iterator . next ( ) ; map < string , fieldaccess > fields = null ; if ( object != null ) { fields = beanutils . getfieldsfromobject ( object ) ; } else { while ( iterator . hasnext ( ) ) { object = iterator . next ( ) ; if ( object != null ) { fields = beanutils . getfieldsfromobject ( object ) ; break ; } } } if ( fields != null ) { final fieldaccess field = fields . get ( sortby ) ; if ( field != null ) { collections . sort ( list , sorting . universalcomparator ( field , ascending , nullsfirst ) ) ; } } }	Sort a list.
public static < k , v > collection < map . entry < k , v > > sortentries ( class < v > componenttype , map < k , v > map , string sortby , boolean ascending , boolean nullsfirst ) { return sort ( ( class ) componenttype , ( collection ) map . entryset ( ) , sortby , ascending , nullsfirst ) ; }	Sort map entries.
public static < k , v > collection < map . entry < k , v > > sortvalues ( class < v > componenttype , map < k , v > map , string sortby , boolean ascending , boolean nullsfirst ) { return sort ( ( class ) componenttype , ( collection ) map . values ( ) , sortby , ascending , nullsfirst ) ; }	Sort map values.
public static < k , v > collection < map . entry < k , v > > sortkeys ( class < v > componenttype , map < k , v > map , string sortby , boolean ascending , boolean nullsfirst ) { return sort ( ( class ) componenttype , ( collection ) map . keyset ( ) , sortby , ascending , nullsfirst ) ; }	Sort map keys.
public static < t > void sort ( t [ ] array , string sortby , boolean ascending , boolean nullsfirst ) { if ( array == null || array . length == num_ ) { return ; } if ( sortby . equals ( str_ ) ) { arrays . sort ( array , thisuniversalcomparator ( ascending , nullsfirst ) ) ; return ; } object object = array [ num_ ] ; map < string , fieldaccess > fields = null ; if ( object != null ) { fields = beanutils . getfieldsfromobject ( object ) ; } else { for ( int index = num_ ; index < array . length ; index ++ ) { object = array [ index ] ; if ( object != null ) { fields = beanutils . getfieldsfromobject ( object ) ; break ; } } } if ( fields != null ) { final fieldaccess field = fields . get ( sortby ) ; if ( field != null ) { arrays . sort ( array , sorting . universalcomparator ( field , ascending , nullsfirst ) ) ; } } }	Sort an array.
public static comparator universalcomparator ( final fieldaccess field , final boolean ascending , final boolean nullsfirst ) { return new comparator ( ) { @ override public int compare ( object o1 , object o2 ) { object value1 = null ; object value2 = null ; if ( ascending ) { value1 = field . getvalue ( o1 ) ; value2 = field . getvalue ( o2 ) ; } else { value1 = field . getvalue ( o2 ) ; value2 = field . getvalue ( o1 ) ; } return sorting . compare ( value1 , value2 , nullsfirst ) ; } } ; }	This creates the universal comparator object which is used by the sort work horse.
public static comparator thisuniversalcomparator ( final boolean ascending , final boolean nullsfirst ) { return new comparator ( ) { @ override public int compare ( object o1 , object o2 ) { object value1 ; object value2 ; if ( ascending ) { value1 = ( o1 ) ; value2 = ( o2 ) ; } else { value1 = ( o2 ) ; value2 = ( o1 ) ; } return sorting . compare ( value1 , value2 , nullsfirst ) ; } } ; }	This creates the universal comparator object used for "this".
public value get ( key key ) { cacheentry < key , value > cacheentry = map . get ( key ) ; if ( cacheentry != null ) { cacheentry . readcount . incrementandget ( ) ; return cacheentry . value ; } else { return null ; } }	Get the value from the cache.
public value getsilent ( key key ) { cacheentry < key , value > cacheentry = map . get ( key ) ; if ( cacheentry != null ) { return cacheentry . value ; } else { return null ; } }	Used for testing as it gets the value without updating stats.
private final void evictifneeded ( ) { if ( list . size ( ) > evictsize ) { final list < cacheentry < key , value > > killlist = list . sortandreturnpurgelist ( num_ ) ; for ( cacheentry < key , value > cacheentry : killlist ) { map . remove ( cacheentry . key ) ; } } }	Evict if we are over the size limit.
private void dynamicallyinitifneeded ( object value ) { if ( ! isinitialized ( ) ) { if ( value instanceof integer ) { init ( new integer ( min . intvalue ( ) ) , new integer ( max . intvalue ( ) ) ) ; } else if ( value instanceof byte ) { init ( new byte ( min . bytevalue ( ) ) , new byte ( max . bytevalue ( ) ) ) ; } else if ( value instanceof short ) { init ( new short ( min . shortvalue ( ) ) , new short ( max . shortvalue ( ) ) ) ; } else { init ( min , max ) ; } } }	If the type was not initialized, we can still figure it out at runtime.
public final bytebuffer allocatebuffer ( int size ) { if ( recycle_buffer ) { bytebuffer spentbuffer = recyclechannel . poll ( ) ; if ( spentbuffer == null ) { spentbuffer = bytebuffer . allocatedirect ( size ) ; } spentbuffer . clear ( ) ; return spentbuffer ; } else { return bytebuffer . allocatedirect ( size ) ; } }	This gets called from the http post handler or event bus handler.
private boolean determineifweshouldexit ( ) { boolean shouldstop = stop . get ( ) ; if ( ! shouldstop ) { thread . interrupted ( ) ; } else { system . out . println ( str_ ) ; return bool_ ; } return bool_ ; }	See if it is time to stopWe have been interrupted.
private void manageinputwriterchannel ( ) throws interruptedexception { try { bytebuffer datatowritetofile ; datatowritetofile = inputchannel . poll ( ) ;	Queue and batch writer main logic.This is where the magic happens.
private void queueemptymaybeflush ( ) { if ( periodic_force_flush ) { long currenttime = time . get ( ) ; if ( ( currenttime - lastflushtime ) > force_flush_after_this_many_mili_seconds ) { if ( writer . synctodisk ( ) ) {	If we detect that the in-coming transfer outputDataQueue channel is emptythen it could be an excellent time to sync to disk.
private void startmonitor ( ) { final scheduledexecutorservice monitor = executors . newscheduledthreadpool ( num_ , new threadfactory ( ) { @ override public thread newthread ( runnable runnable ) { thread thread = new thread ( runnable ) ; thread . setpriority ( thread . norm_priority + num_ ) ; return thread ; } } ) ; monitorfuture = monitor . scheduleatfixedrate ( new runnable ( ) { @ override public void run ( ) { monitor ( ) ; } } , monitor_interval_seconds , monitor_interval_seconds , timeunit . seconds ) ; runtime . getruntime ( ) . addshutdownhook ( new thread ( new runnable ( ) { @ override public void run ( ) { system . err . println ( str_ ) ; monitor ( ) ; } } ) ) ; }	Start up the health monitor.
public void start ( final timeaware receiver ) {	Starts up the batch writer.
@ override public final object get ( object key ) { object object = null ; if ( map == null ) { buildmap ( ) ; } object = map . get ( key ) ; lazychopifneeded ( object ) ; return object ; }	Gets the item by key from the mapping.
private resultset mainqueryplan ( criteria [ ] expressions ) { resultsetinternal results = new resultsetimpl ( this . fields ) ; if ( expressions == null || expressions . length == num_ ) { results . addresults ( searchablecollection . all ( ) ) ; } group group = expressions . length == num_ && expressions [ num_ ] instanceof group ? ( group ) expressions [ num_ ] : objectfilter . and ( expressions ) ; dofiltergroup ( group , results ) ; return results ; }	This is the main criteria plan in case the name was notobvious.
private void dofiltergroup ( group group , resultsetinternal results ) { if ( group . getgrouping ( ) == grouping . or ) { or ( group . getexpressions ( ) , fields , results ) ; } else { resultsetinternal resultsforand = new resultsetimpl ( fields ) ; and ( group . getexpressions ( ) , fields , resultsforand ) ; results . addresults ( resultsforand . aslist ( ) ) ; } }	Run the filter on the group.
public void tick ( long time ) { this . time . set ( time ) ; long starttime = filestarttime . get ( ) ; long duration = time - starttime ; if ( duration > file_timeout_miliseconds ) { filetimeout . set ( bool_ ) ; } }	Recieves a tick from our clock.
public boolean synctodisk ( ) { if ( outputstream != null && dirty ) { try {	flush to disk.
private void cleanupoutputstream ( ) { if ( outputstream != null ) { try { outputstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( system . err ) ; } finally { outputstream = null ; } } }	Attempts to close down log stream.
public void nextbuffertowrite ( final bytebuffer bufferout ) throws interruptedexception { dirty = bool_ ; final int size = bufferout . limit ( ) ; write ( bufferout ) ; if ( ! error . get ( ) ) { totalbytestransferred += size ; bytestransferred += size ; bytessincelastflush += size ; bufferssent ++ ; } if ( this . bytestransferred >= file_size_bytes || filetimeout . get ( ) ) { try { outputstream . close ( ) ; } catch ( ioexception e ) { cleanupoutputstream ( ) ; e . printstacktrace ( system . err ) ; } finally { outputstream = null ; } } }	Writes a buffer of data to the log system.
private void write ( final bytebuffer bufferout ) throws interruptedexception { initoutputstream ( ) ; try { if ( outputstream != null ) { outputstream . write ( bufferout ) ; } else { error . set ( bool_ ) ; } if ( bytessincelastflush > flush_every_n_bytes ) { synctodisk ( ) ; bytessincelastflush = num_ ; } } catch ( closedbyinterruptexception cbie ) { throw new interruptedexception ( str_ ) ; } catch ( exception e ) { cleanupoutputstream ( ) ; error . set ( bool_ ) ; e . printstacktrace ( system . err ) ; diagnose ( ) ; exceptions . handle ( e ) ; } }	Write the actual data to disk.
private void initoutputstream ( ) { long time = this . time . get ( ) ; if ( error . get ( ) || this . totalbytestransferred == num_ ) { cleanupoutputstream ( ) ; error . set ( bool_ ) ; time = system . nanotime ( ) / num_ ; } if ( outputstream != null ) { return ; } filename = logfilesconfig . getlogfilename ( format_pattern , outputdirpath ( ) , numfiles , time , server_name ) ; try { filetimeout . set ( bool_ ) ; outputstream = streamcreator ( ) ; filestarttime . set ( time ) ; bytestransferred = num_ ; bytessincelastflush = num_ ; } catch ( exception ex ) { cleanupoutputstream ( ) ; error . set ( bool_ ) ; exceptions . handle ( ex ) ; } finally { numfiles ++ ; } }	Initialize the output stream.
public void putall ( map < k , v > values ) { set < map . entry < k , v > > entries = values . entryset ( ) ; map < string , string > map = new hashmap < > ( values . size ( ) ) ; for ( map . entry < k , v > entry : entries ) { map . put ( tokeystring ( entry . getkey ( ) ) , tovaluestring ( entry . getvalue ( ) ) ) ; } store . putall ( map ) ; }	Put all of these values in the key value store.
protected byte [ ] tokeybytes ( k key ) { byte [ ] keybytes = keycache . get ( key ) ; if ( keybytes == null ) { keybytes = this . keytobytearrayconverter . apply ( key ) ; keycache . put ( key , keybytes ) ; } return keybytes ; }	Convert a String key to bytes.
public list < validatormetadata > readmetadata ( class < ? > clazz , string propertyname ) { properties props = loadmetadatapropsfile ( clazz ) ; string unparsedstring = props . getproperty ( propertyname ) ; return extractmetadatafromstring ( clazz , propertyname , unparsedstring ) ; }	Read the meta-data from a properties file.
private list < validatormetadata > extractmetadatafromstring ( class < ? > clazz , string propertyname , string unparsedstring ) { string propertykey = clazz . getname ( ) + str_ + propertyname ; list < validatormetadata > validatormetadatalist = metadatacache . get ( propertykey ) ; if ( validatormetadatalist == null ) { validatormetadatalist = new arraylist < validatormetadata > ( ) ; string [ ] validatorsparts = unparsedstring . split ( str_ ) ; for ( string validatorstring : validatorsparts ) { validatormetadata validatormetadata = new validatormetadata ( ) ; validatormetadatalist . add ( validatormetadata ) ; string [ ] parts = validatorstring . trim ( ) . split ( str_ ) ; validatormetadata . setname ( parts [ num_ ] ) ; if ( parts . length > num_ ) { list < string > values = arrays . aslist ( parts ) . sublist ( num_ , parts . length ) ; for ( string value : values ) { if ( value . indexof ( str_ ) != - num_ ) { string [ ] valueparts = value . split ( str_ ) ; validatormetadata . getproperties ( ) . put ( valueparts [ num_ ] , valueparts [ num_ ] ) ; } } } } metadatacache . put ( propertykey , validatormetadatalist ) ; } return validatormetadatalist ; }	This method extracts meta-data from a string.
public list < validatormetadata > readmetadata ( class < ? > clazz , string propertyname ) { string propertykey = clazz . getname ( ) + str_ + propertyname ; list < validatormetadata > validatormetadatalist = metadatacache . get ( propertykey ) ; if ( validatormetadatalist == null ) {	Read the meta-data from annotation.
private list < validatormetadata > extractvalidatormetadata ( class < ? > clazz , string propertyname , list < validatormetadata > validatormetadatalist ) { if ( validatormetadatalist == null ) {	Extract BaseValidator Meta Data.
private list < validatormetadata > extractmetadatafromannotations ( collection < annotationdata > annotations ) { list < validatormetadata > list = new arraylist < validatormetadata > ( ) ; for ( annotationdata annotationdata : annotations ) { validatormetadata validatormetadata = convertannotationdatatovalidatormetadata ( annotationdata ) ; list . add ( validatormetadata ) ; } return list ; }	Extract meta-data from the annotationData we collected thus far.
private validatormetadata convertannotationdatatovalidatormetadata ( annotationdata annotationdata ) { validatormetadata metadata = new validatormetadata ( ) ; metadata . setname ( annotationdata . getname ( ) ) ; metadata . setproperties ( annotationdata . getvalues ( ) ) ; return metadata ; }	Converts an AnnotationData into a ValidatorMetaData POJO.
public static string [ ] split ( final string string , final char split , final int limit ) { char [ ] [ ] comps = charscanner . split ( faststringutils . tochararray ( string ) , split , limit ) ; return str . fromchararrayofarraytostringarray ( comps ) ; }	Splits a string into many parts.
public static string [ ] splitbywhitespace ( final string string ) { char [ ] [ ] comps = charscanner . splitbychars ( faststringutils . tochararray ( string ) , white_space ) ; return str . fromchararrayofarraytostringarray ( comps ) ; }	Split string by white space.
public static string [ ] splitbydelimiters ( final string string , final string delimiters ) { char [ ] [ ] comps = charscanner . splitbychars ( faststringutils . tochararray ( string ) , delimiters . tochararray ( ) ) ; return str . fromchararrayofarraytostringarray ( comps ) ; }	Split string by a list of delimiters.
public static string removechars ( final string string , final char ... delimiters ) { char [ ] [ ] comps = charscanner . splitbycharsnoneempty ( faststringutils . tochararray ( string ) , delimiters ) ; return new string ( chr . add ( comps ) ) ; }	remove chars from a string.
public static string [ ] splitbycharsnoneempty ( final string string , int start , int end , final char ... delimiters ) { exceptions . requirenonnull ( string ) ; char [ ] [ ] comps = charscanner . splitbycharsnoneempty ( faststringutils . tochararray ( string ) , start , end , delimiters ) ; return str . fromchararrayofarraytostringarray ( comps ) ; }	Split string by a list of delimiters but none are empty within a range.
public static double parsedouble ( string buffer , int from , int to ) { return charscanner . parsedouble ( faststringutils . tochararray ( buffer ) , from , to ) ; }	parse a double.
public static int parseint ( string buffer , int from , int to ) { return charscanner . parseint ( faststringutils . tochararray ( buffer ) , from , to ) ; }	parse an int within a range.
public static long parselong ( string buffer , int from , int to ) { return charscanner . parselong ( faststringutils . tochararray ( buffer ) , from , to ) ; }	parse an long within a range.
public static object getpropbypath ( object item , string ... path ) { object o = item ; for ( int index = num_ ; index < path . length ; index ++ ) { string propname = path [ index ] ; if ( o == null ) { return null ; } else if ( o . getclass ( ) . isarray ( ) || o instanceof collection ) { o = getcollectionprop ( o , propname , index , path ) ; break ; } else { o = getprop ( o , propname ) ; } } return conversions . unifylistorarray ( o ) ; }	This method handles walking lists of lists.
public static map < string , fieldaccess > getfieldsfromobject ( object object ) { try { map < string , fieldaccess > fields ; if ( object instanceof map ) { fields = getfieldsfrommap ( ( map < string , object > ) object ) ; } else { fields = getpropertyfieldaccessmap ( object . getclass ( ) ) ; } return fields ; } catch ( exception ex ) { requirenonnull ( object , str_ ) ; return handle ( map . class , ex , str_ , classname ( object ) ) ; } }	Get fields from object or Map.Allows maps to act like they have fields.
public static class < ? > getpropertytype ( final object root , final string property ) { map < string , fieldaccess > fields = getpropertyfieldaccessmap ( root . getclass ( ) ) ; fieldaccess field = fields . get ( property ) ; return field . type ( ) ; }	Get property value, loads nested properties.
public static void injectintoproperty ( object object , string path , object value ) { string [ ] properties = propertypathasstringarray ( path ) ; setpropertyvalue ( object , value , properties ) ; }	Set property value to simulate dependency injection.
public static void idx ( class < ? > cls , string path , object value ) { string [ ] properties = propertypathasstringarray ( path ) ; setpropertyvalue ( cls , value , properties ) ; }	Set a static value.
private static object getcollectionprop ( object o , string propname , int index , string [ ] path ) { o = _getfieldvaluesfromcollectionorarray ( o , propname ) ; if ( index + num_ == path . length ) { return o ; } else { index ++ ; return getcollectionprop ( o , path [ index ] , index , path ) ; } }	This is an amazing little recursive method. It walks a fanout ofnested collection to pull out the leaf nodes.
public static object getprop ( object object , final string property ) { if ( object == null ) { return null ; } if ( isdigits ( property ) ) { object = idx ( object , stringscanner . parseint ( property ) ) ; } class < ? > cls = object . getclass ( ) ; map < string , fieldaccess > fields = reflection . getpropertyfieldaccessors ( cls ) ; if ( ! fields . containskey ( property ) ) { fields = reflection . getallaccessorfields ( cls ) ; } if ( ! fields . containskey ( property ) ) { return null ; } else { return fields . get ( property ) . getvalue ( object ) ; } }	This is one is forgiving of null paths.This works with getters first, i.e., properties.
public static int getpropertyint ( final object root , final string ... properties ) { final string lastproperty = properties [ properties . length - num_ ] ; if ( isdigits ( lastproperty ) ) { return conversions . toint ( getpropertyvalue ( root , properties ) ) ; } object object = baseforgetproperty ( root , properties ) ; map < string , fieldaccess > fields = getfieldsfromobject ( object ) ; fieldaccess field = fields . get ( lastproperty ) ; if ( field . type ( ) == typ . intgr ) { return field . getint ( object ) ; } else { return conversions . toint ( field . getvalue ( object ) ) ; } }	Get an int property.
public void init ( ) { if ( name == null && parent == null ) { this . setdetailmessage ( str_ + this . getclass ( ) . getname ( ) + detail_key + str_ ) ; this . setsummarymessage ( str_ + this . getclass ( ) . getname ( ) + summary_key + str_ ) ; } else if ( name != null && parent == null ) { this . setdetailmessage ( str_ + str_ + getname ( ) + detail_key + str_ ) ; this . setsummarymessage ( str_ + str_ + getname ( ) + summary_key + str_ ) ; } else if ( parent != null ) { this . setdetailmessage ( str_ + str_ + parent + detail_key + str_ ) ; this . setsummarymessage ( str_ + str_ + parent + summary_key + str_ ) ; } }	The init method tries to generate the message keys.You should only call the init method if you don't injectvalues into the detailMessage and summaryMessage.
public string createmessage ( string key , list < string > argkeys , object ... args ) { string message = getmessage ( key ) ; object [ ] actualargs ; if ( args . length > num_ ) { actualargs = args ; } else if ( argkeys != null ) { actualargs = keystovalues ( argkeys ) ; } else { actualargs = new object [ ] { } ; } return docreatemessage ( message , actualargs ) ; }	Creates a message.
@ suppresswarnings ( str_ ) private string docreatemessage ( string message , object [ ] actualargs ) { return validationcontext . get ( ) . createmessage ( message , getsubject ( ) , actualargs ) ; }	Actually creates the message.
private object [ ] keystovalues ( list < string > argkeys ) { list < string > values = new arraylist < > ( ) ; for ( string key : argkeys ) { values . add ( getmessage ( key ) ) ; } return values . toarray ( ) ; }	Convert the keys to values.
public string getsubject ( ) { return validationcontext . get ( ) . getcurrentsubject ( ) == null ? this . subject : validationcontext . get ( ) . getcurrentsubject ( ) ; }	Gets the current subject or the configured subject if thecurrent subject is not found.
public object parsetext ( string text ) { if ( text == null || text . length ( ) == num_ ) { throw new illegalargumentexception ( str_ ) ; } return jsonfactory . create ( ) . fromjson ( text ) ; }	Parse a text representation of a JSON data structure.
private void sendhttprequest ( final request request , final org . boon . core . handler < response > responsehandler ) { final httpclientrequest httpclientrequest = httpclient . request ( request . getmethod ( ) , request . uri ( ) , handleresponse ( request , responsehandler ) ) ; final runnable runnable = new runnable ( ) { @ override public void run ( ) { if ( ! request . getmethod ( ) . equals ( str_ ) ) { httpclientrequest . putheader ( str_ , str_ ) . end ( request . parambody ( ) ) ; } else { httpclientrequest . end ( ) ; } } } ; if ( closed . get ( ) ) { this . scheduledexecutorservice . schedule ( new runnable ( ) { @ override public void run ( ) { connect ( ) ; int retry = num_ ; while ( closed . get ( ) ) { sys . sleep ( num_ ) ; if ( ! closed . get ( ) ) { break ; } retry ++ ; if ( retry > num_ ) { break ; } if ( retry % num_ == num_ ) { connect ( ) ; } } if ( ! closed . get ( ) ) { runnable . run ( ) ; } else { responsehandler . handle ( new response ( str_ , - num_ , new error ( - num_ , str_ , str_ , - num_ ) ) ) ; } } } , num_ , timeunit . milliseconds ) ; } else { runnable . run ( ) ; } }	This actually sends the request.
public void deletedb ( string dbname , string confirm ) { assertnotempty ( dbname , str_ ) ; if ( ! str_ . equals ( confirm ) ) throw new illegalargumentexception ( str_ ) ; dbc . delete ( builduri ( dbc . getbaseuri ( ) ) . path ( dbname ) . build ( ) ) ; }	Requests CouchDB deletes a database.
public void createdb ( string dbname ) { assertnotempty ( dbname , str_ ) ; inputstream getresp = null ; httpresponse putresp = null ; final uri uri = builduri ( dbc . getbaseuri ( ) ) . path ( dbname ) . build ( ) ; try { getresp = dbc . get ( uri ) ; } catch ( nodocumentexception e ) {	Requests CouchDB creates a new database; if one doesn't exist.
public list < string > uuids ( long count ) { final string uri = string . format ( str_ , dbc . getbaseuri ( ) , count ) ; final jsonobject json = dbc . findany ( jsonobject . class , uri ) ; return dbc . getgson ( ) . fromjson ( json . get ( str_ ) . tostring ( ) , new typetoken < list < string > > ( ) { } . gettype ( ) ) ; }	Request a database sends a list of UUIDs.
public replicationresult trigger ( ) { assertnotempty ( source , str_ ) ; assertnotempty ( target , str_ ) ; httpresponse response = null ; try { jsonobject json = createjson ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( json ) ; } final uri uri = builduri ( dbc . getbaseuri ( ) ) . path ( str_ ) . build ( ) ; response = dbc . post ( uri , json . tostring ( ) ) ; final inputstreamreader reader = new inputstreamreader ( getstream ( response ) , charsets . utf_8 ) ; return dbc . getgson ( ) . fromjson ( reader , replicationresult . class ) ; } finally { close ( response ) ; } }	Triggers a replication request.
private < v > v queryvalue ( class < v > classofv ) { inputstream instream = null ; try { reader reader = new inputstreamreader ( instream = queryforstream ( ) , charsets . utf_8 ) ; jsonarray array = new jsonparser ( ) . parse ( reader ) . getasjsonobject ( ) . get ( str_ ) . getasjsonarray ( ) ; if ( array . size ( ) != num_ ) { throw new nodocumentexception ( str_ + array . size ( ) ) ; } return jsontoobject ( gson , array . get ( num_ ) , str_ , classofv ) ; } finally { close ( instream ) ; } }	Queries for scalar values.
public view descending ( boolean descending ) { this . descending = boolean . valueof ( gson . tojson ( descending ) ) ; uribuilder . query ( str_ , this . descending ) ; return this ; }	Reverses the reading direction, not the sort order.
public void synchronizeallwithdb ( ) { list < designdocument > documents = getallfromdesk ( ) ; for ( designdocument dd : documents ) { synchronizewithdb ( dd ) ; } }	Synchronize all design documents on desk to the database.
public designdocument getfromdb ( string id ) { assertnotempty ( id , str_ ) ; final uri uri = builduri ( dbc . getdburi ( ) ) . path ( id ) . build ( ) ; return dbc . get ( uri , designdocument . class ) ; }	Gets a design document from the database.
public list < designdocument > getallfromdesk ( ) { final list < designdocument > designdocslist = new arraylist < designdocument > ( ) ; for ( string docname : listresources ( format ( str_ , design_docs_dir ) ) ) { designdocslist . add ( getfromdesk ( docname ) ) ; } return designdocslist ; }	Gets all design documents from desk.
public designdocument getfromdesk ( string id ) { assertnotempty ( id , str_ ) ; final designdocument dd = new designdocument ( ) ; final string rootpath = format ( str_ , design_docs_dir , id ) ; final list < string > elements = listresources ( rootpath ) ; if ( elements == null ) { throw new illegalargumentexception ( str_ ) ; }	Gets a design document from desk.
public response save ( ) { assertnotempty ( replicatordoc . getsource ( ) , str_ ) ; assertnotempty ( replicatordoc . gettarget ( ) , str_ ) ; if ( userctxname != null ) { userctx ctx = replicatordoc . new userctx ( ) ; ctx . setname ( userctxname ) ; ctx . setroles ( userctxroles ) ; replicatordoc . setuserctx ( ctx ) ; } return dbc . put ( dburi , replicatordoc , bool_ ) ; }	Adds a new document to the replicator database.
public replicatordocument find ( ) { assertnotempty ( replicatordoc . getid ( ) , str_ ) ; final uri uri = builduri ( dburi ) . path ( replicatordoc . getid ( ) ) . query ( str_ , replicatordoc . getrevision ( ) ) . build ( ) ; return dbc . get ( uri , replicatordocument . class ) ; }	Finds a document in the replicator database.
public list < replicatordocument > findall ( ) { inputstream instream = null ; try { final uri uri = builduri ( dburi ) . path ( str_ ) . query ( str_ , str_ ) . build ( ) ; final reader reader = new inputstreamreader ( instream = dbc . get ( uri ) , charsets . utf_8 ) ; final jsonarray jsonarray = new jsonparser ( ) . parse ( reader ) . getasjsonobject ( ) . getasjsonarray ( str_ ) ; final list < replicatordocument > list = new arraylist < replicatordocument > ( ) ; for ( jsonelement jsonelem : jsonarray ) { jsonelement elem = jsonelem . getasjsonobject ( ) . get ( str_ ) ; if ( ! getasstring ( elem . getasjsonobject ( ) , str_ ) . startswith ( str_ ) ) {	Finds all documents in the replicator database.
public response remove ( ) { assertnotempty ( replicatordoc . getid ( ) , str_ ) ; assertnotempty ( replicatordoc . getrevision ( ) , str_ ) ; final uri uri = builduri ( dburi ) . path ( replicatordoc . getid ( ) ) . query ( str_ , replicatordoc . getrevision ( ) ) . build ( ) ; return dbc . delete ( uri ) ; }	Removes a document from the replicator database.
public < t > t find ( class < t > classtype , string id , params params ) { assertnotempty ( classtype , str_ ) ; assertnotempty ( id , str_ ) ; final uri uri = builduri ( getdburi ( ) ) . pathencoded ( id ) . query ( params ) . build ( ) ; return get ( uri , classtype ) ; }	Finds an Object of the specified type.
public < t > list < t > finddocs ( string jsonquery , class < t > classoft ) { assertnotempty ( jsonquery , str_ ) ; httpresponse response = null ; try { response = post ( builduri ( getdburi ( ) ) . path ( str_ ) . build ( ) , jsonquery ) ; reader reader = new inputstreamreader ( getstream ( response ) , charsets . utf_8 ) ; jsonarray jsonarray = new jsonparser ( ) . parse ( reader ) . getasjsonobject ( ) . getasjsonarray ( str_ ) ; list < t > list = new arraylist < t > ( ) ; for ( jsonelement jsonelem : jsonarray ) { jsonelement elem = jsonelem . getasjsonobject ( ) ; t t = this . gson . fromjson ( elem , classoft ) ; list . add ( t ) ; } return list ; } finally { close ( response ) ; } }	Find documents using a declarative JSON querying syntax.
public boolean contains ( string id ) { assertnotempty ( id , str_ ) ; httpresponse response = null ; try { response = head ( builduri ( getdburi ( ) ) . pathencoded ( id ) . build ( ) ) ; } catch ( nodocumentexception e ) { return bool_ ; } finally { close ( response ) ; } return bool_ ; }	Checks if a document exist in the database.
public list < response > bulk ( list < ? > objects , boolean newedits ) { assertnotempty ( objects , str_ ) ; httpresponse response = null ; try { final string neweditsval = newedits ? str_ : str_ ; final string json = string . format ( str_ , neweditsval , str_ , getgson ( ) . tojson ( objects ) ) ; final uri uri = builduri ( getdburi ( ) ) . path ( str_ ) . build ( ) ; response = post ( uri , json ) ; return getresponselist ( response ) ; } finally { close ( response ) ; } }	Performs bulk documents create and update request.
response put ( uri uri , object object , boolean newentity ) { assertnotempty ( object , str_ ) ; httpresponse response = null ; try { final jsonobject json = getgson ( ) . tojsontree ( object ) . getasjsonobject ( ) ; string id = getasstring ( json , str_ ) ; string rev = getasstring ( json , str_ ) ; if ( newentity ) {	Performs a HTTP PUT request, saves or updates a document.
response put ( uri uri , inputstream instream , string contenttype ) { httpresponse response = null ; try { final httpput httpput = new httpput ( uri ) ; final inputstreamentity entity = new inputstreamentity ( instream , - num_ ) ; entity . setcontenttype ( contenttype ) ; httpput . setentity ( entity ) ; response = executerequest ( httpput ) ; return getresponse ( response ) ; } finally { close ( response ) ; } }	Performs a HTTP PUT request, saves an attachment.
httpresponse post ( uri uri , string json ) { httppost post = new httppost ( uri ) ; setentity ( post , json ) ; return executerequest ( post ) ; }	Performs a HTTP POST request.
response delete ( uri uri ) { httpresponse response = null ; try { httpdelete delete = new httpdelete ( uri ) ; response = executerequest ( delete ) ; return getresponse ( response ) ; } finally { close ( response ) ; } }	Performs a HTTP DELETE request.
void validate ( httpresponse response ) throws ioexception { final int code = response . getstatusline ( ) . getstatuscode ( ) ; if ( code == num_ || code == num_ || code == num_ ) {	Validates a HTTP response; on error cases logs status and throws relevant exceptions.
private void setentity ( httpentityenclosingrequestbase httprequest , string json ) { stringentity entity = new stringentity ( json , str_ ) ; entity . setcontenttype ( str_ ) ; httprequest . setentity ( entity ) ; }	Sets a JSON String as a request entity.
public void addattachment ( string name , attachment attachment ) { if ( attachments == null ) attachments = new hashmap < string , attachment > ( ) ; attachments . put ( name , attachment ) ; }	Adds an in-line document attachment.
public changesresult getchanges ( ) { final uri uri = uribuilder . query ( str_ , str_ ) . build ( ) ; return dbc . get ( uri , changesresult . class ) ; }	Requests Change notifications of feed type normal.
private boolean readnextrow ( ) { boolean hasnext = bool_ ; try { if ( ! stop ) { string row = str_ ; do { row = getreader ( ) . readline ( ) ; } while ( row . length ( ) == num_ ) ; if ( ! row . startswith ( str_ ) ) { setnextrow ( gson . fromjson ( row , row . class ) ) ; hasnext = bool_ ; } } } catch ( exception e ) { terminate ( ) ; throw new couchdbexception ( str_ , e ) ; } if ( ! hasnext ) terminate ( ) ; return hasnext ; }	Reads and sets the next feed in the stream.
public string convert ( double themoney ) { if ( themoney == null ) { throw new illegalargumentexception ( str_ ) ; } long intpart = themoney . longvalue ( ) ; long fractpart = math . round ( ( themoney - intpart ) * num100 ) ; if ( currency == currency . per1000 ) { fractpart = math . round ( ( themoney - intpart ) * num1000 ) ; } return convert ( intpart , fractpart ) ; }	Converts double value to the text description.
public void shutdown ( ) { try { locksexecutor . shutdown ( ) ; locksexecutor . awaittermination ( num_ , timeunit . seconds ) ; countdownlatch latch = new countdownlatch ( num_ ) ; activelockslock . writelock ( ) . lock ( ) ; observable . from ( activelocks . entryset ( ) ) . map ( map . entry :: getvalue ) . flatmap ( lock -> releaselock ( lock . getname ( ) , lock . getvalue ( ) ) . map ( released -> new lock ( lock . getname ( ) , lock . getvalue ( ) , lock . getexpiration ( ) , lock . getrenewalrate ( ) , ! released ) ) ) . subscribe ( lock -> { if ( lock . islocked ( ) ) { logger . infof ( str_ , lock . getname ( ) ) ; } } , t -> { logger . info ( str_ , t ) ; latch . countdown ( ) ; } , latch :: countdown ) ; latch . await ( ) ; logger . info ( str_ ) ; } catch ( interruptedexception e ) { logger . debug ( str_ ) ; } }	Attempt to release any locks on shutdown so that other clients can obtain those locks without having to waitfor them to expire.
public static observable < void > write ( final observable < byte [ ] > data , final servletoutputstream out ) { return observable . create ( new observable . onsubscribe < void > ( ) { @ override public void call ( subscriber < ? super void > subscriber ) { observable < void > events = create ( out ) . onbackpressurebuffer ( ) ; observable < void > writeobs = observable . zip ( data , events , ( b , avoid ) -> { try { out . write ( b ) ; } catch ( ioexception ioe ) { exceptions . propagate ( ioe ) ; } return null ; } ) ; writeobs . subscribe ( subscriber ) ; } } ) ; }	Writes the given Observable data to ServletOutputStream.
@ override public observable < void > addtags ( metric < ? > metric , map < string , string > tags ) { try { checkargument ( tags != null , str_ ) ; checkargument ( isvalidtagmap ( tags ) , str_ ) ; } catch ( exception e ) { return observable . error ( e ) ; } return dataaccess . insertintometricstagsindex ( metric , tags ) . concatwith ( dataaccess . addtags ( metric , tags ) ) . tolist ( ) . map ( l -> null ) ; }	functionality into a separate class.
public void verifyandcreatetemptables ( ) { zoneddatetime currentblock = zoneddatetime . ofinstant ( instant . ofepochmilli ( datetimeservice . now . get ( ) . getmillis ( ) ) , utc ) . with ( datetimeservice . startofpreviousevenhour ( ) ) ; zoneddatetime laststartupblock = currentblock . plus ( num_ , chronounit . hours ) ; verifyandcreatetemptables ( currentblock , laststartupblock ) . await ( ) ; }	Intended to be used at the startup of the MetricsServiceImpl to ensure we have enough tables for processing.
public string getnamespaceid ( string namespacename ) { return namespaces . computeifabsent ( namespacename , n -> getprojectid ( namespacename , token ) ) ; }	Returns the namespace id for a particular namespace name.
private boolean isquery ( httpserverexchange serverexchange ) { if ( serverexchange . getrequestmethod ( ) . tostring ( ) . equalsignorecase ( str_ ) || serverexchange . getrequestmethod ( ) . tostring ( ) . equalsignorecase ( str_ ) ) {	Returns if the request is a query request, eg to perform a READ.
private void sendauthenticationrequest ( httpserverexchange serverexchange , pooledconnection connection ) { authcontext context = serverexchange . getattachment ( auth_context_key ) ; string verb = getverb ( serverexchange ) ; string resource ;	Executed when a pooled connection is acquired.
private string getverb ( httpserverexchange serverexchange ) {	Determine the verb we should apply based on the HTTP method being requested.
private string generatesubjectaccessreview ( string namespace , string verb , string resource ) { objectnode objectnode = objectmapper . createobjectnode ( ) ; objectnode . put ( str_ , str_ ) ; objectnode . put ( str_ , kind ) ; objectnode . put ( str_ , resource ) ; objectnode . put ( str_ , verb ) ; objectnode . put ( str_ , namespace ) ; return objectnode . tostring ( ) ; }	Generates a SubjectAccessReview object used to request if a user has a certain permission or not.
private void onrequestresult ( httpserverexchange serverexchange , pooledconnection connection , boolean allowed ) { connectionpools . get ( serverexchange . getiothread ( ) ) . release ( connection ) ;	Called when the Kubernetes master server reponse has been inspected.
private void onrequestfailure ( httpserverexchange serverexchange , pooledconnection connection , ioexception e , boolean retry ) { log . debug ( str_ , e ) ; ioutils . safeclose ( connection ) ; connectionpool connectionpool = connectionpools . get ( serverexchange . getiothread ( ) ) ; connectionpool . release ( connection ) ; authcontext context = serverexchange . getattachment ( auth_context_key ) ; if ( context . retries < max_retry && retry ) { context . retries ++ ; pooledconnectionwaiter waiter = createwaiter ( serverexchange ) ; if ( ! connectionpool . offer ( waiter ) ) { endexchange ( serverexchange , internal_server_error , too_many_pending_requests ) ; } } else { endexchange ( serverexchange , internal_server_error , client_request_failure ) ; } }	Called if an exception occurs at any stage in the process.
public void init ( rxsession session ) { this . session = session ; findconfigurationgroup = session . getsession ( ) . prepare ( str_ ) . setconsistencylevel ( consistencylevel . local_quorum ) ; findconfigurationvalue = session . getsession ( ) . prepare ( str_ ) . setconsistencylevel ( consistencylevel . local_quorum ) ; updateconfigurationvalue = session . getsession ( ) . prepare ( str_ ) . setconsistencylevel ( consistencylevel . local_quorum ) ; deleteconfigurationvalue = session . getsession ( ) . prepare ( str_ ) . setconsistencylevel ( consistencylevel . local_quorum ) ; deleteconfiguration = session . getsession ( ) . prepare ( str_ ) . setconsistencylevel ( consistencylevel . local_quorum ) ; }	eventually I would like service initialization async.
public observable < jobdetails > findscheduledjobs ( date timeslice , rx . scheduler scheduler ) { return session . executeandfetch ( findallscheduled . bind ( ) , scheduler ) . filter ( filternulljobs ) . filter ( row -> row . gettimestamp ( num_ ) . compareto ( timeslice ) <= num_ ) . map ( row -> createjobdetails ( row . getuuid ( num_ ) , row . getstring ( num_ ) , row . getstring ( num_ ) , row . getmap ( num_ , string . class , string . class ) , gettrigger ( row . getudtvalue ( num_ ) ) , jobstatus . fromcode ( row . getbyte ( num_ ) ) , timeslice ) ) . collect ( hashmap :: new , ( map < uuid , sortedset < jobdetails > > map , jobdetails details ) -> { sortedset < jobdetails > set = map . get ( details . getjobid ( ) ) ; if ( set == null ) { set = new treeset < > ( ( jobdetails d1 , jobdetails d2 ) -> long . compare ( d1 . gettrigger ( ) . gettriggertime ( ) , d2 . gettrigger ( ) . gettriggertime ( ) ) ) ; } set . add ( details ) ; map . put ( details . getjobid ( ) , set ) ; } ) . flatmap ( map -> observable . from ( map . entryset ( ) ) ) . map ( entry -> entry . getvalue ( ) . first ( ) ) ; }	This method is currently unused.
public static < t extends bucketpoint > list < t > tolist ( map < long , t > pointmap , buckets buckets , bifunction < long , long , t > emptybucketfactory ) { list < t > result = new arraylist < > ( buckets . getcount ( ) ) ; for ( int index = num_ ; index < buckets . getcount ( ) ; index ++ ) { long from = buckets . getbucketstart ( index ) ; t bucketpoint = pointmap . get ( from ) ; if ( bucketpoint == null ) { long to = from + buckets . getstep ( ) ; bucketpoint = emptybucketfactory . apply ( from , to ) ; } result . add ( bucketpoint ) ; } return result ; }	Converts bucket points indexed by start time into a list, ordered by start time.
public static void endexchange ( httpserverexchange exchange , int statuscode , string reasonphrase ) { exchange . setstatuscode ( statuscode ) ; if ( reasonphrase != null ) { exchange . setreasonphrase ( reasonphrase ) ; } exchange . endexchange ( ) ; }	Changes the status code of the response, sets the HTTP reason phrase and ends the exchange.
@ override public observable < observable < row > > findalldatafrombucket ( long timestamp , int pagesize , int maxconcurrency ) { preparedstatement ts = gettempstatement ( metrictype . undefined , tempstatement . scan_with_token_ranges , timestamp ) ;	Fetch all the data from a temporary table for the compression job.
public static buckets fromstep ( long start , long end , long step ) { checktimerange ( start , end ) ; checkargument ( step > num_ , str_ , step ) ; if ( step > ( end - start ) ) { return new buckets ( start , step , num_ ) ; } long quotient = ( end - start ) / step ; long remainder = ( end - start ) % step ; long count ; if ( remainder == num_ ) { count = quotient ; } else { count = quotient + num_ ; } checkargument ( count <= integer . max_value , str_ , count ) ; return new buckets ( start , step , ( int ) count ) ; }	Force bucket step.
public boolean sendmsg ( message msg ) { sendresult sendresult = null ; try { sendresult = producer . send ( msg ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } return sendresult != null && sendresult . getsendstatus ( ) == sendstatus . send_ok ; }	send msg.
public void sendonewaymsg ( message msg ) { try { producer . sendoneway ( msg ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } }	sene one way msg.
public boolean senddelaymsg ( string topic , string tag , message msg , int delaylevel ) { msg . setdelaytimelevel ( delaylevel ) ; sendresult sendresult = null ; try { sendresult = producer . send ( msg ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } return sendresult != null && sendresult . getsendstatus ( ) == sendstatus . send_ok ; }	send delay msg.
@ override public scanresult < string > scan ( string cursor , scanparams params ) {	In this simple proposal, we're not testing complex iterationsof scan cursor.
public string add ( file file , boolean preserveexternalfilename ) { file existingfile = checkfileexists ( file ) ; string result = zippathfor ( existingfile , preserveexternalfilename ) ; entries . put ( existingfile , result ) ; return result ; }	Add a file to the ZIP.
public void replace ( file file , boolean preserveexternalfilename , string text ) { string path = entries . containskey ( file ) ? entries . remove ( file ) : zippathfor ( file , preserveexternalfilename ) ; entries . put ( text , path ) ; }	Replace the contents of a file with a different text.
public file build ( ) throws ioexception { if ( entries . isempty ( ) ) { throw new emptyzipexception ( ) ; } string filename = str_ + system . currenttimemillis ( ) + str_ ; file result = new file ( temp_dir . tofile ( ) , filename ) ; try ( zipoutputstream zip = new zipoutputstream ( files . newoutputstream ( result . topath ( ) , standardopenoption . create_new ) ) ) { customization . init ( entries . values ( ) , this :: streamfor ) ; for ( entry < object , string > entry : entries . entryset ( ) ) { try ( inputstream input = toinputstream ( entry . getkey ( ) ) ) { addentry ( extrazipentry . of ( entry . getvalue ( ) , customization . customize ( entry . getvalue ( ) , input ) ) , zip ) ; } } customization . extraentries ( ) . foreach ( entry -> addentry ( entry , zip ) ) ; zip . closeentry ( ) ; } return result ; }	Build a ZIP file containing the added entries.
public metrics generate ( c component , databuffer product ) throws ioexception { return generate ( collections . singletonlist ( component ) , product ) ; }	Generate a product from a single piece.
@ override @ deprecated public contentresult fetchcontent ( string contentid ) throws ioexception { try { string contentresource = resourcecache . getciresourceuri ( ) ; uribuilder builder = new uribuilder ( contentresource ) ; builder . setparameter ( str_ , contentid ) ; uri uri = builder . build ( ) ; return restclient . get ( uri . tostring ( ) , contentresultfactory ) ; } catch ( urisyntaxexception e ) { throw new illegalstateexception ( str_ , e ) ; } }	Fetch the content for the specified content id.
@ override @ deprecated public contentresult fetchordercontent ( orderitem orderitem ) throws ioexception { string downloaduri = objects . requirenonnull ( objects . requirenonnull ( orderitem , str_ ) . geturi ( link_download ) , str_ ) ; string fetchuri = restclient . uri ( downloaduri ) . addparameter ( str_ , str_ ) . build ( ) ; return restclient . get ( fetchuri , contentresultfactory ) ; }	Fetch the content for the specified order item.
@ override @ deprecated public linkcontainer uploadtransformation ( exporttransformation exporttransformation , inputstream zip ) throws ioexception { string uri = exporttransformation . geturi ( link_export_transformation_zip ) ; return restclient . post ( uri , linkcontainer . class , new binarypart ( str_ , zip , str_ ) ) ; }	Upload the transformation zip with the stylesheet into Archive.
public filegenerationmetrics generate ( iterator < c > components ) throws ioexception { file result = filesupplier . get ( ) ; return new filegenerationmetrics ( result , generate ( components , new filebuffer ( result ) ) ) ; }	Generate a file by assembling components.
public static file in ( file parentdir ) { file result = new file ( parentdir , uuid . randomuuid ( ) . tostring ( ) ) ; if ( ! result . mkdirs ( ) ) { throw new runtimeioexception ( new ioexception ( str_ + result ) ) ; } return result ; }	Create a new directory in the given parent directory.
public p end ( ) { parent . addchildobject ( english . plural ( object . gettype ( ) ) , object ) ; return parent ; }	End this builder.
protected < s > void registeradaptor ( stgroup group , class < s > type , modeladaptor adaptor ) { group . registermodeladaptor ( type , adaptor ) ; }	Registers a ModelAdaptor with the group.
protected < s > void registerrenderer ( stgroup group , class < s > type , attributerenderer attributerenderer ) { group . registerrenderer ( type , attributerenderer ) ; }	Registers a renderer with the group.
protected st preparetemplate ( st prototype , d domainobject , map < string , contentinfo > contentinfo ) { st template = new st ( prototype ) ; template . add ( model_variable , domainobject ) ; template . add ( content_variable , contentinfo ) ; return template ; }	Prepares the template by adding the variables.
public synchronized void add ( d domainobject ) throws ioexception { if ( shouldstartnewsip ( domainobject ) ) { startsip ( ) ; } assembler . add ( domainobject ) ; }	Add a domain object to the batch of SIPs.
public void setproperty ( string name , object value ) { properties . put ( name , tojsonvalue ( value ) ) ; }	Set the value of a property.
public void addchildobject ( string collection , configurationobject childobject ) { childobjects . computeifabsent ( collection , ignored -> new arraylist < > ( ) ) . add ( childobject ) ; }	Add an object that is to be owned by this object.
public static supplier < file > fromdirectory ( file dir , string prefix , string suffix ) { return new supplier < file > ( ) { private int count ; @ override public file get ( ) { return new file ( ensuredir ( dir ) , string . format ( str_ , prefix , ++ count , suffix ) ) ; } } ; }	Returns a supplier that creates sequentially named files in the given directory.
public static void copy ( inputstream in , outputstream out , int buffersize , hashassembler hashassembler ) throws ioexception { byte [ ] buffer = new byte [ buffersize ] ; int numread = objects . requirenonnull ( in , str_ ) . read ( buffer ) ; if ( numread == num_ ) { throw new illegalargumentexception ( str_ ) ; } objects . requirenonnull ( out , str_ ) ; while ( numread > num_ ) { out . write ( buffer , num_ , numread ) ; hashassembler . add ( buffer , numread ) ; numread = in . read ( buffer ) ; } }	Utility method to copy the bytes from an InputStream to an OutputStream while also assembling a hash value in theprocess.
public static document parse ( file file ) { if ( ! file . isfile ( ) ) { throw new illegalargumentexception ( str_ + file . getabsolutepath ( ) ) ; } try { try ( inputstream stream = files . newinputstream ( file . topath ( ) , standardopenoption . read ) ) { return parse ( stream ) ; } } catch ( ioexception e ) { throw new illegalargumentexception ( str_ + file . getabsolutepath ( ) , e ) ; } }	Parse the content of a given file into an XML document.
public static document parse ( reader reader ) { documentbuilder documentbuilder = getdocumentbuilder ( ) ; try { return documentbuilder . parse ( new inputsource ( reader ) ) ; } catch ( saxexception | ioexception e ) { throw new illegalargumentexception ( str_ , e ) ; } finally { documentbuilder . reset ( ) ; } }	Parse the content of a given reader into an XML document.
public static stream < element > elementsin ( element parent ) { return nodesin ( parent ) . filter ( n -> n . getnodetype ( ) == node . element_node ) . map ( n -> ( element ) n ) ; }	Return the elements under a given parent element.
public static stream < node > nodesin ( element parent ) { return streamsupport . stream ( new childnodesspliterator ( parent ) , bool_ ) ; }	Return the nodes under a given parent element.
public static element getfirstchildelement ( element parent , string ... childnames ) { return firstof ( namedelementsin ( parent , childnames ) ) ; }	Return the first child element of a given parent element whose tag matches any of the given names.
public static stream < element > namedelementsin ( element parent , string ... childnames ) { return elementsin ( parent ) . filter ( e -> isname ( e , childnames ) ) ; }	Return the elements under a given parent element whose tag matches any of the given names.
public static void validate ( inputstream xml , inputstream xmlschema , string humanfriendlydocumenttype ) throws ioexception { try { newxmlschemavalidator ( xmlschema ) . validate ( new streamsource ( objects . requirenonnull ( xml ) ) ) ; } catch ( saxexception e ) { throw new validationexception ( str_ + humanfriendlydocumenttype , e ) ; } }	Validate an XML document against an XML Schema document.
public static void main ( string [ ] args ) { try { arguments arguments = new arguments ( args ) ; file root = new file ( arguments . next ( str_ ) ) ; if ( ! root . isdirectory ( ) ) { root = new file ( str_ ) ; } string rootpath = root . getcanonicalpath ( ) ; string sip = arguments . next ( str_ ) ; new filearchiver ( ) . run ( rootpath , sip ) ; } catch ( ioexception e ) { e . printstacktrace ( system . out ) ; system . exit ( num_ ) ; } }	Build a SIP archive from all files in a given directory tree.
public contentbuilder < p > as ( inputstream content ) { try { return as ( ioutils . tostring ( content , standardcharsets . utf_8 ) ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( str_ , e ) ; } }	Sets the content.
public contentbuilder < p > fromresource ( string name ) { try ( inputstream content = contentbuilder . class . getresourceasstream ( name ) ) { return as ( content ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( str_ + name , e ) ; } }	Sets the content from a named resource.
public < t > t andprocessentry ( string entry , function < inputstream , t > processor ) { try ( zipfile zipfile = new zipfile ( zip ) ) { return processentry ( zipfile , entry , processor ) ; } catch ( ioexception e ) { throw new runtimeioexception ( e ) ; } }	Process a named entry in the ZIP file.
public static string asciicharactersencoding ( string str ) throws qsexception { if ( qsstringutil . isempty ( str ) ) { return str_ ; } try { string encoded = urlencoder . encode ( str , qsconstant . encoding_utf8 ) ; encoded = encoded . replace ( str_ , str_ ) ; encoded = encoded . replace ( str_ , str_ ) ; encoded = encoded . replace ( str_ , str_ ) ; encoded = encoded . replace ( str_ , str_ ) ; return encoded ; } catch ( unsupportedencodingexception e ) { throw new qsexception ( str_ , e ) ; } }	Chinese characters transform.
public void setsignature ( string accesskey , string signature , string gmttime ) throws qsexception { builder . setheader ( qsconstant . header_param_key_date , gmttime ) ; setsignature ( accesskey , signature ) ; }	Set signature and server time.
private static int removewhitespace ( char [ ] data ) { if ( data == null ) { return num_ ; }	remove WhiteSpace from MIME containing encoded Base64 data.
private void sign ( requesthandler requesthandler ) throws qsexception { if ( callback != null ) { string signed = callback . onsignature ( requesthandler . getstringtosignature ( ) ) ; if ( ! qsstringutil . isempty ( signed ) ) requesthandler . setsignature ( callback . onaccesskey ( ) , signed ) ; string correcttime = callback . oncorrecttime ( requesthandler . getstringtosignature ( ) ) ; if ( correcttime != null && correcttime . trim ( ) . length ( ) > num_ ) requesthandler . getbuilder ( ) . setheader ( qsconstant . header_param_key_date , correcttime ) ; } }	When sending a request will call this method to sign with server.
private void setdata ( string objectkey , recorder recorder ) { if ( recorder == null ) return ; string upload = new gson ( ) . tojson ( uploadmodel ) ; recorder . set ( objectkey , upload . getbytes ( ) ) ; }	Set data in the upload with a recorder.
private void completemultiupload ( string objectkey , string filename , string etag , string uploadid , long length ) throws qsexception { completemultipartuploadinput completemultipartuploadinput = new completemultipartuploadinput ( uploadid , partcounts , num_ ) ; completemultipartuploadinput . setcontentlength ( length ) ;	Complete the multi upload.
@ override public void invoke ( final actionrequest req , final actionresponse res ) throws ioexception { final notificationentry entry = gettarget ( ) ; final string notificationid = entry . getid ( ) ; final set < string > favoritenotices = this . getfavoritenotices ( req ) ; if ( favoritenotices . contains ( notificationid ) ) { favoritenotices . remove ( notificationid ) ; } else { favoritenotices . add ( notificationid ) ; } setfavoritenotices ( req , favoritenotices ) ; }	Invoking a FavoriteAction toggles it.
public void addentrystate ( portletrequest req , string entryid , notificationstate state ) { if ( usernamefinder . isauthenticated ( req ) ) { final string username = usernamefinder . findusername ( req ) ; string idstr = entryid . replaceall ( id_prefix , str_ ) ;	Caller must insure that the state being set has not already been added to the entryto avoid multiple events with the same state.
public boolean hasexpired ( ) { long now = system . currenttimemillis ( ) ; if ( created + ( expiresin * num_ ) + timeout_buffer > now ) { return bool_ ; } return bool_ ; }	Helper method to determine if an SSPToken has expired.
@ requestmapping ( value = str_ , method = requestmethod . get ) @ responsebody public entrydto getnotification ( httpservletresponse response , @ pathvariable ( str_ ) long id , @ requestparam ( value = str_ , required = bool_ , defaultvalue = str_ ) boolean full ) { entrydto notification = restservice . getnotification ( id , full ) ; if ( notification == null ) { response . setstatus ( httpstatus . not_found . value ( ) ) ; return null ; } return notification ; }	Get 1 notification by id.
@ requestmapping ( value = str_ , method = requestmethod . get ) @ responsebody public set < addresseedto > getaddressees ( @ pathvariable ( str_ ) long id ) { return restservice . getaddressees ( id ) ; }	Get the set of addressees for a notification.
@ requestmapping ( value = str_ , method = requestmethod . get ) @ responsebody public addresseedto getaddressee ( httpservletresponse resp , @ pathvariable ( str_ ) long notificationid , @ pathvariable ( str_ ) long addresseeid ) { addresseedto dto = restservice . getaddressee ( addresseeid ) ; if ( dto == null ) { resp . setstatus ( httpstatus . not_found . value ( ) ) ; return null ; } return dto ; }	Get a specific addressee.
@ requestmapping ( value = str_ , method = requestmethod . get ) @ responsebody public list < eventdto > geteventsbynotification ( @ pathvariable ( str_ ) long id ) { return restservice . geteventsbynotification ( id ) ; }	Get the list of events for a notification.
@ requestmapping ( value = str_ , method = requestmethod . get ) @ responsebody public eventdto getevent ( httpservletresponse response , @ pathvariable ( str_ ) long notificationid , @ pathvariable ( str_ ) long eventid ) { eventdto event = restservice . getevent ( eventid ) ; if ( event == null ) { response . setstatus ( httpstatus . not_found . value ( ) ) ; return null ; } return event ; }	Get a specific event.
private string getsinglenotificationresturl ( httpservletrequest request , long id ) { string path = request . getcontextpath ( ) + request_root + id ; try { url url = new url ( request . getscheme ( ) , request . getservername ( ) , request . getserverport ( ) , path ) ; return url . toexternalform ( ) ; } catch ( malformedurlexception e ) {	Build the URL for a specific notification.
@ override @ transactional ( readonly = bool_ ) public jpaentry getentry ( long entryid ) { validate . istrue ( entryid > num_ , str_ + entryid ) ; jpaentry rslt = entitymanager . find ( jpaentry . class , entryid ) ; return rslt ; }	Search for a JpaEntry with the specified Id.
private synchronized ssptoken getauthenticationtoken ( boolean forceupdate ) throws malformedurlexception , restclientexception { if ( authenticationtoken != null && ! authenticationtoken . hasexpired ( ) && ! forceupdate ) { return authenticationtoken ; } string authstring = getclientid ( ) + str_ + getclientsecret ( ) ; string authentication = new base64 ( ) . encodetostring ( authstring . getbytes ( ) ) ; httpheaders headers = new httpheaders ( ) ; headers . add ( authorization , basic + str_ + authentication ) ;	Get the authentication token to use.
@ jsonignore @ xmltransient public int size ( ) { return categories . stream ( ) . map ( notificationcategory :: getentries ) . maptoint ( list :: size ) . sum ( ) ; }	Provides the total number of notifications contained in the response.
private void addcategories ( list < notificationcategory > newcategories ) { if ( newcategories == null ) { return ; }	Insert the given categories and their entries into the any existingcategories of the same title.
@ override public notificationresponse fetch ( portletrequest req ) { portletpreferences preferences = req . getpreferences ( ) ; string enabled = preferences . getvalue ( ssp_notifications_enabled , str_ ) ; if ( ! str_ . equalsignorecase ( enabled ) ) { return new notificationresponse ( ) ; } string personid = getpersonid ( req ) ; if ( personid == null ) {	Fetch the set of SSP tasks for the uPortal user.
private notificationresponse notificationerror ( string errormsg ) { notificationerror error = new notificationerror ( ) ; error . seterror ( errormsg ) ; error . setsource ( getclass ( ) . getsimplename ( ) ) ; notificationresponse notification = new notificationresponse ( ) ; notification . seterrors ( arrays . aslist ( error ) ) ; return notification ; }	Error handler.
private notificationresponse maptonotificationresponse ( portletrequest request , responseentity < string > response ) { configuration config = configuration . builder ( ) . options ( option . default_path_leaf_to_null ) . build ( ) ; readcontext readcontext = jsonpath . using ( config ) . parse ( response . getbody ( ) ) ;	Map and SSP Response to a NotificationResponse.
private notificationentry mapnotificationentry ( readcontext readcontext , int index , string source ) { boolean completed = readcontext . read ( format ( row_completed_query_fmt , index ) , boolean . class ) ; if ( completed ) { return null ; } notificationentry entry = new notificationentry ( ) ; entry . setsource ( source ) ; string id = readcontext . read ( format ( row_id_query_fmt , index ) ) ; entry . setid ( id ) ; string title = readcontext . read ( format ( row_name_query_fmt , index ) ) ; entry . settitle ( title ) ; string desc = readcontext . read ( format ( row_description_query_fmt , index ) ) ; entry . setbody ( desc ) ; string link = readcontext . read ( format ( row_link_query_fmt , index ) ) ; url fixedlink = normalizelink ( link ) ; if ( fixedlink != null ) { entry . seturl ( fixedlink . toexternalform ( ) ) ; } date createdate = readcontext . read ( format ( str_ , index ) , date . class ) ; map < notificationstate , date > states = new hashmap < > ( ) ; states . put ( notificationstate . issued , createdate ) ; try {	Map a single notification entry.
private void attachactions ( portletrequest request , notificationentry entry ) { portletpreferences prefs = request . getpreferences ( ) ; string stringval = prefs . getvalue ( ssp_notifications_enable_mark_completed , str_ ) ; boolean enablemarkcompleted = ( str_ . equalsignorecase ( stringval ) ) ; list < notificationaction > actions = new arraylist < > ( ) ; if ( enablemarkcompleted ) { marktaskcompletedaction action = new marktaskcompletedaction ( entry . getid ( ) ) ; actions . add ( action ) ; } entry . setavailableactions ( actions ) ; }	Attach any SSP specific actions to this entry, if enabled.
private url normalizelink ( string link ) { try { if ( stringutils . isempty ( link ) ) { return null ; } if ( link . startswith ( str_ ) ) { return sspapi . getsspurl ( link , bool_ ) ; } if ( link . startswith ( str_ ) || link . startswith ( str_ ) ) { return new url ( link ) ; }	Some of the links I have seen from SSP are not well formed.
private notificationcategory getnotificationcategory ( portletrequest request ) { portletpreferences preferences = request . getpreferences ( ) ; string title = preferences . getvalue ( notification_category_pref , default_category ) ; notificationcategory category = new notificationcategory ( ) ; category . settitle ( title ) ; return category ; }	Get the category name to use for SSP notifications.
private string getnotificationsource ( portletrequest req ) { portletpreferences preferences = req . getpreferences ( ) ; string source = preferences . getvalue ( notification_source_pref , default_notification_source ) ; return source ; }	Get the source value to use for a Notification entry.
@ override public void invoke ( final actionrequest req , final actionresponse res ) throws ioexception { final notificationentry entry = gettarget ( ) ; final string notificationid = entry . getid ( ) ; final set < string > readnotices = this . getreadnotices ( req ) ; if ( readnotices . contains ( notificationid ) ) { readnotices . remove ( notificationid ) ; } else { readnotices . add ( notificationid ) ; } setreadnotices ( req , readnotices ) ; }	Invoking a ReadAction toggles it.
private notificationresponse readfromfile ( string filename ) { notificationresponse rslt ; logger . debug ( str_ , filename ) ; url location = getclass ( ) . getclassloader ( ) . getresource ( filename ) ; if ( location != null ) { try { file f = new file ( location . touri ( ) ) ; rslt = mapper . readvalue ( f , notificationresponse . class ) ; } catch ( exception e ) { string msg = str_ + location ; logger . error ( msg , e ) ; rslt = prepareerrorresponse ( getname ( ) , msg ) ; } } else { string msg = str_ + filename ; rslt = prepareerrorresponse ( getname ( ) , msg ) ; } return rslt ; }	Deserialize the given JSON formatted file back into a object.
private string getschoolid ( portletrequest request ) { portletpreferences prefs = request . getpreferences ( ) ; string schoolidattributename = prefs . getvalue ( str_ , str_ ) ; map < string , string > userinfo = ( map < string , string > ) request . getattribute ( portletrequest . user_info ) ; string studentid = userinfo . get ( schoolidattributename ) ; if ( ! stringutils . isempty ( studentid ) ) { return studentid ; }	Get the schoolId value from the request.
private string extractuserid ( string studentid , responseentity < string > response ) { configuration config = configuration . builder ( ) . options ( option . default_path_leaf_to_null ) . build ( ) ; readcontext readcontext = jsonpath . using ( config ) . parse ( response . getbody ( ) ) ; string success = readcontext . read ( success_query ) ;	Parse the person lookup response from SSP.
@ override public void invoke ( final actionrequest req , final actionresponse res ) throws ioexception { final notificationentry entry = gettarget ( ) ; if ( ! isentrysnoozed ( entry , req ) ) {	Invoking a HideAction toggles it.
@ jsonignore public map < string , list < string > > getattributesmap ( ) { map < string , list < string > > rslt = new hashmap < > ( ) ; for ( notificationattribute a : attributes ) { rslt . put ( a . getname ( ) , a . getvalues ( ) ) ; } return rslt ; }	Convenience method for obtaining the attributes in a more usable collection.
public static void normalize ( geotuple3d_f64 p ) { double n = p . norm ( ) ; p . x /= n ; p . y /= n ; p . z /= n ; }	Normalizes the point such that the Frobenius norm is 1.
public static boolean contained ( box3d_i32 boxa , box3d_i32 boxb ) { return ( boxa . p0 . x <= boxb . p0 . x && boxa . p1 . x >= boxb . p1 . x && boxa . p0 . y <= boxb . p0 . y && boxa . p1 . y >= boxb . p1 . y && boxa . p0 . z <= boxb . p0 . z && boxa . p1 . z >= boxb . p1 . z ) ; }	Returns true if boxB is contained inside of or is identical to boxA.
public void closestpoint ( point3d_f64 p , point3d_f64 closestpt ) {	Find the closest point on the triangle to P.
public double sign ( point3d_f64 p ) { geometrymath_f64 . cross ( e1 , e0 , n ) ;	Returns the signed of the vector.
public void set ( se3_f64 se ) { r . set ( se . getr ( ) ) ; t . set ( se . gett ( ) ) ; }	Set's 'this' Se3_F64 to be identical to the provided transform.
public void set ( double x , double y , double z , eulertype type , double rota , double rotb , double rotc ) { t . set ( x , y , z ) ; convertrotation3d_f64 . eulertomatrix ( type , rota , rotb , rotc , r ) ; }	Fully specify the transform using Euler angles.
public static void convert ( rectangle2d_f64 input , polygon2d_f64 output ) { if ( output . size ( ) != num_ ) throw new illegalargumentexception ( str_ ) ; output . get ( num_ ) . set ( input . p0 . x , input . p0 . y ) ; output . get ( num_ ) . set ( input . p1 . x , input . p0 . y ) ; output . get ( num_ ) . set ( input . p1 . x , input . p1 . y ) ; output . get ( num_ ) . set ( input . p0 . x , input . p1 . y ) ; }	Converts a rectangle into a polygon.
public static void convert ( polygon2d_f64 input , quadrilateral_f64 output ) { if ( input . size ( ) != num_ ) throw new illegalargumentexception ( str_ ) ; output . a . set ( input . get ( num_ ) ) ; output . b . set ( input . get ( num_ ) ) ; output . c . set ( input . get ( num_ ) ) ; output . d . set ( input . get ( num_ ) ) ; }	Converts a polygon into a quadrilateral.
public static void bounding ( quadrilateral_f64 quad , rectangle2d_f64 rectangle ) { rectangle . p0 . x = math . min ( quad . a . x , quad . b . x ) ; rectangle . p0 . x = math . min ( rectangle . p0 . x , quad . c . x ) ; rectangle . p0 . x = math . min ( rectangle . p0 . x , quad . d . x ) ; rectangle . p0 . y = math . min ( quad . a . y , quad . b . y ) ; rectangle . p0 . y = math . min ( rectangle . p0 . y , quad . c . y ) ; rectangle . p0 . y = math . min ( rectangle . p0 . y , quad . d . y ) ; rectangle . p1 . x = math . max ( quad . a . x , quad . b . x ) ; rectangle . p1 . x = math . max ( rectangle . p1 . x , quad . c . x ) ; rectangle . p1 . x = math . max ( rectangle . p1 . x , quad . d . x ) ; rectangle . p1 . y = math . max ( quad . a . y , quad . b . y ) ; rectangle . p1 . y = math . max ( rectangle . p1 . y , quad . c . y ) ; rectangle . p1 . y = math . max ( rectangle . p1 . y , quad . d . y ) ; }	Finds the minimum area bounding rectangle around the quadrilateral.
public static void bounding ( polygon2d_f64 polygon , rectangle2d_f64 rectangle ) { rectangle . p0 . set ( polygon . get ( num_ ) ) ; rectangle . p1 . set ( polygon . get ( num_ ) ) ; for ( int i = num_ ; i < polygon . size ( ) ; i ++ ) { point2d_f64 p = polygon . get ( i ) ; if ( p . x < rectangle . p0 . x ) { rectangle . p0 . x = p . x ; } else if ( p . x > rectangle . p1 . x ) { rectangle . p1 . x = p . x ; } if ( p . y < rectangle . p0 . y ) { rectangle . p0 . y = p . y ; } else if ( p . y > rectangle . p1 . y ) { rectangle . p1 . y = p . y ; } } }	Finds the minimum area bounding rectangle around the quadrilateral that is aligned with coordinatesystem axises.
public static point2d_f64 center ( quadrilateral_f64 quad , point2d_f64 center ) { if ( center == null ) center = new point2d_f64 ( ) ; center . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; center . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; center . x /= num_ ; center . y /= num_ ; return center ; }	Computes the center or average point in the quadrilateral.
public static void vertexaverage ( polygon2d_f64 input , point2d_f64 average ) { average . setidx ( num_ , num_ ) ; for ( int i = num_ ; i < input . size ( ) ; i ++ ) { point2d_f64 v = input . vertexes . data [ i ] ; average . x += v . x ; average . y += v . y ; } average . x /= input . size ( ) ; average . y /= input . size ( ) ; }	Computes the average of all the vertexes.
public static void convexhull ( list < point2d_f64 > points , polygon2d_f64 hull ) { point2d_f64 [ ] array = new point2d_f64 [ points . size ( ) ] ; for ( int i = num_ ; i < points . size ( ) ; i ++ ) { array [ i ] = points . get ( i ) ; } andrewmonotoneconvexhull_f64 andrew = new andrewmonotoneconvexhull_f64 ( ) ; andrew . process ( array , array . length , hull ) ; }	Computes the convex hull of the set of points.
public static void removealmostparallel ( polygon2d_f64 polygon , double tol ) { for ( int i = num_ ; i < polygon . vertexes . size ( ) ; ) { int j = ( i + num_ ) % polygon . vertexes . size ( ) ; int k = ( i + num_ ) % polygon . vertexes . size ( ) ; point2d_f64 p0 = polygon . vertexes . get ( i ) ; point2d_f64 p1 = polygon . vertexes . get ( j ) ; point2d_f64 p2 = polygon . vertexes . get ( k ) ; double angle = utilvector2d_f64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; if ( angle <= tol ) { polygon . vertexes . remove ( j ) ; if ( j < i ) i = polygon . vertexes . size ( ) - num_ ; } else { i ++ ; } } }	Removes a node from a polygon if the two lines its attached two are almost parallel.
public static double averageofclosestpointerror ( polygon2d_f64 model , polygon2d_f64 target , int numberofsamples ) { linesegment2d_f64 line = new linesegment2d_f64 ( ) ; double cornerlocationsb [ ] = new double [ target . size ( ) + num_ ] ; double totallength = num_ ; for ( int i = num_ ; i < target . size ( ) ; i ++ ) { point2d_f64 b0 = target . get ( i % target . size ( ) ) ; point2d_f64 b1 = target . get ( ( i + num_ ) % target . size ( ) ) ; cornerlocationsb [ i ] = totallength ; totallength += b0 . distance ( b1 ) ; } cornerlocationsb [ target . size ( ) ] = totallength ; point2d_f64 pointonb = new point2d_f64 ( ) ; double error = num_ ; int cornerb = num_ ; for ( int k = num_ ; k < numberofsamples ; k ++ ) {	Compute the error as a function of the distance between the model and target.
public double computearea ( polygon2d_f64 a , polygon2d_f64 b ) { ssss = num_ ; sclx = num_ ; scly = num_ ; return inter ( a , b ) ; }	Computes the area of the intersection between the two polygons.Note: the area result has little more accuracy than a floatThis is true even if the polygon is specified with doubles.
public static boolean contains ( quadrilateral_f64 quad , point2d_f64 pt ) { return containtriangle ( quad . a , quad . b , quad . d , pt ) || containtriangle ( quad . b , quad . c , quad . d , pt ) ; }	True if the point is contained inside the quadrilateral.
public static boolean containtriangle ( point2d_f64 a , point2d_f64 b , point2d_f64 c , point2d_f64 pt ) { boolean ret = bool_ ; if ( ( ( a . y > pt . y ) != ( b . y > pt . y ) ) && ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ) ret = bool_ ; if ( ( ( b . y > pt . y ) != ( c . y > pt . y ) ) && ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ) ret = ! ret ; if ( ( ( c . y > pt . y ) != ( a . y > pt . y ) ) && ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ) ret = ! ret ; return ret ; }	Returns true of the the point is inside the triangle.This function is simply an unrolled version of {.
public static point2d_f64 intersection ( lineparametric2d_f64 a , lineparametric2d_f64 b , point2d_f64 ret ) { double t_b = a . getslopex ( ) * ( b . gety ( ) - a . gety ( ) ) - a . getslopey ( ) * ( b . getx ( ) - a . getx ( ) ) ; double bottom = a . getslopey ( ) * b . getslopex ( ) - b . getslopey ( ) * a . getslopex ( ) ; if ( bottom == num_ ) return null ; t_b /= bottom ; double x = b . getslopex ( ) * t_b + b . getx ( ) ; double y = b . getslopey ( ) * t_b + b . gety ( ) ; if ( ret == null ) ret = new point2d_f64 ( ) ; ret . set ( x , y ) ; return ret ; }	Finds the point of intersection between two lines and returns the point.
public static point2d_f64 intersection ( linesegment2d_f64 l_0 , linesegment2d_f64 l_1 , point2d_f64 ret ) { double a0 = l_0 . b . x - l_0 . a . x ; double b0 = l_0 . b . y - l_0 . a . y ; double a1 = l_1 . b . x - l_1 . a . x ; double b1 = l_1 . b . y - l_1 . a . y ; double top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; double bottom = a0 * b1 - b0 * a1 ; if ( bottom == num_ ) return null ; double t_1 = top / bottom ;	Finds the point of intersection between two lines segments.
public static point2d_f64 intersection ( point2d_f64 linea0 , point2d_f64 linea1 , point2d_f64 lineb0 , point2d_f64 lineb1 , point2d_f64 output ) { if ( output == null ) output = new point2d_f64 ( ) ; double slopeax = linea1 . x - linea0 . x ; double slopeay = linea1 . y - linea0 . y ; double slopebx = lineb1 . x - lineb0 . x ; double slopeby = lineb1 . y - lineb0 . y ; double top = slopeay * ( lineb0 . x - linea0 . x ) + slopeax * ( linea0 . y - lineb0 . y ) ; double bottom = slopeax * slopeby - slopeay * slopebx ; if ( bottom == num_ ) return null ; double t = top / bottom ; output . x = lineb0 . x + t * slopebx ; output . y = lineb0 . y + t * slopeby ; return output ; }	Finds the point of intersection between the two lines defined by the set sets of points passed in.
public static double intersection ( lineparametric2d_f64 target , linesegment2d_f64 l ) { double a1 = l . b . x - l . a . x ; double b1 = l . b . y - l . a . y ; double top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; double bottom = target . slope . x * b1 - target . slope . y * a1 ; if ( bottom == num_ ) return double . nan ; double t_1 = top / bottom ;	Finds the point of intersection between a line and a line segment.
public static double intersection ( polygon2d_f64 a , polygon2d_f64 b ) { areaintersectionpolygon2d_f64 alg = new areaintersectionpolygon2d_f64 ( ) ; return math . abs ( alg . computearea ( a , b ) ) ; }	Finds the area of the intersection of two polygons.
public static boolean contains ( ellipserotated_f64 ellipse , double x , double y ) { return ( utilellipse_f64 . evaluate ( x , y , ellipse ) <= num_ ) ; }	Tests to see if the provided point lies on or is contained inside the ellipse.
public static double intersectionarea ( rectangle2d_f64 a , rectangle2d_f64 b ) { if ( ! intersects ( a , b ) ) return num_ ; double x0 = math . max ( a . p0 . x , b . p0 . x ) ; double x1 = math . min ( a . p1 . x , b . p1 . x ) ; double y0 = math . max ( a . p0 . y , b . p0 . y ) ; double y1 = math . min ( a . p1 . y , b . p1 . y ) ; return ( x1 - x0 ) * ( y1 - y0 ) ; }	Returns the area of the intersection of two rectangles.
private static double get ( dmatrixrmaj m , int index ) { if ( index < num_ ) { return - m . data [ - index - num_ ] ; } else { return m . data [ index - num_ ] ; } }	If the index is negative it returns the negative of the value at -index. Starts at 0.
public static quaternion_f64 matrixtoquaternion ( dmatrixrmaj r , quaternion_f64 quat ) { if ( quat == null ) quat = new quaternion_f64 ( ) ;	Extracts quaternions from the provided rotation matrix.
public static dmatrixrmaj rotx ( double ang , dmatrixrmaj r ) { if ( r == null ) r = new dmatrixrmaj ( num_ , num_ ) ; setrotx ( ang , r ) ; return r ; }	Creates a rotation matrix about the x-axis.
public static void setrotx ( double ang , dmatrixrmaj r ) { double c = math . cos ( ang ) ; double s = math . sin ( ang ) ; r . set ( num_ , num_ , num_ ) ; r . set ( num_ , num_ , c ) ; r . set ( num_ , num_ , - s ) ; r . set ( num_ , num_ , s ) ; r . set ( num_ , num_ , c ) ; }	Sets the values in the specified matrix to a rotation matrix about the x-axis.
public static dmatrixrmaj roty ( double ang , dmatrixrmaj r ) { r = checkdeclare3x3 ( r ) ; setroty ( ang , r ) ; return r ; }	Creates a rotation matrix about the y-axis.
public static dmatrixrmaj rotz ( double ang , dmatrixrmaj r ) { r = checkdeclare3x3 ( r ) ; setrotz ( ang , r ) ; return r ; }	Creates a rotation matrix about the z-axis.
public static void setrotz ( double ang , dmatrixrmaj r ) { double c = math . cos ( ang ) ; double s = math . sin ( ang ) ; r . set ( num_ , num_ , c ) ; r . set ( num_ , num_ , - s ) ; r . set ( num_ , num_ , s ) ; r . set ( num_ , num_ , c ) ; r . set ( num_ , num_ , num_ ) ; }	Sets the values in the specified matrix to a rotation matrix about the z-axis.
public static dmatrixrmaj eulertomatrix ( eulertype type , double rota , double rotb , double rotc , dmatrixrmaj r ) { r = checkdeclare3x3 ( r ) ; dmatrixrmaj r_a = rotationaboutaxis ( type . getaxisa ( ) , rota , null ) ; dmatrixrmaj r_b = rotationaboutaxis ( type . getaxisb ( ) , rotb , null ) ; dmatrixrmaj r_c = rotationaboutaxis ( type . getaxisc ( ) , rotc , null ) ; dmatrixrmaj a = new dmatrixrmaj ( num_ , num_ ) ; commonops_ddrm . mult ( r_b , r_a , a ) ; commonops_ddrm . mult ( r_c , a , r ) ; return r ; }	Converts an Euler coordinate into a rotation matrix.
private static dmatrixrmaj rotationaboutaxis ( int axis , double angle , dmatrixrmaj r ) { switch ( axis ) { case num_ : return convertrotation3d_f64 . rotx ( angle , r ) ; case num_ : return convertrotation3d_f64 . roty ( angle , r ) ; case num_ : return convertrotation3d_f64 . rotz ( angle , r ) ; default : throw new illegalargumentexception ( str_ ) ; } }	Creates a rotation matrix about the specified axis.
public void setangle ( double angle ) { slope . set ( math . cos ( angle ) , math . sin ( angle ) ) ; }	Sets the slope to the unit vector specified by the provided angle.
public static twistcoordinate_f64 twist ( se3_f64 motion , twistcoordinate_f64 twist ) { if ( twist == null ) twist = new twistcoordinate_f64 ( ) ; if ( matrixfeatures_ddrm . isidentity ( motion . r , grlconstants . test_f64 ) ) { twist . w . set ( num_ , num_ , num_ ) ; twist . v . set ( motion . t ) ; } else { rodrigues_f64 rod = new rodrigues_f64 ( ) ; convertrotation3d_f64 . matrixtorodrigues ( motion . r , rod ) ; twist . w . set ( rod . unitaxisrotation ) ; double theta = rod . theta ;	Converts a rigid body motion into a twist coordinate.
public void settransforms ( se3_f64 initial , se3_f64 end ) { this . initial . set ( initial ) ; translation . x = end . t . x - initial . t . x ; translation . y = end . t . y - initial . t . y ; translation . z = end . t . z - initial . t . z ; commonops_ddrm . multtransa ( initial . getr ( ) , end . getr ( ) , r ) ; convertrotation3d_f64 . matrixtorodrigues ( r , rotation ) ; rotmagnitude = rotation . theta ; }	Specify the two transforms which values are to be interpolated between.
public void interpolate ( double where , se3_f64 output ) { rotation . settheta ( where * rotmagnitude ) ; convertrotation3d_f64 . rodriguestomatrix ( rotation , r ) ; output . t . x = initial . t . x + where * translation . x ; output . t . y = initial . t . y + where * translation . y ; output . t . z = initial . t . z + where * translation . z ; commonops_ddrm . mult ( initial . r , r , output . r ) ; }	Interpolates a value between the first and second transform.
public boolean svd ( list < point3d_f64 > points , point3d_f64 outputcenter , vector3d_f64 outputnormal ) { final int n = points . size ( ) ;	SVD based method for fitting a plane to a set of points.
public boolean solvepoint ( list < point3d_f64 > points , point3d_f64 pointonplane , vector3d_f64 outputnormal ) { final int n = points . size ( ) ;	SVD based method for fitting a plane to a set of points and a known point on the plane.
public double getsidelength ( int index ) { point2d_f64 a = vertexes . get ( index ) ; point2d_f64 b = vertexes . get ( ( index + num_ ) % vertexes . size ) ; return ( double ) a . distance ( b ) ; }	Resturns the length of the specified side that is composed of point index and index+1.
public boolean isinside ( point2d_f64 p ) { if ( isconvex ( ) ) { return intersection2d_f64 . containconvex ( this , p ) ; } else { return intersection2d_f64 . containconcave ( this , p ) ; } }	Returns true if the point is inside the polygon.
public static dmatrixrmaj convert ( conicgeneral_f64 src , dmatrixrmaj dst ) { if ( dst == null ) dst = new dmatrixrmaj ( num_ , num_ ) ; else dst . reshape ( num_ , num_ ) ; double b = src . b / num_ ; double d = src . d / num_ ; double e = src . e / num_ ; dst . data [ num_ ] = src . a ; dst . data [ num_ ] = b ; dst . data [ num_ ] = d ; dst . data [ num_ ] = b ; dst . data [ num_ ] = src . c ; dst . data [ num_ ] = e ; dst . data [ num_ ] = d ; dst . data [ num_ ] = e ; dst . data [ num_ ] = src . f ; return dst ; }	Converts symmetric 3x3 matrix back into a conic. [A B/2 D/2]dst = [B/2 C E/2][D/2 E/2 F ].
public static dmatrix3x3 convert ( conicgeneral_f64 src , dmatrix3x3 dst ) { if ( dst == null ) dst = new dmatrix3x3 ( ) ; double b = src . b / num_ ; double d = src . d / num_ ; double e = src . e / num_ ; dst . a11 = src . a ; dst . a12 = b ; dst . a13 = d ; dst . a21 = b ; dst . a22 = src . c ; dst . a23 = e ; dst . a31 = d ; dst . a32 = e ; dst . a33 = src . f ; return dst ; }	Converts the conic into a symmetric 3x3 matrix [A B/2 D/2]dst = [B/2 C E/2][D/2 E/2 F ].
public static parabolageneral_f64 convert ( conicgeneral_f64 src , parabolageneral_f64 dst ) { if ( dst == null ) dst = new parabolageneral_f64 ( ) ;	Converts the conic into a parabola.
public static conicgeneral_f64 convert ( parabolageneral_f64 src , conicgeneral_f64 dst ) { if ( dst == null ) dst = new conicgeneral_f64 ( ) ; dst . a = src . a * src . a ; dst . b = src . a * src . c * num_ ; dst . c = src . c * src . c ; dst . d = src . d ; dst . e = src . e ; dst . f = src . f ; return dst ; }	Converts the parabola into a conic.
public static void divide ( geotuple3d_f64 p , double v ) { p . x /= v ; p . y /= v ; p . z /= v ; }	Divides each element by 'v'.
public static dmatrixrmaj tomatrix ( geotuple3d_f64 in , dmatrixrmaj out ) { if ( out == null ) out = new dmatrixrmaj ( num_ , num_ ) ; else if ( out . getnumelements ( ) != num_ ) throw new illegalargumentexception ( str_ ) ; out . data [ num_ ] = in . x ; out . data [ num_ ] = in . y ; out . data [ num_ ] = in . z ; return out ; }	Converts a GeoTuple3D_F64 into DMatrixRMaj.
public static void totuple3d ( dmatrixrmaj in , geotuple3d_f64 out ) { out . x = ( double ) in . get ( num_ ) ; out . y = ( double ) in . get ( num_ ) ; out . z = ( double ) in . get ( num_ ) ; }	Converts a DMatrixRMaj into GeoTuple3D_F64.
public void setparamvector ( double x , double y , double z ) { double ax = math . abs ( x ) ; double ay = math . abs ( y ) ; double az = math . abs ( z ) ; double max = math . max ( ax , ay ) ; max = math . max ( max , az ) ; if ( max == num_ ) { theta = num_ ; unitaxisrotation . set ( num_ , num_ , num_ ) ; } else { x /= max ; y /= max ; z /= max ; theta = math . sqrt ( x * x + y * y + z * z ) ; unitaxisrotation . x = x / theta ; unitaxisrotation . y = y / theta ; unitaxisrotation . z = z / theta ; theta *= max ; } }	Assign the Rodrigues coordinates using a 3 element vector.
public static double disthalf ( double anga , double angb ) { double a = math . abs ( anga - angb ) ; if ( a <= math . pi / num_ ) return a ; else return math . pi - a ; }	Angular distance between two half circle angles.
public static boolean intersect ( planegeneral3d_f64 a , planegeneral3d_f64 b , lineparametric3d_f64 line ) {	Finds the line which is the intersection between the two planes.
private static boolean containedplane ( point3d_f64 t_v0 , point3d_f64 output , vector3d_f64 u , vector3d_f64 v , vector3d_f64 w0 ) { double uu , uv , vv , wu , wv , d ; uu = u . dot ( u ) ; uv = u . dot ( v ) ; vv = v . dot ( v ) ; w0 . minus ( output , t_v0 ) ; wu = w0 . dot ( u ) ; wv = w0 . dot ( v ) ; d = uv * uv - uu * vv ;	Determines if the point on the same plane as T is contained inside of T.
public static boolean intersect ( lineparametric3d_f64 line , sphere3d_f64 sphere , point3d_f64 a , point3d_f64 b ) {	Finds the intersection of a line and sphere.
public static void interpolate ( se2_f64 a , se2_f64 b , double where , se2_f64 output ) { double w0 = num_ - where ; output . t . x = a . t . x * w0 + b . t . x * where ; output . t . y = a . t . y * w0 + b . t . y * where ;	Perform linear interpolation.
private void extractquaternionfromq ( simplematrix q ) { simpleevd < simplematrix > evd = q . eig ( ) ; int indexmax = evd . getindexmax ( ) ; simplematrix v_max = evd . geteigenvector ( indexmax ) ; quat . w = ( double ) v_max . get ( num_ ) ; quat . x = ( double ) v_max . get ( num_ ) ; quat . y = ( double ) v_max . get ( num_ ) ; quat . z = ( double ) v_max . get ( num_ ) ; quat . normalize ( ) ; convertrotation3d_f64 . quaterniontomatrix ( quat , motion . getr ( ) ) ; }	The unit eigenvector corresponding to the maximum eigenvalue of Q is the rotationparameterized as a quaternion.
public void process ( point2d_f64 [ ] input , int length , polygon2d_f64 hull ) {	Computes the convex hull.
public static void settonomotion ( se3_f64 se ) { commonops_ddrm . setidentity ( se . getr ( ) ) ; se . gett ( ) . set ( num_ , num_ , num_ ) ; }	Sets the provided transform so that it does not transform any points.
public static dmatrixrmaj tohomogeneous ( se3_f64 se , dmatrixrmaj ret ) { if ( ret == null ) ret = new dmatrixrmaj ( num_ , num_ ) ; else { ret . set ( num_ , num_ , num_ ) ; ret . set ( num_ , num_ , num_ ) ; ret . set ( num_ , num_ , num_ ) ; } commonops_ddrm . insert ( se . getr ( ) , ret , num_ , num_ ) ; vector3d_f64 t = se . gett ( ) ; ret . set ( num_ , num_ , t . x ) ; ret . set ( num_ , num_ , t . y ) ; ret . set ( num_ , num_ , t . z ) ; ret . set ( num_ , num_ , num_ ) ; return ret ; }	Converts it into a 4 by 4 homogeneous matrix.
public static dmatrixrmaj tohomogeneous ( se2_f64 se , dmatrixrmaj ret ) { if ( ret == null ) ret = new dmatrixrmaj ( num_ , num_ ) ; else { ret . set ( num_ , num_ , num_ ) ; ret . set ( num_ , num_ , num_ ) ; } final double c = se . getcosineyaw ( ) ; final double s = se . getsineyaw ( ) ; ret . set ( num_ , num_ , c ) ; ret . set ( num_ , num_ , - s ) ; ret . set ( num_ , num_ , s ) ; ret . set ( num_ , num_ , c ) ; ret . set ( num_ , num_ , se . getx ( ) ) ; ret . set ( num_ , num_ , se . gety ( ) ) ; ret . set ( num_ , num_ , num_ ) ; return ret ; }	Converts it into a 3 by 3 homogeneous matrix.
public static se3_f64 axisxyz ( double dx , double dy , double dz , double rotx , double roty , double rotz , se3_f64 se ) { if ( se == null ) se = new se3_f64 ( ) ; double theta = math . sqrt ( rotx * rotx + roty + roty + rotz * rotz ) ; if ( theta == num_ ) { commonops_ddrm . setidentity ( se . r ) ; } else { convertrotation3d_f64 . rodriguestomatrix ( rotx / theta , roty / theta , rotz / theta , theta , se . getr ( ) ) ; } vector3d_f64 t = se . gett ( ) ; t . x = dx ; t . y = dy ; t . z = dz ; return se ; }	Create SE3 using axis-angle for rotation and XYZ tanslation.
public static boolean isidentical ( se3_f64 a , se3_f64 b , double tolt , double tolr ) { if ( math . abs ( a . t . x - b . t . x ) > tolt ) return bool_ ; if ( math . abs ( a . t . y - b . t . y ) > tolt ) return bool_ ; if ( math . abs ( a . t . z - b . t . z ) > tolt ) return bool_ ; dmatrixrmaj d = new dmatrixrmaj ( num_ , num_ ) ; commonops_ddrm . multtransa ( a . r , b . r , d ) ; rodrigues_f64 rod = new rodrigues_f64 ( ) ; convertrotation3d_f64 . matrixtorodrigues ( d , rod ) ; return rod . theta <= tolr ; }	Can be used to see if two transforms are identical to within tolerance.
public static < t extends geotuple3d_f64 < t > > t latlontounitvector ( double lat , double lon , t vector ) { if ( vector == null ) vector = ( t ) new vector3d_f64 ( ) ; vector . x = math . cos ( lat ) * math . cos ( lon ) ; vector . y = math . cos ( lat ) * math . sin ( lon ) ; vector . z = - math . sin ( lat ) ; return vector ; }	Converts latitude and longitude coordinates into a unit vector.
public static boolean circle ( point2d_f64 x0 , point2d_f64 x1 , point2d_f64 x2 , circle2d_f64 circle ) {	Given three points find the circle that intersects all three.
public static double circleradiussq ( point2d_f64 x0 , point2d_f64 x1 , point2d_f64 x2 ) {	Radius squares of the circle that passes through these three points.
public static point3d_f64 closestpoint ( lineparametric3d_f64 l0 , lineparametric3d_f64 l1 , point3d_f64 ret ) { if ( ret == null ) { ret = new point3d_f64 ( ) ; } ret . x = l0 . p . x - l1 . p . x ; ret . y = l0 . p . y - l1 . p . y ; ret . z = l0 . p . z - l1 . p . z ;	Returns the point which minimizes the distance between the two lines in 3D.
public static point3d_f64 closestpoint ( lineparametric3d_f64 line , point3d_f64 pt , point3d_f64 ret ) { if ( ret == null ) { ret = new point3d_f64 ( ) ; } double dx = pt . x - line . p . x ; double dy = pt . y - line . p . y ; double dz = pt . z - line . p . z ; double n2 = line . slope . normsq ( ) ; double d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; ret . x = line . p . x + d * line . slope . x / n2 ; ret . y = line . p . y + d * line . slope . y / n2 ; ret . z = line . p . z + d * line . slope . z / n2 ; return ret ; }	Finds the closest point on a line to the specified point.
public static point3d_f64 closestpointorigin ( planegeneral3d_f64 plane , point3d_f64 found ) { if ( found == null ) found = new point3d_f64 ( ) ; double n2 = plane . a * plane . a + plane . b * plane . b + plane . c * plane . c ; found . x = plane . a * plane . d / n2 ; found . y = plane . b * plane . d / n2 ; found . z = plane . c * plane . d / n2 ; return found ; }	Finds the closest point on the plane to the origin.
public static point3d_f64 closestpoint ( linesegment3d_f64 line , point3d_f64 pt , point3d_f64 ret ) { if ( ret == null ) { ret = new point3d_f64 ( ) ; } double dx = pt . x - line . a . x ; double dy = pt . y - line . a . y ; double dz = pt . z - line . a . z ; double slope_x = line . b . x - line . a . x ; double slope_y = line . b . y - line . a . y ; double slope_z = line . b . z - line . a . z ; double n = ( double ) math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ;	Finds the closest point on a line segment to the specified point.
public static point3d_f64 closestpoint ( point3d_f64 vertexa , point3d_f64 vertexb , point3d_f64 vertexc , point3d_f64 point , point3d_f64 ret ) { if ( ret == null ) { ret = new point3d_f64 ( ) ; } distancepointtriangle3d_f64 alg = new distancepointtriangle3d_f64 ( ) ; alg . settriangle ( vertexa , vertexb , vertexc ) ; alg . closestpoint ( point , ret ) ; return ret ; }	Closest point from a 3D triangle to a point.
public static point2d_f64 transform ( se2_f64 se , point2d_f64 orig , point2d_f64 result ) { if ( result == null ) { result = new point2d_f64 ( ) ; } final double c = se . getcosineyaw ( ) ; final double s = se . getsineyaw ( ) ;	Applies a 2D special euclidean transform to the point and stores the results in anothervariable.
public static void transform ( se2_f64 se , point2d_f64 points [ ] , int length ) { double tranx = se . getx ( ) ; double trany = se . gety ( ) ; final double c = se . getcosineyaw ( ) ; final double s = se . getsineyaw ( ) ; for ( int i = num_ ; i < length ; i ++ ) { point2d_f64 pt = points [ i ] ; double x = pt . x ; double y = pt . y ; pt . x = tranx + x * c - y * s ; pt . y = trany + x * s + y * c ; } }	Applies a 2D special euclidean transform to an array of points.
public boolean isequals ( quadrilateral_f64 quad , double tol ) { tol *= tol ; if ( a . distance2 ( quad . a ) > tol ) return bool_ ; if ( b . distance2 ( quad . b ) > tol ) return bool_ ; if ( c . distance2 ( quad . c ) > tol ) return bool_ ; return d . distance2 ( quad . d ) <= tol ; }	Returns true if the two quadrilaterals are equal to each other to within tolerance.
public static double acuteangle ( linegeneral2d_f64 a , linegeneral2d_f64 b ) { double la = math . sqrt ( a . a * a . a + a . b * a . b ) ; double lb = math . sqrt ( b . a * b . a + b . b * b . b ) ;	Returns the acute angle between the slope of two lines.
public static lineparametric2d_f64 convert ( linepolar2d_f64 src , lineparametric2d_f64 ret ) { if ( ret == null ) ret = new lineparametric2d_f64 ( ) ; double c = ( double ) math . cos ( src . angle ) ; double s = ( double ) math . sin ( src . angle ) ; ret . p . set ( c * src . distance , s * src . distance ) ; ret . slope . set ( - s , c ) ; return ret ; }	Converts a line from polar form to parametric.
public static linepolar2d_f64 convert ( linegeneral2d_f64 src , linepolar2d_f64 ret ) { if ( ret == null ) ret = new linepolar2d_f64 ( ) ; double r = math . sqrt ( src . a * src . a + src . b * src . b ) ; double sign = src . c < num_ ? - num_ : num_ ; ret . angle = math . atan2 ( - sign * src . b / r , - sign * src . a / r ) ; ret . distance = sign * src . c / r ; return ret ; }	Converts a line from general to polar.
public static lineparametric2d_f64 convert ( linesegment2d_f64 src , lineparametric2d_f64 ret ) { if ( ret == null ) ret = new lineparametric2d_f64 ( ) ; ret . p . set ( src . a ) ; ret . slope . set ( src . slopex ( ) , src . slopey ( ) ) ; return ret ; }	Converts a line segment into a parametric line.
public static linegeneral2d_f64 convert ( linesegment2d_f64 src , linegeneral2d_f64 ret ) { return convert ( src . a , src . b , ret ) ; }	Converts a line segment into a general line.
public static linegeneral2d_f64 convert ( point2d_f64 a , point2d_f64 b , linegeneral2d_f64 ret ) { if ( ret == null ) ret = new linegeneral2d_f64 ( ) ; ret . a = a . y - b . y ; ret . b = b . x - a . x ; ret . c = - ( ret . a * a . x + ret . b * a . y ) ; return ret ; }	Converts a line segment into a general line.
public static lineparametric2d_f64 convert ( point2d_f64 a , point2d_f64 b , lineparametric2d_f64 ret ) { if ( ret == null ) ret = new lineparametric2d_f64 ( ) ; ret . p . set ( a ) ; ret . slope . x = b . x - a . x ; ret . slope . y = b . y - a . y ; return ret ; }	Converts a line segment into a line in parametric format.
public static linepolar2d_f64 convert ( lineparametric2d_f64 src , linepolar2d_f64 ret ) { if ( ret == null ) ret = new linepolar2d_f64 ( ) ; double top = src . slope . y * src . p . x - src . slope . x * src . p . y ; ret . distance = top / src . slope . norm ( ) ; ret . angle = math . atan2 ( - src . slope . x , src . slope . y ) ; if ( ret . distance < num_ ) { ret . distance = - ret . distance ; ret . angle = utilangle . bound ( ret . angle + math . pi ) ; } return ret ; }	Converts a line from parametric to polar.
public static linegeneral2d_f64 convert ( lineparametric2d_f64 src , linegeneral2d_f64 ret ) { if ( ret == null ) { ret = new linegeneral2d_f64 ( ) ; } ret . a = - src . slope . y ; ret . b = src . slope . x ; ret . c = - ret . a * src . p . x - ret . b * src . p . y ; return ret ; }	Converts a line from parametric to general.
public static lineparametric2d_f64 convert ( linegeneral2d_f64 src , lineparametric2d_f64 ret ) { if ( ret == null ) { ret = new lineparametric2d_f64 ( ) ; } ret . slope . x = src . b ; ret . slope . y = - src . a ;	Converts a line from general to parametric.
public static planegeneral3d_f64 convert ( planenormal3d_f64 input , planegeneral3d_f64 output ) { if ( output == null ) output = new planegeneral3d_f64 ( ) ; vector3d_f64 n = input . n ; point3d_f64 p = input . p ; output . a = n . x ; output . b = n . y ; output . c = n . z ; output . d = n . x * p . x + n . y * p . y + n . z * p . z ; return output ; }	Converts a plane in normal form into a general equation.
public static planenormal3d_f64 convert ( planetangent3d_f64 input , planenormal3d_f64 output ) { if ( output == null ) output = new planenormal3d_f64 ( ) ;	Converts a plane in tangent form into a plane in normal form.
public static planenormal3d_f64 convert ( se3_f64 planetoworld , planenormal3d_f64 output ) { if ( output == null ) output = new planenormal3d_f64 ( ) ;	Defines a plane using a 3D rigid body transform.
public static void point2dto3d ( point3d_f64 origin , vector3d_f64 axisx , vector3d_f64 axisy , point2d_f64 a , point3d_f64 output ) { output . x = origin . x + axisx . x * a . x + axisy . y * a . y ; output . y = origin . y + axisx . y * a . x + axisy . y * a . y ; output . z = origin . z + axisx . z * a . x + axisy . y * a . y ; }	Given a point on the plane's 2D coordinate system, convert it back into a 3D point.
public static se3_f64 planetoworld ( planegeneral3d_f64 plane , se3_f64 planetoworld ) { if ( planetoworld == null ) planetoworld = new se3_f64 ( ) ; vector3d_f64 axisz = new vector3d_f64 ( plane . a , plane . b , plane . c ) ; axisz . normalize ( ) ; vector3d_f64 axisx = new vector3d_f64 ( ) ; vector3d_f64 axisy = new vector3d_f64 ( ) ; utilplane3d_f64 . selectaxis2d ( axisz , axisx , axisy ) ; return planetoworld ( plane , axisx , axisy , axisz , planetoworld ) ; }	Creates a transform from the plane's reference frame into world's reference frame.
public boolean isidentical ( t t , double tol ) { if ( t . getdimension ( ) != getdimension ( ) ) return bool_ ; int n = getdimension ( ) ; for ( int i = num_ ; i < n ; i ++ ) { double diff = math . abs ( getidx ( i ) - t . getidx ( i ) ) ; if ( diff > tol ) return bool_ ; } return bool_ ; }	Checks to see if the two GeoTuple have values which are nearly the same.
@ override public t copy ( ) { t ret = createnewinstance ( ) ; int n = getdimension ( ) ; for ( int i = num_ ; i < n ; i ++ ) { ret . setidx ( i , getidx ( i ) ) ; } return ret ; }	Generic copy routine. It is recommended that this be overridden with a faster implementation.
public double normsq ( ) { double total = num_ ; int n = getdimension ( ) ; for ( int i = num_ ; i < n ; i ++ ) { double a = getidx ( i ) ; total += a * a ; } return total ; }	Computes the square of the Euclidean norm.
public static double computet ( lineparametric3d_f64 line , point3d_f64 pointonline ) { double dx = pointonline . x - line . p . x ; double dy = pointonline . y - line . p . y ; double dz = pointonline . z - line . p . z ; double adx = math . abs ( dx ) ; double ady = math . abs ( dy ) ; double adz = math . abs ( dz ) ; double t ; if ( adx > ady ) { if ( adx > adz ) { t = dx / line . slope . x ; } else { t = dz / line . slope . z ; } } else if ( ady > adz ) { t = dy / line . slope . y ; } else { t = dz / line . slope . z ; } return t ; }	Computes the value of T for a point on the parametric line.
public boolean hasuncountable ( ) { return utilejml . isuncountable ( a ) || utilejml . isuncountable ( c ) || utilejml . isuncountable ( d ) || utilejml . isuncountable ( e ) || utilejml . isuncountable ( f ) ; }	Returns true if any of its parameters have an uncountable number.
public boolean isequivalent ( parabolageneral_f64 parabola , double tol ) { double scale = relativescale ( parabola ) ; if ( math . abs ( a * scale - parabola . a ) > tol ) return bool_ ; if ( math . abs ( c * scale - parabola . c ) > tol ) return bool_ ; if ( math . abs ( d * scale - parabola . d ) > tol ) return bool_ ; if ( math . abs ( e * scale - parabola . e ) > tol ) return bool_ ; if ( math . abs ( f * scale - parabola . f ) > tol ) return bool_ ; return bool_ ; }	Determines if they are equivalent up to a scale factor.
public point3d_f64 center ( point3d_f64 storage ) { if ( storage == null ) storage = new point3d_f64 ( ) ; storage . x = ( p0 . x + p1 . x ) / num_ ; storage . y = ( p0 . y + p1 . y ) / num_ ; storage . z = ( p0 . z + p1 . z ) / num_ ; return storage ; }	Computes and return the center of the cube.
public static double acuteangle ( linesegment2d_i32 line0 , linesegment2d_i32 line1 ) { int dx0 = line0 . b . x - line0 . a . x ; int dy0 = line0 . b . y - line0 . a . y ; int dx1 = line1 . b . x - line1 . a . x ; int dy1 = line1 . b . y - line1 . a . y ; double bottom = math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; return math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; }	Computes the acute angle between the two lines. Does not check for intersection.
public static boolean isinfiniteh ( point4d_f64 p , double tol ) { double n = math . sqrt ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return math . abs ( p . w ) <= n * tol ; }	Checks to see if the homogenous 3D point lies on the plane at infinity.
public static list < point4d_f64 > randomn ( point3d_f64 center , double w , double stdev , int num , random rand ) { list < point4d_f64 > ret = new arraylist < > ( ) ; for ( int i = num_ ; i < num ; i ++ ) { point4d_f64 p = new point4d_f64 ( ) ; p . x = center . x + rand . nextgaussian ( ) * stdev ; p . y = center . y + rand . nextgaussian ( ) * stdev ; p . z = center . z + rand . nextgaussian ( ) * stdev ; p . w = w ; ret . add ( p ) ; } return ret ; }	Normally distributed homogenous 3D point. w is fixed.
public static point3d_f64 h_to_e ( point4d_f64 p ) { point3d_f64 out = new point3d_f64 ( ) ; h_to_e ( p , out ) ; return out ; }	Converts a point from homogenous coordinates into Euclidean.
public static vector2d_f64 minus ( point2d_f64 a , point2d_f64 b , vector2d_f64 output ) { if ( output == null ) output = new vector2d_f64 ( ) ; output . x = a . x - b . x ; output . y = a . y - b . y ; return output ; }	Sets the vector equal to 'a' - 'b'.
public static boolean identicalsign ( double xa , double ya , double xb , double yb , double tol ) { double dx0 = xb - xa ; double dy0 = yb - ya ; double dx1 = xb + xa ; double dy1 = yb + ya ; double error0 = dx0 * dx0 + dy0 * dy0 ; double error1 = dx1 * dx1 + dy1 * dy1 ; if ( error0 < error1 ) { return error0 <= tol * tol ; } else { return error1 <= tol * tol ; } }	Tests to see if the two vectors are identical up to a sign difference.
public void set ( rectanglelength2d_i32 r ) { this . x0 = r . x0 ; this . y0 = r . y0 ; this . width = r . width ; this . height = r . height ; }	Sets this rectangle to be equal to the passed in rectangle.
public static ellipsequadratic_f64 convert ( ellipserotated_f64 input , ellipsequadratic_f64 output ) { if ( output == null ) output = new ellipsequadratic_f64 ( ) ; double x0 = input . center . x ; double y0 = input . center . y ; double a = input . a ; double b = input . b ; double phi = input . phi ; double cphi = math . cos ( phi ) ; double sphi = math . sin ( phi ) ; double cphi2 = cphi * cphi ; double sphi2 = sphi * sphi ; double a2 = a * a ; double b2 = b * b ; double x02 = x0 * x0 ; double y02 = y0 * y0 ;	Convert from rotated to quadratic.
public static point2d_f64 computepoint ( double t , ellipserotated_f64 ellipse , point2d_f64 output ) { if ( output == null ) output = new point2d_f64 ( ) ; double ct = math . cos ( t ) ; double st = math . sin ( t ) ; double cphi = math . cos ( ellipse . phi ) ; double sphi = math . sin ( ellipse . phi ) ;	Computes the point on the ellipse at location 't', where t is an angle in radians.
public static double computeangle ( point2d_f64 p , ellipserotated_f64 ellipse ) {	Computes the value of 't' used to specify a point's location.
public static vector2d_f64 computetangent ( double t , ellipserotated_f64 ellipse , vector2d_f64 output ) { if ( output == null ) output = new vector2d_f64 ( ) ; double ct = math . cos ( t ) ; double st = math . sin ( t ) ; double cphi = math . cos ( ellipse . phi ) ; double sphi = math . sin ( ellipse . phi ) ;	Computes the tangent to the ellipse at the specified location.
boolean selecttangent ( point2d_f64 a , point2d_f64 previoustangent , ellipserotated_f64 ellipse , point2d_f64 tangent , boolean cross ) { if ( ! tangentlines ( a , ellipse , temp0 , temp1 ) ) return bool_ ; templine . a = a ; templine . b = temp0 ; boolean crossed0 = intersection2d_f64 . intersection ( centerline , templine , junk ) != null ; templine . b = temp1 ; boolean crossed1 = intersection2d_f64 . intersection ( centerline , templine , junk ) != null ; if ( crossed0 == crossed1 ) throw new runtimeexception ( str_ ) ; if ( cross == crossed0 ) { sumdifference += previoustangent . distance2 ( temp0 ) ; tangent . set ( temp0 ) ; } else { sumdifference += previoustangent . distance2 ( temp1 ) ; tangent . set ( temp1 ) ; } return bool_ ; }	Selects a tangent point on the ellipse which is closest to the original source point of A.
public point3d_f64 getcorner ( int index , point3d_f64 corner ) { if ( corner == null ) corner = new point3d_f64 ( ) ; corner . set ( p ) ; if ( ( index & num_ ) != num_ ) { corner . x += lengthx ; } if ( ( index & num_ ) != num_ ) { corner . y += lengthy ; } if ( ( index & num_ ) != num_ ) { corner . z += lengthz ; } return corner ; }	Used to retrieve the corners of the box.
public static double distance ( lineparametric3d_f64 l0 , lineparametric3d_f64 l1 ) { double x = l0 . p . x - l1 . p . x ; double y = l0 . p . y - l1 . p . y ; double z = l0 . p . z - l1 . p . z ;	Distance of the closest point between two lines.
public static double distance ( lineparametric3d_f64 l , point3d_f64 p ) { double x = l . p . x - p . x ; double y = l . p . y - p . y ; double z = l . p . z - p . z ; double cc = x * x + y * y + z * z ;	Distance from the point to the closest point on the line.
public static double distance ( linesegment3d_f64 l , point3d_f64 p ) { double dx = p . x - l . a . x ; double dy = p . y - l . a . y ; double dz = p . z - l . a . z ; double cc = dx * dx + dy * dy + dz * dz ; double slope_x = l . b . x - l . a . x ; double slope_y = l . b . y - l . a . y ; double slope_z = l . b . z - l . a . z ; double n = ( double ) math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ;	Distance from the point to the closest point on the line segment.
public static double distance ( planegeneral3d_f64 plane , point3d_f64 point ) { double top = plane . a * point . x + plane . b * point . y + plane . c * point . z - plane . d ; return top / math . sqrt ( plane . a * plane . a + plane . b * plane . b + plane . c * plane . c ) ; }	Distance between a plane and a point.
public static double distance ( cylinder3d_f64 cylinder , point3d_f64 point ) { double r = distance3d_f64 . distance ( cylinder . line , point ) ; return r - cylinder . radius ; }	Returns the signed distance a point is from the cylinder's surface.
public static double distance ( linesegment2d_f64 segmenta , linesegment2d_f64 segmentb ) { return math . sqrt ( distancesq ( segmenta , segmentb ) ) ; }	Finds the distance between the two line segments.
public static double distancesq ( linesegment2d_f64 segmenta , linesegment2d_f64 segmentb ) {	Finds the distance squared between the two line segments.
public static double distance ( quadrilateral_f64 quad , point2d_f64 p ) { return math . sqrt ( distancesq ( quad , p ) ) ; }	Returns the Euclidean distance of the closest point on the quadrilateral to the provided point.
public static double distancesq ( quadrilateral_f64 quad , point2d_f64 p ) { linesegment2d_f64 seg = linesegment2d_f64 . wrap ( quad . a , quad . b ) ; double a = distancesq ( seg , p ) ; seg . a = quad . b ; seg . b = quad . c ; a = math . min ( a , distancesq ( seg , p ) ) ; seg . a = quad . c ; seg . b = quad . d ; a = math . min ( a , distancesq ( seg , p ) ) ; seg . a = quad . d ; seg . b = quad . a ; return math . min ( a , distancesq ( seg , p ) ) ; }	Returns the Euclidean distance squared of the closest point on the quadrilateral to the provided point.
public static double distance ( polygon2d_f64 poly , point2d_f64 p ) { return math . sqrt ( distancesq ( poly , p , null ) ) ; }	Returns the Euclidean distance of the closest point on the Polygon to the provided point.
public static double distancesq ( polygon2d_f64 poly , point2d_f64 p , linesegment2d_f64 storage ) { if ( storage == null ) storage = linesegment2d_f64 . wrap ( null , null ) ; double minimum = double . max_value ; for ( int i = num_ ; i < poly . size ( ) ; i ++ ) { int j = ( i + num_ ) % poly . size ( ) ; storage . a = poly . vertexes . data [ i ] ; storage . b = poly . vertexes . data [ j ] ; double d = distancesq ( storage , p ) ; if ( d < minimum ) minimum = d ; } return minimum ; }	Returns the Euclidean distance squared of the closest point on the Polygon to the provided point.
public static double distanceorigin ( lineparametric2d_f64 line ) { double top = line . slope . y * line . p . x - line . slope . x * line . p . y ; return math . abs ( top ) / line . slope . norm ( ) ; }	Returns the distance of the closest point on the line from the origin.
public static double distance ( ellipserotated_f64 ellipse , point2d_f64 p ) { return math . sqrt ( distance2 ( ellipse , p ) ) ; }	Euclidean distance of closest point on ellipse to point 'p'.
public static double distance2 ( ellipserotated_f64 ellipse , point2d_f64 p ) {	Euclidean distance squared of closest point on ellipse to point 'p'.
public void addtransform ( boolean forward , t tran ) { path . add ( new node < t > ( tran , forward ) ) ; }	Adds the next transform in the sequence.
public static point2d_f64 closestpoint ( linesegment2d_f64 line , point2d_f64 p , point2d_f64 output ) { if ( output == null ) output = new point2d_f64 ( ) ; double slopex = line . b . x - line . a . x ; double slopey = line . b . y - line . a . y ; double t = slopex * ( p . x - line . a . x ) + slopey * ( p . y - line . a . y ) ; t /= slopex * slopex + slopey * slopey ; if ( t < num_ ) t = num_ ; else if ( t > num_ ) t = num_ ; output . x = line . a . x + slopex * t ; output . y = line . a . y + slopey * t ; return output ; }	Finds the closest point on the line segment to the provided point 'p'.
public static point2d_f64 closestpoint ( ellipserotated_f64 ellipse , point2d_f64 p ) { closestpointellipseangle_f64 alg = new closestpointellipseangle_f64 ( grlconstants . test_f64 , num_ ) ; alg . setellipse ( ellipse ) ; alg . process ( p ) ; return alg . getclosest ( ) ; }	Computes the closest point on an ellipse to the provided point.
public boolean process ( double [ ] data , int offset , int length , polynomialcurve_f64 output ) { int n = length / num_ ; int numcoefs = output . size ( ) ; a . reshape ( n , numcoefs ) ; b . reshape ( n , num_ ) ; x . reshape ( numcoefs , num_ ) ; int end = offset + length ; for ( int i = offset , idxa = num_ ; i < end ; i += num_ ) { double x = data [ i ] ; double y = data [ i + num_ ] ; double pow = num_ ; for ( int j = num_ ; j < numcoefs ; j ++ ) { a . data [ idxa ++ ] = pow ; pow *= x ; } b . data [ i / num_ ] = y ; } if ( ! solver . seta ( a ) ) return bool_ ; solver . solve ( b , x ) ; for ( int i = num_ ; i < numcoefs ; i ++ ) { output . set ( i , x . data [ i ] ) ; } return bool_ ; }	Fits the polynomial curve to the data.
public static vector3d_f64 createrandom ( double min , double max , random rand ) { double range = max - min ; vector3d_f64 a = new vector3d_f64 ( ) ; a . x = range * rand . nextdouble ( ) + min ; a . y = range * rand . nextdouble ( ) + min ; a . z = range * rand . nextdouble ( ) + min ; return a ; }	Creates a random vector where each axis is selected from a uniform distribution.
public static vector3d_f64 perpendicularcanonical ( vector3d_f64 a , vector3d_f64 output ) { if ( output == null ) output = new vector3d_f64 ( ) ;	Selects a vector which will be perpendicular.
public static boolean isidentical ( vector3d_f64 a , vector3d_f64 b , double tol ) { if ( math . abs ( a . x - b . x ) > tol ) return bool_ ; if ( math . abs ( a . y - b . y ) > tol ) return bool_ ; return math . abs ( a . z - b . z ) <= tol ; }	Checks to see if the two vectors are identical to within tolerance.
public static void normalize ( vector3d_f64 v ) { double a = v . norm ( ) ; v . x /= a ; v . y /= a ; v . z /= a ; }	Rescales the vector such that its normal is equal to one.
public static dmatrixrmaj creatematrix ( dmatrixrmaj r , vector3d_f64 ... v ) { if ( r == null ) { r = new dmatrixrmaj ( num_ , v . length ) ; } for ( int i = num_ ; i < v . length ; i ++ ) { r . set ( num_ , i , v [ i ] . x ) ; r . set ( num_ , i , v [ i ] . y ) ; r . set ( num_ , i , v [ i ] . z ) ; } return r ; }	Creates a matrix from the set of column vectors.
public static vector3d_f64 convert ( dmatrixrmaj m ) { vector3d_f64 v = new vector3d_f64 ( ) ; v . x = ( double ) m . data [ num_ ] ; v . y = ( double ) m . data [ num_ ] ; v . z = ( double ) m . data [ num_ ] ; return v ; }	Converts matrices into vectors.
public double distance ( double x , double y ) { double dx = x - this . x ; double dy = y - this . y ; return math . sqrt ( dx * dx + dy * dy ) ; }	Euclidean distance from the point.
public void setellipse ( ellipserotated_f64 ellipse ) { this . ellipse = ellipse ; ce = math . cos ( ellipse . phi ) ; se = math . sin ( ellipse . phi ) ; }	Specifies the ellipse which point distance is going to be found from.
public void normalize ( ) { double n = math . sqrt ( w * w + x * x + y * y + z * z ) ; w /= n ; x /= n ; y /= n ; z /= n ; }	Converts the quaternion into a unit quaternion.
public static double triangle ( point2d_f64 a , point2d_f64 b , point2d_f64 c ) { double inner = a . x * ( b . y - c . y ) + b . x * ( c . y - a . y ) + c . x * ( a . y - b . y ) ; return math . abs ( inner / num_ ) ; }	Computes the area of an arbitrary triangle from 3-vertices.area = | a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y) | / 2.
public static double quadrilateral ( quadrilateral_f64 quad ) { double bx = quad . b . x - quad . a . x ; double by = quad . b . y - quad . a . y ; double cx = quad . c . x - quad . a . x ; double cy = quad . c . y - quad . a . y ; double dx = quad . d . x - quad . a . x ; double dy = quad . d . y - quad . a . y ; if ( ( bx * cy - by * cx >= num_ ) == ( cx * dy - cy * dx >= num_ ) ) { return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; } else { return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; } }	Area of a quadrilateral computed from two triangles.
public static double polygonsimple ( polygon2d_f64 poly ) { double total = num_ ; point2d_f64 v0 = poly . get ( num_ ) ; point2d_f64 v1 = poly . get ( num_ ) ; for ( int i = num_ ; i < poly . size ( ) ; i ++ ) { point2d_f64 v2 = poly . get ( i ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; } point2d_f64 v2 = poly . get ( num_ ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; v2 = poly . get ( num_ ) ; total += v1 . x * ( v2 . y - v0 . y ) ; return math . abs ( total / num_ ) ; }	Area of a simple polygon. Meaning it can be concave or convex, but can't have self intersections.
public static point2d_f64 mean ( point2d_f64 [ ] list , int offset , int length , point2d_f64 mean ) { if ( mean == null ) mean = new point2d_f64 ( ) ; double x = num_ ; double y = num_ ; for ( int i = num_ ; i < length ; i ++ ) { point2d_f64 p = list [ offset + i ] ; x += p . getx ( ) ; y += p . gety ( ) ; } x /= length ; y /= length ; mean . set ( x , y ) ; return mean ; }	Finds the point which has the mean location of all the points in the array.
public static list < point2d_f64 > orderccw ( list < point2d_f64 > points ) { point2d_f64 center = mean ( points , null ) ; double angles [ ] = new double [ points . size ( ) ] ; for ( int i = num_ ; i < angles . length ; i ++ ) { point2d_f64 p = points . get ( i ) ; double dx = p . x - center . x ; double dy = p . y - center . y ; angles [ i ] = math . atan2 ( dy , dx ) ; } int order [ ] = new int [ points . size ( ) ] ; quicksort_f64 sorter = new quicksort_f64 ( ) ; sorter . sort ( angles , num_ , points . size ( ) , order ) ; list < point2d_f64 > out = new arraylist < point2d_f64 > ( points . size ( ) ) ; for ( int i = num_ ; i < points . size ( ) ; i ++ ) { out . add ( points . get ( order [ i ] ) ) ; } return out ; }	Puts the points into counter-clockwise order around their center.
public static void computenormal ( list < point2d_f64 > points , point2d_f64 mean , dmatrix covariance ) { if ( covariance . getnumcols ( ) != num_ || covariance . getnumrows ( ) != num_ ) { if ( covariance instanceof reshapematrix ) { ( ( reshapematrix ) covariance ) . reshape ( num_ , num_ ) ; } else { throw new illegalargumentexception ( str_ ) ; } } mean ( points , mean ) ; double xx = num_ , xy = num_ , yy = num_ ; for ( int i = num_ ; i < points . size ( ) ; i ++ ) { point2d_f64 p = points . get ( i ) ; double dx = p . x - mean . x ; double dy = p . y - mean . y ; xx += dx * dx ; xy += dx * dy ; yy += dy * dy ; } xx /= points . size ( ) ; xy /= points . size ( ) ; yy /= points . size ( ) ; covariance . unsafe_set ( num_ , num_ , xx ) ; covariance . unsafe_set ( num_ , num_ , xy ) ; covariance . unsafe_set ( num_ , num_ , xy ) ; covariance . unsafe_set ( num_ , num_ , yy ) ; }	Computes the mean and covariance matrix from the set of points. This describes a normal distribution.
public static boolean isconvex ( polygon2d_i32 poly ) {	Determines if the polugon is convex or concave.
public void timesip ( double scalar ) { x *= scalar ; y *= scalar ; z *= scalar ; w *= scalar ; }	In-place scalar multiplication.
public double maxabs ( ) { double absx = math . abs ( x ) ; double absy = math . abs ( y ) ; double absz = math . abs ( z ) ; double absw = math . abs ( w ) ; double found = math . max ( absx , absy ) ; if ( found < absz ) found = absz ; if ( found < absw ) found = absw ; return found ; }	Returns the absolute value of the component with the largest absolute value.
public static double distance ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { return norm ( x1 - x0 , y1 - y0 , z1 - z0 ) ; }	Euclidean distance between the two specified points.
public static double distancesq ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { double dx = x1 - x0 ; double dy = y1 - y0 ; double dz = z1 - z0 ; return dx * dx + dy * dy + dz * dz ; }	Euclidean distance squared between the two specified points.
public static list < point3d_f64 > random ( planenormal3d_f64 plane , double max , int num , random rand ) { list < point3d_f64 > ret = new arraylist < > ( ) ; vector3d_f64 axisx = new vector3d_f64 ( ) ; vector3d_f64 axisy = new vector3d_f64 ( ) ; utilplane3d_f64 . selectaxis2d ( plane . n , axisx , axisy ) ; for ( int i = num_ ; i < num ; i ++ ) { double x = num_ * max * ( rand . nextdouble ( ) - num_ ) ; double y = num_ * max * ( rand . nextdouble ( ) - num_ ) ; point3d_f64 p = new point3d_f64 ( ) ; p . x = plane . p . x + axisx . x * x + axisy . x * y ; p . y = plane . p . y + axisx . y * x + axisy . y * y ; p . z = plane . p . z + axisx . z * x + axisy . z * y ; ret . add ( p ) ; } return ret ; }	Randomly generates a set of points on the plane centered at the plane's originusing a uniform distribution.
public static list < point3d_f64 > random ( point3d_f64 mean , double minx , double maxx , double miny , double maxy , double minz , double maxz , int num , random rand ) { list < point3d_f64 > ret = new arraylist < > ( ) ; for ( int i = num_ ; i < num ; i ++ ) { point3d_f64 p = new point3d_f64 ( ) ; p . x = mean . x + rand . nextdouble ( ) * ( maxx - minx ) + minx ; p . y = mean . y + rand . nextdouble ( ) * ( maxy - miny ) + miny ; p . z = mean . z + rand . nextdouble ( ) * ( maxz - minz ) + minz ; ret . add ( p ) ; } return ret ; }	Creates a list of random points from a uniform distribution along each axis.
public static list < point3d_f64 > randomn ( point3d_f64 mean , double stdx , double stdy , double stdz , int num , random rand ) { list < point3d_f64 > ret = new arraylist < > ( ) ; for ( int i = num_ ; i < num ; i ++ ) { point3d_f64 p = new point3d_f64 ( ) ; p . x = mean . x + rand . nextgaussian ( ) * stdx ; p . y = mean . y + rand . nextgaussian ( ) * stdy ; p . z = mean . z + rand . nextgaussian ( ) * stdz ; ret . add ( p ) ; } return ret ; }	Creates a list of random points from a normal distribution along each axis.
public static point3d_f64 mean ( list < point3d_f64 > points , point3d_f64 mean ) { if ( mean == null ) mean = new point3d_f64 ( ) ; double x = num_ , y = num_ , z = num_ ; for ( point3d_f64 p : points ) { x += p . x ; y += p . y ; z += p . z ; } mean . x = x / points . size ( ) ; mean . y = y / points . size ( ) ; mean . z = z / points . size ( ) ; return mean ; }	Computes the mean of the list of points.
public static point3d_f64 mean ( list < point3d_f64 > points , int num , point3d_f64 mean ) { if ( mean == null ) mean = new point3d_f64 ( ) ; double x = num_ , y = num_ , z = num_ ; for ( int i = num_ ; i < num ; i ++ ) { point3d_f64 p = points . get ( i ) ; x += p . x ; y += p . y ; z += p . z ; } mean . x = x / num ; mean . y = y / num ; mean . z = z / num ; return mean ; }	Computes the mean of the list of points up to element num.
public void invalidateall ( iterable < jwtcontext > credentials ) { credentials . foreach ( context -> cache . invalidate ( context . getjwt ( ) ) ) ; }	Discards any cached principal for the given collection of credentials.
public void invalidateall ( predicate < ? super jwtcontext > predicate ) { cache . asmap ( ) . entryset ( ) . stream ( ) . map ( entry -> entry . getvalue ( ) . getkey ( ) ) . filter ( predicate :: test ) . map ( jwtcontext :: getjwt ) . foreach ( cache :: invalidate ) ; }	Discards any cached principal for the collection of credentials satisfying the given predicate.
@ safevarargs public static set < string > combinetoset ( collection < string > ... collections ) { set < string > result = new hashset < string > ( ) ; set < string > lowercaseset = new hashset < string > ( ) ; for ( collection < string > collection : collections ) { if ( collection != null ) { for ( string value : collection ) { if ( ! lowercaseset . contains ( value . tolowercase ( ) ) ) { lowercaseset . add ( value . tolowercase ( ) ) ; result . add ( value ) ; } } } } return result ; }	Combine the given String collections into a set using case-insensitive matching.If there are multiple instances of the same string but with different capitalization,only the first one found will be included.
public set < string > getserverfeatures ( file serverdirectory ) { set < string > result = getconfigdropinsfeatures ( null , serverdirectory , str_ ) ; result = getserverxmlfeatures ( result , new file ( serverdirectory , str_ ) , null ) ;	Get the set of features defined in the server.xml.
private set < string > getconfigdropinsfeatures ( set < string > origresult , file serverdirectory , string foldername ) { set < string > result = origresult ; file configdropinsfolder ; try { configdropinsfolder = new file ( new file ( serverdirectory , str_ ) , foldername ) . getcanonicalfile ( ) ; } catch ( ioexception e ) {	Gets features from the configDropins's defaults or overrides directory.
private set < string > getserverxmlfeatures ( set < string > origresult , file serverfile , list < file > parsedxmls ) { set < string > result = origresult ; list < file > updatedparsedxmls = parsedxmls != null ? parsedxmls : new arraylist < file > ( ) ; file canonicalserverfile ; try { canonicalserverfile = serverfile . getcanonicalfile ( ) ; } catch ( ioexception e ) {	Adds features from the given server file into the origResult or a new setif origResult is null.
private set < string > parseincludenode ( set < string > origresult , file serverfile , element node , list < file > updatedparsedxmls ) { set < string > result = origresult ; string includefilename = node . getattribute ( str_ ) ; if ( includefilename == null || includefilename . trim ( ) . isempty ( ) ) { return result ; } file includefile = null ; if ( isurl ( includefilename ) ) { try { file tempfile = file . createtempfile ( str_ , str_ ) ; fileutils . copyurltofile ( new url ( includefilename ) , tempfile , copy_file_timeout_millis , copy_file_timeout_millis ) ; includefile = tempfile ; } catch ( ioexception e ) {	Parse features from an include node.
private static set < string > parsefeaturemanagernode ( element node ) { set < string > result = new hashset < string > ( ) ; nodelist features = node . getelementsbytagname ( str_ ) ; if ( features != null ) { for ( int j = num_ ; j < features . getlength ( ) ; j ++ ) { string content = features . item ( j ) . gettextcontent ( ) ; if ( content != null ) { if ( content . contains ( str_ ) ) { string [ ] split = content . split ( str_ , num_ ) ; result . add ( split [ num_ ] . trim ( ) . tolowercase ( ) ) ; } else { result . add ( content . trim ( ) . tolowercase ( ) ) ; } } } } return result ; }	Parse feature elements from a featureManager node, trimming whitespaceand treating everything as lowercase.
private file downloadjsons ( string productid , string productversion ) { string jsongroupid = productid + str_ ; try { return downloadartifact ( jsongroupid , str_ , str_ , productversion ) ; } catch ( pluginexecutionexception e ) { debug ( str_ + productid + str_ + productversion , e ) ; return null ; } }	Download the JSON file for the given product.
public static set < string > getopenlibertyfeatureset ( set < file > jsons ) throws pluginexecutionexception { set < string > libertyfeatures = new hashset < string > ( ) ; for ( file file : jsons ) { scanner s = null ; try { s = new scanner ( file ) ;	Gets the set of all Open Liberty features by scanning the product JSONs.
private boolean isonlyopenlibertyfeatures ( list < string > featurestoinstall ) throws pluginexecutionexception { boolean result = containsignorecase ( getopenlibertyfeatureset ( downloadedjsons ) , featurestoinstall ) ; debug ( str_ + result ) ; return result ; }	Returns true if all features in featuresToInstall are Open Liberty features.
public static boolean containsignorecase ( collection < string > reference , collection < string > target ) { return tolowercase ( reference ) . containsall ( tolowercase ( target ) ) ; }	Returns whether the reference collection contains all of the strings in the target collection, ignoring case.
public static string getnextproductversion ( string version ) throws pluginexecutionexception { string result = null ; int versionsplittingindex = version . lastindexof ( str_ ) + num_ ; if ( versionsplittingindex == num_ ) { throw new pluginexecutionexception ( str_ + version + str_ ) ; } string quarterversion = version . substring ( versionsplittingindex ) ; int nextquarterspecifier ; try { nextquarterspecifier = integer . parseint ( quarterversion ) + num_ ; } catch ( numberformatexception e ) { throw new pluginexecutionexception ( str_ + version + str_ , e ) ; } result = version . substring ( num_ , versionsplittingindex ) + nextquarterspecifier ; return result ; }	Gets the next product version number.
public static string extractsymbolicname ( file jar ) throws pluginexecutionexception { jarfile jarfile = null ; try { jarfile = new jarfile ( jar ) ; return jarfile . getmanifest ( ) . getmainattributes ( ) . getvalue ( str_ ) ; } catch ( ioexception e ) { throw new pluginexecutionexception ( str_ + jar . getabsolutepath ( ) , e ) ; } finally { if ( jarfile != null ) { try { jarfile . close ( ) ; } catch ( ioexception e ) {	Extracts the bundle symbolic name from the jar manifest.
public static file getmapbasedinstallkerneljar ( file dir ) { file [ ] installmapjars = dir . listfiles ( new filenamefilter ( ) { @ override public boolean accept ( file dir , string name ) { return name . startswith ( install_map_prefix ) && name . endswith ( install_map_suffix ) ; } } ) ; file result = null ; if ( installmapjars != null ) { for ( file jar : installmapjars ) { if ( isreplacementjar ( result , jar ) ) { result = jar ; } } } return result ; }	Find latest install map jar from specified directory.
private static boolean isreplacementjar ( file file1 , file file2 ) { if ( file1 == null ) { return bool_ ; } else if ( file2 == null ) { return bool_ ; } else { string version1 = extractversion ( file1 . getname ( ) ) ; string version2 = extractversion ( file2 . getname ( ) ) ; return compare ( version1 , version2 ) < num_ ; } }	Returns whether file2 can replace file1 as the install map jar.
private static string extractversion ( string filename ) { int startindex = install_map_prefix . length ( ) + num_ ;	Returns the extracted version from fileName.
private static int compare ( string version1 , string version2 ) { if ( version1 == null && version2 == null ) { return num_ ; } else if ( version1 == null && version2 != null ) { return - num_ ; } else if ( version1 != null && version2 == null ) { return num_ ; } string [ ] components1 = version1 . split ( str_ ) ; string [ ] components2 = version2 . split ( str_ ) ; for ( int i = num_ ; i < components1 . length && i < components2 . length ; i ++ ) { int comparison ; try { comparison = new integer ( components1 [ i ] ) . compareto ( new integer ( components2 [ i ] ) ) ; } catch ( numberformatexception e ) { comparison = components1 [ i ] . compareto ( components2 [ i ] ) ; } if ( comparison != num_ ) { return comparison ; } } return components1 . length - components2 . length ; }	Performs pairwise comparison of version strings, including nulls and non-integer components.
public static string productinfo ( file installdirectory , string action ) throws pluginexecutionexception { process pr = null ; inputstream is = null ; scanner s = null ; worker worker = null ; try { string command ; if ( osutil . iswindows ( ) ) { command = installdirectory + str_ + action ; } else { command = installdirectory + str_ + action ; } pr = runtime . getruntime ( ) . exec ( command ) ; worker = new worker ( pr ) ; worker . start ( ) ; worker . join ( num_ ) ; if ( worker . exit == null ) { throw new pluginexecutionexception ( str_ ) ; } int exitvalue = pr . exitvalue ( ) ; if ( exitvalue != num_ ) { throw new pluginexecutionexception ( str_ + exitvalue ) ; } is = pr . getinputstream ( ) ; s = new scanner ( is ) ;	Runs the productInfo command and returns the output.
public static boolean isspringbootuberjar ( file artifact ) { if ( artifact == null || ! artifact . exists ( ) || ! artifact . isfile ( ) ) { return bool_ ; } try ( jarfile jarfile = new jarfile ( artifact ) ) { manifest manifest = jarfile . getmanifest ( ) ; if ( manifest != null ) { attributes attributes = manifest . getmainattributes ( ) ; if ( attributes . getvalue ( boot_version_attribute ) != null && attributes . getvalue ( boot_start_class_attribute ) != null ) { return bool_ ; } else {	Check whether the given artifact is a Spring Boot Uber JAR.
private static libertypropertyi getarquillianproperty ( string key , class < ? > cls ) throws arquillianconfigurationexception { try { if ( cls == libertymanagedobject . libertymanagedproperty . class ) { return libertymanagedobject . libertymanagedproperty . valueof ( key ) ; } else if ( cls == libertyremoteobject . libertyremoteproperty . class ) { return libertyremoteobject . libertyremoteproperty . valueof ( key ) ; } } catch ( illegalargumentexception e ) { throw new arquillianconfigurationexception ( str_ + key + str_ ) ; } throw new arquillianconfigurationexception ( str_ ) ; }	Check that the given key exists in ArquillianProperties.
@ override public boolean isworkinginthisenvironment ( string forfile ) { return ! graphicsenvironment . isheadless ( ) && genericdiffreporter . isfileextensionvalid ( forfile , genericdiffreporter . image_file_extensions ) ; }	We assume any environment that is not headless will have a web browser to display the image in a web page.
private static void movebacktocenter ( double length ) { tortoise . setpenup ( ) ; tortoise . turn ( num_ ) ; tortoise . move ( length / num_ ) ; tortoise . turn ( num_ ) ; tortoise . move ( length / num_ ) ; tortoise . turn ( num_ ) ; tortoise . setpendown ( ) ;	Create the moveBackToCenter recipe.
public static boolean isequal ( object s1 , object s2 ) { return s1 == s2 || ( s1 != null ) && s1 . equals ( s2 ) ; }	A convenience function to check if two objects are equal.
public static int load ( string i , int defaultvalue , boolean stripnonnumeric ) { try { i = stripnonnumeric ? stringutils . stripnonnumeric ( i , bool_ , bool_ ) : i ; defaultvalue = integer . parseint ( i ) ; } catch ( exception ignored ) { } return defaultvalue ; }	Loads an int from a String.
private tortoise [ ] throwpizzaparty ( ) { tortoise karai = new tortoise ( ) ; tortoise cecil = new tortoise ( ) ; tortoise michealangelo = new tortoise ( ) ; tortoise fred = new tortoise ( ) ; return new tortoise [ ] { karai , cecil , michealangelo , fred } ; }	Ignore the following, It's needed to run the deep dive.
public static void verify ( ) { try { approvals . verify ( turtle . getimage ( ) ) ; } catch ( exception e ) { throw objectutils . throwaserror ( e ) ; } finally { tortoiseutils . resetturtle ( ) ; } }	Captures an image of the result of your program and displays it to you.
public puzzle swapblank ( int target ) { int [ ] copy = arrays . copyof ( cells , cells . length ) ; int x = copy [ target ] ; copy [ getblankindex ( ) ] = x ; copy [ target ] = num_ ; return new puzzle ( copy ) ; }	Create a copy of the puzzle where the blank swapped with the value in the target position.
public int getdistancetogoal ( ) { int distance = num_ ; for ( int i = num_ ; i < cells . length ; i ++ ) { distance += getdistance ( i , cells [ i ] ) ; } return distance ; }	Calculate the distance between the goal by summing the distance between each cell and its goal.
public static void printf ( string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	Prints a formatted string to standard output, using the specified formatstring and arguments, and then flushes standard output.
public static void printf ( locale locale , string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	Prints a formatted string to standard output, using the locale andthe specified format string and arguments; then flushes standard output.
public static void makeafishydecision ( int numberoffish ) {	recipe for makeAFishyDecision with the numberOfFish.
public synchronized static void variable ( string name , object value ) { if ( ! variable ) { return ; } system . out . println ( timestamp ( ) + str_ + name + str_ + ( value == null ? null : value . tostring ( ) ) + str_ ) ; }	Prints to screen any variable information to be viewed.
public static int uniform ( int a , int b ) { if ( b <= a ) throw new illegalargumentexception ( str_ ) ; if ( ( long ) b - a >= integer . max_value ) throw new illegalargumentexception ( str_ ) ; return a + uniform ( b - a ) ; }	Returns a random integer uniformly in [a, b).
public static double uniform ( double a , double b ) { if ( ! ( a < b ) ) throw new illegalargumentexception ( str_ ) ; return a + uniform ( ) * ( b - a ) ; }	Returns a random real number uniformly in [a, b).
public static int poisson ( double lambda ) { if ( ! ( lambda > num_ ) ) throw new illegalargumentexception ( str_ ) ; if ( double . isinfinite ( lambda ) ) throw new illegalargumentexception ( str_ ) ;	Returns a random integer from a Poisson distribution with mean &lambda;.
public static int discrete ( double [ ] a ) { if ( a == null ) throw new nullpointerexception ( str_ ) ; double epsilon = num_ ; double sum = num_ ; for ( int i = num_ ; i < a . length ; i ++ ) { if ( ! ( a [ i ] >= num_ ) ) throw new illegalargumentexception ( str_ + i + str_ + a [ i ] ) ; sum = sum + a [ i ] ; } if ( sum > num_ + epsilon || sum < num_ - epsilon ) throw new illegalargumentexception ( str_ + sum ) ;	Returns a random integer from the specified discrete distribution.
public static final string capitalizefirstchar ( string word ) { return character . touppercase ( word . charat ( num_ ) ) + word . substring ( num_ ) ; }	Capitalizes the first character of the word given.It will convert i to I.
public static final string uncapitalizefirstchar ( string word ) { return character . tolowercase ( word . charat ( num_ ) ) + word . substring ( num_ ) ; }	Un capitalizes the first character of the word given.It will convert i to I.
private string fixpath ( string path ) { if ( ! path . isempty ( ) ) { if ( ! path . endswith ( str_ ) ) return path + str_ ; else return path ; } else return path ; }	Helps to fix path.
public static string jointostring ( criteriajoin criteriajoin ) { stringbuilder builder = new stringbuilder ( str_ ) . append ( criteriajoin . getentityclass ( ) . getname ( ) ) . append ( str_ ) . append ( criteriajoin . getalias ( ) ) . append ( str_ ) . append ( str_ ) ; if ( criteriajoin . getjoinrelations ( ) . size ( ) == num_ ) { throw new runtimeexception ( str_ + criteriajoin . getalias ( ) + str_ ) ; } stringjoiner joiner = new stringjoiner ( str_ ) ; list < joinrelation > relationlist = criteriajoin . getjoinrelations ( ) ; for ( joinrelation joinrelation : relationlist ) { stringbuilder relationbuilder = new stringbuilder ( str_ ) . append ( joinrelation . getrelationcriteria ( ) . getalias ( ) ) . append ( str_ ) . append ( joinrelation . getrelationfield ( ) ) . append ( str_ ) . append ( joinrelation . getjoinedcriteria ( ) . getalias ( ) ) . append ( str_ ) . append ( joinrelation . getjoinedfield ( ) ) ; joiner . add ( relationbuilder . tostring ( ) ) ; } if ( joiner . length ( ) > num_ ) { builder . append ( joiner . tostring ( ) ) ; } return builder . tostring ( ) ; }	Generates Join Query for the given JoinCriteria.
public static string gettokensentence ( basictoken token ) throws exception { if ( token == null ) return tokenkey + str_ + cookiesentence ; string sentence = tokenkey + str_ + token . gettokenstring ( ) + cookiesentence ;	Combines the token and cookie sentence.
@ override public void filter ( containerrequestcontext requestcontext , containerresponsecontext responsecontext ) throws ioexception { string authtoken = extractauthtokenfromcookielist ( requestcontext . getheaders ( ) . getfirst ( str_ ) ) ; if ( authtoken != null && authtoken . length ( ) != num_ ) { try { basictoken token = new basictoken ( authtoken ) ; if ( token . isexpired ( ) ) { logger . debug ( str_ + token . getexpirationdate ( ) . tostring ( ) ) ; logger . debug ( str_ + datetime . now ( ) . todate ( ) . tostring ( ) ) ; responsecontext . getheaders ( ) . putsingle ( str_ , gettokensentence ( null ) ) ; responsecontext . setstatusinfo ( response . status . unauthorized ) ; responsecontext . setentity ( str_ ) ; logger . info ( str_ ) ; } else { token . setexpiration ( token . getmaxage ( ) ) ; if ( ! logoutpath . equals ( requestcontext . geturiinfo ( ) . getpath ( ) ) ) { string cookie = gettokensentence ( token ) ; responsecontext . getheaders ( ) . putsingle ( str_ , cookie ) ; } } } catch ( exception e ) { logger . error ( str_ , e . getmessage ( ) ) ; responsecontext . setstatusinfo ( response . status . unauthorized ) ; } } }	Checks the expiration date of token.Renews and puts at header of response.
private string extractauthtokenfromcookielist ( string cookielist ) { if ( cookielist == null || cookielist . length ( ) == num_ ) { return null ; } string [ ] cookies = cookielist . split ( str_ ) ; for ( string cookie : cookies ) { if ( cookie . trim ( ) . startswith ( tokenkey ) ) { return cookie . trim ( ) . substring ( tokenkey . length ( ) + num_ ) ; } } return null ; }	Extracts the accesstoken from cookies.
public static void registerguicebound ( injector injector , final jerseyenvironment environment ) { while ( injector != null ) { for ( key < ? > key : injector . getbindings ( ) . keyset ( ) ) { type type = key . gettypeliteral ( ) . gettype ( ) ; if ( type instanceof class ) { class < ? > c = ( class ) type ; if ( isproviderclass ( c ) ) { logger . info ( str_ , c . getname ( ) ) ; environment . register ( c ) ; } else if ( isrootresourceclass ( c ) ) {	Registers any Guice-bound providers or root resources.
private void getallrolepermissions ( roleentry parent , set < permissionentry > rolepermissions ) { rolepermissions . addall ( permissionstore . findbyroleid ( parent . getid ( ) ) ) ; set < rolegroupentry > rolegroupentries = ( set < rolegroupentry > ) rolegroupstore . findbygroupid ( parent . getid ( ) ) ; for ( rolegroupentry entry : rolegroupentries ) { optional < roleentry > role = ( optional < roleentry > ) rolestore . findbyroleid ( entry . getroleid ( ) ) ; getallrolepermissions ( role . get ( ) , rolepermissions ) ; } }	Fill permission list with role and sub-role permissions recursively.
public projectionlist add ( projection projection , string alias ) { return add ( projections . alias ( projection , alias ) ) ; }	Adds a projection to this list of projections after wrapping it with an alias.
public static jobdetail convert2jobdetail ( jobinfo info ) { jobkey jobkey = jobkey . jobkey ( info . getname ( ) ) ; jobdetail jobdetail = newjob ( info . getjobclass ( ) ) . withidentity ( jobkey ) . build ( ) ; return jobdetail ; }	Creates an identical JobDetail instance from the given parameters.
public static trigger convert2trigger ( triggerinfo trig , jobinfo job ) { triggerbuilder < trigger > builder = newtrigger ( ) ; builder . withidentity ( trig . getname ( ) , trig . getgroup ( ) ) ; builder . forjob ( job . getname ( ) , job . getgroup ( ) ) ; switch ( trig . gettype ( ) ) { case cron : setstartendtime ( trig , builder ) ; if ( ! trig . getcron ( ) . isempty ( ) ) builder . withschedule ( cronschedulebuilder . cronschedule ( trig . getcron ( ) ) ) ; break ; case simple : setstartendtime ( trig , builder ) ; setcountintervalvalues ( trig , builder ) ; break ; } return builder . build ( ) ; }	Creates an identical Trigger instance from the given annotation.
private static void setcountintervalvalues ( triggerinfo dto , triggerbuilder < org . quartz . trigger > builder ) { simpleschedulebuilder buildersc = simpleschedulebuilder . simpleschedule ( ) ; if ( dto . getrepeatcount ( ) != num_ ) buildersc . withrepeatcount ( dto . getrepeatcount ( ) ) ; if ( dto . getrepeatinterval ( ) > num_ ) buildersc . withintervalinmilliseconds ( dto . getrepeatinterval ( ) ) ; builder . withschedule ( buildersc ) ; }	Helps to set count and intervals.
private static void setstartendtime ( triggerinfo dto , triggerbuilder < org . quartz . trigger > builder ) { if ( dto . getstarttime ( ) > - num_ ) builder . startat ( new date ( dto . getstarttime ( ) ) ) ; else builder . startnow ( ) ; if ( dto . getendtime ( ) > - num_ ) builder . endat ( new date ( dto . getendtime ( ) ) ) ; }	Helps to set start and end times.
public static boolean sendmail ( mailitem item ) { logger . debug ( str_ + item . tostring ( ) ) ; boolean result = queue . add ( item ) ; logger . info ( str_ + queue . size ( ) ) ;	Takes the mail item into the queue and manages the mail sender thread.If thread is alive it will send the mail at the end of current thread queue.Else a new thread will be created and started.
@ override public void write ( outputstream output ) throws ioexception , webapplicationexception {	Called to write the message body.
private void initializescheduler ( properties properties ) throws schedulerexception { schedulerfactory factory = new stdschedulerfactory ( properties ) ; scheduler scheduler = factory . getscheduler ( ) ; scheduler . start ( ) ; jobmanager . initialize ( scheduler ) ; }	Initialize scheduler and start JobManager.
protected final collection < fieldentry > getfields ( class clazz ) { linkedlist < fieldentry > fieldlist = getallfields ( clazz ) ; collections . sort ( fieldlist , new comparator < fieldentry > ( ) { public int compare ( fieldentry o1 , fieldentry o2 ) { return o1 . compareto ( o2 ) ; } } ) ; return fieldlist ; }	Returns an ordered list of the fields which belongs to the given class.
protected final map < string , field > getfieldmap ( class clazz ) { map < string , field > fieldlist = new hashmap < string , field > ( ) ; for ( fieldentry entry : getallfields ( clazz ) ) { field field = entry . getvalue ( ) ; fieldlist . put ( field . getname ( ) , field ) ; } return fieldlist ; }	Returns a map of the fields which belongs to the given class with field name as key.
public static void configure ( tokenbasedauthconfiguration configuration ) { encryptor . setpoolsize ( configuration . getpoolsize ( ) ) ;	Configure method for Token generation configurations and encryptor configure.
private void generateattributeshash ( map < string , string > attributes ) { stringbuilder attr = new stringbuilder ( ) ; attr . append ( attributes . get ( str_ ) ) ;	Generates attribute has with 'userAgent', 'remoteAddr' keys.Combines them and hashes with SHA256 and sets the variable.
private string generatetokenstring ( ) throws exception {	Generates a tokenString with a new expiration date and assigns it.
public void sendmessage ( mailitem item ) throws messagingexception { checknotnull ( item . getreceivers ( ) ) ; checknotnull ( item . getreceivers ( ) . get ( num_ ) ) ; checknotnull ( item . gettitle ( ) ) ; checknotnull ( item . getbody ( ) ) ;	Sends a mail with the given item.
public string generatestrongpassword ( t user , string oldpassword ) { string newpassword ; do { newpassword = generatestrongpassword ( ) ;	Generate strong password that takes into account the user's information and old password.
public t getuser ( string accountname ) { optional < t > optional = ( optional < t > ) userstore . findbyusername ( accountname ) ; if ( optional . ispresent ( ) ) { return optional . get ( ) ; } else { return null ; } }	Returns the UserEntry matching the provided accountName.
public string hashpassword ( string password , string accountname ) { return hashing . sha256 ( ) . hashstring ( password , charset . forname ( str_ ) ) . tostring ( ) ; }	Returns a string representation of the hashed password, using theaccountName as the salt.
public void verifyaccountnamestrength ( string accountname ) throws authenticationexception { matcher matcher = pattern . matcher ( accountname ) ; if ( ! matcher . matches ( ) ) { throw new authenticationexception ( accountname + str_ ) ; } }	Ensures that the account name passes site-specific complexity requirements, like minimum length.
private void success ( ) { org . hibernate . transaction txn = session . gettransaction ( ) ; if ( txn != null && txn . getstatus ( ) . equals ( transactionstatus . active ) ) { txn . commit ( ) ; } }	If transaction is present and active then commit.
private void error ( ) { org . hibernate . transaction txn = session . gettransaction ( ) ; if ( txn != null && txn . getstatus ( ) . equals ( transactionstatus . active ) ) { txn . rollback ( ) ; } }	If transaction is present and active then rollback.
private void start ( ) { try { before ( ) ; transactionwrapper . wrap ( ) ; success ( ) ; } catch ( exception e ) { error ( ) ; if ( exceptionhandler != null ) { exceptionhandler . onexception ( e ) ; } else { throw e ; } } finally { finish ( ) ; } }	Starts the progress.
private boolean isauthorized ( basictoken token , list < uritemplate > matchedtemplates , string method ) { stringbuilder path = new stringbuilder ( ) ;	Merges all path patterns and and creates a single string value which will be equal with service methods pathannotation value and HTTP method type.
@ override public date parse ( object o , field field ) { if ( ! isvalid ( o ) ) { return null ; } jsonformat formatann = field . getannotation ( jsonformat . class ) ; if ( formatann == null ) { throw new runtimeexception ( str_ + field . getname ( ) ) ; } try { return new simpledateformat ( formatann . pattern ( ) , locale . getdefault ( ) ) . parse ( o . tostring ( ) ) ; } catch ( parseexception e ) { throw new runtimeexception ( str_ + field . getname ( ) + str_ + formatann . pattern ( ) ) ; } }	First it checks is there any annotation class for parsing operations,if it is, parses with given format, if there is a exception whileparsing with given format catches and tries with default values,If there is no given format, tries with static values.
public response getresponse ( ) { return response . status ( response . status . internal_server_error ) . entity ( builder . build ( ) ) . build ( ) ; }	Gets current response created with exception parameters.
public static restriction eq ( string name , object value ) { return new restriction ( operator . equals , name , value ) ; }	generates '=' equals.
public static restriction ne ( string name , object value ) { return new restriction ( operator . not_equals , name , value ) ; }	'!=' not equals operator.
public static restriction lt ( string name , object object ) { return new restriction ( operator . less_than , name , object ) ; }	'<' less than operator.
public static restriction le ( string name , object value ) { return new restriction ( operator . less_or_equals_than , name , value ) ; }	'<=' less or equals than operator.
public static restriction gt ( string name , object value ) { return new restriction ( operator . greater_than , name , value ) ; }	'>' greater than operator.
public static restriction ge ( string name , object value ) { return new restriction ( operator . greater_or_equals_than , name , value ) ; }	'>=' greater or equals than operator.
public static restriction ilike ( string name , object value ) { return new restriction ( operator . contains , name , value ) ; }	'~=' contains than operator.
public static restriction in ( string name , object value ) { return new restriction ( operator . in , name , value ) ; }	'|=' in list operator.
public namespacemanager withnamespace ( string namespace , string href ) { if ( namespaces . containskey ( namespace ) ) { throw new representationexception ( format ( str_ , namespace ) ) ; } if ( ! href . contains ( str_ ) ) { throw new representationexception ( format ( str_ , namespace ) ) ; } return new namespacemanager ( namespaces . put ( namespace , href ) ) ; }	Update the list of declared namespaces with a new namespace.
public resourcerepresentation < v > withcontent ( bytestring content ) { return new resourcerepresentation < > ( option . of ( content ) , links , rels , namespacemanager , value , resources ) ; }	Adds or replaces the content of the representation.
public resourcerepresentation < v > withrel ( rel rel ) { if ( rels . containskey ( rel . rel ( ) ) ) { throw new illegalstateexception ( string . format ( str_ , rel . rel ( ) ) ) ; } final treemap < string , rel > updatedrels = rels . put ( rel . rel ( ) , rel ) ; return new resourcerepresentation < > ( content , links , updatedrels , namespacemanager , value , resources ) ; }	Define rel semantics for this representation.
public < r > resourcerepresentation < r > withvalue ( r newvalue ) { return new resourcerepresentation < > ( option . none ( ) , links , rels , namespacemanager , newvalue , resources ) ; }	Replace the value of this resource with a new value, optionally of a new type.
public resourcerepresentation < v > withnamespace ( string namespace , string href ) { if ( ! rels . containskey ( str_ ) ) { rels = rels . put ( str_ , rels . collection ( str_ ) ) ; } final namespacemanager updatednamespacemanager = namespacemanager . withnamespace ( namespace , href ) ; return new resourcerepresentation < > ( content , links , rels , updatednamespacemanager , value , resources ) ; }	Adds a new namespace.
public static boolean candecode ( byte [ ] input , int off , int len ) { try { decode ( input , off , len ) ; } catch ( illegalargumentexception ex ) { return bool_ ; } return bool_ ; }	Returns whether the specified range in the given byte array representsvalid UTF-8 encoded characters.
public static byte [ ] encode ( string str , int off , int len ) { return encode ( str . substring ( off , off + len ) ) ; }	Returns the UTF-8 encoding of the specified character sequence.
public static boolean equal ( reader in1 , reader in2 ) throws ioexception { if ( in1 == in2 ) { return bool_ ; } if ( in1 == null || in2 == null ) { return bool_ ; } in1 = buffer ( in1 ) ; in2 = buffer ( in2 ) ; int c1 = in1 . read ( ) ; int c2 = in2 . read ( ) ; while ( c1 != - num_ && c2 != - num_ && c1 == c2 ) { c1 = in1 . read ( ) ; c2 = in2 . read ( ) ; } return in1 . read ( ) == - num_ && in2 . read ( ) == - num_ ; }	Returns whether the given streams have the same content.
public static void mv ( file src , file dst ) throws ioexception { parameters . checknotnull ( dst ) ; if ( ! src . equals ( dst ) ) { cp ( src , dst ) ; try { rm ( src ) ; } catch ( ioexception e ) { rm ( dst ) ; throw new ioexception ( str_ + src , e ) ; } } }	Moves a file from one path to another.
public static void touch ( file ... files ) throws ioexception { long now = system . currenttimemillis ( ) ; for ( file f : files ) { if ( ! f . createnewfile ( ) && ! f . setlastmodified ( now ) ) { throw new ioexception ( str_ + f ) ; } } }	Creates empty files at the specified paths or updates the lastmodification time of the files at the specified paths.
public static string getbasename ( file f ) { string filename = f . getname ( ) ; int index = filename . lastindexof ( str_ ) ; return index == - num_ ? filename : filename . substring ( num_ , index ) ; }	Returns the file name without its path or extension.
private void addpadding ( ) { int len = block_length - bufferlen ; if ( len < num_ ) { len += block_length ; } byte [ ] buf = new byte [ len ] ; buf [ num_ ] = ( byte ) num_ ; for ( int i = num_ ; i < len - num_ ; i ++ ) { buf [ i ] = ( byte ) num_ ; } counter = ( counter + ( long ) bufferlen ) * num_ ; littleendian . encode ( counter , buf , len - num_ ) ; update ( buf ) ; }	Adds the padding bits and the message length to the input data.
public static string getshortname ( class < ? > c ) { string qname = getqualifiedname ( c ) ; int start = qname . lastindexof ( str_ ) ; if ( start == - num_ ) { start = qname . lastindexof ( str_ ) ; } return qname . substring ( start + num_ ) ; }	Returns only the name of the given class, that is, without itspackage name and without its eventual "outer" class name.
public static set < class < ? > > getsupertypes ( class < ? > c ) { set < class < ? > > classes = new hashset < class < ? > > ( ) ; for ( class < ? > clazz : c . getinterfaces ( ) ) { classes . add ( clazz ) ; classes . addall ( getsupertypes ( clazz ) ) ; } class < ? > sup = c . getsuperclass ( ) ; if ( sup != null ) { classes . add ( sup ) ; classes . addall ( getsupertypes ( sup ) ) ; } return collections . unmodifiableset ( classes ) ; }	Returns all the super types of the given class, that is, all theclasses in which any instance of the given class can be cast into.
public static boolean verify ( string password , byte [ ] hash ) { byte [ ] h = arrays . copyof ( hash , hash_length + salt_length + num_ ) ; int n = num_ << ( h [ hash_length + salt_length ] & num_ ) ; int r = h [ hash_length + salt_length + num_ ] & num_ ; int p = h [ hash_length + salt_length + num_ ] & num_ ; if ( n > n || n < n_min || r > r || r < r_min || p > p || p < p_min ) { n = n ; r = r ; p = p ; } byte [ ] salt = new byte [ salt_length ] ; system . arraycopy ( h , hash_length , salt , num_ , salt_length ) ; byte [ ] expected = hash ( password , salt , r , n , p ) ; int result = num_ ; for ( int i = num_ ; i < h . length ; i ++ ) { result |= h [ i ] ^ expected [ i ] ; } return result == num_ ; }	Verifies that the given password matches the hashed one.
public static string readstring ( charset charset ) throws ioexception { reader in = new inputstreamreader ( system . in , charset ) ; bufferedreader reader = new bufferedreader ( in ) ; try { return reader . readline ( ) ; } finally { reader . close ( ) ; } }	Reads the next line from the standard input using the given charset.
public bytebuffer append ( byte b ) { int newcount = count + num_ ; ensurecapacity ( newcount ) ; buf [ count ] = b ; count = newcount ; return this ; }	Writes the given byte to this buffer.
public bytebuffer append ( byte [ ] bytes , int off , int len ) { int newcount = count + len ; ensurecapacity ( newcount ) ; system . arraycopy ( bytes , off , buf , count , len ) ; count = newcount ; return this ; }	Writes the given data to this buffer.
public static < t > t [ ] copyof ( t [ ] original ) { return arrays . copyof ( original , original . length ) ; }	Returns a copy of the given array.
public fraction plus ( fraction f ) { return new fraction ( n . multiply ( f . d ) . add ( f . n . multiply ( d ) ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Adds the given value to this one and returns the result in reducedform.
public fraction minus ( fraction f ) { return new fraction ( n . multiply ( f . d ) . subtract ( f . n . multiply ( d ) ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Subtracts the given value from this one and returns the result inreduced form.
public fraction multipliedby ( fraction f ) { return new fraction ( n . multiply ( f . n ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Multiplies this value by the given one and returns the result inreduced form.
public fraction dividedby ( fraction f ) { if ( zero . equals ( f ) ) { throw new arithmeticexception ( str_ ) ; } return new fraction ( n . multiply ( f . d ) , d . multiply ( f . n ) ) . reduced ( ) ; }	Divides this value by the given one and returns the result in reducedform.
public static long max ( long ... values ) { parameters . checkcondition ( values . length > num_ ) ; long max = values [ num_ ] ; for ( int i = num_ ; i < values . length ; i ++ ) { max = math . max ( max , values [ i ] ) ; } return max ; }	Returns the maximum of the given values.
public static long min ( long ... values ) { parameters . checkcondition ( values . length > num_ ) ; long min = values [ num_ ] ; for ( int i = num_ ; i < values . length ; i ++ ) { min = math . min ( min , values [ i ] ) ; } return min ; }	Returns the minimum of the given values.
public static void checkcondition ( boolean condition , string msg , object ... args ) { if ( ! condition ) { throw new illegalargumentexception ( format ( msg , args ) ) ; } }	Checks the truth of the given condition checking parameters validity.
public meteodata < locationforecast > fetchcontent ( double longitude , double latitude , int altitude ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( param_latitude , latitude ) . addparameter ( param_longitude , longitude ) . addparameter ( param_altitude , altitude ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch a LocationforecastLTS from the MET API, based on longitude, latitude and altitude.
public meteodata < sunrise > fetchcontent ( double longitude , double latitude , localdate date ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( param_latitude , latitude ) . addparameter ( param_longitude , longitude ) . addparameter ( param_date , zoneddatetimetoyyyymmdd ( date ) ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch a Sunrise from the MET API based on a given longitude, latitude and date.
public meteodata < sunrise > fetchcontent ( double longitude , double latitude , localdate from , localdate to ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( param_latitude , latitude ) . addparameter ( param_longitude , longitude ) . addparameter ( param_from , zoneddatetimetoyyyymmdd ( from ) ) . addparameter ( param_to , zoneddatetimetoyyyymmdd ( to ) ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch a Sunrise from the MET API based on a given longitude, latitude and date range.
public list < meteoextrasforecast > findhourlypointforecastsfromnow ( int hoursahead ) { list < meteoextrasforecast > pointextrasforecasts = new arraylist < > ( ) ; zoneddatetime now = getnow ( ) ; for ( int i = num_ ; i < hoursahead ; i ++ ) { zoneddatetime ahead = now . plushours ( i ) ; optional < pointforecast > pointforecast = getindexer ( ) . getpointforecast ( ahead ) ; pointforecast . ifpresent ( pof -> { optional < periodforecast > periodforecast = getindexer ( ) . gettightestfitperiodforecast ( pof . getfrom ( ) ) ; periodforecast . ifpresent ( pef -> pointextrasforecasts . add ( new meteoextrasforecast ( pof , pef ) ) ) ; } ) ; } return pointextrasforecasts ; }	Get all point forecasts from now and to the given hours ahead.
public optional < meteoextrasforecast > findnearestforecast ( zoneddatetime datetime ) { zoneddatetime dt = tozeromsn ( datetime . withzonesameinstant ( metzone ) ) ; pointforecast chosenforecast = null ; for ( forecast forecast : getlocationforecast ( ) . getforecasts ( ) ) { if ( forecast instanceof pointforecast ) { pointforecast pointforecast = ( pointforecast ) forecast ; if ( isdatematch ( dt , clonezoneddatetime ( pointforecast . getfrom ( ) ) ) ) { chosenforecast = pointforecast ; break ; } else if ( chosenforecast == null ) { chosenforecast = pointforecast ; } else if ( isnearerdate ( pointforecast . getfrom ( ) , dt , chosenforecast . getfrom ( ) ) ) { chosenforecast = pointforecast ; } } } if ( chosenforecast == null ) { return optional . empty ( ) ; } return optional . of ( new meteoextrasforecast ( chosenforecast , getindexer ( ) . getwidestfitperiodforecast ( chosenforecast . getfrom ( ) ) . orelse ( null ) ) ) ; }	Get the most accurate forecast for the given date.
public meteodata < weather > fetchcontent ( forecastquery query ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( str_ , query . getname ( ) ) . addparameter ( str_ , query . getlanguage ( ) . getvalue ( ) ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch a textforecast for a named forecast.
public meteoextraslongtermforecast createsimplelongtermforecast ( ) throws meteoexception { list < meteoextrasforecastday > forecastdays = new arraylist < > ( ) ; zoneddatetime dt = getnow ( ) ; for ( int i = num_ ; i <= num_ ; i ++ ) { zoneddatetime dti = dt . plusdays ( i ) ; if ( getindexer ( ) . hasforecastsforday ( dti ) ) { meteoextrasforecastday mefd = createsimpleforcastforday ( dti ) ; if ( mefd != null && mefd . getforecasts ( ) . size ( ) > num_ ) { forecastdays . add ( mefd ) ; } } } return new meteoextraslongtermforecast ( forecastdays ) ; }	Create a longterm forecast, but only with a small subset of the weather data fields.
public meteoextraslongtermforecast createlongtermforecast ( ) { list < meteoextrasforecastday > forecastdays = new arraylist < > ( ) ; zoneddatetime dt = tozerohmsn ( getlocationforecast ( ) . getcreated ( ) . plusdays ( num_ ) ) ; for ( int i = num_ ; i < series . getseries ( ) . size ( ) ; i ++ ) { createlongtermforecastday ( dt . plusdays ( i ) , series . getseries ( ) . get ( i ) ) . ifpresent ( forecastdays :: add ) ; } return new meteoextraslongtermforecast ( forecastdays ) ; }	Create a longterm forecast.
public static location fromcoordinates ( string coordinates ) { if ( coordinates == null ) { throw new illegalargumentexception ( str_ ) ; } matcher m = p . matcher ( coordinates ) ; if ( ! m . matches ( ) ) { throw new illegalargumentexception ( coordinates + str_ + p . pattern ( ) ) ; } try { double longitude = double . valueof ( m . group ( num_ ) ) ; double latitude = double . valueof ( m . group ( num_ ) ) ; integer altitude = num_ ; if ( m . group ( num_ ) != null ) { altitude = integer . valueof ( m . group ( num_ ) . substring ( num_ ) ) ; } return new location ( longitude , latitude , altitude , str_ ) ; } catch ( numberformatexception e ) { throw new illegalargumentexception ( coordinates + str_ + p . pattern ( ) ) ; } }	Create an untitled Location from coordinate string.
public meteodata < available > fetchcontent ( ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( str_ , null ) . skipquestionmarkinurl ( ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch a list of all available textforecasts.
public static optional < string > createwindsymbolname ( pointforecast pointforecast ) { if ( pointforecast == null || pointforecast . getwinddirection ( ) == null || pointforecast . getwindspeed ( ) == null ) { return optional . empty ( ) ; } return optional . of ( pointforecast . getwinddirection ( ) . getname ( ) . tolowercase ( ) + idformat . format ( pointforecast . getwindspeed ( ) . getbeaufort ( ) ) ) ; }	Create name for a wind symbol.This will be created as a mix of the Beaufort wind speed id and the wind direction.
public static optional < beaufortlevel > findbeaufortlevel ( pointforecast pointforecast ) { if ( pointforecast == null || pointforecast . getwindspeed ( ) == null ) { return optional . empty ( ) ; } return optional . ofnullable ( findunitbyid ( pointforecast . getwindspeed ( ) . getbeaufort ( ) ) ) ; }	Find matching Beaufort level for a given point forecast.This provides you with extra information about the wind speed specified in the forecast.
public static uri createuri ( string uri ) throws meteoexception { if ( uri == null ) { throw new meteoexception ( str_ ) ; } try { return new uri ( uri ) ; } catch ( urisyntaxexception e ) { throw new meteoexception ( e ) ; } }	Wrap the construction of URL's to avoid throwing of checked MalformedURLException.
public boolean issun ( zoneddatetime currentdate ) { if ( getsun ( ) . getneverrise ( ) ) { return bool_ ; } else if ( getsun ( ) . getneverset ( ) ) { return bool_ ; } return timewithinperiod ( currentdate ) ; }	Check if the sun is shining for a given time.
optional < pointforecast > getpointforecast ( zoneddatetime datetime ) { for ( forecast forecast : forecasts ) { if ( forecast instanceof pointforecast ) { pointforecast pointforecast = ( pointforecast ) forecast ; if ( createhourindexkey ( datetime ) . equals ( createhourindexkey ( clonezoneddatetime ( pointforecast . getfrom ( ) ) ) ) ) { return optional . of ( pointforecast ) ; } } } return optional . empty ( ) ; }	Get the PointForecast that matches the given time.
optional < periodforecast > getbestfitperiodforecast ( zoneddatetime from , zoneddatetime to ) { if ( from == null || to == null ) { return optional . empty ( ) ; }	Find the period forecast that has the best fitted forecast for a given period.This means a forecast covering the requested period, with to and from time closest possible to that period.
public meteodata < textlocationweather > fetchcontent ( double longitude , double latitude ) throws meteoexception { return fetchcontent ( longitude , latitude , textlocationlanguage . nb ) ; }	Fetch textforecasts and warnings for a geographical point or area, in Norwegian.
public meteodata < textlocationweather > fetchcontent ( double longitude , double latitude , textlocationlanguage language ) throws meteoexception { meteoresponse response = getmeteoclient ( ) . fetchcontent ( createserviceuribuilder ( ) . addparameter ( str_ , latitude ) . addparameter ( str_ , longitude ) . addparameter ( str_ , language . getvalue ( ) ) . build ( ) ) ; return new meteodata < > ( parser . parse ( response . getdata ( ) ) , response ) ; }	Fetch textforecasts and warnings for a geographical point or area.
private void updatedb ( ) throws sqlexception , liquibaseexception { system . out . println ( str_ ) ; try ( basicdatasource datasource = new basicdatasource ( ) ) { datasource . seturl ( fullconnectionstring ) ; datasource . setusername ( username ) ; datasource . setpassword ( password ) ; try ( java . sql . connection c = datasource . getconnection ( ) ) { database database = databasefactory . getinstance ( ) . findcorrectdatabaseimplementation ( new jdbcconnection ( c ) ) ;	Checks connection, retrieves appropriate changelog and performs database update.
private static string invokestringmethod ( final scriptengine jsengine , final object thiz , final string name , final object ... args ) throws nosuchmethodexception , scriptexception { return ( string ) ( ( invocable ) jsengine ) . invokemethod ( thiz , name , args ) ; }	Calls a method on a script object compiled during a previous script execution, which is retained in the state of the ScriptEngine.
public synchronized t acquire ( final datasource source ) throws datasourceexception { if ( object == null ) { if ( getreference ( ) == null ) { throw new illegalstateexception ( str_ ) ; } else { object = source . getobject ( getreference ( ) , objectclass ) ; } } return object ; }	Return the referenced object, potentially performing a remote DataStore lookup and deserialisation.
public static < t > referencedobject < t > getreferencedobject ( final class < t > clazz , final string ref ) { return new referencedobject < > ( clazz , ref , null ) ; }	Create a ReferencedObject that uses a remote reference to data present in an ObjectSource.
public static < t > referencedobject < t > getwrappedobject ( final class < t > clazz , final t obj ) { return new referencedobject < > ( clazz , null , obj ) ; }	Create a ReferencedObject that directly wraps an object without a reference.
private < t > t getconfig ( final class < t > configclass ) throws configurationexception { iterator < name > it = getservicepath ( ) . descendingpathiterator ( ) ; while ( it . hasnext ( ) ) { try ( inputstream in = getconfigurationstream ( configclass , it . next ( ) ) ) { return decoder . deserialise ( in , configclass ) ; } catch ( final configurationexception e ) { log . trace ( str_ , e ) ; } catch ( final codecexception | ioexception e ) { incrementerrors ( ) ; throw new configurationexception ( str_ + configclass . getsimplename ( ) , e ) ; } } incrementerrors ( ) ; throw new configurationexception ( str_ + configclass . getsimplename ( ) ) ; }	Acquire, decode and decrypt a configuration object from a data stream.
private static boolean getissubstitutorenabled ( final bootstrapconfiguration bootstrapconfig ) { final string enable_substitutor_config_key = str_ ; final boolean enable_substitutor_config_default = bool_ ;	Checks whether the string substitution functionality should be enabled.
@ override public < t > iterator < class < t > > createclassiterator ( final class < t > service , final string servicename , final classloader loader , final boolean ignoreonclassnotfound ) { final iterator < class < t > > delegateclassiterator = delegate . createclassiterator ( service , servicename , loader , ignoreonclassnotfound ) ; stream < class < t > > stream = streamsupport . stream ( spliterators . spliteratorunknownsize ( delegateclassiterator , spliterator . ordered ) , bool_ ) ; return stream . filter ( t -> ! t . getpackage ( ) . getname ( ) . startswith ( str_ ) ) . collect ( collectors . tolist ( ) ) . iterator ( ) ; }	Excludes all "com.sun.jersey" classes.
@ override public decoder getdecoder ( final bootstrapconfiguration bootstrap , final decoder defaultdecoder ) { final string decoder_config_key = str_ ; final string decoder ; try {	Returns the Decoder that should be used to interpret the configuration files.
public static < t > list < t > getservices ( final class < t > intf ) { objects . requirenonnull ( intf ) ; list < t > ret = new linkedlist < > ( ) ; for ( final t t : serviceloader . load ( intf ) ) { ret . add ( t ) ; } return ret ; }	Get all advertised service implementations of the specified interface.
public < t > t getmodule ( final class < t > interfaceimplemented , final string moduletype ) throws nullpointerexception {	Retrieves a module by its simple name, that implements a particular type T.
public synchronized inputstream acquire ( final datasource source ) throws datasourceexception { inputstream ret ; if ( data == null ) { if ( getreference ( ) == null ) { throw new illegalstateexception ( str_ ) ; } else { ret = source . getstream ( getreference ( ) ) ; } } else { ret = new bytearrayinputstream ( data ) ; } return ret ; }	Return the referenced data as a stream, potentially performing a remote lookup.
public synchronized long size ( final datasource source ) throws datasourceexception { if ( data == null ) { if ( getreference ( ) == null ) { throw new illegalstateexception ( str_ ) ; } else { return source . getdatasize ( getreference ( ) ) ; } } else { return data . length ; } }	Determine the size of the data.
public static referenceddata getwrappeddata ( final string ref , final byte [ ] data ) { return new referenceddata ( objects . requirenonnull ( ref ) , data ) ; }	Create a ReferencedData instance that wraps data but also has a reference.
public string getindex ( final int index ) { if ( index < num_ || index >= components . size ( ) ) { throw new illegalargumentexception ( str_ ) ; } return components . get ( index ) ; }	Get the components of the Name at the specified numeric index.
public name getprefix ( final int upperindex ) { if ( upperindex < num_ || upperindex > components . size ( ) ) { throw new illegalargumentexception ( str_ ) ; } return new name ( components . sublist ( num_ , upperindex ) ) ; }	Return a Name that consists of a subsection of the current Name.
boolean colored ( ) { return type == compiler . plain || type == compiler . ahead || type == compiler . behind ; }	is an arc colored, and hence on a color chain?.
boolean exec ( hsrepattern re , charsequence data , enumset < execflags > execflags ) throws regexexception { if ( num_ != ( re . guts . info & flags . reg_uimpossible ) ) { throw new regexexception ( str_ ) ; } eflags = num_ ; for ( execflags ef : execflags ) { switch ( ef ) { case notbol : eflags |= flags . reg_notbol ; break ; case noteol : eflags |= flags . reg_noteol ; break ; case looking_at : eflags |= flags . reg_looking_at ; break ; default : throw new runtimeexception ( str_ ) ; } } this . re = re ; this . g = re . guts ; this . data = data ; this . datalength = this . data . length ( ) ; if ( this . match != null ) { this . match . clear ( ) ; } else { this . match = lists . newarraylist ( ) ; } match . add ( null ) ;	exec - match regular expression.
private boolean cfindloop ( dfa d , dfa s , int [ ] coldp ) { int begin ; int end ; int cold ; int open ; int close ; int estart ; int estop ; boolean shorter = num_ != ( g . tree . flags & subre . shorter ) ; boolean hitend [ ] = new boolean [ num_ ] ; boolean lookingat = num_ != ( eflags & flags . reg_looking_at ) ; assert d != null && s != null ; close = num_ ; do { int [ ] cold0 = new int [ num_ ] ; if ( lookingat ) {	cfindloop - the heart of cfind.
private void subset ( runtimesubexpression sub , int begin , int end ) { int n = sub . number ; assert n > num_ ; while ( match . size ( ) < ( n + num_ ) ) { match . add ( null ) ; } match . set ( n , new regmatch ( begin , end ) ) ; }	subset - set any subexpression relevant to a successful subre.
private boolean cbrdissect ( runtimesubexpression t , int begin , int end ) { int i ; int n = t . number ; int len ; int paren ; int p ; int stop ; int min = t . min ; int max = t . max ; assert t . op == str_ ; assert n >= num_ ;	cbrdissect - determine backref subexpression matches.
private void cloneouts ( nfa nfa , state old , state from , state to , int type ) { arc a ; assert old != from ; for ( a = old . outs ; a != null ; a = a . outchain ) { nfa . newarc ( type , a . co , from , to ) ; } }	cloneouts - copy out arcs of a state to another state pair, modifying type.
private void optst ( subre t ) { if ( t == null ) { return ; } if ( t . left != null ) { optst ( t . left ) ; } if ( t . right != null ) { optst ( t . right ) ; } }	optst - optimize a subRE subtree.
private void markst ( subre t ) { assert t != null ; t . flags |= subre . inuse ; if ( t . left != null ) { markst ( t . left ) ; } if ( t . right != null ) { markst ( t . right ) ; } }	markst - mark tree nodes as INUSE.
private long nfanode ( subre t ) throws regexexception { long ret ; assert t . begin != null ; if ( log . isdebugenabled ( ) && is_debug ) { log . debug ( string . format ( str_ , t . shortid ( ) ) ) ; } nfa newnfa = new nfa ( nfa ) ; newnfa . dupnfa ( t . begin , t . end , newnfa . init , newnfa . finalstate ) ; newnfa . specialcolors ( ) ; ret = newnfa . optimize ( ) ; t . cnfa = newnfa . compact ( ) ;	nfanode - do one NFA for nfatree.
private subre parse ( int stopper , int type , state initstate , state finalstate ) throws regexexception { state left ; state right ; subre branches ; subre branch ; subre t ; int firstbranch ; assert stopper == str_ || stopper == eos ; branches = new subre ( str_ , subre . longer , initstate , finalstate ) ; branch = branches ; firstbranch = num_ ; do { if ( num_ == firstbranch ) { branch . right = new subre ( str_ , subre . longer , initstate , finalstate ) ; branch = branch . right ; } firstbranch = num_ ; left = nfa . newstate ( ) ; right = nfa . newstate ( ) ; nfa . emptyarc ( initstate , left ) ; nfa . emptyarc ( right , finalstate ) ; branch . left = parsebranch ( stopper , type , left , right , bool_ ) ; branch . flags |= up ( branch . flags | branch . left . flags ) ; if ( ( branch . flags & ~ branches . flags ) != num_ ) { for ( t = branches ; t != branch ; t = t . right ) { t . flags |= branch . flags ; } } } while ( eat ( str_ ) ) ; assert see ( stopper ) || see ( eos ) ; if ( ! see ( stopper ) ) { assert stopper == str_ && see ( eos ) ;	parse - parse an REThis is actually just the top level, which parses a bunch of branchestied together with '|'.
private void deltraverse ( nfa nfa , state leftend , state s ) { arc a ; state to ; if ( s . nouts == num_ ) { return ; } if ( s . tmp != null ) { return ; } s . tmp = s ; while ( ( a = s . outs ) != null ) { to = a . to ; deltraverse ( nfa , leftend , to ) ; assert to . nouts == num_ || to . tmp != null ; nfa . freearc ( a ) ; if ( to . nins == num_ && to . tmp == null ) { assert to . nouts == num_ ; nfa . freestate ( to ) ; } } assert s . no != state . freestate ; assert s == leftend || s . nins != num_ ; assert s . nouts == num_ ; s . tmp = null ; }	deltraverse - the recursive heart of delsubThis routine's basic job is to destroy all out-arcs of the state.
private void nonword ( int dir , state lp , state rp ) { int anchor = ( dir == ahead ) ? str_ : str_ ; assert dir == ahead || dir == behind ; nfa . newarc ( anchor , ( short ) num_ , lp , rp ) ; nfa . newarc ( anchor , ( short ) num_ , lp , rp ) ; cm . colorcomplement ( nfa , dir , wordchrs , lp , rp ) ; }	nonword - generate arcs for non-word-character ahead or behind.
private void word ( int dir , state lp , state rp ) { assert dir == ahead || dir == behind ; cloneouts ( nfa , wordchrs , lp , rp , dir ) ; }	word - generate arcs for word character ahead or behind.
private int scannum ( ) throws regexexception { int n = num_ ; while ( see ( digit ) && n < dupmax ) { n = n * num_ + nextvalue ; lex . next ( ) ; } if ( see ( digit ) || n > dupmax ) { throw new regexexception ( str_ ) ; } return n ; }	scannum - scan a number.
private void bracket ( state lp , state rp ) throws regexexception { assert see ( str_ ) ; lex . next ( ) ; while ( ! see ( str_ ) && ! see ( eos ) ) { brackpart ( lp , rp ) ; } assert see ( str_ ) ; cm . okcolors ( nfa ) ; }	bracket - handle non-complemented bracket expressionAlso called from cbracket for complemented bracket expressions.
private string scanplain ( ) throws regexexception { int startp = now ; int endp ; assert see ( collel ) || see ( eclass ) || see ( cclass ) ; lex . next ( ) ; endp = now ; while ( see ( plain ) ) { endp = now ; lex . next ( ) ; } string ret = new string ( pattern , startp , endp - startp ) ; assert see ( end ) ; lex . next ( ) ; return ret ; }	scanplain - scan PLAIN contents of [.
private int newlacon ( state begin , state end , int pos ) { if ( lacons . size ( ) == num_ ) {	newlacon - allocate a lookahead-constraint subRE.
private void onechr ( int c , state lp , state rp ) throws regexexception { if ( num_ == ( cflags & flags . reg_icase ) ) { nfa . newarc ( plain , cm . subcolor ( c ) , lp , rp ) ; return ; } dovec ( locale . allcases ( c ) , lp , rp ) ; }	onechr - fill in arcs for a plain character, and possible case complementsThis is mostly a shortcut for efficient handling of the common case.
private void dovec ( unicodeset set , state lp , state rp ) throws regexexception { int rangecount = set . getrangecount ( ) ; for ( int rx = num_ ; rx < rangecount ; rx ++ ) { int rangestart = set . getrangestart ( rx ) ; int rangeend = set . getrangeend ( rx ) ; if ( log . isdebugenabled ( ) && is_debug ) { log . debug ( string . format ( str_ , set , rx , rangestart , rangeend ) ) ; }	dovec - fill in arcs for each element of a cvecall kinds of MCCE complexity removed.
private short getcolor ( int c ) { try { return map . get ( c ) ; } catch ( nullpointerexception npe ) { throw new regexruntimeexception ( string . format ( str_ , c ) ) ; } }	Retrieve the color for a character.
short pseudocolor ( ) { short co = newcolor ( ) ; colordesc cd = colordescs . get ( co ) ; cd . setnchars ( num_ ) ; cd . markpseudo ( ) ; return co ; }	pseudocolor - allocate a false color to be managed by other means.
void subrange ( int from , int to , state lp , state rp ) throws regexexception { map < range < integer > , short > curcolors = map . subrangemap ( range . closed ( from , to ) ) . asmapofranges ( ) ; list < range < integer > > ranges = lists . newarraylist ( curcolors . keyset ( ) ) ; for ( range < integer > rangetoprocess : ranges ) {	subrange - allocate new subcolors to this range of chars, fill in arcs.The range will overlap existing ranges; even in the simplest case,it will overlap the initial WHITE range.
void okcolors ( nfa nfa ) { colordesc cd ; colordesc scd ; arc a ; short sco ; for ( short co = num_ ; co < colordescs . size ( ) ; co ++ ) { cd = colordescs . get ( co ) ; if ( cd == null ) { continue ;	okcolors - promote subcolors to full colors.
void colorchain ( arc a ) { colordesc cd = colordescs . get ( a . co ) ; a . colorchain = cd . arcs ; cd . arcs = a ; }	colorchain - add this arc to the color chain of its color.
void uncolorchain ( arc a ) { colordesc cd = colordescs . get ( a . co ) ; arc aa ; aa = cd . arcs ; if ( aa == a ) { cd . arcs = a . colorchain ; } else { for ( ; aa != null && aa . colorchain != a ; aa = aa . colorchain ) {	uncolorchain - delete this arc from the color chain of its color.
void dumpcolors ( ) { for ( int co = num_ ; co < colordescs . size ( ) ; co ++ ) { colordesc cd = colordescs . get ( co ) ; if ( cd != null ) { dumpcolor ( co , cd ) ; } } }	dumpcolors - debugging output.
void lexstart ( ) throws regexexception { prefixes ( ) ; if ( num_ != ( v . cflags & flags . reg_quote ) ) { assert num_ == ( v . cflags & ( flags . reg_advanced | flags . reg_expanded | flags . reg_newline ) ) ; intocon ( l_q ) ; } else if ( num_ != ( v . cflags & flags . reg_extended ) ) { assert num_ == ( v . cflags & flags . reg_quote ) ; intocon ( l_ere ) ; } else { assert num_ == ( v . cflags & ( flags . reg_quote | flags . reg_advf ) ) ; intocon ( l_bre ) ; } v . nexttype = compiler . empty ; next ( ) ; }	lexstart - set up lexical stuff, scan leading options.
void lexnest ( char [ ] interpolated ) { assert v . savepattern == null ; v . savepattern = v . pattern ; v . savenow = v . now ; v . savestop = v . stop ; v . savenow = v . now ; v . pattern = interpolated ; v . now = num_ ; v . stop = v . pattern . length ; }	lexnest - "call a subroutine", interpolating string at the lexical levelNote, this is not a very general facility.
short getcolor ( int codepoint ) { try { return fullmap . get ( codepoint ) ; } catch ( nullpointerexception npe ) { throw new runtimeexception ( string . format ( str_ , codepoint ) ) ; } }	Retrieve the color for a full codepoint.
stateset initialize ( int start ) {	Called at the start of a match.arguably we could just construct a new DFA each time.
int lastcold ( ) { int nopr = num_ ; for ( stateset ss : statesets . values ( ) ) { if ( ss . noprogress && nopr < ss . getlastseen ( ) ) { nopr = ss . getlastseen ( ) ; } } return nopr ; }	lastcold - determine last point at which no progress had been made.
static unicodeset eclass ( char c , boolean cases ) { if ( cases ) { return allcases ( c ) ; } else { unicodeset set = new unicodeset ( ) ; set . add ( c ) ; return set ; } }	eclass - Because we have no MCCE support, thisjust processing single characters.
public static unicodeset cclass ( string cclassname , boolean casefold ) throws regexexception { try { if ( casefold ) { return known_sets_ci . get ( cclassname ) ; } else { return known_sets_cs . get ( cclassname ) ; } } catch ( executionexception e ) { throwables . propagateifinstanceof ( e . getcause ( ) , regexexception . class ) ; throw new regexruntimeexception ( e . getcause ( ) ) ; } }	Return a UnicodeSet for a character class name.It appears that the names that TCL accepts are also acceptable to ICU.
void carcsort ( int first , int last ) { int p ; int q ; long tmp ; if ( last - first <= num_ ) { return ; } for ( p = first ; p <= last ; p ++ ) { for ( q = p ; q <= last ; q ++ ) { short pco = cnfa . carccolor ( arcs [ p ] ) ; short qco = cnfa . carccolor ( arcs [ q ] ) ; int pto = cnfa . carctarget ( arcs [ p ] ) ; int qto = cnfa . carctarget ( arcs [ q ] ) ; if ( pco > qco || ( pco == qco && pto > qto ) ) { assert p != q ; tmp = arcs [ p ] ; arcs [ p ] = arcs [ q ] ; arcs [ q ] = tmp ; } } } }	carcsort - sort compacted-NFA arcs by colorReally dumb algorithm, but if the list is long enough for that to matter,you're in real trouble anyway.
state newstate ( int flag ) { state newstate = new state ( ) ; newstate . no = nstates ++ ;	Factory method for new states.
void moveouts ( state old , state newstate ) { arc a ; assert old != newstate ; while ( ( a = old . outs ) != null ) { cparc ( a , newstate , a . to ) ; freearc ( a ) ; } }	moveouts - move all out arcs of a state to another state.
void moveins ( state old , state newstate ) { arc a ; assert old != newstate ; while ( ( a = old . ins ) != null ) { cparc ( a , a . from , newstate ) ; freearc ( a ) ; } assert old . nins == num_ ; assert old . ins == null ; }	moveins - move all in arcs of a state to another stateYou might think this could be done better by just updating theexisting arcs, and you would be right if it weren't for the desirefor duplicate suppression, which makes it easier to just make newones to exploit the suppression built into newarc.
void copyins ( state old , state newstate ) { arc a ; assert old != newstate ; for ( a = old . ins ; a != null ; a = a . inchain ) { cparc ( a , a . from , newstate ) ; } }	copyins - copy all in arcs of a state to another state.
void copyouts ( state old , state newstate ) { arc a ; assert old != newstate ; for ( a = old . outs ; a != null ; a = a . outchain ) { cparc ( a , newstate , a . to ) ; } }	copyouts - copy all out arcs of a state to another state.
void dropstate ( state s ) { arc a ; while ( ( a = s . ins ) != null ) { freearc ( a ) ; } while ( ( a = s . outs ) != null ) { freearc ( a ) ; } freestate ( s ) ; }	get rid of a state, releasing all its arcs.I'm not sure that all this is needed, as opposed to depending on the GC.
void freestate ( state s ) { assert s != null ; assert s . nins == num_ ; assert s . nouts == num_ ; if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast ; slast = s . prev ; } if ( s . prev != null ) { s . prev . next = s . next ; } else { assert s == states ; states = s . next ; } }	Unwire a state from the NFA.
void cparc ( arc oa , state from , state to ) { newarc ( oa . type , oa . co , from , to ) ; }	cparc - allocate a new arc within an NFA, copying details from old one.
void duptraverse ( state s , state stmp ) { arc a ; if ( s . tmp != null ) { return ; } s . tmp = ( stmp == null ) ? newstate ( ) : stmp ; if ( s . tmp == null ) { return ; } for ( a = s . outs ; a != null ; a = a . outchain ) { duptraverse ( a . to , null ) ; assert a . to . tmp != null ; cparc ( a , s . tmp , a . to . tmp ) ; } }	duptraverse - recursive heart of dupnfa.
void specialcolors ( ) { if ( parent == null ) { bos [ num_ ] = cm . pseudocolor ( ) ; bos [ num_ ] = cm . pseudocolor ( ) ; eos [ num_ ] = cm . pseudocolor ( ) ; eos [ num_ ] = cm . pseudocolor ( ) ; } else { assert parent . bos [ num_ ] != constants . colorless ; bos [ num_ ] = parent . bos [ num_ ] ; assert parent . bos [ num_ ] != constants . colorless ; bos [ num_ ] = parent . bos [ num_ ] ; assert parent . eos [ num_ ] != constants . colorless ; eos [ num_ ] = parent . eos [ num_ ] ; assert parent . eos [ num_ ] != constants . colorless ; eos [ num_ ] = parent . eos [ num_ ] ; } }	specialcolors - fill in special colors for an NFA.
void dumpnfa ( ) { if ( ! log . isdebugenabled ( ) || ! is_debug ) { return ; } log . debug ( str_ ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( string . format ( str_ , pre . no , post . no , init . no , finalstate . no ) ) ; if ( bos [ num_ ] != constants . colorless ) { sb . append ( string . format ( str_ , bos [ num_ ] ) ) ; } if ( bos [ num_ ] != constants . colorless ) { sb . append ( string . format ( str_ , bos [ num_ ] ) ) ; } if ( eos [ num_ ] != constants . colorless ) { sb . append ( string . format ( str_ , eos [ num_ ] ) ) ; } if ( eos [ num_ ] != constants . colorless ) { sb . append ( string . format ( str_ , eos [ num_ ] ) ) ; } log . debug ( sb . tostring ( ) ) ; for ( state s = states ; s != null ; s = s . next ) { dumpstate ( s ) ; } if ( parent == null ) { cm . dumpcolors ( ) ; } }	dumpnfa - dump an NFA in human-readable form.
void dumpstate ( state s ) { arc a ; if ( ! log . isdebugenabled ( ) || ! is_debug ) { return ; } stringbuilder sb = new stringbuilder ( ) ; sb . append ( string . format ( str_ , s . no , ( s . tmp != null ) ? str_ : str_ , ( s . flag != num_ ) ? ( char ) s . flag : str_ ) ) ; if ( s . prev != null && s . prev . next != s ) { sb . append ( string . format ( str_ ) ) ; } if ( s . nouts == num_ ) { sb . append ( str_ ) ; } else { dumparcs ( s , sb ) ; } log . debug ( sb . tostring ( ) ) ; for ( a = s . ins ; a != null ; a = a . inchain ) { if ( a . to != s ) { log . debug ( string . format ( str_ , a . from . no , a . to . no , s . no ) ) ; } } }	dumpstate - dump an NFA state in human-readable form.
void dumparcs ( state s , stringbuilder sb ) { int pos ; assert s . nouts > num_ ; pos = dumprarcs ( s . outs , s , num_ , sb ) ; if ( pos != num_ ) {	dumparcs - dump out-arcs in human-readable form.
int dumprarcs ( arc a , state s , int pos , stringbuilder sb ) { if ( a . outchain != null ) { pos = dumprarcs ( a . outchain , s , pos , sb ) ; } dumparc ( a , s , sb ) ; if ( pos == num_ ) { sb . append ( str_ ) ; pos = num_ ; } else { pos ++ ; } return pos ; }	dumprarcs - dump remaining outarcs, recursively, in reverse order.
long optimize ( ) throws regexexception { log . debug ( str_ ) ; cleanup ( ) ; dumpnfa ( ) ; log . debug ( str_ ) ; fixempties ( ) ; log . debug ( str_ ) ; pullback ( ) ; pushfwd ( ) ; log . debug ( str_ ) ; cleanup ( ) ; return analyze ( ) ; }	optimize - optimize an NFA.
long analyze ( ) { arc a ; arc aa ; if ( pre . outs == null ) { return flags . reg_uimpossible ; } for ( a = pre . outs ; a != null ; a = a . outchain ) { for ( aa = a . to . outs ; aa != null ; aa = aa . outchain ) { if ( aa . to == post ) { return flags . reg_uemptymatch ; } } } return num_ ; }	analyze - ascertain potentially-useful facts about an optimized NFA.
int combine ( arc con , arc a ) throws regexexception {	combine - constraint lands on an arc, what happens?.
void cleanup ( ) { state s ; state nexts ; int n ; markreachable ( pre , null , pre ) ; markcanreach ( post , pre , post ) ; for ( s = states ; s != null ; s = nexts ) { nexts = s . next ; if ( s . tmp != post && num_ == s . flag ) { dropstate ( s ) ; } } assert post . nins == num_ || post . tmp == post ; cleartraverse ( pre ) ; assert post . nins == num_ || post . tmp == null ; n = num_ ; for ( s = states ; s != null ; s = s . next ) { s . no = n ++ ; } nstates = n ; }	cleanup - clean up NFA after optimizations.
void markreachable ( state s , state okay , state mark ) { arc a ; if ( s . tmp != okay ) { return ; } s . tmp = mark ; for ( a = s . outs ; a != null ; a = a . outchain ) { markreachable ( a . to , okay , mark ) ; } }	markreachable - recursive marking of reachable states.
void markcanreach ( state s , state okay , state mark ) { arc a ; if ( s . tmp != okay ) { return ; } s . tmp = mark ; for ( a = s . ins ; a != null ; a = a . inchain ) { markcanreach ( a . from , okay , mark ) ; } }	markcanreach - recursive marking of states which can reach here.
void fixempties ( ) { state s ; state nexts ; arc a ; arc nexta ; boolean progress ; do { progress = bool_ ; for ( s = states ; s != null ; s = nexts ) { nexts = s . next ; for ( a = s . outs ; a != null ; a = nexta ) { nexta = a . outchain ; if ( a . type == compiler . empty && unempty ( a ) ) { progress = bool_ ; } assert nexta == null || s . no != state . freestate ; } } if ( progress ) { dumpnfa ( ) ; } } while ( progress ) ; }	fixempties - get rid of EMPTY arcs.
boolean unempty ( arc a ) { state from = a . from ; state to = a . to ; boolean usefrom ; assert a . type == compiler . empty ; assert from != pre && to != post ; if ( from == to ) { freearc ( a ) ; return bool_ ; } usefrom = bool_ ; if ( from . nouts > to . nins ) { usefrom = bool_ ; } else if ( from . nouts == to . nins ) { if ( from . nins > to . nouts ) { usefrom = bool_ ; } } freearc ( a ) ; if ( usefrom ) { if ( from . nouts == num_ ) { moveins ( from , to ) ; freestate ( from ) ; } else { copyins ( from , to ) ; } } else { if ( to . nins == num_ ) { moveouts ( to , from ) ; freestate ( to ) ; } else { copyouts ( to , from ) ; } } return bool_ ; }	unempty - optimize out an EMPTY arc, if possibleActually, as it stands this function always succeeds, but the returnvalue is kept with an eye on possible future changes.
private map < string , string > getruleparameters ( ) throws cliexecutionexception { map < string , string > ruleparameters ; if ( ruleparametersfile == null ) { ruleparameters = collections . emptymap ( ) ; } else { properties properties = new properties ( ) ; try { properties . load ( new fileinputstream ( ruleparametersfile ) ) ; } catch ( ioexception e ) { throw new cliexecutionexception ( str_ + ruleparametersfile . getpath ( ) + str_ ) ; } ruleparameters = new treemap < > ( ) ; for ( string name : properties . stringpropertynames ( ) ) { ruleparameters . put ( name , properties . getproperty ( name ) ) ; } } return ruleparameters ; }	Reads the given rule parameters file.
private map < string , collection < ruleinterpreterplugin > > getruleinterpreterplugins ( ) throws cliexecutionexception { try { return pluginrepository . getruleinterpreterpluginrepository ( ) . getruleinterpreterplugins ( collections . < string , object > emptymap ( ) ) ; } catch ( pluginrepositoryexception e ) { throw new cliexecutionexception ( str_ , e ) ; } }	Get all configured rule interpreter plugins.
private map < string , reportplugin > getreportplugins ( reportcontext reportcontext ) throws cliexecutionexception { reportpluginrepository reportpluginrepository ; try { reportpluginrepository = pluginrepository . getreportpluginrepository ( ) ; return reportpluginrepository . getreportplugins ( reportcontext , pluginproperties ) ; } catch ( pluginrepositoryexception e ) { throw new cliexecutionexception ( str_ , e ) ; } }	Get all configured report plugins.
protected ruleselection getruleselection ( ruleset ruleset ) { return ruleselection . select ( ruleset , groupids , constraintids , conceptids ) ; }	Return the selection of rules.
public void run ( string [ ] args ) throws cliexecutionexception { options options = gatheroptions ( taskfactory ) ; commandline commandline = getcommandline ( args , options ) ; interpretcommandline ( commandline , options , taskfactory ) ; }	Run tasks according to the given arguments.
private static string geterrormessage ( cliexecutionexception e ) { stringbuffer messagebuilder = new stringbuffer ( ) ; throwable current = e ; do { messagebuilder . append ( str_ ) ; messagebuilder . append ( current . getmessage ( ) ) ; current = current . getcause ( ) ; } while ( current != null ) ; return messagebuilder . tostring ( ) ; }	Extract an error message from the given exception and its causes.
@ suppresswarnings ( str_ ) private void gatherstandardoptions ( final options options ) { options . addoption ( optionbuilder . withargname ( str_ ) . withdescription ( str_ ) . withlongopt ( str_ ) . hasarg ( ) . create ( str_ ) ) ; options . addoption ( new option ( str_ , str_ ) ) ; }	Gathers the standard options shared by all tasks.
private void gathertasksoptions ( taskfactory taskfactory , options options ) { for ( task task : taskfactory . gettasks ( ) ) { for ( option option : task . getoptions ( ) ) { options . addoption ( option ) ; } } }	Gathers the task specific options for all tasks.
private string gathertasknames ( taskfactory taskfactory ) { final stringbuilder builder = new stringbuilder ( ) ; for ( string taskname : taskfactory . gettasknames ( ) ) { builder . append ( str_ ) . append ( taskname ) . append ( str_ ) ; } return builder . tostring ( ) . trim ( ) ; }	Returns a string containing the names of all supported tasks.
private void interpretcommandline ( commandline commandline , options options , taskfactory taskfactory ) throws cliexecutionexception { if ( commandline . hasoption ( option_help ) ) { printusage ( options , null ) ; system . exit ( num_ ) ; } list < string > tasknames = commandline . getarglist ( ) ; if ( tasknames . isempty ( ) ) { printusage ( options , str_ + gathertasknames ( taskfactory ) ) ; system . exit ( num_ ) ; } list < task > tasks = new arraylist < > ( ) ; for ( string taskname : tasknames ) { task task = taskfactory . fromname ( taskname ) ; if ( task == null ) { printusage ( options , str_ + taskname ) ; } tasks . add ( task ) ; } map < string , object > properties = readproperties ( commandline ) ; pluginrepository pluginrepository = getpluginrepository ( ) ; try { executetasks ( tasks , options , commandline , pluginrepository , properties ) ; } catch ( pluginrepositoryexception e ) { throw new cliexecutionexception ( str_ , e ) ; } }	Parse the command line and execute the requested task.
private commandline getcommandline ( string [ ] args , options options ) { final commandlineparser parser = new basicparser ( ) ; commandline commandline = null ; try { commandline = parser . parse ( options , args ) ; } catch ( parseexception e ) { printusage ( options , e . getmessage ( ) ) ; system . exit ( num_ ) ; } return commandline ; }	Parse the command line.
private void executetask ( task task , options option , commandline commandline , pluginrepository pluginrepository , map < string , object > properties ) throws cliexecutionexception { try { task . withstandardoptions ( commandline ) ; task . withoptions ( commandline ) ; } catch ( cliconfigurationexception e ) { printusage ( option , e . getmessage ( ) ) ; system . exit ( num_ ) ; } task . initialize ( pluginrepository , properties ) ; task . run ( ) ; }	Executes a task.
private map < string , object > readproperties ( commandline commandline ) throws cliconfigurationexception { final properties properties = new properties ( ) ; inputstream propertiesstream ; if ( commandline . hasoption ( str_ ) ) { file propertyfile = new file ( commandline . getoptionvalue ( str_ ) ) ; if ( ! propertyfile . exists ( ) ) { throw new cliconfigurationexception ( str_ + propertyfile . getabsolutepath ( ) ) ; } try { propertiesstream = new fileinputstream ( propertyfile ) ; } catch ( filenotfoundexception e ) { throw new cliconfigurationexception ( str_ , e ) ; } } else { propertiesstream = main . class . getresourceasstream ( str_ ) ; } map < string , object > result = new hashmap < > ( ) ; if ( propertiesstream != null ) { try { properties . load ( propertiesstream ) ; } catch ( ioexception e ) { throw new cliconfigurationexception ( str_ , e ) ; } for ( string name : properties . stringpropertynames ( ) ) { result . put ( name , properties . getproperty ( name ) ) ; } } return result ; }	Read the plugin properties file if specified on the command line or if it exists on the class path.
private void printusage ( final options options , final string errormessage ) { if ( errormessage != null ) { system . out . println ( str_ + errormessage ) ; } final helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( main . class . getcanonicalname ( ) + str_ , options ) ; system . out . println ( str_ + gathertasknames ( taskfactory ) ) ; system . out . println ( str_ + main . class . getcanonicalname ( ) + str_ ) ; }	Print usage information.
private file gethomedirectory ( ) { string dirname = system . getenv ( env_jqassistant_home ) ; if ( dirname != null ) { file dir = new file ( dirname ) ; if ( dir . exists ( ) ) { logger . debug ( str_ + dir . getabsolutepath ( ) + str_ ) ; return dir ; } else { logger . warn ( str_ + dir . getabsolutepath ( ) + str_ ) ; return null ; } } logger . warn ( str_ ) ; return null ; }	Determine the JQASSISTANT_HOME directory.
private classloader createpluginclassloader ( ) throws cliexecutionexception { classloader parentclassloader = task . class . getclassloader ( ) ; file homedirectory = gethomedirectory ( ) ; if ( homedirectory != null ) { file plugindirectory = new file ( homedirectory , directory_plugins ) ; if ( plugindirectory . exists ( ) ) { final list < url > urls = new arraylist < > ( ) ; final path plugindirectorypath = plugindirectory . topath ( ) ; simplefilevisitor < path > visitor = new simplefilevisitor < path > ( ) { @ override public filevisitresult visitfile ( path file , basicfileattributes attrs ) throws ioexception { if ( file . tofile ( ) . getname ( ) . endswith ( str_ ) ) { urls . add ( file . tofile ( ) . touri ( ) . tourl ( ) ) ; } return filevisitresult . continue ; } } ; try { files . walkfiletree ( plugindirectorypath , visitor ) ; } catch ( ioexception e ) { throw new cliexecutionexception ( str_ , e ) ; } logger . debug ( str_ + urls ) ; return new com . buschmais . jqassistant . commandline . pluginclassloader ( urls , parentclassloader ) ; } } return parentclassloader ; }	Create the class loader to be used for detecting and loading plugins.
public set < string > getcontainingids ( double minlongitude , double minlatitude , double maxlongitude , double maxlatitude ) { set < string > ids = new hashset < > ( ) ; forcellsin ( minlongitude , minlatitude , maxlongitude , maxlatitude , cell -> { if ( ids . isempty ( ) ) { ids . addall ( cell . getcontainingids ( ) ) ; } else { ids . retainall ( cell . getcontainingids ( ) ) ; } } ) ; return ids ; }	Identify which countries are guaranteed to contain the given bounding box fully.The given bounding box may wrap around the 180th longitude, i.e minLongitude = 170 andmaxLongitude = -170.
public set < string > getintersectingids ( double minlongitude , double minlatitude , double maxlongitude , double maxlatitude ) { set < string > ids = new hashset < > ( ) ; forcellsin ( minlongitude , minlatitude , maxlongitude , maxlatitude , cell -> { ids . addall ( cell . getallids ( ) ) ; } ) ; return ids ; }	Identify which countries intersect with the given bounding box.
public string uri ( httpmethod method , t target , object ... params ) { methodlessrouter < t > router = ( method == null ) ? anymethodrouter : routers . get ( method ) ;	Given a target and params, this method tries to do the reverse routingand returns the URI.
public orderlessrouter < t > addroute ( string pathpattern , t target ) { pathpattern p = new pathpattern ( pathpattern ) ; if ( routes . containskey ( p ) ) { return this ; } routes . put ( p , target ) ; addreverseroute ( target , p ) ; return this ; }	This method does nothing if the path pattern has already been added.A path pattern can only point to one target.
public int size ( ) { return first . routes ( ) . size ( ) + other . routes ( ) . size ( ) + last . routes ( ) . size ( ) ; }	Returns the number of routes in this router.
public methodlessrouter < t > addroutefirst ( string pathpattern , t target ) { first . addroute ( pathpattern , target ) ; return this ; }	Adds route to the "first" section.
public methodlessrouter < t > addroute ( string pathpattern , t target ) { other . addroute ( pathpattern , target ) ; return this ; }	Adds route to the "other" section.
public methodlessrouter < t > addroutelast ( string pathpattern , t target ) { last . addroute ( pathpattern , target ) ; return this ; }	Adds route to the "last" section.
public boolean anymatched ( string [ ] requestpathtokens ) { return first . anymatched ( requestpathtokens ) || other . anymatched ( requestpathtokens ) || last . anymatched ( requestpathtokens ) ; }	Checks if there's any matching route.
private criterion smartequal ( string property , object value ) { if ( value == null ) { return restrictions . isnull ( property ) ; } else { return restrictions . eq ( property , value ) ; } }	There are two different Criterion for if a property is null or checking equality.
protected string getstorefilename ( string owner , string name ) { final stringbuilder filenamebuff = new stringbuilder ( ) ; filenamebuff . append ( owner != null ? str_ + owner : str_ ) ; filenamebuff . append ( str_ ) ; filenamebuff . append ( name != null ? str_ + name : str_ ) ; filenamebuff . append ( str_ ) ; return filenamebuff . tostring ( ) ; }	Generates the file name String for an owner and book name.
protected int comparefolders ( final entry e1 , final entry e2 ) { final boolean f1 = e1 instanceof folder ; final boolean f2 = e2 instanceof folder ; if ( f1 && ! f2 ) { return - num_ ; } else if ( ! f1 && f2 ) { return num_ ; } else { return num_ ; } }	Folders are always greater than non-Folders, if they are both Foldersor both not Folders they are equal.
protected int compareentries ( final entry e1 , final entry e2 ) { return new comparetobuilder ( ) . append ( e1 . getname ( ) , e2 . getname ( ) ) . append ( e1 . getnote ( ) , e2 . getnote ( ) ) . append ( e1 . getcreated ( ) , e2 . getcreated ( ) ) . append ( e1 . getmodified ( ) , e2 . getmodified ( ) ) . tocomparison ( ) ; }	Compairs the entries by name, note, created and modified properties in thatorder.
protected int comparebookmarks ( final entry e1 , final entry e2 ) { if ( e1 instanceof bookmark && e2 instanceof bookmark ) { final bookmark b1 = ( bookmark ) e1 ; final bookmark b2 = ( bookmark ) e2 ; return new comparetobuilder ( ) . append ( b1 . geturl ( ) , b2 . geturl ( ) ) . append ( b1 . isnewwindow ( ) , b2 . isnewwindow ( ) ) . tocomparison ( ) ; } else { return num_ ; } }	If both classes are not Bookmarks they are equal.
public void setservletclasslastmodifiedtime ( long lastmodified ) { if ( this . servletclasslastmodifiedtime < lastmodified ) { synchronized ( this ) { if ( this . servletclasslastmodifiedtime < lastmodified ) { this . servletclasslastmodifiedtime = lastmodified ; reload = bool_ ; } } } }	Sets the last-modified time of the servlet class file associated withthis JspServletWrapper.
public java . util . list < string > getdependants ( ) { try { object target ; if ( istagfile ) { if ( reload ) { taghandlerclass = ctxt . load ( ) ; } target = taghandlerclass . newinstance ( ) ; } else { target = getservlet ( ) ; } if ( target != null && target instanceof jspsourcedependent ) { return ( ( jspsourcedependent ) target ) . getdependants ( ) ; } } catch ( throwable ex ) { } return null ; }	Get a list of files that the current page has source dependency on.
public class findclass ( string classname ) throws classnotfoundexception {	START OF IASRI 4709374.
public static string [ ] parseauthorization ( final httpservletrequest request ) { final string auth = request . getheader ( str_ ) ; logger . debug ( str_ , auth ) ; if ( auth == null || auth . isempty ( ) ) { return null ; } final string [ ] toks = auth . split ( str_ ) ; if ( toks . length < num_ ) { return null ; } if ( ! str_ . equalsignorecase ( toks [ num_ ] ) ) { return null ; } final byte [ ] authdata = base64 . getdecoder ( ) . decode ( toks [ num_ ] ) ; final string authstr = standardcharsets . iso_8859_1 . decode ( bytebuffer . wrap ( authdata ) ) . tostring ( ) ; logger . debug ( str_ , authstr ) ; final string [ ] authtoks = authstr . split ( str_ , num_ ) ; logger . debug ( str_ , new object [ ] { authtoks } ) ; if ( authtoks . length != num_ ) { return null ; } return authtoks ; }	Parse the basic authentication header.
public static protectedfunctionmapper getinstance ( ) { protectedfunctionmapper funcmapper ; if ( securityutil . ispackageprotectionenabled ( ) ) { funcmapper = accesscontroller . doprivileged ( new privilegedaction < protectedfunctionmapper > ( ) { public protectedfunctionmapper run ( ) { return new protectedfunctionmapper ( ) ; } } ) ; } else { funcmapper = new protectedfunctionmapper ( ) ; } funcmapper . fnmap = new java . util . hashmap < string , method > ( ) ; return funcmapper ; }	Generated Servlet and Tag Handler implementations call thismethod to retrieve an instance of the ProtectedFunctionMapper.This is necessary since generated code does not have access tocreate instances of classes in this package.
public void mapfunction ( string fnqname , final class < ? > c , final string methodname , final class < ? > [ ] args ) { java . lang . reflect . method method ; if ( securityutil . ispackageprotectionenabled ( ) ) { try { method = accesscontroller . doprivileged ( new privilegedexceptionaction < method > ( ) { public method run ( ) throws exception { return c . getdeclaredmethod ( methodname , args ) ; } } ) ; } catch ( privilegedactionexception ex ) { throw new runtimeexception ( str_ + ex . getexception ( ) . getmessage ( ) ) ; } } else { try { method = c . getdeclaredmethod ( methodname , args ) ; } catch ( nosuchmethodexception e ) { throw new runtimeexception ( str_ + e . getmessage ( ) ) ; } } this . fnmap . put ( fnqname , method ) ; }	Stores a mapping from the given EL function prefix and name tothe given Java method.
public static protectedfunctionmapper getmapforfunction ( string fnqname , final class < ? > c , final string methodname , final class < ? > [ ] args ) { java . lang . reflect . method method ; protectedfunctionmapper funcmapper ; if ( securityutil . ispackageprotectionenabled ( ) ) { funcmapper = accesscontroller . doprivileged ( new privilegedaction < protectedfunctionmapper > ( ) { public protectedfunctionmapper run ( ) { return new protectedfunctionmapper ( ) ; } } ) ; try { method = accesscontroller . doprivileged ( new privilegedexceptionaction < method > ( ) { public method run ( ) throws exception { return c . getdeclaredmethod ( methodname , args ) ; } } ) ; } catch ( privilegedactionexception ex ) { throw new runtimeexception ( str_ + ex . getexception ( ) . getmessage ( ) ) ; } } else { funcmapper = new protectedfunctionmapper ( ) ; try { method = c . getdeclaredmethod ( methodname , args ) ; } catch ( nosuchmethodexception e ) { throw new runtimeexception ( str_ + e . getmessage ( ) ) ; } } funcmapper . themethod = method ; return funcmapper ; }	Creates an instance for this class, and stores the Method forthe given EL function prefix and name.
public method resolvefunction ( string prefix , string localname ) { if ( this . fnmap != null ) { return this . fnmap . get ( prefix + str_ + localname ) ; } return themethod ; }	Resolves the specified local name and prefix into a Java.lang.Method.Returns null if the prefix and local name are not found.
public void setvalues ( char [ ] ch , int offset , int length ) { this . ch = ch ; this . offset = offset ; this . length = length ; }	Initializes the contents of the XMLString structure with thespecified values.
public object resolvevariable ( string pname ) throws javax . servlet . jsp . el . elexception { elcontext elcontext = pagecontext . getelcontext ( ) ; elresolver elresolver = elcontext . getelresolver ( ) ; try { return elresolver . getvalue ( elcontext , null , pname ) ; } catch ( javax . el . elexception ex ) { throw new javax . servlet . jsp . el . elexception ( ) ; } }	Resolves the specified variable within the given context.Returns null if the variable is not found.
public node . nodes parse ( string infilename ) throws filenotfoundexception , jasperexception , ioexception {	Parses a JSP page or tag file.
public node . nodes parse ( string infilename , node parent , url jarfileurl ) throws filenotfoundexception , jasperexception , ioexception {	Processes an include directive with the given path.
public node . nodes parsetagfiledirectives ( string infilename ) throws filenotfoundexception , jasperexception , ioexception { boolean istagfilesave = istagfile ; boolean directiveonlysave = directiveonly ; istagfile = bool_ ; directiveonly = bool_ ; node . nodes page = doparse ( infilename , null , ( url ) ctxt . gettagfilejarurls ( ) . get ( infilename ) ) ; directiveonly = directiveonlysave ; istagfile = istagfilesave ; return page ; }	Extracts tag file directive information from the tag file with thegiven name.This is invoked by the compiler.
public compiler createcompiler ( boolean jspcmode ) throws jasperexception { if ( jspcompiler != null ) { return jspcompiler ; } jspcompiler = new compiler ( this , jsw , jspcmode ) ; return jspcompiler ; }	Create a "Compiler" object.
public java . io . inputstream getresourceasstream ( string res ) throws jasperexception { return context . getresourceasstream ( canonicaluri ( res ) ) ; }	Gets a resource as a stream, relative to the meanings of thiscontext's implementation.
private optional < instant > calclastmod ( ) { instant globallastmod = null ; for ( final channelinformation ci : this . channelservice . list ( ) ) { final optional < instant > lastmod = ofnullable ( ci . getstate ( ) . getmodificationtimestamp ( ) ) ; if ( globallastmod == null || lastmod . get ( ) . isafter ( globallastmod ) ) { globallastmod = lastmod . get ( ) ; } } return optional . ofnullable ( globallastmod ) ; }	Find the last modification timestamp of all channels.
arraylist basicfindclassloaders ( ) { class [ ] stack = contextfinder . getclasscontext ( ) ; arraylist result = new arraylist ( num_ ) ; classloader previousloader = null ; for ( int i = num_ ; i < stack . length ; i ++ ) { classloader tmp = stack [ i ] . getclassloader ( ) ; if ( checkclass ( stack [ i ] ) && tmp != null && tmp != this ) { if ( checkclassloader ( tmp ) ) { if ( previousloader != tmp ) { result . add ( tmp ) ; previousloader = tmp ; } }	We assume that the bootclassloader never uses the context classloader to find classes in itself.
private boolean checkclassloader ( classloader classloader ) { if ( classloader == null || classloader == getparent ( ) ) return bool_ ; for ( classloader parent = classloader . getparent ( ) ; parent != null ; parent = parent . getparent ( ) ) if ( parent == this ) return bool_ ; return bool_ ; }	not be used as a delegate, otherwise we endup in endless recursion.
private boolean startloading ( string name ) { set classesandresources = ( set ) cycledetector . get ( ) ; if ( classesandresources != null && classesandresources . contains ( name ) ) return bool_ ; if ( classesandresources == null ) { classesandresources = new hashset ( num_ ) ; cycledetector . set ( classesandresources ) ; } classesandresources . add ( name ) ; return bool_ ; }	False is returned when a cycle is being detected.
private static byte [ ] readstreamheader ( inputstream in ) throws ioexception { byte [ ] streamheader = new byte [ decoderutil . stream_header_size ] ; new datainputstream ( in ) . readfully ( streamheader ) ; return streamheader ; }	Reads the Stream Header into a buffer.This is a helper function for the constructors.
public static < t > paginationresult < t > paginate ( final integer startpage , final int pagesize , final list < t > fulldataset ) { return paginate ( startpage , pagesize , ( start , length ) -> { final int len = fulldataset . size ( ) ; if ( start > len ) { return collections . emptylist ( ) ; } return fulldataset . sublist ( start , math . min ( start + length , len ) ) ; } ) ; }	Paginate from a full data set.
public static metakey fromstring ( final string string ) { final int idx = string . indexof ( str_ ) ; if ( idx < num_ ) {	Convert a string to a MetaKey if possible.
private void fillrequirements ( ) throws ioexception { this . requirements . add ( new dependency ( str_ , str_ , rpmdependencyflags . less , rpmdependencyflags . equal , rpmdependencyflags . rpmlib ) ) ; if ( ! this . options . getfiledigestalgorithm ( ) . equals ( digestalgorithm . md5 ) ) { this . requirements . add ( new dependency ( str_ , str_ , rpmdependencyflags . less , rpmdependencyflags . equal , rpmdependencyflags . rpmlib ) ) ; } this . requirements . add ( new dependency ( str_ , str_ , rpmdependencyflags . less , rpmdependencyflags . equal , rpmdependencyflags . rpmlib ) ) ; this . options . getpayloadcoding ( ) . createprovider ( ) . fillrequirements ( this . requirements :: add ) ; }	Fill extra requirements the RPM file itself may have.
public tagfileinfo gettagfile ( string shortname ) { tagfileinfo tagfile = super . gettagfile ( shortname ) ; if ( tagfile == null ) { string path = tagfilemap . get ( shortname ) ; if ( path == null ) { return null ; } taginfo taginfo = null ; try { taginfo = tagfileprocessor . parsetagfiledirectives ( pc , shortname , path , this ) ; } catch ( jasperexception je ) { throw new runtimeexception ( je . tostring ( ) ) ; } tagfile = new tagfileinfo ( shortname , path , taginfo ) ; vec . add ( tagfile ) ; this . tagfiles = vec . toarray ( new tagfileinfo [ vec . size ( ) ] ) ; } return tagfile ; }	Checks to see if the given tag name maps to a tag file path,and if so, parses the corresponding tag file.
private void parseimplicittld ( jspcompilationcontext ctxt , string path ) throws jasperexception { inputstream is = null ; treenode tld = null ; try { url uri = ctxt . getresource ( path ) ; if ( uri == null ) {	Parses the JSP version and tlib-version from the implicit.tld at thegiven path.
public string getchecksum ( final string filename , final string algorithm ) { if ( ! this . digests . contains ( algorithm ) ) { return null ; } final string result = this . checksums . get ( filename + str_ + algorithm ) ; if ( result == null ) { throw new illegalstateexception ( string . format ( str_ , filename ) ) ; } return result ; }	Get the digest of a closed file.
public long getsize ( final string filename ) { final long result = this . sizes . get ( filename ) ; if ( result == null ) { throw new illegalstateexception ( string . format ( str_ , filename ) ) ; } return result ; }	Get the size of a closed file.
private static void validatechannelname ( final string name , final validationcontext ctx ) { if ( name == null || name . isempty ( ) ) { return ; } final matcher m = channelservice . name_pattern . matcher ( name ) ; if ( ! m . matches ( ) ) { ctx . error ( str_ , string . format ( str_ , name , channelservice . name_pattern . pattern ( ) ) ) ; } }	Validate the name of the channel.
public void seektoblock ( int blocknumber ) throws ioexception { if ( in == null ) throw new xzioexception ( str_ ) ; if ( blocknumber < num_ || blocknumber >= blockcount ) throw new xzioexception ( str_ + blocknumber ) ;	Seeks to the beginning of the given XZ Block.
private void locateblockbypos ( blockinfo info , long pos ) { if ( pos < num_ || pos >= uncompressedsize ) throw new indexoutofboundsexception ( str_ + pos ) ;	Locates the Block that contains the given uncompressed position.
protected static list < mavenversionedartifact > getmavenartifacts ( final string channelid , final supplier < collection < artifactinformation > > artifactssupplier , final string groupid , final string artifactid , final boolean snapshot , final predicate < comparableversion > versionfilter ) { final list < mavenversionedartifact > arts = new arraylist < > ( ) ; for ( final artifactinformation ai : artifactssupplier . get ( ) ) { if ( ! iszip ( ai ) ) {	Get a list of all relevant maven artifacts.
private void updateoptstateandreps ( ) { int optprev = opts [ optcur ] . optprev ; assert optprev < optcur ; if ( opts [ optcur ] . prev1isliteral ) { -- optprev ; if ( opts [ optcur ] . hasprev2 ) { opts [ optcur ] . state . set ( opts [ opts [ optcur ] . optprev2 ] . state ) ; if ( opts [ optcur ] . backprev2 < reps ) opts [ optcur ] . state . updatelongrep ( ) ; else opts [ optcur ] . state . updatematch ( ) ; } else { opts [ optcur ] . state . set ( opts [ optprev ] . state ) ; } opts [ optcur ] . state . updateliteral ( ) ; } else { opts [ optcur ] . state . set ( opts [ optprev ] . state ) ; } if ( optprev == optcur - num_ ) {	Updates the state and reps for the current byte in the opts array.
private void calc1byteprices ( int pos , int posstate , int avail , int anyrepprice ) {	Calculates prices of a literal, a short rep, and literal + rep0.
private int calclongrepprices ( int pos , int posstate , int avail , int anyrepprice ) { int startlen = match_len_min ; int lenlimit = math . min ( avail , nicelen ) ; for ( int rep = num_ ; rep < reps ; ++ rep ) { int len = lz . getmatchlen ( opts [ optcur ] . reps [ rep ] , lenlimit ) ; if ( len < match_len_min ) continue ; while ( optend < optcur + len ) opts [ ++ optend ] . reset ( ) ; int longrepprice = getlongrepprice ( anyrepprice , rep , opts [ optcur ] . state , posstate ) ; for ( int i = len ; i >= match_len_min ; -- i ) { int price = longrepprice + replenencoder . getprice ( i , posstate ) ; if ( price < opts [ optcur + i ] . price ) opts [ optcur + i ] . set1 ( price , optcur , rep ) ; } if ( rep == num_ ) startlen = len + num_ ; int len2limit = math . min ( nicelen , avail - len - num_ ) ; int len2 = lz . getmatchlen ( len + num_ , opts [ optcur ] . reps [ rep ] , len2limit ) ; if ( len2 >= match_len_min ) {	Calculates prices of long rep and long rep + literal + rep0.
private void calcnormalmatchprices ( int pos , int posstate , int avail , int anymatchprice , int startlen ) {	Calculates prices of a normal match and normal match + literal + rep0.
private void expectedbyte ( int position , int count ) throws utfdataformatexception { throw new utfdataformatexception ( localizer . getmessage ( str_ , integer . tostring ( position ) , integer . tostring ( count ) ) ) ; }	Throws an exception for expected byte.
private void invalidbyte ( int position , int count , int c ) throws utfdataformatexception { throw new utfdataformatexception ( localizer . getmessage ( str_ , integer . tostring ( position ) , integer . tostring ( count ) ) ) ; }	Throws an exception for invalid byte.
private void scantlds ( ) throws jasperexception { mappings = new hashmap < string , string [ ] > ( ) ;	Scan the all the tlds accessible in the web app.For performance reasons, this is done in two stages.
private tldinfo scantld ( string resourcepath , string entryname , inputstream stream ) throws jasperexception { try {	Scan the given TLD for uri and listeners elements.
public void addwrapper ( string jspuri , jspservletwrapper jsw ) { jsps . remove ( jspuri ) ; jsps . put ( jspuri , jsw ) ; }	Add a new JspServletWrapper.
public classloader getparentclassloader ( ) { classloader parentclassloader = thread . currentthread ( ) . getcontextclassloader ( ) ; if ( parentclassloader == null ) { parentclassloader = this . getclass ( ) . getclassloader ( ) ; } return parentclassloader ; }	Get the parent class loader.
public void setbytecode ( string name , byte [ ] bytecode ) { if ( bytecode == null ) { bytecodes . remove ( name ) ; bytecodebirthtimes . remove ( name ) ; return ; } bytecodes . put ( name , bytecode ) ; bytecodebirthtimes . put ( name , long . valueof ( system . currenttimemillis ( ) ) ) ; }	Save the bytecode for the class in a map.
public long getbytecodebirthtime ( string name ) { long time = bytecodebirthtimes . get ( name ) ; return ( time != null ? time . longvalue ( ) : num_ ) ; }	Retrieve the time the bytecode for a class was created.
public void savebytecode ( string classname , string classfilename ) { byte [ ] bytecode = getbytecode ( classname ) ; if ( bytecode != null ) { try { fileoutputstream fos = new fileoutputstream ( classfilename ) ; fos . write ( bytecode ) ; fos . close ( ) ; } catch ( ioexception ex ) { context . log ( str_ + classname + str_ + classfilename , ex ) ; } } }	Save the bytecode for a class to disk.
private void checkcompile ( ) { for ( jspservletwrapper jsw : jsps . values ( ) ) { if ( jsw . istagfile ( ) ) {	Method used by background thread to check the JSP dependenciesregistered with this class for JSP's.
private void initclasspath ( ) { stringbuilder cpath = new stringbuilder ( ) ; string sep = system . getproperty ( str_ ) ; cpath . append ( options . getscratchdir ( ) + sep ) ; string cp = ( string ) context . getattribute ( constants . servlet_classpath ) ; if ( cp == null || cp . equals ( str_ ) ) { cp = options . getclasspath ( ) ; } if ( cp != null ) { classpath = cpath . tostring ( ) + cp ; }	Method used to initialize classpath for compiles.
protected void threadstart ( ) {	Start the background thread that will periodically check forchanges to compile time included files in a JSP.
protected void threadstop ( ) { if ( thread == null ) { return ; } threaddone = bool_ ; thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( interruptedexception e ) { ; } thread = null ; }	Stop the background thread that is periodically checking forchanges to compile time included files in a JSP.
public void run ( ) {	The background thread that checks for changes to filesincluded by a JSP and flags that a recompile is required.
private optional < channelinstance > findbyname ( final string name ) { if ( name == null ) { return empty ( ) ; } final string id = this . manager . accesscall ( key_storage , channelserviceaccess . class , channels -> { return channels . maptoid ( name ) ; } ) ; return findbyid ( id ) ; }	Find a channel by name.
private channelinstance findchannel ( final by by ) { final optional < channelinstance > channel ; try ( locked l = lock ( this . readlock ) ) { channel = find ( by ) ; } if ( ! channel . ispresent ( ) ) { throw new channelnotfoundexception ( by . tostring ( ) ) ; } return channel . get ( ) ; }	Find a channel.
private void updatedeploygroupcache ( final channelserviceaccess model ) {	Update the channel to deploy group cache map.
public static long copy ( final inputstream in , final outputstream out ) throws ioexception { objects . requirenonnull ( in ) ; objects . requirenonnull ( out ) ; final byte [ ] buffer = new byte [ copy_buffer_size ] ; long result = num_ ; int rc ; while ( ( rc = in . read ( buffer ) ) >= num_ ) { result += rc ; out . write ( buffer , num_ , rc ) ; } return result ; }	Copy the remaining content of one stream to the other.
public static node . nodes parse ( parsercontroller pc , string path , jspreader reader , node parent , boolean istagfile , boolean directivesonly , url jarfileurl , string pageenc , string jspconfigpageenc , boolean isdefaultpageencoding , boolean hasbom ) throws jasperexception { parser parser = new parser ( pc , reader , istagfile , directivesonly , jarfileurl , hasbom ) ; node . root root = new node . root ( reader . mark ( ) , parent , bool_ ) ; root . setpageencoding ( pageenc ) ; root . setjspconfigpageencoding ( jspconfigpageenc ) ; root . setisdefaultpageencoding ( isdefaultpageencoding ) ; root . sethasbom ( hasbom ) ; if ( hasbom ) {	The main entry for Parser.
public static attributes parseattributes ( parsercontroller pc , jspreader reader ) throws jasperexception { parser tmpparser = new parser ( pc , reader , bool_ , bool_ , null , bool_ ) ; return tmpparser . parseattributes ( ) ; }	Parse Attributes for a reader, provided for external use.
private void addinclude ( node parent , list files ) throws jasperexception { if ( files != null ) { iterator iter = files . iterator ( ) ; while ( iter . hasnext ( ) ) { string file = ( string ) iter . next ( ) ; attributesimpl attrs = new attributesimpl ( ) ; attrs . addattribute ( str_ , str_ , str_ , str_ , file ) ;	Add a list of files.
private boolean parsejspattributeandbody ( node parent , string tag , string bodytype ) throws jasperexception { boolean result = bool_ ; if ( reader . matchesoptionalspacesfollowedby ( str_ ) ) {	Attempts to parse 'JspAttributeAndBody' production.
public void addattribute ( string name , string value ) { if ( attributes == null ) attributes = new hashmap < string , string > ( ) ; attributes . put ( name , value ) ; }	Add an attribute to this node, replacing any existing attributewith the same name.
public void addchild ( treenode node ) { if ( children == null ) children = new arraylist < treenode > ( ) ; children . add ( node ) ; }	Add a new child node to this node.
public iterator < string > findattributes ( ) { set < string > attrs ; if ( attributes == null ) attrs = collections . emptyset ( ) ; else attrs = attributes . keyset ( ) ; return attrs . iterator ( ) ; }	Return an Iterator of the attribute names of this node.
public iterator < treenode > findchildren ( ) { list < treenode > nodes ; if ( children == null ) nodes = collections . emptylist ( ) ; else nodes = children ; return nodes . iterator ( ) ; }	Return an Iterator of all children of this node.
public iterator < treenode > findchildren ( string name ) { list < treenode > results ; if ( children == null ) results = collections . emptylist ( ) ; else { results = new arraylist < treenode > ( ) ; for ( treenode item : children ) { if ( name . equals ( item . getname ( ) ) ) results . add ( item ) ; } } return results . iterator ( ) ; }	Return an Iterator over all children of this node that have thespecified name.
public mavencoordinates tobase ( ) { if ( this . classifier == null && this . extension == null ) { return this ; } return new mavencoordinates ( this . groupid , this . artifactid , this . version ) ; }	Create a new instance without classifier and extension.
private string findalias ( string varname ) { if ( aliases == null ) return varname ; string alias = aliases . get ( varname ) ; if ( alias == null ) { return varname ; } return alias ; }	Checks to see if the given variable name is used as an alias, and if so,returns the variable name for which it is used as an alias.
public static void setthread ( ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; data . set ( baos ) ; streams . set ( new printstream ( baos ) ) ; }	Start capturing thread's output.
public static string unsetthread ( ) { bytearrayoutputstream baos = ( bytearrayoutputstream ) data . get ( ) ; if ( baos == null ) { return null ; } streams . set ( null ) ; data . set ( null ) ; return baos . tostring ( ) ; }	Stop capturing thread's output and return captured data as a String.
protected printstream findstream ( ) { printstream ps = ( printstream ) streams . get ( ) ; if ( ps == null ) { ps = wrapped ; } return ps ; }	Find PrintStream to which the output must be written to.
protected static void writeoptional ( final stringwriter writer , final string fieldname , final string value ) { if ( value != null ) { write ( writer , fieldname , value ) ; } }	Write field only when the value is set.
protected static void write ( final stringwriter writer , final string fieldname , final string value ) { writer . write ( fieldname + str_ + value + str_ ) ; }	Write a field.
public static element addelement ( final element parent , final string name ) { final element ele = parent . getownerdocument ( ) . createelement ( name ) ; parent . appendchild ( ele ) ; return ele ; }	Create a new element and add it as the last child.
public static element addelementfirst ( final element parent , final string name ) { final element ele = parent . getownerdocument ( ) . createelement ( name ) ; parent . insertbefore ( ele , null ) ; return ele ; }	Create a new element and add it as the first child.
public void writeout ( writer out ) throws ioexception { if ( writer == null ) { out . write ( cb , num_ , nextchar ) ;	Write the contents of this BodyJspWriter into a Writer.Subclasses are likely to do interesting things with theimplementation so some things are extra efficient.
void setwriter ( writer writer ) { this . writer = writer ; if ( writer != null ) {	Sets the writer to which all output is written.
private void reallocbuff ( int len ) { if ( buffersize + len <= cb . length ) { buffersize = cb . length ; return ; } if ( len < cb . length ) { len = cb . length ; } buffersize = cb . length + len ; char [ ] tmp = new char [ buffersize ] ; system . arraycopy ( cb , num_ , tmp , num_ , cb . length ) ; cb = tmp ; tmp = null ; }	Reallocates buffer since the spec requires it to be unbounded.
public static void map ( compiler compiler , node . nodes page ) throws jasperexception { elfunctionmapper map = new elfunctionmapper ( ) ; map . ds = new stringbuilder ( ) ; map . ss = new stringbuilder ( ) ; page . visit ( map . new elfunctionvisitor ( ) ) ;	Creates the functions mappers for all EL expressions in the JSP page.
private static state getsameparent ( final state parent , final metakey key ) { state current = parent ; while ( current != null ) { if ( current . key . equals ( key ) ) { return current ; } current = current . parent ; } return null ; }	Traverse up from the provided parent and find the first which uses thesame key.
public storageregistration registermodel ( final long lockpriority , final metakey key , final storagemodelprovider < ? , ? > storageprovider ) throws modelinitializationexception { this . modellock . writelock ( ) . lock ( ) ; try { testclosed ( ) ; if ( this . modelkeymap . containskey ( key ) ) { throw new illegalargumentexception ( string . format ( str_ , key ) ) ; } try { storageprovider . start ( this . context ) ; } catch ( final exception e ) { throw new modelinitializationexception ( str_ + key , e ) ; } final long id = this . counter ++ ; final entry entry = new entry ( id , lockpriority , key , storageprovider ) ; this . modelidmap . put ( id , entry ) ; this . modelkeymap . put ( key , entry ) ; return new storageregistration ( ) { @ override public void unregister ( ) { unregistermodel ( id ) ; } } ; } finally { this . modellock . writelock ( ) . unlock ( ) ; } }	Register a new model with the storage manager.
public boolean stream ( final metakey key , final ioconsumer < inputstream > consumer ) throws ioexception { return streamfrom ( this . datapath , key , consumer ) ; }	Stream directly from the storage.
@ requestmapping ( str_ ) public modelandview monitor ( @ pathvariable ( str_ ) final string id ) { final jobhandle job = this . manager . getjob ( id ) ; if ( job != null ) { logger . debug ( str_ , job . getid ( ) , job . getstate ( ) ) ; } else { logger . debug ( str_ , id ) ; } final map < string , object > model = new hashmap < > ( num_ ) ; model . put ( str_ , job ) ; return new modelandview ( str_ , model ) ; }	Monitor the job, only produces an HTML fragment of the current job state.
protected boolean isauthenticated ( final by by , final httpservletrequest request ) { final string [ ] authtoks = parseauthorization ( request ) ; if ( authtoks == null ) { return bool_ ; }	Simply test if the request is authenticated against the channels deploykeys.
public void finish ( ) throws ioexception { if ( ! this . finished ) { this . finished = bool_ ; writeend ( ) ; } try { this . out . close ( ) ; } catch ( final xmlstreamexception e ) { throw new ioexception ( e ) ; } }	Complete the document but don't close the underlying writer.
public static gson makegson ( final boolean pretty ) { final gsonbuilder gb = new gsonbuilder ( ) ; if ( pretty ) { gb . setprettyprinting ( ) ; } gb . registertypeadapter ( node . class , new nodeadapter ( ) ) ; gb . registertypeadapter ( byte [ ] . class , new bytearrayadapter ( ) ) ; return gb . create ( ) ; }	Make an appropriate Gson parser to processing ChannelData instances.
public boolean encodeforlzma2 ( ) {	Compresses for LZMA2.
public static map < metakey , string > union ( final map < metakey , string > providedmetadata , final map < metakey , string > extractedmetadata ) { final int size1 = providedmetadata != null ? providedmetadata . size ( ) : num_ ; final int size2 = extractedmetadata != null ? extractedmetadata . size ( ) : num_ ; if ( size1 + size2 == num_ ) { return collections . emptymap ( ) ; } final map < metakey , string > result = new hashmap < > ( size1 + size2 ) ; if ( extractedmetadata != null ) { result . putall ( extractedmetadata ) ; }	Return an unmodifiable map of provided and extracted meta data.
public static throwable getthrowable ( servletrequest request ) { throwable error = ( throwable ) request . getattribute ( servlet_exception ) ; if ( error == null ) { error = ( throwable ) request . getattribute ( jsp_exception ) ; if ( error != null ) { request . setattribute ( servlet_exception , error ) ; } } return error ; }	Returns the value of the javax.servlet.error.exception requestattribute value, if present, otherwise the value of thejavax.servlet.jsp.jspException request attribute value.This method is called at the beginning of the generated servlet codefor a JSP error page, when the "exception" implicit scripting languagevariable is initialized.
private string ischecksum ( final coordinates c ) { final string cext = c . getextension ( ) ; if ( cext == null ) { return null ; } for ( final string ext : this . options . getchecksumextensions ( ) ) { if ( cext . endswith ( str_ + ext ) ) { return ext ; } } return null ; }	Check if the uploaded artifact is actually a checksum file.
public void finish ( ) throws ioexception { if ( ! finished ) { if ( exception != null ) throw exception ; try { if ( expecteduncompressedsize != - num_ && expecteduncompressedsize != currentuncompressedsize ) throw new xzioexception ( str_ + expecteduncompressedsize + str_ + str_ + currentuncompressedsize + str_ ) ; lz . setfinishing ( ) ; lzma . encodeforlzma1 ( ) ; if ( useendmarker ) lzma . encodelzma1endmarker ( ) ; rc . finish ( ) ; } catch ( ioexception e ) { exception = e ; throw e ; } finished = bool_ ; lzma . putarraystocache ( arraycache ) ; lzma = null ; lz = null ; } }	Finishes the stream without closing the underlying OutputStream.
public exception getexception ( ) { throwable t = jspruntimelibrary . getthrowable ( request ) ;	Returns the exception associated with this page context, if any.Added wrapping for Throwables to avoid ClassCastException(see Bugzilla 31171 for details).
public static object evaluateexpression ( final string expression , final class expectedtype , final pagecontext pagecontext , final protectedfunctionmapper functionmap ) throws elexception { object retvalue ; if ( securityutil . ispackageprotectionenabled ( ) ) { try { retvalue = accesscontroller . doprivileged ( new privilegedexceptionaction < object > ( ) { public object run ( ) throws exception { elcontextimpl elcontext = ( elcontextimpl ) pagecontext . getelcontext ( ) ; elcontext . setfunctionmapper ( functionmap ) ; expressionfactory expfactory = getexpressionfactory ( pagecontext ) ; valueexpression expr = expfactory . createvalueexpression ( elcontext , expression , expectedtype ) ; return expr . getvalue ( elcontext ) ; } } ) ; } catch ( privilegedactionexception ex ) { exception realex = ex . getexception ( ) ; if ( realex instanceof elexception ) { throw ( elexception ) realex ; } else { throw new elexception ( realex ) ; } } } else { elcontextimpl elcontext = ( elcontextimpl ) pagecontext . getelcontext ( ) ; elcontext . setfunctionmapper ( functionmap ) ; expressionfactory expfactory = getexpressionfactory ( pagecontext ) ; valueexpression expr = expfactory . createvalueexpression ( elcontext , expression , expectedtype ) ; retvalue = expr . getvalue ( elcontext ) ; } return retvalue ; }	Evaluates an EL expression.
protected string makeprefixfromosgiproperties ( ) { final string port = system . getproperty ( str_ ) ; if ( port == null ) { return null ; } final stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) . append ( discoverhostname ( ) ) ; if ( ! str_ . equals ( port ) ) { sb . append ( str_ ) . append ( port ) ; } return sb . tostring ( ) ; }	Make the prefix by guessing the port from the OSGi settings.
public static boolean isxml ( final path path ) throws ioexception { final xmltoolsfactory xml = activator . getxmltoolsfactory ( ) ; final xmlinputfactory xin = xml . newxmlinputfactory ( ) ; try ( inputstream stream = new bufferedinputstream ( files . newinputstream ( path ) ) ) { try { final xmlstreamreader reader = xin . createxmlstreamreader ( stream ) ; reader . next ( ) ; return bool_ ; } catch ( final xmlstreamexception e ) { return bool_ ; } } }	Test if this file is an XML file.
public static taginfo parsetagfiledirectives ( parsercontroller pc , string name , string path , taglibraryinfo taglibinfo ) throws jasperexception { errordispatcher err = pc . getcompiler ( ) . geterrordispatcher ( ) ; node . nodes page = null ; try { page = pc . parsetagfiledirectives ( path ) ; } catch ( filenotfoundexception e ) { err . jsperror ( str_ , path ) ; } catch ( ioexception e ) { err . jsperror ( str_ , path ) ; } tagfiledirectivevisitor tagfilevisitor = new tagfiledirectivevisitor ( pc . getcompiler ( ) , taglibinfo , name , path ) ; page . visit ( tagfilevisitor ) ; tagfilevisitor . postcheck ( ) ; return tagfilevisitor . gettaginfo ( ) ; }	Parses the tag file, and collects information on the directives includedin it.
private class loadtagfile ( compiler compiler , string tagfilepath , taginfo taginfo , pageinfo parentpageinfo ) throws jasperexception { jspcompilationcontext ctxt = compiler . getcompilationcontext ( ) ; jspruntimecontext rctxt = ctxt . getruntimecontext ( ) ; synchronized ( rctxt ) { jspservletwrapper wrapper = ( jspservletwrapper ) rctxt . getwrapper ( tagfilepath ) ; if ( wrapper == null ) { wrapper = new jspservletwrapper ( ctxt . getservletcontext ( ) , ctxt . getoptions ( ) , tagfilepath , taginfo , ctxt . getruntimecontext ( ) , ( url ) ctxt . gettagfilejarurls ( ) . get ( tagfilepath ) ) ; rctxt . addwrapper ( tagfilepath , wrapper ) ;	Compiles and loads a tagfile.
public void removeprototypefiles ( string classfilename ) { iterator < compiler > iter = tempvector . iterator ( ) ; while ( iter . hasnext ( ) ) { compiler c = iter . next ( ) ; if ( classfilename == null ) { c . removegeneratedclassfiles ( ) ; } else if ( classfilename . equals ( c . getcompilationcontext ( ) . getclassfilename ( ) ) ) { c . removegeneratedclassfiles ( ) ; tempvector . remove ( c ) ; return ; } } }	Removed the java and class files for the tag prototypegenerated from the current compilation.
public void seturiroot ( string s ) { uriroot = s ; if ( s != null ) { try { uriroot = new file ( s ) . getcanonicalpath ( ) ; } catch ( exception ex ) { uriroot = s ; } } }	Base dir for the webapp. Used to generate class names and resolveincludes.
public void scanfiles ( file base ) throws jasperexception { stack < string > dirs = new stack < string > ( ) ; dirs . push ( base . tostring ( ) ) ; if ( extensions == null ) { extensions = new arraylist < string > ( ) ; extensions . add ( str_ ) ; extensions . add ( str_ ) ; } while ( ! dirs . isempty ( ) ) { string s = dirs . pop ( ) ; file f = new file ( s ) ; if ( f . exists ( ) && f . isdirectory ( ) ) { string [ ] files = f . list ( ) ; string ext ; for ( int i = num_ ; ( files != null ) && i < files . length ; i ++ ) { file f2 = new file ( s , files [ i ] ) ; if ( f2 . isdirectory ( ) ) { dirs . push ( f2 . getpath ( ) ) ; } else { string path = f2 . getpath ( ) ; string uri = path . substring ( uriroot . length ( ) ) ; ext = files [ i ] . substring ( files [ i ] . lastindexof ( str_ ) + num_ ) ; if ( extensions . contains ( ext ) || jspconfig . isjsppage ( uri ) ) { pages . add ( path ) ; } } } } } }	Locate all jsp files in the webapp.
private void locateuriroot ( file f ) { string turibase = uribase ; if ( turibase == null ) { turibase = str_ ; } try { if ( f . exists ( ) ) { f = new file ( f . getcanonicalpath ( ) ) ; while ( f != null ) { file g = new file ( f , str_ ) ; if ( g . exists ( ) && g . isdirectory ( ) ) { uriroot = f . getcanonicalpath ( ) ; uribase = turibase ; if ( log . isloggable ( level . info ) ) { log . info ( localizer . getmessage ( str_ , uriroot ) ) ; } break ; } if ( f . exists ( ) && f . isdirectory ( ) ) { turibase = str_ + f . getname ( ) + str_ + turibase ; } string fparent = f . getparent ( ) ; if ( fparent == null ) { break ; } else { f = new file ( fparent ) ; }	Find the WEB-INF dir by looking up in the directory tree.This is used if no explicit docbase is set, but only files.XXX Maybe we should require the docbase.
private int movepos ( ) { int avail = movepos ( num_ , num_ ) ; if ( avail != num_ ) { if ( ++ lzpos == integer . max_value ) { int normalizationoffset = integer . max_value - cyclicsize ; hash . normalize ( normalizationoffset ) ; normalize ( chain , cyclicsize , normalizationoffset ) ; lzpos -= normalizationoffset ; } if ( ++ cyclicpos == cyclicsize ) cyclicpos = num_ ; } return avail ; }	Moves to the next byte, checks that there is enough available space,and possibly normalizes the hash tables and the hash chain.
boolean matches ( string string ) throws jasperexception { mark mark = mark ( ) ; int ch = num_ ; int i = num_ ; do { ch = nextchar ( ) ; if ( ( ( char ) ch ) != string . charat ( i ++ ) ) { reset ( mark ) ; return bool_ ; } } while ( i < string . length ( ) ) ; return bool_ ; }	search the stream for a match to a string.
boolean matchesoptionalspacesfollowedby ( string s ) throws jasperexception { mark mark = mark ( ) ; skipspaces ( ) ; boolean result = matches ( s ) ; if ( ! result ) { reset ( mark ) ; } return result ; }	Looks ahead to see if there are optional spaces followed bythe given String.
mark skipuntil ( string limit ) throws jasperexception { mark ret = null ; int limlen = limit . length ( ) ; int ch ; skip : for ( ret = mark ( ) , ch = nextchar ( ) ; ch != - num_ ; ret = mark ( ) , ch = nextchar ( ) ) { if ( ch == limit . charat ( num_ ) ) { mark restart = mark ( ) ; for ( int i = num_ ; i < limlen ; i ++ ) { if ( peekchar ( ) == limit . charat ( i ) ) nextchar ( ) ; else { reset ( restart ) ; continue skip ; } } return ret ; } } return null ; }	Skip until the given string is matched in the stream.When returned, the context is positioned past the end of the match.
mark skipuntilignoreesc ( string limit ) throws jasperexception { mark ret = null ; int limlen = limit . length ( ) ; int ch ; int prev = str_ ;	Skip until the given string is matched in the stream, but ignoringchars initially escaped by a '\'.When returned, the context is positioned past the end of the match.
mark skipuntiletag ( string tag ) throws jasperexception { mark ret = skipuntil ( str_ + tag ) ; if ( ret != null ) { skipspaces ( ) ; if ( nextchar ( ) != str_ ) ret = null ; } return ret ; }	Skip until the given end tag is matched in the stream.When returned, the context is positioned past the end of the tag.
string parsetoken ( boolean quoted ) throws jasperexception { stringbuilder stringbuffer = new stringbuilder ( ) ; skipspaces ( ) ; stringbuffer . setlength ( num_ ) ; if ( ! hasmoreinput ( ) ) { return str_ ; } int ch = peekchar ( ) ; if ( quoted ) { if ( ch == str_ || ch == str_ ) { char endquote = ch == str_ ? str_ : str_ ;	Parse a space delimited token.If quoted the token will consume all characters up to a matching quote,otherwise, it consumes up to the first delimiter character.
private boolean popfile ( ) throws jasperexception {	Pop a file from the file stack.
public coordinates makeunclassified ( ) { if ( this . classifier == null ) { return this ; } return new coordinates ( this . groupid , this . artifactid , this . version , this . qualifiedversion , null , this . extension ) ; }	Create an unclassified version of ourself.
public static list < aspectinformation > filterids ( final list < aspectinformation > list , final predicate < string > predicate ) { if ( list == null ) { return null ; } return list . stream ( ) . filter ( ( i ) -> predicate . test ( i . getfactoryid ( ) ) ) . collect ( collectors . tolist ( ) ) ; }	Filter the provided aspect lists by a predicate on the ID.
public string [ ] getmissingids ( final list < aspectinformation > assignedaspects ) { final set < aspectinformation > required = new hashset < > ( ) ; addrequired ( required , this , assignedaspects ) ; return required . stream ( ) . map ( aspectinformation :: getfactoryid ) . toarray ( size -> new string [ size ] ) ; }	Get all aspect ids which are currently missing but required by thisaspect.
public static void setschemaresourceprefix ( string prefix ) { if ( prefix != null && prefix . startswith ( str_ ) ) { schemaresourceprefix = uencode ( prefix ) ; isschemaresourceprefixfileurl = bool_ ; } else { schemaresourceprefix = prefix ; isschemaresourceprefixfileurl = bool_ ; } for ( int i = num_ ; i < cached_schema_resource_paths . length ; i ++ ) { string path = default_schema_resource_paths [ i ] ; int index = path . lastindexof ( str_ ) ; if ( index != - num_ ) { cached_schema_resource_paths [ i ] = schemaresourceprefix + path . substring ( index + num_ ) ; } } }	Sets the path prefix URL for .xsd resources.
public static void setdtdresourceprefix ( string prefix ) { if ( prefix != null && prefix . startswith ( str_ ) ) { dtdresourceprefix = uencode ( prefix ) ; isdtdresourceprefixfileurl = bool_ ; } else { dtdresourceprefix = prefix ; isdtdresourceprefixfileurl = bool_ ; } for ( int i = num_ ; i < cached_dtd_resource_paths . length ; i ++ ) { string path = default_dtd_resource_paths [ i ] ; int index = path . lastindexof ( str_ ) ; if ( index != - num_ ) { cached_dtd_resource_paths [ i ] = dtdresourceprefix + path . substring ( index + num_ ) ; } } }	Sets the path prefix URL for .dtd resources.
protected treenode convert ( treenode parent , node node ) {	Create and return a TreeNode that corresponds to the specified Node,including processing all of the attributes and children nodes.
private static void mergeerrors ( final bindingresult bindingresult , final bindingresult result ) { if ( bindingresult == null ) { return ; } result . adderrors ( bindingresult . getlocalerrors ( ) ) ; for ( final map . entry < string , bindingresult > child : bindingresult . getchildren ( ) . entryset ( ) ) { mergeerrors ( child . getvalue ( ) , result . getchildoradd ( child . getkey ( ) ) ) ; } }	Merge all errors of this binding into this result.
private void initializebinder ( final binder binder ) { for ( final method m : binder . getclass ( ) . getmethods ( ) ) { if ( ! m . isannotationpresent ( binder . initializer . class ) ) { continue ; } final call call = bind ( m , binder ) ; try { call . invoke ( ) ; } catch ( final exception e ) { throw new runtimeexception ( string . format ( str_ , binder , m ) , e ) ; } } }	Initialize the binder with our current state.
public static map < string , channelaspectinformation > scanaspectinformations ( final bundlecontext context ) { collection < servicereference < channelaspectfactory > > refs ; try { refs = context . getservicereferences ( channelaspectfactory . class , null ) ; } catch ( final invalidsyntaxexception e ) {	This actively scans for available aspects and returns their informationobjects.
private static string unqualify ( string path ) { path = path . replace ( str_ , str_ ) ; return path . substring ( path . lastindexof ( str_ ) + num_ ) ; }	Returns an unqualified version of the given file path.
private void invokeplugin ( node . customtag n ) { tagplugin tagplugin = tagplugins . get ( n . gettaghandlerclass ( ) . getname ( ) ) ; if ( tagplugin == null ) { return ; } tagplugincontext tagplugincontext = new tagplugincontextimpl ( n , pageinfo ) ; n . settagplugincontext ( tagplugincontext ) ; tagplugin . dotag ( tagplugincontext ) ; }	Invoke tag plugin for the given custom tag, if a plugin exists forthe custom tag's tag handler.The given custom tag node will be manipulated by the plugin.
public byte [ ] getbytearray ( int size , boolean fillwithzeros ) { byte [ ] array = getarray ( bytearraycache , size ) ; if ( array == null ) array = new byte [ size ] ; else if ( fillwithzeros ) arrays . fill ( array , ( byte ) num_ ) ; return array ; }	Allocates a new byte array, hopefully reusing an existingarray from the cache.
public int [ ] getintarray ( int size , boolean fillwithzeros ) { int [ ] array = getarray ( intarraycache , size ) ; if ( array == null ) array = new int [ size ] ; else if ( fillwithzeros ) arrays . fill ( array , num_ ) ; return array ; }	This is like getByteArray but for int arrays.
public static aetherresult asresult ( final collection < artifactresult > results , final importconfiguration cfg , final optional < dependencyresult > dependencyresult ) { final aetherresult result = new aetherresult ( ) ;	Convert aether result list to AetherResult object.
private inputstream getresourceasstream ( string uri ) throws jasperexception { try {	the following is a workaround until these problems are resolved.
public validationmessage [ ] validate ( pagedata thepage ) { taglibraryvalidator tlv = gettaglibraryvalidator ( ) ; if ( tlv == null ) return null ; string uri = geturi ( ) ; if ( uri . startswith ( str_ ) ) { uri = urn_jsptld + uri ; } validationmessage [ ] messages = tlv . validate ( getprefixstring ( ) , uri , thepage ) ; tlv . release ( ) ; return messages ; }	Translation-time validation of the XML documentassociated with the JSP page.This is a convenience method on the associatedTagLibraryValidator class.
public void pushstream ( char [ ] instream , int infileid , string name , string inbasedir , string inencoding ) {	Sets this mark's state to a new stream.It will store the current stream in it's includeStack.
public static object [ ] getencoding ( string fname , jarfile jarfile , jspcompilationcontext ctxt , errordispatcher err ) throws ioexception , jasperexception { inputstream instream = jsputil . getinputstream ( fname , jarfile , ctxt , err ) ; xmlencodingdetector detector = new xmlencodingdetector ( ) ; object [ ] ret = detector . getencoding ( instream , err ) ; instream . close ( ) ; return ret ; }	Autodetects the encoding of the XML document supplied by the giveninput stream.Encoding autodetection is done according to the XML 1.0 specification,Appendix F.1: Detection Without External Encoding Information.
private void reportfatalerror ( string msgid , string arg ) throws jasperexception { err . jsperror ( msgid , arg ) ; }	Convenience function used in all XML scanners.
public string getrealpath ( string path ) { if ( ! myresourcebaseurl . getprotocol ( ) . equals ( str_ ) ) return ( null ) ; if ( ! path . startswith ( str_ ) ) return ( null ) ; try { return ( getresource ( path ) . getfile ( ) . replace ( str_ , file . separatorchar ) ) ; } catch ( throwable t ) { return ( null ) ; } }	Return the real path for the specified context-relativevirtual path.
public url getresource ( string path ) throws malformedurlexception { if ( ! path . startswith ( str_ ) ) throw new malformedurlexception ( str_ + path + str_ ) ; url url = new url ( myresourcebaseurl , path . substring ( num_ ) ) ; inputstream is = null ; try { is = url . openstream ( ) ; } catch ( throwable t ) { url = null ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( throwable t2 ) {	Return a URL object of a resource that is mapped to thespecified context-relative path.
public inputstream getresourceasstream ( string path ) { try { return ( getresource ( path ) . openstream ( ) ) ; } catch ( throwable t ) { return ( null ) ; } }	Return an InputStream allowing access to the resource at thespecified context-relative path.
public set < string > getresourcepaths ( string path ) { set < string > thepaths = new hashset < string > ( ) ; if ( ! path . endswith ( str_ ) ) path += str_ ; string basepath = getrealpath ( path ) ; if ( basepath == null ) return ( thepaths ) ; file thebasedir = new file ( basepath ) ; if ( ! thebasedir . exists ( ) || ! thebasedir . isdirectory ( ) ) return ( thepaths ) ; string thefiles [ ] = thebasedir . list ( ) ; for ( int i = num_ ; i < thefiles . length ; i ++ ) { file testfile = new file ( basepath + file . separator + thefiles [ i ] ) ; if ( testfile . isfile ( ) ) thepaths . add ( path + thefiles [ i ] ) ; else if ( testfile . isdirectory ( ) ) thepaths . add ( path + thefiles [ i ] + str_ ) ; } return ( thepaths ) ; }	Return the set of resource paths for the "directory" at thespecified context path.
public void log ( string message , throwable exception ) { mylogwriter . println ( message ) ; exception . printstacktrace ( mylogwriter ) ; }	Log the specified message and exception.
public void addfilter ( string filtername , string description , string classname , map < string , string > initparameters ) {	Adds the filter with the given name, description, and class name tothis servlet context.
private static int getbufsize ( int dictsize , int extrasizebefore , int extrasizeafter , int matchlenmax ) { int keepsizebefore = extrasizebefore + dictsize ; int keepsizeafter = extrasizeafter + matchlenmax ; int reservesize = math . min ( dictsize / num_ + ( num_ << num_ ) , num_ << num_ ) ; return keepsizebefore + keepsizeafter + reservesize ; }	Gets the size of the LZ window buffer that needs to be allocated.
public static int getmemoryusage ( int dictsize , int extrasizebefore , int extrasizeafter , int matchlenmax , int mf ) {	Gets approximate memory usage of the LZEncoder base structure andthe match finder as kibibytes.
public void setpresetdict ( int dictsize , byte [ ] presetdict ) { assert ! isstarted ( ) ; assert writepos == num_ ; if ( presetdict != null ) {	Sets a preset dictionary.
private void movewindow ( ) {	Moves data from the end of the buffer to the beginning, discardingold data and making space for new input.
public int fillwindow ( byte [ ] in , int off , int len ) { assert ! finishing ;	Copies new data into the LZEncoder's buffer.
private void processpendingbytes ( ) {	Process pending bytes remaining from preset dictionary initializationor encoder flush operation.
public int getmatchlen ( int dist , int lenlimit ) { int backpos = readpos - dist - num_ ; int len = num_ ; while ( len < lenlimit && buf [ readpos + len ] == buf [ backpos + len ] ) ++ len ; return len ; }	Get the length of a match at the given distance.
public int getmatchlen ( int forward , int dist , int lenlimit ) { int curpos = readpos + forward ; int backpos = curpos - dist - num_ ; int len = num_ ; while ( len < lenlimit && buf [ curpos + len ] == buf [ backpos + len ] ) ++ len ; return len ; }	Get the length of a match at the given distance and forward offset.
public boolean verifymatches ( matches matches ) { int lenlimit = math . min ( getavail ( ) , matchlenmax ) ; for ( int i = num_ ; i < matches . count ; ++ i ) if ( getmatchlen ( matches . dist [ i ] , lenlimit ) != matches . len [ i ] ) return bool_ ; return bool_ ; }	Verifies that the matches returned by the match finder are valid.This is meant to be used in an assert statement.
int movepos ( int requiredforflushing , int requiredforfinishing ) { assert requiredforflushing >= requiredforfinishing ; ++ readpos ; int avail = writepos - readpos ; if ( avail < requiredforflushing ) { if ( avail < requiredforfinishing || ! finishing ) { ++ pendingsize ; avail = num_ ; } } return avail ; }	Moves to the next byte, checks if there is enough input available,and returns the amount of input available.
void recycle ( ) { flushed = bool_ ; closed = bool_ ; out = null ; byteout = null ; releasecharbuffer ( ) ; response = null ; }	Package-level access.
protected final void flushbuffer ( ) throws ioexception { if ( buffersize == num_ ) return ; flushed = bool_ ; ensureopen ( ) ; if ( buf . pos == buf . offset ) return ; initout ( ) ; out . write ( buf . buf , buf . offset , buf . pos - buf . offset ) ; buf . pos = buf . offset ; }	Flush the output buffer to the underlying character stream, withoutflushing the stream itself.
public final void clear ( ) throws ioexception { if ( ( buffersize == num_ ) && ( out != null ) )	Discard the output buffer.
public void flush ( ) throws ioexception { flushbuffer ( ) ; if ( out != null ) { out . flush ( ) ; }	Flush the stream.
public void close ( ) throws ioexception { if ( response == null || closed )	Close the stream.
public void write ( boolean bytesok , byte buf [ ] , string str ) throws ioexception { ensureopen ( ) ; if ( buffersize == num_ && bytesok ) { initbyteout ( ) ; if ( implementsbytewriter ) { write ( buf , num_ , buf . length ) ; return ; } } write ( str ) ; }	Attempt to write a String pre-encoded with the page encoding.
public void javacerror ( string errorreport , exception exception ) throws jasperexception { throw new jasperexception ( localizer . getmessage ( str_ ) , exception ) ; }	Processes the given javac error report and exception.
public list < string > makekey ( final map < metakey , string > metadata , final boolean requireall ) { final list < string > result = new arraylist < > ( this . fields . size ( ) ) ; for ( final metakey field : this . fields ) { final string value = metadata . get ( field ) ; if ( requireall && value == null ) { return null ; } result . add ( value ) ; } return result ; }	Make a key from the aggregator fields.
private void generateclass ( ) throws filenotfoundexception , jasperexception , exception { long t1 = num_ ; if ( log . isloggable ( level . fine ) ) { t1 = system . currenttimemillis ( ) ; } string javafilename = ctxt . getservletjavafilename ( ) ; setjavacompileroptions ( ) ;	Compile the servlet from .java file to .class file.
public void compile ( boolean compileclass ) throws filenotfoundexception , jasperexception , exception { try {	Compile the jsp file from the current engine context.
private void initjavacompiler ( ) throws jasperexception { boolean disablejsr199 = boolean . true . tostring ( ) . equals ( system . getproperty ( str_ ) ) ; double version = double . valueof ( system . getproperty ( str_ ) ) ; if ( ! disablejsr199 && ( version >= num_ || getclassfor ( str_ ) != null ) ) {	Get an instance of JavaCompiler.If Running with JDK 6, use a Jsr199JavaCompiler that supports JSR199,else if eclipse's JDT compiler is available, use that.The default is to use javac from ant.
private boolean systemjarinwebinf ( string path ) { if ( path . indexof ( str_ ) < num_ ) { return bool_ ; } boolean usemyfaces = ( boolean ) ctxt . getservletcontext ( ) . getattribute ( str_ ) ; if ( usemyfaces == null || ! usemyfaces ) { for ( string jar : systemjsfjars ) { if ( path . indexof ( jar ) > num_ ) { return bool_ ; } } } for ( string jar : systemjars ) { if ( path . indexof ( jar ) > num_ ) { return bool_ ; } } return bool_ ; }	Return true if the path refers to a jar file in WEB-INF and is asystem jar.
static string quote ( char c ) { stringbuilder b = new stringbuilder ( ) ; b . append ( str_ ) ; if ( c == str_ ) b . append ( str_ ) . append ( str_ ) ; else if ( c == str_ ) b . append ( str_ ) . append ( str_ ) ; else if ( c == str_ ) b . append ( str_ ) . append ( str_ ) ; else if ( c == str_ ) b . append ( str_ ) . append ( str_ ) ; else b . append ( c ) ; b . append ( str_ ) ; return b . tostring ( ) ; }	Single quote and escape a character.
private void generatedeclarations ( node . nodes page ) throws jasperexception { class declarationvisitor extends node . visitor { private boolean getservletinfogenerated = bool_ ; public void visit ( node . pagedirective n ) throws jasperexception { if ( getservletinfogenerated ) { return ; } string info = n . getattributevalue ( str_ ) ; if ( info == null ) return ; getservletinfogenerated = bool_ ; out . printil ( str_ ) ; out . pushindent ( ) ; out . printin ( str_ ) ; out . print ( quote ( info ) ) ; out . println ( str_ ) ; out . popindent ( ) ; out . printil ( str_ ) ; out . println ( ) ; } public void visit ( node . declaration n ) throws jasperexception { n . setbeginjavaline ( out . getjavaline ( ) ) ; out . printmultiln ( n . gettext ( ) ) ; out . println ( ) ; n . setendjavaline ( out . getjavaline ( ) ) ; }	Generates declarations. This includes "info" of the page directive,and scriptlet declarations.
private void compiletaghandlerpoollist ( node . nodes page ) throws jasperexception { class taghandlerpoolvisitor extends node . visitor { private set < string > names = new hashset < string > ( ) ; taghandlerpoolvisitor ( set < string > v ) { names = v ; } public void visit ( node . customtag n ) throws jasperexception { if ( ! n . implementssimpletag ( ) ) { string name = createtaghandlerpoolname ( n . getprefix ( ) , n . getlocalname ( ) , n . getattributes ( ) , n . hasemptybody ( ) ) ; n . settaghandlerpoolname ( name ) ; if ( ! names . contains ( name ) ) { names . add ( name ) ; } } visitbody ( n ) ; } private string createtaghandlerpoolname ( string prefix , string shortname , attributes attrs , boolean hasemptybody ) { string poolname = null ; poolname = str_ + prefix + str_ + shortname ; if ( attrs != null ) { string [ ] attrnames = new string [ attrs . getlength ( ) ] ; for ( int i = num_ ; i < attrnames . length ; i ++ ) { attrnames [ i ] = attrs . getqname ( i ) ; } arrays . sort ( attrnames , collections . reverseorder ( ) ) ; for ( int i = num_ ; i < attrnames . length ; i ++ ) { poolname = poolname + str_ + attrnames [ i ] ; } } if ( hasemptybody ) { poolname = poolname + str_ ; } return jsputil . makexmljavaidentifier ( poolname ) ; } } page . visit ( new taghandlerpoolvisitor ( taghandlerpoolnames ) ) ; }	Compiles list of tag handler pool names.
private void generatexmlprolog ( node . nodes page ) { string omitxmldecl = pageinfo . getomitxmldecl ( ) ; if ( ( omitxmldecl != null && ! jsputil . booleanvalue ( omitxmldecl ) ) || ( omitxmldecl == null && page . getroot ( ) . isxmlsyntax ( ) && ! pageinfo . hasjsproot ( ) && ! ctxt . istagfile ( ) ) ) { string ctype = pageinfo . getcontenttype ( ) ; string charset = ctype . substring ( ctype . indexof ( str_ ) + num_ ) ; out . printil ( str_ + charset + str_ ) ; } string doctypename = pageinfo . getdoctypename ( ) ; if ( doctypename != null ) { string doctypepublic = pageinfo . getdoctypepublic ( ) ; string doctypesystem = pageinfo . getdoctypesystem ( ) ; out . printin ( str_ ) ; out . print ( doctypename ) ; if ( doctypepublic == null ) { out . print ( str_ ) ; } else { out . print ( str_ ) ; out . print ( doctypepublic ) ; out . print ( str_ ) ; } out . print ( doctypesystem ) ; out . println ( str_ ) ; } }	Generates an XML Prolog, which includes an XML declaration andan XML doctype declaration.
private void gencommonpostamble ( ) {	Common part of postamble, shared by both servlets and tag files.
private void generatepostamble ( node . nodes page ) { out . popindent ( ) ; out . printil ( str_ ) ; out . pushindent ( ) ; out . printil ( str_ ) ; out . pushindent ( ) ; out . printil ( str_ ) ; out . printil ( str_ ) ; out . pushindent ( ) ; out . printil ( str_ ) ; out . popindent ( ) ; out . printil ( str_ ) ; out . printil ( str_ ) ; out . popindent ( ) ; out . printil ( str_ ) ; out . popindent ( ) ; out . printil ( str_ ) ; out . pushindent ( ) ; out . printil ( str_ ) ; out . popindent ( ) ; out . printil ( str_ ) ;	Generates the ending part of the static portion of the servlet.
public static void generate ( servletwriter out , compiler compiler , node . nodes page ) throws jasperexception { generator gen = new generator ( out , compiler ) ; if ( gen . ispoolingenabled ) { gen . compiletaghandlerpoollist ( page ) ; } if ( gen . ctxt . istagfile ( ) ) { jaspertaginfo taginfo = ( jaspertaginfo ) gen . ctxt . gettaginfo ( ) ; gen . generatetaghandlerpreamble ( taginfo , page ) ; if ( gen . ctxt . isprototypemode ( ) ) { return ; } gen . generatexmlprolog ( page ) ; gen . fragmenthelperclass . generatepreamble ( ) ; page . visit ( gen . new generatevisitor ( gen . ctxt . istagfile ( ) , out , gen . methodsbuffered , gen . fragmenthelperclass ) ) ; gen . generatetaghandlerpostamble ( taginfo ) ; } else { gen . generatepreamble ( page ) ; gen . generatexmlprolog ( page ) ; gen . fragmenthelperclass . generatepreamble ( ) ; page . visit ( gen . new generatevisitor ( gen . ctxt . istagfile ( ) , out , gen . methodsbuffered , gen . fragmenthelperclass ) ) ; gen . generatepostamble ( page ) ; } }	The main entry for Generator.
private void generatetaghandlerattributes ( taginfo taginfo ) throws jasperexception { if ( taginfo . hasdynamicattributes ( ) ) { out . printil ( str_ ) ; }	Generates declarations for tag handler attributes, and defines thegetter and setter methods for each.
private map < metakey , string > readproperties ( final inputstream stream ) throws ioexception { try {	Read in a map of properties.
private void exportchannel ( final by by , final outputstream stream ) throws ioexception { final zipoutputstream zos = new zipoutputstream ( stream ) ; initexportfile ( zos ) ; this . channelservice . accessrun ( by , readablechannel . class , channel -> { putdataentry ( zos , str_ , makenames ( channel . getid ( ) ) ) ; putdataentry ( zos , str_ , channel . getid ( ) . getdescription ( ) ) ; putdirentry ( zos , str_ ) ; putproperties ( zos , str_ , channel . getcontext ( ) . getprovidedmetadata ( ) ) ; putaspects ( zos , channel . getcontext ( ) . getaspectstates ( ) . keyset ( ) ) ;	Export the content of a channel.
private static void validatexmlview ( pagedata xmlview , compiler compiler ) throws jasperexception { stringbuilder errmsg = null ; errordispatcher errdisp = compiler . geterrordispatcher ( ) ; for ( iterator < taglibraryinfo > iter = compiler . getpageinfo ( ) . gettaglibs ( ) . iterator ( ) ; iter . hasnext ( ) ; ) { taglibraryinfo o = iter . next ( ) ; if ( ! ( o instanceof taglibraryinfoimpl ) ) continue ; taglibraryinfoimpl tli = ( taglibraryinfoimpl ) o ; validationmessage [ ] errors = tli . validate ( xmlview ) ; if ( ( errors != null ) && ( errors . length != num_ ) ) { if ( errmsg == null ) { errmsg = new stringbuilder ( ) ; } errmsg . append ( str_ ) ; errmsg . append ( localizer . getmessage ( str_ , tli . getshortname ( ) ) ) ; errmsg . append ( str_ ) ; for ( int i = num_ ; i < errors . length ; i ++ ) { if ( errors [ i ] != null ) { errmsg . append ( str_ ) ; errmsg . append ( errors [ i ] . getid ( ) ) ; errmsg . append ( str_ ) ; errmsg . append ( errors [ i ] . getmessage ( ) ) ; errmsg . append ( str_ ) ; } } } } if ( errmsg != null ) { errdisp . jsperror ( errmsg . tostring ( ) ) ; } }	Validate XML view against the TagLibraryValidator classes of allimported tag libraries.
public < t extends jsptag > jsptag get ( class < t > handlerclass ) throws jspexception { synchronized ( this ) { if ( current >= num_ ) { return handlers [ current -- ] ; } }	Gets the next available tag handler from this tag handler pool,instantiating one if this tag handler pool is empty.
public static elnode . nodes parse ( string expression ) { elparser parser = new elparser ( expression ) ; while ( parser . hasnextchar ( ) ) { string text = parser . skipuntilel ( ) ; if ( text . length ( ) > num_ ) { parser . expr . add ( new elnode . text ( text ) ) ; } elnode . nodes elexpr = parser . parseel ( ) ; if ( ! elexpr . isempty ( ) ) { parser . expr . add ( new elnode . root ( elexpr , parser . isdollarexpr ) ) ; } } return parser . expr ; }	Parse an EL expression.
private jsppropertygroup selectproperty ( jsppropertygroup prev , jsppropertygroup curr ) { if ( prev == null ) { return curr ; } if ( prev . getextension ( ) == null ) {	Select the property group that has more restrictive url-pattern.In case of tie, select the first.
public boolean isjsppage ( string uri ) throws jasperexception { init ( ) ; if ( jspproperties == null ) { return bool_ ; } string uripath = null ; int index = uri . lastindexof ( str_ ) ; if ( index >= num_ ) { uripath = uri . substring ( num_ , index + num_ ) ; } string uriextension = null ; index = uri . lastindexof ( str_ ) ; if ( index >= num_ ) { uriextension = uri . substring ( index + num_ ) ; } for ( jsppropertygroup jpg : jspproperties ) { jspproperty jp = jpg . getjspproperty ( ) ; string extension = jpg . getextension ( ) ; string path = jpg . getpath ( ) ; if ( extension == null ) { if ( uri . equals ( path ) ) {	To find out if an uri matches an url pattern in jsp config.
public void printcomment ( mark start , mark stop , char [ ] chars ) { if ( start != null && stop != null ) { println ( str_ + start ) ; println ( str_ + stop ) ; } if ( chars != null ) for ( int i = num_ ; i < chars . length ; ) { printin ( ) ; print ( str_ ) ; while ( chars [ i ] != str_ && i < chars . length ) writer . print ( chars [ i ++ ] ) ; } }	Print a standard comment for echo outputed chunk.
public void printin ( string s ) { writer . print ( spaces . substring ( num_ , indent ) ) ; writer . print ( s ) ; }	Prints the current indention, followed by the given string.
public void printil ( string s ) { javaline ++ ; writer . print ( spaces . substring ( num_ , indent ) ) ; writer . println ( s ) ; }	Prints the current indention, and then the string, and a '\n'.
public void printmultiln ( string s ) { int index = num_ ;	Prints the given string.If the string spans multiple lines, the line count will be adjustedaccordingly.
public static string getexprinxml ( string expression ) { string returnstring ; int length = expression . length ( ) ; if ( expression . startswith ( open_expr ) && expression . endswith ( close_expr ) ) { returnstring = expression . substring ( num_ , length - num_ ) ; } else { returnstring = expression ; } return escapexml ( returnstring ) ; }	Takes a potential expression and converts it into XML form.
public static void checkscope ( string scope , node n , errordispatcher err ) throws jasperexception { if ( scope != null && ! scope . equals ( str_ ) && ! scope . equals ( str_ ) && ! scope . equals ( str_ ) && ! scope . equals ( str_ ) ) { err . jsperror ( n , str_ , scope ) ; } }	Checks to see if the given scope is valid.
public static string escapexml ( string s ) { if ( s == null ) return null ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == str_ ) { sb . append ( str_ ) ; } else if ( c == str_ ) { sb . append ( str_ ) ; } else if ( c == str_ ) { sb . append ( str_ ) ; } else if ( c == str_ ) { sb . append ( str_ ) ; } else if ( c == str_ ) { sb . append ( str_ ) ; } else { sb . append ( c ) ; } } return sb . tostring ( ) ; }	Escape the 5 entities defined by XML.
public static void validateexpressions ( mark where , string expressions , functionmapper functionmapper , errordispatcher err ) throws jasperexception { try { elcontextimpl elcontext = new elcontextimpl ( null ) ; elcontext . setfunctionmapper ( functionmapper ) ; getexpressionfactory ( ) . createvalueexpression ( elcontext , expressions , object . class ) ; } catch ( elexception e ) { err . jsperror ( where , str_ , expressions , e . tostring ( ) ) ; } }	Validates the syntax of all EL expressions within the given string.
public static string gettaghandlerclassname ( string path , errordispatcher err ) throws jasperexception { string classname = null ; int begin = num_ ; int index ; index = path . lastindexof ( str_ ) ; if ( index == - num_ ) { err . jsperror ( str_ , path ) ; }	Gets the fully-qualified class name of the tag handler corresponding tothe given tag file path.
public static final string makejavapackage ( string path ) { string classnamecomponents [ ] = split ( path , str_ ) ; stringbuilder legalclassnames = new stringbuilder ( ) ; for ( int i = num_ ; i < classnamecomponents . length ; i ++ ) { legalclassnames . append ( makejavaidentifier ( classnamecomponents [ i ] ) ) ; if ( i < classnamecomponents . length - num_ ) { legalclassnames . append ( str_ ) ; } } return legalclassnames . tostring ( ) ; }	Converts the given path to a Java package or fully-qualified class name.
private static final string [ ] split ( string path , string pat ) { arraylist < string > comps = new arraylist < string > ( ) ; int pos = path . indexof ( pat ) ; int start = num_ ; while ( pos >= num_ ) { if ( pos > start ) { string comp = path . substring ( start , pos ) ; comps . add ( comp ) ; } start = pos + pat . length ( ) ; pos = path . indexof ( pat , start ) ; } if ( start < path . length ( ) ) { comps . add ( path . substring ( start ) ) ; } string [ ] result = new string [ comps . size ( ) ] ; for ( int i = num_ ; i < comps . size ( ) ; i ++ ) { result [ i ] = comps . get ( i ) ; } return result ; }	Splits a string into it's components.
public static final string makejavaidentifier ( string identifier ) { stringbuilder modifiedidentifier = new stringbuilder ( identifier . length ( ) ) ; if ( ! character . isjavaidentifierstart ( identifier . charat ( num_ ) ) ) { modifiedidentifier . append ( str_ ) ; } for ( int i = num_ ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . charat ( i ) ; if ( character . isjavaidentifierpart ( ch ) && ch != str_ ) { modifiedidentifier . append ( ch ) ; } else if ( ch == str_ ) { modifiedidentifier . append ( str_ ) ; } else { modifiedidentifier . append ( manglechar ( ch ) ) ; } } if ( isjavakeyword ( modifiedidentifier . tostring ( ) ) ) { modifiedidentifier . append ( str_ ) ; } return modifiedidentifier . tostring ( ) ; }	Converts the given identifier to a legal Java identifier.
public static final string manglechar ( char ch ) { char [ ] result = new char [ num_ ] ; result [ num_ ] = str_ ; result [ num_ ] = character . fordigit ( ( ch > > num_ ) & num_ , num_ ) ; result [ num_ ] = character . fordigit ( ( ch > > num_ ) & num_ , num_ ) ; result [ num_ ] = character . fordigit ( ( ch > > num_ ) & num_ , num_ ) ; result [ num_ ] = character . fordigit ( ch & num_ , num_ ) ; return new string ( result ) ; }	Mangle the specified character to create a legal Java class name.
public static boolean isjavakeyword ( string key ) { int i = num_ ; int j = javakeywords . length ; while ( i < j ) { int k = ( i + j ) / num_ ; int result = javakeywords [ k ] . compareto ( key ) ; if ( result == num_ ) { return bool_ ; } if ( result < num_ ) { i = k + num_ ; } else { j = k ; } } return bool_ ; }	Test whether the argument is a Java keyword.
private static void addproperty ( final map < string , string > props , final string key , final string value ) { if ( value == null ) { return ; } props . put ( key , value ) ; }	Add property entry only of value is not null.
public static string modifier ( final string prefix , final modifier modifier ) { if ( modifier == null ) { return str_ ; } string value = null ; switch ( modifier ) { case default : value = str_ ; break ; case primary : value = str_ ; break ; case success : value = str_ ; break ; case info : value = str_ ; break ; case warning : value = str_ ; break ; case danger : value = str_ ; break ; case link : value = str_ ; break ; } if ( value != null && prefix != null ) { return prefix + value ; } else { return value != null ? value : str_ ; } }	Convert a modifier value to a bootstrap type modifier.
public static sortedset < string > metadata ( final map < metakey , string > metadata , string namespace , string key ) { final sortedset < string > result = new treeset < > ( ) ; if ( namespace . isempty ( ) ) { namespace = null ; } if ( key . isempty ( ) ) { key = null ; } for ( final map . entry < metakey , string > entry : metadata . entryset ( ) ) { if ( namespace != null && ! namespace . equals ( entry . getkey ( ) . getnamespace ( ) ) ) { continue ; } if ( key != null && ! key . equals ( entry . getkey ( ) . getkey ( ) ) ) { continue ; } result . add ( entry . getvalue ( ) ) ; } return result ; }	Get all meta data values which match namespace and key.
@ override public void run ( ) throws exception { this . storagemanager . modifyrun ( model_key , userwritemodel . class , users -> { final date timeout = new date ( system . currenttimemillis ( ) - gettimeout ( ) ) ; final collection < userentity > updates = new linkedlist < > ( ) ; final collection < string > removals = new linkedlist < > ( ) ; for ( final userentity user : users . ascollection ( ) ) { if ( user . getemailtokendate ( ) == null || user . getemailtokendate ( ) . after ( timeout ) ) { continue ; }	Clean up timed out user registrations.
public static string getbasename ( final string name ) { if ( name == null ) { return null ; } final string [ ] toks = name . split ( str_ ) ; if ( toks . length < num_ ) { return name ; } return toks [ toks . length - num_ ] ; }	Get the last segment of a path, the filename.
public boolean put ( locator locator , string key , string value ) throws cacheexception { if ( value == null ) return bool_ ; timer . context cacheputtimercontext = metadatacache . cacheputtimer . time ( ) ; boolean dbwrite = bool_ ; try { cachekey cachekey = new cachekey ( locator , key ) ; string oldvalue = cache . getifpresent ( cachekey ) ;	returns true if updated.
private string databaseload ( locator locator , string key ) throws cacheexception { try { cachekey cachekey = new cachekey ( locator , key ) ; map < string , string > metadata = io . getallvalues ( locator ) ; if ( metadata == null || metadata . isempty ( ) ) { cache . put ( cachekey , null ) ; return null ; } int metadatarowsize = num_ ;	implements the CacheLoader interface.
public static collection < imetric > buildmetricscollection ( aggregatedpayload payload ) { collection < imetric > metrics = new arraylist < imetric > ( ) ; metrics . addall ( preaggregateconversions . convertcounters ( payload . gettenantid ( ) , payload . gettimestamp ( ) , payload . getflushintervalmillis ( ) , payload . getcounters ( ) ) ) ; metrics . addall ( preaggregateconversions . convertgauges ( payload . gettenantid ( ) , payload . gettimestamp ( ) , payload . getgauges ( ) ) ) ; metrics . addall ( preaggregateconversions . convertsets ( payload . gettenantid ( ) , payload . gettimestamp ( ) , payload . getsets ( ) ) ) ; metrics . addall ( preaggregateconversions . converttimers ( payload . gettenantid ( ) , payload . gettimestamp ( ) , payload . gettimers ( ) ) ) ; return metrics ; }	type comparisions we use to determine how to serialize a number.
public static number resolvenumber ( number n ) { if ( n instanceof lazilyparsednumber ) { try { return n . longvalue ( ) ; } catch ( numberformatexception ex ) { return n . doublevalue ( ) ; } } else {	resolve a number to a Long or double.
private static void writetooutputstream ( object obj , codedoutputstream out ) throws ioexception { out . writerawbyte ( string ) ; out . writestringnotag ( ( string ) obj ) ; }	writes object to CodedOutputStream.
protected int getttl ( locator locator , rolluptype rolluptype , granularity granularity ) { return ( int ) ttl_provider . getttl ( locator . gettenantid ( ) , granularity , rolluptype ) . get ( ) . toseconds ( ) ; }	Gets the TTL for a particular locator, rollupType and granularity.
private void createpreparedstatements ( ) {	Create all prepared statements use in this class for metrics_locator.
public void trackdelayedmetricstenant ( string tenantid , final list < metric > delayedmetrics ) { if ( istrackingdelayedmetrics ) { string logmessage = string . format ( str_ , tenantid ) ; log . info ( logmessage ) ;	This method is used to log delayed metrics, if tracking delayed metricsis turned on for this Blueflood service.
public void trackdelayedaggregatedmetricstenant ( string tenantid , long collectiontimems , long delaytimems , list < string > delayedmetricnames ) { if ( istrackingdelayedmetrics ) { string logmessage = string . format ( str_ , tenantid ) ; log . info ( logmessage ) ;	This method logs the delayed aggregated metrics for a particular tenant,if tracking delayed metric is turned on for this Blueflood service.Aggregated metrics have one single timestamp for the group of metrics thatare sent in one request.
protected number getunversioneddoubleorlong ( codedinputstream in ) throws ioexception { byte type = in . readrawbyte ( ) ; if ( type == constants . b_double ) return in . readdouble ( ) ; else return in . readrawvarint64 ( ) ; }	read out a type-specified number.
protected void putunversioneddoubleorlong ( number number , codedoutputstream out ) throws ioexception { if ( number instanceof double ) { out . writerawbyte ( constants . b_double ) ; out . writedoublenotag ( number . doublevalue ( ) ) ; } else { out . writerawbyte ( constants . b_i64 ) ; out . writerawvarint64 ( number . longvalue ( ) ) ; } }	put out a number prefaced only by a type.
public map < object , object > getallproperties ( ) { map < object , object > map = new hashmap < object , object > ( ) ; for ( object key : defaultprops . keyset ( ) ) { map . put ( key , defaultprops . getproperty ( key . tostring ( ) ) ) ; } for ( object key : props . keyset ( ) ) { map . put ( key , props . getproperty ( key . tostring ( ) ) ) ; } return collections . unmodifiablemap ( map ) ; }	Convert the existing configuration values into a Map, including those specified in defaultProps.
private void createcontainer ( ) { string containername = container_date_format . format ( new date ( ) ) ; blobstore . createcontainerinlocation ( null , containername ) ; lastcontainercreated = containername ; }	idempotent other than when the month changes between two calls.
void scheduleeligibleslots ( long maxagemillis , long rollupdelayformetricswithshortdelay , long rollupwaitformetricswithlongdelay ) { long now = scheduletime ; arraylist < integer > shardkeys = new arraylist < integer > ( shardstatemanager . getmanagedshards ( ) ) ; collections . shuffle ( shardkeys ) ; for ( int shard : shardkeys ) { for ( granularity g : granularity . rollupgranularities ( ) ) {	only one thread should be calling in this puppy.
void clearfromrunning ( slotkey slotkey ) { synchronized ( runningslots ) { runningslots . remove ( slotkey ) ; updatestamp stamp = shardstatemanager . getupdatestamp ( slotkey ) ; shardstatemanager . setallcoarserslotsdirtyforslot ( slotkey ) ;	Remove the given slot from the running group after it has beensuccessfully re-rolled.
public emitter on ( string event , listener fn ) { concurrentlinkedqueue < listener > callbacks = this . callbacks . get ( event ) ; if ( callbacks == null ) { callbacks = new concurrentlinkedqueue < listener > ( ) ; concurrentlinkedqueue < listener > _callbacks = this . callbacks . putifabsent ( event , callbacks ) ; if ( _callbacks != null ) { callbacks = _callbacks ; } } callbacks . add ( fn ) ; return this ; }	Listens on the event.
public emitter once ( final string event , final listener < t > fn ) { listener on = new listener < t > ( ) { @ override public void call ( t ... args ) { emitter . this . off ( event , this ) ; fn . call ( args ) ; } } ; this . oncecallbacks . put ( fn , on ) ; this . on ( event , on ) ; return this ; }	Adds a one time listener for the event.
public emitter off ( string event ) { concurrentlinkedqueue < listener > callbacks = this . callbacks . remove ( event ) ; if ( callbacks != null ) { for ( listener fn : callbacks ) { this . oncecallbacks . remove ( fn ) ; } } return this ; }	Removes all listeners of the specified event.
public future emit ( string event , t ... args ) { concurrentlinkedqueue < listener > callbacks = this . callbacks . get ( event ) ; if ( callbacks != null ) { callbacks = new concurrentlinkedqueue < listener > ( callbacks ) ; for ( listener fn : callbacks ) { fn . call ( args ) ; } } return null ; }	Executes each of listeners with the given args.
public list < listener > listeners ( string event ) { concurrentlinkedqueue < listener > callbacks = this . callbacks . get ( event ) ; return callbacks != null ? new arraylist < listener > ( callbacks ) : new arraylist < listener > ( ) ; }	Returns a list of listeners for the specified event.
public string getremotename ( ) { date time = new date ( timestamp ) ; string formattedtime = new simpledateformat ( str_ ) . format ( time ) ; return formattedtime + system . currenttimemillis ( ) + str_ + configuration . getinstance ( ) . getstringproperty ( cloudfilesconfig . cloudfiles_host_unique_identifier ) ; }	Get the remote file name.
public void append ( rollupevent rollup ) throws ioexception { ensureopen ( ) ; outputstream . write ( serializer . tobytes ( rollup ) ) ; outputstream . write ( str_ ) ; outputstream . flush ( ) ; }	Serialize a Rollup Event and append it to the file.
private static long parsetimestamp ( string filename ) throws numberformatexception { string numberpart = filename . substring ( num_ , filename . length ( ) - num_ ) ; return long . parselong ( numberpart ) ; }	Parse the timestamp from a filename.
public void startserver ( ) throws interruptedexception { routematcher router = new routematcher ( ) ; router . get ( str_ , new defaulthandler ( ) ) ; router . post ( str_ , new httpmultitenantmetricsingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , new httpmetricsingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , new httpaggregatedingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . get ( str_ , new defaulthandler ( ) ) ; router . post ( str_ , new httpmultitenantmetricsingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , new httpmetricsingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , new httpaggregatedingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , new httpaggregatedmultiingestionhandler ( processor , timeout , enable_per_tenant_metrics ) ) ; router . post ( str_ , gethttpeventsingestionhandler ( ) ) ; final routematcher finalrouter = router ; log . info ( str_ , httpingestport ) ; serverbootstrap server = new serverbootstrap ( ) ; server . group ( acceptorgroup , workergroup ) . channel ( nioserversocketchannel . class ) . childhandler ( new channelinitializer < socketchannel > ( ) { @ override public void initchannel ( socketchannel channel ) throws exception { setuppipeline ( channel , finalrouter ) ; } } ) ; channel channel = server . bind ( new inetsocketaddress ( httpingesthost , httpingestport ) ) . sync ( ) . channel ( ) ; allopenchannels . add ( channel ) ;	Starts the Ingest server.
public static rollup . type getrollupcomputer ( rolluptype srctype , granularity srcgran ) { switch ( srctype ) { case counter : return rollup . counterfromcounter ; case timer : return rollup . timerfromtimer ; case gauge : return rollup . gaugefromgauge ; case bf_basic : return srcgran == granularity . full ? rollup . basicfromraw : rollup . basicfrombasic ; case set : return rollup . setfromset ; default : break ; } throw new illegalargumentexception ( string . format ( str_ , srctype . name ( ) , srcgran . shortname ( ) ) ) ; }	determine which DataType to use for serialization.
public static synchronized iocontainer fromconfig ( ) { if ( from_config_instance == null ) { string driver = configuration . getstringproperty ( coreconfig . cassandra_driver ) ; log . info ( string . format ( str_ , driver ) ) ; boolean isrecordingdelayedmetrics = configuration . getbooleanproperty ( coreconfig . record_delayed_metrics ) ; log . info ( string . format ( str_ , isrecordingdelayedmetrics ) ) ; boolean isdtxingestbatchenabled = configuration . getbooleanproperty ( coreconfig . enable_dtx_ingest_batch ) ; log . info ( string . format ( str_ , isdtxingestbatchenabled ) ) ; from_config_instance = new iocontainer ( drivertype . getdrivertype ( driver ) , isrecordingdelayedmetrics , isdtxingestbatchenabled ) ; } return from_config_instance ; }	Returns an instance of this class based on what configuration says ourdriver should be.
private boolean put ( immutabletable . builder < granularity , rolluptype , timevalue > ttlmapbuilder , configuration config , granularity gran , rolluptype rolluptype , ttlconfig configkey ) { int value ; try { value = config . getintegerproperty ( configkey ) ; if ( value < num_ ) return bool_ ; } catch ( numberformatexception ex ) { log . trace ( string . format ( str_ , gran . name ( ) , rolluptype . name ( ) ) , ex ) ; return bool_ ; } ttlmapbuilder . put ( gran , rolluptype , new timevalue ( value , timeunit . days ) ) ; return bool_ ; }	Helper function to build the ttl mapping.
public static int [ ] computemaximums ( string [ ] headers , outputformatter ... outputs ) { int [ ] max = new int [ headers . length ] ; for ( int i = num_ ; i < headers . length ; i ++ ) max [ i ] = headers [ i ] . length ( ) ; for ( outputformatter output : outputs ) { max [ num_ ] = math . max ( output . host . length ( ) , max [ num_ ] ) ; for ( int i = num_ ; i < headers . length ; i ++ ) max [ i ] = math . max ( output . results [ i - num_ ] . length ( ) , max [ i ] ) ; } return max ; }	compute the maximum width for each field across a collection of formatters.
public static string formatheader ( int [ ] maximums , string [ ] headers ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < headers . length ; i ++ ) sb = sb . append ( formatin ( headers [ i ] , maximums [ i ] , bool_ ) ) . append ( gap ) ; return sb . tostring ( ) ; }	formats a header row after maximums have been established.
public static string [ ] format ( int [ ] maximums , outputformatter ... outputs ) { string [ ] formattedstrings = new string [ outputs . length ] ; int pos = num_ ; for ( outputformatter output : outputs ) { stringbuilder sb = new stringbuilder ( ) ; sb = sb . append ( formatin ( output . host , maximums [ num_ ] , bool_ ) ) ; for ( int i = num_ ; i < output . results . length ; i ++ ) sb = sb . append ( gap ) . append ( formatin ( output . results [ i ] , maximums [ i + num_ ] , bool_ ) ) ; formattedstrings [ pos ++ ] = sb . tostring ( ) ; } return formattedstrings ; }	formats results and sets formattedStrings.
private void registermetrics ( final objectname nameobj , metricregistry reg ) { reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new jmxattributegauge ( nameobj , str_ ) ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new jmxattributegauge ( nameobj , str_ ) ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new jmxattributegauge ( nameobj , str_ ) ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new jmxattributegauge ( nameobj , str_ ) { @ override public object getvalue ( ) { object val = super . getvalue ( ) ; if ( val . equals ( str_ ) ) { return num_ ; } return num_ ; } } ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new gauge < integer > ( ) { @ override public integer getvalue ( ) { return getheldshards ( ) . size ( ) ; } } ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new gauge < integer > ( ) { @ override public integer getvalue ( ) { return getunheldshards ( ) . size ( ) ; } } ) ; reg . register ( metricregistry . name ( zkshardlockmanager . class , str_ ) , new gauge < integer > ( ) { @ override public integer getvalue ( ) { return geterrorshards ( ) . size ( ) ; } } ) ; }	Registers the different ZooKeeper metrics.
public threadpoolbuilder withname ( string name ) {	Set the threadpool name.
public void add ( string metricindex , long doccount ) { final string [ ] tokens = metricindex . split ( metric_token_separator_regex ) ; switch ( tokens . length - baselevel ) { case num_ : if ( baselevel > num_ ) { metricnameswithnextlevelset . add ( metricindex . substring ( num_ , metricindex . lastindexof ( str_ ) ) ) ; } else { metricnameswithnextlevelset . add ( metricindex . substring ( num_ , metricindex . indexof ( str_ ) ) ) ; }	For a given metricIndex and docCount, classifies the data with respect to baseLeveland stores it accordingly.
private set < string > getcompletemetricnames ( map < string , metricindexdoccount > metricindexmap ) { set < string > completemetricnames = new hashset < string > ( ) ; for ( map . entry < string , metricindexdoccount > entry : metricindexmap . entryset ( ) ) { metricindexdoccount metricindexdoccount = entry . getvalue ( ) ; if ( metricindexdoccount != null ) {	Compares actualDocCount and total docCount of its immediate children of an indexto determine if the metric index is a complete metric name or not.For the ES response shown in class description, for a baseLevel of 2,foo.bar.baz has actualDocCount of 2, but total doc count of all its children,which in this case is only foo.bar.baz, is 1.
public static list < token > gettokens ( locator locator ) { if ( stringutils . isempty ( locator . getmetricname ( ) ) || stringutils . isempty ( locator . gettenantid ( ) ) ) return new arraylist < > ( ) ; string [ ] tokens = locator . getmetricname ( ) . split ( locator . metric_token_separator_regex ) ; return intstream . range ( num_ , tokens . length ) . maptoobj ( index -> new token ( locator , tokens , index ) ) . collect ( tolist ( ) ) ; }	This method return list of tokens with their parents for a current Discovery object.For example: A locator of 1111:a.b.c.d would generate the following tokensToken{token='a', parent='', isLeaf=false, id='111111:a', locator=111111.a.b.c.d}Token{token='b', parent='a', isLeaf=false, id='111111:a.b', locator=111111.a.b.c.d}Token{token='c', parent='a.b', isLeaf=false, id='111111:a.b.c', locator=111111.a.b.c.d}Token{token='d', parent='a.b.c', isLeaf=true, id='111111:a.b.c.d:$', locator=111111.a.b.c.d}.
public resultsetfuture putasync ( locator locator , long collectiontime , rollup rollup , granularity granularity , int ttl ) { session session = datastaxio . getsession ( ) ;	Asynchronously insert a rolled up metric to the appropriate column familyfor a particular granularity.
private static granularity granularityfrompointslessthanequal ( double requestedduration , int points , long assumedintervalmillis ) { granularity gran = granularityfrompointslinear ( requestedduration , points , assumedintervalmillis ) ; if ( requestedduration / gran . milliseconds ( ) > points ) { try { gran = gran . coarser ( ) ; } catch ( granularityexception e ) { } } return gran ; }	Find the granularity in the interval that will yield a number of data points that areclosest to the requested points but <= requested points.
public synchronized void setservertime ( long millis ) { log . info ( str_ , millis , new java . util . date ( millis ) ) ; context . setcurrenttimemillis ( millis ) ; }	set the server time in millis.
public set < string > getuniquehosts ( ) { set < string > uniquehosts = new hashset < string > ( ) ; collections . addall ( uniquehosts , config . getstringproperty ( coreconfig . cassandra_hosts ) . split ( str_ ) ) ; return uniquehosts ; }	Retrieves the set of unique Cassandra hosts from configuration file.If a single host appears multiple times in the configuration, only one willbe listed.
public int getmaxconnperhost ( int numhosts ) { int maxconns = config . getintegerproperty ( coreconfig . max_cassandra_connections ) ; return maxconns / numhosts + ( maxconns % numhosts == num_ ? num_ : num_ ) ; }	Calculates the number of max connections per Cassandra hosts.
public static iterable < metriccolumnfamily > getmetriccolumnfamilies ( ) { return new iterable < metriccolumnfamily > ( ) { @ override public iterator < metriccolumnfamily > iterator ( ) { return new iterator < metriccolumnfamily > ( ) { private int pos = num_ ; @ override public boolean hasnext ( ) { return pos < metric_column_familes . length ; } @ override public metriccolumnfamily next ( ) { return metric_column_familes [ pos ++ ] ; } @ override public void remove ( ) { throw new nosuchmethoderror ( str_ ) ; } } ; } } ; }	iterate over all column families that store metrics.
@ override public void insertmetrics ( collection < imetric > metrics ) throws ioexception { insertmetrics ( metrics , granularity . full ) ; }	Inserts a collection of metrics to the metrics_preaggregated_full column family.
@ override public void insertmetrics ( collection < imetric > metrics , granularity granularity ) throws ioexception { try { astyanaxwriter . getinstance ( ) . insertmetrics ( metrics , cassandramodel . getpreaggregatedcolumnfamily ( granularity ) , isrecordingdelayedmetrics , clock ) ; } catch ( connectionexception ex ) { throw new ioexception ( ex ) ; } }	Inserts a collection of metrics to the correct column family based onthe specified granularity.
protected set < locator > getlocators ( rollupexecutioncontext executioncontext , boolean isreroll , granularity delayedmetricsrerollgranularity , granularity delayedmetricsstoragegranularity ) { set < locator > locators = new hashset < locator > ( ) ;	This methods gets locators to rollup a slot.During re-rolls, If the granularity of the slot is finer(or equal) to the configuredDELAYED_METRICS_REROLL_GRANULARITY, we re-roll only the delayed locator's correspondingto that slot.
protected string regextograbcurrentandnextlevel ( final string query ) { if ( stringutils . isempty ( query ) ) { throw new illegalargumentexception ( str_ ) ; } string queryregex = getregex ( query ) ; int totalquerytokens = gettotaltokens ( query ) ; if ( totalquerytokens == num_ ) {	Returns regex which could grab metric names from current level to the next levelfor a given query.(Some exceptions when query has only one level due to the nature of underlying data)for metrics : foo.bar.baz,foo.bar.baz.qux,for query=foo.bar.*, the regex which this method returns will capture the following metric token paths."foo.bar.baz" <- current level"foo.bar.baz.qux" <- next level.
public synchronized void start ( ) { if ( uploaderthread != null ) { throw new runtimeexception ( str_ ) ; } fileuploader = new donefileuploader ( ) ; uploaderthread = new thread ( fileuploader , str_ ) ; uploaderthread . start ( ) ; }	Start background storage management and uploading tasks.
public synchronized void stop ( ) throws ioexception { if ( uploaderthread == null ) { throw new runtimeexception ( str_ ) ; } uploaderthread . interrupt ( ) ; uploaderthread = null ; fileuploader . shutdown ( ) ; }	Stop background storage management.
public synchronized boolean islocatorcurrentinbatchlayer ( locator loc ) { locatorcacheentry entry = insertedlocators . getifpresent ( loc . tostring ( ) ) ; return entry != null && entry . isbatchcurrent ( ) ; }	Checks if Locator is recently inserted in the batch layer.
public synchronized boolean islocatorcurrentindiscoverylayer ( locator loc ) { locatorcacheentry entry = insertedlocators . getifpresent ( loc . tostring ( ) ) ; return entry != null && entry . isdiscoverycurrent ( ) ; }	Checks if Locator is recently inserted in the discovery layer.
public synchronized boolean islocatorcurrentintokendiscoverylayer ( locator loc ) { locatorcacheentry entry = insertedlocators . getifpresent ( loc . tostring ( ) ) ; return entry != null && entry . istokendiscoverycurrent ( ) ; }	Checks if Locator is recently inserted in the token discovery layer.
public synchronized boolean isdelayedlocatorforaslotcurrent ( int slot , locator locator ) { return inserteddelayedlocators . getifpresent ( getlocatorslotkey ( slot , locator ) ) != null ; }	Check if the delayed locator is recently inserted for a given slot.
public synchronized void setdelayedlocatorforaslotcurrent ( int slot , locator locator ) { inserteddelayedlocators . put ( getlocatorslotkey ( slot , locator ) , boolean . true ) ; }	Marks the delayed locator as recently inserted for a given slot.
public static map < range , iterable < range > > mapfinerranges ( granularity g , range range ) throws granularityexception { if ( range . getstart ( ) >= range . getstop ( ) ) throw new illegalargumentexception ( str_ + range . getstart ( ) + str_ + range . getstop ( ) ) ; final long snappedstartmillis = g . snapmillis ( range . getstart ( ) ) ; final long snappedstopmillis = g . snapmillis ( range . getstop ( ) + g . milliseconds ( ) ) ; hashmap < range , iterable < range > > rangemap = new hashmap < range , iterable < range > > ( ) ; long tempstartmillis = snappedstartmillis ; int numberofmillis = g . milliseconds ( ) ; while ( tempstartmillis <= ( snappedstopmillis - numberofmillis ) ) { range slotrange = new range ( tempstartmillis , tempstartmillis + numberofmillis ) ; rangemap . put ( slotrange , new intervalrangeiterator ( g . finer ( ) , slotrange . start , slotrange . stop ) ) ; tempstartmillis = tempstartmillis + numberofmillis ; } return rangemap ; }	Returns a mapping of ranges in the coarser granularity to the sub-ranges in finer granularityHere is an example: Given start/end (s,e), we need to return mapping between ranges in Y that will be mapped toa single range in X. From the example above, it will be mapping from A to all the sub-ranges in Y that get rolledto a single point in A.
public static iterable < range > rangesforinterval ( granularity g , final long from , final long to ) { if ( g == granularity . full ) { return arrays . aslist ( new range ( from , to ) ) ; } final long snappedstartmillis = g . snapmillis ( from ) ; final long snappedstopmillis = g . snapmillis ( to + g . milliseconds ( ) ) ; return new intervalrangeiterator ( g , snappedstartmillis , snappedstopmillis ) ; }	return the Ranges for an interval at this granularity.
public void insertfull ( collection < ? extends imetric > metrics , boolean isrecordingdelayedmetrics , clock clock ) throws connectionexception { timer . context ctx = instrumentation . getwritetimercontext ( cassandramodel . cf_metrics_full_name ) ; try { mutationbatch mutationbatch = keyspace . preparemutationbatch ( ) ; for ( imetric metric : metrics ) { final locator locator = metric . getlocator ( ) ;	single column updates).
public void insertmetrics ( collection < imetric > metrics , columnfamily cf , boolean isrecordingdelayedmetrics , clock clock ) throws connectionexception { timer . context ctx = instrumentation . getwritetimercontext ( cf . getname ( ) ) ; multimap < locator , imetric > map = asmultimap ( metrics ) ; mutationbatch batch = keyspace . preparemutationbatch ( ) ; try { for ( locator locator : map . keyset ( ) ) { columnlistmutation < long > mutation = batch . withrow ( cf , locator ) ; for ( imetric metric : map . get ( locator ) ) { mutation . putcolumn ( metric . getcollectiontime ( ) , metric . getmetricvalue ( ) , ( abstractserializer ) ( serializers . serializerfor ( metric . getmetricvalue ( ) . getclass ( ) ) ) , metric . getttlinseconds ( ) ) ; if ( cf . getname ( ) . equals ( cassandramodel . cf_metrics_preaggregated_full_name ) ) { instrumentation . markfullrespreaggregatedmetricwritten ( ) ; } if ( isrecordingdelayedmetrics ) {	generic IMetric insertion. All other metric insertion methods could use this one.
protected boolean isdelayed ( imetric metric ) { long delay = clock . now ( ) . getmillis ( ) - metric . getcollectiontime ( ) ; return delay > max_age_allowed ; }	Determines if the metric is considered delayed or not.
protected boundstatement getboundstatementformetricifdelayed ( imetric metric ) { locator locator = metric . getlocator ( ) ; if ( isdelayed ( metric ) ) { int slot = getdelayedslot ( metric ) ; if ( ! locatorcache . getinstance ( ) . isdelayedlocatorforaslotcurrent ( slot , locator ) ) { locatorcache . getinstance ( ) . setdelayedlocatorforaslotcurrent ( slot , locator ) ; return delayedlocatorio . getboundstatementforlocator ( delayed_metrics_storage_granularity , slot , locator ) ; } } return null ; }	Returns a BoundStatement if a metric needs to be inserted to the metrics_delayed_locatorColumn Family.
public map < string , string > getmetadatavalues ( locator locator ) { timer . context ctx = instrumentation . getreadtimercontext ( cassandramodel . cf_metrics_metadata_name ) ; try { final columnlist < string > results = keyspace . preparequery ( cassandramodel . cf_metrics_metadata ) . getkey ( locator ) . execute ( ) . getresult ( ) ; return new hashmap < string , string > ( ) { { for ( column < string > result : results ) { put ( result . getname ( ) , result . getvalue ( stringmetadataserializer . get ( ) ) ) ; } } } ; } catch ( notfoundexception ex ) { instrumentation . marknotfound ( cassandramodel . cf_metrics_metadata_name ) ; return null ; } catch ( connectionexception e ) { log . error ( str_ , e ) ; instrumentation . markreaderror ( e ) ; throw new runtimeexception ( e ) ; } finally { ctx . stop ( ) ; } }	Method that returns all metadata for a given locator as a map.
public boolean iscontenttypevalid ( httpheaders headers ) { string contenttype = headers . get ( httpheaders . names . content_type ) ;	Checks the Content-Type header to see if clients specify the rightmedia type.
public boolean isacceptvalid ( httpheaders headers ) { string accept = headers . get ( httpheaders . names . accept ) ;	Checks the Accept header to see if clients accept the correctmedia type.
public void insertdiscovery ( list < imetric > batch ) throws ioexception { batchhistogram . update ( batch . size ( ) ) ; if ( batch . size ( ) == num_ ) { log . debug ( str_ ) ; return ; } timer . context ctx = writetimer . time ( ) ; try { for ( object obj : batch ) { if ( ! ( obj instanceof imetric ) ) { classcastexceptionmeter . mark ( ) ; continue ; } } elasticsearchresthelper . indexmetrics ( batch ) ; } finally { ctx . stop ( ) ; } }	REST call to index into ES.
@ asserttrue ( message = str_ ) private boolean isvalid ( ) { boolean isgaugepresent = gauges != null && gauges . length > num_ ; boolean iscounterpresent = counters != null && counters . length > num_ ; boolean istimerpresent = timers != null && timers . length > num_ ; boolean issetpresent = sets != null && sets . length > num_ ; return ( isgaugepresent || iscounterpresent || istimerpresent || issetpresent ) ; }	This method is invoked by the validator automatically.
private void docheck ( ) { if ( ! running ) return ; if ( filemanager == null ) return ; if ( unexpectederrors > max_unexpected_errors ) { log . info ( str_ ) ; terminate ( bool_ ) ; return ; } timer . context waittimercontext = waitingtimer . time ( ) ;	gets run by the thread.
public extractor getnewinstance ( ) { extractor extractor = new basicextractor ( config ) ; if ( config . shouldcacheddownload ( ) ) { extractor = new cachedextractor ( extractor , config ) ; } return extractor ; }	Returns an Extractor instance appropriate based on the given configuration.
private static boolean getosmatches ( final string osnameprefix , final string osversionprefix ) { return isosmatch ( os_name , os_version , osnameprefix , osversionprefix ) ; }	Decides if the operating system matches.
public void start ( ) throws erlangversionexception , downloadexception , extractionexception , startupexception { if ( rabbitmqprocess != null ) { throw new illegalstateexception ( str_ ) ; } check ( ) ; download ( ) ; extract ( ) ; run ( ) ; }	Starts the RabbitMQ server process and blocks the current thread until the initialization is completed.
public void stop ( ) throws shutdownexception { if ( rabbitmqprocess == null ) { throw new illegalstateexception ( str_ ) ; } new shutdownhelper ( config , rabbitmqprocess ) . run ( ) ; rabbitmqprocess = null ; }	Submits the command to stop RabbitMQ and blocks the current thread until the shutdown is completed.
public static pnsignalingparams defaultinstance ( ) { mediaconstraints pcconstraints = pnsignalingparams . defaultpcconstraints ( ) ; mediaconstraints videoconstraints = pnsignalingparams . defaultvideoconstraints ( ) ; mediaconstraints audioconstraints = pnsignalingparams . defaultaudioconstraints ( ) ; list < peerconnection . iceserver > iceservers = pnsignalingparams . defaulticeservers ( ) ; return new pnsignalingparams ( iceservers , pcconstraints , videoconstraints , audioconstraints ) ; }	The default parameters for media constraints.
public void addiceservers ( list < peerconnection . iceserver > iceservers ) { if ( this . iceservers != null ) { iceservers . addall ( this . iceservers ) ; } this . iceservers = iceservers ; }	Append default servers to the end of given list and set as iceServers instance variable.
public void addiceservers ( peerconnection . iceserver iceservers ) { if ( this . iceservers == null ) { this . iceservers = new arraylist < peerconnection . iceserver > ( ) ; } this . iceservers . add ( num_ , iceservers ) ; }	Instantiate iceServers if they are not already, and add Ice Server to beginning of list.
public void transmit ( string userid , jsonobject message ) { jsonobject usrmsgjson = new jsonobject ( ) ; try { usrmsgjson . put ( pnrtcmessage . json_usermsg , message ) ; this . pcclient . transmitmessage ( userid , usrmsgjson ) ; } catch ( jsonexception e ) { e . printstacktrace ( ) ; } }	Send a custom JSONObject user message to a single peer.
public void transmitall ( jsonobject message ) { list < pnpeer > peerlist = this . pcclient . getpeers ( ) ; for ( pnpeer p : peerlist ) { transmit ( p . getid ( ) , message ) ; } }	Send a custom JSONObject user message to all peers.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < weitereadresse > getweitereadresse ( ) { if ( weitereadresse == null ) { weitereadresse = new arraylist < weitereadresse > ( ) ; } return this . weitereadresse ; }	Gets the value of the weitereAdresse property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < userdefinedsimplefield > getuserdefinedsimplefield ( ) { if ( userdefinedsimplefield == null ) { userdefinedsimplefield = new arraylist < userdefinedsimplefield > ( ) ; } return this . userdefinedsimplefield ; }	Gets the value of the userDefinedSimplefield property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < userdefinedanyfield > getuserdefinedanyfield ( ) { if ( userdefinedanyfield == null ) { userdefinedanyfield = new arraylist < userdefinedanyfield > ( ) ; } return this . userdefinedanyfield ; }	Gets the value of the userDefinedAnyfield property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setapisuchfelder ( jaxbelement < apisuchfeldertyp > value ) { this . apisuchfelder = value ; }	Sets the value of the apiSuchfelder property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < multimediaanhangtyp > getmultimediaanhang ( ) { if ( multimediaanhang == null ) { multimediaanhang = new arraylist < multimediaanhangtyp > ( ) ; } return this . multimediaanhang ; }	Gets the value of the multimediaAnhang property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public statustyp getstatusvbm ( ) { if ( statusvbm == null ) { return statustyp . aktiv ; } else { return statusvbm ; } }	Gets the value of the statusVBM property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public statustyp getstatusis24 ( ) { if ( statusis24 == null ) { return statustyp . aktiv ; } else { return statusis24 ; } }	Gets the value of the statusIS24 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public statustyp getstatushp ( ) { if ( statushp == null ) { return statustyp . aktiv ; } else { return statushp ; } }	Gets the value of the statusHP property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public aktionstyp getimportmodus ( ) { if ( importmodus == null ) { return aktionstyp . importieren ; } else { return importmodus ; } }	Gets the value of the importmodus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public boolean getadressdruck ( ) { if ( adressdruck == null ) { return bool_ ; } else { return adressdruck ; } }	Gets the value of the adressdruck property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public waehrungtyp getwaehrung ( ) { if ( waehrung == null ) { return waehrungtyp . eur ; } else { return waehrung ; } }	Gets the value of the waehrung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public bodenbelagtyp getbodenbelag ( ) { if ( bodenbelag == null ) { return bodenbelagtyp . keine_angabe ; } else { return bodenbelag ; } }	Gets the value of the bodenbelag property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setregion ( java . lang . string value ) { this . region = value ; }	Sets the value of the region property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setarea ( java . lang . string value ) { this . area = value ; }	Sets the value of the area property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setaddress ( java . lang . string value ) { this . address = value ; }	Sets the value of the address property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setdescription ( java . lang . string value ) { this . description = value ; }	Sets the value of the description property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setrentcollectionperiod ( overseasrentaladtype . rentperiod value ) { this . rentcollectionperiod = value ; }	Sets the value of the rentCollectionPeriod property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setfurnished ( overseasrentaladtype . furnished value ) { this . furnished = value ; }	Sets the value of the furnished property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setphone1 ( java . lang . string value ) { this . phone1 = value ; }	Sets the value of the phone1 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setphone2 ( java . lang . string value ) { this . phone2 = value ; }	Sets the value of the phone2 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setcontactname ( java . lang . string value ) { this . contactname = value ; }	Sets the value of the contactName property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setphoneinfo ( java . lang . string value ) { this . phoneinfo = value ; }	Sets the value of the phoneInfo property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmainemail ( java . lang . string value ) { this . mainemail = value ; }	Sets the value of the mainEmail property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setccemail ( java . lang . string value ) { this . ccemail = value ; }	Sets the value of the ccEmail property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setexternalid ( java . lang . string value ) { this . externalid = value ; }	Sets the value of the externalId property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setagentid ( java . lang . string value ) { this . agentid = value ; }	Sets the value of the agentId property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setepart ( energiepass . epart value ) { this . epart = value ; }	Sets the value of the epart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setjahrgang ( energiepass . jahrgang value ) { this . jahrgang = value ; }	Sets the value of the jahrgang property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgebaeudeart ( energiepass . gebaeudeart value ) { this . gebaeudeart = value ; }	Sets the value of the gebaeudeart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbuerotyp ( bueropraxen . buerotyp value ) { this . buerotyp = value ; }	Sets the value of the bueroTyp property.
public static boolean isnumeric ( string value , locale locale ) { if ( value == null ) return bool_ ; int start = num_ ; final decimalformatsymbols symbols = ( locale != null ) ? decimalformatsymbols . getinstance ( locale ) : decimalformatsymbols . getinstance ( ) ; if ( value . startswith ( str_ ) || value . startswith ( str_ ) ) start ++ ; boolean fraction = bool_ ; for ( int i = start ; i < value . length ( ) ; i ++ ) { final char c = value . charat ( i ) ; if ( c == symbols . getdecimalseparator ( ) && ! fraction ) { fraction = bool_ ; continue ; } if ( c == symbols . getgroupingseparator ( ) && ! fraction ) { continue ; } if ( ! character . isdigit ( c ) ) { return bool_ ; } } return bool_ ; }	Test, if a string contains a parsable number.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgebiete ( lagegebiet . gebiete value ) { this . gebiete = value ; }	Sets the value of the gebiete property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgruppe ( anhang . gruppe value ) { this . gruppe = value ; }	Sets the value of the gruppe property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setagent ( root . agent value ) { this . agent = value ; }	Sets the value of the agent property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < propertytype > getproperty ( ) { if ( property == null ) { property = new arraylist < propertytype > ( ) ; } return this . property ; }	Gets the value of the property property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setstand ( verkaufstatus . stand value ) { this . stand = value ; }	Sets the value of the stand property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < userdefinedextend > getuserdefinedextend ( ) { if ( userdefinedextend == null ) { userdefinedextend = new arraylist < userdefinedextend > ( ) ; } return this . userdefinedextend ; }	Gets the value of the userDefinedExtend property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setzeiteinheit ( preiszeiteinheit . zeiteinheit value ) { this . zeiteinheit = value ; }	Sets the value of the zeiteinheit property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < zimmer > getzimmer ( ) { if ( zimmer == null ) { zimmer = new arraylist < zimmer > ( ) ; } return this . zimmer ; }	Gets the value of the zimmer property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < haus > gethaus ( ) { if ( haus == null ) { haus = new arraylist < haus > ( ) ; } return this . haus ; }	Gets the value of the haus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < bueropraxen > getbueropraxen ( ) { if ( bueropraxen == null ) { bueropraxen = new arraylist < bueropraxen > ( ) ; } return this . bueropraxen ; }	Gets the value of the bueroPraxen property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < gastgewerbe > getgastgewerbe ( ) { if ( gastgewerbe == null ) { gastgewerbe = new arraylist < gastgewerbe > ( ) ; } return this . gastgewerbe ; }	Gets the value of the gastgewerbe property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < landundforstwirtschaft > getlandundforstwirtschaft ( ) { if ( landundforstwirtschaft == null ) { landundforstwirtschaft = new arraylist < landundforstwirtschaft > ( ) ; } return this . landundforstwirtschaft ; }	Gets the value of the landUndForstwirtschaft property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < sonstige > getsonstige ( ) { if ( sonstige == null ) { sonstige = new arraylist < sonstige > ( ) ; } return this . sonstige ; }	Gets the value of the sonstige property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < zinshausrenditeobjekt > getzinshausrenditeobjekt ( ) { if ( zinshausrenditeobjekt == null ) { zinshausrenditeobjekt = new arraylist < zinshausrenditeobjekt > ( ) ; } return this . zinshausrenditeobjekt ; }	Gets the value of the zinshausRenditeobjekt property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < terraintype > getterrain ( ) { if ( terrain == null ) { terrain = new arraylist < terraintype > ( ) ; } return this . terrain ; }	Gets the value of the terrain property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setumfang ( uebertragung . umfang value ) { this . umfang = value ; }	Sets the value of the umfang property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setwohnungtyp ( wohnung . wohnungtyp value ) { this . wohnungtyp = value ; }	Sets the value of the wohnungtyp property.
public static string getcountryiso2 ( string country ) { country = stringutils . trimtonull ( country ) ; if ( country == null ) return null ; if ( country . length ( ) == num_ ) return country ; string [ ] iso2codes = locale . getisocountries ( ) ; if ( country . length ( ) == num_ ) { string iso2code = localeutils . getcountryiso2fromiso3 ( country ) ; if ( iso2code != null ) return iso2code ; } for ( string iso2code : iso2codes ) { locale countrylocale = new locale ( iso2code , iso2code ) ; for ( locale translationlocale : localeutils . availablelocalelist ( ) ) { string name = stringutils . trimtonull ( countrylocale . getdisplaycountry ( translationlocale ) ) ; if ( name != null && name . equalsignorecase ( country ) ) return iso2code ; } } return null ; }	Return an ISO-2 country code from a country name.
public static string getcountryiso2fromiso3 ( string iso3code ) { iso3code = stringutils . trimtonull ( iso3code ) ; if ( iso3code == null ) return null ; if ( iso3code . length ( ) == num_ ) { for ( string iso2code : locale . getisocountries ( ) ) { locale countrylocale = new locale ( iso2code , iso2code ) ; string countryiso3 = stringutils . trimtonull ( countrylocale . getiso3country ( ) ) ; if ( countryiso3 != null && countryiso3 . equalsignorecase ( iso3code ) ) { return iso2code ; } } } return null ; }	Create an ISO-2 country code from an ISO-3 country code.
public static string getcountryiso3 ( string country ) { country = stringutils . trimtonull ( country ) ; if ( country == null ) return null ; if ( country . length ( ) == num_ ) return country ; string [ ] iso2codes = locale . getisocountries ( ) ; if ( country . length ( ) == num_ ) { string iso3code = localeutils . getcountryiso3fromiso2 ( country ) ; if ( iso3code != null ) return iso3code ; } for ( string iso2code : iso2codes ) { locale countrylocale = new locale ( iso2code , iso2code ) ; string iso3code = stringutils . trimtonull ( countrylocale . getiso3country ( ) ) ; if ( iso3code == null ) continue ; for ( locale translationlocale : localeutils . availablelocalelist ( ) ) { string name = stringutils . trimtonull ( countrylocale . getdisplaycountry ( translationlocale ) ) ; if ( name != null && name . equalsignorecase ( country ) ) return iso3code ; } } return null ; }	Return an ISO-3 country code from a country name.
public static string getcountryiso3fromiso2 ( string iso2code ) { iso2code = stringutils . trimtonull ( iso2code ) ; if ( iso2code == null ) return null ; if ( iso2code . length ( ) == num_ ) { locale countrylocale = new locale ( iso2code , iso2code ) ; string iso3code = stringutils . trimtonull ( countrylocale . getiso3country ( ) ) ; if ( iso3code != null ) return iso3code ; } return null ; }	Create an ISO-3 country code from an ISO-2 country code.
public static string getcountryname ( string country , locale language ) { country = stringutils . trimtonull ( country ) ; if ( country == null ) return null ; string iso2code = localeutils . getcountryiso2 ( country ) ; if ( iso2code != null ) { string name = stringutils . trimtonull ( new locale ( iso2code , iso2code ) . getdisplaycountry ( language ) ) ; if ( name != null ) return name ; } return null ; }	Return a country name in another language.
public static string translatecountryname ( string country , locale language ) { country = stringutils . trimtonull ( country ) ; if ( country == null ) return null ; for ( string iso2code : locale . getisocountries ( ) ) { locale countrylocale = new locale ( iso2code , iso2code ) ; for ( locale translationlocale : localeutils . availablelocalelist ( ) ) { string name = stringutils . trimtonull ( countrylocale . getdisplaycountry ( translationlocale ) ) ; if ( name != null && name . equalsignorecase ( country ) ) { name = stringutils . trimtonull ( countrylocale . getdisplaycountry ( language ) ) ; if ( name != null ) return name ; } } } return null ; }	Translate a country name into another language.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < anbieter > getanbieter ( ) { if ( anbieter == null ) { anbieter = new arraylist < anbieter > ( ) ; } return this . anbieter ; }	Gets the value of the anbieter property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setcategory ( businesselement . businesselementcategory value ) { this . category = value ; }	Sets the value of the category property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < uri > getpdf ( ) { if ( pdf == null ) { pdf = new arraylist < uri > ( ) ; } return this . pdf ; }	Gets the value of the pdf property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setaktionart ( aktion . aktionart value ) { this . aktionart = value ; }	Sets the value of the aktionart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setrealestateitems ( container . realestateitems value ) { this . realestateitems = value ; }	Sets the value of the realestateitems property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpacht ( jaxbelement < vermarktunggrundstueckwohnenmietetyp . pacht > value ) { this . pacht = value ; }	Sets the value of the pacht property.
@ override public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_7 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgradesummemietenettoelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradeenergiepasselements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.6 to 1.2.7.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < object > getcontent ( ) { if ( content == null ) { content = new arraylist < object > ( ) ; } return this . content ; }	Gets the value of the content property.
public string [ ] getfieldnames ( ) { list < string > names = new arraylist < > ( ) ; for ( metadatatype . field field : this . fields ) { names . add ( field . getname ( ) ) ; } return names . toarray ( new string [ num_ ] ) ; }	Returns the names of specified fields.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setblick ( ausblick . blick value ) { this . blick = value ; }	Sets the value of the blick property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpauschalmiete ( waztyp . pauschalmiete value ) { this . pauschalmiete = value ; }	Sets the value of the pauschalmiete property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmonatsmiete ( waztyp . monatsmiete value ) { this . monatsmiete = value ; }	Sets the value of the monatsmiete property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public stellplatzkategorietyp getparkplatz ( ) { if ( parkplatz == null ) { return stellplatzkategorietyp . keine_angabe ; } else { return parkplatz ; } }	Gets the value of the parkplatz property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setlastenaufzug ( jaxbelement < hebeanlagetyp > value ) { this . lastenaufzug = value ; }	Sets the value of the lastenaufzug property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setzustandart ( zustand . zustandart value ) { this . zustandart = value ; }	Sets the value of the zustandArt property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < bewertung . feld > getfeld ( ) { if ( feld == null ) { feld = new arraylist < bewertung . feld > ( ) ; } return this . feld ; }	Gets the value of the feld property.
public void dump ( writer writer , string lineseparator ) throws ioexception { for ( int i = num_ ; i < this . getrecordlenth ( ) ; i ++ ) { stringbuilder txt = new stringbuilder ( ) ; try ( stringreader reader = new stringreader ( stringutils . trimtoempty ( this . get ( i ) ) ) ) { for ( string line : ioutils . readlines ( reader ) ) { if ( txt . length ( ) > num_ ) txt . append ( lineseparator ) ; txt . append ( line ) ; } } writer . write ( i + str_ + txt . tostring ( ) ) ; writer . write ( system . lineseparator ( ) ) ; } }	Write content of the record in a human readable form.
protected final string get ( int pos , string defaultvalue ) { string value = stringutils . trimtonull ( this . values . get ( pos ) ) ; return ( value != null ) ? value : defaultvalue ; }	Returns the value of the record at a certain index position.
protected iterable < string > print ( ) { final int length = this . getrecordlenth ( ) ; list < string > row = new arraylist < > ( ) ; for ( int i = num_ ; i < length ; i ++ ) { row . add ( this . get ( i ) ) ; } return row ; }	Returns a list of values for this record as they are written into CSV.
protected final void set ( int pos , string value ) { value = stringutils . trimtonull ( value ) ; if ( value != null ) this . values . put ( pos , value ) ; else if ( this . values . containskey ( pos ) ) this . values . remove ( pos ) ; }	Sets the value of this record at a certain index position.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setctype ( check . ctype value ) { this . ctype = value ; }	Sets the value of the ctype property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void sethaustyp ( haus . haustyp value ) { this . haustyp = value ; }	Sets the value of the haustyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < energiepass > getenergiepass ( ) { if ( energiepass == null ) { energiepass = new arraylist < energiepass > ( ) ; } return this . energiepass ; }	Gets the value of the energiepass property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setkeller ( unterkellert . keller value ) { this . keller = value ; }	Sets the value of the keller property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgrundsttyp ( grundstueck . grundsttyp value ) { this . grundsttyp = value ; }	Sets the value of the grundstTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgeschlattr ( geschlecht . geschlattr value ) { this . geschlattr = value ; }	Sets the value of the geschlAttr property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void sethallentyp ( hallenlagerprod . hallentyp value ) { this . hallentyp = value ; }	Sets the value of the hallenTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public boolean getwiederholungstermin ( ) { if ( wiederholungstermin == null ) { return bool_ ; } else { return wiederholungstermin ; } }	Gets the value of the wiederholungstermin property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public boolean getteilungsversteigerung ( ) { if ( teilungsversteigerung == null ) { return bool_ ; } else { return teilungsversteigerung ; } }	Gets the value of the teilungsversteigerung property.
@ override public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_3 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgradesonstigeelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradezinshausrenditeobjektelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.2 to 1.2.3.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < interessent . bevorzugt > getbevorzugt ( ) { if ( bevorzugt == null ) { bevorzugt = new arraylist < interessent . bevorzugt > ( ) ; } return this . bevorzugt ; }	Gets the value of the bevorzugt property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < interessent . wunsch > getwunsch ( ) { if ( wunsch == null ) { wunsch = new arraylist < interessent . wunsch > ( ) ; } return this . wunsch ; }	Gets the value of the wunsch property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setart ( uebertragung . art value ) { this . art = value ; }	Sets the value of the art property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmodus ( uebertragung . modus value ) { this . modus = value ; }	Sets the value of the modus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < emailsonstige > getemailsonstige ( ) { if ( emailsonstige == null ) { emailsonstige = new arraylist < emailsonstige > ( ) ; } return this . emailsonstige ; }	Gets the value of the emailSonstige property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < telsonstige > gettelsonstige ( ) { if ( telsonstige == null ) { telsonstige = new arraylist < telsonstige > ( ) ; } return this . telsonstige ; }	Gets the value of the telSonstige property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void sethandeltyp ( einzelhandel . handeltyp value ) { this . handeltyp = value ; }	Sets the value of the handelTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setapisuchfeld1 ( jaxbelement < string > value ) { this . apisuchfeld1 = value ; }	Sets the value of the apiSuchfeld1 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setapisuchfeld2 ( jaxbelement < string > value ) { this . apisuchfeld2 = value ; }	Sets the value of the apiSuchfeld2 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setapisuchfeld3 ( jaxbelement < string > value ) { this . apisuchfeld3 = value ; }	Sets the value of the apiSuchfeld3 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < resultsettype . row > getrow ( ) { if ( row == null ) { row = new arraylist < resultsettype . row > ( ) ; } return this . row ; }	Gets the value of the row property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setdistanzzusport ( distanzensport . distanzzusport value ) { this . distanzzusport = value ; }	Sets the value of the distanzZuSport property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < anhang > getanhang ( ) { if ( anhang == null ) { anhang = new arraylist < anhang > ( ) ; } return this . anhang ; }	Gets the value of the anhang property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public garagenkategorietyp getobjektkategorie2 ( ) { if ( objektkategorie2 == null ) { return garagenkategorietyp . keine_angabe ; } else { return objektkategorie2 ; } }	Gets the value of the objektKategorie2 property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public objektzustandtyp getobjektzustand ( ) { if ( objektzustand == null ) { return objektzustandtyp . keine_angabe ; } else { return objektzustand ; } }	Gets the value of the objektzustand property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public hauskategorientyp gethauskategorie ( ) { if ( hauskategorie == null ) { return hauskategorientyp . keine_angabe ; } else { return hauskategorie ; } }	Gets the value of the hausKategorie property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public ausstattungsqualitaetstyp getausstattungsqualitaet ( ) { if ( ausstattungsqualitaet == null ) { return ausstattungsqualitaetstyp . keine_angabe ; } else { return ausstattungsqualitaet ; } }	Gets the value of the ausstattungsqualitaet property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < string > getvermarktungsart ( ) { if ( vermarktungsart == null ) { vermarktungsart = new arraylist < string > ( ) ; } return this . vermarktungsart ; }	Gets the value of the vermarktungsart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < interessent > getinteressent ( ) { if ( interessent == null ) { interessent = new arraylist < interessent > ( ) ; } return this . interessent ; }	Gets the value of the interessent property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setwert ( provisionteilen . wert value ) { this . wert = value ; }	Sets the value of the wert property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setackerland ( jaxbelement < object > value ) { this . ackerland = value ; }	Sets the value of the ackerland property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbauerwartungsland ( jaxbelement < object > value ) { this . bauerwartungsland = value ; }	Sets the value of the bauerwartungsland property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbootsstaende ( jaxbelement < object > value ) { this . bootsstaende = value ; }	Sets the value of the bootsstaende property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbuero ( jaxbelement < object > value ) { this . buero = value ; }	Sets the value of the buero property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setcamping ( jaxbelement < object > value ) { this . camping = value ; }	Sets the value of the camping property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setdoppelhaus ( jaxbelement < object > value ) { this . doppelhaus = value ; }	Sets the value of the doppelhaus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void seteinfamilienhaus ( jaxbelement < object > value ) { this . einfamilienhaus = value ; }	Sets the value of the einfamilienhaus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void seteinzelhandelgross ( jaxbelement < object > value ) { this . einzelhandelgross = value ; }	Sets the value of the einzelhandelGross property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void seteinzelhandelklein ( jaxbelement < object > value ) { this . einzelhandelklein = value ; }	Sets the value of the einzelhandelKlein property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgaragen ( jaxbelement < object > value ) { this . garagen = value ; }	Sets the value of the garagen property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgarten ( jaxbelement < object > value ) { this . garten = value ; }	Sets the value of the garten property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgastronomie ( jaxbelement < object > value ) { this . gastronomie = value ; }	Sets the value of the gastronomie property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgewerbe ( jaxbelement < object > value ) { this . gewerbe = value ; }	Sets the value of the gewerbe property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void sethotel ( jaxbelement < object > value ) { this . hotel = value ; }	Sets the value of the hotel property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setindustrie ( jaxbelement < object > value ) { this . industrie = value ; }	Sets the value of the industrie property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setkeinebebauung ( jaxbelement < object > value ) { this . keinebebauung = value ; }	Sets the value of the keineBebauung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setkleingewerbe ( jaxbelement < object > value ) { this . kleingewerbe = value ; }	Sets the value of the kleingewerbe property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setlager ( jaxbelement < object > value ) { this . lager = value ; }	Sets the value of the lager property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmehrfamilienhaus ( jaxbelement < object > value ) { this . mehrfamilienhaus = value ; }	Sets the value of the mehrfamilienhaus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setobstpflanzung ( jaxbelement < object > value ) { this . obstpflanzung = value ; }	Sets the value of the obstpflanzung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setparkhaus ( jaxbelement < object > value ) { this . parkhaus = value ; }	Sets the value of the parkhaus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setproduktion ( jaxbelement < object > value ) { this . produktion = value ; }	Sets the value of the produktion property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setreihenhaus ( jaxbelement < object > value ) { this . reihenhaus = value ; }	Sets the value of the reihenhaus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setstellplaetze ( jaxbelement < object > value ) { this . stellplaetze = value ; }	Sets the value of the stellplaetze property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setvilla ( jaxbelement < object > value ) { this . villa = value ; }	Sets the value of the villa property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setwald ( jaxbelement < object > value ) { this . wald = value ; }	Sets the value of the wald property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setanbieter ( immobilientransfertyp . anbieter value ) { this . anbieter = value ; }	Sets the value of the anbieter property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < wohnung > getwohnung ( ) { if ( wohnung == null ) { wohnung = new arraylist < wohnung > ( ) ; } return this . wohnung ; }	Gets the value of the wohnung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < grundstueck > getgrundstueck ( ) { if ( grundstueck == null ) { grundstueck = new arraylist < grundstueck > ( ) ; } return this . grundstueck ; }	Gets the value of the grundstueck property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < einzelhandel > geteinzelhandel ( ) { if ( einzelhandel == null ) { einzelhandel = new arraylist < einzelhandel > ( ) ; } return this . einzelhandel ; }	Gets the value of the einzelhandel property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < hallenlagerprod > gethallenlagerprod ( ) { if ( hallenlagerprod == null ) { hallenlagerprod = new arraylist < hallenlagerprod > ( ) ; } return this . hallenlagerprod ; }	Gets the value of the hallenLagerProd property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < parken > getparken ( ) { if ( parken == null ) { parken = new arraylist < parken > ( ) ; } return this . parken ; }	Gets the value of the parken property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < freizeitimmobiliegewerblich > getfreizeitimmobiliegewerblich ( ) { if ( freizeitimmobiliegewerblich == null ) { freizeitimmobiliegewerblich = new arraylist < freizeitimmobiliegewerblich > ( ) ; } return this . freizeitimmobiliegewerblich ; }	Gets the value of the freizeitimmobilieGewerblich property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < string > getobjektartzusatz ( ) { if ( objektartzusatz == null ) { objektartzusatz = new arraylist < string > ( ) ; } return this . objektartzusatz ; }	Gets the value of the objektartZusatz property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < stellplatzart > getstellplatzart ( ) { if ( stellplatzart == null ) { stellplatzart = new arraylist < stellplatzart > ( ) ; } return this . stellplatzart ; }	Gets the value of the stellplatzart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmaxdauer ( maxmietdauer . maxdauer value ) { this . maxdauer = value ; }	Sets the value of the maxDauer property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < string > getfeature ( ) { if ( feature == null ) { feature = new arraylist < string > ( ) ; } return this . feature ; }	Gets the value of the feature property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setzimmertyp ( zimmer . zimmertyp value ) { this . zimmertyp = value ; }	Sets the value of the zimmertyp property.
@ override @ suppresswarnings ( str_ ) public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_5 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgradeenergiepasselements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.4 to 1.2.5.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setkeineangabe ( jaxbelement < object > value ) { this . keineangabe = value ; }	Sets the value of the keineAngabe property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void seterdwaerme ( jaxbelement < object > value ) { this . erdwaerme = value ; }	Sets the value of the erdwaerme property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setsolarheizung ( jaxbelement < object > value ) { this . solarheizung = value ; }	Sets the value of the solarheizung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpelletheizung ( jaxbelement < object > value ) { this . pelletheizung = value ; }	Sets the value of the pelletheizung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgas ( jaxbelement < object > value ) { this . gas = value ; }	Sets the value of the gas property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setoel ( jaxbelement < object > value ) { this . oel = value ; }	Sets the value of the oel property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setfernwaerme ( jaxbelement < object > value ) { this . fernwaerme = value ; }	Sets the value of the fernwaerme property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setstrom ( jaxbelement < object > value ) { this . strom = value ; }	Sets the value of the strom property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setkohle ( jaxbelement < object > value ) { this . kohle = value ; }	Sets the value of the kohle property.
public static string random ( int length ) { return new randomstringgenerator . builder ( ) . filteredby ( numbers , letters ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII letters and digits.
public static string randomletters ( int length ) { return new randomstringgenerator . builder ( ) . filteredby ( letters ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII letters.
public static string randomnumeric ( int length ) { return new randomstringgenerator . builder ( ) . filteredby ( numbers ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII digits.
@ generated ( value = str_ , date = str_ , comments = str_ ) public wohnungkategorientyp getwohnungkategorie ( ) { if ( wohnungkategorie == null ) { return wohnungkategorientyp . keine_angabe ; } else { return wohnungkategorie ; } }	Gets the value of the wohnungKategorie property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbenutzer ( wis . benutzer value ) { this . benutzer = value ; }	Sets the value of the benutzer property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setobjekte ( wis . objekte value ) { this . objekte = value ; }	Sets the value of the objekte property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < feedindex . feed > getfeed ( ) { if ( feed == null ) { feed = new arraylist < feedindex . feed > ( ) ; } return this . feed ; }	Gets the value of the feed property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmoeb ( moebliert . moeb value ) { this . moeb = value ; }	Sets the value of the moeb property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < serviceleistungen > getserviceleistungen ( ) { if ( serviceleistungen == null ) { serviceleistungen = new arraylist < serviceleistungen > ( ) ; } return this . serviceleistungen ; }	Gets the value of the serviceleistungen property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setsubadministrativearea ( locationstructure . subadministrativearea value ) { this . subadministrativearea = value ; }	Sets the value of the subAdministrativeArea property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setcity ( locationstructure . city value ) { this . city = value ; }	Sets the value of the city property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setlocality ( locationstructure . locality value ) { this . locality = value ; }	Sets the value of the locality property.
@ override public void downgradetopreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_0 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . removeobjektartzusatzelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . downgradeenergiepasselements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . downgradehauselements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } try { this . downgradexmlnamespace ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } }	Downgrade an OpenImmo document from version 1.2.1 to 1.2.0.
@ override @ suppresswarnings ( str_ ) public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_1 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgradeenergiepasselements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } try { this . upgradexmlnamespace ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } }	Upgrade an OpenImmo document from version 1.2.0 to 1.2.1.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setlandtyp ( landundforstwirtschaft . landtyp value ) { this . landtyp = value ; }	Sets the value of the landTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < metadatatype . field > getfield ( ) { if ( field == null ) { field = new arraylist < metadatatype . field > ( ) ; } return this . field ; }	Gets the value of the field property.
@ override public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_0 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgrademieteinnahmenelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.1 to 1.2.0.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < adtype > getad ( ) { if ( ad == null ) { ad = new arraylist < adtype > ( ) ; } return this . ad ; }	Gets the value of the ad property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setgastgewtyp ( gastgewerbe . gastgewtyp value ) { this . gastgewtyp = value ; }	Sets the value of the gastgewTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setplatzart ( stpsonstige . platzart value ) { this . platzart = value ; }	Sets the value of the platzart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public datenverkabelungstyp getdatenverkabelung ( ) { if ( datenverkabelung == null ) { return datenverkabelungstyp . keine_angabe ; } else { return datenverkabelung ; } }	Gets the value of the datenVerkabelung property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public janeinvereinbarungtyp getklimaanlage ( ) { if ( klimaanlage == null ) { return janeinvereinbarungtyp . keine_angabe ; } else { return klimaanlage ; } }	Gets the value of the klimaanlage property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < imagestype . image > getimage ( ) { if ( image == null ) { image = new arraylist < imagestype . image > ( ) ; } return this . image ; }	Gets the value of the image property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpricetype ( overseassaleadtype . pricetype value ) { this . pricetype = value ; }	Sets the value of the priceType property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setnewdevelopmentavailability ( java . lang . string value ) { this . newdevelopmentavailability = value ; }	Sets the value of the newDevelopmentAvailability property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setdirections ( java . lang . string value ) { this . directions = value ; }	Sets the value of the directions property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setco2rating ( java . lang . string value ) { this . co2rating = value ; }	Sets the value of the co2Rating property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setenergyrating ( java . lang . string value ) { this . energyrating = value ; }	Sets the value of the energyRating property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setviewingdetails ( java . lang . string value ) { this . viewingdetails = value ; }	Sets the value of the viewingDetails property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpropertystatus ( overseassaleadtype . propertystatus value ) { this . propertystatus = value ; }	Sets the value of the propertyStatus property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setpictures ( adtype . pictures value ) { this . pictures = value ; }	Sets the value of the pictures property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setbebaubarattr ( bebaubarnach . bebaubarattr value ) { this . bebaubarattr = value ; }	Sets the value of the bebaubarAttr property.
@ override public void upgradefrompreviousversion ( openimmodocument doc ) { doc . setdocumentversion ( openimmoversion . v1_2_4 ) ; if ( doc instanceof openimmotransferdocument ) { try { this . upgradeanzahlbalkonterrassenelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradeanhangelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradesonstigeelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.3 to 1.2.4.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setparkentyp ( parken . parkentyp value ) { this . parkentyp = value ; }	Sets the value of the parkenTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setalterattr ( alter . alterattr value ) { this . alterattr = value ; }	Sets the value of the alterAttr property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setfreizeittyp ( freizeitimmobiliegewerblich . freizeittyp value ) { this . freizeittyp = value ; }	Sets the value of the freizeitTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void settelefonart ( telsonstige . telefonart value ) { this . telefonart = value ; }	Sets the value of the telefonart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setemailart ( emailsonstige . emailart value ) { this . emailart = value ; }	Sets the value of the emailart property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setoverseassales ( daft . overseassales value ) { this . overseassales = value ; }	Sets the value of the overseasSales property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setoverseasrental ( daft . overseasrental value ) { this . overseasrental = value ; }	Sets the value of the overseasRental property.
@ suppresswarnings ( str_ ) public static element createuserdefinedsimplefield ( document doc , string name , string value ) { element root = xmlutils . getrootelement ( doc ) ; element node = doc . createelementns ( root . getnamespaceuri ( ) , str_ ) ; node . setattribute ( str_ , name ) ; node . settextcontent ( value ) ; return node ; }	Helper method to create a &lt;user_defined_simplefield&gt; element with a"feldname" attribute and a string value.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < fehlerliste . fehler > getfehler ( ) { if ( fehler == null ) { fehler = new arraylist < fehlerliste . fehler > ( ) ; } return this . fehler ; }	Gets the value of the fehler property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void seterbpacht ( jaxbelement < vermarktunggrundstueckgewerbetyp . erbpacht > value ) { this . erbpacht = value ; }	Sets the value of the erbpacht property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < stpsonstige > getstpsonstige ( ) { if ( stpsonstige == null ) { stpsonstige = new arraylist < stpsonstige > ( ) ; } return this . stpsonstige ; }	Gets the value of the stpSonstige property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < valueliststype . valuelist > getvaluelist ( ) { if ( valuelist == null ) { valuelist = new arraylist < valueliststype . valuelist > ( ) ; } return this . valuelist ; }	Gets the value of the valuelist property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmindauer ( minmietdauer . mindauer value ) { this . mindauer = value ; }	Sets the value of the minDauer property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setzinstyp ( zinshausrenditeobjekt . zinstyp value ) { this . zinstyp = value ; }	Sets the value of the zinsTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < uri > getphoto ( ) { if ( photo == null ) { photo = new arraylist < uri > ( ) ; } return this . photo ; }	Gets the value of the photo property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setmetadata ( feed . metadata value ) { this . metadata = value ; }	Sets the value of the metadata property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setprojects ( feed . projects value ) { this . projects = value ; }	Sets the value of the projects property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setproperties ( feed . properties value ) { this . properties = value ; }	Sets the value of the properties property.
@ override public void upgradefrompreviousversion ( kyerodocument doc ) { doc . setdocumentversion ( kyeroversion . v3 ) ; try { this . removecustomelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradenewbuildelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradetypeelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradecurrencyelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } try { this . upgradeurlelements ( doc . getdocument ( ) ) ; } catch ( exception ex ) { logger . error ( str_ ) ; logger . error ( str_ + ex . getlocalizedmessage ( ) , ex ) ; } }	Upgrade a Kyero document to version 3.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < immobilie > getimmobilie ( ) { if ( immobilie == null ) { immobilie = new arraylist < immobilie > ( ) ; } return this . immobilie ; }	Gets the value of the immobilie property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < objekt > getobjekt ( ) { if ( objekt == null ) { objekt = new arraylist < objekt > ( ) ; } return this . objekt ; }	Gets the value of the objekt property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < fehlerliste > getfehlerliste ( ) { if ( fehlerliste == null ) { fehlerliste = new arraylist < fehlerliste > ( ) ; } return this . fehlerliste ; }	Gets the value of the fehlerliste property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < status > getstatus ( ) { if ( status == null ) { status = new arraylist < status > ( ) ; } return this . status ; }	Gets the value of the status property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setsonstigetyp ( sonstige . sonstigetyp value ) { this . sonstigetyp = value ; }	Sets the value of the sonstigeTyp property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public void setdistanzzu ( distanzen . distanzzu value ) { this . distanzzu = value ; }	Sets the value of the distanzZu property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < distanzen > getdistanzen ( ) { if ( distanzen == null ) { distanzen = new arraylist < distanzen > ( ) ; } return this . distanzen ; }	Gets the value of the distanzen property.
@ generated ( value = str_ , date = str_ , comments = str_ ) public list < distanzensport > getdistanzensport ( ) { if ( distanzensport == null ) { distanzensport = new arraylist < distanzensport > ( ) ; } return this . distanzensport ; }	Gets the value of the distanzenSport property.
public static boolean iscompatiblewiththrowsclause ( throwable ex , class < ? > [ ] declaredexceptions ) { if ( ! ischeckedexception ( ex ) ) { return bool_ ; } if ( declaredexceptions != null ) { int i = num_ ; while ( i < declaredexceptions . length ) { if ( declaredexceptions [ i ] . isassignablefrom ( ex . getclass ( ) ) ) { return bool_ ; } i ++ ; } } return bool_ ; }	Check whether the given exception is compatible with the exceptionsdeclared in a throws clause.
public void setbindings ( map < string , string > bindings ) { for ( map . entry < string , string > entry : bindings . entryset ( ) ) { bindnamespaceuri ( entry . getkey ( ) , entry . getvalue ( ) ) ; } }	Sets the bindings for this namespace context.
public void bindnamespaceuri ( string prefix , string namespaceuri ) { assert . notnull ( prefix , str_ ) ; assert . notnull ( namespaceuri , str_ ) ; if ( xmlconstants . default_ns_prefix . equals ( prefix ) ) { defaultnamespaceuri = namespaceuri ; } else { prefixtonamespaceuri . put ( prefix , namespaceuri ) ; getprefixesinternal ( namespaceuri ) . add ( prefix ) ; } }	Binds the given prefix to the given namespace.
public void removebinding ( string prefix ) { if ( xmlconstants . default_ns_prefix . equals ( prefix ) ) { defaultnamespaceuri = str_ ; } else { string namespaceuri = prefixtonamespaceuri . remove ( prefix ) ; list < string > prefixes = getprefixesinternal ( namespaceuri ) ; prefixes . remove ( prefix ) ; } }	Removes the given prefix from this context.
private boolean hasopeningtag ( string content ) { if ( this . incomment ) { return bool_ ; } int opentagindex = content . indexof ( str_ ) ; return ( opentagindex > - num_ && content . length ( ) > opentagindex && character . isletter ( content . charat ( opentagindex + num_ ) ) ) ; }	Does the supplied content contain an XML opening tag.
private string consumecommenttokens ( string line ) { if ( line . indexof ( start_comment ) == - num_ && line . indexof ( end_comment ) == - num_ ) { return line ; } while ( ( line = consume ( line ) ) != null ) { if ( ! this . incomment && ! line . trim ( ) . startswith ( start_comment ) ) { return line ; } } return line ; }	Consumes all the leading comment data in the given String and returns the remaining content, whichmay be empty since the supplied content might be all comment data.
private string consume ( string line ) { int index = ( this . incomment ? endcomment ( line ) : startcomment ( line ) ) ; return ( index == - num_ ? null : line . substring ( index ) ) ; }	Consume the next comment token, update the "inComment" flagand return the remaining content.
private int commenttoken ( string line , string token , boolean incommentifpresent ) { int index = line . indexof ( token ) ; if ( index > - num_ ) { this . incomment = incommentifpresent ; } return ( index == - num_ ? index : index + token . length ( ) ) ; }	Try to consume the supplied token against the supplied content and update thein comment parse state to the supplied value.
public static void initlogging ( string location ) throws filenotfoundexception { string resolvedlocation = systempropertyutils . resolveplaceholders ( location ) ; url url = resourceutils . geturl ( resolvedlocation ) ; if ( resolvedlocation . tolowercase ( ) . endswith ( xml_file_extension ) ) { domconfigurator . configure ( url ) ; } else { propertyconfigurator . configure ( url ) ; } }	Initialize log4j from the given file location, with no config file refreshing.Assumes an XML file in case of a ".xml" file extension, and a properties fileotherwise.
@ override public final void startprefixmapping ( string prefix , string uri ) { namespacecontext . bindnamespaceuri ( prefix , uri ) ; namespacecontextchanged = bool_ ; }	Binds the given prefix to the given namespaces.
public void add ( iterator < e > iterator ) { assert . state ( ! inuse , str_ ) ; if ( iterators . contains ( iterator ) ) { throw new illegalargumentexception ( str_ ) ; } iterators . add ( iterator ) ; }	Add given iterator to this composite.
public final option addoption ( option opt ) { if ( opt . shortform ( ) != null ) this . options . put ( str_ + opt . shortform ( ) , opt ) ; this . options . put ( str_ + opt . longform ( ) , opt ) ; return opt ; }	Add the specified Option to the list of accepted options.
public final option addstringoption ( char shortform , string longform ) { return addoption ( new option . stringoption ( shortform , longform ) ) ; }	Convenience method for adding a string option.
public final option addintegeroption ( char shortform , string longform ) { return addoption ( new option . integeroption ( shortform , longform ) ) ; }	Convenience method for adding an integer option.
public final option addlongoption ( char shortform , string longform ) { return addoption ( new option . longoption ( shortform , longform ) ) ; }	Convenience method for adding a long integer option.
public final option adddoubleoption ( char shortform , string longform ) { return addoption ( new option . doubleoption ( shortform , longform ) ) ; }	Convenience method for adding a double option.
public final option addbooleanoption ( char shortform , string longform ) { return addoption ( new option . booleanoption ( shortform , longform ) ) ; }	Convenience method for adding a boolean option.
public final void parse ( string [ ] argv , locale locale ) throws illegaloptionvalueexception , unknownoptionexception {	Extract the options and non-option arguments from the givenlist of command-line arguments.
public object newinstance ( class c ) throws instantiationexception , illegalaccessexception { object ret = null ; method [ ] methods = c . getdeclaredmethods ( ) ; method m ; int modifiers ;	Dynamic instantiation of the given type with singleton retrieval support as described in this class description.
protected void afteraccess ( ) { if ( this . concurrencylimit >= num_ ) { synchronized ( this . monitor ) { this . concurrencycount -- ; if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + this . concurrencycount ) ; } this . monitor . notify ( ) ; } } }	To be invoked after the main execution logic of concrete subclasses.
public void settargetobject ( object targetobject ) { this . targetobject = targetobject ; if ( targetobject != null ) { this . targetclass = targetobject . getclass ( ) ; } }	Set the target object on which to call the target method.Only necessary when the target method is not static;else, a target class is sufficient.
public void prepare ( ) throws classnotfoundexception , nosuchmethodexception { if ( this . staticmethod != null ) { int lastdotindex = this . staticmethod . lastindexof ( str_ ) ; if ( lastdotindex == - num_ || lastdotindex == this . staticmethod . length ( ) ) { throw new illegalargumentexception ( str_ + str_ ) ; } string classname = this . staticmethod . substring ( num_ , lastdotindex ) ; string methodname = this . staticmethod . substring ( lastdotindex + num_ ) ; this . targetclass = resolveclassname ( classname ) ; this . targetmethod = methodname ; } class < ? > targetclass = gettargetclass ( ) ; string targetmethod = gettargetmethod ( ) ; if ( targetclass == null ) { throw new illegalargumentexception ( str_ ) ; } if ( targetmethod == null ) { throw new illegalargumentexception ( str_ ) ; } object [ ] arguments = getarguments ( ) ; class < ? > [ ] argtypes = new class < ? > [ arguments . length ] ; for ( int i = num_ ; i < arguments . length ; ++ i ) { argtypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getclass ( ) : object . class ) ; }	Prepare the specified method.The method can be invoked any number of times afterwards.
protected method findmatchingmethod ( ) { string targetmethod = gettargetmethod ( ) ; object [ ] arguments = getarguments ( ) ; int argcount = arguments . length ; method [ ] candidates = reflectionutils . getalldeclaredmethods ( gettargetclass ( ) ) ; int mintypediffweight = integer . max_value ; method matchingmethod = null ; for ( method candidate : candidates ) { if ( candidate . getname ( ) . equals ( targetmethod ) ) { class < ? > [ ] paramtypes = candidate . getparametertypes ( ) ; if ( paramtypes . length == argcount ) { int typediffweight = gettypedifferenceweight ( paramtypes , arguments ) ; if ( typediffweight < mintypediffweight ) { mintypediffweight = typediffweight ; matchingmethod = candidate ; } } } } return matchingmethod ; }	Find a matching method with the specified name for the specified arguments.
private static string tounsignedstring ( int i , int shift ) { char [ ] buf = new char [ num_ ] ; int charpos = num_ ; int radix = num_ << shift ; int mask = radix - num_ ; do { buf [ -- charpos ] = digits [ i & mask ] ; i >>>= shift ; } while ( i != num_ ) ; return new string ( buf , charpos , ( num_ - charpos ) ) ; }	Convert the integer to an unsigned number.
public static byte [ ] serialize ( object object ) { if ( object == null ) { return null ; } bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; try { objectoutputstream oos = new objectoutputstream ( baos ) ; oos . writeobject ( object ) ; oos . flush ( ) ; } catch ( ioexception ex ) { throw new illegalargumentexception ( str_ + object . getclass ( ) , ex ) ; } return baos . tobytearray ( ) ; }	Serialize the given object to a byte array.
public static object deserialize ( byte [ ] bytes ) { if ( bytes == null ) { return null ; } try { objectinputstream ois = new objectinputstream ( new bytearrayinputstream ( bytes ) ) ; return ois . readobject ( ) ; } catch ( ioexception ex ) { throw new illegalargumentexception ( str_ , ex ) ; } catch ( classnotfoundexception ex ) { throw new illegalstateexception ( str_ , ex ) ; } }	Deserialize the byte array into an object.
public static element getchildelementbytagname ( element ele , string childelename ) { assert . notnull ( ele , str_ ) ; assert . notnull ( childelename , str_ ) ; nodelist nl = ele . getchildnodes ( ) ; for ( int i = num_ ; i < nl . getlength ( ) ; i ++ ) { node node = nl . item ( i ) ; if ( node instanceof element && nodenamematch ( node , childelename ) ) { return ( element ) node ; } } return null ; }	Utility method that returns the first child element identified by its name.
public static string getchildelementvaluebytagname ( element ele , string childelename ) { element child = getchildelementbytagname ( ele , childelename ) ; return ( child != null ? gettextvalue ( child ) : null ) ; }	Utility method that returns the first child element value identified by its name.
public static list < element > getchildelements ( element ele ) { assert . notnull ( ele , str_ ) ; nodelist nl = ele . getchildnodes ( ) ; list < element > childeles = new arraylist < element > ( ) ; for ( int i = num_ ; i < nl . getlength ( ) ; i ++ ) { node node = nl . item ( i ) ; if ( node instanceof element ) { childeles . add ( ( element ) node ) ; } } return childeles ; }	Retrieves all child elements of the given DOM element.
private static boolean nodenamematch ( node node , string desiredname ) { return ( desiredname . equals ( node . getnodename ( ) ) || desiredname . equals ( node . getlocalname ( ) ) ) ; }	Matches the given node's name and local name against the given desired name.
private static boolean nodenamematch ( node node , collection < ? > desirednames ) { return ( desirednames . contains ( node . getnodename ( ) ) || desirednames . contains ( node . getlocalname ( ) ) ) ; }	Matches the given node's name and local name against the given desired names.
public static final string setsize ( final string s , final int length ) { string result = s ; int oldlen = s . length ( ) ; if ( oldlen > length ) { system . err . println ( str_ + length + str_ + oldlen + str_ + s ) ; } else { int tofill = length - oldlen ; result = stringutil . appendspaces ( s , tofill ) ; } return result ; }	Appends the necessary amount of spaces to the string until it has the givnlength.
public static void monitor ( object handle , releaselistener listener ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ + handle + str_ + listener + str_ ) ; }	Start to monitor given handle object for becoming weakly reachable.When the handle isn't used anymore, the given listener will be called.
private static void addentry ( reference < ? > ref , releaselistener entry ) { synchronized ( weakreferencemonitor . class ) {	Add entry to internal map of tracked entries.Internal monitoring thread is started if not already running.
private static boolean keepmonitoringthreadalive ( ) { synchronized ( weakreferencemonitor . class ) { if ( ! trackedentries . isempty ( ) ) { return bool_ ; } else { logger . debug ( str_ ) ; monitoringthread = null ; return bool_ ; } } }	Check whether to keep the monitoring thread alive,i.e.
public static string calcmobilecity ( string mobilenumber ) throws malformedurlexception { objectmapper objectmapper = new objectmapper ( ) ; string jsonstring = null ; string urlstring = str_ + mobilenumber ; stringbuffer sb = new stringbuffer ( ) ; bufferedreader buffer ; url url = new url ( urlstring ) ; try { inputstream in = url . openstream ( ) ;	Test the phone number from which the city is using Taobao API.
protected void startprefixmapping ( string prefix , string namespace ) throws saxexception { if ( getcontenthandler ( ) != null ) { if ( prefix == null ) { prefix = str_ ; } if ( ! stringutils . haslength ( namespace ) ) { return ; } if ( ! namespace . equals ( namespaces . get ( prefix ) ) ) { getcontenthandler ( ) . startprefixmapping ( prefix , namespace ) ; namespaces . put ( prefix , namespace ) ; } } }	Starts the prefix mapping for the given prefix.
protected void endprefixmapping ( string prefix ) throws saxexception { if ( getcontenthandler ( ) != null ) { if ( namespaces . containskey ( prefix ) ) { getcontenthandler ( ) . endprefixmapping ( prefix ) ; namespaces . remove ( prefix ) ; } } }	Ends the prefix mapping for the given prefix.
@ suppresswarnings ( str_ ) public void addcallback ( listenablefuturecallback < ? super t > callback ) { assert . notnull ( callback , str_ ) ; synchronized ( mutex ) { switch ( state ) { case new : callbacks . add ( callback ) ; break ; case success : callback . onsuccess ( ( t ) result ) ; break ; case failure : callback . onfailure ( ( throwable ) result ) ; break ; } } }	Adds the given callback to this registry.
private itreenode parsetree ( ) { itreenode root = new treenodeuniquechildren ( ) ; itreenode newnode , oldnode ; enumeration entries = this . jar . entries ( ) ; string entry ; while ( entries . hasmoreelements ( ) ) { newnode = root ; oldnode = root ; entry = ( ( jarentry ) entries . nextelement ( ) ) . getname ( ) ; system . out . println ( str_ + entry ) ; stringtokenizer tokenizer = new stringtokenizer ( entry , str_ ) ; while ( tokenizer . hasmoreelements ( ) ) { string path = tokenizer . nexttoken ( ) ; newnode = new treenodeuniquechildren ( path ) ; oldnode . addchildnode ( newnode ) ; oldnode = newnode ; } } return root ; }	Build a Tree from the entries.
private int gettextcolor ( int item ) { int scrollx = getscrollx ( ) ;	Calculates text color for specified item based on its position and state.
public void setvalues ( charsequence [ ] values ) { if ( this . values != values ) { this . values = values ; if ( this . values != null ) { layouts = new boringlayout [ this . values . length ] ; for ( int i = num_ ; i < layouts . length ; i ++ ) { layouts [ i ] = new boringlayout ( this . values [ i ] , textpaint , itemwidth , layout . alignment . align_center , num_ , num_ , boringmetrics , bool_ , ellipsize , itemwidth ) ; } } else { layouts = new boringlayout [ num_ ] ; }	Sets values to choose from.
private int getcolor ( int scrollx , int position ) { int itemwithpadding = ( int ) ( itemwidth + dividersize ) ; float proportion = math . abs ( ( ( num_ * scrollx % itemwithpadding ) / num_ ) / ( itemwithpadding / num_ ) ) ; if ( proportion > num_ ) { proportion = ( proportion - num_ ) ; } else { proportion = num_ - proportion ; } proportion *= num_ ; int defaultcolor ; int selectedcolor ; if ( presseditem == position ) { defaultcolor = textcolor . getcolorforstate ( new int [ ] { android . r . attr . state_pressed } , textcolor . getdefaultcolor ( ) ) ; selectedcolor = textcolor . getcolorforstate ( new int [ ] { android . r . attr . state_pressed , android . r . attr . state_selected } , defaultcolor ) ; } else { defaultcolor = textcolor . getdefaultcolor ( ) ; selectedcolor = textcolor . getcolorforstate ( new int [ ] { android . r . attr . state_selected } , defaultcolor ) ; } return ( integer ) new argbevaluator ( ) . evaluate ( proportion , selectedcolor , defaultcolor ) ; }	Calculates color for specific position on time picker.
private void settextsize ( float size ) { if ( size != textpaint . gettextsize ( ) ) { textpaint . settextsize ( size ) ; requestlayout ( ) ; invalidate ( ) ; } }	Sets text size for items.
private int getinboundsx ( int x ) { if ( x < num_ ) { x = num_ ; } else if ( x > ( ( itemwidth + ( int ) dividersize ) * ( values . length - num_ ) ) ) { x = ( ( itemwidth + ( int ) dividersize ) * ( values . length - num_ ) ) ; } return x ; }	Calculates x scroll position that is still in range of view scroller.
private string getintro ( ) { try { inputstream introstream = myremotelibrary . class . getresourceasstream ( str_ ) ; stringwriter writer = new stringwriter ( ) ; ioutils . copy ( introstream , writer , charset . defaultcharset ( ) ) ; return writer . tostring ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	The introduction is stored in a text file resource because it is easier to edit than String constants.
public string [ ] get_keyword_names ( ) { try { string [ ] names = servlet . getlibrary ( ) . getkeywordnames ( ) ; if ( names == null || names . length == num_ ) throw new runtimeexception ( str_ ) ; string [ ] newnames = arrays . copyof ( names , names . length + num_ ) ; newnames [ names . length ] = str_ ; return newnames ; } catch ( throwable e ) { log . warn ( str_ , e ) ; throw new runtimeexception ( e ) ; } }	Get an array containing the names of the keywords that the libraryimplements.
public string [ ] get_keyword_arguments ( string keyword ) { if ( keyword . equalsignorecase ( str_ ) ) { return new string [ num_ ] ; } try { string [ ] args = servlet . getlibrary ( ) . getkeywordarguments ( keyword ) ; return args == null ? new string [ num_ ] : args ; } catch ( throwable e ) { log . warn ( str_ , e ) ; throw new runtimeexception ( e ) ; } }	Get an array of argument specifications for the given keyword.
public string get_keyword_documentation ( string keyword ) { if ( keyword . equalsignorecase ( str_ ) ) { return str_ ; } try { string doc = servlet . getlibrary ( ) . getkeyworddocumentation ( keyword ) ; return doc == null ? str_ : doc ; } catch ( throwable e ) { log . warn ( str_ , e ) ; throw new runtimeexception ( e ) ; } }	Get documentation for given keyword.
public static void main ( string [ ] args ) throws exception { configurelogging ( ) ; commandlinehelper helper = new commandlinehelper ( args ) ; if ( helper . gethelprequested ( ) ) { system . out . print ( helper . getusage ( ) ) ; system . exit ( num_ ) ; } remoteserver remoteserver = new remoteserver ( ) ; string error = helper . geterror ( ) ; if ( error == null ) { try { for ( string path : helper . getlibrarymap ( ) . keyset ( ) ) remoteserver . putlibrary ( path , helper . getlibrarymap ( ) . get ( path ) ) ; } catch ( illegalpathexception e ) { error = e . getmessage ( ) ; } } if ( error != null ) { system . out . println ( str_ + error ) ; system . out . println ( ) ; system . out . println ( helper . getusage ( ) ) ; system . exit ( num_ ) ; } remoteserver . setport ( helper . getport ( ) ) ; remoteserver . setallowstop ( helper . getallowstop ( ) ) ; remoteserver . sethost ( helper . gethost ( ) ) ; remoteserver . start ( ) ; }	Main method for command line usage.
public void stop ( int timeoutms ) throws exception { log . info ( str_ ) ; if ( timeoutms > num_ ) { server . setgracefulshutdown ( timeoutms ) ; thread stopper = new thread ( ) { @ override public void run ( ) { try { server . stop ( ) ; } catch ( throwable e ) { log . error ( string . format ( str_ , e . getmessage ( ) ) , e ) ; } } } ; stopper . start ( ) ; } else { server . stop ( ) ; } }	A non-blocking method for stopping the remote server that allows requeststo complete within the given timeout before shutting down the server.
public void start ( ) throws exception { log . info ( str_ ) ; server . start ( ) ; log . info ( string . format ( str_ , getlocalport ( ) ) ) ; }	Starts the remote server.
public string convertpropertiesfromfiletojson ( string pathtofile , string ... includedomainkeys ) throws readinputexception , parsepropertiesexception { return convertpropertiesfromfiletojson ( new file ( pathtofile ) , includedomainkeys ) ; }	Generate Json by given path to file with properties with only included domain keys.
public string convertpropertiesfromfiletojson ( file file , string ... includedomainkeys ) throws readinputexception , parsepropertiesexception { try { inputstream targetstream = new fileinputstream ( file ) ; return converttojson ( targetstream , includedomainkeys ) ; } catch ( filenotfoundexception e ) { throw new readinputexception ( e ) ; } }	Generate Json by given file with properties with only included domain keys.
public string converttojson ( inputstream inputstream , string ... includedomainkeys ) throws readinputexception , parsepropertiesexception { return converttojson ( inputstreamtoproperties ( inputstream ) , includedomainkeys ) ; }	generate Json by given InputStream and given filter.
public string converttojson ( properties properties ) throws parsepropertiesexception { for ( map . entry < object , object > entry : properties . entryset ( ) ) { if ( ! ( entry . getkey ( ) instanceof string ) ) { throw new parsepropertiesexception ( format ( property_key_needs_to_be_string_type , entry . getkey ( ) . getclass ( ) , entry . getkey ( ) == null ? str_ : entry . getkey ( ) ) ) ; } } return convertfromvaluesasobjectmap ( propertiestomap ( properties ) ) ; }	generate Json by given Java Properties.
public string converttojson ( map < string , string > properties ) throws parsepropertiesexception { return convertfromvaluesasobjectmap ( stringvaluemaptoobjectvaluemap ( properties ) ) ; }	generate Json by given Map&lt;String,String&gt;.
public string convertfromvaluesasobjectmap ( map < string , object > properties ) throws parsepropertiesexception { objectjsontype coreobjectjsontype = new objectjsontype ( ) ; for ( string propertieskey : getallkeysfromproperties ( properties ) ) { addfieldstojsonobject ( properties , coreobjectjsontype , propertieskey ) ; } return prettifyofjson ( coreobjectjsontype . tostringjson ( ) ) ; }	generate Json by given Map&lt;String,Object&gt;.
public string convertfromvaluesasobjectmap ( map < string , object > properties , string ... includedomainkeys ) throws parsepropertiesexception { map < string , object > filteredproperties = new hashmap < > ( ) ; for ( string key : properties . keyset ( ) ) { for ( string requiredkey : includedomainkeys ) { checkkey ( properties , filteredproperties , key , requiredkey ) ; } } return convertfromvaluesasobjectmap ( filteredproperties ) ; }	generate Json by given Map&lt;String,String&gt; and given filter.
public string converttojson ( properties properties , string ... includedomainkeys ) throws parsepropertiesexception { return convertfromvaluesasobjectmap ( propertiestomap ( properties ) , includedomainkeys ) ; }	generate Json by given Java Properties and given filter.
protected static int getshadowradius ( drawable shadow , drawable circle ) { int radius = num_ ; if ( shadow != null && circle != null ) { rect rect = new rect ( ) ; radius = ( circle . getintrinsicwidth ( ) + ( shadow . getpadding ( rect ) ? rect . left + rect . right : num_ ) ) / num_ ; } return math . max ( num_ , radius ) ; }	Calculates required radius of shadow.
public static builder < ocspfetcher > builder ( ) { return new builder < > ( new buildhandler < ocspfetcher > ( ) { @ override public ocspfetcher build ( properties properties ) { return new apacheocspfetcher ( properties ) ; } } ) ; }	Builder to create an instance of OcspFetcher using Apache HttpClient for connectivity.
protected x509certificate findintermediate ( x509certificate certificate ) throws ocspexception { for ( x509certificate issuer : properties . get ( intermediates ) ) if ( issuer . getsubjectx500principal ( ) . equals ( certificate . getissuerx500principal ( ) ) ) return issuer ; throw new ocspexception ( str_ , certificate . getissuerx500principal ( ) . getname ( ) ) ; }	Method for finding issuer by provided issuers in properties given an issued certificate.
@ override public void execute ( ) throws mojoexecutionexception {	Execute the maven plugin.
@ suppresswarnings ( str_ ) private boolean preprocessmarkdownfiles ( file inputdirectory ) throws mojoexecutionexception { getlog ( ) . debug ( str_ + inputdirectory ) ; try { if ( ! inputdirectory . exists ( ) ) { getlog ( ) . info ( str_ ) ; return bool_ ; } int basedepth = stringutils . countmatches ( inputdirectory . getabsolutepath ( ) , file . separator ) ;	Read Markdown files from directory.
private string substitutevariables ( string template , string patternstring , map < string , string > variables ) { pattern pattern = pattern . compile ( patternstring ) ; matcher matcher = pattern . matcher ( template ) ; stringbuffer buffer = new stringbuffer ( ) ; while ( matcher . find ( ) ) { if ( variables . containskey ( matcher . group ( num_ ) ) ) { string replacement = variables . get ( matcher . group ( num_ ) ) ;	Replace variables with given pattern.
private string gettitle ( list < string > raw ) { if ( raw == null ) { return defaulttitle ; } string previousline = str_ ; for ( string line : raw ) { line = line . trim ( ) ; if ( line . startswith ( str_ ) ) { line = line . replace ( str_ , str_ ) ; return line ; }	Get the first h1 for the title.
private string addtitletohtmlfile ( string html , string title ) { if ( html == null ) { return html ; } if ( title != null ) { getlog ( ) . debug ( str_ + title ) ; return html . replacefirst ( str_ , title ) ; } else { getlog ( ) . debug ( str_ ) ; return html . replacefirst ( str_ , str_ ) ; } }	Adds the title to the html file.
private string replacevariables ( string initialcontent , map < string , string > variables ) { string newcontent = initialcontent ;	Replace variables in the html file.
private string updaterelativepaths ( string html , int folderdepth ) { if ( html == null ) { return html ; } getlog ( ) . debug ( str_ ) ; return html . replaceall ( str_ , getsitebaseprefix ( folderdepth ) ) ; }	Update relative include paths corresponding to the markdown file's location in the folder structure.
private void copyfiles ( string fromdir , string todir ) throws mojoexecutionexception { getlog ( ) . debug ( str_ + fromdir + str_ + todir ) ; try { file fromdirfile = new file ( fromdir ) ; if ( fromdirfile . exists ( ) ) { iterator < file > files = fileutils . iteratefiles ( new file ( fromdir ) , null , bool_ ) ; while ( files . hasnext ( ) ) { file file = files . next ( ) ; if ( file . exists ( ) ) { fileutils . copyfiletodirectory ( file , new file ( todir ) ) ; } else { getlog ( ) . error ( str_ + file . getabsolutepath ( ) + str_ ) ; } } } } catch ( ioexception e ) { throw new mojoexecutionexception ( str_ + e . getmessage ( ) , e ) ; } }	Copy files from one dir to another based on file extensions.
protected string checkpath ( string path ) { if ( path . tolowercase ( ) . contains ( str_ ) && path . tolowercase ( ) . contains ( str_ ) ) { int pathlength = this . _host . getpath ( ) . length ( ) ; return path . substring ( pathlength , path . length ( ) ) ; } return path ; }	When retrieving 'more' statements, LRS will return full path..the client will have part in the URI already so cut that off.
private view wrapslidercontent ( view child , int index ) {	this will wrap the view which is added to the slider into another layout so we can then overlap the small and large view.
public void fadeup ( int duration ) {	animate to the large view.
public void fadedown ( int duration ) {	animate to the small view.
private float calculatepercentage ( int width ) { int absolute = mmaxwidth - mminwidth ; int current = width - mminwidth ; float percentage = num_ * current / absolute ;	calculate the percentage to how many percent the slide is already visible.
private void overlapviews ( int width ) { if ( width == mwidth ) { return ; }	overlap the views and provide the crossfade effect.
protected < t extends activity > intent getlaunchintent ( string targetpackage , class < t > activityclass , bundlecreator bundlecreator ) { intent intent = new intent ( intent . action_main ) ; intent . setclassname ( targetpackage , activityclass . getname ( ) ) ; intent . putextras ( bundlecreator . createbundle ( ) ) ; intent . addflags ( intent . flag_activity_new_task ) ; return intent ; }	The intent to launch the Activity.
@ suppresswarnings ( str_ ) private void launchactivity ( ) { if ( activity != null && activityrunmode . specification . equals ( activityrunmode ) ) return ; string targetpackage = instrumentation . gettargetcontext ( ) . getpackagename ( ) ; intent intent = getlaunchintent ( targetpackage , activityclass , bundlecreator ) ; activity = instrumentation . startactivitysync ( intent ) ; instrumentation . waitforidlesync ( ) ; }	Launch the activity if needed.
public factsheetlistresponse getfactsheets ( string type , string relationtypes , integer pagesize , string cursor , boolean permissions ) throws apiexception { object localvarpostbody = null ;	getFactSheetsRetrieves all Fact Sheets.
public file downloadfilefromresponse ( response response ) throws apiexception { try { file file = preparedownloadfile ( response ) ; files . copy ( response . readentity ( inputstream . class ) , file . topath ( ) ) ; return file ; } catch ( ioexception e ) { throw new apiexception ( e ) ; } }	Download file from the given response.
private client buildhttpclient ( boolean debugging ) { final clientconfig clientconfig = new clientconfig ( ) ; clientconfig . register ( multipartfeature . class ) ; clientconfig . register ( json ) ; clientconfig . register ( jacksonfeature . class ) ; if ( debugging ) { clientconfig . register ( loggingfilter . class ) ; } return clientbuilder . newclient ( clientconfig ) ; }	Build the Client used to make HTTP requests.
public accesscontrolentityresponse createaccesscontrolentity ( accesscontrolentity body ) throws apiexception { object localvarpostbody = body ;	createAccessControlEntityCreates an access control entity.
public datamodelupdateresponse updatedatamodel ( datamodel body , boolean force , string workspaceid ) throws apiexception { object localvarpostbody = body ;	updateDataModelUpdates the data model for a workspace.
public jobresponse createfullexport ( string exporttype , string startdate , string enddate ) throws apiexception { object localvarpostbody = null ;	createFullExportCreates a full export of the workspace data, or an export of the changelog, depending on given type.
public apiclientbuilder withtokenproviderhost ( string host ) { withoauth2tokenurl ( uri . create ( string . format ( str_ , host ) ) ) ; return this ; }	Specifies all urls needed to get an access token based on given host name and common url naming convention.
public apiclientbuilder withclientcredentials ( string clientid , string clientsecret ) { this . clientid = clientid ; this . clientsecret = clientsecret ; return this ; }	Sets your client Id and client Secret.
public graphqlresult processgraphqlmultipart ( string graphqlrequest , file file ) throws apiexception { object localvarpostbody = null ;	processGraphQLMultipartProcesses GraphQL requests, supporting multipart documents.
public bookmarklistresponse getbookmarks ( string bookmarktype , string groupkey , string sharingtype ) throws apiexception { object localvarpostbody = null ;	getBookmarksRetrieves all stored bookmarks a user can read.
public void addpermissions ( node graphname , graphpermissions permissions ) { checkisopen ( ) ; client . mergegraphpermissions ( graphname . geturi ( ) , permissions ) ; }	Adds permissions to a graph.
public void writepermissions ( node graphname , graphpermissions permissions ) { checkisopen ( ) ; client . writegraphpermissions ( graphname . geturi ( ) , permissions ) ; }	Sets the permissions on a graph.
public marklogicdatasetgraph withrulesets ( sparqlruleset ... rulesets ) { if ( this . rulesets == null ) { this . rulesets = rulesets ; } else { collection < sparqlruleset > collection = new arraylist < sparqlruleset > ( ) ; collection . addall ( arrays . aslist ( this . rulesets ) ) ; collection . addall ( arrays . aslist ( rulesets ) ) ; this . rulesets = collection . toarray ( new sparqlruleset [ ] { } ) ; } return this ; }	Fluent setter for rulesets.
public void close ( ) { if ( writebuffer != null ) { writebuffer . cancel ( ) ; } if ( timer != null ) { timer . cancel ( ) ; } client = null ; }	Close the connection and free resources.
public synchronized inputstreamhandle executeselect ( sparqlquerydefinition qdef , inputstreamhandle handle , long offset , long limit ) { if ( limit == null ) { this . sparqlquerymanager . clearpagelength ( ) ; } else { this . sparqlquerymanager . setpagelength ( limit ) ; } if ( offset != null ) { return this . sparqlquerymanager . executeselect ( qdef , handle , offset , currenttransaction ) ; } else { return this . sparqlquerymanager . executeselect ( qdef , handle , currenttransaction ) ; } }	synchronization needed because of setting of page length.
static public marklogicdatasetgraph createdatasetgraph ( string host , int port , string user , string password , authentication type ) { databaseclient client = databaseclientfactory . newclient ( host , port , user , password , type ) ; return marklogicdatasetgraphfactory . createdatasetgraph ( client ) ; }	Creates MarkLogicDatasetGraph from access parameters to a REST MarkLogicserver.
public gmoperation limitthreads ( final int threadsperprocess ) { final list < string > args = getcmdargs ( ) ; args . add ( str_ ) ; args . add ( str_ ) ; args . add ( integer . tostring ( threadsperprocess ) ) ; return this ; }	Limits the number of threads used by the GraphicsMagick process during execution.
public gmoperation resize ( final int width , final int height , final collection < geometryannotation > annotations ) { final list < string > args = getcmdargs ( ) ; args . add ( str_ ) ; args . add ( resample ( width , height , annotations ) ) ; return this ; }	Resize source to desired target dimensions, using default resizing filter algorithm.
public gmoperation rotate ( final double degrees , final rotationannotation annotation ) { if ( annotation == null ) { throw new illegalargumentexception ( str_ ) ; } final list < string > args = getcmdargs ( ) ; args . add ( str_ ) ; args . add ( string . format ( locale . english , str_ , degrees , annotation . asannotation ( ) ) ) ; return this ; }	Rotates the image, with empty triangles back-filled using default background color.
public gmoperation gravity ( final gravity value ) { if ( value == null ) { throw new illegalargumentexception ( str_ ) ; } gravity ( value . tostring ( ) ) ; return this ; }	Defines the gravity for geometry-based operations.
public gmoperation stripprofiles ( ) { final list < string > args = getcmdargs ( ) ; args . add ( str_ ) ; args . add ( str_ ) ; return this ; }	Strips out ICC profiles.
public gmoperation font ( final string style , final int size , final string color ) { if ( isblank ( style ) ) { throw new illegalargumentexception ( str_ ) ; } if ( isblank ( color ) ) { throw new illegalargumentexception ( str_ ) ; } font ( style ) ; pointsize ( size ) ; fill ( color ) ; return this ; }	Defines font for text overlay.
public gmoperation source ( final file file , @ checkfornull final integer width , @ checkfornull final integer height ) throws ioexception { if ( file != null && ! file . exists ( ) ) { throw new ioexception ( str_ + file + str_ ) ; } if ( ( width != null ) && ( height != null ) && ( width > num_ ) && ( height > num_ ) ) { size ( width , height ) ; } return addimage ( file ) ; }	Specifies the source image to convert.
public gmoperation addimage ( final file file ) { if ( file == null ) { throw new illegalargumentexception ( str_ ) ; } getcmdargs ( ) . add ( file . getpath ( ) ) ; return this ; }	Add image to operation.
public static list < string > parse ( object target , string [ ] args ) { list < string > arguments = new arraylist < string > ( ) ; arguments . addall ( arrays . aslist ( args ) ) ; class < ? > clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . getclass ( ) ; try { beaninfo info = introspector . getbeaninfo ( clazz ) ; for ( propertydescriptor pd : info . getpropertydescriptors ( ) ) { processproperty ( target , pd , arguments ) ; } } catch ( introspectionexception e ) {	Parse a set of arguments and populate the target with the appropriate values.
public static void usage ( printstream errstream , object target ) { class < ? > clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . getclass ( ) ; } errstream . println ( str_ + clazz . getname ( ) ) ; for ( class < ? > currentclazz = clazz ; currentclazz != null ; currentclazz = currentclazz . getsuperclass ( ) ) { for ( field field : currentclazz . getdeclaredfields ( ) ) { fieldusage ( errstream , target , field ) ; } } try { beaninfo info = introspector . getbeaninfo ( clazz ) ; for ( propertydescriptor pd : info . getpropertydescriptors ( ) ) { propertyusage ( errstream , target , pd ) ; } } catch ( introspectionexception e ) {	Generate usage information based on the target annotations.
public static timeunit extracttimeunitfromstring ( string timestring ) { timestring = timestring . tolowercase ( ) ; if ( timestring . contains ( str_ ) ) { return timeunit . minutes ; } else if ( timestring . contains ( str_ ) ) { return timeunit . microseconds ; } else if ( timestring . contains ( str_ ) ) { return timeunit . milliseconds ; } else if ( timestring . contains ( str_ ) ) { return timeunit . seconds ; } else if ( timestring . contains ( str_ ) ) { return timeunit . hours ; } else if ( timestring . tolowercase ( ) . contains ( str_ ) ) { return timeunit . days ; } else return null ; }	Extracts and returns the time unit from a string.
public static void parse ( object target , properties arguments ) { class clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . getclass ( ) ; } for ( field field : clazz . getdeclaredfields ( ) ) { processfield ( target , field , arguments ) ; } try { beaninfo info = introspector . getbeaninfo ( clazz ) ; for ( propertydescriptor pd : info . getpropertydescriptors ( ) ) { processproperty ( target , pd , arguments ) ; } } catch ( introspectionexception e ) {	Parse properties instead of String arguments.
static public void execute ( url url ) throws slideexecutionexception { checknotnull ( url ) ; screenregion screenregion = new desktopscreenregion ( ) ; context context = new context ( screenregion ) ; execute ( url , context ) ; }	Execute a presentation file at a given url.
static public void execute ( file file ) throws slideexecutionexception { checknotnull ( file ) ; try { execute ( file . touri ( ) . tourl ( ) ) ; } catch ( malformedurlexception e ) { throw new slideexecutionexception ( e ) ; } }	Execute a presentation file.
public static list < action > interpret ( file file ) throws ioexception { checknotnull ( file ) ; interpreter interpreter = new defaultinterpreter ( ) ; slidesreader reader = new pptxslidesreader ( ) ; list < slide > slides ; slides = reader . read ( file ) ; list < action > actions = lists . newarraylist ( ) ; for ( slide slide : slides ) { action action = interpreter . interpret ( slide ) ; actions . add ( action ) ; logger . info ( str_ , action ) ; } return actions ; }	Interpret a presentation file as a list of executable actions.
static public list < rectangle > sortbysize ( list < rectangle > list ) { list < rectangle > result = lists . newarraylist ( ) ; collections . sort ( list , new comparator < rectangle > ( ) { @ override public int compare ( rectangle r1 , rectangle r2 ) { return ( r1 . height * r1 . width ) - ( r2 . height * r2 . width ) ; } } ) ; return result ; }	sort a list of rectangles by their sizes in ascending order.
public string render ( string templatetext ) { checknotnull ( templatetext ) ; st st = new st ( templatetext ) ; for ( map . entry < string , object > e : parameters . entryset ( ) ) { st . add ( e . getkey ( ) , e . getvalue ( ) ) ; } return st . render ( ) ; }	Render the given template string as a string based on the parameter valuesassociated with this context.
file getslidexmlrel ( int slidenumber ) { string filename = string . format ( str_ , slidenumber ) ; return new file ( getrelationshipsdirectory ( ) , filename ) ; }	Get the file of the slide rel for a slide number.
protected boolean inrange ( nativemouseevent e ) { rectangle r = screenregion . getbounds ( ) ; r . x += screenoffsetx ; r . y += screenoffsety ; int x = e . getx ( ) ; int y = e . gety ( ) ; return r . contains ( x , y ) ; }	Check the mouse action is within the screen region range.
public selector overlapverticallywith ( final slideelement element , final float minoverlapratio ) { checknotnull ( element ) ; final rectangle r1 = element . getbounds ( ) ; r1 . x = num_ ; r1 . width = num_ ; elements = collections2 . filter ( elements , new predicate < slideelement > ( ) { @ override public boolean apply ( slideelement e ) { if ( e == element ) { return bool_ ; } if ( r1 . height == num_ ) { return bool_ ; } rectangle r2 = e . getbounds ( ) ; r2 . x = num_ ; r2 . width = num_ ; rectangle intersection = r1 . intersection ( r2 ) ; float yoverlapratio = num_ * intersection . height / r1 . height ; return yoverlapratio > minoverlapratio ; } } ) ; return this ; }	namely, if they have the same x range, they would intersect.
public object executeoutboundoperation ( final message < ? > message ) { try { string serializedmessage = messagemarshaller . serialize ( message ) ; if ( queue == null ) { sendmessagerequest request = new sendmessagerequest ( queueurl , serializedmessage ) ; sendmessageresult result = sqsclient . sendmessage ( request ) ; log . debug ( str_ + result . getmessageid ( ) ) ; } else { queue . add ( serializedmessage ) ; } } catch ( messagemarshallerexception e ) { log . error ( e . getmessage ( ) , e ) ; throw new messagingexception ( e . getmessage ( ) , e . getcause ( ) ) ; } return message . getpayload ( ) ; }	Executes the outbound Sqs Operation.
public object executeoutboundoperation ( final message < ? > message ) { try { string serializedmessage = messagemarshaller . serialize ( message ) ; if ( snstestproxy == null ) { publishrequest request = new publishrequest ( ) ; publishresult result = client . publish ( request . withtopicarn ( topicarn ) . withmessage ( serializedmessage ) ) ; log . debug ( str_ + result . getmessageid ( ) ) ; } else { snstestproxy . dispatchmessage ( serializedmessage ) ; } } catch ( messagemarshallerexception e ) { log . error ( e . getmessage ( ) , e ) ; throw new messagingexception ( e . getmessage ( ) , e . getcause ( ) ) ; } return message . getpayload ( ) ; }	Executes the outbound Sns Operation.
synchronized static public file requirefile ( string name , options options ) throws ioexception { file file = findfile ( name , options ) ; if ( file == null ) { throw new resourcenotfoundexception ( str_ + name + str_ ) ; } return file ; }	Same as findFile but throws an exception if the file was not found.
static private file getorcreatetempdirectory ( boolean deleteonexit ) throws extractexception {	Attempts to create a temporary directory that did not exist previously.
public static logvaluemap of ( final string k1 , final object v1 ) { return builder ( ) . put ( k1 , v1 ) . build ( ) ; }	Construct an immutable map from one key-value pair.
public void trace ( @ nullable final string message ) { log ( loglevel . trace , default_event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message at the trace level.
public void trace ( @ nullable final string event , @ nullable final string message ) { log ( loglevel . trace , event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message for a canonical event at the trace level.
public void debug ( @ nullable final string message ) { log ( loglevel . debug , default_event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message at the debug level.
public void debug ( @ nullable final string event , @ nullable final string message ) { log ( loglevel . debug , event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message for a canonical event at the debug level.
public void info ( @ nullable final string message ) { log ( loglevel . info , default_event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message at the info level.
public void info ( @ nullable final string event , @ nullable final string message ) { log ( loglevel . info , event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message for a canonical event at the info level.
public void info ( @ nullable final string event , @ nullable final string message , @ nullable final string datakey1 , @ nullable final string datakey2 , @ nullable final object datavalue1 , @ nullable final object datavalue2 ) { info ( event , message , datakey1 , datakey2 , datavalue1 , datavalue2 , default_throwable ) ; }	Log a message for a canonical event with supporting key-value pairs atthe info level.
public void warn ( @ nullable final string message ) { log ( loglevel . warn , default_event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message at the warn level.
public void warn ( @ nullable final string event , @ nullable final string message ) { log ( loglevel . warn , event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message for a canonical event at the warn level.
public void error ( @ nullable final string message ) { log ( loglevel . error , default_event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message at the error level.
public void error ( @ nullable final string event , @ nullable final string message ) { log ( loglevel . error , event , message , empty_string_array , empty_object_array , default_throwable ) ; }	Log a message for a canonical event at the error level.
@ before ( str_ ) public void addtocontextlineandmethod ( final joinpoint joinpoint ) { final sourcelocation sourcelocation = joinpoint . getsourcelocation ( ) ; final logbuilder targetlogbuilder = ( logbuilder ) joinpoint . gettarget ( ) ; targetlogbuilder . addcontext ( str_ , string . valueof ( sourcelocation . getline ( ) ) ) ; targetlogbuilder . addcontext ( str_ , sourcelocation . getfilename ( ) ) ; targetlogbuilder . addcontext ( str_ , sourcelocation . getwithintype ( ) ) ; }	Before outputting the message inject additional context.
public static void startstenowrapper ( final iloggingevent event , final string eventname , final jsongenerator jsongenerator , final objectmapper objectmapper ) throws ioexception { final stenoserializationhelper . stenolevel level = stenoserializationhelper . stenolevel . findbylogbacklevel ( event . getlevel ( ) ) ; jsongenerator . writestartobject ( ) ; jsongenerator . writeobjectfield ( str_ , iso_date_time_formatter . format ( instant . ofepochmilli ( event . gettimestamp ( ) ) ) ) ; jsongenerator . writeobjectfield ( str_ , eventname ) ; jsongenerator . writeobjectfield ( str_ , level . name ( ) ) ; }	Start writing the Steno JSON wrapper.
public static void writekeyvaluepairs ( @ nullable final list < string > keys , @ nullable final list < object > values , final jsongenerator jsongenerator , final objectmapper objectmapper , final stenoencoder encoder ) throws ioexception { if ( keys != null ) { final int contextvalueslength = values == null ? num_ : values . size ( ) ; for ( int i = num_ ; i < keys . size ( ) ; ++ i ) { final string key = keys . get ( i ) ; if ( i >= contextvalueslength ) { jsongenerator . writeobjectfield ( key , null ) ; } else { final object value = values . get ( i ) ; if ( issimpletype ( value ) ) { jsongenerator . writeobjectfield ( key , value ) ; } else { jsongenerator . writefieldname ( key ) ; objectmapper . writevalue ( jsongenerator , value ) ; } } } } }	Write specified key-value pairs into the current block.
public static void serializethrowable ( final ithrowableproxy throwableproxy , final jsongenerator jsongenerator , final objectmapper objectmapper ) throws ioexception { jsongenerator . writestringfield ( str_ , throwableproxy . getclassname ( ) ) ; jsongenerator . writestringfield ( str_ , throwableproxy . getmessage ( ) ) ; jsongenerator . writearrayfieldstart ( str_ ) ; for ( final stacktraceelementproxy ste : throwableproxy . getstacktraceelementproxyarray ( ) ) { jsongenerator . writestring ( ste . tostring ( ) ) ; } jsongenerator . writeendarray ( ) ; jsongenerator . writeobjectfieldstart ( str_ ) ; if ( throwableproxy instanceof throwableproxy ) { final jsonnode jsonnode = objectmapper . valuetotree ( ( ( throwableproxy ) throwableproxy ) . getthrowable ( ) ) ; for ( final iterator < map . entry < string , jsonnode > > iterator = jsonnode . fields ( ) ; iterator . hasnext ( ) ; ) { final map . entry < string , jsonnode > field = iterator . next ( ) ; jsongenerator . writefieldname ( field . getkey ( ) ) ; objectmapper . writevalue ( jsongenerator , field . getvalue ( ) ) ; } }	This function assumes the field object has already been started for this throwable, this only fills inthe fields in the 'exception' or equivalent object and does not create the field in the containing object.
@ logvalue public object tologvalue ( ) { return logvaluemapfactory . < string , object > builder ( ) . put ( str_ , _logbuilder ) . put ( str_ , _duration ) . put ( str_ , _lastlogtime ) . put ( str_ , _skipped ) . build ( ) ; }	Generate a Steno log compatible representation.
protected stacktraceelement getcallerdata ( final iloggingevent loggingevent ) { final stacktraceelement [ ] callerdata = loggingevent . getcallerdata ( ) ; if ( callerdata != null ) { for ( int i = num_ ; i < callerdata . length ; ++ i ) { final string callerclassname = callerdata [ i ] . getclassname ( ) ; if ( ! callerclassname . startswith ( steno_class_name_prefix ) ) { return callerdata [ i ] ; } } } return null ; }	Retrieve the relevant caller data adjusted for Steno logger wrapping.
public void createdatabase ( string databasename ) throws texception { hivemetastoreclient client = new hivemetastoreclient ( conf ( ) ) ; string databasefolder = new file ( temporaryfolder . getroot ( ) , databasename ) . touri ( ) . tostring ( ) ; try { client . createdatabase ( new database ( databasename , null , databasefolder , null ) ) ; } finally { client . close ( ) ; } }	Create a new database with the specified name.
protected void checkmappings ( int arrayposition ) { final int index = positions . indexofvalue ( arrayposition ) ; if ( index >= num_ ) { positions . removeat ( index ) ; } }	we should clear it.
public static string parsesaveattr ( final cell cell , final map < string , string > savecommentsmap ) { if ( cell != null ) { string key = cell . getsheet ( ) . getsheetname ( ) + str_ + cellutility . getcellindexnumberkey ( cell . getcolumnindex ( ) , cell . getrowindex ( ) ) ; string saveattr = null ; if ( savecommentsmap != null ) { saveattr = parserutility . getstringbetweenbracket ( savecommentsmap . get ( key ) ) ; } if ( ( saveattr == null ) && ( cell . getcelltypeenum ( ) == celltype . string ) ) { saveattr = saveattrsutility . parsesaveattrstring ( cell . getstringcellvalue ( ) ) ; } if ( ( saveattr != null ) && ( ! saveattr . isempty ( ) ) ) { return tieconstants . cell_addr_pre_fix + cell . getcolumnindex ( ) + str_ + saveattr + str_ ; } } return str_ ; }	Parses the save attr.
public static void savedatatoobjectincontext ( final map < string , object > context , final string saveattr , final string strvalue , final expressionengine engine ) { int index = saveattr . lastindexof ( str_ ) ; if ( index > num_ ) { string strobject = saveattr . substring ( num_ , index ) ; string strmethod = saveattr . substring ( index + num_ ) ; strobject = tieconstants . method_prefix + strobject + tieconstants . method_end ; object object = commandutility . evaluate ( strobject , context , engine ) ; cellcontrolsutility . setobjectproperty ( object , strmethod , strvalue , bool_ ) ; } }	Save data to object in context.
public static void refreshsheetrowfromcontext ( final map < string , object > context , final string fullsaveattr , final row row , final expressionengine engine ) { if ( ! fullsaveattr . startswith ( tieconstants . cell_addr_pre_fix ) ) { return ; } int ipos = fullsaveattr . indexof ( str_ ) ; if ( ipos > num_ ) { string columnindex = fullsaveattr . substring ( num_ , ipos ) ; string saveattr = fullsaveattr . substring ( ipos + num_ ) ; cell cell = row . getcell ( integer . parseint ( columnindex ) ) ; if ( cell . getcelltypeenum ( ) != celltype . formula ) { commandutility . evaluatenormalcells ( cell , tieconstants . method_prefix + saveattr + tieconstants . method_end , context , engine ) ; } } }	reload the data from context to websheet row.
public static string parsesaveattrstring ( final string strvalue ) { if ( strvalue != null ) { int first = strvalue . indexof ( tieconstants . method_prefix ) ; int last = strvalue . lastindexof ( tieconstants . method_prefix ) ; int end = strvalue . lastindexof ( tieconstants . method_end ) ; if ( ( first >= num_ ) && ( first == last ) && ( end > num_ ) ) { return strvalue . substring ( first + num_ , end ) ; } } return str_ ; }	Parses the save attr string.
public static string getsaveattrlistfromrow ( final row row ) { if ( row != null ) { cell cell = row . getcell ( tieconstants . hidden_save_objects_column ) ; if ( cell != null ) { string str = cell . getstringcellvalue ( ) ; if ( ( str != null ) && ( ! str . isempty ( ) ) ) { return str ; } } } return null ; }	Gets the save attr list from row.
public static string getsaveattrfromlist ( final int columnindex , final string saveattrs ) { if ( ( saveattrs != null ) && ( ! saveattrs . isempty ( ) ) ) { string str = tieconstants . cell_addr_pre_fix + columnindex + str_ ; int istart = saveattrs . indexof ( str ) ; if ( istart >= num_ ) { int iend = saveattrs . indexof ( str_ , istart ) ; if ( iend > istart ) { return saveattrs . substring ( istart + str . length ( ) , iend ) ; } } } return null ; }	Gets the save attr from list.
public static void setsaveobjectsinhiddencolumn ( final row row , final string saveattr ) { cell cell = row . getcell ( tieconstants . hidden_save_objects_column , missingcellpolicy . create_null_as_blank ) ; cell . setcellvalue ( saveattr ) ; }	Sets the save objects in hidden column.
public static void setsaveattrsforsheet ( final sheet sheet , final int minrownum , final int maxrownum , final map < string , string > savecommentsmap ) { for ( row row : sheet ) { int rowindex = row . getrownum ( ) ; if ( ( rowindex >= minrownum ) && ( rowindex <= maxrownum ) ) { setsaveattrsforrow ( row , savecommentsmap ) ; } } }	Sets the save attrs for sheet.
public static void setsaveattrsforrow ( final row row , final map < string , string > savecommentsmap ) { stringbuilder saveattr = new stringbuilder ( ) ; for ( cell cell : row ) { string sattr = parsesaveattr ( cell , savecommentsmap ) ; if ( ! sattr . isempty ( ) ) { saveattr . append ( sattr ) ; } } if ( saveattr . length ( ) > num_ ) { saveattrsutility . setsaveobjectsinhiddencolumn ( row , saveattr . tostring ( ) ) ; } }	Sets the save attrs for row.
public static string preparecontextandattrsforcell ( cell poicell , string fullname , cellhelper cellhelper ) { if ( fullname == null ) { return null ; } string saveattrlist = saveattrsutility . getsaveattrlistfromrow ( poicell . getrow ( ) ) ; if ( saveattrlist != null ) { string saveattr = saveattrsutility . getsaveattrfromlist ( poicell . getcolumnindex ( ) , saveattrlist ) ; if ( saveattr != null ) { cellhelper . restoredatacontext ( fullname ) ; return saveattr ; } } return null ; }	Prepare context and attrs for cell.
private string fmtnumber ( final double d ) { if ( double . compare ( d % num_ , num_ ) == num_ ) { return string . format ( str_ , ( int ) d ) ; } else { return string . format ( str_ , d ) ; } }	Fmt number.
public final void putshiftattrs ( final string fullname , final configrangeattrs attrs , final rowsmapping unitrowsmapping ) { attrs . setunitrowsmapping ( unitrowsmapping ) ; this . shiftmap . put ( fullname , attrs ) ; }	Put shift attrs.
public void setwb ( final workbook pwb ) { this . getserialwb ( ) . setwb ( pwb ) ; this . wbwrapper = xssfevaluationworkbook . create ( ( xssfworkbook ) pwb ) ; }	Set up workbook. Also create evaluation wrapper.
public xssfevaluationworkbook getwbwrapper ( ) { if ( ( this . wbwrapper == null ) && ( this . getwb ( ) != null ) ) { this . wbwrapper = xssfevaluationworkbook . create ( ( xssfworkbook ) this . getwb ( ) ) ; } return wbwrapper ; }	Return evaluation wrapper if needed.
public formulaevaluator getformulaevaluator ( ) { if ( ( this . formulaevaluator == null ) && ( this . getwb ( ) != null ) ) { this . formulaevaluator = this . getwb ( ) . getcreationhelper ( ) . createformulaevaluator ( ) ; } return formulaevaluator ; }	get formulaevaluator.
public void recalcmaxcolcounts ( ) { if ( ( this . getsheetconfigmap ( ) == null ) || ( this . getsheetconfigmap ( ) . isempty ( ) ) ) { this . maxcolcounts = num_ ; return ; } int maxcolumns = num_ ; for ( sheetconfiguration sheetconfig : this . getsheetconfigmap ( ) . values ( ) ) { int counts = sheetconfig . getheadercellrange ( ) . getrightcol ( ) - sheetconfig . getheadercellrange ( ) . getleftcol ( ) + num_ ; if ( maxcolumns < counts ) { maxcolumns = counts ; } } this . maxcolcounts = maxcolumns ; }	recalculate max coulumn count across sheets in the workbook.
public int loadwebsheet ( final inputstream inputstream , final map < string , object > pdatacontext ) { return this . gethelper ( ) . getwebsheetloader ( ) . loadworkbook ( inputstream , pdatacontext ) ; }	load web sheet from inputStream file with data object.
public int loadwebsheet ( final workbook pwb , final map < string , object > pdatacontext ) { return this . gethelper ( ) . getwebsheetloader ( ) . loadworkbook ( pwb , pdatacontext ) ; }	load web sheet from giving workbook with data object.
public int loadworksheetbytabname ( final string tabname ) { try { int sheetid = this . gethelper ( ) . getwebsheetloader ( ) . findtabindexwithname ( tabname ) ; if ( ( getsheetconfigmap ( ) != null ) && ( sheetid < getsheetconfigmap ( ) . size ( ) ) ) { this . gethelper ( ) . getwebsheetloader ( ) . loadworksheet ( tabname ) ; setactivetabindex ( sheetid ) ; } return num_ ; } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getmessage ( ) , ex ) ; } return - num_ ; }	load worksheet by tab name.
public void doexport ( ) { try { string filename = this . getexportfilename ( ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; this . getwb ( ) . write ( out ) ; inputstream stream = new bufferedinputstream ( new bytearrayinputstream ( out . tobytearray ( ) ) ) ; exportfile = new defaultstreamedcontent ( stream , str_ , filename ) ; } catch ( exception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } return ; }	download current workbook.
public void dosave ( ) { this . setsubmitmde ( bool_ ) ; if ( ! this . gethelper ( ) . getvalidationhandler ( ) . prevalidation ( ) ) { log . fine ( str_ ) ; return ; } processsave ( ) ; this . gethelper ( ) . getwebsheetloader ( ) . setunsavedstatus ( requestcontext . getcurrentinstance ( ) , bool_ ) ; }	Save the current workbooks.
public void dosubmit ( ) { this . setsubmitmde ( bool_ ) ;	Submit the current workbooks.
public void populatecomponent ( final componentsystemevent event ) { uicomponent component = event . getcomponent ( ) ; int [ ] rowcol = cellutility . getrowcolfromcomponentattributes ( component ) ; int row = rowcol [ num_ ] ; int col = rowcol [ num_ ] ; facescell fcell = cellutility . getfacescellfrombodyrow ( row , col , this . getbodyrows ( ) , this . getcurrent ( ) . getcurrenttoprow ( ) , this . getcurrent ( ) . getcurrentleftcolumn ( ) ) ; cellcontrolsutility . populateattributes ( component , fcell , this . getcelldefaultcontrol ( ) ) ; }	populate component.
public sheetconfiguration getcurrentsheetconfig ( ) { string currenttabname = this . getcurrent ( ) . getcurrenttabname ( ) ; if ( currenttabname == null ) { return null ; } return this . getsheetconfigmap ( ) . get ( currenttabname ) ; }	Gets the current sheet config.
private void readobject ( final java . io . objectinputstream in ) throws ioexception { try { in . defaultreadobject ( ) ; recover ( ) ; } catch ( encrypteddocumentexception | classnotfoundexception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } }	load the bean from saving.
private locale getlocale ( final facescontext context , final uicomponent component ) { string localestr = ( string ) component . getattributes ( ) . get ( tieconstants . component_attr_locale ) ; if ( localestr == null ) { return context . getviewroot ( ) . getlocale ( ) ; } return locale . forlanguagetag ( localestr ) ; }	Gets the locale.
public streamedcontent getpicture ( ) { facescontext context = facescontext . getcurrentinstance ( ) ; if ( context . getcurrentphaseid ( ) == phaseid . render_response ) {	Return picture to web front end.
public final cellhelper getcellhelper ( ) { if ( ( this . cellhelper == null ) && ( this . parent != null ) ) { this . cellhelper = new cellhelper ( parent ) ; } return cellhelper ; }	Gets the cell helper.
public final pictureshelper getpichelper ( ) { if ( ( this . pichelper == null ) && ( this . parent != null ) ) { this . pichelper = new pictureshelper ( parent ) ; } return pichelper ; }	Gets the pic helper.
public final validationhandler getvalidationhandler ( ) { if ( ( this . validationhandler == null ) && ( this . parent != null ) ) { this . validationhandler = new validationhandler ( parent ) ; } return validationhandler ; }	Gets the validation handler.
public final charthelper getcharthelper ( ) { if ( ( this . charthelper == null ) && ( this . parent != null ) ) { this . charthelper = new charthelper ( parent ) ; } return charthelper ; }	Gets the chart helper.
public static ptg [ ] convertsharedformulas ( final ptg [ ] ptgs , final shiftformularef shiftformularef ) { list < ptg > newptglist = new arraylist < > ( ) ; object ptg ; for ( int k = num_ ; k < ptgs . length ; ++ k ) { ptg = ptgs [ k ] ; newptglist . addall ( arrays . aslist ( convertptg ( ptgs , k , shiftformularef , ptg ) ) ) ; } return newptglist . toarray ( new ptg [ newptglist . size ( ) ] ) ; }	Convert shared formulas.
private static ptg [ ] convertptg ( final ptg [ ] ptgs , final int position , final shiftformularef shiftformularef , final object ptg ) { byte originaloperandclass = - num_ ; if ( ! ( ( ptg ) ptg ) . isbasetoken ( ) ) { originaloperandclass = ( ( ptg ) ptg ) . getptgclass ( ) ; } int currentrow ; currentrow = getfirstsupportedrownumfromptg ( ptg ) ; if ( ( currentrow >= num_ ) && shiftformularef . getwatchlist ( ) . contains ( currentrow ) ) { return convertptgforwatchlist ( ptgs , position , shiftformularef , ptg , originaloperandclass , currentrow ) ; }	Convert ptg.
private static ptg [ ] convertptgforwatchlist ( final ptg [ ] ptgs , final int position , final shiftformularef shiftformularef , final object ptg , final byte originaloperandclass , final int currentrow ) { list < serialrow > rowlist = getrowslist ( currentrow , shiftformularef . getcurrentrowsmappinglist ( ) ) ; if ( ( rowlist == null ) || ( rowlist . isempty ( ) ) ) {	Convert ptg for watch list.
private static ptg [ ] singleptg ( final object ptg , final byte originaloperandclass , final int formulachanged ) { ptg [ ] newptg = new ptg [ num_ ] ; if ( originaloperandclass != ( - num_ ) ) { ( ( ptg ) ptg ) . setclass ( originaloperandclass ) ; } object ptgafter = ptg ; if ( ptg instanceof funcvarptg ) { funcvarptg fptg = ( funcvarptg ) ptg ; if ( ( formulachanged > num_ ) && ( fptg . getnumberofoperands ( ) != formulachanged ) ) { ptgafter = funcvarptg . create ( ( ( funcvarptg ) ptg ) . getname ( ) , formulachanged ) ; } } newptg [ num_ ] = ( ptg ) ptgafter ; return newptg ; }	Single ptg.
private static list < serialrow > getrowslist ( final int currentrow , final list < rowsmapping > currentrowsmappinglist ) { list < serialrow > all = null ; int size = currentrowsmappinglist . size ( ) ; for ( rowsmapping rowsmapping : currentrowsmappinglist ) { list < serialrow > current = rowsmapping . get ( currentrow ) ; if ( current != null ) { if ( size == num_ ) { return current ; } all = assemblerowslistfromrowsmapping ( all , current ) ; } } return all ; }	Gets the rows list.
private static list < serialrow > assemblerowslistfromrowsmapping ( final list < serialrow > all , final list < serialrow > current ) { list < serialrow > list ; if ( all == null ) { list = new arraylist < > ( ) ; list . addall ( current ) ; } else { list = all ; for ( serialrow row : current ) { if ( ! all . contains ( row ) ) { list . add ( row ) ; } } } return list ; }	assemble rowslist from rowsmapping.
private static void builddynamicrowforrefptgbase ( final object ptg , final byte originaloperandclass , final list < serialrow > rowlist , final ptg [ ] newptg , final boolean includeparenthesis ) { refptgbase refptg = ( refptgbase ) ptg ; int unitsize = num_ ; if ( includeparenthesis ) { unitsize = num_ ; } for ( int i = num_ ; i < rowlist . size ( ) ; i ++ ) { row row = rowlist . get ( i ) . getrow ( ) ; if ( refptg instanceof ref3dpxg ) { ref3dpxg ref3dpxg = ( ref3dpxg ) refptg ; ref3dpxg new3dpxg = new ref3dpxg ( ref3dpxg . getexternalworkbooknumber ( ) , new sheetidentifier ( null , new nameidentifier ( ref3dpxg . getsheetname ( ) , bool_ ) ) , new cellreference ( row . getrownum ( ) , ref3dpxg . getcolumn ( ) ) ) ; new3dpxg . setclass ( originaloperandclass ) ; new3dpxg . setcolrelative ( ref3dpxg . iscolrelative ( ) ) ; new3dpxg . setrowrelative ( ref3dpxg . isrowrelative ( ) ) ; new3dpxg . setlastsheetname ( ref3dpxg . getlastsheetname ( ) ) ; newptg [ i * unitsize ] = new3dpxg ; } else { refptgbase refptgbase = refptg ; newptg [ i * unitsize ] = new refptg ( row . getrownum ( ) , refptgbase . getcolumn ( ) , refptgbase . isrowrelative ( ) , refptgbase . iscolrelative ( ) ) ; } if ( ( unitsize == num_ ) && ( i < ( rowlist . size ( ) - num_ ) ) ) { newptg [ i * unitsize + num_ ] = parenthesisptg . instance ; } } }	Builds the dynamic row for ref ptg base.
public static xcolor getbgcolor ( final ctplotarea ctplot , final themestable themetable ) { ctsolidcolorfillproperties colorfill = null ; try { colorfill = ctplot . getsppr ( ) . getsolidfill ( ) ; } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } xcolor xcolor = findautomaticfillcolor ( themetable , colorfill ) ; if ( xcolor != null ) { return xcolor ; } else { return new xcolor ( new xssfcolor ( color . white ) ) ; } }	retrieve background color for plot area.
public static xcolor gecolorfromsppr ( final int index , final ctshapeproperties ctsppr , final themestable themetable , final boolean islinecolor ) { ctsolidcolorfillproperties colorfill = null ; try { if ( islinecolor ) { colorfill = ctsppr . getln ( ) . getsolidfill ( ) ; } else { colorfill = ctsppr . getsolidfill ( ) ; } } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } xcolor xcolor = findautomaticfillcolor ( themetable , colorfill ) ; if ( xcolor != null ) { return xcolor ; } else { return getxcolorwithautomaticfill ( index , themetable ) ; } }	get line color of line chart from CTLineSer.
private static xcolor findautomaticfillcolor ( final themestable themetable , final ctsolidcolorfillproperties colorfill ) {	Find automatic fill color.
private static xcolor getxcolorfromschemeclr ( final ctschemecolor ctscolor , final themestable themetable ) { if ( ctscolor . getval ( ) != null ) { return getxcolorwithschema ( ctscolor . getval ( ) . tostring ( ) , num_ , ctscolor , themetable ) ; } return null ; }	retrieve xcolor from scheme color.
private static xcolor getxcolorfromrgbclr ( final ctsrgbcolor ctrcolor ) { xssfcolor bcolor = null ; try { byte [ ] rgb = ctrcolor . getval ( ) ; bcolor = new xssfcolor ( rgb ) ; } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getlocalizedmessage ( ) , ex ) ; return null ; } int lumoff = num_ ; int lummod = num_ ; int alphastr = num_ ; try { lumoff = ctrcolor . getlumoffarray ( num_ ) . getval ( ) ; } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } try { lummod = ctrcolor . getlummodarray ( num_ ) . getval ( ) ; } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } try { alphastr = ctrcolor . getalphaarray ( num_ ) . getval ( ) ; } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } return assemblexcolor ( bcolor , num_ , lumoff , lummod , alphastr ) ; }	get xcolor from ctsRgbColor.
private static xcolor getxcolorwithautomaticfill ( final int index , final themestable themetable ) { int reminder = ( index + num_ ) % autocolorsize ; if ( reminder == num_ ) { reminder = autocolorsize ; } string schema = autocolorname + reminder ; double tint = getautomatictint ( index ) ; return getxcolorwithschema ( schema , tint , null , themetable ) ; }	Get xcolor for automatic fill setting.
public static color xssfclrtoclr ( final xssfcolor xssfcolor ) { short [ ] rgb = gettripletfromxssfcolor ( xssfcolor ) ; return new color ( rgb [ num_ ] , rgb [ num_ ] , rgb [ num_ ] ) ; }	convert xssf color to color.
public static short [ ] gettripletfromxssfcolor ( final xssfcolor xssfcolor ) { short [ ] rgbfix = { rgb8bits , rgb8bits , rgb8bits } ; if ( xssfcolor != null ) { byte [ ] rgb = xssfcolor . getrgbwithtint ( ) ; if ( rgb == null ) { rgb = xssfcolor . getrgb ( ) ; }	Convert xssfcolor to triple let numbers.
static string getbgcolorfromcell ( final workbook wb , final cell poicell , final cellstyle cellstyle ) { string style = str_ ; if ( poicell instanceof hssfcell ) { int bkcolorindex = cellstyle . getfillforegroundcolor ( ) ; hssfcolor color = hssfcolor . getindexhash ( ) . get ( bkcolorindex ) ; if ( color != null ) {	Gets the bg color from cell.
private static string findcomponentnamefromclass ( final uicomponent component ) { string cname = component . getclass ( ) . getsimplename ( ) ; if ( supportcomponents . contains ( cname ) ) { return cname ; } return null ; }	find component according it's class.
public static void populateattributes ( final uicomponent component , final facescell fcell , final map < string , map < string , string > > defaultcontrolmap ) { list < cellformattributes > inputattrs = fcell . getinputattrs ( ) ; string cname = findcomponentnamefromclass ( component ) ; if ( cname == null ) { return ; } map < string , string > defaultmap = defaultcontrolmap . get ( cname ) ; if ( defaultmap == null ) { defaultmap = new hashmap < > ( ) ; defaultcontrolmap . put ( cname , defaultmap ) ; } for ( map . entry < string , string > entry : defaultmap . entryset ( ) ) { setobjectproperty ( component , entry . getkey ( ) , entry . getvalue ( ) , bool_ ) ; } for ( cellformattributes attr : inputattrs ) { string propertyname = attr . gettype ( ) ; string propertyvalue = attr . getvalue ( ) ; if ( ! defaultmap . containskey ( propertyname ) ) { string defaultvalue = getobjectpropertyvalue ( component , propertyname , bool_ ) ; defaultmap . put ( propertyname , defaultvalue ) ; } setobjectproperty ( component , propertyname , propertyvalue , bool_ ) ; } }	populate attributes.
private static attributestype matchparameterofmethod ( final object obj , final string methodname ) { for ( attributestype attr : attributestype . values ( ) ) { try { obj . getclass ( ) . getmethod ( methodname , new class [ ] { attr . clazz } ) ; return attr ; } catch ( exception ex ) { log . log ( level . fine , str_ + ex . getlocalizedmessage ( ) , ex ) ; } } return null ; }	match parameter of method.
public static void setobjectproperty ( final object obj , final string propertyname , final string propertyvalue , final boolean ignorenonexisting ) { try { string methodname = str_ + character . touppercase ( propertyname . charat ( num_ ) ) + propertyname . substring ( num_ ) ; attributestype parametertype = matchparameterofmethod ( obj , methodname ) ; if ( parametertype != null ) { method method = obj . getclass ( ) . getmethod ( methodname , new class [ ] { parametertype . clazz } ) ; method . invoke ( obj , converttoobject ( parametertype , propertyvalue ) ) ; } } catch ( exception e ) { string msg = str_ + propertyname + str_ + propertyvalue + str_ + obj ; if ( ignorenonexisting ) { log . log ( level . fine , msg , e ) ; } else { log . warning ( msg ) ; throw new illegalargumentexception ( e ) ; } } }	set object property.
public static string getobjectpropertyvalue ( final object obj , final string propertyname , final boolean ignorenonexisting ) { try { method method = obj . getclass ( ) . getmethod ( str_ + character . touppercase ( propertyname . charat ( num_ ) ) + propertyname . substring ( num_ ) ) ; return ( string ) method . invoke ( obj ) ; } catch ( exception e ) { string msg = str_ + propertyname + str_ + obj ; if ( ignorenonexisting ) { log . log ( level . fine , msg , e ) ; } else { log . warning ( msg ) ; throw new illegalargumentexception ( e ) ; } } return null ; }	get object property value.
public static void setupcontrolattributes ( final int originrowindex , final facescell fcell , final cell poicell , final sheetconfiguration sheetconfig , final cellattributesmap cellattributesmap ) { int rowindex = originrowindex ; if ( rowindex < num_ ) { rowindex = poicell . getrowindex ( ) ; } string skey = poicell . getsheet ( ) . getsheetname ( ) + str_ + cellutility . getcellindexnumberkey ( poicell . getcolumnindex ( ) , rowindex ) ; map < string , string > commentmap = cellattributesmap . gettemplatecommentmap ( ) . get ( str_ ) ; if ( commentmap != null ) { string comment = commentmap . get ( skey ) ; if ( comment != null ) { commandutility . createcellcomment ( poicell , comment , sheetconfig . getfinalcommentmap ( ) ) ; } } string widgettype = cellattributesmap . getcellinputtype ( ) . get ( skey ) ; if ( widgettype != null ) { fcell . setcontrol ( widgettype . tolowercase ( ) ) ; fcell . setinputattrs ( cellattributesmap . getcellinputattributes ( ) . get ( skey ) ) ; fcell . setselectitemattrs ( cellattributesmap . getcellselectitemsattributes ( ) . get ( skey ) ) ; fcell . setdatepattern ( cellattributesmap . getcelldatepattern ( ) . get ( skey ) ) ; } }	Setup control attributes.
public static list < cellformattributes > findcellvalidateattributes ( final map < string , list < cellformattributes > > validatemaps , final int originrowindex , final cell cell ) { string key = cell . getsheet ( ) . getsheetname ( ) + str_ + cellutility . getcellindexnumberkey ( cell . getcolumnindex ( ) , originrowindex ) ; return validatemaps . get ( key ) ; }	Find cell validate attributes.
public final void setupfacescellpicturecharts ( final sheet sheet1 , final facescell fcell , final cell cell , final string fid ) { if ( parent . getpicturesmap ( ) != null ) { setupfacescellpicture ( sheet1 , fcell , cell , fid ) ; } if ( parent . getcharsdata ( ) . getchartsmap ( ) != null ) { setupfacescellcharts ( sheet1 , fcell , cell , fid ) ; } }	Setup faces cell picture charts.
private void setupfacescellcharts ( final sheet sheet1 , final facescell fcell , final cell cell , final string fid ) { try { string chartid = parent . getcharsdata ( ) . getchartpositionmap ( ) . get ( fid ) ; if ( chartid != null ) { bufferedimage img = parent . getcharsdata ( ) . getchartsmap ( ) . get ( chartid ) ; if ( img != null ) { fcell . setcontainchart ( bool_ ) ; fcell . setchartid ( chartid ) ; fcell . setchartstyle ( picturesutility . generatechartstyle ( sheet1 , fcell , cell , chartid , parent . getcharsdata ( ) . getchartanchorsmap ( ) ) ) ; } } } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getmessage ( ) , ex ) ; } }	Setup faces cell charts.
private void setupfacescellpicture ( final sheet sheet1 , final facescell fcell , final cell cell , final string fid ) { try { picture pic = parent . getpicturesmap ( ) . get ( fid ) ; if ( pic != null ) { fcell . setcontainpic ( bool_ ) ; fcell . setpictureid ( fid ) ; fcell . setpicturestyle ( picturesutility . generatepicturestyle ( sheet1 , fcell , cell , pic ) ) ; } } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getmessage ( ) , ex ) ; } }	Setup faces cell picture.
private void initchartsmap ( final workbook wb ) { try { if ( wb instanceof xssfworkbook ) { initxssfchartsmap ( ( xssfworkbook ) wb , parent . getcharsdata ( ) ) ; } } catch ( exception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } }	initial chart map for specified workbook.
private string getpietitle ( final chartdata chartdata ) { for ( chartseries chartseries : chartdata . getserieslist ( ) ) { if ( chartseries != null ) { return getparsedcellvalue ( chartseries . getserieslabel ( ) ) ; } } return str_ ; }	return pie chart title from chartData.
public final void setseriesstyle ( final jfreechart chart , final int seriesindex , final string style ) { if ( chart != null && style != null ) { basicstroke stroke = chartutility . tostroke ( style ) ; plot plot = chart . getplot ( ) ; if ( plot instanceof categoryplot ) { categoryplot categoryplot = chart . getcategoryplot ( ) ; categoryitemrenderer cir = categoryplot . getrenderer ( ) ; try { cir . setseriesstroke ( seriesindex , stroke ) ;	Set color of series.
public jfreechart createpie3dchart ( final chartdata chartdata ) {	create pie 3d chart.
private void setupbarstyle ( final jfreechart chart , final chartdata chartdata ) { setupstyle ( chart , chartdata ) ; categoryplot plot = ( categoryplot ) chart . getplot ( ) ; barrenderer renderer = ( barrenderer ) plot . getrenderer ( ) ; renderer . setbarpainter ( new standardbarpainter ( ) ) ; renderer . setitemmargin ( tieconstants . default_bar_style_item_margin ) ; plot . setforegroundalpha ( tieconstants . default_barstyle_foreground_alpha ) ; }	finalize the style for barchart.
private void initxssfchartsmap ( final xssfworkbook wb , final chartsdata chartsdata ) { initanchorsmap ( wb , chartsdata ) ; map < string , clientanchor > anchormap = chartsdata . getchartanchorsmap ( ) ; map < string , bufferedimage > chartmap = chartsdata . getchartsmap ( ) ; map < string , chartdata > chartdatamap = chartsdata . getchartdatamap ( ) ; chartmap . clear ( ) ; chartdatamap . clear ( ) ; for ( int i = num_ ; i < wb . getnumberofsheets ( ) ; i ++ ) { xssfsheet sheet = wb . getsheetat ( i ) ; xssfdrawing drawing = sheet . createdrawingpatriarch ( ) ; list < xssfchart > charts = drawing . getcharts ( ) ; if ( ( charts != null ) && ( ! charts . isempty ( ) ) ) { for ( xssfchart chart : charts ) { generatesinglexssfchart ( chart , getchartidfromparent ( chart , sheet . getsheetname ( ) ) , sheet , anchormap , chartmap , chartdatamap ) ; } } } }	initial chart map for XSSF format file.
private string getchartidfromparent ( final xssfchart chart , final string sheetname ) { if ( chart . getparent ( ) != null ) { for ( relationpart rp : chart . getparent ( ) . getrelationparts ( ) ) { if ( rp . getdocumentpart ( ) == chart ) { return sheetname + str_ + rp . getrelationship ( ) . getid ( ) ; } } } return null ; }	Gets the chart id from parent.
private void initanchorsmap ( final workbook wb , final chartsdata chartsdata ) { try { if ( wb instanceof xssfworkbook ) { chartutility . initxssfanchorsmap ( ( xssfworkbook ) wb , chartsdata ) ; } } catch ( exception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } }	initial anchors map for specified workbook.
private void generatesinglexssfchart ( final xssfchart chart , final string chartid , final xssfsheet sheet , final map < string , clientanchor > anchormap , final map < string , bufferedimage > chartmap , final map < string , chartdata > chartdatamap ) { clientanchor anchor ; try { anchor = anchormap . get ( chartid ) ; if ( anchor != null ) { chartdata chartdata = chartutility . initchartdatafromxssfchart ( chartid , chart , ( xssfworkbook ) parent . getwb ( ) ) ; chartdatamap . put ( chartid , chartdata ) ; jfreechart jchart = createchart ( chartdata ) ; if ( jchart != null ) { anchorsize anchorsize = picturesutility . getanchorsize ( sheet , null , null , anchor ) ; bufferedimage img = jchart . createbufferedimage ( anchorsize . getwidth ( ) , anchorsize . getheight ( ) ) ; chartmap . put ( chartid , img ) ; } } } catch ( exception ex ) { log . log ( level . severe , str_ + chartid + str_ + ex . getlocalizedmessage ( ) , ex ) ; } }	Generate single XSSF chart.
@ suppresswarnings ( str_ ) public static collection transformtocollectionobject ( final expressionengine engine , final string collectionname , final map < string , object > context ) { object collectionobject = engine . evaluate ( collectionname , context ) ; if ( ! ( collectionobject instanceof collection ) ) { throw new evaluationexception ( collectionname + str_ ) ; } return ( collection ) collectionobject ; }	Transform to collection object.
public static string getfullnamefromrow ( final row row ) { if ( row != null ) { cell cell = row . getcell ( tieconstants . hidden_full_name_column ) ; if ( cell != null ) { return cell . getstringcellvalue ( ) ; } } return null ; }	Gets the full name from row.
public static void rebuildupperlevelformula ( final configbuildref configbuildref , final string actionfullname ) { map < cell , string > cachedmap = configbuildref . getcachedcells ( ) ; map < string , list < rowsmapping > > rowsmap = new hashmap < > ( ) ; for ( map . entry < cell , string > entry : cachedmap . entryset ( ) ) { cell cell = entry . getkey ( ) ; string originformula = entry . getvalue ( ) ; if ( originformula != null ) { setupupperlevelformula ( cell , originformula , actionfullname , rowsmap , configbuildref ) ; } } }	Re build upper level formula.
private static void setupupperlevelformula ( final cell cell , final string originformula , final string actionfullname , final map < string , list < rowsmapping > > rowsmap , final configbuildref configbuildref ) { string fullname = getfullnamefromrow ( cell . getrow ( ) ) ;	Setup upper level formula.
public static void buildcellformulaforshiftedrows ( final sheet sheet , final xssfevaluationworkbook wbwrapper , final shiftformularef shiftformularef , final cell cell , final string originformula ) {	Builds the cell formula for shifted rows.
public static list < rowsmapping > gatherrowsmappingbyfullname ( final configbuildref configbuildref , final string fullname ) { list < rowsmapping > list = new arraylist < > ( ) ; map < string , configrangeattrs > shiftmap = configbuildref . getshiftmap ( ) ; for ( map . entry < string , configrangeattrs > entry : shiftmap . entryset ( ) ) { string fname = entry . getkey ( ) ; if ( fname . startswith ( fullname + str_ ) || fname . equals ( fullname ) ) { configrangeattrs attrs = entry . getvalue ( ) ; list . add ( attrs . getunitrowsmapping ( ) ) ; } } return list ; }	Gather rows mapping by full name.
public static void changeindexnumberinshiftmap ( final map < string , configrangeattrs > shiftmap , final map < string , string > changemap ) { for ( map . entry < string , string > entry : changemap . entryset ( ) ) { string key = entry . getkey ( ) ; string newkey = entry . getvalue ( ) ; configrangeattrs attrs = shiftmap . get ( key ) ; if ( attrs != null ) { shiftmap . remove ( key ) ; shiftmap . put ( newkey , attrs ) ; } } }	Increase index number in shift map.
public static void changeupperlevelfinallength ( final map < string , configrangeattrs > shiftmap , final string addedfullname , final int increasedlength ) { string [ ] parts = addedfullname . split ( str_ ) ; stringbuilder fname = new stringbuilder ( ) ; for ( int i = num_ ; i < ( parts . length - num_ ) ; i ++ ) { if ( i == num_ ) { fname . append ( parts [ i ] ) ; } else { fname . append ( str_ ) . append ( parts [ i ] ) ; } string sname = fname . tostring ( ) ; shiftmap . get ( sname ) . setfinallength ( shiftmap . get ( sname ) . getfinallength ( ) + increasedlength ) ; } }	Increase upper level final length.
public static void changeindexnumberinhiddencolumn ( final configbuildref configbuildref , final int startrowindex , final string fullname , final map < string , string > changemap , final int steps ) { string searchname = fullname . substring ( num_ , fullname . lastindexof ( str_ ) + num_ ) ; sheet sheet = configbuildref . getsheet ( ) ; for ( int i = startrowindex ; i <= sheet . getlastrownum ( ) ; i ++ ) { row row = sheet . getrow ( i ) ; string fname = getfullnamefromrow ( row ) ; if ( ( fname != null ) && ( fname . indexof ( searchname ) >= num_ ) ) { int sindex = fname . indexof ( searchname ) ; string snum = fname . substring ( sindex + searchname . length ( ) ) ; int sufindex = snum . indexof ( str_ ) ; string suffix = str_ ; if ( sufindex > num_ ) { snum = snum . substring ( num_ , sufindex ) ; suffix = str_ ; } int increasenum = integer . parseint ( snum ) + steps ; string realfullname = fname . substring ( sindex ) ; string changename = fname . replace ( searchname + snum + suffix , searchname + increasenum + suffix ) ; if ( changemap . get ( realfullname ) == null ) { changemap . put ( realfullname , changename . substring ( sindex ) ) ; } setfullnameinhiddencolumn ( row , changename ) ; } else { return ; } } }	Change index number in hidden column.
public static void setfullnameinhiddencolumn ( final row row , final string fullname ) { cell cell = row . getcell ( tieconstants . hidden_full_name_column , missingcellpolicy . create_null_as_blank ) ; cell . setcellvalue ( fullname ) ; }	Sets the full name in hidden column.
public static int getoriginalrownuminhiddencolumn ( final row row ) { if ( row != null ) { cell cell = row . getcell ( tieconstants . hidden_origin_row_number_column , missingcellpolicy . create_null_as_blank ) ; string rownum = cell . getstringcellvalue ( ) ; try { if ( ( rownum != null ) && ( ! rownum . isempty ( ) ) && ( websheetutility . isnumeric ( rownum ) ) ) { return integer . parseint ( rownum ) ; } } catch ( exception ex ) { log . log ( level . severe , str_ + rownum + str_ + ex . getlocalizedmessage ( ) , ex ) ; } } return - num_ ; }	Gets the original row num in hidden column.
public static void setoriginalrownuminhiddencolumn ( final row row , final int rownum ) { cell cell = row . getcell ( tieconstants . hidden_origin_row_number_column , missingcellpolicy . create_null_as_blank ) ; cell . setcellvalue ( integer . tostring ( rownum ) ) ; cell . setcelltype ( celltype . string ) ; }	Sets the original row num in hidden column.
public static list < rowsmapping > findparentrowsmappingfromshiftmap ( final string [ ] parts , final map < string , configrangeattrs > shiftmap ) { stringbuilder fullname = new stringbuilder ( ) ; list < rowsmapping > rowsmappinglist = new arraylist < > ( ) ; for ( int i = num_ ; i < parts . length - num_ ; i ++ ) { string part = parts [ i ] ; if ( fullname . length ( ) == num_ ) { fullname . append ( part ) ; } else { fullname . append ( str_ + part ) ; } if ( fullname . length ( ) > num_ ) { configrangeattrs rangeattrs = shiftmap . get ( fullname . tostring ( ) ) ; if ( rangeattrs != null ) { rowsmappinglist . add ( rangeattrs . getunitrowsmapping ( ) ) ; } } } return rowsmappinglist ; }	Find parent rows mapping from shift map.
public static list < rowsmapping > findchildrowsmappingfromshiftmap ( final string fullname , final navigablemap < string , configrangeattrs > shiftmap ) { list < rowsmapping > rowsmappinglist = new arraylist < > ( ) ; navigablemap < string , configrangeattrs > tailmap = shiftmap . tailmap ( fullname , bool_ ) ; for ( map . entry < string , configrangeattrs > entry : tailmap . entryset ( ) ) { string key = entry . getkey ( ) ;	Find child rows mapping from shift map.
@ suppresswarnings ( str_ ) public static object finditemincollection ( final collection collection , final int index ) { if ( index >= num_ ) { if ( collection instanceof list ) { list list = ( list ) collection ; return list . get ( index ) ; } int i = num_ ; for ( object object : collection ) { if ( i == index ) { return object ; } i ++ ; } } return null ; }	Find item in collection.
public static configrange buildcurrentrange ( final configrange sourceconfigrange , final sheet sheet , final int insertposition ) { configrange current = new configrange ( sourceconfigrange ) ; int shiftnum = insertposition - sourceconfigrange . getfirstrowaddr ( ) . getrow ( ) ; current . shiftrowref ( sheet , shiftnum ) ; return current ; }	Builds the current range.
public static boolean isstaticrow ( final configrange sourceconfigrange , final int rowindex ) { if ( sourceconfigrange . getcommandlist ( ) != null ) { for ( int i = num_ ; i < sourceconfigrange . getcommandlist ( ) . size ( ) ; i ++ ) { command command = sourceconfigrange . getcommandlist ( ) . get ( i ) ; if ( ( rowindex >= command . getconfigrange ( ) . getfirstrowaddr ( ) . getrow ( ) ) && ( rowindex < ( command . getconfigrange ( ) . getlastrowplusaddr ( ) . getrow ( ) ) ) ) { return bool_ ; } } } return bool_ ; }	Whether the row is static.
public static boolean isstaticrowref ( final configrange sourceconfigrange , final row row ) { if ( sourceconfigrange . getcommandlist ( ) != null ) { for ( int i = num_ ; i < sourceconfigrange . getcommandlist ( ) . size ( ) ; i ++ ) { command command = sourceconfigrange . getcommandlist ( ) . get ( i ) ; int rowindex = row . getrownum ( ) ; if ( ( rowindex >= command . gettoprow ( ) ) && ( rowindex < ( command . gettoprow ( ) + command . getfinallength ( ) ) ) ) { return bool_ ; } } } return bool_ ; }	Whether the row is static.This check row after shifted.
public static string replaceexpressionwithcellvalue ( final string attrvalue , final int rowindex , final sheet sheet ) { int ibegin = num_ ; int ifind ; int inameend ; string tempstr ; string findstr ; string replacestr ; string returnstr = attrvalue ; while ( ( ifind = attrvalue . indexof ( tieconstants . cell_addr_pre_fix , ibegin ) ) > num_ ) { inameend = parserutility . findfirstnoncellnameposition ( attrvalue , ifind ) ; if ( inameend > num_ ) { findstr = attrvalue . substring ( ifind , inameend ) ; } else { findstr = attrvalue . substring ( ifind ) ; } if ( findstr . indexof ( tieconstants . cell_addr_pre_fix , num_ ) < num_ ) {	100 >= 80.
public static map < string , cellrangeaddress > indexmergedregion ( final sheet sheet1 ) { int numregions = sheet1 . getnummergedregions ( ) ; map < string , cellrangeaddress > cellrangemap = new hashmap < > ( ) ; for ( int i = num_ ; i < numregions ; i ++ ) { cellrangeaddress caddress = sheet1 . getmergedregion ( i ) ; if ( caddress != null ) { cellrangemap . put ( cellutility . getcellindexnumberkey ( caddress . getfirstcolumn ( ) , caddress . getfirstrow ( ) ) , caddress ) ; } } return cellrangemap ; }	Index merged region.
public static list < string > skippedregioncells ( final sheet sheet1 ) { int numregions = sheet1 . getnummergedregions ( ) ; list < string > skipcelllist = new arraylist < > ( ) ; for ( int i = num_ ; i < numregions ; i ++ ) { cellrangeaddress caddress = sheet1 . getmergedregion ( i ) ; if ( caddress != null ) { addskipcelltolistintheregion ( skipcelllist , caddress ) ; } } return skipcelllist ; }	Skipped region cells.
private static void addskipcelltolistintheregion ( final list < string > skipcelllist , final cellrangeaddress caddress ) { for ( int col = caddress . getfirstcolumn ( ) ; col <= caddress . getlastcolumn ( ) ; col ++ ) { for ( int row = caddress . getfirstrow ( ) ; row <= caddress . getlastrow ( ) ; row ++ ) { if ( ( col == caddress . getfirstcolumn ( ) ) && ( row == caddress . getfirstrow ( ) ) ) { continue ; } skipcelllist . add ( cellutility . getcellindexnumberkey ( col , row ) ) ; } } }	Add skipped cell into the list of a region.
public static void buildsheetcommentfromalias ( sheet sheet , list < tiecommandalias > tiecommandaliaslist ) { if ( ( tiecommandaliaslist == null ) || ( tiecommandaliaslist . isempty ( ) ) ) { return ; } for ( row row : sheet ) { for ( cell cell : row ) { buildcellcommentfromalias ( tiecommandaliaslist , cell ) ; } } }	Build Sheet Comment From command alias.
private static void buildcellcommentfromalias ( list < tiecommandalias > tiecommandaliaslist , cell cell ) { string value = cellutility . getcellvaluewithoutformat ( cell ) ; if ( ( value != null ) && ( ! value . isempty ( ) ) ) { for ( tiecommandalias alias : tiecommandaliaslist ) { matcher matcher = alias . getpattern ( ) . matcher ( value ) ; if ( matcher . find ( ) ) { cellutility . createorinsertcomment ( cell , alias . getcommand ( ) ) ; if ( alias . isremove ( ) ) { cellutility . setcellvalue ( cell , parserutility . removecharsfromstring ( value , matcher . start ( ) , matcher . end ( ) ) ) ; } } } } }	Builds the cell comment fromalias.
public final map < string , sheetconfiguration > buildconfiguration ( ) { map < string , sheetconfiguration > sheetconfigmap = new linkedhashmap < > ( ) ;	Builds the configuration.
private sheetconfiguration getsheetconfiguration ( final sheet sheet , final string formname , final int sheetrightcol ) { sheetconfiguration sheetconfig = new sheetconfiguration ( ) ; sheetconfig . setformname ( formname ) ; sheetconfig . setsheetname ( sheet . getsheetname ( ) ) ; int leftcol = sheet . getleftcol ( ) ; int lastrow = sheet . getlastrownum ( ) ; int firstrow = sheet . getfirstrownum ( ) ; int rightcol = num_ ; int maxrow = num_ ; for ( row row : sheet ) { if ( row . getrownum ( ) > tieconstants . tie_web_sheet_max_rows ) { break ; } maxrow = row . getrownum ( ) ; int firstcellnum = row . getfirstcellnum ( ) ; if ( firstcellnum >= num_ && firstcellnum < leftcol ) { leftcol = firstcellnum ; } if ( ( row . getlastcellnum ( ) - num_ ) > rightcol ) { int verifiedcol = verifylastcell ( row , rightcol , sheetrightcol ) ; if ( verifiedcol > rightcol ) { rightcol = verifiedcol ; } } } if ( maxrow < lastrow ) { lastrow = maxrow ; }	Gets the sheet configuration.
private formcommand buildformcommandfromsheetconfig ( final sheetconfiguration sheetconfig , final sheet sheet ) { int firstrow = sheetconfig . getbodycellrange ( ) . gettoprow ( ) ; int leftcol = sheetconfig . getbodycellrange ( ) . getleftcol ( ) ; int rightcol = sheetconfig . getbodycellrange ( ) . getrightcol ( ) ; int lastrow = sheetconfig . getbodycellrange ( ) . getbottomrow ( ) ; cell firstcell = sheet . getrow ( firstrow ) . getcell ( leftcol , missingcellpolicy . create_null_as_blank ) ; formcommand fcommand = new formcommand ( ) ; fcommand . setcommandtypename ( tieconstants . command_form ) ; if ( sheetconfig . ishidden ( ) ) { fcommand . sethidden ( tieconstants . true_string ) ; } else { fcommand . sethidden ( tieconstants . false_string ) ; } fcommand . setname ( sheetconfig . getformname ( ) ) ; fcommand . getconfigrange ( ) . setfirstrowref ( firstcell , bool_ ) ; fcommand . getconfigrange ( ) . setlastrowplusref ( sheet , rightcol , lastrow , bool_ ) ; fcommand . setheaderlength ( str_ ) ; fcommand . setfooterlength ( str_ ) ; fcommand . setlength ( integer . tostring ( lastrow - firstrow + num_ ) ) ; return fcommand ; }	Builds the form command from sheet config.
private int verifylastcell ( final row row , final int stoppoint , final int sheetrightcol ) { int lastcol = sheetrightcol ; int col ; for ( col = lastcol ; col >= stoppoint ; col -- ) { cell cell = row . getcell ( col ) ; if ( ( cell != null ) && ( cell . getcelltypeenum ( ) != celltype . blank ) ) { break ; } } return col ; }	check last column. if it's blank then treat it as null cell.
public final void buildsheet ( final sheet sheet , final map < string , sheetconfiguration > sheetconfigmap , final cellattributesmap cellattributesmap ) { if ( ( sheet . getlastrownum ( ) <= num_ ) && ( sheet . getrow ( num_ ) == null ) ) {	build a sheet for configuration map.
private final void checkandrepairlastrow ( final sheet sheet ) {	check and repair the sheet's lastrow.
private list < configcommand > buildcommandlistfromsheetcomment ( final xssfsheet sheet , final int sheetrightcol , final cellattributesmap cellattributesmap ) { list < configcommand > commandlist = new arraylist < > ( ) ;	build command list from comments.
private void setparentforchildcommand ( final list < configcommand > commandlist , final int i , final configcommand child ) { int matchindex = - num_ ; configrange matchrange = null ; for ( int j = num_ ; j < commandlist . size ( ) ; j ++ ) { if ( j != i ) { command commandparent = commandlist . get ( j ) ; if ( ! commandparent . getcommandtypename ( ) . equalsignorecase ( tieconstants . command_form ) && websheetutility . insiderange ( child . getconfigrange ( ) , commandparent . getconfigrange ( ) ) && ( ( matchrange == null ) || ( websheetutility . insiderange ( commandparent . getconfigrange ( ) , matchrange ) ) ) ) { matchrange = commandparent . getconfigrange ( ) ; matchindex = j ; } } } if ( matchindex >= num_ ) { commandlist . get ( matchindex ) . getconfigrange ( ) . addcommand ( child ) ; child . setparentfound ( bool_ ) ; } }	Sets the parent for child command.
private boolean haseachcommandinthelist ( final list < configcommand > commandlist ) { if ( commandlist != null ) { for ( configcommand command : commandlist ) { if ( command . getcommandtypename ( ) . equalsignorecase ( tieconstants . command_each ) ) { return bool_ ; } } } return bool_ ; }	check whether contain each command in the list.
private void matchcommandtosheetconfigform ( final map < string , sheetconfiguration > sheetconfigmap , final list < string > formlist , final configcommand command ) { for ( string formname : formlist ) { sheetconfiguration sheetconfig = sheetconfigmap . get ( formname ) ; if ( websheetutility . insiderange ( command . getconfigrange ( ) , sheetconfig . getformcommand ( ) . getconfigrange ( ) ) ) { sheetconfig . getformcommand ( ) . getconfigrange ( ) . addcommand ( command ) ; break ; } } }	Match command to sheet config form.
private void copytemplatefortiecommands ( final sheet sheet ) {	Copy the each command area to seperated sheet.
private list < configcommand > buildcommandlist ( final sheet sheet , final int sheetrightcol , final cell cell , final list < configcommand > clist , final cellattributesmap cellattributesmap ) { comment comment = cell . getcellcomment ( ) ; string text = comment . getstring ( ) . getstring ( ) ; string [ ] commentlines = text . split ( str_ ) ; stringbuilder newcomment = new stringbuilder ( ) ; boolean changed = bool_ ; for ( string commentline : commentlines ) { string line = commentline . trim ( ) ; if ( parserutility . iscommandstring ( line ) ) { processcommandline ( sheet , cell , line , clist , sheetrightcol ) ; changed = bool_ ; } else if ( parserutility . isemptymethodstring ( line ) || parserutility . ismethodstring ( line ) ) { processmethodline ( cell , line , cellattributesmap ) ; changed = bool_ ; } else { if ( newcomment . length ( ) > num_ ) { newcomment . append ( str_ + commentline ) ; } else { newcomment . append ( commentline ) ; } } } if ( ! changed ) { movecommenttomap ( cell , text , cellattributesmap . gettemplatecommentmap ( ) , bool_ ) ; } else {	build command list from comment.
private void processmethodline ( final cell cell , final string line , final cellattributesmap cellattributesmap ) { if ( parserutility . iswidgetmethodstring ( line ) ) { parserutility . parsewidgetattributes ( cell , line , cellattributesmap ) ; } else if ( parserutility . isvalidatemethodstring ( line ) ) { parserutility . parsevalidateattributes ( cell , line , cellattributesmap ) ; } else { movecommenttomap ( cell , line , cellattributesmap . gettemplatecommentmap ( ) , bool_ ) ; } }	Process method line.
private void processcommandline ( final sheet sheet , final cell cell , final string line , final list < configcommand > clist , final int sheetrightcol ) { int nameendindex = line . indexof ( tieconstants . attr_prefix , tieconstants . command_prefix . length ( ) ) ; if ( nameendindex < num_ ) { string errmsg = str_ + line + str_ + tieconstants . attr_prefix + str_ ; log . severe ( errmsg ) ; throw new illegalstateexception ( errmsg ) ; } string commandname = line . substring ( tieconstants . command_prefix . length ( ) , nameendindex ) . trim ( ) ; map < string , string > attrmap = buildattrmap ( line , nameendindex ) ; configcommand configcommand = createconfigcommand ( sheet , cell , sheetrightcol , commandname , attrmap ) ; if ( configcommand != null ) { clist . add ( configcommand ) ; } }	Process command line.
private void movecommenttomap ( final cell cell , final string newcomment , final map < string , map < string , string > > sheetcommentmap , final boolean normalcomment ) { string cellkey = cell . getsheet ( ) . getsheetname ( ) + str_ + cell . getcolumnindex ( ) + str_ + cell . getrowindex ( ) ; parserutility . parsecommenttomap ( cellkey , newcomment , sheetcommentmap , normalcomment ) ; }	change the comment.
private configcommand createconfigcommand ( final sheet sheet , final cell firstcell , final int sheetrightcol , final string commandname , final map < string , string > attrmap ) { @ suppresswarnings ( str_ ) class clas = commandmap . get ( commandname ) ; if ( clas == null ) { log . log ( level . warning , str_ , commandname ) ; return null ; } try { configcommand command = ( configcommand ) clas . newinstance ( ) ; command . setcommandtypename ( commandname ) ; for ( map . entry < string , string > attr : attrmap . entryset ( ) ) { websheetutility . setobjectproperty ( command , attr . getkey ( ) , attr . getvalue ( ) , bool_ ) ; } command . getconfigrange ( ) . setfirstrowref ( firstcell , bool_ ) ; command . getconfigrange ( ) . setlastrowplusref ( sheet , sheetrightcol , command . getlastrow ( ) , bool_ ) ; return command ; } catch ( exception e ) { log . log ( level . warning , str_ + clas . getname ( ) + str_ + commandname , e ) ; return null ; } }	create configuration command.
private map < string , string > buildattrmap ( final string commandline , final int nameendindex ) { int paramsendindex = commandline . lastindexof ( tieconstants . attr_suffix ) ; if ( paramsendindex < num_ ) { string errmsg = str_ + commandline + str_ + tieconstants . attr_suffix + str_ ; throw new illegalargumentexception ( errmsg ) ; } string attrstring = commandline . substring ( nameendindex + num_ , paramsendindex ) . trim ( ) ; return parserutility . parsecommandattributes ( attrstring ) ; }	Build the attributes map.
private sheetconfiguration getsheetconfigurationfromconfigcommand ( final sheet sheet , final formcommand fcommand , final int sheetrightcol ) { sheetconfiguration sheetconfig = new sheetconfiguration ( ) ; sheetconfig . setformname ( fcommand . getname ( ) ) ; sheetconfig . setsheetname ( sheet . getsheetname ( ) ) ; int leftcol = fcommand . getleftcol ( ) ; int lastrow = fcommand . getlastrow ( ) ; int rightcol = num_ ; int maxrow = num_ ; for ( row row : sheet ) { if ( row . getrownum ( ) > tieconstants . tie_web_sheet_max_rows ) { break ; } maxrow = row . getrownum ( ) ; if ( ( row . getlastcellnum ( ) - num_ ) > rightcol ) { int verifiedcol = verifylastcell ( row , rightcol , sheetrightcol ) ; if ( verifiedcol > rightcol ) { rightcol = verifiedcol ; } } } if ( maxrow < lastrow ) { lastrow = maxrow ; }	Create sheet configuration from form command.
private void setfooterofsheetconfiguration ( final formcommand fcommand , final sheetconfiguration sheetconfig , final int leftcol , final int rightcol ) { string tempstr ; if ( fcommand . calcfooterlength ( ) == num_ ) { tempstr = cellutility . getcellindexletterkey ( leftcol , num_ ) + str_ + cellutility . getcellindexletterkey ( rightcol , num_ ) ; } else { tempstr = cellutility . getcellindexletterkey ( leftcol , fcommand . gettoprow ( ) + fcommand . calcheaderlength ( ) + fcommand . calcbodylength ( ) ) + str_ + cellutility . getcellindexletterkey ( rightcol , fcommand . gettoprow ( ) + fcommand . calcheaderlength ( ) ) ; } sheetconfig . setformfooterrange ( tempstr ) ; sheetconfig . setfootercellrange ( new cellrange ( tempstr ) ) ; }	Sets the footer of sheet configuration.
private void setbodyofsheetconfiguration ( final formcommand fcommand , final sheetconfiguration sheetconfig , final int leftcol , final int lastrow , final int rightcol ) { string tempstr ; tempstr = cellutility . getcellindexletterkey ( leftcol , fcommand . gettoprow ( ) + fcommand . calcheaderlength ( ) + num_ ) + str_ + cellutility . getcellindexletterkey ( rightcol , lastrow + num_ ) ; sheetconfig . setformbodyrange ( tempstr ) ; sheetconfig . setbodycellrange ( new cellrange ( tempstr ) ) ; sheetconfig . setformbodytype ( tieconstants . form_type_free ) ; sheetconfig . setcellformattributes ( new hashmap < string , list < cellformattributes > > ( ) ) ; }	Sets the body of sheet configuration.
private void setheaderofsheetconfiguration ( final formcommand fcommand , final sheetconfiguration sheetconfig , final int leftcol , final int rightcol ) { string tempstr ; if ( fcommand . calcheaderlength ( ) == num_ ) { tempstr = cellutility . getcellindexletterkey ( leftcol , num_ ) + str_ + cellutility . getcellindexletterkey ( rightcol , num_ ) ; } else { tempstr = cellutility . getcellindexletterkey ( leftcol , fcommand . gettoprow ( ) + num_ ) + str_ + cellutility . getcellindexletterkey ( rightcol , fcommand . gettoprow ( ) + fcommand . calcheaderlength ( ) ) ; } sheetconfig . setformheaderrange ( tempstr ) ; sheetconfig . setheadercellrange ( new cellrange ( tempstr ) ) ; }	Sets the header of sheet configuration.
@ suppresswarnings ( { str_ } ) public static int deleterow ( final configbuildref configbuildref , final int rowindex , final map < string , object > datacontext , final sheetconfiguration sheetconfig , final list < facesrow > bodyrows ) { string fullname = configurationutility . getfullnamefromrow ( configbuildref . getsheet ( ) . getrow ( rowindex ) ) ; configbuildref . getcellhelper ( ) . restoredatacontext ( fullname ) ; collectionobject collect = configbuildref . getcellhelper ( ) . getlastcollect ( fullname ) ; collection lastcollection = collect . getlastcollection ( ) ; int lastcollectionindex = collect . getlastcollectionindex ( ) ; eachcommand eachcommand = collect . geteachcommand ( ) ; if ( lastcollectionindex < num_ ) {	Delete row.
private static void removerangesfromshiftmap ( final navigablemap < string , configrangeattrs > shiftmap , final list < string > removefullnamelist ) { for ( string fname : removefullnamelist ) { shiftmap . remove ( fname ) ; } }	Removes the ranges from shift map.
private static list < string > findremovefullnamelist ( final sheet sheet , final int startrow , final int endrow ) { list < string > list = new arraylist < > ( ) ; for ( int rowindex = startrow ; rowindex <= endrow ; rowindex ++ ) { string fullname = configurationutility . getfullnamefromrow ( sheet . getrow ( rowindex ) ) ; if ( ! list . contains ( fullname ) ) { list . add ( fullname ) ; } } return list ; }	Find remove full name list.
public static eachcommand geteachcommandfrompartsname ( final map < string , command > commandindexmap , final string [ ] varparts ) { if ( varparts . length == tieconstants . default_command_part_length ) { return ( eachcommand ) commandindexmap . get ( tieconstants . each_command_full_name_prefix + varparts [ num_ ] ) ; } return null ; }	Gets the each command from parts name.
@ suppresswarnings ( { str_ , str_ } ) private static string insertemptyobjectincontext ( final string fullname , final collection lastcollection , final eachcommand eachcommand , final int lastcollectionindex , final map < string , object > datacontext ) { if ( ! ( lastcollection instanceof list ) ) { throw new evaluationexception ( str_ ) ; } list collectionlist = ( list ) lastcollection ;	Insert empty object in context.
@ suppresswarnings ( { str_ } ) private static void deleteobjectincontext ( final collection lastcollection , final eachcommand eachcommand , final int lastcollectionindex , final map < string , object > datacontext ) { if ( ! ( lastcollection instanceof list ) ) { throw new evaluationexception ( eachcommand . getvar ( ) + tieconstants . each_command_invalid_msg ) ; } list collectionlist = ( list ) lastcollection ;	Delete object in context.
@ suppresswarnings ( str_ ) public static int preparecollectiondataincontext ( final string [ ] varparts , final collection collection , final map < string , object > datacontext ) { if ( varparts . length == tieconstants . default_command_part_length ) { int collectionindex = integer . parseint ( varparts [ num_ ] ) ; object obj = configurationutility . finditemincollection ( collection , collectionindex ) ; if ( obj != null ) { datacontext . put ( varparts [ num_ ] , obj ) ; return collectionindex ; } } return - num_ ; }	Prepare collection data in context.
public static void indexcommandrange ( final configrange sourceconfigrange , final map < string , command > indexmap ) { if ( sourceconfigrange . getcommandlist ( ) != null ) { for ( int i = num_ ; i < sourceconfigrange . getcommandlist ( ) . size ( ) ; i ++ ) { command command = sourceconfigrange . getcommandlist ( ) . get ( i ) ; indexmap . put ( command . getcommandname ( ) , command ) ; command . getconfigrange ( ) . indexcommandrange ( indexmap ) ; } } }	Index command range.
public static boolean isrowallowadd ( final row row , final sheetconfiguration sheetconfig ) { string fullname = configurationutility . getfullnamefromrow ( row ) ; if ( fullname != null ) { configrangeattrs attrs = sheetconfig . getshiftmap ( ) . get ( fullname ) ; if ( ( attrs != null ) && ( attrs . isallowadd ( ) ) && ( row . getrownum ( ) == attrs . getfirstrowref ( ) . getrowindex ( ) ) ) { return bool_ ; } } return bool_ ; }	Checks if is row allow add.
public static void inserteachtemplate ( final configrange sourceconfigrange , final configbuildref configbuildref , final int index , final int insertposition , final rowsmapping unitrowsmapping ) { int srcstartrow = sourceconfigrange . getfirstrowaddr ( ) . getrow ( ) ; int srcendrow = sourceconfigrange . getlastrowplusaddr ( ) . getrow ( ) - num_ ; sheet sheet = configbuildref . getsheet ( ) ; workbook wb = sheet . getworkbook ( ) ;	Insert each template.
public static void evaluatenormalcells ( final cell cell , final string strvalue , final map < string , object > context , final expressionengine engine ) { if ( strvalue . contains ( tieconstants . method_prefix ) ) { object evaluationresult = evaluate ( strvalue , context , engine ) ; if ( evaluationresult == null ) { evaluationresult = str_ ; } cellutility . setcellvalue ( cell , evaluationresult . tostring ( ) ) ; createtiecell ( cell , context , engine ) ; } }	Evaluate normal cells.
private static void evaluateuserformula ( final cell cell , final string strvalue ) { string formulastr = strvalue . substring ( num_ , strvalue . length ( ) - num_ ) ; if ( ( formulastr != null ) && ( ! formulastr . isempty ( ) ) ) { cell . setcellformula ( formulastr ) ; } }	Evaluate user formula.
private static boolean isuserformula ( final string str ) { return str . startswith ( tieconstants . user_formula_prefix ) && str . endswith ( tieconstants . user_formula_suffix ) ; }	Checks if is user formula.
public static void createcellcomment ( final cell cell , final string newcomment , final map < cell , string > finalcommentmap ) {	Creates the cell comment.
public static boolean evalboolexpression ( final expressionengine expengine , final string pscript ) { object result = null ; string script = str_ + pscript + str_ ; script = script . touppercase ( ) . replace ( str_ , str_ ) ; script = script . touppercase ( ) . replace ( str_ , str_ ) ; try { result = expengine . evaluate ( script ) ; } catch ( exception e ) { log . log ( level . severe , str_ + script + str_ + e . getlocalizedmessage ( ) , e ) ; } if ( result != null ) { return ( ( boolean ) result ) . booleanvalue ( ) ; } else { return bool_ ; } }	evaluate boolean express.
public static void removerowsinsheet ( final sheet sheet , final int rowindexstart , final int rowindexend , final map < cell , string > cachedmap ) { for ( int irow = rowindexstart ; irow <= rowindexend ; irow ++ ) { removecachedcellforrow ( sheet , irow , cachedmap ) ; } int irows = rowindexend - rowindexstart + num_ ; if ( ( irows < num_ ) || ( rowindexstart < num_ ) ) { return ; } int lastrownum = sheet . getlastrownum ( ) ; if ( rowindexend < lastrownum ) { sheet . shiftrows ( rowindexend + num_ , lastrownum , - irows ) ; } if ( rowindexend == lastrownum ) {	Remove the rows.
private static void removesinglerowinsheet ( final sheet sheet , final int rowindexstart ) { row removingrow = sheet . getrow ( rowindexstart ) ; if ( removingrow != null ) { sheet . removerow ( removingrow ) ; } }	Removes the single row in sheet.
private static void removecachedcellforrow ( final sheet sheet , final int rowindexstart , final map < cell , string > cachedmap ) { row removingrow = sheet . getrow ( rowindexstart ) ; if ( removingrow != null ) {	Removes the cached cell for row.
public static void removerowsinbody ( final sheetconfiguration sheetconfig , final list < facesrow > bodyrows , final int rowindexstart , final int rowindexend ) { int top = sheetconfig . getbodycellrange ( ) . gettoprow ( ) ; if ( ( rowindexend < rowindexstart ) || ( rowindexstart < top ) ) { return ; } int irows = rowindexend - rowindexstart + num_ ; for ( int rowindex = rowindexend ; rowindex >= rowindexstart ; rowindex -- ) { bodyrows . remove ( rowindex - top ) ; } for ( int irow = rowindexstart - top ; irow < bodyrows . size ( ) ; irow ++ ) { facesrow facesrow = bodyrows . get ( irow ) ; facesrow . setrowindex ( facesrow . getrowindex ( ) - irows ) ; } }	Removes the rows in body.
private string loadpicture ( final int rowindex , final int colindex ) { facescell facescell = parent . getcellhelper ( ) . getfacescellwithrowcolfromcurrentpage ( rowindex , colindex ) ; if ( facescell != null && facescell . iscontainpic ( ) ) { facescontext context = facescontext . getcurrentinstance ( ) ; string pictureid = facescell . getpictureid ( ) ; string pictureviewid = integer . tohexstring ( system . identityhashcode ( parent . getwb ( ) ) ) + pictureid ; map < string , object > sessionmap = context . getexternalcontext ( ) . getsessionmap ( ) ; if ( sessionmap . get ( pictureviewid ) == null ) { sessionmap . put ( pictureviewid , parent . getpicturesmap ( ) . get ( pictureid ) . getpicturedata ( ) ) ; } return pictureviewid ; } else { return null ; } }	Put picture image to session map and return the key to web.
private string loadchart ( final int rowindex , final int colindex ) { facescell facescell = parent . getcellhelper ( ) . getfacescellwithrowcolfromcurrentpage ( rowindex , colindex ) ; if ( facescell != null && facescell . iscontainchart ( ) ) { facescontext context = facescontext . getcurrentinstance ( ) ; string chartid = facescell . getchartid ( ) ; string chartviewid = integer . tohexstring ( system . identityhashcode ( parent . getwb ( ) ) ) + chartid ; if ( context != null ) { map < string , object > sessionmap = context . getexternalcontext ( ) . getsessionmap ( ) ; if ( sessionmap . get ( chartviewid ) == null ) { sessionmap . put ( chartviewid , parent . getcharsdata ( ) . getchartsmap ( ) . get ( chartid ) ) ; } } return chartviewid ; } else { return null ; } }	Put chart image to session map and return the key to web.
private string assemblenewvalue ( final object value , final facescell facescell ) { string newvalue ; if ( value instanceof java . util . date ) { string datepattern = facescell . getdatepattern ( ) ; if ( datepattern == null || datepattern . isempty ( ) ) { datepattern = parent . getdefaultdatepattern ( ) ; } format formatter = new simpledateformat ( datepattern ) ; newvalue = formatter . format ( value ) ; } else { newvalue = ( string ) value ; } if ( str_ . equalsignorecase ( facescell . getinputtype ( ) ) && ( newvalue != null ) ) {	Assemble new value.
@ suppresswarnings ( str_ ) public static string getcellvaluewithformat ( final cell poicell , final formulaevaluator formulaevaluator , final dataformatter dataformatter ) { if ( poicell == null ) { return null ; } string result ; try { celltype celltype = poicell . getcelltypeenum ( ) ; if ( celltype == celltype . formula ) { celltype = formulaevaluator . evaluate ( poicell ) . getcelltypeenum ( ) ; } if ( celltype == celltype . error ) { result = str_ ; } else { result = dataformatter . formatcellvalue ( poicell , formulaevaluator ) ; } } catch ( exception e ) { log . log ( level . severe , str_ + poicell . getrowindex ( ) + str_ + poicell . getcolumnindex ( ) + str_ + e . getlocalizedmessage ( ) + str_ , e ) ; result = str_ ; } return result ; }	return cell value with format.
@ suppresswarnings ( str_ ) public static string getcellvaluewithoutformat ( final cell poicell ) { if ( poicell == null ) { return null ; } if ( poicell . getcelltypeenum ( ) == celltype . formula ) { return getcellstringvaluewithtype ( poicell , poicell . getcachedformularesulttypeenum ( ) ) ; } else { return getcellstringvaluewithtype ( poicell , poicell . getcelltypeenum ( ) ) ; } }	get input cell value. none input return blank.
private static string getcellstringvaluewithtype ( final cell poicell , final celltype celltype ) { switch ( celltype ) { case boolean : return getcellstringvaluewithbooleantype ( poicell ) ; case numeric : return getcellstringvaluewithnumbertype ( poicell ) ; case string : return poicell . getstringcellvalue ( ) ; default : return str_ ; }	Get cell value as string but with giving type.
private static string getcellstringvaluewithnumbertype ( final cell poicell ) { string result ; if ( dateutil . iscelldateformatted ( poicell ) ) { result = poicell . getdatecellvalue ( ) . tostring ( ) ; } else { result = bigdecimal . valueof ( poicell . getnumericcellvalue ( ) ) . toplainstring ( ) ;	Gets the cell string value with number type.
@ suppresswarnings ( str_ ) public static cell setcellvalue ( final cell c , final string value ) { try { if ( value . length ( ) == num_ ) { c . setcelltype ( celltype . blank ) ; } else if ( websheetutility . isnumeric ( value ) ) { setcellvaluenumber ( c , value ) ; } else if ( websheetutility . isdate ( value ) ) { setcellvaluedate ( c , value ) ; } else if ( c . getcelltypeenum ( ) == celltype . boolean ) { setcellvalueboolean ( c , value ) ; } else { setcellvaluestring ( c , value ) ; } } catch ( exception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; setcellvaluestring ( c , value ) ; } return c ; }	Set cell value with giving String value.
private static void setcellvaluestring ( final cell c , final string value ) { c . setcelltype ( celltype . string ) ; c . setcellvalue ( value ) ; }	Sets the cell value string.
private static void setcellvalueboolean ( final cell c , final string value ) { if ( str_ . equalsignorecase ( value ) || str_ . equalsignorecase ( value ) || str_ . equalsignorecase ( value ) ) { c . setcellvalue ( bool_ ) ; } else { c . setcellvalue ( bool_ ) ; } }	Sets the cell value boolean.
private static void setcellvaluedate ( final cell c , final string value ) { string date = websheetutility . parsedate ( value ) ; setcellvaluestring ( c , date ) ; }	Sets the cell value date.
private static void setcellvaluenumber ( final cell c , final string value ) { double val = double . parsedouble ( value . replace ( character . tostring ( str_ ) , str_ ) ) ; c . setcelltype ( celltype . numeric ) ; c . setcellvalue ( val ) ; }	Sets the cell value number.
public static void copyrows ( final sheet srcsheet , final sheet destsheet , final int srcrowstart , final int srcrowend , final int destrow , final boolean checklock , final boolean sethiddencolumn ) { int length = srcrowend - srcrowstart + num_ ; if ( length <= num_ ) { return ; } destsheet . shiftrows ( destrow , destsheet . getlastrownum ( ) , length , bool_ , bool_ ) ; for ( int i = num_ ; i < length ; i ++ ) { copysinglerow ( srcsheet , destsheet , srcrowstart + i , destrow + i , checklock , sethiddencolumn ) ; }	Copy rows.
private static void copysinglerow ( final sheet srcsheet , final sheet destsheet , final int sourcerownum , final int destinationrownum , final boolean checklock , final boolean sethiddencolumn ) {	Copy single row.
public static cell copycell ( final sheet destsheet , final row sourcerow , final row newrow , final int cellindex , final boolean checklock ) {	Copy cell.
@ suppresswarnings ( str_ ) private static void copycellsetvalue ( final cell sourcecell , final cell newcell , final boolean checklock ) { cellstyle newcellstyle = newcell . getcellstyle ( ) ; string name = sourcecell . getcelltypeenum ( ) . tostring ( ) ; cellvaluetype e = enum . valueof ( cellvaluetype . class , name ) ; e . setcellvalue ( newcell , sourcecell , checklock , newcellstyle ) ; }	set cell value.
@ suppresswarnings ( str_ ) private static void copycellsetstyle ( final sheet destsheet , final cell sourcecell , final cell newcell ) { cellstyle newcellstyle = getcellstylefromsourcecell ( destsheet , sourcecell ) ; newcell . setcellstyle ( newcellstyle ) ;	set up cell style.
public static void clonecomment ( final cell sourcecell , final cell newcell ) { xssfsheet sheet = ( xssfsheet ) newcell . getsheet ( ) ; creationhelper factory = sheet . getworkbook ( ) . getcreationhelper ( ) ; drawing drawing = sheet . createdrawingpatriarch ( ) ; xssfcomment sourcecomment = ( xssfcomment ) sourcecell . getcellcomment ( ) ;	clone existing comments into new cell comment.
private static clientanchor createcommentanchor ( final cell newcell , creationhelper factory ) { clientanchor anchor = factory . createclientanchor ( ) ; anchor . setcol1 ( newcell . getcolumnindex ( ) ) ; anchor . setcol2 ( newcell . getcolumnindex ( ) + num_ ) ; anchor . setrow1 ( newcell . getrowindex ( ) ) ; anchor . setrow2 ( newcell . getrowindex ( ) + num_ ) ; return anchor ; }	Creates the comment anchor.
public static void createorinsertcomment ( final cell cell , final string commentstr ) { xssfsheet sheet = ( xssfsheet ) cell . getsheet ( ) ; creationhelper factory = sheet . getworkbook ( ) . getcreationhelper ( ) ; drawing drawing = sheet . createdrawingpatriarch ( ) ; comment comment = cell . getcellcomment ( ) ; string originstr = str_ ; if ( comment == null ) {	Creates the or insert comment.
private static void matchcommentsettings ( final cell newcell , final cell sourcecell ) { try { xssfvmldrawing sourcevml = getvmldrawingfromcell ( sourcecell ) ; xssfvmldrawing targetvml = getvmldrawingfromcell ( newcell ) ; ctshape sourcectshape = getctshapefromvml ( sourcecell , sourcevml ) ; ctshape targetctshape = getctshapefromvml ( newcell , targetvml ) ; targetctshape . settype ( sourcectshape . gettype ( ) ) ; ctclientdata sourceclientdata = sourcectshape . getclientdataarray ( num_ ) ; ctclientdata targetclientdata = targetctshape . getclientdataarray ( num_ ) ; string [ ] anchorarray = sourceclientdata . getanchorlist ( ) . get ( num_ ) . split ( str_ ) ; int shiftrows = newcell . getrowindex ( ) - sourcecell . getrowindex ( ) ; anchorarray [ num_ ] = integer . tostring ( integer . parseint ( anchorarray [ num_ ] . trim ( ) ) + shiftrows ) ; anchorarray [ num_ ] = integer . tostring ( integer . parseint ( anchorarray [ num_ ] . trim ( ) ) + shiftrows ) ; targetclientdata . getanchorlist ( ) . set ( num_ , facesutility . strjoin ( anchorarray , str_ ) ) ; } catch ( exception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } }	Use low level API to match the comments setting.
private static xssfvmldrawing getvmldrawingfromcell ( final cell cell ) { xssfsheet sourcesheet = ( xssfsheet ) cell . getsheet ( ) ; for ( poixmldocumentpart sourcepart : sourcesheet . getrelations ( ) ) { if ( ( sourcepart != null ) && ( sourcepart instanceof xssfvmldrawing ) ) { return ( xssfvmldrawing ) sourcepart ; } } return null ; }	Find vmldrawing part according to cell.
@ suppresswarnings ( str_ ) private static ctshape getctshapefromvml ( final cell sourcecell , xssfvmldrawing sourcevml ) throws reflectiveoperationexception { method findshape ;	Find CtShape from vml object.
private static cellstyle getcellstylefromsourcecell ( final sheet destsheet , final cell sourcecell ) { workbook wb = destsheet . getworkbook ( ) ;	create cell style from source cell.
public static void convertcell ( final sheetconfiguration sheetconfig , final facescell fcell , final cell poicell , final map < string , cellrangeaddress > cellrangemap , final int originrowindex , final cellattributesmap cellattributesmap , final string saveattrs ) { cellrangeaddress caddress ; string key = getcellindexnumberkey ( poicell ) ; caddress = cellrangemap . get ( key ) ; if ( caddress != null ) {	set up facesCell's attribute from poiCell and others.
public static int [ ] getrowcolfromcomponentattributes ( final uicomponent target ) { int rowindex = ( integer ) target . getattributes ( ) . get ( str_ ) ; int colindex = ( integer ) target . getattributes ( ) . get ( str_ ) ; int [ ] list = new int [ num_ ] ; list [ num_ ] = rowindex ; list [ num_ ] = colindex ; return list ; }	Gets the row col from component attributes.
public static int getinitrowsfromconfig ( final sheetconfiguration sheetconfig ) { int initrows = num_ ; if ( str_ . equalsignorecase ( sheetconfig . getformbodytype ( ) ) ) { initrows = sheetconfig . getbodyinitialrows ( ) ; if ( initrows < num_ ) { initrows = num_ ; } } return initrows ; }	Gets the inits the rows from config.
public static facesrow getfacesrowfrombodyrow ( final int row , final list < facesrow > bodyrows , final int toprow ) { facesrow frow = null ; try { frow = bodyrows . get ( row - toprow ) ; } catch ( exception e ) { log . log ( level . severe , str_ + row + str_ + toprow + str_ + e . getlocalizedmessage ( ) , e ) ; } return frow ; }	Gets the faces row from body row.
public static facescell getfacescellfrombodyrow ( final int row , final int col , final list < facesrow > bodyrows , final int toprow , final int leftcol ) { facescell cell = null ; try { cell = bodyrows . get ( row - toprow ) . getcells ( ) . get ( col - leftcol ) ; } catch ( exception e ) { log . log ( level . severe , str_ + row + str_ + col + str_ + toprow + str_ + leftcol + str_ + e . getlocalizedmessage ( ) , e ) ; } return cell ; }	Gets the faces cell from body row.
public static cell getpoicellfromsheet ( final int rowindex , final int colindex , final sheet sheet1 ) { if ( ( sheet1 != null ) && ( sheet1 . getrow ( rowindex ) != null ) ) { return sheet1 . getrow ( rowindex ) . getcell ( colindex ) ; } return null ; }	Gets the poi cell from sheet.
public static string getskeyfrompoicell ( final cell poicell ) { return poicell . getsheet ( ) . getsheetname ( ) + str_ + cellutility . getcellindexnumberkey ( poicell . getcolumnindex ( ) , poicell . getrowindex ( ) ) ; }	Gets the skey from poi cell.
public static tiecell getoraddtiecellinmap ( final cell poicell , hashmap < string , tiecell > tiecells ) { string skey = cellutility . getskeyfrompoicell ( poicell ) ; tiecell tiecell = tiecells . get ( skey ) ; if ( tiecell == null ) { tiecell = new tiecell ( ) ; tiecell . setskey ( skey ) ; tiecells . put ( skey , tiecell ) ; } return tiecell ; }	Gets the or add tie cell in map.
public final string getcurrentdatacontextname ( ) { if ( currentdatacontextname == null ) { stringbuilder sb = new stringbuilder ( ) ; list < string > list = this . getcurrentdatacontextnamelist ( ) ; for ( int i = num_ ; i < list . size ( ) ; i ++ ) { if ( i > num_ ) { sb . append ( str_ + list . get ( i ) ) ; } else { sb . append ( list . get ( i ) ) ; } } this . setcurrentdatacontextname ( sb . tostring ( ) ) ; } return currentdatacontextname ; }	Gets the current data context name.
public final object evaluate ( final string expression , final map < string , object > context ) { jexlcontext jexlcontext = new mapcontext ( context ) ; try { jexlengine jexl = jexl_local . get ( ) ; map < string , expression > expmap = jexl_map_local . get ( ) ; expression jexlexpression = expmap . get ( expression ) ; if ( jexlexpression == null ) { jexlexpression = jexl . createexpression ( expression ) ; expmap . put ( expression , jexlexpression ) ; } return jexlexpression . evaluate ( jexlcontext ) ; } catch ( exception e ) { throw new evaluationexception ( e ) ; } }	Evaluate the expression.
public final object evaluate ( final map < string , object > context ) { jexlcontext jexlcontext = new mapcontext ( context ) ; try { return jexpression . evaluate ( jexlcontext ) ; } catch ( exception e ) { throw new evaluationexception ( str_ + jexpression . getexpression ( ) , e ) ; } }	evaluate from giving context.
private void writeobject ( final java . io . objectoutputstream out ) throws ioexception { this . rowindex = this . getrow ( ) . getrownum ( ) ; out . defaultwriteobject ( ) ; }	save the row before serialize.
public final void removerow ( final integer sourcerownum , final row targetrow ) { list < serialrow > maprowlist = rowsmap . get ( sourcerownum ) ; if ( maprowlist != null ) { maprowlist . remove ( new serialrow ( targetrow , - num_ ) ) ; rowsmap . put ( sourcerownum , maprowlist ) ; } }	Removes the row.
public final void mergemap ( final rowsmapping addmap ) { map < integer , list < serialrow > > map = addmap . getrowsmap ( ) ; for ( map . entry < integer , list < serialrow > > entry : map . entryset ( ) ) { list < serialrow > entryrowlist = entry . getvalue ( ) ; if ( ( entryrowlist != null ) && ( ! entryrowlist . isempty ( ) ) ) { for ( serialrow row : entryrowlist ) { this . addrow ( entry . getkey ( ) , row . getrow ( ) ) ; } } } }	Merge map.
public final void recover ( final sheet sheet ) { for ( map . entry < integer , list < serialrow > > entry : this . getrowsmap ( ) . entryset ( ) ) { list < serialrow > listrow = entry . getvalue ( ) ; for ( serialrow serialrow : listrow ) { serialrow . recover ( sheet ) ; } } }	recover rows mapping by using it's address.
public static charttype getcharttype ( final ctchart ctchart ) { ctplotarea plotarea = ctchart . getplotarea ( ) ; for ( charttype charttype : charttype . values ( ) ) { if ( charttype . isthistype ( plotarea ) ) { return charttype ; } } return null ; }	return chart type from CTChart object.
public static basicstroke tostroke ( final string style ) { basicstroke result = null ; if ( style != null ) { float linewidth = stroke_default_line_width ; float [ ] dash = { stroke_default_dash_width } ; float [ ] dot = { linewidth } ; if ( style . equalsignorecase ( style_line ) ) { result = new basicstroke ( linewidth ) ; } else if ( style . equalsignorecase ( style_dash ) ) { result = new basicstroke ( linewidth , basicstroke . cap_butt , basicstroke . join_miter , stroke_miter_limit_style_dash , dash , stroke_default_dashphase ) ; } else if ( style . equalsignorecase ( style_dot ) ) { result = new basicstroke ( linewidth , basicstroke . cap_butt , basicstroke . join_miter , stroke_miter_limit_style_dot , dot , stroke_default_dashphase ) ; } } return result ; }	Convert style string to stroke object.
public static chartdata initchartdatafromxssfchart ( final string chartid , final xssfchart chart , final xssfworkbook wb ) { themestable themetable = wb . getstylessource ( ) . gettheme ( ) ; chartdata chartdata = new chartdata ( ) ; xssfrichtextstring charttitle = chart . gettitle ( ) ; if ( charttitle != null ) { chartdata . settitle ( charttitle . tostring ( ) ) ; } ctchart ctchart = chart . getctchart ( ) ; charttype charttype = chartutility . getcharttype ( ctchart ) ; if ( charttype == null ) { throw new illegalchartexception ( str_ ) ; } chartdata . setbgcolor ( colorutility . getbgcolor ( ctchart . getplotarea ( ) , themetable ) ) ; chartdata . setid ( chartid ) ; chartdata . settype ( charttype ) ; list < ctcatax > ctcataxlist = ctchart . getplotarea ( ) . getcataxlist ( ) ; if ( ( ctcataxlist != null ) && ( ! ctcataxlist . isempty ( ) ) ) { chartdata . setcatax ( new chartaxis ( ctcataxlist . get ( num_ ) ) ) ; } list < ctvalax > ctvalaxlist = ctchart . getplotarea ( ) . getvalaxlist ( ) ; if ( ( ctvalaxlist != null ) && ( ! ctvalaxlist . isempty ( ) ) ) { chartdata . setvalax ( new chartaxis ( ctvalaxlist . get ( num_ ) ) ) ; } chartobject ctobj = charttype . createchartobject ( ) ; if ( ctobj == null ) { throw new illegalchartexception ( str_ ) ; } setupchartdata ( chartdata , ctchart , themetable , ctobj ) ; return chartdata ; }	init chart data.
public static void setupchartdata ( final chartdata chartdata , final ctchart ctchart , final themestable themetable , final chartobject ctobj ) { object chartobj = null ; @ suppresswarnings ( str_ ) list plotcharts = ctobj . getchartlistfromctchart ( ctchart ) ;	build chartData for line chart.
public static void initxssfanchorsmap ( final xssfworkbook wb , final chartsdata charsdata ) { map < string , clientanchor > anchortmap = charsdata . getchartanchorsmap ( ) ; map < string , string > positionmap = charsdata . getchartpositionmap ( ) ; anchortmap . clear ( ) ; positionmap . clear ( ) ; for ( int i = num_ ; i < wb . getnumberofsheets ( ) ; i ++ ) { initxssfanchorsmapforsheet ( anchortmap , positionmap , wb . getsheetat ( i ) ) ; } }	retrieve anchor information from draw.xml for all the charts in theworkbook.
private static void initxssfanchorsmapforsheet ( final map < string , clientanchor > anchortmap , final map < string , string > positionmap , final xssfsheet sheet ) { xssfdrawing drawing = sheet . createdrawingpatriarch ( ) ; ctdrawing ctdrawing = drawing . getctdrawing ( ) ; if ( ctdrawing . sizeoftwocellanchorarray ( ) <= num_ ) { return ; } list < cttwocellanchor > alist = ctdrawing . gettwocellanchorlist ( ) ; for ( int j = num_ ; j < alist . size ( ) ; j ++ ) { cttwocellanchor ctanchor = alist . get ( j ) ; string singlechartid = getanchorassociatechartid ( ctanchor ) ; if ( singlechartid != null ) { string chartid = sheet . getsheetname ( ) + str_ + singlechartid ; int dx1 = ( int ) ctanchor . getfrom ( ) . getcoloff ( ) ; int dy1 = ( int ) ctanchor . getfrom ( ) . getrowoff ( ) ; int dx2 = ( int ) ctanchor . getto ( ) . getcoloff ( ) ; int dy2 = ( int ) ctanchor . getto ( ) . getrowoff ( ) ; int col1 = ctanchor . getfrom ( ) . getcol ( ) ; int row1 = ctanchor . getfrom ( ) . getrow ( ) ; int col2 = ctanchor . getto ( ) . getcol ( ) ; int row2 = ctanchor . getto ( ) . getrow ( ) ; anchortmap . put ( chartid , new xssfclientanchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; positionmap . put ( websheetutility . getfullcellrefname ( sheet . getsheetname ( ) , row1 , col1 ) , chartid ) ; } } }	Inits the XSSF anchors map for sheet.
private static string getanchorassociatechartid ( final cttwocellanchor ctanchor ) { if ( ctanchor . getgraphicframe ( ) == null ) { return null ; } node parentnode = ctanchor . getgraphicframe ( ) . getgraphic ( ) . getgraphicdata ( ) . getdomnode ( ) ; nodelist childnodes = parentnode . getchildnodes ( ) ; for ( int i = num_ ; i < childnodes . getlength ( ) ; i ++ ) { node childnode = childnodes . item ( i ) ; if ( ( childnode != null ) && ( str_ . equalsignorecase ( childnode . getnodename ( ) ) ) && ( childnode . hasattributes ( ) ) ) { string rid = getchartidfromchildnodeattributes ( childnode . getattributes ( ) ) ; if ( rid != null ) { return rid ; } } } return null ; }	Gets the anchor associate chart id.
private static string getchartidfromchildnodeattributes ( final namednodemap attrs ) { for ( int j = num_ ; j < attrs . getlength ( ) ; j ++ ) { attr attribute = ( attr ) attrs . item ( j ) ; if ( str_ . equalsignorecase ( attribute . getname ( ) ) ) { return attribute . getvalue ( ) ; } } return null ; }	Gets the chart id from child node attributes.
@ suppresswarnings ( str_ ) private int buildeachobjects ( string fullname , final configbuildref configbuildref , final int atrow , final map < string , object > context , final list < rowsmapping > currentrowsmappinglist , final collection itemscollection , final string objclassname ) { int index = num_ ; int insertposition = atrow ; string thisobjclassname = objclassname ;	Builds the each objects.
public final void savedataincontext ( final cell poicell , final string strvalue ) { string saveattr = saveattrsutility . preparecontextandattrsforcell ( poicell , configurationutility . getfullnamefromrow ( poicell . getrow ( ) ) , this ) ; if ( saveattr != null ) { saveattrsutility . savedatatoobjectincontext ( parent . getserialdatacontext ( ) . getdatacontext ( ) , saveattr , strvalue , parent . getexpengine ( ) ) ; parent . gethelper ( ) . getwebsheetloader ( ) . setunsavedstatus ( requestcontext . getcurrentinstance ( ) , bool_ ) ; } }	Save data in context.
public final void recalc ( ) { parent . getformulaevaluator ( ) . clearallcachedresultvalues ( ) ; try { parent . getformulaevaluator ( ) . evaluateall ( ) ; } catch ( exception ex ) {	recalc whole workbook.
public final cell getpoicellwithrowcolfromtab ( final int rowindex , final int colindex , final string tabname ) { if ( parent . getwb ( ) != null ) { return cellutility . getpoicellfromsheet ( rowindex , colindex , parent . getwb ( ) . getsheet ( parent . getsheetconfigmap ( ) . get ( tabname ) . getsheetname ( ) ) ) ; } return null ; }	Gets the poi cell with row col from tab.
public final facescell getfacescellwithrowcolfromcurrentpage ( final int rowindex , final int colindex ) { if ( parent . getbodyrows ( ) != null ) { int top = parent . getcurrent ( ) . getcurrenttoprow ( ) ; int left = parent . getcurrent ( ) . getcurrentleftcolumn ( ) ; return parent . getbodyrows ( ) . get ( rowindex - top ) . getcells ( ) . get ( colindex - left ) ; } return null ; }	Gets the faces cell with row col from current page.
public final void restoredatacontext ( final string fullname ) { string [ ] parts = fullname . split ( str_ ) ; if ( ! isneedrestore ( fullname , parts ) ) { return ; } boolean stopskip = bool_ ; list < string > list = parent . getcurrent ( ) . getcurrentdatacontextnamelist ( ) ; int listsize = list . size ( ) ;	Restore data context.
public final collectionobject getlastcollect ( final string fullname ) { string [ ] parts = fullname . split ( str_ ) ; string part = parts [ parts . length - num_ ] ; return startrestoredatacontext ( part ) ; }	Get last collect object from full name.Last collect contain each command, collection and index.
private boolean isneedrestore ( final string fullname , final string [ ] parts ) { if ( fullname == null ) { return bool_ ; } if ( ( parent . getcurrent ( ) . getcurrentdatacontextname ( ) != null ) && ( parent . getcurrent ( ) . getcurrentdatacontextname ( ) . tolowercase ( ) . startswith ( fullname . tolowercase ( ) ) ) ) { return bool_ ; } return ( ( parts != null ) && ( parts . length > num_ ) ) ; }	Checks if is need restore.
private collectionobject startrestoredatacontext ( final string part ) { if ( part . startswith ( tieconstants . each_command_full_name_prefix ) ) { string [ ] varparts = part . split ( str_ ) ; collectionobject collect = new collectionobject ( ) ; collect . seteachcommand ( commandutility . geteachcommandfrompartsname ( parent . getcurrentsheetconfig ( ) . getcommandindexmap ( ) , varparts ) ) ; collect . setlastcollection ( configurationutility . transformtocollectionobject ( parent . getexpengine ( ) , collect . geteachcommand ( ) . getitems ( ) , parent . getserialdatacontext ( ) . getdatacontext ( ) ) ) ; collect . setlastcollectionindex ( commandutility . preparecollectiondataincontext ( varparts , collect . getlastcollection ( ) , parent . getserialdatacontext ( ) . getdatacontext ( ) ) ) ; return collect ; } return null ; }	Start restore data context.
public final void shiftrowref ( final sheet sheet , final int shiftnum ) { try { this . setfirstrowref ( sheet . getrow ( attrs . getfirstrowaddr ( ) . getrow ( ) + shiftnum ) . getcell ( attrs . getfirstrowaddr ( ) . getcolumn ( ) , missingcellpolicy . create_null_as_blank ) , bool_ ) ; this . setlastrowplusref ( sheet , attrs . getlastrowplusaddr ( ) . getcolumn ( ) , attrs . getlastrowplusaddr ( ) . getrow ( ) + shiftnum - num_ , bool_ ) ; if ( commandlist != null ) { for ( configcommand command : commandlist ) { command . shiftrowref ( sheet , shiftnum ) ; } } } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getlocalizedmessage ( ) , ex ) ; } }	Shift row ref.
public final void setfirstrowref ( final cell pfirstrowref , final boolean alsocreateaddr ) { this . attrs . setfirstrowref ( pfirstrowref ) ; if ( alsocreateaddr ) { this . setfirstrowaddr ( new serialcelladdress ( pfirstrowref ) ) ; } }	set first cell also set static relative address firstCellAddress.
public final void setlastrowplusref ( final sheet sheet , final int rightcol , final int lastrow , final boolean alsosetaddr ) { if ( ( lastrow >= num_ ) && ( sheet != null ) && ( rightcol >= num_ ) ) { row row = sheet . getrow ( lastrow + num_ ) ; if ( row == null ) { row = sheet . createrow ( lastrow + num_ ) ; } cell cell = row . getcell ( rightcol ) ; if ( cell == null ) { cell = row . getcell ( rightcol , missingcellpolicy . create_null_as_blank ) ; this . attrs . setlastcellcreated ( bool_ ) ; } else { this . attrs . setlastcellcreated ( bool_ ) ; } this . attrs . setlastrowplusref ( cell ) ; if ( alsosetaddr ) { this . setlastrowplusaddr ( new serialcelladdress ( cell ) ) ; } } else { this . attrs . setlastrowplusref ( null ) ; if ( alsosetaddr ) { this . attrs . setlastrowplusaddr ( null ) ; } } }	set last cell also set static relative address lastCellAddress.
private void buildcellsforrow ( final row row , final string fullname , final map < string , object > context , final configbuildref configbuildref , shiftformularef shiftformularef ) { if ( ( row == null ) || ! configurationutility . isstaticrowref ( this , row ) ) { return ; } for ( cell cell : row ) { buildsinglecell ( cell , context , configbuildref , shiftformularef ) ; } configurationutility . setfullnameinhiddencolumn ( row , fullname ) ; }	Builds the cells for row.
private void buildsinglecell ( final cell cell , final map < string , object > context , final configbuildref configbuildref , final shiftformularef shiftformularef ) { try { commandutility . evaluate ( context , cell , configbuildref . getengine ( ) ) ; if ( cell . getcelltypeenum ( ) == celltype . formula ) {	Builds the single cell.
private void readobject ( final java . io . objectinputstream in ) throws ioexception { try { in . defaultreadobject ( ) ; gson objgson = new gsonbuilder ( ) . setprettyprinting ( ) . create ( ) ; type listtype = new typetoken < map < string , object > > ( ) { } . gettype ( ) ; this . datacontext = objgson . fromjson ( maptojson , listtype ) ; } catch ( encrypteddocumentexception | classnotfoundexception e ) { log . log ( level . severe , str_ + e . getlocalizedmessage ( ) , e ) ; } }	load the workbook from saving.
public final void buildcategorylist ( final ctaxdatasource ctaxds ) { list < parsedcell > cells = new arraylist < > ( ) ; try { string fullrangename = ctaxds . getstrref ( ) . getf ( ) ; string sheetname = websheetutility . getsheetnamefromfullcellrefname ( fullrangename ) ; cellrangeaddress region = cellrangeaddress . valueof ( websheetutility . removesheetnamefromfullcellrefname ( fullrangename ) ) ; for ( int row = region . getfirstrow ( ) ; row <= region . getlastrow ( ) ; row ++ ) { for ( int col = region . getfirstcolumn ( ) ; col <= region . getlastcolumn ( ) ; col ++ ) { cells . add ( new parsedcell ( sheetname , row , col ) ) ; } } } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } this . setcategorylist ( cells ) ; }	build categotry list.
@ suppresswarnings ( str_ ) public final void buildserieslist ( final list bsers , final themestable themetable , final chartobject ctobj ) { list < chartseries > lserieslist = new arraylist < > ( ) ; try { for ( int index = num_ ; index < bsers . size ( ) ; index ++ ) { object ctobjser = bsers . get ( index ) ; chartseries ctser = buildchartseriesinlist ( themetable , ctobj , ctobjser , index ) ; lserieslist . add ( ctser ) ; } } catch ( exception ex ) { log . log ( level . fine , str_ , ex ) ; } this . setserieslist ( lserieslist ) ; }	build series list.
private chartseries buildchartseriesinlist ( final themestable themetable , final chartobject ctobj , final object ctobjser , final int index ) { chartseries ctser = new chartseries ( ) ; ctser . setserieslabel ( new parsedcell ( ctobj . getserieslabelfromctser ( ctobjser ) ) ) ; ctser . setseriescolor ( colorutility . gecolorfromsppr ( index , ctobj . getshapepropertiesfromctser ( ctobjser ) , themetable , ctobj . islinecolor ( ) ) ) ; list < parsedcell > cells = new arraylist < > ( ) ; string fullrangename = ( ctobj . getctnumdatasourcefromctser ( ctobjser ) ) . getnumref ( ) . getf ( ) ; string sheetname = websheetutility . getsheetnamefromfullcellrefname ( fullrangename ) ; cellrangeaddress region = cellrangeaddress . valueof ( websheetutility . removesheetnamefromfullcellrefname ( fullrangename ) ) ; for ( int row = region . getfirstrow ( ) ; row <= region . getlastrow ( ) ; row ++ ) { for ( int col = region . getfirstcolumn ( ) ; col <= region . getlastcolumn ( ) ; col ++ ) { cells . add ( new parsedcell ( sheetname , row , col ) ) ; } } ctser . setvaluelist ( cells ) ; ctser . setvaluecolorlist ( getcolorlistfromdptwithvaluelist ( ctobj . getdptlistfromctser ( ctobjser ) , cells , themetable , ctobj ) ) ; return ctser ; }	Builds the chart series in list.
private list < xcolor > getcolorlistfromdptwithvaluelist ( final list < ctdpt > dptlist , final list < parsedcell > cells , final themestable themetable , final chartobject ctobj ) { list < xcolor > colors = new arraylist < > ( ) ; if ( ( dptlist != null ) && ( cells != null ) ) { for ( int index = num_ ; index < cells . size ( ) ; index ++ ) { ctdpt dpt = getdptfromlistwithindex ( dptlist , index ) ; ctshapeproperties ctsppr = null ; if ( dpt != null ) { ctsppr = dpt . getsppr ( ) ; } colors . add ( colorutility . gecolorfromsppr ( index , ctsppr , themetable , ctobj . islinecolor ( ) ) ) ; } } return colors ; }	get color list from dpt.
private ctdpt getdptfromlistwithindex ( final list < ctdpt > dptlist , final int index ) { if ( dptlist != null ) { for ( ctdpt dpt : dptlist ) { if ( dpt . getidx ( ) . getval ( ) == index ) { return dpt ; } } } return null ; }	get dpt from list.
public final void setcommandindexmap ( final map < string , command > pcommandindexmap ) { if ( pcommandindexmap instanceof hashmap ) { this . commandindexmap = ( hashmap < string , command > ) pcommandindexmap ; } else { this . commandindexmap = new hashmap < > ( ) ; this . commandindexmap . putall ( pcommandindexmap ) ; } }	Sets the command index map.
public static void getpictruesmap ( final workbook wb , final map < string , picture > picmap ) { if ( wb instanceof xssfworkbook ) { getxssfpictruesmap ( ( xssfworkbook ) wb , picmap ) ; } return ; }	Gets the pictrues map.
private static void getxssfpictruesmap ( final xssfworkbook wb , final map < string , picture > picmap ) { picmap . clear ( ) ; list < xssfpicturedata > pictures = wb . getallpictures ( ) ; if ( pictures . isempty ( ) ) { return ; } for ( int i = num_ ; i < wb . getnumberofsheets ( ) ; i ++ ) { xssfsheet sheet = wb . getsheetat ( i ) ; for ( poixmldocumentpart dr : sheet . getrelations ( ) ) { try { indexpictureinmap ( picmap , sheet , dr ) ; } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getlocalizedmessage ( ) , ex ) ; } } } return ; }	Gets the XSSF pictrues map.
private static void indexpictureinmap ( final map < string , picture > picmap , final xssfsheet sheet , final poixmldocumentpart dr ) { if ( dr instanceof xssfdrawing ) { xssfdrawing drawing = ( xssfdrawing ) dr ; list < xssfshape > shapes = drawing . getshapes ( ) ; for ( xssfshape shape : shapes ) { if ( shape instanceof xssfpicture ) { xssfpicture pic = ( xssfpicture ) shape ; xssfclientanchor anchor = pic . getpreferredsize ( ) ; ctmarker ctmarker = anchor . getfrom ( ) ; string picindex = websheetutility . getfullcellrefname ( sheet . getsheetname ( ) , ctmarker . getrow ( ) , ctmarker . getcol ( ) ) ; picmap . put ( picindex , pic ) ; } } } }	save pciture in map with index.
public static string generatepicturestyle ( final sheet sheet1 , final facescell fcell , final cell cell , final picture pic ) { clientanchor anchor = pic . getclientanchor ( ) ; if ( anchor != null ) { anchorsize anchorsize = getanchorsize ( sheet1 , fcell , cell , anchor ) ; if ( anchorsize != null ) { return str_ + string . format ( str_ , anchorsize . getpercentleft ( ) ) + str_ + string . format ( str_ , anchorsize . getpercenttop ( ) ) + str_ + string . format ( str_ , anchorsize . getpercentwidth ( ) ) + str_ ; } } return str_ ; }	Generate picture style.
public static string generatechartstyle ( final sheet sheet1 , final facescell fcell , final cell cell , final string chartid , final map < string , clientanchor > anchorsmap ) { clientanchor anchor = anchorsmap . get ( chartid ) ; if ( anchor != null ) { anchorsize anchorsize = getanchorsize ( sheet1 , fcell , cell , anchor ) ; if ( anchorsize != null ) { return str_ + string . format ( str_ , anchorsize . getpercentleft ( ) ) + str_ + string . format ( str_ , anchorsize . getpercenttop ( ) ) + str_ + string . format ( str_ , anchorsize . getpercentwidth ( ) ) + str_ ; } } return str_ ; }	Generate chart style.
public pattern getpattern ( ) { if ( ( this . pattern == null ) && ( alias != null ) ) { this . pattern = pattern . compile ( str_ + parserutility . wildcardtoregex ( alias ) ) ; } return pattern ; }	Gets the pattern.
public streamedcontent getchart ( ) throws ioexception { facescontext context = facescontext . getcurrentinstance ( ) ; if ( context . getcurrentphaseid ( ) == phaseid . render_response ) {	Return real chart picture when browser requesting the image.
public final void recover ( final sheet sheet ) { if ( this . celladdr != null ) { this . setcell ( sheet . getrow ( this . celladdr . getrow ( ) ) . getcell ( this . celladdr . getcolumn ( ) ) ) ; } }	recover cell by using it's address.
public static string getrowstyle ( final workbook wb , final cell poicell , final string inputtype , final float rowheight , final int rowspan ) { cellstyle cellstyle = poicell . getcellstyle ( ) ; if ( ( cellstyle != null ) && ( rowspan == num_ ) ) { short fontidx = cellstyle . getfontindex ( ) ; font font = wb . getfontat ( fontidx ) ; float maxheight = rowheight ; if ( ! inputtype . isempty ( ) ) { maxheight = math . min ( font . getfontheightinpoints ( ) + num_ , rowheight ) ; } return str_ + websheetutility . pointstopixels ( maxheight ) + str_ ; } return str_ ; }	Gets the row style.
public static string getcellfontstyle ( final workbook wb , final cell poicell ) { cellstyle cellstyle = poicell . getcellstyle ( ) ; stringbuilder webstyle = new stringbuilder ( ) ; if ( cellstyle != null ) { short fontidx = cellstyle . getfontindex ( ) ; font font = wb . getfontat ( fontidx ) ; if ( font . getitalic ( ) ) { webstyle . append ( str_ ) ; } if ( font . getbold ( ) ) { webstyle . append ( str_ ) ; } webstyle . append ( str_ + font . getfontheightinpoints ( ) + str_ ) ; string decoration = getcellfontdecoration ( font ) ; if ( decoration . length ( ) > num_ ) { webstyle . append ( str_ + decoration + str_ ) ; } webstyle . append ( getcellfontcolor ( font ) ) ; } return webstyle . tostring ( ) ; }	Gets the cell font style.
private static string getcellfontcolor ( final font font ) { short [ ] rgbfix = { tieconstants . rgb_max , tieconstants . rgb_max , tieconstants . rgb_max } ; if ( font instanceof xssffont ) { xssfcolor color = ( ( xssffont ) font ) . getxssfcolor ( ) ; if ( color != null ) { rgbfix = colorutility . gettripletfromxssfcolor ( color ) ; } } if ( rgbfix [ num_ ] != tieconstants . rgb_max ) { return str_ + facesutility . strjoin ( rgbfix , str_ ) + str_ ; } return str_ ; }	get cell font color.
private static string getcellfontdecoration ( final font font ) { stringbuilder decoration = new stringbuilder ( ) ; if ( font . getunderline ( ) != num_ ) { decoration . append ( str_ ) ; } if ( font . getstrikeout ( ) ) { decoration . append ( str_ ) ; } return decoration . tostring ( ) ; }	Get font decoration.
public static string getcellstyle ( final workbook wb , final cell poicell , final string inputtype ) { cellstyle cellstyle = poicell . getcellstyle ( ) ; stringbuilder webstyle = new stringbuilder ( ) ; if ( cellstyle != null ) { if ( ! inputtype . isempty ( ) ) { webstyle . append ( getalignmentfromcell ( poicell , cellstyle ) ) ; webstyle . append ( getverticalalignmentfromcell ( cellstyle ) ) ; } webstyle . append ( colorutility . getbgcolorfromcell ( wb , poicell , cellstyle ) ) ; } return webstyle . tostring ( ) ; }	Gets the cell style.
public static string getcolumnstyle ( final workbook wb , final facescell fcell , final cell poicell , final float rowheight ) { string inputtype = fcell . getinputtype ( ) ; cellstyle cellstyle = poicell . getcellstyle ( ) ; stringbuilder webstyle = new stringbuilder ( ) ; if ( cellstyle != null ) { if ( fcell . iscontainpic ( ) || fcell . iscontainchart ( ) ) { webstyle . append ( str_ ) ; } else { webstyle . append ( getalignmentfromcell ( poicell , cellstyle ) ) ; webstyle . append ( getverticalalignmentfromcell ( cellstyle ) ) ; } webstyle . append ( colorutility . getbgcolorfromcell ( wb , poicell , cellstyle ) ) ; webstyle . append ( getrowstyle ( wb , poicell , inputtype , rowheight , fcell . getrowspan ( ) ) ) ; } else { webstyle . append ( getalignmentfromcelltype ( poicell ) ) ; } return webstyle . tostring ( ) ; }	Gets the column style.
private static string getalignmentfromcell ( final cell poicell , final cellstyle cellstyle ) { string style = str_ ; switch ( cellstyle . getalignmentenum ( ) ) { case left : style = tieconstants . text_align_left ; break ; case right : style = tieconstants . text_align_right ; break ; case center : style = tieconstants . text_align_center ; break ; case general : style = getalignmentfromcelltype ( poicell ) ; break ; default : break ; } return style ; }	Gets the alignment from cell.
private static string getverticalalignmentfromcell ( final cellstyle cellstyle ) { string style = str_ ; switch ( cellstyle . getverticalalignmentenum ( ) ) { case top : style = tieconstants . vertical_align_top ; break ; case center : style = tieconstants . vertical_align_center ; break ; case bottom : style = tieconstants . vertical_align_bottom ; break ; default : break ; } return style ; }	Gets the vertical alignment from cell.
public static int calctotalheight ( final sheet sheet1 , final int firstrow , final int lastrow , final int additionalheight ) { int totalheight = additionalheight ; for ( int i = firstrow ; i <= lastrow ; i ++ ) { totalheight += sheet1 . getrow ( i ) . getheight ( ) ; } return totalheight ; }	Calc total height.
public static void setupcellstyle ( final workbook wb , final facescell fcell , final cell poicell , final float rowheight ) { cellstyle cellstyle = poicell . getcellstyle ( ) ; if ( ( cellstyle != null ) && ( ! cellstyle . getlocked ( ) ) ) {	Setup cell style.
@ suppresswarnings ( str_ ) private static string getinputtypefromcelltype ( final cell cell ) { string inputtype = tieconstants . cell_input_type_text ; if ( cell . getcelltypeenum ( ) == celltype . numeric ) { inputtype = tieconstants . cell_input_type_double ; } cellstyle style = cell . getcellstyle ( ) ; if ( style != null ) { int formatindex = style . getdataformat ( ) ; string formatstring = style . getdataformatstring ( ) ; if ( dateutil . isadateformat ( formatindex , formatstring ) ) { inputtype = tieconstants . cell_input_type_date ; } else { if ( isapercentagecell ( formatstring ) ) { inputtype = tieconstants . cell_input_type_percentage ; } } } return inputtype ; }	Gets the input type from cell type.
public static set < string > getresourcepaths ( final facescontext context , final string path ) { return context . getexternalcontext ( ) . getresourcepaths ( path ) ; }	return faces context resource path.
public static inputstream getresourceasstream ( final facescontext context , final string path ) { return context . getexternalcontext ( ) . getresourceasstream ( path ) ; }	get resource file as stream.
public static string removeprefixpath ( final string prefix , final string resource ) { string normalizedresource = resource ; if ( normalizedresource . startswith ( prefix ) ) { normalizedresource = normalizedresource . substring ( prefix . length ( ) - num_ ) ; } return normalizedresource ; }	remove prefix path of the full path.
public static boolean evalinputtype ( final string input , final string type ) { scanner scanner = new scanner ( input ) ; boolean ireturn = bool_ ; if ( str_ . equalsignorecase ( type ) ) { ireturn = scanner . hasnextint ( ) ; } else if ( str_ . equalsignorecase ( type ) ) { ireturn = scanner . hasnextdouble ( ) ; } else if ( str_ . equalsignorecase ( type ) ) { ireturn = scanner . hasnextboolean ( ) ; } else if ( str_ . equalsignorecase ( type ) ) { ireturn = scanner . hasnextbyte ( ) ; } else if ( type . tolowercase ( ) . startswith ( str_ ) ) { ireturn = bool_ ; } scanner . close ( ) ; return ireturn ; }	evaluate input type.
@ suppresswarnings ( str_ ) public static < t > t findbean ( final string beanname ) { facescontext context = facescontext . getcurrentinstance ( ) ; return ( t ) context . getapplication ( ) . evaluateexpressionget ( context , tieconstants . el_start + beanname + tieconstants . el_end , object . class ) ; }	Find bean in context.
public static string strjoin ( final short [ ] aarr , final string ssep ) { stringbuilder sbstr = new stringbuilder ( ) ; for ( int i = num_ , il = aarr . length ; i < il ; i ++ ) { if ( i > num_ ) { sbstr . append ( ssep ) ; } sbstr . append ( aarr [ i ] ) ; } return sbstr . tostring ( ) ; }	join string.
public static double round ( final double value , final int places ) { if ( places < num_ ) { throw new illegalargumentexception ( ) ; } bigdecimal bd = bigdecimal . valueof ( value ) ; bd = bd . setscale ( places , roundingmode . half_up ) ; return bd . doublevalue ( ) ; }	round number according to decimal places.
public string gettabtype ( ) { int sheetid = webformtabview . getactiveindex ( ) ; if ( ( sheetid >= num_ ) && ( tabs != null ) ) { if ( sheetid >= tabs . size ( ) ) { sheetid = num_ ; } tabtype = tabs . get ( sheetid ) . type . tolowercase ( ) ; } else { tabtype = tieconstants . tab_type_none ; } return tabtype ; }	get tab type.
public string gettabstyle ( ) { string tabstyle = tieconstants . tab_style_visible ; int sheetid = webformtabview . getactiveindex ( ) ; if ( ( sheetid >= num_ ) && ( sheetid < tabs . size ( ) ) ) { tabstyle = tieconstants . tab_style_invisible ; } return tabstyle ; }	get tab style.
public string getdefaultdatepattern ( ) { if ( defaultdatepattern == null ) { dateformat formatter = dateformat . getdateinstance ( dateformat . short , locale . getdefault ( ) ) ; defaultdatepattern = ( ( simpledateformat ) formatter ) . tolocalizedpattern ( ) ; } return defaultdatepattern ; }	Gets the default date pattern.
public string getdecimalseparatorbydefaultlocale ( ) { final decimalformat nf = ( decimalformat ) decimalformat . getinstance ( getdefaultlocale ( ) ) ; return str_ + nf . getdecimalformatsymbols ( ) . getdecimalseparator ( ) ; }	Gets the decimal separator by default locale.
public string getthousandseparatorbydefaultlocale ( ) { final decimalformat nf = ( decimalformat ) decimalformat . getinstance ( getdefaultlocale ( ) ) ; return str_ + nf . getdecimalformatsymbols ( ) . getgroupingseparator ( ) ; }	Gets the thousand separator by default locale.
public void settiecommandaliaslist ( string aliaslistjson ) { gson gson = new gson ( ) ; type aliaslisttype = new typetoken < arraylist < tiecommandalias > > ( ) { } . gettype ( ) ; this . tiecommandaliaslist = gson . fromjson ( aliaslistjson , aliaslisttype ) ; }	Sets the tie command alias list.
private list < integer > buildformwatchlist ( final xssfevaluationworkbook wbwrapper , final sheet sheet ) { list < integer > watchlist = new arraylist < > ( ) ; configrange crange = this . getconfigrange ( ) ; list < configcommand > commandlist = crange . getcommandlist ( ) ; if ( commandlist . isempty ( ) ) {	Watch list serve for formula changes.
private void buildwatchlistforcell ( final xssfevaluationworkbook wbwrapper , final int sheetindex , final cell cell , final list < integer > watchlist , final int laststaticrow ) { string formula = cell . getcellformula ( ) ; ptg [ ] ptgs = formulaparser . parse ( formula , wbwrapper , formulatype . cell , sheetindex ) ; for ( int k = num_ ; k < ptgs . length ; k ++ ) { object ptg = ptgs [ k ] ;	Builds the watch list for cell.
private void addtowatchlist ( final int addrow , final int laststaticrow , final list < integer > watchlist ) { if ( ( addrow > laststaticrow ) && ! ( watchlist . contains ( addrow ) ) ) { watchlist . add ( addrow ) ; } }	Only rows in dynamic area will be added to watch list.
public static boolean iscommandstring ( final string str ) { if ( str == null ) { return bool_ ; } return str . startswith ( tieconstants . command_prefix ) ; }	check it's a command comment.
public static void parsewidgetattributes ( final cell cell , final string newcomment , final cellattributesmap cellattributesmap ) { if ( ( newcomment == null ) || ( newcomment . isempty ( ) ) ) { return ; } int widgetstart = newcomment . indexof ( tieconstants . method_widget_prefix ) ; int elstart = newcomment . indexof ( tieconstants . el_start_bracket ) ; if ( ( widgetstart < num_ ) || ( widgetstart >= elstart ) ) { return ; } string type = newcomment . substring ( widgetstart + tieconstants . method_widget_prefix . length ( ) , elstart ) ; string values = getstringbetweenbracket ( newcomment ) ; if ( values == null ) { return ; }	Parses the widget attributes.
public static string getattributekeyinmapbycell ( final cell cell ) { if ( cell == null ) { return null ; }	get attribute key in map by cell.
public static void parsevalidateattributes ( final cell cell , final string newcomment , final cellattributesmap cellattributesmap ) { if ( ( newcomment == null ) || ( newcomment . isempty ( ) ) ) { return ; } if ( ! newcomment . startswith ( tieconstants . method_validate_prefix ) ) { return ; } string values = getstringbetweenbracket ( newcomment ) ; if ( values == null ) { return ; }	Parses the validate attributes.
private static int findpairbracketposition ( final string str , final int startpos ) { int bracketnum = num_ ; for ( int i = startpos ; i < str . length ( ) ; i ++ ) { char current = str . charat ( i ) ; if ( current == tieconstants . el_start_bracket ) { bracketnum ++ ; } else if ( current == tieconstants . el_end ) { bracketnum -- ; if ( bracketnum <= num_ ) { return i ; } } } return - num_ ; }	Find pair bracket position.
public static map < string , string > parsecommandattributes ( final string attrstring ) { map < string , string > attrmap = new linkedhashmap < > ( ) ; matcher attrmatcher = tieconstants . attr_regex_pattern . matcher ( attrstring ) ; while ( attrmatcher . find ( ) ) { string attrdata = attrmatcher . group ( ) ; int attrnameendindex = attrdata . indexof ( str_ ) ; string attrname = attrdata . substring ( num_ , attrnameendindex ) . trim ( ) ; string attrvaluepart = attrdata . substring ( attrnameendindex + num_ ) . trim ( ) ; string attrvalue = attrvaluepart . substring ( num_ , attrvaluepart . length ( ) - num_ ) ; attrmap . put ( attrname , attrvalue ) ; } return attrmap ; }	Parse the attributes from string.
public static void parseinputattributes ( final list < cellformattributes > clist , final string controlattrs ) {	parse input attributes.
public static void parsevalidateattributes ( final list < cellformattributes > clist , final string controlattrs ) {	parse validate attributes.
private static string [ ] splitbyeualsign ( final string attrdata ) { int attrnameendindex = attrdata . indexof ( str_ ) ; if ( attrnameendindex < num_ ) { return new string [ num_ ] ; } string attrname = attrdata . substring ( num_ , attrnameendindex ) . trim ( ) ; string attrvalue = attrdata . substring ( attrnameendindex + num_ ) . trim ( ) ; string [ ] rlist = new string [ num_ ] ; rlist [ num_ ] = attrname ; rlist [ num_ ] = attrvalue ; return rlist ; }	split string by = sign.
public static void parsespecialattributes ( final string key , final string type , final list < cellformattributes > inputs , final cellattributesmap cellattributesmap ) { specialattributes sattr = new specialattributes ( ) ; for ( cellformattributes attr : inputs ) { gatherspecialattributes ( type , sattr , attr ) ; } if ( sattr . selectlabels != null ) { processselectitemattributes ( key , cellattributesmap , sattr ) ; } if ( type . equalsignorecase ( tieconstants . widget_calendar ) ) { processcalendarattributes ( key , cellattributesmap , sattr ) ; } }	parse select item attributes.
private static void processcalendarattributes ( final string key , final cellattributesmap cellattributesmap , final specialattributes sattr ) { cellattributesmap . getcelldatepattern ( ) . put ( key , sattr . defaultdatepattern ) ; }	Process calendar attributes.
private static void processselectitemattributes ( final string key , final cellattributesmap cellattributesmap , final specialattributes sattr ) { if ( ( sattr . selectvalues == null ) || ( sattr . selectvalues . length != sattr . selectlabels . length ) ) { sattr . selectvalues = sattr . selectlabels ; } map < string , string > smap = cellattributesmap . getcellselectitemsattributes ( ) . get ( key ) ; if ( smap == null ) { smap = new linkedhashmap < > ( ) ; } smap . clear ( ) ; if ( sattr . defaultselectlabel != null ) { smap . put ( sattr . defaultselectlabel , sattr . defaultselectvalue ) ; } for ( int i = num_ ; i < sattr . selectlabels . length ; i ++ ) { smap . put ( sattr . selectlabels [ i ] , sattr . selectvalues [ i ] ) ; } cellattributesmap . getcellselectitemsattributes ( ) . put ( key , smap ) ; }	Process select item attributes.
private static void gatherspecialattributes ( final string type , final specialattributes sattr , final cellformattributes attr ) { string attrkey = attr . gettype ( ) ; if ( attrkey . equalsignorecase ( tieconstants . select_item_labels ) ) { sattr . selectlabels = attr . getvalue ( ) . split ( str_ ) ; } if ( attrkey . equalsignorecase ( tieconstants . select_item_values ) ) { sattr . selectvalues = attr . getvalue ( ) . split ( str_ ) ; } if ( attrkey . equalsignorecase ( tieconstants . default_select_item_label ) ) { sattr . defaultselectlabel = attr . getvalue ( ) ; } if ( attrkey . equalsignorecase ( tieconstants . default_select_item_value ) ) { sattr . defaultselectvalue = attr . getvalue ( ) ; } if ( type . equalsignorecase ( tieconstants . widget_calendar ) && attrkey . equalsignorecase ( tieconstants . widget_attr_pattern ) ) { sattr . defaultdatepattern = attr . getvalue ( ) ; } }	Gather special attributes.
public static void parsecommenttomap ( final string cellkey , final string newcomment , final map < string , map < string , string > > sheetcommentmap , final boolean normalcomment ) { if ( ( newcomment != null ) && ( ! newcomment . trim ( ) . isempty ( ) ) ) {	Parse Comment To MapNormal comment : key $$ Not Normal comment: key e.g.
public static int findfirstnoncellnameposition ( string input , int startposition ) { char c ; for ( int i = startposition ; i < input . length ( ) ; i ++ ) { c = input . charat ( i ) ; if ( c != str_ && ! character . isletterordigit ( c ) ) { return i ; } } return - num_ ;	find first non letterordigit position from string.
public static string removecharsfromstring ( string inputstr , int start , int end ) { stringbuilder sb = new stringbuilder ( inputstr ) ; sb . delete ( start , end ) ;	Removes the chars from string.
public static string getexcelcolumnname ( final int pnumber ) { stringbuilder converted = new stringbuilder ( ) ;	Gets the excel column name.
public static int convertcoltoint ( final string col ) { string name = col . touppercase ( ) ; int number = num_ ; int pow = num_ ; for ( int i = name . length ( ) - num_ ; i >= num_ ; i -- ) { number += ( name . charat ( i ) - str_ + num_ ) * pow ; pow *= tieconstants . excel_letter_numbers ; } return number - num_ ; }	Convert col to int.
public static cell getcellbyreference ( final string cellref , final sheet sheet ) { cell c = null ; try { cellreference ref = new cellreference ( cellref ) ; row r = sheet . getrow ( ref . getrow ( ) ) ; if ( r != null ) { c = r . getcell ( ref . getcol ( ) , missingcellpolicy . create_null_as_blank ) ; } } catch ( exception ex ) {	Gets the cell by reference.
public static int heightunits2pixel ( final short heightunits ) { int pixels = heightunits / excel_row_height_factor ; int offsetheightunits = heightunits % excel_row_height_factor ; pixels += math . round ( ( float ) offsetheightunits / ( ( float ) excel_column_width_factor / unit_offset_length / num_ ) ) ; pixels += ( math . floor ( pixels / pixel_height_aspc_adjust ) + num_ ) * num_ ; return pixels ; }	Height units 2 pixel.
public static boolean isdate ( final string s ) { pattern pattern = pattern . compile ( date_regex_4_digit_year ) ; string [ ] terms = s . split ( str_ ) ; matcher matcher ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return bool_ ; } } pattern = pattern . compile ( date_regex_2_digit_year ) ; terms = s . split ( str_ ) ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return bool_ ; } } return bool_ ; }	Checks if is date.
public static string parsedate ( final string entry ) { pattern pattern = pattern . compile ( date_regex_4_digit_year ) ; string [ ] terms = entry . split ( str_ ) ; matcher matcher ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } pattern = pattern . compile ( date_regex_2_digit_year ) ; terms = entry . split ( str_ ) ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } return str_ ; }	Parses the date.
public static boolean isnumeric ( final string str ) { string s = str ; if ( s . startswith ( str_ ) ) { s = s . substring ( num_ ) ; } char c ; int i ; int slen = s . length ( ) ; shouldcontinueparameter spara = new shouldcontinueparameter ( bool_ , bool_ , num_ ) ; for ( i = num_ ; i < slen ; i ++ ) { c = s . charat ( i ) ; if ( c < str_ || c > str_ ) { if ( ! shouldcontinue ( c , spara ) ) { return bool_ ; } } else { if ( spara . iscommahit ( ) ) { spara . setsincelastcomma ( spara . getsincelastcomma ( ) + num_ ) ; } } } return bool_ ; }	Checks if is numeric.
private static boolean shouldcontinue ( final char c , final shouldcontinueparameter para ) { if ( c == str_ && ! para . isdecimalhit ( ) ) { para . setdecimalhit ( bool_ ) ; if ( para . iscommahit ( ) && para . getsincelastcomma ( ) != num_ ) { return bool_ ; } return bool_ ; } else if ( c == str_ && ! para . isdecimalhit ( ) ) { if ( para . iscommahit ( ) ) { if ( para . getsincelastcomma ( ) != num_ ) { return bool_ ; } para . setsincelastcomma ( num_ ) ; } para . setcommahit ( bool_ ) ; return bool_ ; } return bool_ ; }	Should continue.
public static void setobjectproperty ( final object obj , final string propertyname , final string propertyvalue , final boolean ignorenonexisting ) { try { method method = obj . getclass ( ) . getmethod ( str_ + character . touppercase ( propertyname . charat ( num_ ) ) + propertyname . substring ( num_ ) , new class [ ] { string . class } ) ; method . invoke ( obj , propertyvalue ) ; } catch ( exception e ) { string msg = str_ + propertyname + str_ + propertyvalue + str_ + obj ; if ( ignorenonexisting ) { log . info ( msg ) ; } else { log . warning ( msg ) ; throw new illegalargumentexception ( e ) ; } } }	Sets the object property.
public static int cellcompareto ( final cell thiscell , final cell othercell ) { int r = thiscell . getrowindex ( ) - othercell . getrowindex ( ) ; if ( r != num_ ) { return r ; } r = thiscell . getcolumnindex ( ) - othercell . getcolumnindex ( ) ; if ( r != num_ ) { return r ; } return num_ ; }	Cell compare to.
public static boolean insiderange ( final configrange child , final configrange parent ) { return ( ( cellcompareto ( child . getfirstrowref ( ) , parent . getfirstrowref ( ) ) >= num_ ) && ( cellcompareto ( child . getlastrowplusref ( ) , parent . getlastrowplusref ( ) ) <= num_ ) ) ; }	Inside range.
public static void clearhiddencolumns ( final sheet sheet ) { for ( row row : sheet ) { if ( row . getlastcellnum ( ) > tieconstants . max_columns_in_sheet ) { deletehiddencolumnsinrow ( row ) ; } } }	Clear hidden columns.
private static void deletehiddencolumnsinrow ( final row row ) { deletecellfromrow ( row , tieconstants . hidden_save_objects_column ) ; deletecellfromrow ( row , tieconstants . hidden_origin_row_number_column ) ; deletecellfromrow ( row , tieconstants . hidden_full_name_column ) ; }	Delete hidden columns in row.
private static void deletecellfromrow ( final row row , final int cellnum ) { cell cell = row . getcell ( cellnum ) ; if ( cell != null ) { row . removecell ( cell ) ; } }	Delete cell from row.
@ override public final void processevent ( final systemevent event ) { logger . log ( level . info , str_ , apputils . getbuildversion ( ) ) ; }	process event.
private void refreshafterstatuschanged ( final boolean oldstatus , final boolean newstatus , final int formrow , final int formcol , final facescell cell , final boolean updategui ) { if ( ! newstatus ) { cell . seterrormsg ( str_ ) ; } cell . setinvalid ( newstatus ) ; if ( updategui && ( oldstatus != newstatus ) && ( parent . getwebformclientid ( ) != null ) ) { requestcontext . getcurrentinstance ( ) . update ( parent . getwebformclientid ( ) + str_ + ( formrow ) + str_ + ( formcol ) ) ; } }	Refresh after status changed.
public boolean validatewithrowcolincurrentpage ( final int row , final int col , boolean updategui ) {	Validate with row col in current page.
private boolean validatebytiewebsheetvalidationbean ( final cell poicell , final int toprow , final int leftcol , final facescell cell , final string value , boolean updategui ) { if ( parent . gettiewebsheetvalidationbean ( ) != null ) { string errormsg = null ; string fullname = configurationutility . getfullnamefromrow ( poicell . getrow ( ) ) ; string saveattr = saveattrsutility . preparecontextandattrsforcell ( poicell , fullname , parent . getcellhelper ( ) ) ; if ( saveattr != null ) { int row = poicell . getrowindex ( ) ; int col = poicell . getcolumnindex ( ) ; errormsg = parent . gettiewebsheetvalidationbean ( ) . validate ( parent . getserialdatacontext ( ) . getdatacontext ( ) , saveattr , configurationutility . getfullnamefromrow ( poicell . getrow ( ) ) , poicell . getsheet ( ) . getsheetname ( ) , row , col , value ) ; if ( ( errormsg != null ) && ( ! errormsg . isempty ( ) ) ) { cell . seterrormsg ( errormsg ) ; refreshafterstatuschanged ( bool_ , bool_ , row - toprow , col - leftcol , cell , updategui ) ; return bool_ ; } } } return bool_ ; }	Validate by tie web sheet validation bean.
private boolean checkerrormessagefromobjectincontext ( final int formrow , final int formcol , final facescell cell , final cell poicell , final string value , final sheetconfiguration sheetconfig , boolean updategui ) { @ suppresswarnings ( str_ ) hashmap < string , tiecell > tiecells = ( hashmap < string , tiecell > ) parent . getserialdatacontext ( ) . getdatacontext ( ) . get ( str_ ) ; if ( tiecells != null ) { tiecell tiecell = tiecells . get ( cellutility . getskeyfrompoicell ( poicell ) ) ; if ( tiecell != null && tiecell . getcontextobject ( ) != null ) { string errormethod = tiecell . getmethodstr ( ) + parent . getconfigadvancedcontext ( ) . geterrorsuffix ( ) ; string errormessage = cellcontrolsutility . getobjectpropertyvalue ( tiecell . getcontextobject ( ) , errormethod , bool_ ) ; if ( errormessage != null && ! errormessage . isempty ( ) ) { cell . seterrormsg ( errormessage ) ; log . log ( level . info , str_ , new object [ ] { poicell . getsheet ( ) . getsheetname ( ) , poicell . getrowindex ( ) , poicell . getcolumnindex ( ) , errormessage } ) ; refreshafterstatuschanged ( bool_ , bool_ , formrow , formcol , cell , updategui ) ; return bool_ ; } } } return bool_ ; }	Check error message from object in context.
private boolean validateallrulesforsinglecell ( final int formrow , final int formcol , final facescell cell , final cell poicell , final string value , final sheetconfiguration sheetconfig , final list < cellformattributes > cellattributes , boolean updategui ) { sheet sheet1 = parent . getwb ( ) . getsheet ( sheetconfig . getsheetname ( ) ) ; for ( cellformattributes attr : cellattributes ) { boolean pass = dovalidation ( value , attr , poicell . getrowindex ( ) , poicell . getcolumnindex ( ) , sheet1 ) ; if ( ! pass ) { string errmsg = attr . getmessage ( ) ; if ( errmsg == null ) { errmsg = tieconstants . defalt_msg_invalid_input ; } cell . seterrormsg ( errmsg ) ; log . log ( level . info , str_ , new object [ ] { poicell . getsheet ( ) . getsheetname ( ) , poicell . getrowindex ( ) , poicell . getcolumnindex ( ) , errmsg } ) ; refreshafterstatuschanged ( bool_ , bool_ , formrow , formcol , cell , updategui ) ; return bool_ ; } } return bool_ ; }	Validate all rules for single cell.
private boolean dovalidation ( final object value , final cellformattributes attr , final int rowindex , final int colindex , final sheet sheet ) { boolean pass ; string attrvalue = attr . getvalue ( ) ; attrvalue = attrvalue . replace ( str_ , value . tostring ( ) + str_ ) . replace ( str_ , rowindex + str_ ) . replace ( str_ , colindex + str_ ) . replace ( str_ , sheet . getsheetname ( ) ) ; attrvalue = configurationutility . replaceexpressionwithcellvalue ( attrvalue , rowindex , sheet ) ; if ( attrvalue . contains ( tieconstants . el_start ) ) { object returnobj = facesutility . evaluateexpression ( attrvalue , object . class ) ; attrvalue = returnobj . tostring ( ) ; pass = boolean . parseboolean ( attrvalue ) ; } else { pass = parent . getcellhelper ( ) . evalboolexpression ( attrvalue ) ; } return pass ; }	Do validation.
public final boolean validatecell ( final uicomponent target ) { int [ ] rowcol = cellutility . getrowcolfromcomponentattributes ( target ) ; int row = rowcol [ num_ ] ; int col = rowcol [ num_ ] ; return validatewithrowcolincurrentpage ( row , col , bool_ ) ; }	Validate cell.
public final boolean validatecurrentpage ( ) { boolean allpass = bool_ ; int top = parent . getcurrent ( ) . getcurrenttoprow ( ) ; for ( int irow = num_ ; irow < parent . getbodyrows ( ) . size ( ) ; irow ++ ) { if ( ! validaterowincurrentpage ( irow + top , bool_ ) ) { allpass = bool_ ; } } return allpass ; }	Validate current page.
public final boolean validaterowincurrentpage ( final int irow , final boolean updategui ) { sheetconfiguration sheetconfig = parent . getsheetconfigmap ( ) . get ( parent . getcurrent ( ) . getcurrenttabname ( ) ) ; return this . validaterow ( irow , sheetconfig , updategui ) ; }	Validate row in current page.
private boolean validaterow ( final int irow , final sheetconfiguration sheetconfig , boolean updategui ) { boolean pass = bool_ ; if ( sheetconfig == null ) { return pass ; } int top = sheetconfig . getbodycellrange ( ) . gettoprow ( ) ; list < facescell > cellrow = parent . getbodyrows ( ) . get ( irow - top ) . getcells ( ) ; for ( int index = num_ ; index < cellrow . size ( ) ; index ++ ) { facescell fcell = cellrow . get ( index ) ; if ( ( fcell != null ) && ( ! validatewithrowcolincurrentpage ( irow , fcell . getcolumnindex ( ) , updategui ) ) ) { pass = bool_ ; } } return pass ; }	Validate row.
private void refreshcachedcellsincurrentpage ( final facescontext facescontext , final string tblname ) {	Refresh cached cells in current page.
private void refreshcachedcellsinrow ( final string tblname , final int top , final int left , final int i ) { facesrow datarow = parent . getbodyrows ( ) . get ( i ) ; int isize = datarow . getcells ( ) . size ( ) ; for ( int index = num_ ; index < isize ; index ++ ) { facescell fcell = datarow . getcells ( ) . get ( index ) ; cell poicell = parent . getcellhelper ( ) . getpoicellwithrowcolfromcurrentpage ( i + top , index + left ) ; if ( poicell != null ) { parent . gethelper ( ) . getwebsheetloader ( ) . refreshcachedcell ( tblname , i , index , poicell , fcell ) ; } } }	Refresh cached cells in row.
public void setsubmitmodeinview ( final boolean fullflag ) { if ( facescontext . getcurrentinstance ( ) != null ) { map < string , object > viewmap = facescontext . getcurrentinstance ( ) . getviewroot ( ) . getviewmap ( ) ; if ( viewmap != null ) { boolean flag = ( boolean ) viewmap . get ( tieconstants . submitmode ) ; if ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) { viewmap . put ( tieconstants . submitmode , fullflag ) ; } } } }	set submit mode flag with javascript for holding in client side.
public boolean prevalidation ( ) { string currenttabname = parent . getcurrent ( ) . getcurrenttabname ( ) ; string tabname = null ; string firstinvalidtabname = null ; boolean reload = bool_ ; for ( map . entry < string , sheetconfiguration > entry : parent . getsheetconfigmap ( ) . entryset ( ) ) { tabname = entry . getkey ( ) ;	triggered validation process before actions like save or submit.
public final void clear ( ) { if ( this . templatecommentmap != null ) { this . templatecommentmap . clear ( ) ; } if ( this . celldatepattern != null ) { this . celldatepattern . clear ( ) ; } if ( this . cellinputattributes != null ) { this . cellinputattributes . clear ( ) ; } if ( this . cellinputtype != null ) { this . cellinputtype . clear ( ) ; } if ( this . cellselectitemsattributes != null ) { this . cellselectitemsattributes . clear ( ) ; } }	clear all the related maps.
private void loadheaderrows ( final sheetconfiguration sheetconfig , final map < string , cellrangeaddress > cellrangemap , final list < string > skippedregioncells ) { int top = sheetconfig . getheadercellrange ( ) . gettoprow ( ) ; int bottom = sheetconfig . getheadercellrange ( ) . getbottomrow ( ) ; int left = sheetconfig . getheadercellrange ( ) . getleftcol ( ) ; int right = sheetconfig . getheadercellrange ( ) . getrightcol ( ) ; string sheetname = sheetconfig . getsheetname ( ) ; sheet sheet1 = parent . getwb ( ) . getsheet ( sheetname ) ; int totalwidth = cellstyleutility . calctotalwidth ( sheet1 , left , right , websheetutility . pixel2widthunits ( parent . getlinenumbercolumnwidth ( ) + parent . getaddrowcolumnwidth ( ) ) ) ; rangebuildref rangebuildref = new rangebuildref ( left , right , totalwidth , sheet1 ) ; if ( sheetconfig . isfixedwidthstyle ( ) ) { parent . settablewidthstyle ( str_ + websheetutility . widthunits2pixel ( totalwidth ) + str_ ) ; } parent . setlinenumbercolumnwidthstyle ( getwidthstyle ( websheetutility . pixel2widthunits ( parent . getlinenumbercolumnwidth ( ) ) , totalwidth ) ) ; parent . setaddrowcolumnwidthstyle ( str_ + parent . getaddrowcolumnwidth ( ) + str_ ) ; parent . getheaderrows ( ) . clear ( ) ; if ( top < num_ ) {	Load header rows.
private list < headercell > loadheaderrowwithoutconfigurationtab ( final rangebuildref rangebuildref , final boolean rendered ) { int firstcol = rangebuildref . getleft ( ) ; int lastcol = rangebuildref . getright ( ) ; double totalwidth = ( double ) rangebuildref . gettotalwidth ( ) ; sheet sheet1 = rangebuildref . getsheet ( ) ; list < headercell > headercells = new arraylist < > ( ) ; for ( int i = firstcol ; i <= lastcol ; i ++ ) { if ( ! sheet1 . iscolumnhidden ( i ) ) { string style = getheadercolumnstyle ( parent . getwb ( ) , null , sheet1 . getcolumnwidth ( i ) , totalwidth ) ; headercells . add ( new headercell ( str_ , str_ , style , style , websheetutility . getexcelcolumnname ( i ) , rendered , bool_ ) ) ; } } filltomaxcolumns ( headercells ) ; return headercells ; }	Load header row without configuration tab.
private void filltomaxcolumns ( final list < headercell > headercells ) { if ( headercells . size ( ) < parent . getmaxcolcounts ( ) ) { int fills = parent . getmaxcolcounts ( ) - headercells . size ( ) ; for ( int s = num_ ; s < fills ; s ++ ) { headercells . add ( new headercell ( str_ , str_ , str_ , str_ , str_ , bool_ , bool_ ) ) ; } } }	Fill to max columns.
private string getheadercolumnstyle ( final workbook wb , final cell cell , final double colwidth , final double totalwidth ) { string columnstyle = str_ ; if ( cell != null ) { columnstyle += cellstyleutility . getcellstyle ( wb , cell , str_ ) + cellstyleutility . getcellfontstyle ( wb , cell ) ;	Gets the header column style.
private string getwidthstyle ( final double colwidth , final double totalwidth ) { double percentage = facesutility . round ( tieconstants . cell_format_percentage_value * colwidth / totalwidth , num_ ) ; return str_ + percentage + tieconstants . cell_format_percentage_symbol + str_ ; }	Gets the width style.
private string getcolumnwidthstyle ( final sheet sheet1 , final map < string , cellrangeaddress > cellrangemap , final string cellindex , final int cindex , final double totalwidth ) { cellrangeaddress caddress = cellrangemap . get ( cellindex ) ; double colwidth ;	Gets the column width style.
private void inittabs ( ) { parent . settabs ( new arraylist < tabmodel > ( ) ) ; if ( parent . getsheetconfigmap ( ) != null ) { for ( string key : parent . getsheetconfigmap ( ) . keyset ( ) ) { parent . gettabs ( ) . add ( new tabmodel ( str_ + key , key , str_ ) ) ; } } }	Inits the tabs.
private void loaddata ( ) { if ( parent . getserialdatacontext ( ) . getdatacontext ( ) == null ) {	load data process. unfinished.
private void refreshdataforrow ( row row ) { if ( row == null ) { return ; } string saveattrlist = saveattrsutility . getsaveattrlistfromrow ( row ) ; if ( saveattrlist != null ) { string [ ] saveattrs = saveattrlist . split ( str_ ) ; for ( string fullsaveattr : saveattrs ) { refreshdataforcell ( row , fullsaveattr ) ; } } }	Refresh data for row.
private void refreshdataforcell ( row row , string fullsaveattr ) { if ( fullsaveattr != null ) { try { string fullname = configurationutility . getfullnamefromrow ( row ) ; if ( fullname != null ) { parent . getcellhelper ( ) . restoredatacontext ( fullname ) ; saveattrsutility . refreshsheetrowfromcontext ( parent . getserialdatacontext ( ) . getdatacontext ( ) , fullsaveattr , row , parent . getexpengine ( ) ) ; } } catch ( exception ex ) { log . log ( level . severe , str_ + fullsaveattr + str_ + ex . getmessage ( ) , ex ) ; } } }	refresh data for single cell.
public final int findtabindexwithname ( final string tabname ) { for ( int i = num_ ; i < parent . gettabs ( ) . size ( ) ; i ++ ) { if ( parent . gettabs ( ) . get ( i ) . gettitle ( ) . equalsignorecase ( tabname ) ) { return i ; } } return - num_ ; }	Find tab index with name.
public final void loadworksheet ( final string tabname ) { prepareworkshee ( tabname ) ; parent . getvalidationhandler ( ) . validatecurrentpage ( ) ; createdynamiccolumns ( tabname ) ;	Load work sheet.
public final void prepareworkshee ( final string tabname ) { int tabindex = findtabindexwithname ( tabname ) ; if ( parent . getwebformtabview ( ) != null ) { parent . getwebformtabview ( ) . setactiveindex ( tabindex ) ; } parent . getcurrent ( ) . setcurrenttabname ( tabname ) ; string sheetname = parent . getsheetconfigmap ( ) . get ( tabname ) . getsheetname ( ) ; sheet sheet1 = parent . getwb ( ) . getsheet ( sheetname ) ; parent . getwb ( ) . setactivesheet ( parent . getwb ( ) . getsheetindex ( sheet1 ) ) ; sheetconfiguration sheetconfig = parent . getsheetconfigmap ( ) . get ( tabname ) ; parent . setmaxrowsperpage ( parent . getsheetconfigmap ( ) . get ( tabname ) . getmaxrowperpage ( ) ) ; parent . setbodyallowaddrows ( parent . getsheetconfigmap ( ) . get ( tabname ) . isbodyallowaddrows ( ) ) ;	prepare worksheet for loading.this only load at backend without refresh gui.
private void setdatatablepage ( final int first ) { if ( parent . getwebformclientid ( ) != null ) { final datatable d = ( datatable ) facescontext . getcurrentinstance ( ) . getviewroot ( ) . findcomponent ( parent . getwebformclientid ( ) ) ; if ( d != null ) { d . setfirst ( first ) ; } } }	Sets the data table page.
private void setuprowinfo ( final facesrow facesrow , final sheet sheet1 , final row row , final int rowindex , final boolean allowadd ) { facesrow . setallowadd ( allowadd ) ; if ( row != null ) { facesrow . setrendered ( ! row . getzeroheight ( ) ) ; facesrow . setrowheight ( row . getheight ( ) ) ; int rownum = configurationutility . getoriginalrownuminhiddencolumn ( row ) ; facesrow . setoriginrowindex ( rownum ) ; } else { facesrow . setrendered ( bool_ ) ; facesrow . setrowheight ( sheet1 . getdefaultrowheight ( ) ) ; facesrow . setoriginrowindex ( rowindex ) ; } }	Setup row info.
private void loadbodyrows ( final sheetconfiguration sheetconfig , final map < string , cellrangeaddress > cellrangemap , final list < string > skippedregioncells ) { int top = sheetconfig . getbodycellrange ( ) . gettoprow ( ) ; int bottom = cellutility . getbodybottomfromconfig ( sheetconfig ) ; int left = sheetconfig . getbodycellrange ( ) . getleftcol ( ) ; int right = sheetconfig . getbodycellrange ( ) . getrightcol ( ) ; string sheetname = sheetconfig . getsheetname ( ) ; sheet sheet1 = parent . getwb ( ) . getsheet ( sheetname ) ; parent . getbodyrows ( ) . clear ( ) ; clearcache ( ) ; for ( int i = top ; i <= bottom ; i ++ ) { parent . getbodyrows ( ) . add ( assemblefacesbodyrow ( i , sheet1 , left , right , sheetconfig , cellrangemap , skippedregioncells ) ) ; } sheetconfig . setbodypopulated ( bool_ ) ; parent . getcurrent ( ) . setcurrenttoprow ( top ) ; parent . getcurrent ( ) . setcurrentleftcolumn ( left ) ; }	Load body rows.
public final void refreshcachedcell ( final string tblname , final int i , final int index , final cell cell , final facescell fcell ) { if ( ( cell != null ) && ( cell . getcelltypeenum ( ) == celltype . formula ) && ( tblname != null ) ) { try { processrefreshcell ( tblname , i , index , cell , fcell ) ; } catch ( exception ex ) { log . log ( level . severe , str_ + ex . getlocalizedmessage ( ) , ex ) ; } } }	Refresh cached cell.
private void processrefreshcell ( final string tblname , final int i , final int index , final cell cell , final facescell fcell ) { string newvalue = cellutility . getcellvaluewithformat ( cell , parent . getformulaevaluator ( ) , parent . getdataformatter ( ) ) ; if ( parent . getcachedcells ( ) . isvaluechanged ( cell , newvalue ) ) { if ( fcell . ishassaveattr ( ) ) { parent . getcellhelper ( ) . savedataincontext ( cell , newvalue ) ; } requestcontext . getcurrentinstance ( ) . update ( tblname + str_ + i + str_ + index ) ; parent . getcachedcells ( ) . put ( cell , celltype . formula ) ; } }	Process refresh cell.
private void createdynamiccolumns ( final string tabname ) { sheetconfiguration sheetconfig = parent . getsheetconfigmap ( ) . get ( tabname ) ; int left = sheetconfig . getbodycellrange ( ) . getleftcol ( ) ; int right = sheetconfig . getbodycellrange ( ) . getrightcol ( ) ; parent . getcolumns ( ) . clear ( ) ; for ( int i = left ; i <= right ; i ++ ) { parent . getcolumns ( ) . add ( str_ + ( i - left ) ) ; } }	Creates the dynamic columns.
public final void addrepeatrow ( final int rowindex ) { try { sheetconfiguration sheetconfig = parent . getsheetconfigmap ( ) . get ( parent . getcurrent ( ) . getcurrenttabname ( ) ) ; sheet sheet = parent . getwb ( ) . getsheet ( sheetconfig . getsheetname ( ) ) ; configbuildref configbuildref = new configbuildref ( parent . getwbwrapper ( ) , sheet , parent . getexpengine ( ) , parent . getcellhelper ( ) , sheetconfig . getcachedcells ( ) , parent . getcellattributesmap ( ) , sheetconfig . getfinalcommentmap ( ) ) ;	Adds the repeat row.
private void refreshbodyrowsinrange ( final int insertposition , final int length , final sheet sheet , final sheetconfiguration sheetconfig ) { map < string , cellrangeaddress > cellrangemap = configurationutility . indexmergedregion ( sheet ) ; list < string > skippedregioncells = configurationutility . skippedregioncells ( sheet ) ; int top = sheetconfig . getbodycellrange ( ) . gettoprow ( ) ; int left = sheetconfig . getbodycellrange ( ) . getleftcol ( ) ; int right = sheetconfig . getbodycellrange ( ) . getrightcol ( ) ; for ( int irow = insertposition ; irow < ( insertposition + length ) ; irow ++ ) { parent . getbodyrows ( ) . add ( irow - top , assemblefacesbodyrow ( irow , sheet , left , right , sheetconfig , cellrangemap , skippedregioncells ) ) ; } for ( int irow = insertposition + length - top ; irow < parent . getbodyrows ( ) . size ( ) ; irow ++ ) { facesrow facesrow = parent . getbodyrows ( ) . get ( irow ) ; facesrow . setrowindex ( facesrow . getrowindex ( ) + length ) ; } }	Refresh body rows in range.
public void setunsavedstatus ( final requestcontext requestcontext , final boolean statusflag ) {	Sets the unsaved status.
public final boolean isunsavedstatus ( ) { map < string , object > viewmap = facescontext . getcurrentinstance ( ) . getviewroot ( ) . getviewmap ( ) ; boolean flag = ( boolean ) viewmap . get ( tieconstants . unsavedstate ) ; if ( flag == null ) { return bool_ ; } return flag ; }	Checks if is unsaved status.
public static < t > constructor < t > commonconstructor ( class < t > type ) throws nomethodfordependency { constructor < ? > [ ] cs = type . getdeclaredconstructors ( ) ; if ( cs . length == num_ ) throw new nomethodfordependency ( raw ( type ) ) ; constructor < ? > mostparamsconstructor = null ; for ( constructor < ? > c : cs ) { if ( ! arraycontains ( c . getparametertypes ( ) , type , ( a , b ) -> a == b )	Returns the constructor with most visible visibility and longest argumentlist.
protected static void writeinputstreamtooutput ( final context context , final inputstream source , final outputstream output ) throws ioexception { bufferspool pool = beansmanager . get ( context ) . getcontainer ( ) . getbean ( bufferspool . class ) ; ioutils . transfer ( source , output , pool ) ; }	Utility method for transferring input stream to output.
protected static void writelong ( final writer writer , final long value ) throws ioexception { writer . write ( new stringbuilder ( ) . append ( value ) . append ( str_ ) . tostring ( ) ) ; }	Write next line as a long.
protected final void writestring ( final writer writer , final string line ) throws ioexception { if ( line != null ) { writer . write ( line + str_ ) ; } else { writer . write ( str_ ) ; } }	Write next line to the output.
protected void setconvertedtrafficstatstag ( final string tag ) { result . statstag = utils . gettrafficstatstag ( tag ) ; if ( config . isdebugrest ( ) ) { log . d ( tag , str_ + tag + str_ + integer . tohexstring ( result . statstag ) ) ; } }	Set network stats tag.
protected void addbitmap ( final string name , final bitmap bitmap , final string filename ) { final bitmapbinarydata bdata = new bitmapbinarydata ( ) ; bdata . setname ( name ) ; bdata . setcontentname ( filename ) ; bdata . setbitmap ( bitmap ) ; result . addbinarydata ( bdata ) ; }	Setup binary content with the bitmap.
protected void addfiledescriptor ( final string name , final assetfiledescriptor fd , final string contenttype , final string filename ) { final assetfdbinarydata bdata = new assetfdbinarydata ( ) ; bdata . setfiledescriptor ( filename , fd ) ; bdata . setname ( name ) ; bdata . setcontenttype ( contenttype ) ; result . addbinarydata ( bdata ) ; }	Setup binary content with the file descriptor.
protected parameter removeparameter ( final string name ) { if ( name == null ) { throw new illegalargumentexception ( str_ ) ; } final iterator < parameter > iter = result . simpleparameters . getchildren ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { final parameter p = iter . next ( ) ; if ( name . equals ( p . name ) ) { iter . remove ( ) ; return p ; } } return null ; }	Remove parameter with the specified name from request description.
protected baserequestbuilder < mt > addheader ( final string name , final string value ) { result . addheader ( name , value ) ; return this ; }	Add header to request description.
public void clear ( ) { final requestdescription result = this . result ; result . simpleparameters . children . clear ( ) ; result . clearbinarydata ( ) ; result . contenttype = null ; result . clearheaders ( ) ; }	Clear the builder.
protected void callplay ( final uri uri , final int volume , final bundle params ) { playing = bool_ ; paused = bool_ ; context . startservice ( createplayintent ( ) . setdata ( uri ) . putextra ( streamingplaybackservice . extra_volume , volume ) . putextra ( streamingplaybackservice . extra_track_info , params ) ) ; bind ( ) ; onplayingchanged ( ) ; preparing = bool_ ; onpreparingchanged ( ) ; }	Play the track.
protected final void bind ( ) { if ( bindrequested ) { return ; } final boolean result = context . bindservice ( createbindintent ( ) , serviceconnection , num_ ) ; if ( debug ) { log . v ( tag , str_ + result ) ; } bindrequested = result ; onbind ( result ) ; }	Bind to the streaming service.
protected final void unbind ( ) { if ( streamingplayback != null ) { droplistener ( ) ; } try { context . unbindservice ( serviceconnection ) ; } catch ( final runtimeexception e ) { if ( debug ) { log . w ( tag , str_ , e ) ; } } bindrequested = bool_ ; }	Unbind from the streaming service.
protected final void droplistener ( ) { if ( debug ) { log . v ( tag , str_ ) ; } if ( streamingplayback != null ) { try { streamingplayback . removelistener ( ) ; } catch ( final remoteexception e ) { log . e ( tag , str_ , e ) ; } bindrequested = bool_ ; } }	Drop streaming service listener.
public void storetodisk ( ) throws ioexception { if ( manager . ispresentondisk ( url ) ) { return ; } if ( ! hasallowedsize ( ) ) { ioutils . consumestream ( getremoteinputstream ( ) , manager . getbufferspool ( ) ) ; return ; } imageresult result = decodestream ( getremoteinputstream ( ) , bool_ ) ; if ( result . gettype ( ) == imagesourcetype . network && result . getbitmap ( ) != null ) {	Store image to the disk cache.If max allowed size is set image may be rescaled on disk.
public static string streamtostring ( final inputstream stream , final string charset , final bufferspool bufferspool ) throws ioexception { bytearrayoutputstream output = new bytearrayoutputstream ( ) ; transfer ( stream , output , bufferspool ) ; return new string ( output . tobytearray ( ) , charset ) ; }	Read all the bytes from input stream and convert them to a string.Input stream is closed after this method invocation.
public static string streamtostring ( final inputstream stream , final bufferspool bufferspool ) throws ioexception { return streamtostring ( stream , utf_8_name , bufferspool ) ; }	Read all the bytes from input stream and convert them to a string using UTF-8 charset.Input stream is closed after this method invocation.
@ override protected void senddata ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } out . write ( getcontent ( ) ) ; }	Writes the data to the given OutputStream.
@ override public synchronized int available ( ) throws ioexception { final inputstream localin = in ;	Returns the number of bytes that are available before this stream willblock.
@ override public void close ( ) throws ioexception { final byte [ ] localbuf = buf ; buf = null ; final inputstream localin = in ; in = null ; pool . release ( localbuf ) ; if ( localin != null ) { localin . close ( ) ; } }	Closes this stream. The source stream is closed and any resourcesassociated with it are released.
@ override public synchronized int read ( ) throws ioexception {	Reads a single byte from this stream and returns it as an integer in therange from 0 to 255.
@ override public synchronized void reset ( ) throws ioexception {	Resets this stream to the last marked location.
protected void sendstart ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } out . write ( extra_bytes ) ; out . write ( getpartboundary ( ) ) ; out . write ( crlf_bytes ) ; }	Write the start to the specified output stream.
protected void senddispositionheader ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } out . write ( content_disposition_bytes ) ; out . write ( quote_bytes ) ; out . write ( encodingutils . getasciibytes ( getname ( ) ) ) ; out . write ( quote_bytes ) ; }	Write the content disposition header to the specified output stream.
protected void sendcontenttypeheader ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } final string contenttype = getcontenttype ( ) ; if ( contenttype != null ) { out . write ( crlf_bytes ) ; out . write ( content_type_bytes ) ; out . write ( encodingutils . getasciibytes ( contenttype ) ) ; final string charset = getcharset ( ) ; if ( charset != null ) { out . write ( charset_bytes ) ; out . write ( encodingutils . getasciibytes ( charset ) ) ; } } }	Write the content type header to the specified output stream.
protected void sendtransferencodingheader ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } final string transferencoding = gettransferencoding ( ) ; if ( transferencoding != null ) { out . write ( crlf_bytes ) ; out . write ( content_transfer_encoding_bytes ) ; out . write ( encodingutils . getasciibytes ( transferencoding ) ) ; } }	Write the content transfer encoding header to the specifiedoutput stream.
protected void sendendofheader ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } out . write ( crlf_bytes ) ; out . write ( crlf_bytes ) ; }	Write the end of the header to the output stream.
protected void sendend ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } out . write ( crlf_bytes ) ; }	Write the end data to the output stream.
public static void sendparts ( final outputstream out , final part [ ] parts , final byte [ ] partboundary ) throws ioexception { if ( parts == null ) { throw new illegalargumentexception ( str_ ) ; } if ( partboundary == null || partboundary . length == num_ ) { throw new illegalargumentexception ( str_ ) ; } for ( int i = num_ ; i < parts . length ; i ++ ) {	Write all parts and the last boundary to the specified output stream.
public static long getlengthofparts ( final part [ ] parts , final byte [ ] partboundary ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } if ( parts == null ) { throw new illegalargumentexception ( str_ ) ; } long total = num_ ; for ( int i = num_ ; i < parts . length ; i ++ ) {	Gets the length of the multipart message including the given parts.
private string isredirect ( string uri ) throws urisyntaxexception , malformedurlexception {	if it is, it returns the url parameter.
private void sendnotmodified ( channelhandlercontext ctx ) { httpresponse response = new defaulthttpresponse ( http_1_1 , httpresponsestatus . not_modified ) ; setdateheader ( response ) ;	When file timestamp is the same as what the browser is sending up, send a "304 Not Modified".
private void setdateheader ( httpresponse response ) { simpledateformat dateformatter = new simpledateformat ( http_date_format , locale . us ) ; dateformatter . settimezone ( timezone . gettimezone ( http_date_gmt_timezone ) ) ; calendar time = new gregoriancalendar ( ) ; response . setheader ( httpheaders . names . date , dateformatter . format ( time . gettime ( ) ) ) ; }	Sets the Date header for the HTTP response.
private void setdateandcacheheaders ( httpresponse response , file filetocache ) { simpledateformat dateformatter = new simpledateformat ( http_date_format , locale . us ) ; dateformatter . settimezone ( timezone . gettimezone ( http_date_gmt_timezone ) ) ;	Sets the Date and Cache headers for the HTTP Response.
private void setcontenttypeheader ( httpresponse response , file file ) { mimetypesfiletypemap mimetypesmap = new mimetypesfiletypemap ( ) ; response . setheader ( httpheaders . names . content_type , mimetypesmap . getcontenttype ( file . getpath ( ) ) ) ; }	Sets the content type header for the HTTP Response.
static void closeonflush ( channel ch ) { if ( ch . isconnected ( ) ) { ch . write ( channelbuffers . empty_buffer ) . addlistener ( channelfuturelistener . close ) ; } }	Closes the specified channel after all queued write requests are flushed.
@ override protected void senddispositionheader ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( str_ , str_ ) ; } super . senddispositionheader ( out ) ; final string filename = this . source . getfilename ( ) ; if ( filename != null ) { out . write ( file_name_bytes ) ; out . write ( quote_bytes ) ; out . write ( encodingutils . getasciibytes ( filename ) ) ; out . write ( quote_bytes ) ; } }	Write the disposition header to the output stream.
@ override protected void senddata ( final outputstream out ) throws ioexception { if ( debug ) { log . v ( tag , str_ ) ; } if ( lengthofdata ( ) == num_ ) {	Write the data in "source" to the specified stream.
protected void install ( final int version ) throws ioexception { if ( bufferspool == null ) { throw new illegalstateexception ( str_ ) ; } diskcache = disklrucache . open ( ensureworkingdirectory ( ) , version , entries_count , getmaxsize ( ) ) ; oncacheinstalled ( ) ; }	Setup cache. This operation causes disk reads.
private synchronized file ensureworkingdirectory ( ) throws ioexception { file directory = getworkingdirectory ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new ioexception ( str_ + directory + str_ ) ; } } else { if ( ! directory . isdirectory ( ) ) { if ( ! directory . delete ( ) ) { throw new ioexception ( directory + str_ ) ; } if ( ! directory . mkdirs ( ) ) { throw new ioexception ( str_ + directory + str_ ) ; } } } return directory ; }	this method is synchronized in order to avoid concurrent calls to mkdir.
protected cacheresponse get ( final cacheentry requestinfo ) { if ( ! checkdiskcache ( ) ) { return null ; } final cacheentry entry = newcacheentry ( ) ; final disklrucache . snapshot snapshot = readcacheinfo ( requestinfo , entry ) ; if ( snapshot == null ) { return null ; } if ( ! entry . matches ( requestinfo ) || ! entry . canbeused ( ) ) { snapshot . close ( ) ; return null ; } hitcount . incrementandget ( ) ; final inputstream body = newbodyinputstream ( snapshot ) ; return entry . newcacheresponse ( body ) ; }	Read cache for the specified cache entry.
private inputstream newbodyinputstream ( final disklrucache . snapshot snapshot ) { return new filterinputstream ( snapshot . getinputstream ( entry_body ) ) { @ override public void close ( ) throws ioexception { snapshot . close ( ) ; super . close ( ) ; } } ; }	Returns an input stream that reads the body of a snapshot, closing thesnapshot when the stream is closed.
protected void reset ( final int width , final int height ) { bitmap bitmap = this . bitmap ;	Prepare for new width and hight.
public static websockifysslcontext getinstance ( string keystore , string password , string keypassword ) { websockifysslcontext context = singletonholder . instance_map . get ( keystore ) ; if ( context == null ) { context = new websockifysslcontext ( keystore , password , keypassword ) ; singletonholder . instance_map . put ( keystore , context ) ; } return context ; }	Returns the singleton instance for this class.
public static void validatekeystore ( string keystore , string password , string keypassword ) throws keymanagementexception , unrecoverablekeyexception , ioexception , nosuchalgorithmexception , certificateexception , keystoreexception { getsslcontext ( keystore , password , keypassword ) ; }	Validates that a keystore with the given parameters exists and can be used for an SSL context.
public scaletype replacescaletype ( final scaletype type ) { blocklayoutrequests = bool_ ; final scaletype result = getscaletype ( ) ; setscaletype ( type ) ; blocklayoutrequests = bool_ ; return result ; }	This method replaces the scale type of an image view without call to layout requests.
public pendingintent getpendingintent ( final requestbuilder < ? > requestbuilder , final int flags ) { return pendingintent . getservice ( context , num_ , getintent ( requestbuilder ) , flags ) ; }	Construct a pending intent that can be used for starting request processing.Note that after this method is executed executor of the request builder is always null.
protected void disconnect ( final urlconnection connection ) { final urlconnection http = urlconnectionwrapper . unwrap ( connection ) ; if ( http instanceof httpurlconnection ) { ( ( httpurlconnection ) http ) . disconnect ( ) ; } }	Perform disconnect actions.
public void bind ( ) { if ( serviceobject != null ) { return ; } final context context = contextref . get ( ) ; if ( context == null ) { return ; }	Create the service connection.
public void unbind ( ) { if ( serviceobject == null ) { return ; } serviceobject = null ; final context context = contextref . get ( ) ; if ( debug ) { log . v ( tag , str_ + context + str_ + getinterfaceclass ( ) ) ; } if ( context == null ) { return ; } try { context . unbindservice ( this ) ; } catch ( final exception e ) { if ( debug ) { log . e ( tag , str_ , e ) ; } } }	Destroy the service connection.
public void notifyaboutviewchanges ( ) { final t view = this . view ; if ( view != null && view instanceof imagesloadlistenerprovider ) { this . listener = ( ( imagesloadlistenerprovider ) view ) . getimagesloadlistener ( ) ; } }	Method should be called when wrapped view gets changes related to this consumer.
@ override public void channelopen ( final channelhandlercontext ctx , final channelstateevent e ) throws exception { try {	The client won't send any message so connect directly on channel open.
protected responsedata < mt > onacceptdata ( final responsedata < mt > previousdata , final responsedata < mt > responsedata ) { return responsedata ; }	Data loading has been successful, we are going to accept data.Here we can implement some accumulation logic.
@ override protected void onreset ( ) { if ( debug ) { log . v ( tag , str_ + this ) ; } super . onreset ( ) ; onstoploading ( ) ; if ( receivedresponse != null ) { onreleasedata ( receivedresponse ) ; receivedresponse = null ; } }	request to completely reset the loader.
void waitforloader ( final long time ) { try { done . await ( time , timeunit . milliseconds ) ; } catch ( final interruptedexception e ) { log . e ( tag , str_ , e ) ; } }	For testing only.
public static void settextorhide ( final textview view , final charsequence text , final int hvisibility ) { if ( textutils . isempty ( text ) ) { view . setvisibility ( hvisibility ) ; } else { view . settext ( text ) ; view . setvisibility ( view . visible ) ; } }	Set text view value or change its visibility in case of empty value.
public static void hidesoftinput ( final view textview ) { try { final inputmethodmanager imm = ( inputmethodmanager ) textview . getcontext ( ) . getsystemservice ( context . input_method_service ) ; imm . hidesoftinputfromwindow ( textview . getwindowtoken ( ) , num_ ) ; } catch ( final exception e ) { log . w ( tag , str_ , e ) ; } }	Hide soft keyboard.
public static void showsoftinput ( final view textview ) { try { final inputmethodmanager imm = ( inputmethodmanager ) textview . getcontext ( ) . getsystemservice ( context . input_method_service ) ; imm . showsoftinput ( textview , inputmethodmanager . show_forced ) ; } catch ( final exception e ) { log . w ( tag , str_ , e ) ; } }	Show soft keyboard.
public static void togglesoftinput ( final view textview ) { try { final inputmethodmanager imm = ( inputmethodmanager ) textview . getcontext ( ) . getsystemservice ( context . input_method_service ) ; imm . togglesoftinputfromwindow ( textview . getwindowtoken ( ) , num_ , num_ ) ; } catch ( final exception e ) { log . w ( tag , str_ , e ) ; } }	Toggles keyboard visibility.
public static int pixelswidth ( final displaymetrics displaymetrics , final int dip ) { final float scale = displaymetrics . density ; final float alpha = num_ ; return ( int ) ( dip * scale + alpha ) ; }	Converts device independent points to actual pixels.
@ override public void exceptioncaught ( channelhandlercontext ctx , exceptionevent e ) throws exception { canceldirectconnectiontimer ( ) ; logger . getlogger ( portunificationhandler . class . getname ( ) ) . severe ( str_ + ctx . getchannel ( ) . getremoteaddress ( ) + str_ + e . getcause ( ) . getmessage ( ) ) ; }	cancel the timer if exception is caught - prevents useless stack traces.
public boolean clearcache ( final string url ) { memcache . remove ( url ) ; try { return imagesresponsecache . deletegetentry ( url ) ; } catch ( final ioexception e ) { log . w ( tag , str_ + url , e ) ; return bool_ ; } }	Clear the cached entities.
public void populateimage ( final view view , final string url ) { final object tag = view . gettag ( ) ; imageconsumer consumer = null ; if ( tag == null ) { consumer = createimageconsumer ( view ) ; view . settag ( consumer ) ; } else { if ( ! ( tag instanceof imageconsumer ) ) { throw new illegalstateexception ( str_ + tag + str_ ) ; } consumer = ( imageconsumer ) tag ; } populateimage ( consumer , url ) ; }	Populate the requested image to the specified view.
public void cancelimageloading ( final view view ) { checkthread ( ) ; final object tag = view . gettag ( ) ; if ( tag != null && tag instanceof imageconsumer ) { cancelimageloading ( ( imageconsumer ) tag ) ; } }	Cancel image loading for a view.
protected imageconsumer createimageconsumer ( final view view ) { if ( this . consumerfactory == null ) { throw new illegalstateexception ( str_ ) ; } return consumerfactory . createconsumer ( view ) ; }	Create an image holder instance for the defined view.
protected final void setresultimage ( final imageconsumer consumer , final imageresult result , final boolean animate ) { decorateresult ( consumer , result ) ; consumer . setimage ( createdrawable ( result . getbitmap ( ) ) , animate ) ; consumer . reset ( ) ; }	It must be executed in the main thread.
private void setloadingimage ( final imageconsumer consumer ) { if ( ! consumer . skiploadingimage ( ) ) { drawable d = getloadingdrawable ( consumer ) ; if ( ! consumer . hasundefinedsize ( ) || ( d . getintrinsicwidth ( ) != num_ && d . getintrinsicheight ( ) != num_ ) ) { consumer . setloadingimage ( d ) ; } } }	Set preloader.
private void startimageloadertask ( final imageconsumer consumer , final imagerequest request ) { final string key = request . getkey ( ) ; if ( debug ) { log . d ( tag , str_ + key ) ; } imageloader loader = currentloads . get ( key ) ; if ( loader != null ) { final boolean added = loader . addtarget ( consumer ) ; if ( ! added ) { loader = null ; } } if ( loader == null ) { if ( debug ) { log . d ( tag , str_ ) ; } loader = new imageloader ( request , this ) ; if ( ! loader . addtarget ( consumer ) ) { throw new illegalstateexception ( str_ ) ; } currentloads . put ( key , loader ) ; if ( debug ) { log . d ( tag , str_ + currentloads . size ( ) ) ; } final executor executor = getimagetaskexecutor ( ) ; executor . execute ( loader . future ) ; } else if ( debug ) { log . d ( tag , str_ + key ) ; } }	Executed in the main thread.
protected void memcacheimage ( final string url , final bitmap bitmap ) { if ( debug ) { log . d ( tag , str_ + url ) ; } memcache . putelement ( url , bitmap ) ; }	Add image to memory cache.
public void release ( final byte [ ] buffer ) { if ( buffer == null ) { return ; } final int capacity = buffer . length ; if ( capacity == num_ ) { return ; } synchronized ( lock ) { list < object > blist = buffers . get ( capacity ) ; if ( blist == null ) { blist = new linkedlist < object > ( ) ; buffers . put ( capacity , blist ) ; } blist . add ( buffer ) ; usedbufferscount -- ; } }	Recycle the buffer.
protected void onurlconnectionprepared ( final context context , final urlconnection urlconnection ) { if ( contenttype != null ) { urlconnection . addrequestproperty ( str_ , contenttype ) ; } if ( contentlanguage != null ) { urlconnection . addrequestproperty ( str_ , contentlanguage ) ; } urlconnection . addrequestproperty ( str_ , ioutils . encoding_gzip ) ; urlconnection . addrequestproperty ( str_ , builduseragent ( context ) ) ; if ( headers != null ) { for ( string name : headers . keyset ( ) ) { urlconnection . addrequestproperty ( name , headers . getstring ( name ) ) ; } } }	A good place to set custom request headers.
public simplerequestbuilder < mt > addparam ( final string name , final string value ) { addsimpleparameter ( name , value ) ; return this ; }	Add string parameter.
private void connectwithworkaround ( ) throws ioexception { if ( build . version . sdk_int > build . version_codes . gingerbread_mr1 ) { super . connect ( ) ; return ; } urlconnection coreconnection = urlconnectionwrapper . unwrap ( getcore ( ) ) ; if ( coreconnection instanceof httpsurlconnection ) {	XXX on 2.3 we get NP exception in case of HTTPs connection and cache.
public static string getmd5 ( final string text ) { try { final messagedigest md = messagedigest . getinstance ( str_ ) ; final byte [ ] utf8bytes = text . getbytes ( utf_8_name ) ; md . update ( utf8bytes , num_ , utf8bytes . length ) ; final byte [ ] md5hash = md . digest ( ) ; final int radix = num_ ; final int length = num_ ; final stringbuilder result = new stringbuilder ( length ) . append ( new biginteger ( num_ , md5hash ) . tostring ( radix ) ) ; final int zerobeginlen = length - result . length ( ) ; if ( zerobeginlen > num_ ) { final char [ ] zerobegin = new char [ zerobeginlen ] ; arrays . fill ( zerobegin , character . fordigit ( num_ , radix ) ) ; result . insert ( num_ , zerobegin ) ; } return result . tostring ( ) ; } catch ( final nosuchalgorithmexception | unsupportedencodingexception e ) { throw new assertionerror ( e ) ; } }	Calculate 32 bytes length MD5 digest.
public static string stringfor ( int n ) { switch ( n ) { case cublas_gemm_default : return str_ ; case cublas_gemm_algo0 : return str_ ; case cublas_gemm_algo1 : return str_ ; case cublas_gemm_algo2 : return str_ ; case cublas_gemm_algo3 : return str_ ; case cublas_gemm_algo4 : return str_ ; case cublas_gemm_algo5 : return str_ ; case cublas_gemm_algo6 : return str_ ; case cublas_gemm_algo7 : return str_ ; case cublas_gemm_algo8 : return str_ ; case cublas_gemm_algo9 : return str_ ; case cublas_gemm_algo10 : return str_ ; case cublas_gemm_algo11 : return str_ ; case cublas_gemm_algo12 : return str_ ; case cublas_gemm_algo13 : return str_ ; case cublas_gemm_algo14 : return str_ ; case cublas_gemm_algo15 : return str_ ; case cublas_gemm_algo16 : return str_ ; case cublas_gemm_algo17 : return str_ ; case cublas_gemm_algo18 : return str_ ; case cublas_gemm_algo19 : return str_ ; case cublas_gemm_algo20 : return str_ ; case cublas_gemm_algo21 : return str_ ; case cublas_gemm_algo22 : return str_ ; case cublas_gemm_algo23 : return str_ ; case cublas_gemm_default_tensor_op : return str_ ; case cublas_gemm_algo0_tensor_op : return str_ ; case cublas_gemm_algo1_tensor_op : return str_ ; case cublas_gemm_algo2_tensor_op : return str_ ; case cublas_gemm_algo3_tensor_op : return str_ ; case cublas_gemm_algo4_tensor_op : return str_ ; case cublas_gemm_algo5_tensor_op : return str_ ; case cublas_gemm_algo6_tensor_op : return str_ ; case cublas_gemm_algo7_tensor_op : return str_ ; case cublas_gemm_algo8_tensor_op : return str_ ; case cublas_gemm_algo9_tensor_op : return str_ ; case cublas_gemm_algo10_tensor_op : return str_ ; case cublas_gemm_algo11_tensor_op : return str_ ; case cublas_gemm_algo12_tensor_op : return str_ ; case cublas_gemm_algo13_tensor_op : return str_ ; case cublas_gemm_algo14_tensor_op : return str_ ; } return str_ + n ; }	Returns a string representation of the given constant.
public static string stringfor ( int n ) { switch ( n ) { case cublas_status_success : return str_ ; case cublas_status_not_initialized : return str_ ; case cublas_status_alloc_failed : return str_ ; case cublas_status_invalid_value : return str_ ; case cublas_status_arch_mismatch : return str_ ; case cublas_status_mapping_error : return str_ ; case cublas_status_execution_failed : return str_ ; case cublas_status_internal_error : return str_ ; case cublas_status_not_supported : return str_ ; case jcublas_status_internal_error : return str_ ; } return str_ + n ; }	Returns the String identifying the given cublasStatus.
private static int checkresult ( int result ) { if ( exceptionsenabled && result != cublasstatus . cublas_status_success ) { throw new cudaexception ( cublasstatus . stringfor ( result ) ) ; } return result ; }	If the given result is different to cublasStatus.CUBLAS_STATUS_SUCCESSand exceptions have been enabled, this method will throw aCudaException with an error message that corresponds to thegiven result code.
private static void checkresultblas ( ) { if ( exceptionsenabled ) { lastresult = cublasgeterrornative ( ) ; if ( lastresult != cublasstatus . cublas_status_success ) { throw new cudaexception ( cublasstatus . stringfor ( lastresult ) ) ; } } }	Obtain the current CUBLAS status by calling cublasGetErrorNative,and store the result as the lastResult.
public void addlexeme ( int lexemeid ) { int count = num_ ; if ( lexemefrequency . get ( lexemeid ) != null ) count = lexemefrequency . get ( lexemeid ) + num_ ; lexemefrequency . put ( lexemeid , count ) ; }	Add one occurrence of one lexeme.
public void addending ( int endingid ) { int count = num_ ; if ( endingfrequency . get ( endingid ) != null ) count = endingfrequency . get ( endingid ) + num_ ; endingfrequency . put ( endingid , count ) ; }	Add one occurrence of one ending.
public double getestimate ( attributevalues wordform ) { double estimate = num_ ; string endingidstr = wordform . getvalue ( attributenames . i_endingid ) ; int endingid = ( endingidstr == null ) ? - num_ : integer . parseint ( endingidstr ) ; if ( endingfrequency . get ( endingid ) != null ) estimate += endingfrequency . get ( endingid ) ; string lexemeidstr = wordform . getvalue ( attributenames . i_lexemeid ) ; int lexemeid = ( lexemeidstr == null ) ? - num_ : integer . parseint ( lexemeidstr ) ; if ( lexemefrequency . get ( lexemeid ) != null ) estimate += lexemefrequency . get ( lexemeid ) * lexemeweight ; return estimate ; }	Cumulative frequency estimate for given wordform.
public void longdescription ( printstream out ) { out . println ( this . token + str_ ) ; for ( string s : this . attributes . keyset ( ) ) { out . println ( s + str_ + attributes . get ( s ) ) ; } }	For debugging purposes only.
private static void verifyandsetkamolsattribute ( attributevalues avs , stringbuilder tag , int index , char tagvalue , string attribute , string attributevalue ) { if ( avs . ismatchingstrong ( attribute , attributevalue ) ) tag . setcharat ( index , tagvalue ) ; }	Check if attribute-value structure has attribute matching givenattributeValue and if so then set corresponding position in the tag.
public static string removekamolsmarkupformating ( string tag ) { string result = str_ ; if ( ! tag . contains ( str_ ) ) return str_ ; int depth = num_ ; int commas = num_ ; for ( char c : tag . tochararray ( ) ) { if ( c == str_ ) depth ++ ; if ( c == str_ ) depth -- ; if ( depth == num_ && c == str_ ) commas ++ ; if ( commas == num_ ) result = result + c ; } result = result . replaceall ( str_ , str_ ) ; result = result . replaceall ( str_ , str_ ) ; return result ; }	Remove formating from Kamols-style tag.
public list < metricdata > get ( ) throws requestexception , unauthorizedexception { httpresponse < string > response ; try { response = unirest . get ( this . appdurl + str_ + appname + str_ ) . header ( str_ , str_ ) . basicauth ( this . appdusername , this . appdpassword ) . querystring ( getquerystring ( ) ) . querystring ( str_ , str_ ) . asstring ( ) ; } catch ( unirestexception e ) { throw new requestexception ( str_ , e ) ; } if ( response == null ) { throw new requestexception ( str_ ) ; } switch ( response . getstatus ( ) ) { case num_ : { return process ( new jsonnode ( response . getbody ( ) ) ) ; } case num_ : { throw new unauthorizedexception ( str_ ) ; } default : { throw new requestexception ( str_ + response . getstatus ( ) ) ; } } }	Perform retrieval of metrics from AppDynamics using specified parameters.
protected map < string , object > getquerystring ( ) { map < string , object > qs = new hashmap < > ( ) ; if ( timeparams != null ) { qs . put ( str_ , timeparams . type ) ; if ( timeparams . duration > num_ ) { qs . put ( str_ , timeparams . duration ) ; } if ( timeparams . starttime > num_ ) { qs . put ( str_ , timeparams . starttime ) ; } if ( timeparams . endtime > num_ ) { qs . put ( str_ , timeparams . endtime ) ; } } qs . put ( str_ , bool_ ) ; if ( metricpath != null ) { qs . put ( str_ , metricpath ) ; } return qs ; }	Generate querystring for the request.
protected list < metricdata > process ( jsonnode node ) { jsonarray dataarray = node . getarray ( ) ; list < metricdata > list = new linkedlist < > ( ) ; for ( int i = num_ ; i < dataarray . length ( ) ; i ++ ) { jsonobject data = dataarray . getjsonobject ( i ) ; metricdata metricdata = new metricdata ( data . getstring ( str_ ) , data . getlong ( str_ ) , data . getstring ( str_ ) , data . getstring ( str_ ) ) ; list . add ( metricdata ) ; jsonarray valuearray = data . getjsonarray ( str_ ) ; for ( int j = num_ ; j < valuearray . length ( ) ; j ++ ) { jsonobject value = valuearray . getjsonobject ( j ) ; metricdata . metricvalues . add ( new metricvalue ( value . getlong ( str_ ) , value . getlong ( str_ ) , value . getlong ( str_ ) , value . getlong ( str_ ) , value . getlong ( str_ ) , value . getlong ( str_ ) ) ) ; } } return list ; }	Process the JSON response from the request.
public static list < appinfo > parseinfo ( string jsonstring ) throws ioexception { objectmapper mapper = new objectmapper ( ) ; return mapper . readvalue ( jsonstring , new typereference < list < appinfo > > ( ) { } ) ; }	Parse JSON String as configurations that the task should query from AppDynamics.
public static connectionconfig getconnectionconfig ( ) { boolean isvalid = bool_ ; string appdusername = getpropertyorenv ( str_ , str_ ) ; if ( stringutils . isempty ( appdusername ) ) { log . error ( str_ ) ; isvalid = bool_ ; } string appdpassword = getpropertyorenv ( str_ , str_ ) ; if ( stringutils . isempty ( appdpassword ) ) { log . error ( str_ ) ; isvalid = bool_ ; } string appdurl = getpropertyorenv ( str_ , str_ ) ; if ( stringutils . isempty ( appdurl ) ) { log . error ( str_ ) ; isvalid = bool_ ; } string fxtoken = getpropertyorenv ( str_ , str_ ) ; if ( stringutils . isempty ( fxtoken ) ) { log . error ( str_ ) ; isvalid = bool_ ; } if ( isvalid ) { return new connectionconfig ( appdusername , appdpassword , appdurl , fxtoken ) ; } else { return null ; } }	Retrieve configurations by looking up in property param first then environment variable.
public void perform ( list < appinfo > apps , metricdatarequest . timeparams timeparams ) { list < signalfxprotocolbuffers . datapoint > datapoints = new linkedlist < > ( ) ; for ( appinfo app : apps ) { datarequest . setappname ( app . name ) ; for ( metricinfo metricinfo : app . metrics ) { datarequest . settimeparams ( timeparams ) ; datarequest . setmetricpath ( metricinfo . metricpathquery ) ; list < metricdata > metricdatalist ; try { metricdatalist = datarequest . get ( ) ; } catch ( requestexception e ) {	Perform reading and reporting of AppDynamics metrics to SignalFx.
@ nonnull public static genericodereader < com . helger . genericode . v04 . codelistdocument > gc04codelist ( ) { return new genericodereader < > ( egenericodedocumenttype . gc04_code_list , com . helger . genericode . v04 . codelistdocument . class ) ; }	Create a reader builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericodereader < com . helger . genericode . v04 . codelistsetdocument > gc04codelistset ( ) { return new genericodereader < > ( egenericodedocumenttype . gc04_code_list_set , com . helger . genericode . v04 . codelistsetdocument . class ) ; }	Create a reader builder for com.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericodereader < com . helger . genericode . v04 . columnsetdocument > gc04columnset ( ) { return new genericodereader < > ( egenericodedocumenttype . gc04_column_set , com . helger . genericode . v04 . columnsetdocument . class ) ; }	Create a reader builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericodereader < com . helger . genericode . v10 . codelistdocument > gc10codelist ( ) { return new genericodereader < > ( egenericodedocumenttype . gc10_code_list , com . helger . genericode . v10 . codelistdocument . class ) ; }	Create a reader builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericodereader < com . helger . genericode . v10 . codelistsetdocument > gc10codelistset ( ) { return new genericodereader < > ( egenericodedocumenttype . gc10_code_list_set , com . helger . genericode . v10 . codelistsetdocument . class ) ; }	Create a reader builder for com.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericodereader < com . helger . genericode . v10 . columnsetdocument > gc10columnset ( ) { return new genericodereader < > ( egenericodedocumenttype . gc10_column_set , com . helger . genericode . v10 . columnsetdocument . class ) ; }	Create a reader builder for com.helger.genericode.v10.ColumnSetDocument.
@ nonnull public static string getcolumnelementid ( @ nonnull final object acolumnelement ) { if ( acolumnelement instanceof columnref ) return ( ( columnref ) acolumnelement ) . getid ( ) ; if ( acolumnelement instanceof column ) return ( ( column ) acolumnelement ) . getid ( ) ; if ( acolumnelement instanceof key ) { final list < keycolumnref > akeycolumnrefs = ( ( key ) acolumnelement ) . getcolumnref ( ) ; final keycolumnref akeycolumnref = collectionhelper . getfirstelement ( akeycolumnrefs ) ; if ( akeycolumnref == null ) throw new illegalargumentexception ( str_ ) ; final object aref = akeycolumnref . getref ( ) ; if ( aref instanceof column ) return ( ( column ) aref ) . getid ( ) ; throw new illegalargumentexception ( str_ + aref + str_ + classhelper . getsafeclassname ( aref ) ) ; } throw new illegalargumentexception ( str_ + acolumnelement + str_ + classhelper . getsafeclassname ( acolumnelement ) ) ; }	Get the ID of the passed column element.
@ nullable public static string getrowvalue ( @ nonnull final row arow , @ nonnull final string scolumnid ) { for ( final value avalue : arow . getvalue ( ) ) { final string sid = getcolumnelementid ( avalue . getcolumnref ( ) ) ; if ( sid . equals ( scolumnid ) ) { final simplevalue asimplevalue = avalue . getsimplevalue ( ) ; return asimplevalue != null ? asimplevalue . getvalue ( ) : null ; } } return null ; }	Get the value of a column identified by an ID within a specified row.
@ nullable public static column getcolumnofid ( @ nonnull final columnset acolumnset , @ nullable final string sid ) { if ( sid != null ) for ( final column acolumn : getallcolumns ( acolumnset ) ) if ( acolumn . getid ( ) . equals ( sid ) ) return acolumn ; return null ; }	Get the column with the specified ID.
public static void getallkeyids ( @ nonnull final columnset acolumnset , @ nonnull final collection < string > atarget ) { collectionhelper . findall ( acolumnset . getkeychoice ( ) , o -> o instanceof key , o -> atarget . add ( ( ( key ) o ) . getid ( ) ) ) ; }	Get the IDs of all contained keys.
@ nullable public static key getkeyofid ( @ nonnull final columnset acolumnset , @ nullable final string sid ) { if ( sid != null ) for ( final key akey : getallkeys ( acolumnset ) ) if ( akey . getid ( ) . equals ( sid ) ) return akey ; return null ; }	Get the key with the specified ID.
public static boolean iskeycolumn ( @ nonnull final columnset acolumnset , @ nullable final string scolumnid ) { if ( scolumnid != null ) for ( final key akey : getallkeys ( acolumnset ) ) for ( final keycolumnref acolumnref : akey . getcolumnref ( ) ) if ( acolumnref . getref ( ) instanceof column ) if ( ( ( column ) acolumnref . getref ( ) ) . getid ( ) . equals ( scolumnid ) ) return bool_ ; return bool_ ; }	Check if the passed column ID is a key column in the specified column set.
@ nonnull public static column createcolumn ( @ nonnull @ nonempty final string scolumnid , @ nonnull final usetype eusetype , @ nonnull @ nonempty final string sshortname , @ nullable final string slongname , @ nonnull @ nonempty final string sdatatype ) { valueenforcer . notempty ( scolumnid , str_ ) ; valueenforcer . notnull ( eusetype , str_ ) ; valueenforcer . notempty ( sshortname , str_ ) ; valueenforcer . notempty ( sdatatype , str_ ) ; final column acolumn = s_afactory . createcolumn ( ) ; acolumn . setid ( scolumnid ) ; acolumn . setuse ( eusetype ) ; acolumn . setshortname ( createshortname ( sshortname ) ) ; if ( stringhelper . hastext ( slongname ) ) acolumn . getlongname ( ) . add ( createlongname ( slongname ) ) ; final data adata = s_afactory . createdata ( ) ; adata . settype ( sdatatype ) ; acolumn . setdata ( adata ) ; return acolumn ; }	Create a new column to be added to a column set.
@ nonnull public static key createkey ( @ nonnull @ nonempty final string scolumnid , @ nonnull @ nonempty final string sshortname , @ nullable final string slongname , @ nonnull final column acolumn ) { valueenforcer . notempty ( scolumnid , str_ ) ; valueenforcer . notempty ( sshortname , str_ ) ; valueenforcer . notnull ( acolumn , str_ ) ; final key akey = s_afactory . createkey ( ) ; akey . setid ( scolumnid ) ; akey . setshortname ( createshortname ( sshortname ) ) ; if ( stringhelper . hastext ( slongname ) ) akey . getlongname ( ) . add ( createlongname ( slongname ) ) ; akey . getcolumnref ( ) . add ( createkeycolumnref ( acolumn ) ) ; return akey ; }	Create a new key to be added to a column set.
@ nonnull public excelreadoptions < use_type > setlinestoskip ( @ nonnegative final int nlinestoskip ) { valueenforcer . isge0 ( nlinestoskip , str_ ) ; m_nlinestoskip = nlinestoskip ; return this ; }	Set the number of lines to skip before the header row starts.
@ nonnull public excelreadoptions < use_type > addcolumn ( @ nonnegative final int nindex , @ nonnull @ nonempty final string scolumnid , @ nonnull final use_type eusetype , @ nonnull @ nonempty final string sdatatype , final boolean bkeycolumn ) { valueenforcer . isge0 ( nindex , str_ ) ; final integer aindex = integer . valueof ( nindex ) ; if ( m_acolumns . containskey ( aindex ) ) throw new illegalargumentexception ( str_ + nindex + str_ ) ; m_acolumns . put ( aindex , new excelreadcolumn < > ( nindex , scolumnid , eusetype , sdatatype , bkeycolumn ) ) ; return this ; }	Add a single column definition.
@ nonnull public static genericodewriter < com . helger . genericode . v04 . codelistdocument > gc04codelist ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc04_code_list ) ; }	Create a writer builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericodewriter < com . helger . genericode . v04 . codelistsetdocument > gc04codelistset ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc04_code_list_set ) ; }	Create a writer builder for com.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericodewriter < com . helger . genericode . v04 . columnsetdocument > gc04columnset ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc04_column_set ) ; }	Create a writer builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericodewriter < com . helger . genericode . v10 . codelistdocument > gc10codelist ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc10_code_list ) ; }	Create a writer builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericodewriter < com . helger . genericode . v10 . codelistsetdocument > gc10codelistset ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc10_code_list_set ) ; }	Create a writer builder for com.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericodewriter < com . helger . genericode . v10 . columnsetdocument > gc10columnset ( ) { return new genericodewriter < > ( egenericodedocumenttype . gc10_column_set ) ; }	Create a writer builder for com.helger.genericode.v10.ColumnSetDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v04 . codelistdocument > gc04codelist ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc04_code_list ) ; }	Create a validator builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v04 . codelistsetdocument > gc04codelistset ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc04_code_list_set ) ; }	Create a validator builder forcom.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v04 . columnsetdocument > gc04columnset ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc04_column_set ) ; }	Create a validator builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v10 . codelistdocument > gc10codelist ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc10_code_list ) ; }	Create a validator builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v10 . codelistsetdocument > gc10codelistset ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc10_code_list_set ) ; }	Create a validator builder forcom.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericodevalidator < com . helger . genericode . v10 . columnsetdocument > gc10columnset ( ) { return new genericodevalidator < > ( egenericodedocumenttype . gc10_column_set ) ; }	Create a validator builder for com.helger.genericode.v10.ColumnSetDocument.
protected static void sendlogstoserver ( boolean setsenttime ) { long timesent = new date ( ) . gettime ( ) ; string appfeedbacksummary = utility . convertfiletostring ( str_ ) ; if ( str_ . equals ( appfeedbacksummary ) || str_ . equals ( appfeedbacksummary ) ) { return ; } else { try { jsonobject appfeedbacksummaryjson = new jsonobject ( appfeedbacksummary ) ; jsonarray savedarray = ( jsonarray ) appfeedbacksummaryjson . get ( str_ ) ; hashmap < string , string > timesentmap = new hashmap < > ( ) ;	Send Logs to Server.
static public void setcontext ( final context context ) {	Context object must be set in order to use the Logger API.
static public logger . level getloglevel ( ) { final future < logger . level > task = threadpoolworkqueue . submit ( new callable < logger . level > ( ) { @ override public logger . level call ( ) { return getlevelsync ( ) ; } } ) ; try { return task . get ( ) ; } catch ( exception e ) { return getlevelsync ( ) ; } }	Get the current Logger.LEVEL.
static public boolean getcapture ( ) { final future < boolean > task = threadpoolworkqueue . submit ( new callable < boolean > ( ) { @ override public boolean call ( ) { return getcapturesync ( ) ; } } ) ; try { return task . get ( ) ; } catch ( exception e ) { return getcapturesync ( ) ; } }	Get the current value of the capture flag, indicating that the Logger is recording log calls persistently.
static public void setmaxlogstoresize ( final int bytes ) {	Set the maximum size of the local log file.
protected static string prependmetadata ( string message , jsonobject metadata ) { try { if ( null != metadata ) { string clazz = str_ ; string method = str_ ; string file = str_ ; string line = str_ ; if ( metadata . has ( str_ ) ) { clazz = metadata . getstring ( str_ ) ; clazz = clazz . substring ( clazz . lastindexof ( str_ ) + num_ , clazz . length ( ) ) ; } if ( metadata . has ( str_ ) ) { method = metadata . getstring ( str_ ) ; } if ( metadata . has ( str_ ) ) { file = metadata . getstring ( str_ ) ; } if ( metadata . has ( str_ ) ) { line = metadata . getstring ( str_ ) ; } if ( ! ( clazz + method + file + line ) . equals ( str_ ) ) {	if we have callstack metadata, prepend it to the message.
protected static jsonobject appendstackmetadata ( jsonobject additionalmetadata ) { jsonobject jsonmetadata ; if ( additionalmetadata != null ) { jsonmetadata = additionalmetadata ; } else { jsonmetadata = new jsonobject ( ) ; } try {	Get stack trace caused by Logger exceptions.
private static jsonobject createjsonobject ( final logger . level level , final string pkg , final string message , long timestamp , final jsonobject jsonmetadata , final throwable t ) { jsonobject jsonobject = new jsonobject ( ) ; try { jsonobject . put ( str_ , timestamp ) ; jsonobject . put ( str_ , level . tostring ( ) ) ; jsonobject . put ( str_ , pkg ) ; jsonobject . put ( str_ , message ) ; jsonobject . put ( str_ , thread . currentthread ( ) . getid ( ) ) ; if ( null != jsonmetadata ) { jsonobject . put ( str_ , jsonmetadata ) ; } if ( null != t ) { jsonobject . put ( str_ , appendfullstacktrace ( jsonmetadata , t ) ) ; } } catch ( jsonexception e ) { log . e ( log_tag_name , str_ , e ) ; } return jsonobject ; }	Will create JSONObject with the passed parameters, and other relevant information.
private static void setuseridentity ( final string user , boolean isinitialctx ) { if ( ! isinitialctx && ! bmsanalytics . hasusercontext ) {	Specify current application user.
private byte [ ] getbytearrayfromfile ( final string file ) throws unsupportedencodingexception { string ret = str_ ; file fl = new file ( context . getfilesdir ( ) , file ) ; if ( fl . exists ( ) ) { try { fileinputstream fin = new fileinputstream ( fl ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( ( int ) fl . length ( ) ) ; copystream ( fin , baos ) ; return baos . tobytearray ( ) ; } catch ( ioexception e ) { log . e ( logpersister . log_tag_name , str_ + fl . tostring ( ) , e ) ; } } return ret . getbytes ( str_ ) ; }	public for testing only.
protected void startlocationupdates ( ) { if ( activitycompat . checkselfpermission ( context , manifest . permission . access_fine_location ) != packagemanager . permission_granted && activitycompat . checkselfpermission ( context , manifest . permission . access_coarse_location ) != packagemanager . permission_granted ) {	Starting the location updates.
public void sizeregion ( region < ? , ? > region , int numentries ) { if ( region == null ) { throw new illegalargumentexception ( str_ ) ; } if ( region instanceof partitionedregion ) { sizepartitionedregion ( region , numentries ) ; } else { sizereplicatedorlocalregion ( region , numentries ) ; } }	Calculates and logs the size of first numEntries in the region.
private void sizepartitionedregion ( region < ? , ? > region , int numentries ) { region < ? , ? > primarydataset = partitionregionhelper . getlocaldata ( region ) ; int regionsize = primarydataset . size ( ) ; if ( numentries == num_ ) { numentries = primarydataset . size ( ) ; } else if ( numentries > regionsize ) { numentries = regionsize ; } int count = num_ ; for ( iterator < ? > i = primarydataset . entryset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { if ( count == numentries ) { break ; } entrysnapshot entry = ( entrysnapshot ) i . next ( ) ; regionentry re = entry . getregionentry ( ) ; dumpsizes ( entry , re ) ; } dumptotalandaveragesizes ( numentries ) ; cleartotals ( ) ; }	Sizes numEntries of a partitioned region, or all the entries ifnumEntries is 0.
private void sizereplicatedorlocalregion ( region < ? , ? > region , int numentries ) { set < ? > entries = region . entryset ( ) ; int regionsize = entries . size ( ) ; if ( numentries == num_ ) { numentries = entries . size ( ) ; } else if ( numentries > regionsize ) { numentries = regionsize ; } int count = num_ ; for ( iterator < ? > i = entries . iterator ( ) ; i . hasnext ( ) ; ) { if ( count == numentries ) { break ; } localregion . nontxentry entry = ( localregion . nontxentry ) i . next ( ) ; regionentry re = entry . getregionentry ( ) ; dumpsizes ( entry , re ) ; } dumptotalandaveragesizes ( numentries ) ; cleartotals ( ) ; }	Sizes numEntries of a replicated or local region, or all the entries ifnumEntries is 0.
public snapshotrecord readsnapshotrecord ( ) throws ioexception , classnotfoundexception { byte [ ] key = dataserializer . readbytearray ( dis ) ; if ( key == null ) { return null ; } byte [ ] value = dataserializer . readbytearray ( dis ) ; return new snapshotrecord ( key , value ) ; }	Reads a snapshot entry.
void dump ( printwriter stream ) { stream . print ( str_ + count ) ; for ( int i = num_ ; i < count ; i ++ ) { if ( i != num_ ) { stream . print ( str_ ) ; stream . print ( timestamps [ i ] - timestamps [ i - num_ ] ) ; } else { stream . print ( str_ + timestamps [ i ] ) ; } } stream . println ( str_ ) ; }	elapsed millis from base.
double [ ] gettimevaluessinceidx ( int idx ) { int resultsize = this . count - idx ; double [ ] result = new double [ resultsize ] ; for ( int i = num_ ; i < resultsize ; i ++ ) { result [ i ] = getmillitimestamp ( idx + i ) ; } return result ; }	Returns an array of time stamp values the first of which has thespecified index.
public chart convert ( file file ) { if ( file == null ) return null ; try { if ( file . isdirectory ( ) ) {	Accepts a file or directory contain the statistics files.
public static synchronized pool getpoolforserver ( string servername , jmx jmx ) throws instancenotfoundexception { pool pool = poolmanager . find ( servername ) ; if ( pool != null ) return pool ; poolfactory poolfactory = poolmanager . createfactory ( ) ;	Dynamically create a GemFire pool with just the server.
public static synchronized pool getpoolforlocator ( jmx jmx ) { string locatorspoolname = jmx . gethost ( ) + str_ + jmx . getport ( ) + str_ ; pool pool = poolmanager . find ( locatorspoolname ) ; if ( pool != null ) return pool ; poolfactory poolfactory = poolmanager . createfactory ( ) ; try { int port = getlocatorport ( jmx ) ; poolfactory = poolfactory . addlocator ( jmx . gethost ( ) , port ) ; return poolfactory . create ( locatorspoolname ) ; } catch ( exception e ) { throw new runtimeexception ( str_ + jmx . gethost ( ) + str_ + e . getmessage ( ) , e ) ; } }	This methods create a pool for connecting to a locator.
private static boolean isexistingregiononserver ( string regionname , jmx jmx ) { string regionjmxpattern = string . format ( str_ , regionname ) ;	Determine if a given region exists.
public static membermxbean getmember ( string name , jmx jmx ) { try { string pattern = str_ + name ; set < objectname > objectnames = jmx . searchobjectnames ( pattern ) ; if ( objectnames == null || objectnames . isempty ( ) ) return null ; objectname servername = new objectname ( pattern ) ; return jmx . newbean ( membermxbean . class , servername ) ; } catch ( malformedobjectnameexception e ) { throw new runtimeexception ( str_ + name + str_ + e . getmessage ( ) , e ) ; } }	Obtain a GemFire JMX client.
public static collection < string > listhosts ( jmx jmx ) { set < objectname > objectnames = jmx . searchobjectnames ( str_ ) ; if ( objectnames == null || objectnames . isempty ( ) ) { return null ; } hashset < string > hostlists = new hashset < string > ( objectnames . size ( ) ) ; membermxbean membermxbean = null ; for ( objectname objectname : objectnames ) { membermxbean = jmx . newbean ( membermxbean . class , objectname ) ; hostlists . add ( membermxbean . gethost ( ) ) ; } return hostlists ; }	Determines the unique set of the host names for the distributed system.
static synchronized string lookupnetworkhost ( string host ) { try { if ( _bundle == null ) { url url = gemfirejmxclient . class . getresource ( hostpropfilename ) ; string filepath = null ; if ( url == null ) filepath = hostpropfilename ; else filepath = url . tostring ( ) ; system . out . println ( new stringbuilder ( str_ ) . append ( filepath ) . tostring ( ) ) ; _bundle = resourcebundle . getbundle ( str_ ) ; } system . out . println ( new stringbuilder ( str_ ) . append ( host ) . append ( str_ ) . append ( hostpropfilename ) . tostring ( ) ) ; string newhost = _bundle . getstring ( host ) ; system . out . println ( new stringbuilder ( host ) . append ( str_ ) . append ( newhost ) . tostring ( ) ) ; return newhost ; } catch ( runtimeexception e ) { system . out . println ( str_ + host ) ; return host ; } }	Supports resolving host network lookup issues.
public static boolean iserrorandsendexception ( resultsender < object > resultsender , object data ) { if ( data instanceof throwable ) { throwable e = ( throwable ) data ; resultsender . sendexception ( e ) ; return bool_ ; } return bool_ ; }	Determine if the data should be sent.
@ suppresswarnings ( str_ ) public static < t > collection < t > exewithresults ( execution < ? , ? , ? > execution , function < ? > function ) throws exception { resultcollector < ? , ? > resultcollector ; try { resultcollector = execution . execute ( function ) ; } catch ( functionexception e ) { if ( e . getcause ( ) instanceof nullpointerexception ) throw new runtimeexception ( str_ + function . getid ( ) + str_ + str_ + str_ + str_ , e ) ; else throw e ; } object resultsobject = resultcollector . getresult ( ) ;	Execute a function with the given execution settings.
@ suppresswarnings ( str_ ) public static < t > void flatten ( collection < object > input , collection < object > flattenoutput ) throws exception { if ( input == null || input . isempty ( ) || flattenoutput == null ) return ; for ( object inputobj : input ) { if ( inputobj instanceof exception ) throw ( exception ) inputobj ; if ( inputobj == null ) continue ; if ( inputobj instanceof collection ) flatten ( ( collection < object > ) inputobj , flattenoutput ) ; else flattenoutput . add ( inputobj ) ; } }	Used to flatten results from multiple servers.
@ suppresswarnings ( str_ ) public static < returntype > collection < returntype > query ( query queryobj , regionfunctioncontext rfc , object ... params ) throws functiondomainexception , typemismatchexception , nameresolutionexception , queryinvocationtargetexception { selectresults < returntype > selectresults ;	Select results for OQL.
public static < k , v > cachelistenerbridge < k , v > forafterput ( consumer < entryevent < k , v > > consumer ) { return new cachelistenerbridge < k , v > ( consumer , null ) ; }	Factory method for put events registration.
public static < k , v > cachelistenerbridge < k , v > forafterdelete ( consumer < entryevent < k , v > > consumer ) { return new cachelistenerbridge < k , v > ( null , consumer ) ; }	Factory method for delete events registration.
@ exceptionhandler ( exception . class ) private dataerror handleexception ( httpservletrequest request , httpservletresponse response , exception e ) { return faultagent . handleexception ( request , response , e ) ; }	Handling exceptions in general for REST responses.
public onregionfilterkeyfacts [ ] getonregionfilterkeyfacts ( ) { if ( onregionfilterkeyfacts == null ) return null ; return arrays . copyof ( onregionfilterkeyfacts , onregionfilterkeyfacts . length ) ; }	On region filter facts determine how to parse the inputs typically for CICS to grid calls.
@ override public void execute ( functioncontext < object > functioncontext ) { resultsender < object > sender = functioncontext . getresultsender ( ) ; cache cache = cachefactory . getanyinstance ( ) ; logger logwriter = logmanager . getlogger ( getclass ( ) ) ; try {	This function will use the JsonExportFunction functionto export json data and read the results to be returned to callers.
public static set < string > listhosts ( jmx jmx ) { set < objectname > memberobjects = jmx . searchobjectnames ( str_ ) ; if ( memberobjects == null || memberobjects . isempty ( ) ) { return null ; } hashset < string > hostlist = new hashset < string > ( memberobjects . size ( ) ) ; membermxbean bean = null ; for ( objectname objectname : memberobjects ) { bean = jmx . newbean ( membermxbean . class , objectname ) ; try { hostlist . add ( bean . gethost ( ) ) ; } catch ( undeclaredthrowableexception e ) {	List the unique set of host name.
@ suppresswarnings ( { str_ , str_ } ) @ override public void execute ( functioncontext functioncontext ) { cache cache = cachefactory . getanyinstance ( ) ; try {	Execute the search on Region.
public static string getappname ( resourceinst [ ] resources ) { if ( resources == null || resources . length == num_ ) return null ; resourcetype rt = null ; for ( resourceinst resourceinst : resources ) { if ( resourceinst == null ) continue ; rt = resourceinst . gettype ( ) ; if ( rt == null ) continue ; if ( ! str_ . equals ( rt . getname ( ) ) ) continue ; return resourceinst . getname ( ) ; } return null ; }	Current supports get cache server nameDetermine the logic name of app.
protected static void constructsecurity ( properties props ) throws ioexception { props . setproperty ( str_ , geodeconfigauthinitialize . class . getname ( ) + str_ ) ;	Initialize security properties.
@ suppresswarnings ( str_ ) public < k , v > region < k , v > getregion ( string regionname ) { if ( regionname == null || regionname . length ( ) == num_ ) return null ; region < k , v > region = ( region < k , v > ) clientcache . getregion ( regionname ) ; if ( region != null ) return ( region < k , v > ) region ; region = ( region < k , v > ) this . createregion ( regionname ) ;	This is an example to get or create a region.
@ suppresswarnings ( str_ ) public static < k , v > region < k , v > getregion ( clientcache clientcache , string regionname ) { if ( regionname == null || regionname . length ( ) == num_ ) return null ; region < k , v > region = ( region < k , v > ) clientcache . getregion ( regionname ) ; if ( region != null ) return ( region < k , v > ) region ; region = ( region < k , v > ) clientcache . createclientregionfactory ( clientregionshortcut . proxy ) . create ( regionname ) ; return region ; }	Create a proxy region.
public void constructcomparison ( map < ? , biginteger > sourcechecksummap , map < ? , biginteger > targetmap ) { if ( sourcechecksummap == null ) { if ( targetmap != null && ! targetmap . isempty ( ) ) { this . keysremovedfromsource . addall ( targetmap . keyset ( ) ) ; } return ; } if ( targetmap == null ) { this . keysmissingontarget . addall ( sourcechecksummap . keyset ( ) ) ; return ; } biginteger targetbi = null ; biginteger sourcebi = null ; for ( map . entry < ? , biginteger > entrysource : sourcechecksummap . entryset ( ) ) { targetbi = targetmap . get ( entrysource . getkey ( ) ) ; sourcebi = sourcechecksummap . get ( entrysource . getkey ( ) ) ; if ( targetbi == null ) { keysmissingontarget . add ( entrysource . getkey ( ) ) ; } else if ( ! targetbi . equals ( sourcebi ) ) { keysdifferentontarget . add ( entrysource . getkey ( ) ) ; } }	Build the RegionSyncReport the given.
private static boolean mustinsert ( int nextidx , long [ ] valuetimestamps , long tsatinsertpoint ) { return ( nextidx < valuetimestamps . length ) && ( valuetimestamps [ nextidx ] <= tsatinsertpoint ) ; }	Return true if the current ts must be inserted instead of being mapped tothe tsAtInsertPoint.
public void close ( ) throws ioexception { if ( ! this . closed ) { this . closed = bool_ ; this . is . close ( ) ; this . datain . close ( ) ; this . is = null ; this . datain = null ; int typecount = num_ ; if ( this . resourcetypetable != null ) {	Closes the archive.
public static void tocvsfiles ( file directory ) throws ioexception { set < file > statsfiles = io . listfilerecursive ( directory , str_ ) ; if ( statsfiles == null || statsfiles . isempty ( ) ) return ; for ( file archivefile : statsfiles ) { gfstatsreader reader = new gfstatsreader ( archivefile . getabsolutepath ( ) ) ; reader . dumpcsvfiles ( ) ; } }	Finds and converts all statistics files in a given directory to CSV.
public static void main ( string [ ] args ) { file archivefile , csvfile ; if ( args . length < num_ ) { system . err . println ( str_ + gfstatsreader . class . getname ( ) + str_ ) ; return ; } try { archivefile = paths . get ( args [ num_ ] ) . tofile ( ) ; if ( archivefile . isdirectory ( ) ) { tocvsfiles ( archivefile ) ; return ; } if ( args . length < num_ ) { gfstatsreader reader = new gfstatsreader ( archivefile . getabsolutepath ( ) ) ; reader . dumpcsvfiles ( ) ; return ; } string typename = args [ num_ ] ; csvfile = paths . get ( args [ num_ ] ) . tofile ( ) ; genericcsvstatsvisitor visitor = null ; if ( args . length > num_ ) { string [ ] statenames = arrays . copyofrange ( args , num_ , args . length - num_ ) ; visitor = new genericcsvstatsvisitor ( csvfile , typename , statenames ) ; } else visitor = new genericcsvstatsvisitor ( csvfile , typename ) ; system . out . println ( str_ ) ; gfstatsreader reader = new gfstatsreader ( archivefile . getabsolutepath ( ) ) ; reader . accept ( visitor ) ; } catch ( ioexception e ) {	Main method to extract GF Stats to file.
public synchronized static jmx reconnect ( ) { try { clientcache cache = null ; cache = clientcachefactory . getanyinstance ( ) ; if ( cache != null && ! cache . isclosed ( ) ) { cache . close ( ) ; } } catch ( exception e ) { system . out . println ( str_ ) ; } if ( jmx != null ) { jmx . dispose ( ) ; jmx = null ; } return getjmx ( ) ; }	Close and recreate the JMX connect.
public static int stopmembersonhost ( string hostname ) { jmx jmx = singletongemfirejmx . getjmx ( ) ; string objectnamepattern = str_ ; queryexp queryexp = null ; valueexp [ ] values = null ;	Stops all cache servers followed by locators on a given server.
public static void shutdownmember ( string name ) { try { objectname servername = new objectname ( str_ + name ) ; jmx jmx = singletongemfirejmx . getjmx ( ) ; membermxbean bean = jmx . newbean ( membermxbean . class , servername ) ; bean . shutdownmember ( ) ;	Shut down a given member by its name.
public static string [ ] shutdown ( jmx jmx ) { try { distributedsystemmxbean bean = todistributesystem ( jmx ) ; return bean . shutdownallmembers ( ) ; } catch ( exception e ) { throw new runtimeexception ( str_ + e . getmessage ( ) , e ) ; } }	Does not stop locators.
public static void shutdownredundancyzone ( string redundancyzone ) { if ( redundancyzone == null || redundancyzone . length ( ) == num_ ) throw new illegalargumentexception ( str_ ) ; string objectnamepattern = str_ ; queryexp exp = query . eq ( query . attr ( str_ ) , query . value ( redundancyzone ) ) ; collection < objectname > memberobjectnames = singletongemfirejmx . getjmx ( ) . searchobjectnames ( objectnamepattern , exp ) ; for ( objectname objectname : memberobjectnames ) { gemfiremgmt . shutdownmember ( objectname . getkeyproperty ( str_ ) ) ; } }	Shut down each member in a given RedundancyZone.
@ suppresswarnings ( { str_ , str_ } ) public < k , v > list < string > storepaginationmap ( string id , int pagesize , region < string , collection < k > > pagekeysregion , list < map . entry < k , v > > results ) { if ( results == null || results . isempty ( ) ) return null ;	Store the pagination search result details.
public < k , v > map < k , v > readresultsbypage ( textpagecriteria criteria , int pagenumber , region < k , v > region , region < string , collection < ? > > pageregion ) { if ( pageregion == null ) return null ; collection < ? > regionkeys = pageregion . get ( criteria . topagekey ( pagenumber ) ) ; if ( regionkeys == null || regionkeys . isempty ( ) ) return null ; return region . getall ( regionkeys ) ; }	Read Results from region by keys in pageRegion.
private boolean importregion ( region < object , object > region ) throws exception { file file = dataopssecretary . determinefile ( exportfiletype . gfd , region . getname ( ) ) ; if ( ! file . exists ( ) ) return bool_ ; region . getsnapshotservice ( ) . load ( file , snapshotformat . gemfire ) ; return bool_ ; }	Import exported data from a given.
public static boolean checkremotelocatorsandlocatorsmatch ( string remotelocators , string locators ) { if ( remotelocators == null || remotelocators . length ( ) == num_ ) return bool_ ; if ( remotelocators . equalsignorecase ( locators ) ) return bool_ ; string [ ] remotelocatorsarray = remotelocators . split ( str_ ) ; if ( locators == null || locators . length ( ) == num_ ) return bool_ ; string [ ] locatorsarray = locators . split ( str_ ) ; string remotelocatorhost , locatorhost ; int remotelocatorport , locatorport ; for ( string remotelocator : remotelocatorsarray ) { if ( remotelocator == null || remotelocator . length ( ) == num_ ) continue ;	Parse the remote locators and locator and assert that they match.
@ override public void execute ( functioncontext < object > functioncontext ) { try { string [ ] args = ( string [ ] ) functioncontext . getarguments ( ) ; if ( args == null || args . length == num_ ) throw new illegalargumentexception ( str_ ) ; string regionname = args [ num_ ] ; if ( regionname == null || regionname . length ( ) == num_ ) throw new illegalargumentexception ( str_ ) ; region < serializable , object > region = cachefactory . getanyinstance ( ) . getregion ( regionname ) ; if ( region == null ) throw new illegalargumentexception ( str_ + regionname + str_ ) ; functioncontext . getresultsender ( ) . lastresult ( buildchecksummap ( region ) ) ; } catch ( exception e ) { string stack = debugger . stacktrace ( e ) ; logmanager . getlogger ( getclass ( ) ) . error ( stack ) ; throw new functionexception ( stack ) ; } }	This function gets HashMap key=Serializable value=BigInteger.
hashmap < serializable , biginteger > buildchecksummap ( region < serializable , object > region ) { if ( region . getattributes ( ) . getdatapolicy ( ) . withpartitioning ( ) ) { region = partitionregionhelper . getlocaldata ( region ) ; } set < serializable > keyset = region . keyset ( ) ; if ( keyset == null || keyset . isempty ( ) ) return null ; hashmap < serializable , biginteger > regionchecksummap = new hashmap < serializable , biginteger > ( keyset . size ( ) ) ; object object = null ; object tmp = null ; for ( map . entry < serializable , object > entry : region . entryset ( ) ) { object = entry . getvalue ( ) ; if ( pdxinstance . class . isassignablefrom ( object . getclass ( ) ) ) { tmp = ( ( pdxinstance ) object ) . getobject ( ) ; if ( serializable . class . isassignablefrom ( tmp . getclass ( ) ) ) { object = tmp ; }	Build check sum map.
private object valueof ( string columnname , object value ) { java . lang . reflect . field field ; try { field = tableobject . getdeclaredfield ( columnname ) ; } catch ( nosuchfieldexception e ) { throw new runtimeexception ( string . format ( str_ , columnname , tableobject ) ) ; } return field . gettype ( ) == string . class ? string . format ( str_ , value ) : value ; }	Forces the value to be wrapped with ' if it isEqualTo for a string field.
boolean istypeof ( typemirror typemirror ) { if ( integerkinds . contains ( typemirror . getkind ( ) ) ) { return bool_ ; } if ( integerobjects . contains ( typemirror . tostring ( ) ) ) { return bool_ ; } return bool_ ; }	Checks if a TypeMirror is mapped to Sqlite Integer Type.
public static < t > byte [ ] serialize ( t object ) { try { bytearrayoutputstream bytearrayoutputstream = new bytearrayoutputstream ( ) ; objectoutputstream objectoutputstream = new objectoutputstream ( bytearrayoutputstream ) ; objectoutputstream . writeobject ( object ) ; return bytearrayoutputstream . tobytearray ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	Takes an object and serializes it to a byte array.
public static < k > k deserialize ( byte [ ] bytes ) { try { bytearrayinputstream bytearrayinputstream = new bytearrayinputstream ( bytes ) ; objectinputstream objectinputstream = new objectinputstream ( bytearrayinputstream ) ; @ suppresswarnings ( str_ ) final k k = ( k ) objectinputstream . readobject ( ) ; return k ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( e ) ; } }	De-serialize a byte array back to it's original object.
@ suppresswarnings ( str_ ) public static < t > t createinstance ( class < t > clazz ) { if ( clazz . isinterface ( ) ) { if ( clazz == list . class ) { return ( t ) new arraylist ( ) ; } else if ( clazz == map . class ) { return ( t ) new hashmap ( ) ; } throw new unsupportedoperationexception ( str_ ) ; } objectinstantiator instantiator = objenesis . getinstantiatorof ( clazz ) ; return ( t ) instantiator . newinstance ( ) ; }	Takes a class type and constructs it.
private void checkfortableid ( tableobject tableobject , element element ) {	Check if the element has the .
private void checkforfields ( tableobject tableobject , element columnelement ) { column columnannotation = columnelement . getannotation ( column . class ) ; if ( columnannotation == null ) return ;	Check if the element has a .
private boolean checkforsupertype ( element element , class type ) { list < ? extends typemirror > supertypes = typeutils . directsupertypes ( element . astype ( ) ) ; for ( typemirror supertype : supertypes ) { if ( supertype . tostring ( ) . equals ( type . getname ( ) ) ) { return bool_ ; } } return bool_ ; }	Checks for a supertype returns true if element has a supertype.
void brewjava ( writer writer ) throws ioexception { logger . d ( str_ ) ; javawriter javawriter = new javawriter ( writer ) ; javawriter . setcompressingtypes ( bool_ ) ; javawriter . emitsinglelinecomment ( str_ )	Create the java functions required for the internal class.
private void emitgetid ( javawriter javawriter ) throws ioexception { logger . d ( str_ ) ; javawriter . beginmethod ( str_ , get_id_function , enumset . of ( public , static ) , gettargetclass ( ) , str_ ) . emitstatement ( str_ , idcolumn . getmembername ( ) ) . endmethod ( ) ; }	Create a way to get an id for foreign keys.
public final observable < t > toobservable ( ) { if ( ! has_rx_java ) { throw new runtimeexception ( str_ ) ; } return shillelagh . getobservable ( tableobject , new cursorloader ( ) { @ override public cursor getcursor ( ) { return shillelagh . rawquery ( query . tostring ( ) ) ; } } ) ; }	Executes a query and returns the results wrapped in an observable.
final void checkcolumnname ( string columnname ) { try { tableobject . getdeclaredfield ( columnname ) ; } catch ( nosuchfieldexception e ) { throw new runtimeexception ( string . format ( str_ , columnname , tableobject ) ) ; } }	Check to ensure that the column name provided is valid.
static string valueordefault ( string string , string defaultstring ) { return isblank ( string ) ? defaultstring : string ; }	Checks if a string there, if not returns the default string.
static string capitalize ( string string ) { if ( isblank ( string ) ) { return str_ ; } char first = string . charat ( num_ ) ; if ( character . isuppercase ( first ) ) { return string ; } else { return character . touppercase ( first ) + string . substring ( num_ ) ; } }	Capitalizes the first letter of the string passed in.
boolean istypeof ( typemirror typemirror ) { if ( realkinds . contains ( typemirror . getkind ( ) ) ) { return bool_ ; } if ( realobjects . contains ( typemirror . tostring ( ) ) ) { return bool_ ; } return bool_ ; }	Checks if a TypeMirror is mapped to Sqlite Type.
public builder < t > descending ( ) { this . query . append ( str_ ) ; return new builder < t > ( shillelagh , tableobject , query ) ; }	Order the results in descending order.
public float readtemperature ( ) throws ioexception { byte [ ] encoded = files . readallbytes ( new file ( devicefile , str_ ) . topath ( ) ) ; string tmp = new string ( encoded ) ; int tmpindex = tmp . indexof ( str_ ) ; if ( tmpindex < num_ ) { throw new ioexception ( str_ ) ; } return integer . parseint ( tmp . substring ( tmpindex + num_ ) . trim ( ) ) / num_ ; }	Read temperature from the sensors.
public static string get ( string type ) { final string returnvalue = supported_cursor_methods . get ( type ) ; return returnvalue != null ? returnvalue : supported_cursor_methods . get ( blob ) ; }	Maps a type to the corresponding Cursor get function.
void e ( string message , object ... args ) { messenger . printmessage ( error , formatstring ( message , args ) ) ; }	Print out errors, this will stop the build from succeeding.
public static list < iconfont > geticonfonts ( ) { list < iconfont > list = new arraylist < > ( ) ; list . add ( googlematerialdesignicons . geticonfont ( ) ) ; list . add ( elusive . geticonfont ( ) ) ; list . add ( entypo . geticonfont ( ) ) ; list . add ( fontawesome . geticonfont ( ) ) ; list . add ( iconic . geticonfont ( ) ) ; list . add ( typicons . geticonfont ( ) ) ; return list ; }	Returns all icon fonts from bundle.
public static list < iconcode > geticons ( ) { list < iconcode > list = new arraylist < > ( ) ; for ( iconcode icon : googlematerialdesignicons . values ( ) ) { list . add ( icon ) ; } for ( iconcode icon : elusive . values ( ) ) { list . add ( icon ) ; } for ( iconcode icon : entypo . values ( ) ) { list . add ( icon ) ; } for ( iconcode icon : fontawesome . values ( ) ) { list . add ( icon ) ; } for ( iconcode icon : iconic . values ( ) ) { list . add ( icon ) ; } for ( iconcode icon : typicons . values ( ) ) { list . add ( icon ) ; } return list ; }	Returns all icons from bundle.
private htmlflow getbackgrounddecoration ( ) {	Create background content decoration for the widget tab.
public static double raise ( final double px , final int pexponent ) { double x = px ; int exponent = pexponent ; if ( exponent < num_ ) return num_ / raise ( x , - exponent ) ; double power = num_ ;	Compute and return x^power.
protected void set ( final float values [ ] ) { this . m_nrows = values . length ; this . m_ncols = num_ ; this . m_avalues = new float [ m_nrows ] [ num_ ] ; for ( int r = num_ ; r < m_nrows ; ++ r ) { this . m_avalues [ r ] [ num_ ] = values [ r ] ; } }	Set this column vector from an array of values.
public static bigdecimal intpower ( @ nonnull final bigdecimal px , final long pexponent , final int scale ) { bigdecimal x = px ; long exponent = pexponent ;	Compute x^exponent to a given scale.
public static bigdecimal introot ( @ nonnull final bigdecimal px , final long index , final int scale ) { bigdecimal x = px ;	Compute the integral root of x to a given scale, x &ge; 0.
private static bigdecimal _exptaylor ( final bigdecimal x , final int scale ) { bigdecimal factorial = bigdecimal . one ; bigdecimal xpower = x ; bigdecimal sumprev ;	Compute e^x to a given scale by the Taylor series.
public static bigdecimal ln ( @ nonnull final bigdecimal x , final int scale ) {	Compute the natural logarithm of x to a given scale, x &gt; 0.
private static bigdecimal _lnnewton ( @ nonnull final bigdecimal px , final int scale ) { bigdecimal x = px ; final int sp1 = scale + num_ ; final bigdecimal n = x ; bigdecimal term ;	Compute the natural logarithm of x to a given scale, x > 0.
public static bigdecimal arctan ( @ nonnull final bigdecimal x , final int scale ) {	Compute the arctangent of x to a given scale, |x| &lt; 1.
private static bigdecimal _arctantaylor ( final bigdecimal x , final int scale ) { final int sp1 = scale + num_ ; int i = num_ ; boolean addflag = bool_ ; bigdecimal power = x ; bigdecimal sum = x ; bigdecimal term ;	Compute the arctangent of x to a given scale by the Taylor series, |x| < 1.
public static bigdecimal sqrt ( @ nonnull final bigdecimal x , final int scale ) {	Compute the square root of x to a given scale, x &ge; 0.
protected void printpi ( final string pistring ) { system . out . print ( str_ + pistring . substring ( num_ , num_ ) ) ; int index = num_ ; int line = num_ ; int group = num_ ; final int length = pistring . length ( ) ;	Print the string containing the digits of pi.
protected string timestamp ( final long time ) {	Return a timestamp string that contains the elapsed time period.
public void setlimits ( final float rmin , final float rmax ) { this . m_fmin = rmin ; this . m_fmax = rmax ; this . m_fwidth = ( rmax - rmin ) / m_n ; }	Set the minimum and maximum random values.
public void put ( final float r ) {	Determine a random value's interval and count it.
public void print ( ) {	Print the counter values as a horizontal bar chart.
public complex add ( final complex z ) { return new complex ( m_freal + z . real ( ) , m_fimaginary + z . imaginary ( ) ) ; }	Add another complex number to this one.
public complex subtract ( final complex z ) { return new complex ( m_freal - z . real ( ) , m_fimaginary - z . imaginary ( ) ) ; }	Subtract another complex number from this one.
public complex multiply ( final complex z ) { return new complex ( m_freal * z . real ( ) - m_fimaginary * z . imaginary ( ) , m_freal * z . imaginary ( ) + m_fimaginary * z . real ( ) ) ; }	Multiply this complex number by another one.
public complex divide ( final complex z ) { final float denom = z . real ( ) * z . real ( ) + z . imaginary ( ) * z . imaginary ( ) ; final float qr = ( m_freal * z . real ( ) + m_fimaginary * z . imaginary ( ) ) / denom ; final float qi = ( m_fimaginary * z . real ( ) - m_freal * z . imaginary ( ) ) / denom ; return new complex ( qr , qi ) ; }	Divide this complex number by another one.
private void _set ( final matrix m ) { m_nrows = num_ ; m_ncols = m . m_ncols ; m_avalues = m . m_avalues ; }	Set this row vector from a matrix.
public rowvector getrow ( final int r ) throws matrixexception { if ( ( r < num_ ) || ( r >= m_nrows ) ) { throw new matrixexception ( matrixexception . invalid_index ) ; } final rowvector rv = new rowvector ( m_ncols ) ; for ( int c = num_ ; c < m_ncols ; ++ c ) { rv . m_avalues [ num_ ] [ c ] = m_avalues [ r ] [ c ] ; } return rv ; }	Get a row of this matrix.
public columnvector getcolumn ( final int c ) throws matrixexception { if ( ( c < num_ ) || ( c >= m_ncols ) ) { throw new matrixexception ( matrixexception . invalid_index ) ; } final columnvector cv = new columnvector ( m_nrows ) ; for ( int r = num_ ; r < m_nrows ; ++ r ) { cv . m_avalues [ r ] [ num_ ] = m_avalues [ r ] [ c ] ; } return cv ; }	Get a column of this matrix.
protected void set ( final float values [ ] [ ] ) { m_nrows = values . length ; m_ncols = values [ num_ ] . length ; m_avalues = values ; for ( int r = num_ ; r < m_nrows ; ++ r ) { m_ncols = math . min ( m_ncols , values [ r ] . length ) ; } }	Set this matrix from a 2-d array of values.
public matrix transpose ( ) { final float tv [ ] [ ] = new float [ m_ncols ] [ m_nrows ] ;	Return the transpose of this matrix.
public matrix add ( final matrix m ) throws matrixexception {	Add another matrix to this matrix.
public matrix subtract ( final matrix m ) throws matrixexception {	Subtract another matrix from this matrix.
public matrix multiply ( final float k ) { final float pv [ ] [ ] = new float [ m_nrows ] [ m_ncols ] ;	Multiply this matrix by a constant.
public matrix multiply ( final matrix m ) throws matrixexception {	Multiply this matrix by another matrix.
public void print ( final int width , @ nonnull final printstream aps ) { final systemoutalignright ar = new systemoutalignright ( aps ) ; for ( int r = num_ ; r < m_nrows ; ++ r ) { ar . print ( str_ , num_ ) ; ar . print ( r + num_ , num_ ) ; ar . print ( str_ , num_ ) ; for ( int c = num_ ; c < m_ncols ; ++ c ) { ar . print ( m_avalues [ r ] [ c ] , width ) ; } ar . println ( ) ; } }	Print the matrix values.
public void setresource ( imageresource imageresource ) { image img = new image ( imageresource ) ; dom . insertchild ( getelement ( ) , img . getelement ( ) , num_ ) ; }	Attach an ImageResource to the button.
private void _validatecoefficients ( ) { if ( m_bcoefsvalid ) return ; if ( m_ndatapoints >= num_ ) { final float xbar = ( float ) m_dsumx / m_ndatapoints ; final float ybar = ( float ) m_dsumy / m_ndatapoints ; m_fa1 = ( float ) ( ( m_ndatapoints * m_dsumxy - m_dsumx * m_dsumy ) / ( m_ndatapoints * m_dsumxx - m_dsumx * m_dsumx ) ) ; m_fa0 = ybar - m_fa1 * xbar ; } else { m_fa0 = m_fa1 = float . nan ; } m_bcoefsvalid = bool_ ; }	Validate the coefficients.
@ override protected void computenextposition ( ) { m_fprevxn = m_fxn ; m_fxn = m_fgn ; m_fgn = m_afunction . at ( m_fxn ) ; }	Compute the next position of xn.
public void clear ( ) { rawsld = new rawsld ( ) ; dirty = bool_ ; valid = bool_ ; template = null ; slddescriptor = null ; }	Does not clear templateNames.
public rawsld toxml ( styledlayerdescriptorinfo sldi ) throws sldexception { try { if ( sldi . getversion ( ) == null ) { sldi . setversion ( str_ ) ; } return parsesldi ( sldi ) ; } catch ( jibxexception e ) { throw new sldexception ( str_ , e ) ; } }	Convert StyledLayerDescriptorInfo to raw xml.
public styledlayerdescriptorinfo tosldi ( rawsld sld ) throws sldexception { try { return parsexml ( sld . getname ( ) , sld . getxml ( ) ) ; } catch ( jibxexception e ) { throw new sldexception ( str_ , e ) ; } }	Convert raw xml to StyledLayerDescriptorInfo.
public void validate ( styledlayerdescriptorinfo sld ) throws sldexception { try { parsesldi ( sld ) ; } catch ( jibxexception e ) { throw new sldexception ( str_ , e ) ; } }	Test by marshalling.
public boolean validate ( rawsld sld ) throws sldexception { try { parsexml ( str_ , sld . getxml ( ) ) ; return bool_ ; } catch ( jibxexception e ) { return bool_ ; } }	Test by unmarshalling.
private float _areaof ( final float x1 , final float h ) { final float x2 = x1 + h ;	Compute the area of the ith trapezoidal region.
private void _set ( final matrix m ) { this . m_nrows = this . m_ncols = math . min ( m . m_nrows , m . m_ncols ) ; this . m_avalues = m . m_avalues ; }	Set this square matrix from another matrix.
@ override protected void set ( final float values [ ] [ ] ) { super . set ( values ) ; m_nrows = m_ncols = math . min ( m_nrows , m_ncols ) ; }	Set this square matrix from a 2-d array of values.
public invertiblematrix inverse ( ) throws matrixexception { final invertiblematrix inverse = new invertiblematrix ( m_nrows ) ; final identitymatrix identity = new identitymatrix ( m_nrows ) ;	Compute the inverse of this matrix.
public float determinant ( ) throws matrixexception { decompose ( ) ;	Compute the determinant.
public float norm ( ) { float sum = num_ ; for ( int r = num_ ; r < m_nrows ; ++ r ) { for ( int c = num_ ; c < m_ncols ; ++ c ) { final float v = m_avalues [ r ] [ c ] ; sum += v * v ; } } return ( float ) math . sqrt ( sum ) ; }	Compute the Euclidean norm of this matrix.
public columnvector solve ( final columnvector b , final boolean improve ) throws matrixexception {	Solve Ax = b for x using the Gaussian elimination algorithm.
public void printdecomposed ( final int width , @ nonnull final printstream aps ) throws matrixexception { decompose ( ) ; final systemoutalignright ar = new systemoutalignright ( aps ) ; for ( int r = num_ ; r < m_nrows ; ++ r ) { final int pr = m_apermutation [ r ] ;	Print the decomposed matrix LU.
private void _forwardelimination ( final float scales [ ] ) throws matrixexception {	Do forward elimination with scaled partial row pivoting.
private columnvector _forwardsubstitution ( final columnvector b ) throws matrixexception { final columnvector y = new columnvector ( m_nrows ) ;	Solve Ly = b for y by forward substitution.
private columnvector _backsubstitution ( final columnvector y ) throws matrixexception { final columnvector x = new columnvector ( m_nrows ) ;	Solve Ux = y for x by back substitution.
private void _improve ( final columnvector b , final columnvector x ) throws matrixexception {	Iteratively improve the solution x to machine accuracy.
public static void convert ( final squarematrix sm ) { for ( int r = num_ ; r < sm . m_nrows ; ++ r ) { for ( int c = num_ ; c < sm . m_ncols ; ++ c ) { sm . m_avalues [ r ] [ c ] = ( r == c ) ? num_ : num_ ; } } }	Convert a square matrix into an identity matrix.
public float nextvonneumann ( ) { int n ; int k = num_ ; float u1 ;	Compute the next randomn value using the von Neumann algorithm.
@ override protected void doiterationprocedure ( final int n ) { if ( n == num_ ) return ;	Do the regula falsi iteration procedure.
@ override protected void computenextposition ( ) { m_fprevxfalse = m_fxfalse ; m_fxfalse = m_fxpos - m_fpos * ( m_fxneg - m_fxpos ) / ( m_fneg - m_fpos ) ; m_ffalse = m_afunction . at ( m_fxfalse ) ; }	Compute the next position of x-false.
@ override protected void checkposition ( ) throws abstractrootfinder . positionunchangedexception { if ( equalshelper . equals ( m_fxfalse , m_fprevxfalse ) ) { throw new abstractrootfinder . positionunchangedexception ( ) ; } }	Check the position of x-false.
@ override protected void computenextposition ( ) { m_fprevxfalse = m_fxfalse ; m_fprevffalse = m_ffalse ; m_fxfalse = m_fxpos - m_fpos * ( m_fxneg - m_fxpos ) / ( m_fneg - m_fpos ) ; m_ffalse = m_afunction . at ( m_fxfalse ) ; m_bdecreasepos = m_bdecreaseneg = bool_ ;	Compute the next position of xFalse.
public void checkinterval ( final float x1 , final float x2 ) throws invalidintervalexception { final float y1 = m_afunction . at ( x1 ) ; final float y2 = m_afunction . at ( x2 ) ;	Check the interval.
public void add ( final float addend ) {	Add the value of an addend to the running sum.
public static int multiply ( final int pa , final int pb , final int m ) { int a = pa ; int b = pb ; int product = num_ ;	Multiply two integer values a and b modulo m.
public static int raise ( final int pbase , final int pexponent , final int m ) { int base = pbase ; int exponent = pexponent ; int power = num_ ;	Raise a to the b power modulo m.
@ override protected void doiterationprocedure ( final int n ) { if ( n == num_ ) return ;	Do the secant iteration procedure.
public sldmanager getsldmanager ( ) { if ( sldmanager == null ) { sldmanager = new sldmanagerimpl ( geteventbus ( ) , getsldeditorservicefactory ( ) . createsldgwtserviceasync ( ) ) ; } return sldmanager ; }	Create an instance of the SldManager.
private static char [ ] _tocharbitarray ( final long pvalue , final int size ) { long value = pvalue ; final char bits [ ] = new char [ size ] ;	Convert a long value into a character array of '0' and '1' that representsthe value in base 2.
private void _decompose ( final char [ ] bits , final int bias , final int reserved , final int signindex , final int signsize , final int exponentindex , final int exponentsize , final int fractionindex , final int fractionsize ) { this . m_nbias = bias ;	Decompose a floating-point value into its parts.
public void print ( @ nonnull final printstream apw ) { apw . println ( str_ ) ;	Print the decomposed parts of the value.
public static void validatefloatbiasedexponent ( final int biased ) throws ieee754exception { if ( ( biased < num_ ) || ( biased > ieee754constants . float_exponent_reserved ) ) { throw new ieee754exception ( str_ + str_ + ieee754constants . float_exponent_reserved + str_ ) ; } }	Validate the value of the float biased exponent value.
public static void validatefloatunbiasedexponent ( final int unbiased ) throws ieee754exception { if ( ( unbiased < - ieee754constants . float_exponent_bias + num_ ) || ( unbiased > ieee754constants . float_exponent_bias ) ) { throw new ieee754exception ( str_ + - ( ieee754constants . float_exponent_bias - num_ ) + str_ + ieee754constants . float_exponent_bias + str_ ) ; } }	Validate the value of the float unbiased exponent value.
public static void validatedoublebiasedexponent ( final int biased ) throws ieee754exception { if ( ( biased < num_ ) || ( biased > ieee754constants . double_exponent_reserved ) ) { throw new ieee754exception ( str_ + str_ + ieee754constants . double_exponent_reserved + str_ ) ; } }	Validate the value of the double biased exponent value.
public static void validatedoubleunbiasedexponent ( final int unbiased ) throws ieee754exception { if ( ( unbiased < - ieee754constants . double_exponent_bias + num_ ) || ( unbiased > ieee754constants . double_exponent_bias ) ) { throw new ieee754exception ( str_ + - ( ieee754constants . double_exponent_bias - num_ ) + str_ + ieee754constants . double_exponent_bias + str_ ) ; } }	Validate the value of the double unbiased exponent value.
public float nextcentral ( ) {	Compute the next random value using the Central Limit Theorem, which statesthat the averages of sets of uniformly-distributed random values arenormally distributed.
public float nextpolar ( ) {	Compute the next randomn value using the polar algorithm.
public float nextratio ( ) { float u , v , x , xx ; do {	Compute the next random value using the ratio algorithm.
public static boolean [ ] primesieve ( final int n ) { final int halfn = ( n + num_ ) > > num_ ; final boolean sieve [ ] = new boolean [ n + num_ ] ;	Compute the Sieve of Eratosthenes.
public static int [ ] factorsof ( final int pn ) { int n = pn ; final boolean isprime [ ] = primesieve ( n ) ;	Compute the prime factors of an integer value.
@ override protected void doiterationprocedure ( final int n ) { if ( n == num_ ) return ;	Do the bisection iteration procedure.
@ override protected void computenextposition ( ) { m_fprevxmid = m_fxmid ; m_fxmid = ( m_fxneg + m_fxpos ) / num_ ; m_fmid = m_afunction . at ( m_fxmid ) ; }	Compute the next position of xMid.
@ override protected void checkposition ( ) throws abstractrootfinder . positionunchangedexception { if ( equalshelper . equals ( m_fxmid , m_fprevxmid ) ) { throw new abstractrootfinder . positionunchangedexception ( ) ; } }	Check the position of xMid.
public static void setjavafxapplication ( final cdiapplication javafxapplication ) { final countdownlatch latch = new countdownlatch ( num_ ) ; platform . runlater ( ( ) -> { java_fx_application . set ( javafxapplication ) ; latch . countdown ( ) ; } ) ; if ( ! platform . isfxapplicationthread ( ) ) { try { latch . await ( ) ; } catch ( interruptedexception e ) { throw new illegalstateexception ( e ) ; } } }	Sets the JavaFX application instance to be provided by the CDI BeanManager.
public void setconfiguration ( file configfile ) { if ( configfile == null ) nextconfig = null ; else try { xprocconfiguration config = new xprocconfiguration ( str_ , bool_ ) ; nextconfig = config . getprocessor ( ) . newdocumentbuilder ( ) . build ( new saxsource ( new inputsource ( new filereader ( configfile ) ) ) ) ; } catch ( filenotfoundexception e ) { throw new illegalargumentexception ( str_ , e ) ; } catch ( saxonapiexception e ) { throw new runtimeexception ( e ) ; } }	Settings from a custom calabash.xml.
public void setdefaultconfiguration ( reader defaultconfig ) { xprocconfiguration config = new xprocconfiguration ( str_ , bool_ ) ; try { nextdefaultconfig = config . getprocessor ( ) . newdocumentbuilder ( ) . build ( new saxsource ( new inputsource ( defaultconfig ) ) ) ; } catch ( saxonapiexception e ) { throw new runtimeexception ( e ) ; } }	Settings to be always applied.
static void initializefxmlloader ( final fxmlloader fxmlloader , final class < ? > targetclass , final string location , final string resources , final string charset ) { checkandsetlocation ( fxmlloader , targetclass , location ) ; if ( charset != null && ! charset . equals ( charset_unspecified ) ) { fxmlloader . setcharset ( charset . forname ( charset ) ) ; } if ( resources != null && ! resources . equals ( resources_unspecified ) ) { fxmlloader . setresources ( resourcebundle . getbundle ( resources ) ) ; } }	Initializes the given FXMLLoader instance using the provided parameters.
public reversegeocoderequestbuilder latlng ( double lat , double lng ) { parameters . put ( str_ , lat + str_ + lng ) ; return this ; }	The location latitude and longitude.This parameter is required.
public static inetsocketaddress gethostportpair ( service svc ) { try { return new inetsocketaddress ( svc . getmetadata ( ) . get ( str_ ) , integer . parseint ( svc . getmetadata ( ) . get ( str_ ) ) ) ; } catch ( exception e ) { logger . error ( str_ , svc , e ) ; return null ; } }	Safely get the information from our convention.
protected attributedefinition getapplicableattributedefinition ( final uuid attributedefinitionuuid , final list < attributedefinition > attributedefinitions ) { if ( log . istraceenabled ( ) ) { log . entry ( attributedefinitionuuid , attributedefinitions ) ; } attributedefinition attributedefinition = null ; for ( attributedefinition anattributedefinition : attributedefinitions ) { if ( anattributedefinition . getuuid ( ) . equals ( attributedefinitionuuid ) ) { attributedefinition = anattributedefinition ; break ; } } if ( log . istraceenabled ( ) ) { log . exit ( attributedefinition ) ; } return attributedefinition ; }	Find an attribute definition that applies to a particular attribute filter.
protected boolean evaluate ( final uuid attributedefinitionuuid , final attributefilterexpression attributefilter , final map < uuid , string > eventattributes , final list < attributedefinition > attributedefinitions ) throws parseexception { if ( log . istraceenabled ( ) ) { log . entry ( attributedefinitionuuid , attributefilter , eventattributes , attributedefinitions ) ; }	Evaluate single attribute filter.
public static string sanitizetag ( string s ) {	1..55 chars. anything goes.
public geocoderequestbuilder address ( string address ) { parameters . put ( str_ , address != null ? address . replace ( str_ , str_ ) : address ) ; return this ; }	The address that you want to geocode.
public collection < string > queryfornames ( ) throws exception { set < string > names = new hashset < string > ( ) ;	return all distinct names registered by this discovery type.
public collection < serviceinstance < t > > queryforinstances ( string name ) throws exception { list < serviceinstance < t > > serviceinstances = new arraylist < serviceinstance < t > > ( ) ; iterator < service > services = client . getservicesclient ( ) . list ( new methodoptions ( num_ , null ) ) ; while ( services . hasnext ( ) ) { service service = services . next ( ) ; if ( service . gettags ( ) . contains ( typetag ) && service . getmetadata ( ) . get ( servicetracker . name ) . equals ( name ) ) {	return all instances registered to this particular name for this discovery type.
public list < collaboration > getalltobyloggedin ( ) { collaborationlisting collaborationlisting = new collaborationlisting ( ) ; if ( this . serviceticket != null ) { collaborationlisting . setserviceticket ( this . serviceticket ) ; } return new collaborationlisting ( this . postjson ( collaborationlisting , ws . path . collaboration . version1 . getalltobyloggedin ( ) ) ) . getlisting ( ) ; }	Retrieve all Collaboration items TO where logged in user.
protected string getmetadatafordecimalas ( string metadataprefixparam , double minparam , double maxparam , double stepfactorparam , string prefixparam ) { stringbuffer returnbuffer = new stringbuffer ( ) ; if ( metadataprefixparam != null && ! metadataprefixparam . isempty ( ) ) { returnbuffer . append ( metadataprefixparam ) ; }	Construct the correct Meta-Data from parameters.
public user changepasswordforloggedinuser ( string existingpasswordparam , string newpasswordparam , string confirmnewpasswordparam ) { user tochangepasswordfor = new user ( ) ; if ( this . serviceticket != null ) { tochangepasswordfor . setserviceticket ( this . serviceticket ) ; } string existingpassword = existingpasswordparam == null ? utilglobal . empty : existingpasswordparam ; string newpassword = newpasswordparam == null ? utilglobal . empty : newpasswordparam ; string confirmnewpassword = confirmnewpasswordparam == null ? utilglobal . empty : confirmnewpasswordparam ; jsonobject passwordclear = new jsonobject ( ) ; passwordclear . put ( str_ , existingpassword ) ; passwordclear . put ( str_ , newpassword ) ; passwordclear . put ( str_ , confirmnewpassword ) ; tochangepasswordfor . setpasswordclear ( passwordclear . tostring ( ) ) ; return new user ( this . postjson ( tochangepasswordfor , ws . path . user . version1 . changepassword ( ) ) ) ; }	Change the password for the currently logged in user.
public userlisting getallusers ( ) { userlisting usertogetinfofor = new userlisting ( ) ; if ( this . serviceticket != null ) { usertogetinfofor . setserviceticket ( this . serviceticket ) ; } try { return new userlisting ( this . postjson ( usertogetinfofor , ws . path . user . version1 . getallusers ( ) ) ) ; }	Retrieves all user information.
public byte [ ] getgravatarforemail ( string emailaddressparam , int sizeparam ) { try { jsonobject gravatarjsonobj = this . getjson ( ws . path . user . version1 . getgravatarbyemail ( emailaddressparam , sizeparam ) ) ; string base64text = gravatarjsonobj . optstring ( json_tag_data , str_ ) ; if ( base64text == null || base64text . isempty ( ) ) { return null ; } return utilglobal . decodebase64 ( base64text ) ; }	Retrieve the gravatar bytes by email.
public byte [ ] getgravatarforuser ( user userparam , int sizeparam ) { if ( userparam == null ) { return null ; } try { jsonobject gravatarjsonobj = this . postjson ( userparam , ws . path . user . version1 . getgravatarbyuser ( sizeparam ) ) ; string base64text = gravatarjsonobj . optstring ( json_tag_data , str_ ) ; if ( base64text == null || base64text . isempty ( ) ) { return null ; } return utilglobal . decodebase64 ( base64text ) ; }	Retrieve the gravatar bytes for Fluid user.
@ override @ xmltransient public void populatefromelasticsearchjson ( jsonobject jsonobjectparam , list < field > formfieldsparam ) throws jsonexception { throw new fluidelasticsearchexception ( str_ ) ; }	Not allowed to call this method.
@ xmltransient public string getelasticsearchfieldtype ( ) { type fieldtype = this . gettypeasenum ( ) ; if ( fieldtype == null ) { return null ; }	Returns the ElasticSearch equivalent data field-type from the Fluid datatype.
public flowstep createflowstep ( flowstep flowstepparam ) { if ( flowstepparam != null && this . serviceticket != null ) { flowstepparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . putjson ( flowstepparam , ws . path . flowstep . version1 . flowstepcreate ( ) ) ) ; }	Creates a new Flow Step.
public flowstep updateflowstep ( flowstep flowstepparam ) { if ( flowstepparam != null && this . serviceticket != null ) { flowstepparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepparam , ws . path . flowstep . version1 . flowstepupdate ( ) ) ) ; }	Updates an existing Flow Step.
public flowstep getflowstepbyid ( long flowstepidparam , string flowsteptypeparam ) { flowstep flowstep = new flowstep ( flowstepidparam ) ; flowstep . setflowsteptype ( flowsteptypeparam ) ; if ( this . serviceticket != null ) { flowstep . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstep , ws . path . flowstep . version1 . getbyid ( ) ) ) ; }	Retrieves an existing Flow Step via Primary key.
public flowstep getflowstepbystep ( flowstep flowstepparam ) { if ( this . serviceticket != null && flowstepparam != null ) { flowstepparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepparam , ws . path . flowstep . version1 . getbystep ( ) ) ) ; }	Retrieves an existing Flow Step via Step.Lookup will include id, then;Name.
public flowsteplisting getstepsbyflow ( flow flowparam ) { if ( this . serviceticket != null && flowparam != null ) { flowparam . setserviceticket ( this . serviceticket ) ; } return new flowsteplisting ( this . postjson ( flowparam , ws . path . flowstep . version1 . getallstepsbyflow ( ) ) ) ; }	Retrieves all Steps via Flow.
public flowstep deleteflowstep ( flowstep flowstepparam ) { if ( flowstepparam != null && this . serviceticket != null ) { flowstepparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepparam , ws . path . flowstep . version1 . flowstepdelete ( ) ) ) ; }	Delete an existing Flow Step.
public flowstep forcedeleteflowstep ( flowstep flowstepparam ) { if ( flowstepparam != null && this . serviceticket != null ) { flowstepparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepparam , ws . path . flowstep . version1 . flowstepdelete ( bool_ ) ) ) ; }	Forcefully delete an existing Flow Step.Only 'admin' can forcefully delete a step.
protected final list < form > populatetablefields ( boolean addalltablerecordsforreturnparam , boolean includefielddataparam , list < field > formfieldsparam ) { if ( formfieldsparam == null || formfieldsparam . isempty ( ) ) { return null ; } list < form > alltablerecordsfromallfields = addalltablerecordsforreturnparam ? new arraylist ( ) : null ;	Populate all the Table Field values from the Table index.
@ override public void closeconnection ( ) { closeconnectionrunnable closeconnectionrunnable = new closeconnectionrunnable ( this ) ; thread closeconnthread = new thread ( closeconnectionrunnable , str_ ) ; closeconnthread . start ( ) ; }	Close the SQL and ElasticSearch Connection.
@ override public void handlemessage ( object objecttoprocess ) {	'Handles' the message.If there was an error, the object will be ErrorIf there was no error, the object will be JSONObject.
@ override public void connectionclosed ( ) { this . isconnectionclosed = bool_ ; if ( this . completablefuture != null ) {	Event for when connection is closed.
private list < string > getechomessagesfromreturnvalue ( ) { list < string > returnlisting = new arraylist ( ) ; if ( this . returnvalue == null ) { return returnlisting ; } iterator < t > iterforreturnval = this . returnvalue . iterator ( ) ;	Gets a list of echo messages of the current return values.
public list < fluiditem > getpersonalinventoryitems ( ) { user loggedinuser = new user ( ) ; if ( this . serviceticket != null ) { loggedinuser . setserviceticket ( this . serviceticket ) ; } try { return new fluiditemlisting ( this . postjson ( loggedinuser , ws . path . personalinventory . version1 . getallbyloggedinuser ( ) ) ) . getlisting ( ) ; }	Retrieves all Personal Inventory items for the logged in user.
public tablerecord createtablerecord ( tablerecord tablerecordparam ) { if ( tablerecordparam != null && this . serviceticket != null ) { tablerecordparam . setserviceticket ( this . serviceticket ) ; } return new tablerecord ( this . putjson ( tablerecordparam , ws . path . formcontainertablerecord . version1 . formcontainertablerecordcreate ( ) ) ) ; }	Create a new Table Record.
public form deleteformcontainer ( form formcontainerparam ) { if ( formcontainerparam != null && this . serviceticket != null ) { formcontainerparam . setserviceticket ( this . serviceticket ) ; } return new form ( this . postjson ( formcontainerparam , ws . path . formcontainer . version1 . formcontainerdelete ( ) ) ) ; }	Deletes the Form Container provided.Id must be set on the Form Container.
public list < formflowhistoricdata > getformflowhistoricdata ( form formparam ) { if ( formparam != null && this . serviceticket != null ) { formparam . setserviceticket ( this . serviceticket ) ; } return new formflowhistoricdatalisting ( this . postjson ( formparam , ws . path . flowitemhistory . version1 . getbyformcontainer ( ) ) ) . getlisting ( ) ; }	Retrieves Electronic Form Workflow historic information.The Form Id must be provided.
public list < formhistoricdata > getformandfieldhistoricdata ( form formparam , boolean includecurrentparam ) { if ( formparam != null && this . serviceticket != null ) { formparam . setserviceticket ( this . serviceticket ) ; } return new formhistoricdatalisting ( this . postjson ( formparam , ws . path . formhistory . version1 . getbyformcontainer ( includecurrentparam ) ) ) . getlisting ( ) ; }	Retrieves Electronic Form and Field historic information.The Form Id must be provided.
public formhistoricdata getmostrecentformandfieldhistoricdata ( form formparam ) { if ( formparam != null && this . serviceticket != null ) { formparam . setserviceticket ( this . serviceticket ) ; } return new formhistoricdata ( this . postjson ( formparam , ws . path . formhistory . version1 . getbymostrecentbyformcontainer ( ) ) ) ; }	Retrieves Electronic Form and Field historic information forthe most recent modification.The Form Id must be provided.
public form lockformcontainer ( form formparam , jobview jobviewparam ) { return this . lockformcontainer ( formparam , jobviewparam , null ) ; }	Lock the provided form container for logged in user.
public form unlockformcontainer ( form formparam , boolean unlockasyncparam ) { return this . unlockformcontainer ( formparam , null , unlockasyncparam , bool_ ) ; }	Unlock the provided form container from the logged in user.Item will not be removed from users Personal Inventory.
public form unlockformcontainer ( form formparam , user usertounlockasparam , boolean unlockasyncparam , boolean removefrompersonalinventoryparam ) { if ( this . serviceticket != null && formparam != null ) { formparam . setserviceticket ( this . serviceticket ) ; } long unlockasuserid = ( usertounlockasparam == null ) ? null : usertounlockasparam . getid ( ) ; try { return new form ( this . postjson ( formparam , ws . path . formcontainer . version1 . unlockformcontainer ( unlockasuserid , unlockasyncparam , removefrompersonalinventoryparam ) ) ) ; }	Unlock the provided form container from the logged in user.
private form mapformcontainerto ( map < long , string > definitionandtitleparam , resultset resultsetparam ) throws sqlexception { long formid = resultsetparam . getlong ( sqlcolumnindex . _01_form_id ) ; string formtype = definitionandtitleparam . get ( resultsetparam . getlong ( sqlcolumnindex . _02_form_type ) ) ; string title = resultsetparam . getstring ( sqlcolumnindex . _03_title ) ; date created = resultsetparam . getdate ( sqlcolumnindex . _04_created ) ; date lastupdated = resultsetparam . getdate ( sqlcolumnindex . _05_last_updated ) ; long currentuserid = resultsetparam . getlong ( sqlcolumnindex . _06_current_user_id ) ; if ( formtype == null ) { throw new sqlexception ( str_ + resultsetparam . getlong ( sqlcolumnindex . _02_form_type ) + str_ ) ; } form toadd = new form ( formtype ) ; toadd . setid ( formid ) ; toadd . settitle ( title ) ;	Maps the Form to the provided Definition-Id and Title.
@ xmltransient public static list < role > converttoobjects ( string rolelistingparam ) { if ( rolelistingparam == null || rolelistingparam . trim ( ) . isempty ( ) ) { return null ; } string [ ] listofroles = rolelistingparam . split ( utilglobal . reg_ex_comma ) ; list < role > returnval = new arraylist < > ( ) ; for ( string rolename : listofroles ) { role roletoadd = new role ( ) ; roletoadd . setname ( rolename . trim ( ) ) ; returnval . add ( roletoadd ) ; } return returnval ; }	Convert the comma separated list of roles as objects.
public form createformdefinition ( form formdefinitionparam ) { if ( formdefinitionparam != null && this . serviceticket != null ) { formdefinitionparam . setserviceticket ( this . serviceticket ) ; } return new form ( this . putjson ( formdefinitionparam , ws . path . formdefinition . version1 . formdefinitioncreate ( ) ) ) ; }	Creates a new Form Definition with the Fields inside the definition.
public form updateformdefinition ( form formdefinitionparam ) { if ( formdefinitionparam != null && this . serviceticket != null ) { formdefinitionparam . setserviceticket ( this . serviceticket ) ; } return new form ( this . postjson ( formdefinitionparam , ws . path . formdefinition . version1 . formdefinitionupdate ( ) ) ) ; }	Updates an existing Form Definition with the Fields inside the definition.
public form getformdefinitionbyid ( long formdefinitionidparam ) { form form = new form ( formdefinitionidparam ) ; if ( this . serviceticket != null ) { form . setserviceticket ( this . serviceticket ) ; } return new form ( this . postjson ( form , ws . path . formdefinition . version1 . getbyid ( ) ) ) ; }	Retrieves the Form Definition by Primary key.
public form getformdefinitionbyname ( string formdefinitionnameparam ) { form form = new form ( formdefinitionnameparam ) ; if ( this . serviceticket != null ) { form . setserviceticket ( this . serviceticket ) ; } return new form ( this . postjson ( form , ws . path . formdefinition . version1 . getbyname ( ) ) ) ; }	Retrieves the Form Definition by Name.
public list < form > getallbyloggedinuser ( boolean includetablerecordtypesparam ) { form form = new form ( ) ; if ( this . serviceticket != null ) { form . setserviceticket ( this . serviceticket ) ; } if ( includetablerecordtypesparam ) { return new formlisting ( this . postjson ( form , ws . path . formdefinition . version1 . getallbyloggedinuserincludetabletypes ( ) ) ) . getlisting ( ) ; } else { return new formlisting ( this . postjson ( form , ws . path . formdefinition . version1 . getallbyloggedinuser ( ) ) ) . getlisting ( ) ; } }	Retrieves all Form Definitions by logged in user.
public form deleteformdefinition ( form formdefinitionparam ) { if ( formdefinitionparam != null && this . serviceticket != null ) { formdefinitionparam . setserviceticket ( this . serviceticket ) ; } return new form ( this . postjson ( formdefinitionparam , ws . path . formdefinition . version1 . formdefinitiondelete ( ) ) ) ; }	Deletes the Form Definition provided.Id must be set on the Form Definition.
private string getstoragekeyfrom ( long formdefidparam , long formcontidparam , long formfieldidparam ) { stringbuilder stringbuff = new stringbuilder ( ) ;	Generates the storage key the provided parameters.
private memcachedclient initxmemcachedclient ( ) { if ( this . memcachedclient != null && ! this . memcachedclient . isshutdown ( ) ) { return this . memcachedclient ; } try { this . memcachedclient = new xmemcachedclient ( this . cachehost , this . cacheport ) ; return this . memcachedclient ; }	Creates an instance of MemcachedClient.
public void shutdown ( ) { if ( this . memcachedclient != null && ! this . memcachedclient . isshutdown ( ) ) { try { this . memcachedclient . shutdown ( ) ; }	Closes the Memcached client connection.
protected long tolongsafe ( string toparseparam ) { if ( toparseparam == null || toparseparam . trim ( ) . isempty ( ) ) { return - num_ ; } try { return long . parselong ( toparseparam . trim ( ) ) ; } catch ( numberformatexception e ) { return - num_ ; } }	Returns -1 if there is a problem with conversion.
public file convertdocumenttopdf ( file inputdocumentparam ) { if ( inputdocumentparam == null || ! inputdocumentparam . exists ( ) ) { throw new utilexception ( str_ , utilexception . errorcode . command ) ; } if ( ! inputdocumentparam . isfile ( ) ) { throw new utilexception ( str_ , utilexception . errorcode . command ) ; } file parentfolder = inputdocumentparam . getparentfile ( ) ; string inputfilenamewithoutext = inputdocumentparam . getname ( ) ; int indexofdot = - num_ ; if ( ( indexofdot = inputfilenamewithoutext . indexof ( str_ ) ) > - num_ ) { inputfilenamewithoutext = inputfilenamewithoutext . substring ( num_ , indexofdot ) ; } file generatedpdffileout = new file ( parentfolder . getabsolutepath ( ) . concat ( file . separator ) . concat ( inputfilenamewithoutext ) . concat ( str_ ) ) ; string completeoutputpath = generatedpdffileout . getabsolutepath ( ) ; try { commandutil . commandresult commandresult = this . commandutil . executecommand ( commandutil . fluid_cli , command_convert_doc_to_pdf , str_ , inputdocumentparam . getabsolutepath ( ) , str_ , completeoutputpath ) ;	Makes use of the Fluid Core to convert a document into a PDF file.
private list < field > getfieldvaluesforformfromcache ( long formidparam , list < formfieldlisting > listingreturnfieldvalspopulatedparam , form [ ] formstofetchforlocalcachearrparam ) { if ( formidparam == null || formidparam . longvalue ( ) < num_ ) { return null ; } if ( listingreturnfieldvalspopulatedparam == null || listingreturnfieldvalspopulatedparam . isempty ( ) ) { return null ; } if ( formstofetchforlocalcachearrparam == null || formstofetchforlocalcachearrparam . length == num_ ) { return null ; } for ( form formiter : formstofetchforlocalcachearrparam ) {	Populate the field values from the cache.
public flowsteprule createflowstepentryrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . putjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleentrycreate ( ) ) ) ; }	Create a new Flow Step Entry rule.
public flowsteprule createflowstepexitrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . putjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleexitcreate ( ) ) ) ; }	Create a new Flow Step Exit rule.
public flowsteprule createflowstepviewrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . putjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleviewcreate ( ) ) ) ; }	Create a new Flow Step View rule.
public flowsteprule updateflowstepentryrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleupdateentry ( ) ) ) ; }	Update an existing Flow Step Entry rule.
public flowsteprule updateflowstepexitrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleupdateexit ( ) ) ) ; }	Update an existing Flow Step Exit rule.
public flowsteprule updateflowstepviewrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruleupdateview ( ) ) ) ; }	Update an existing Flow Step View rule.
public flowsteprule moveflowstepentryruleup ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowsteprulemoveentryup ( ) ) ) ; }	Moves an entry rule order one up from the current location.
public flowsteprule moveflowstepentryruledown ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowsteprulemoveentrydown ( ) ) ) ; }	Moves an entry rule order one down from the current location.
public flowsteprule deleteflowstepentryrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowsteprule ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruledeleteentry ( ) ) ) ; }	Deletes an Step Entry rule.
public flowstep deleteflowstepexitrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruledeleteexit ( ) ) ) ; }	Deletes an Step Exit rule.
public flowstep deleteflowstepviewrule ( flowsteprule flowstepruleparam ) { if ( flowstepruleparam != null && this . serviceticket != null ) { flowstepruleparam . setserviceticket ( this . serviceticket ) ; } return new flowstep ( this . postjson ( flowstepruleparam , ws . path . flowsteprule . version1 . flowstepruledeleteview ( ) ) ) ; }	Deletes an Step View rule.
private authencrypteddata initializesession ( string passwordparam , authresponse authresponseparam ) {	Performs HMAC and encryption to initialize the session.
public userquerylisting getalluserqueries ( ) { userquery userquerytogetinfofor = new userquery ( ) ; if ( this . serviceticket != null ) { userquerytogetinfofor . setserviceticket ( this . serviceticket ) ; } try { return new userquerylisting ( this . postjson ( userquerytogetinfofor , ws . path . userquery . version1 . getalluserqueries ( ) ) ) ; }	Retrieves all user query information.
public rolelisting getallroles ( ) { rolelisting roletogetinfofor = new rolelisting ( ) ; if ( this . serviceticket != null ) { roletogetinfofor . setserviceticket ( this . serviceticket ) ; } try { return new rolelisting ( this . postjson ( roletogetinfofor , ws . path . role . version1 . getallroles ( ) ) ) ; }	Retrieves all role information.
public string getserviceticketashexupper ( ) { string serviceticket = this . getserviceticket ( ) ; if ( serviceticket == null ) { return null ; } if ( serviceticket . isempty ( ) ) { return serviceticket ; } byte [ ] base64bytes = base64 . getdecoder ( ) . decode ( serviceticket ) ; return this . bytestohex ( base64bytes ) ; }	Gets the Service Ticket associated with the Fluid session as HEX.
public field createfieldtextmasked ( field formfieldparam , string maskvalueparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( maskvalueparam == null || maskvalueparam . trim ( ) . isempty ( ) ) { maskvalueparam = str_ ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . text ) ; formfieldparam . settypemetadata ( fieldmetadata . text . masked . concat ( maskvalueparam ) ) ; } return new field ( this . putjson ( formfieldparam , ws . path . formfield . version1 . formfieldcreate ( ) ) ) ; }	Create a new Text Masked field.
public field createfieldtextbarcode ( field formfieldparam , string barcodetypeparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( barcodetypeparam == null || barcodetypeparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . text ) ; formfieldparam . settypemetadata ( fieldmetadata . text . barcode . concat ( barcodetypeparam ) ) ; } return new field ( this . putjson ( formfieldparam , ws . path . formfield . version1 . formfieldcreate ( ) ) ) ; }	Create a new Text Barcode field.
public field createfielddecimalspinner ( field formfieldparam , double minparam , double maxparam , double stepfactorparam , string prefixparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . decimal ) ; formfieldparam . settypemetadata ( this . getmetadatafordecimalas ( fieldmetadata . decimal . spinner , minparam , maxparam , stepfactorparam , prefixparam ) ) ; } return new field ( this . putjson ( formfieldparam , ws . path . formfield . version1 . formfieldcreate ( ) ) ) ; }	Create a new Decimal Spinner field.
public field createfielddecimalslider ( field formfieldparam , double minparam , double maxparam , double stepfactorparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . decimal ) ; formfieldparam . settypemetadata ( this . getmetadatafordecimalas ( fieldmetadata . decimal . slider , minparam , maxparam , stepfactorparam , null ) ) ; } return new field ( this . putjson ( formfieldparam , ws . path . formfield . version1 . formfieldcreate ( ) ) ) ; }	Create a new Decimal Slider field.
public field createfieldtable ( field formfieldparam , form formdefinitionparam , boolean sumdecimalsparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . table ) ; formfieldparam . settypemetadata ( this . getmetadatafortablefield ( formdefinitionparam , sumdecimalsparam ) ) ; } return new field ( this . putjson ( formfieldparam , ws . path . formfield . version1 . formfieldcreate ( ) ) ) ; }	Creates a new Table Field.
public field updatefieldtextmasked ( field formfieldparam , string maskvalueparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( maskvalueparam == null || maskvalueparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . text ) ; formfieldparam . settypemetadata ( fieldmetadata . text . masked . concat ( maskvalueparam ) ) ; } return new field ( this . postjson ( formfieldparam , ws . path . formfield . version1 . formfieldupdate ( ) ) ) ; }	Update an existing Masked Text field.
public field updatefieldtextbarcode ( field formfieldparam , string barcodetypeparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( barcodetypeparam == null || barcodetypeparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . text ) ; formfieldparam . settypemetadata ( fieldmetadata . text . barcode . concat ( barcodetypeparam ) ) ; } return new field ( this . postjson ( formfieldparam , ws . path . formfield . version1 . formfieldupdate ( ) ) ) ; }	Update an existing Barcode Text field.
public field updatefielddecimalspinner ( field formfieldparam , double minparam , double maxparam , double stepfactorparam , string prefixparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . decimal ) ; formfieldparam . settypemetadata ( this . getmetadatafordecimalas ( fieldmetadata . decimal . spinner , minparam , maxparam , stepfactorparam , prefixparam ) ) ; } return new field ( this . postjson ( formfieldparam , ws . path . formfield . version1 . formfieldupdate ( ) ) ) ; }	Updates the Decimal Spinner field.
public field updatefielddecimalslider ( field formfieldparam , double minparam , double maxparam , double stepfactorparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . decimal ) ; formfieldparam . settypemetadata ( this . getmetadatafordecimalas ( fieldmetadata . decimal . slider , minparam , maxparam , stepfactorparam , null ) ) ; } return new field ( this . postjson ( formfieldparam , ws . path . formfield . version1 . formfieldupdate ( ) ) ) ; }	Updates the Decimal Slider field.
public field updatefieldtable ( field formfieldparam , form formdefinitionparam , boolean sumdecimalsparam ) { if ( formfieldparam != null && this . serviceticket != null ) { formfieldparam . setserviceticket ( this . serviceticket ) ; } if ( formfieldparam != null ) { formfieldparam . settypeasenum ( field . type . table ) ; formfieldparam . settypemetadata ( this . getmetadatafortablefield ( formdefinitionparam , sumdecimalsparam ) ) ; } return new field ( this . postjson ( formfieldparam , ws . path . formfield . version1 . formfieldupdate ( ) ) ) ; }	Updates a Table Field.
public field getfieldbyname ( string fieldnameparam ) { field field = new field ( ) ; field . setfieldname ( fieldnameparam ) ; if ( this . serviceticket != null ) { field . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( field , ws . path . formfield . version1 . getbyname ( ) ) ) ; }	Retrieve a Form Field via name.
public formfieldlisting getfieldsbyformnameandloggedinuser ( string formnameparam , boolean editonlyfieldsparam ) { form form = new form ( ) ; form . setformtype ( formnameparam ) ; if ( this . serviceticket != null ) { form . setserviceticket ( this . serviceticket ) ; } return new formfieldlisting ( this . postjson ( form , ws . path . formfield . version1 . getbyformdefinitionandloggedinuser ( editonlyfieldsparam ) ) ) ; }	Retrieve the Form Fields via Form Definition name.
public formfieldlisting getfieldsbyformtypeidandloggedinuser ( long formtypeidparam , boolean editonlyfieldsparam ) { form form = new form ( ) ; form . setformtypeid ( formtypeidparam ) ; if ( this . serviceticket != null ) { form . setserviceticket ( this . serviceticket ) ; } return new formfieldlisting ( this . postjson ( form , ws . path . formfield . version1 . getbyformdefinitionandloggedinuser ( editonlyfieldsparam ) ) ) ; }	Retrieve the Form Fields via Form Definition id.
public field deletefield ( field fieldparam ) { if ( fieldparam != null && this . serviceticket != null ) { fieldparam . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( fieldparam , ws . path . formfield . version1 . formfielddelete ( ) ) ) ; }	Deletes the provided field.Ensure that Id is set.
public field forcedeletefield ( field fieldparam ) { if ( fieldparam != null && this . serviceticket != null ) { fieldparam . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( fieldparam , ws . path . formfield . version1 . formfielddelete ( bool_ ) ) ) ; }	Forcefully deletes the provided field.Ensure that Id is set.Only 'admin' is able to forcefully delete a field.
private string getmetadatafortablefield ( form formdefinitionparam , boolean sumdecimalsparam ) { stringbuilder returnbuffer = new stringbuilder ( ) ; long definitionid = ( formdefinitionparam == null ) ? - num_ : formdefinitionparam . getid ( ) ;	Generates the Meta Data for a table field.
public field updatefieldvalue ( field userfieldvalueparam ) { if ( userfieldvalueparam != null && this . serviceticket != null ) { userfieldvalueparam . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( userfieldvalueparam , ws . path . userfield . version1 . userfieldupdatevalue ( ) ) ) ; }	Update an existing User field value.
public getindexresponse getorcreateindex ( string indexparam ) { if ( this . doesindexexist ( indexparam ) ) { return this . client . admin ( ) . indices ( ) . preparegetindex ( ) . get ( ) ; } else { createindexrequestbuilder createindexrequestbuilder = this . client . admin ( ) . indices ( ) . preparecreate ( indexparam ) ; createindexresponse mappingcreateresponse = createindexrequestbuilder . execute ( ) . actionget ( ) ; if ( ! mappingcreateresponse . isacknowledged ( ) ) { throw new fluidelasticsearchexception ( str_ + indexparam + str_ ) ; } return this . client . admin ( ) . indices ( ) . preparegetindex ( ) . get ( ) ; } }	Creates a new index or fetches existing index.
public flow createflow ( flow flowparam ) { if ( flowparam != null && this . serviceticket != null ) { flowparam . setserviceticket ( this . serviceticket ) ; } return new flow ( this . putjson ( flowparam , ws . path . flow . version1 . flowcreate ( ) ) ) ; }	Creates a new Flow with an Introduction and Exit basic rule.
public flow updateflow ( flow flowparam ) { if ( flowparam != null && this . serviceticket != null ) { flowparam . setserviceticket ( this . serviceticket ) ; } return new flow ( this . postjson ( flowparam , ws . path . flow . version1 . flowupdate ( ) ) ) ; }	Updates an existing Flow.
public flow getflowbyid ( long flowidparam ) { flow flow = new flow ( flowidparam ) ; if ( this . serviceticket != null ) { flow . setserviceticket ( this . serviceticket ) ; } return new flow ( this . postjson ( flow , ws . path . flow . version1 . getbyid ( ) ) ) ; }	Retrieves a Flow by Primary Key.
public flow getflowbyname ( string flownameparam ) { flow flow = new flow ( ) ; flow . setname ( flownameparam ) ; if ( this . serviceticket != null ) { flow . setserviceticket ( this . serviceticket ) ; } return new flow ( this . postjson ( flow , ws . path . flow . version1 . getbyname ( ) ) ) ; }	Retrieves a Flow by unique Name.
public flow deleteflow ( flow flowparam ) { if ( flowparam != null && this . serviceticket != null ) { flowparam . setserviceticket ( this . serviceticket ) ; } return new flow ( this . postjson ( flowparam , ws . path . flow . version1 . flowdelete ( ) ) ) ; }	Delete an existing Flow.
public flow forcedeleteflow ( flow flowparam ) { if ( flowparam != null && this . serviceticket != null ) { flowparam . setserviceticket ( this . serviceticket ) ; } return new flow ( this . postjson ( flowparam , ws . path . flow . version1 . flowdelete ( bool_ ) ) ) ; }	Forcefully Delete an existing Flow.Only 'admin' can forcefully delete a Flow.
public field updatefieldvalue ( field globalfieldvalueparam ) { if ( globalfieldvalueparam != null && this . serviceticket != null ) { globalfieldvalueparam . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( globalfieldvalueparam , version1 . globalfieldupdatevalue ( ) ) ) ; }	Update an existing Global field value.
public list < field > getallglobalfieldvalues ( ) { field field = new field ( ) ;	Retrieve all the Global field values.
public map < long , string > getformdefinitionidandtitle ( ) {	Retrieves the Form Definition and Title mappingcurrently stored in Fluid.
public static byte [ ] decryptinitpacket ( byte [ ] encrypteddataparam , string passwordparam , string saltparam , byte [ ] ivparam , byte [ ] seedparam ) {	Decrypts the encrypted data.
@ override public void closeandclean ( ) { closeconnectionrunnable closeconnectionrunnable = new closeconnectionrunnable ( this ) ; thread closeconnthread = new thread ( closeconnectionrunnable , str_ ) ; closeconnthread . start ( ) ; }	If the HTTP Client is set, this willclose and clean any connections that needs to be closed.
public synchronized string initnewrequest ( ) { string returnval = uuid . randomuuid ( ) . tostring ( ) ; this . messagehandler . put ( returnval , this . getnewhandlerinstance ( ) ) ; return returnval ; }	Initiate a new request process.Synchronized.
protected string getexceptionmessageverbose ( string prefixparam , string uniquereqidparam , int numberofsentitemsparam ) { stringbuilder formfieldscombined = new stringbuilder ( ) ; int returnvalsize = - num_ ; resphandler resphandler = this . gethandler ( uniquereqidparam ) ; if ( resphandler instanceof agenericlistmessagehandler ) { list < ? extends abasefluidjsonobject > returnvalue = ( ( agenericlistmessagehandler ) resphandler ) . getreturnvalue ( ) ; if ( returnvalue != null ) { returnvalsize = returnvalue . size ( ) ; returnvalue . foreach ( listingitm -> { if ( listingitm instanceof abaselisting ) { abaselisting castedtolisting = ( abaselisting ) listingitm ; if ( castedtolisting != null ) { castedtolisting . getlisting ( ) . foreach ( formitm -> { formfieldscombined . append ( formitm . tostring ( ) ) ; } ) ; } } else { formfieldscombined . append ( listingitm . tostring ( ) ) ; } } ) ; } } return ( prefixparam + str_ + str_ + returnvalsize + str_ + ( timeunit . milliseconds . toseconds ( this . gettimeoutinmillis ( ) ) ) + str_ + uniquereqidparam + str_ + numberofsentitemsparam + str_ + formfieldscombined . tostring ( ) + str_ ) ; }	Generate a verbose Exception message.
public user createadminuser ( string passwordparam ) { user adminusercreate = new user ( ) ; adminusercreate . setpasswordclear ( passwordparam ) ; return new user ( this . putjson ( adminusercreate , ws . path . user . version1 . usercreateadmin ( ) ) ) ; }	Create a new administrator user for Fluid.This function only works if there are no pre-existing admin user.
public accesstoken getaccesstoken ( string clientidparam , string clientsecretparam , string codeparam , string redirecturlparam ) { if ( clientidparam == null || clientidparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( clientsecretparam == null || clientsecretparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( codeparam == null || codeparam . trim ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } accesstokenrequest tokenrequest = new accesstokenrequest ( ) ; tokenrequest . setclientid ( clientidparam ) ; tokenrequest . setclientsecret ( clientsecretparam ) ; tokenrequest . setgranttype ( authorization_code ) ; tokenrequest . setcode ( codeparam ) ; tokenrequest . setredirecturi ( redirecturlparam ) ; return new accesstoken ( this . postjson ( bool_ , tokenrequest , ws . path . auth0 . version1 . usertoken ( ) ) ) ; }	Gets a Access Token from Auth0.
public normalizeduserprofile getuserprofileinfo ( accesstoken accesstokenparam ) { if ( accesstokenparam == null || ( accesstokenparam . getaccesstoken ( ) == null || accesstokenparam . getaccesstoken ( ) . trim ( ) . isempty ( ) ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } try { string accesstoken = accesstokenparam . getaccesstoken ( ) ; list < headernamevalue > headerlisting = new arraylist < headernamevalue > ( ) ; headerlisting . add ( new headernamevalue ( normalizeduserprofile . headermapping . authorization , str_ + accesstoken ) ) ; return new normalizeduserprofile ( this . getjson ( bool_ , ws . path . auth0 . version1 . userinfo ( ) , headerlisting ) ) ; }	Gets Auth0 Normalized User Profile info.
protected jsonobject executejson ( httpmethod httpmethodparam , list < headernamevalue > headernamevaluesparam , boolean checkconnectionvalidparam , abasefluidjsonobject basedomainparam , contenttype contenttypeparam , string postfixurlparam ) {	Submit a JSON based HTTP request body with JSON as a response.
protected jsonobject executeform ( httpmethod httpmethodparam , list < headernamevalue > headernamevaluesparam , boolean checkconnectionvalidparam , list < formnamevalue > formnamevaluesparam , contenttype contenttypeparam , string postfixurlparam ) {	Submit a HTML Form based HTTP request body with JSON as a response.
private responsehandler < string > getjsonresponsehandler ( final string urlcalledparam ) {	Get a text based response handler used mainly for JSON.
public boolean isconnectionvalid ( ) {	Performs a HTTP Get against the connection test Web Service toconfirm whether the connection is valid.
private closeablehttpclient getclient ( ) { if ( this . closeablehttpclient != null ) { return this . closeablehttpclient ; }	Creates a new Http client.If part of a test run, the Http client will acceptself signed certificates.See flag {.
private string getpathtofluidspecifictruststore ( ) { string fluidsystemtruststore = system . getproperty ( system_prop_fluid_trust_store ) ; if ( fluidsystemtruststore == null || fluidsystemtruststore . trim ( ) . isempty ( ) ) { return null ; } file certfile = new file ( fluidsystemtruststore ) ; if ( certfile . exists ( ) && certfile . isfile ( ) ) { return fluidsystemtruststore ; } return null ; }	Retrieves the system property for the Fluid specific trust store.
public void closeconnection ( ) { if ( this . connection == null ) { return ; } try { if ( this . connection . isclosed ( ) ) { return ; } this . connection . close ( ) ; } catch ( sqlexception sqlexcept ) { throw new fluidsqlexception ( sqlexcept ) ; } }	Close the SQL Connection.
public fluiditemlisting getfluiditemsforview ( jobview jobviewparam , int querylimitparam , int offsetparam , string sortfieldparam , string sortorderparam ) { if ( this . serviceticket != null && jobviewparam != null ) { jobviewparam . setserviceticket ( this . serviceticket ) ; } try { return new fluiditemlisting ( this . postjson ( jobviewparam , ws . path . flowitem . version1 . getbyjobview ( querylimitparam , offsetparam , sortfieldparam , sortorderparam ) ) ) ; }	Retrieves items for the provided JobView.
public fluiditem sendformtoflow ( form formtosendtoflowparam , string flowparam ) { fluiditem itemtosend = new fluiditem ( ) ; itemtosend . setform ( formtosendtoflowparam ) ; itemtosend . setflow ( flowparam ) ; if ( this . serviceticket != null ) { itemtosend . setserviceticket ( this . serviceticket ) ; } try { return new fluiditem ( this . postjson ( itemtosend , ws . path . flowitem . version1 . sendflowitemtoflow ( ) ) ) ; } catch ( jsonexception e ) { throw new fluidclientexception ( e . getmessage ( ) , e , fluidclientexception . errorcode . json_parsing ) ; } }	Send a form item to be part of a workflow.
@ onclose public void onclose ( session usersessionparam , closereason reasonparam ) { this . usersession = null ; if ( this . messagehandlers != null ) { this . messagehandlers . values ( ) . foreach ( handle -> { handle . connectionclosed ( ) ; } ) ; } }	Callback hook for Connection close events.
@ onmessage public void onmessage ( string messageparam ) { boolean handlerfoundformsg = bool_ ; for ( imessageresponsehandler handler : new arraylist < > ( this . messagehandlers . values ( ) ) ) { object qualifyobj = handler . doeshandlerqualifyforprocessing ( messageparam ) ; if ( qualifyobj instanceof error ) { handler . handlemessage ( qualifyobj ) ; } else if ( qualifyobj instanceof jsonobject ) { handler . handlemessage ( qualifyobj ) ; handlerfoundformsg = bool_ ; break ; } } if ( ! handlerfoundformsg ) { throw new fluidclientexception ( str_ + messageparam , fluidclientexception . errorcode . io_error ) ; } }	Callback hook for Message Events.
public void sendmessage ( abasefluidjsonobject abasefluidjsonobjectparam ) { if ( abasefluidjsonobjectparam == null ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . io_error ) ; } else { this . sendmessage ( abasefluidjsonobjectparam . tojsonobject ( ) . tostring ( ) ) ; } }	Send a message.
public void sendmessage ( string messagetosendparam ) { if ( this . usersession == null ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . io_error ) ; } remoteendpoint . async asyncremote = null ; if ( ( asyncremote = this . usersession . getasyncremote ( ) ) == null ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . io_error ) ; } asyncremote . sendtext ( messagetosendparam ) ; }	Send a message as text.
public void closesession ( ) { if ( this . usersession == null ) { return ; } try { this . usersession . close ( ) ; } catch ( ioexception e ) { throw new fluidclientexception ( str_ + e . getmessage ( ) , e , fluidclientexception . errorcode . io_error ) ; } }	Closes the Web Socket User session.
public list < sqlresultset > executenativesqlsynchronized ( nativesqlquery nativesqlqueryparam ) { if ( nativesqlqueryparam == null ) { return null ; } if ( nativesqlqueryparam . getdatasourcename ( ) == null || nativesqlqueryparam . getdatasourcename ( ) . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; }	Executes a native SQL query on the remote Fluid instance.The relevant access must exist.
public string requestlicense ( licenserequest licenserequestparam ) { if ( licenserequestparam != null && this . serviceticket != null ) { licenserequestparam . setserviceticket ( this . serviceticket ) ; } return this . executetxtreceivetxt ( httpmethod . post , null , bool_ , ( licenserequestparam == null ) ? null : licenserequestparam . tojsonobject ( ) . tostring ( ) , contenttype . application_json , version1 . licenserequest ( ) ) ; }	Request a new license based on the license request input.It is important to set the following fields.{.
public licenserequest applylicense ( string licensetoapplyparam ) { licenserequest licereq = new licenserequest ( ) ; licereq . setlicenseciphertext ( licensetoapplyparam ) ; if ( this . serviceticket != null ) { licereq . setserviceticket ( this . serviceticket ) ; } return new licenserequest ( this . postjson ( licereq , version1 . licenseapply ( ) ) ) ; }	Applies a generated license for the server.
public field createfieldtextplain ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . text ) ; routefieldparam . settypemetadata ( fieldmetadata . text . plain ) ; } return new field ( this . putjson ( routefieldparam , version1 . routefieldcreate ( ) ) ) ; }	Create a new Plain Text field.
public field createfieldparagraphtextplain ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . paragraphtext ) ; routefieldparam . settypemetadata ( fieldmetadata . paragraphtext . plain ) ; } return new field ( this . putjson ( routefieldparam , version1 . routefieldcreate ( ) ) ) ; }	Create a new Paragraph Text field.
public field createfieldparagraphtexthtml ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . paragraphtext ) ; routefieldparam . settypemetadata ( fieldmetadata . paragraphtext . html ) ; } return new field ( this . putjson ( routefieldparam , version1 . routefieldcreate ( ) ) ) ; }	Create a new Paragraph HTML field.
public field createfieldmultichoiceselectmany ( field routefieldparam , list < string > multichoicevaluesparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( multichoicevaluesparam == null || multichoicevaluesparam . isempty ( ) ) { throw new fluidclientexception ( str_ , fluidclientexception . errorcode . field_validate ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . multiplechoice ) ; routefieldparam . settypemetadata ( fieldmetadata . multichoice . select_many ) ; routefieldparam . setfieldvalue ( new multichoice ( multichoicevaluesparam ) ) ; } return new field ( this . putjson ( routefieldparam , version1 . routefieldcreate ( ) ) ) ; }	Create a new Multi Choice select Many field.
public field createfielddatetimedate ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . datetime ) ; routefieldparam . settypemetadata ( fieldmetadata . datetime . date ) ; } return new field ( this . putjson ( routefieldparam , version1 . routefieldcreate ( ) ) ) ; }	Create a new Date only field.
public field updatefieldtextplain ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . text ) ; routefieldparam . settypemetadata ( fieldmetadata . text . plain ) ; } return new field ( this . postjson ( routefieldparam , version1 . routefieldupdate ( ) ) ) ; }	Update an existing Text field.
public field updatefieldparagraphtexthtml ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . paragraphtext ) ; routefieldparam . settypemetadata ( fieldmetadata . paragraphtext . html ) ; } return new field ( this . postjson ( routefieldparam , version1 . routefieldupdate ( ) ) ) ; }	Update an existing Paragraph HTML field.
public field updatefielddatetimedateandtime ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . datetime ) ; routefieldparam . settypemetadata ( fieldmetadata . datetime . date_and_time ) ; } return new field ( this . postjson ( routefieldparam , version1 . routefieldupdate ( ) ) ) ; }	Update an existing Date and Time field.
public field updatefielddecimalplain ( field routefieldparam ) { if ( routefieldparam != null && this . serviceticket != null ) { routefieldparam . setserviceticket ( this . serviceticket ) ; } if ( routefieldparam != null ) { routefieldparam . settypeasenum ( field . type . decimal ) ; routefieldparam . settypemetadata ( fieldmetadata . decimal . plain ) ; } return new field ( this . postjson ( routefieldparam , version1 . routefieldupdate ( ) ) ) ; }	Update an existing Decimal field.
public field updatefieldvalue ( field routefieldvalueparam ) { if ( routefieldvalueparam != null && this . serviceticket != null ) { routefieldvalueparam . setserviceticket ( this . serviceticket ) ; } return new field ( this . postjson ( routefieldvalueparam , version1 . routefieldupdatevalue ( ) ) ) ; }	Update an existing 'Route field' value.
public field createfieldvalue ( field routefieldvaluetocreateparam , fluiditem fluiditemparam ) { if ( routefieldvaluetocreateparam != null && this . serviceticket != null ) { routefieldvaluetocreateparam . setserviceticket ( this . serviceticket ) ; } long fluiditmid = ( fluiditemparam == null ) ? null : fluiditemparam . getid ( ) ; return new field ( this . putjson ( routefieldvaluetocreateparam , version1 . routefieldcreatevalue ( fluiditmid ) ) ) ; }	Create an new 'Route field' value.
public configuration getconfigurationbykey ( string configurationkeyparam ) { configuration configuration = new configuration ( ) ; configuration . setkey ( configurationkeyparam ) ; if ( this . serviceticket != null ) { configuration . setserviceticket ( this . serviceticket ) ; } return new configuration ( this . postjson ( configuration , ws . path . configuration . version1 . getbykey ( ) ) ) ; }	Retrieves a Configuration by Key.
public configurationlisting getallconfigurations ( ) { configuration configuration = new configuration ( ) ; if ( this . serviceticket != null ) { configuration . setserviceticket ( this . serviceticket ) ; } return new configurationlisting ( this . postjson ( configuration , ws . path . configuration . version1 . getallconfigurations ( ) ) ) ; }	Retrieves all Configurations.
public attachment createattachment ( attachment attachmentparam ) { if ( attachmentparam != null && this . serviceticket != null ) { attachmentparam . setserviceticket ( this . serviceticket ) ; } return new attachment ( this . putjson ( attachmentparam , ws . path . attachment . version1 . attachmentcreate ( ) ) ) ; }	Uploads a new Attachment.If there is an existing attachment with the same name, a new version will beuploaded.
public attachment getattachmentbyid ( long attachmentidparam , boolean includeattachmentdataparam ) { attachment attachment = new attachment ( attachmentidparam ) ; if ( this . serviceticket != null ) { attachment . setserviceticket ( this . serviceticket ) ; } return new attachment ( this . postjson ( attachment , ws . path . attachment . version1 . getbyid ( includeattachmentdataparam ) ) ) ; }	Retrieves a Attachment by Primary Key.
public attachment deleteattachment ( attachment attachmentparam ) { if ( attachmentparam != null && this . serviceticket != null ) { attachmentparam . setserviceticket ( this . serviceticket ) ; } return new attachment ( this . postjson ( attachmentparam , ws . path . attachment . version1 . attachmentdelete ( ) ) ) ; }	Delete an existing Attachment.
public attachment forcedeleteattachment ( attachment attachmentparam ) { if ( attachmentparam != null && this . serviceticket != null ) { attachmentparam . setserviceticket ( this . serviceticket ) ; } return new attachment ( this . postjson ( attachmentparam , ws . path . attachment . version1 . attachmentdelete ( bool_ ) ) ) ; }	Forcefully Delete an existing Attachment.Only 'admin' can forcefully delete a Attachment.
private void parsejarfile ( inputstream inputstream ) {	Parses the XSD file represented by the received InputStream.
private void setclassloader ( string jarpath ) { if ( ! jarpath . endswith ( str_ ) ) { throw new parsingexception ( str_ ) ; } classloader originalcl = thread . currentthread ( ) . getcontextclassloader ( ) ; url url = originalcl . getresource ( jarpath ) ; if ( url == null ) { try { url = new url ( str_ + jarpath ) ; } catch ( malformedurlexception e ) { throw new parsingexception ( str_ ) ; } }	Creates a new class loader, replacing the current one, having another path added to the classpath.
private void rule2 ( ) { if ( ! ( parent instanceof xsdschema ) && name != null ) { throw new parsingexception ( xsd_tag + str_ + name_tag + str_ + xsd_tag + str_ + xsdschema . xsd_tag + str_ ) ; } }	Asserts if the current object has the name attribute when not being a direct child of the XsdSchema element, which isnot allowed, throwing an exception in that case.
private void rule3 ( ) { if ( parent instanceof xsdschema && name == null ) { throw new parsingexception ( xsd_tag + str_ + name_tag + str_ + xsd_tag + str_ + xsdschema . xsd_tag + str_ ) ; } }	Asserts if the current has no value for its name attribute while being a direct child of the top level XsdSchema element,which is required.
private void rule3 ( ) { if ( attributesmap . containskey ( ref_tag ) && ( simpletype != null || form != null || type != null ) ) { throw new parsingexception ( xsd_tag + str_ + ref_tag + str_ ) ; } }	Asserts if the current object has a ref attribute at the same time as either a simpleType as children, a form attribute or a type attribute.Throws an exception in that case.
private node getschemanode ( string filepath ) throws ioexception , saxexception , parserconfigurationexception { document doc = documentbuilderfactory . newinstance ( ) . newdocumentbuilder ( ) . parse ( filepath ) ; doc . getdocumentelement ( ) . normalize ( ) ; return doc . getfirstchild ( ) ; }	This function uses DOM to obtain a list of nodes from a XSD file.
private void rule7 ( ) { if ( parent instanceof xsdschema && attributesmap . containskey ( form_tag ) ) { throw new parsingexception ( xsd_tag + str_ + form_tag + str_ + xsdelementisxsdschema ) ; } }	Asserts if the current object has a form attribute while being a direct child of the top level XsdSchema element,which isn't allowed, throwing an exception in that case.
private void rule3 ( ) { if ( parent instanceof xsdschema && attributesmap . containskey ( ref_tag ) ) { throw new parsingexception ( xsd_tag + str_ + ref_tag + str_ + xsdelementisxsdschema ) ; } }	Asserts if the current object has a ref attribute while being a direct child of the top level XsdSchema element, which isn't allowed,throwing an exception in that case.
@ override public t convert ( final object value ) { if ( value == null ) { return null ; } else if ( isiterable ( ) && iterable . class . isassignablefrom ( value . getclass ( ) ) ) { return convertiterable ( value ) ; } else if ( reflectedklass . assignablefromobject ( value ) ) { return ( t ) value ; } else if ( reflectedklass . canbeunboxed ( value . getclass ( ) ) ) { return ( t ) value ; } else if ( reflectedklass . canbeboxed ( value . getclass ( ) ) ) { return ( t ) value ; } fluentclass < ? > klasstocreate ; if ( reflectedklass . isprimitive ( ) ) { klasstocreate = reflectedklass . boxedtype ( ) ; } else { klasstocreate = reflectedklass ; } return ( t ) convertvalueto ( value , klasstocreate ) ; }	If T is assignable from value, then return the value.
public static < o > cli < o > createcli ( final class < o > klass ) throws invalidoptionspecificationexception { return new cliinterfaceimpl < o > ( klass ) ; }	Construct a Cli from an annotated interface definition.
public static < o > cli < o > createcliusinginstance ( final o options ) throws invalidoptionspecificationexception { return new cliinstanceimpl < o > ( options ) ; }	Construct a Cli from an annotated class.
public static < o > o parsearguments ( final class < o > klass , final string ... arguments ) throws argumentvalidationexception , invalidoptionspecificationexception { return createcli ( klass ) . parsearguments ( arguments ) ; }	Parse arguments from an annotated interface definition.
public static < o > o parseargumentsusinginstance ( final o options , final string ... arguments ) throws argumentvalidationexception , invalidoptionspecificationexception { return createcliusinginstance ( options ) . parsearguments ( arguments ) ; }	Parse arguments from an annotated class instance.
builder urlbuilder ( string path ) { builder builder = baseurlbuilder ( ) . addpathsegment ( configuration . getapipackage ( ) ) . addpathsegment ( configuration . getapiversion ( ) ) . addpathsegment ( path ) ; if ( configuration . getpathmodifier ( ) != discoveryapiconfiguration . pathmodifier . none ) { builder . addpathsegment ( configuration . getpathmodifier ( ) . getmodifier ( ) ) ; } return builder ; }	Package protected for testing purposess.
public boolean removefooterview ( view v ) { if ( mfooterviewinfos . size ( ) > num_ ) { boolean result = bool_ ; if ( madapter != null && ( ( footerviewgridadapter ) madapter ) . removefooter ( v ) ) { notifiychanged ( ) ; result = bool_ ; } removefixedviewinfo ( v , mfooterviewinfos ) ; return result ; } return bool_ ; }	Removes a previously-added footer view.
public double getvalue ( double p ) { if ( module == null ) { throw new nomoduleexception ( ) ; } double x = ( x1 - x0 ) * p + x0 ; double y = ( y1 - y0 ) * p + y0 ; double z = ( z1 - z0 ) * p + z0 ; double value = module . getvalue ( x , y , z ) ; if ( attenuate ) { return p * ( num_ - p ) * num_ * value ; } else { return value ; } }	Returns the output value from the noise module given the one-dimensional coordinate of the specified input value located on the line segment.
public static int intvaluenoise3d ( int x , int y , int z , int seed ) {	Generates an integer-noise value from the coordinates of a three-dimensional input value.
public static double valuenoise3d ( int x , int y , int z , int seed ) { return intvaluenoise3d ( x , y , z , seed ) / num_ ; }	Generates a value-noise value from the coordinates of a three-dimensional input value.
public static double cubicinterp ( double n0 , double n1 , double n2 , double n3 , double a ) { double p = ( n3 - n2 ) - ( n0 - n1 ) ; double q = ( n0 - n1 ) - p ; double r = n2 - n0 ; return p * a * a * a + q * a * a + r * a + n1 ; }	Performs cubic interpolation between two values bound between two other values.
public static double scurve5 ( double a ) { double a3 = a * a * a ; double a4 = a3 * a ; double a5 = a4 * a ; return ( num_ * a5 ) - ( num_ * a4 ) + ( num_ * a3 ) ; }	maps a value onto a quitnic S-Curve.
public void setbounds ( double currentlower , double currentupper , double newlower , double newupper ) { if ( currentlower == currentupper ) { throw new illegalargumentexception ( str_ + currentupper ) ; } if ( newlower == newupper ) { throw new illegalargumentexception ( str_ + newupper ) ; } currentlowerbound = currentlower ; currentupperbound = currentupper ; newlowerbound = newlower ; newupperbound = newupper ; recalculatescalebias ( ) ; }	Configure bounds for range module.
protected void doprocess ( final cloudtrailevent event ) { for ( final fullstopplugin plugin : getpluginsforevent ( event ) ) { doprocess ( event , plugin ) ; } }	Processes an single event by looping available plugins.
protected void doprocess ( final cloudtrailevent event , final fullstopplugin plugin ) { try { plugin . processevent ( event ) ; } catch ( hystrixruntimeexception | httpservererrorexception e ) { log . warn ( e . getmessage ( ) , e ) ; } catch ( final exception e ) { log . error ( e . getmessage ( ) , e ) ; } }	Processes a specific event on specified plugin.
public static string getaccountid ( final cloudtrailevent event ) { final cloudtraileventdata eventdata = geteventdata ( event ) ; final useridentity useridentity = checknotnull ( eventdata . getuseridentity ( ) , user_identity_should_never_be_null ) ; final string value = ofnullable ( useridentity . getaccountid ( ) ) . orelse ( eventdata . getrecipientaccountid ( ) ) ; return checknotnull ( value , account_id_or_recipient_should_never_be_null ) ; }	Extracts the 'accountId'.
@ override public boolean apply ( final ruleentity ruleentity , final violationentity violationentity ) { final list < predicate < violationentity > > predicates = newarraylist ( ) ; trimoptional ( ruleentity . getaccountid ( ) ) . map ( whitelistrulesevaluator :: accountisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getregion ( ) ) . map ( whitelistrulesevaluator :: regionisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getviolationtypeentityid ( ) ) . map ( whitelistrulesevaluator :: violationtypeidisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getimagename ( ) ) . map ( whitelistrulesevaluator :: imagenamematches ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getimageowner ( ) ) . map ( whitelistrulesevaluator :: imageownerisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getapplicationid ( ) ) . map ( whitelistrulesevaluator :: applicationidisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getapplicationversion ( ) ) . map ( whitelistrulesevaluator :: applicationversionisequal ) . ifpresent ( predicates :: add ) ; trimoptional ( ruleentity . getmetainfojsonpath ( ) ) . map ( this :: metainfojsonpathexists ) . ifpresent ( predicates :: add ) ; final optional < predicate < violationentity > > whitelisttest = predicates . stream ( ) . reduce ( predicate :: and ) ; return whitelisttest . ispresent ( ) && whitelisttest . get ( ) . test ( violationentity ) ; }	true if rule matches a violation and should be whitelisted.
private eventserializer geteventserializer ( final gzipinputstream inputstream , final cloudtraillog ctlog ) throws ioexception { final eventserializer serializer ; if ( isenableraweventinfo ) { final string logfilecontent = new string ( libraryutils . tobytearray ( inputstream ) , standardcharsets . utf_8 ) ; final jsonparser jsonparser = this . mapper . getfactory ( ) . createparser ( logfilecontent ) ; serializer = new rawlogdeliveryeventserializer ( logfilecontent , ctlog , jsonparser ) ; } else { final jsonparser jsonparser = this . mapper . getfactory ( ) . createparser ( inputstream ) ; serializer = new defaulteventserializer ( ctlog , jsonparser ) ; } return serializer ; }	Get the EventSerializer based on user's configuration.
public file createfile ( string filename ) throws ioexception { path path = paths . get ( rootfolder . getpath ( ) , filename ) ; return files . createfile ( path ) . tofile ( ) ; }	Create a file within the temporary folder root.
public file createdirectory ( string directoryname ) { path path = paths . get ( rootfolder . getpath ( ) , directoryname ) ; try { return files . createdirectory ( path ) . tofile ( ) ; } catch ( ioexception ex ) { throw new temporaryfolderexception ( string . format ( str_ , path . tostring ( ) ) , ex ) ; } }	Create a directory within the temporary folder root.
public void restore ( ) { for ( string propertyname : propertynames ) { if ( restoreproperties . containskey ( propertyname ) ) {	Reverse the system property 'sets' performed on behalf of this restore context. For each entry in {.
private map < k , v > createimplementation ( ) { if ( delegate instanceof hashmap == bool_ ) return new hashmap < k , v > ( delegate ) ; return delegate ; }	Create the map implementation.
public boolean add ( final object obj ) { maintain ( ) ; softobject soft = softobject . create ( obj , queue ) ; return collection . add ( soft ) ; }	Add an object to the collection.
public static string set ( string name , string value ) { return propertymanager . setproperty ( name , value ) ; }	Set a property.
public static string [ ] getarray ( string base , string [ ] defaultvalues ) { return propertymanager . getarrayproperty ( base , defaultvalues ) ; }	Get an array style property.
public state nextstate ( string actionname ) throws illegaltransitionexception { transition t = currentstate . gettransition ( actionname ) ; if ( t == null ) { string msg = str_ + actionname + str_ + currentstate . getname ( ) + str_ ; throw new illegaltransitionexception ( msg ) ; } state nextstate = t . gettarget ( ) ; log . trace ( str_ + actionname + str_ + nextstate ) ; currentstate = nextstate ; return currentstate ; }	Transition to the next state given the name of a valid transition.
private void processqueue ( ) { comparablesoftreference cr ; while ( ( cr = ( comparablesoftreference ) gcqueue . poll ( ) ) != null ) { map . remove ( cr . getkey ( ) ) ; } }	Iterate through the gcqueue for for any cleared reference, removethe associated value from the underlying set.
@ suppresswarnings ( { str_ , str_ } ) public t get ( type type ) { if ( type == null ) throw new illegalargumentexception ( str_ ) ; if ( type instanceof parameterizedtype ) return getparameterizedtype ( ( parameterizedtype ) type ) ; else if ( type instanceof class ) return getclass ( ( class < ? > ) type ) ; else if ( type instanceof typevariable )	Get the information for a type.
protected t getparameterizedtype ( parameterizedtype type ) {	Get the information for a parameterized type.
protected < d extends genericdeclaration > t gettypevariable ( typevariable < d > type ) {	Get the information for a type variable.
public void printstacktrace ( final printstream stream ) { if ( nested == null || nestedthrowable . parent_trace_enabled ) { super . printstacktrace ( stream ) ; } nestedthrowable . util . print ( nested , stream ) ; }	Prints the composite message and the embedded stack trace to thespecified print stream.
public void printstacktrace ( final printwriter writer ) { if ( nested == null || nestedthrowable . parent_trace_enabled ) { super . printstacktrace ( writer ) ; } nestedthrowable . util . print ( nested , writer ) ; }	Prints the composite message and the embedded stack trace to thespecified print writer.
protected object replaceobject ( object obj ) throws ioexception { if ( ( obj instanceof remote ) && ! ( obj instanceof remotestub ) ) { remote remote = ( remote ) obj ; try { obj = remoteobject . tostub ( remote ) ; } catch ( ioexception ignore ) {	Override replaceObject to check for Remote objects that arenot RemoteStubs.
public void run ( ) {	Called by the thread pool executor.
protected void settask ( task task ) { if ( task == null ) throw new illegalargumentexception ( str_ ) ; this . task = task ; this . taskstring = task . tostring ( ) ; this . starttime = system . currenttimemillis ( ) ; this . waittype = task . getwaittype ( ) ; this . priority = task . getpriority ( ) ; this . starttimeout = task . getstarttimeout ( ) ; this . completiontimeout = task . getcompletiontimeout ( ) ; }	Set thetask for this wrapper.
protected boolean taskaccepted ( ) { try { task . accepted ( getelapsedtime ( ) ) ; return bool_ ; } catch ( throwable t ) { log . warn ( str_ + taskstring , t ) ; return bool_ ; } }	Notify the task it has been accepted.
protected boolean taskrejected ( runtimeexception e ) { try { task . rejected ( getelapsedtime ( ) , e ) ; return bool_ ; } catch ( throwable t ) { log . warn ( str_ + taskstring , t ) ; if ( e != null ) log . warn ( str_ + taskstring , e ) ; return bool_ ; } }	Notify the task it has been rejected.
protected boolean taskstarted ( ) { try { task . started ( getelapsedtime ( ) ) ; return bool_ ; } catch ( throwable t ) { log . warn ( str_ + taskstring , t ) ; return bool_ ; } }	Notify the task it has started.
protected boolean taskcompleted ( throwable throwable ) { try { task . completed ( getelapsedtime ( ) , throwable ) ; return bool_ ; } catch ( throwable t ) { log . warn ( str_ + taskstring , t ) ; if ( throwable != null ) log . warn ( str_ + taskstring , throwable ) ; return bool_ ; } }	Notify the task it has completed.
protected boolean taskstop ( ) { try { task . stop ( ) ; return bool_ ; } catch ( throwable t ) { log . warn ( str_ + taskstring , t ) ; return bool_ ; } }	Stop the task.
protected executable getjobimpl ( ) throws interruptedexception {	Never call this method, only override in subclasses to performjob getting in a specific way, normally tied to the data structureholding the jobs.
protected void putjobimpl ( executable job ) { jobitem posted = new jobitem ( job ) ; if ( m_currentjob == null ) {	Never call this method, only override in subclasses to performjob adding in a specific way, normally tied to the data structureholding the jobs.
public static final blockingmode toblockingmode ( string name ) { blockingmode mode = null ; if ( name == null ) { mode = null ; } else if ( name . equalsignorecase ( str_ ) ) { mode = run ; } else if ( name . equalsignorecase ( str_ ) ) { mode = wait ; } else if ( name . equalsignorecase ( str_ ) ) { mode = discard ; } else if ( name . equalsignorecase ( str_ ) ) { mode = discard_oldest ; } else if ( name . equalsignorecase ( str_ ) ) { mode = abort ; } return mode ; }	A utility method to convert a string name to a BlockingMode.
object readresolve ( ) throws objectstreamexception {	Overriden to return the indentity instance of BlockingMode based on thestream type int value.
protected void copyreaders ( catalog newcatalog ) {	Copies the reader list from the current Catalog to a new Catalog.
protected catalog newcatalog ( ) { string catalogclass = this . getclass ( ) . getname ( ) ; try { catalog c = ( catalog ) ( class . forname ( catalogclass ) . newinstance ( ) ) ; c . setcatalogmanager ( catalogmanager ) ; copyreaders ( c ) ; return c ; } catch ( classnotfoundexception cnfe ) { catalogmanager . debug . message ( num_ , str_ + catalogclass ) ; } catch ( illegalaccessexception iae ) { catalogmanager . debug . message ( num_ , str_ + catalogclass ) ; } catch ( instantiationexception ie ) { catalogmanager . debug . message ( num_ , str_ + catalogclass ) ; } catch ( classcastexception cce ) { catalogmanager . debug . message ( num_ , str_ + catalogclass ) ; } catch ( exception e ) { catalogmanager . debug . message ( num_ , str_ + catalogclass ) ; } catalog c = new catalog ( ) ; c . setcatalogmanager ( catalogmanager ) ; copyreaders ( c ) ; return c ; }	Create a new Catalog object.
public void loadsystemcatalogs ( ) throws malformedurlexception , ioexception { vector catalogs = catalogmanager . getcatalogfiles ( ) ; if ( catalogs != null ) { for ( int count = num_ ; count < catalogs . size ( ) ; count ++ ) { catalogfiles . addelement ( catalogs . elementat ( count ) ) ; } } if ( catalogfiles . size ( ) > num_ ) {	Load the system catalog files.
public synchronized void parsecatalog ( url aurl ) throws ioexception { catalogcwd = aurl ; base = aurl ; default_override = catalogmanager . getpreferpublic ( ) ; catalogmanager . debug . message ( num_ , str_ + aurl . tostring ( ) ) ; datainputstream instream = null ; boolean parsed = bool_ ; for ( int count = num_ ; ! parsed && count < readerarr . size ( ) ; count ++ ) { catalogreader reader = ( catalogreader ) readerarr . get ( count ) ; try { instream = new datainputstream ( aurl . openstream ( ) ) ; } catch ( filenotfoundexception fnfe ) {	Parse a catalog document, augmenting internal data structures.
protected synchronized void parsependingcatalogs ( ) throws malformedurlexception , ioexception { if ( ! localcatalogfiles . isempty ( ) ) {	Parse all of the pending catalogs.
protected synchronized void parsecatalogfile ( string filename ) throws malformedurlexception , ioexception , catalogexception {	Parse a single catalog file, augmenting internal data structures.
public void unknownentry ( vector strings ) { if ( strings != null && strings . size ( ) > num_ ) { string keyword = ( string ) strings . elementat ( num_ ) ; catalogmanager . debug . message ( num_ , str_ , keyword ) ; } }	Handle unknown CatalogEntry types.
public string resolvedoctype ( string entityname , string publicid , string systemid ) throws malformedurlexception , ioexception { string resolved = null ; catalogmanager . debug . message ( num_ , str_ + entityname + str_ + publicid + str_ + systemid + str_ ) ; systemid = normalizeuri ( systemid ) ; if ( publicid != null && publicid . startswith ( str_ ) ) { publicid = publicid . decodeurn ( publicid ) ; } if ( systemid != null && systemid . startswith ( str_ ) ) { systemid = publicid . decodeurn ( systemid ) ; if ( publicid != null && ! publicid . equals ( systemid ) ) { catalogmanager . debug . message ( num_ , str_ ) ; systemid = null ; } else { publicid = systemid ; systemid = null ; } } if ( systemid != null ) {	Return the applicable DOCTYPE system identifier.
public string resolvedocument ( ) throws malformedurlexception , ioexception {	Return the applicable DOCUMENT entry.
public string resolvesystem ( string systemid ) throws malformedurlexception , ioexception { catalogmanager . debug . message ( num_ , str_ + systemid + str_ ) ; systemid = normalizeuri ( systemid ) ; if ( systemid != null && systemid . startswith ( str_ ) ) { systemid = publicid . decodeurn ( systemid ) ; return resolvepublic ( systemid , null ) ; }	Return the applicable SYSTEM system identifier.
protected string resolvelocaluri ( string uri ) throws malformedurlexception , ioexception { enumeration enumt = catalogentries . elements ( ) ; while ( enumt . hasmoreelements ( ) ) { catalogentry e = ( catalogentry ) enumt . nextelement ( ) ; if ( e . getentrytype ( ) == uri && ( e . getentryarg ( num_ ) . equals ( uri ) ) ) { return e . getentryarg ( num_ ) ; } }	Return the applicable URI in this catalog.
protected string makeabsolute ( string sysid ) { url local = null ; sysid = fixslashes ( sysid ) ; try { local = new url ( base , sysid ) ; } catch ( malformedurlexception e ) { catalogmanager . debug . message ( num_ , str_ , sysid ) ; } if ( local != null ) { return local . tostring ( ) ; } else { return sysid ; } }	Construct an absolute URI from a relative one, using the currentbase URI.
protected string normalizeuri ( string uriref ) { string newref = str_ ; byte [ ] bytes ; if ( uriref == null ) { return null ; } try { bytes = uriref . getbytes ( str_ ) ; } catch ( unsupportedencodingexception uee ) {	Perform character normalization on a URI reference.
protected string encodedbyte ( int b ) { string hex = integer . tohexstring ( b ) . touppercase ( ) ; if ( hex . length ( ) < num_ ) { return str_ + hex ; } else { return str_ + hex ; } }	Perform %-encoding on a single byte.
protected void adddelegate ( catalogentry entry ) { int pos = num_ ; string partial = entry . getentryarg ( num_ ) ; enumeration local = localdelegate . elements ( ) ; while ( local . hasmoreelements ( ) ) { catalogentry dpe = ( catalogentry ) local . nextelement ( ) ; string dp = dpe . getentryarg ( num_ ) ; if ( dp . equals ( partial ) ) {	Add to the current list of delegated catalogs. This method always constructs the {.
static < k , v > softvalueref < k , v > create ( k key , v val , referencequeue < v > q ) { if ( val == null ) return null ; else return new softvalueref < k , v > ( key , val , q ) ; }	Safely create a new SoftValueRef.
protected static void fireonthrowable ( int type , throwable t ) { object [ ] list = listeners . toarray ( ) ; for ( int i = num_ ; i < list . length ; i ++ ) { ( ( throwablelistener ) list [ i ] ) . onthrowable ( type , t ) ; } }	Fire onThrowable to all registered listeners.
public static void add ( int type , throwable t ) {	Add a throwable that is to be handled.
private list < t > createimplementation ( ) { if ( delegate instanceof arraylist == bool_ ) return new arraylist < t > ( delegate ) ; return delegate ; }	Create the list implementation.
public int compareto ( object other ) { if ( other == this ) return num_ ; timertask t = ( timertask ) other ; long diff = getnextexecutiontime ( ) - t . getnextexecutiontime ( ) ; return ( int ) diff ; }	A TimerTask is less than another if it will be scheduled before.
public object getvalue ( ) { try { string text = getastext ( ) ; if ( text == null ) { return null ; } if ( text . startswith ( str_ ) ) {	Returns a InetAddress for the input object converted to a string.
private object getobject ( final int index ) { object obj = list . get ( index ) ; return objects . deref ( obj ) ; }	Dereference the object at the given index.
public object set ( final int index , final object obj ) { maintain ( ) ; softobject soft = softobject . create ( obj , queue ) ; soft = ( softobject ) list . set ( index , soft ) ; return objects . deref ( soft ) ; }	Replaces the element at the specified position in this list with thespecified element.
private void maintain ( ) { softobject obj ; int count = num_ ; while ( ( obj = ( softobject ) queue . poll ( ) ) != null ) { count ++ ; list . remove ( obj ) ; } if ( count != num_ ) {	Maintains the collection by removing garbage collected objects.
public static int addentrytype ( string name , int numargs ) { entrytypes . put ( name , new integer ( nextentry ) ) ; entryargs . add ( nextentry , new integer ( numargs ) ) ; nextentry ++ ; return nextentry - num_ ; }	Adds a new catalog entry type.
public static int getentrytype ( string name ) throws catalogexception { if ( ! entrytypes . containskey ( name ) ) { throw new catalogexception ( catalogexception . invalid_entry_type ) ; } integer itype = ( integer ) entrytypes . get ( name ) ; if ( itype == null ) { throw new catalogexception ( catalogexception . invalid_entry_type ) ; } return itype . intvalue ( ) ; }	Lookup an entry type.
public static int getentryargcount ( int type ) throws catalogexception { try { integer iargs = ( integer ) entryargs . get ( type ) ; return iargs . intvalue ( ) ; } catch ( arrayindexoutofboundsexception e ) { throw new catalogexception ( catalogexception . invalid_entry_type ) ; } }	Find out how many arguments an entry is required to have.
public string getentryarg ( int argnum ) { try { string arg = ( string ) args . get ( argnum ) ; return arg ; } catch ( arrayindexoutofboundsexception e ) { return null ; } }	Get an entry argument.
public void setcontextclassloader ( final thread thread , final classloader cl ) { accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { thread . setcontextclassloader ( cl ) ; return null ; } } ) ; }	Set the context classloader for the given thread.
private void swap ( int a , int b ) {	Swap two nodes in the tree.
private timeoutextimpl removenode ( int index ) {	Remove a node from the tree and normalize.
private timeoutextimpl cleanuptimeoutextimpl ( timeoutextimpl timeout ) { if ( timeout != null ) timeout . target = null ; return null ; }	Recursive cleanup of a TimeoutImpl.
protected class < ? > loadclass ( string classname , boolean resolve ) throws classnotfoundexception {	Load a class, by asking the parent.
@ suppresswarnings ( str_ ) public static void preload ( ) { for ( int i = num_ ; i < protocols . length ; i ++ ) { try { url url = new url ( protocols [ i ] , str_ , - num_ , str_ ) ; log . trace ( str_ + protocols [ i ] ) ; } catch ( exception e ) { log . warn ( str_ + protocols [ i ] , e ) ; } } }	Preload the JBoss specific protocol handlers, so that URL knows aboutthem even if the handler factory is changed.
public urlstreamhandler createurlstreamhandler ( final string protocol ) {	Search the handlerPkgs for URLStreamHandler classes matching thepkg + protocol + ".Handler" naming convention.
private synchronized void checkhandlerpkgs ( ) { string handlerpkgsprop = system . getproperty ( str_ ) ; if ( handlerpkgsprop != null && handlerpkgsprop . equals ( lasthandlerpkgs ) == bool_ ) {	See if the java.protocol.handler.pkgs system property has changedand if it has, parse it to update the handlerPkgs array.
public object getvalue ( ) { try { classloader loader = thread . currentthread ( ) . getcontextclassloader ( ) ; string classname = getastext ( ) ; class < ? > type = loader . loadclass ( classname ) ; return type ; } catch ( exception e ) { throw new nestedruntimeexception ( e ) ; } }	Returns a Class for the input object converted to a string.
private set < t > createimplementation ( ) { if ( delegate instanceof hashset == bool_ ) return new hashset < t > ( delegate ) ; return delegate ; }	Create the set implementation.
public static longcounter makesynchronized ( final longcounter counter ) { return new wrapper ( counter ) { private static final long serialversionuid = num_ ; public synchronized long increment ( ) { return this . counter . increment ( ) ; } public synchronized long decrement ( ) { return this . counter . decrement ( ) ; } public synchronized long getcount ( ) { return this . counter . getcount ( ) ; } public synchronized void reset ( ) { this . counter . reset ( ) ; } public synchronized int hashcode ( ) { return this . counter . hashcode ( ) ; } public synchronized boolean equals ( final object obj ) { return this . counter . equals ( obj ) ; } public synchronized string tostring ( ) { return this . counter . tostring ( ) ; } public synchronized object clone ( ) { return this . counter . clone ( ) ; } } ; }	Return a synchronized counter.
public static longcounter makedirectional ( final longcounter counter , final boolean increasing ) { longcounter temp ; if ( increasing ) { temp = new wrapper ( counter ) { private static final long serialversionuid = - num_ ; public long decrement ( ) { throw new unsupportedoperationexception ( ) ; } public void reset ( ) { throw new unsupportedoperationexception ( ) ; } } ; } else { temp = new wrapper ( counter ) { private static final long serialversionuid = num_ ; public long increment ( ) { throw new unsupportedoperationexception ( ) ; } } ; } return temp ; }	Returns a directional counter.
protected boolean inextensionnamespace ( ) { boolean inextension = bool_ ; enumeration elements = namespacestack . elements ( ) ; while ( ! inextension && elements . hasmoreelements ( ) ) { string ns = ( string ) elements . nextelement ( ) ; if ( ns == null ) { inextension = bool_ ; } else { inextension = ( ! ns . equals ( tr9401namespacename ) && ! ns . equals ( namespacename ) ) ; } } return inextension ; }	Are we in an extension namespace?.
public void checknotification ( int result ) {	Checks whether a notification is required andnotifies as appropriate.
public object getobjectinstance ( object obj , name name , context namectx , hashtable env ) throws exception {	Transform the obj Reference bound into the JNDI namespace into theactual non-Serializable object.
public static string subst ( final stringbuffer buff , final string string , final map map , final string begintoken , final string endtoken ) { int begin = num_ , rangeend = num_ ; range range ; while ( ( range = rangeof ( begintoken , endtoken , string , rangeend ) ) != null ) {	Substitute sub-strings in side of a string.
public static string [ ] split ( final string string , final string delim , final int limit ) {	Split up a string into multiple strings based on a delimiter.
public static string join ( final byte array [ ] ) { byte bytes [ ] = new byte [ array . length ] ; for ( int i = num_ ; i < bytes . length ; i ++ ) { bytes [ i ] = new byte ( array [ i ] ) ; } return join ( bytes , null ) ; }	Convert and join an array of bytes into one string.
public static final void defaulttostring ( jbossstringbuilder buffer , object object ) { if ( object == null ) buffer . append ( str_ ) ; else { buffer . append ( object . getclass ( ) . getname ( ) ) ; buffer . append ( str_ ) ; buffer . append ( integer . tohexstring ( system . identityhashcode ( object ) ) ) ; } }	The default toString implementation of an object.
public object getvalue ( ) { string text = getastext ( ) ; blockingmode mode = blockingmode . toblockingmode ( text ) ; return mode ; }	Returns a BlockingMode for the input object converted to a string.
public void create ( ) { if ( threadsafe ) entrymap = collections . synchronizedmap ( new hashmap ( ) ) ; else entrymap = new hashmap ( ) ; now = system . currenttimemillis ( ) ; }	Initializes the cache for use.
public object get ( object key ) { timedentry entry = ( timedentry ) entrymap . get ( key ) ; if ( entry == null ) return null ; if ( entry . iscurrent ( now ) == bool_ ) {	Get the cache value for key if it has not expired.
public object peek ( object key ) { timedentry entry = ( timedentry ) entrymap . get ( key ) ; object value = null ; if ( entry != null ) value = entry . getvalue ( ) ; return value ; }	Get the cache value for key.
public void remove ( object key ) { timedentry entry = ( timedentry ) entrymap . remove ( key ) ; if ( entry != null ) entry . destroy ( ) ; }	Remove the entry associated with key and call destroy on the entryif found.
public void flush ( ) { map tmpmap = null ; synchronized ( this ) { tmpmap = entrymap ; if ( threadsafe ) entrymap = collections . synchronizedmap ( new hashmap ( ) ) ; else entrymap = new hashmap ( ) ; }	Remove all entries from the cache.
public list getvalidkeys ( ) { arraylist validkeys = new arraylist ( ) ; synchronized ( entrymap ) { iterator iter = entrymap . entryset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; timedentry value = ( timedentry ) entry . getvalue ( ) ; if ( value . iscurrent ( now ) == bool_ ) validkeys . add ( entry . getkey ( ) ) ; } } return validkeys ; }	Get the list of keys for entries that are not expired.
public synchronized void setresolution ( int resolution ) { if ( resolution <= num_ ) resolution = num_ ; if ( resolution != this . resolution ) { this . resolution = resolution ; thetimer . cancel ( ) ; thetimer = new resolutiontimer ( ) ; resolutiontimer . scheduleatfixedrate ( thetimer , num_ , num_ * resolution ) ; } }	Set the cache timer resolution.
public timedentry peekentry ( object key ) { timedentry entry = ( timedentry ) entrymap . get ( key ) ; return entry ; }	Get the raw TimedEntry for key without performing any expiration check.
public static iterator getchildrenbytagname ( element element , string tagname ) { if ( element == null ) return null ;	Returns an iterator over the children of the given element withthe given tag name.
public static element getuniquechild ( element element , string tagname ) throws exception { iterator goodchildren = getchildrenbytagname ( element , tagname ) ; if ( goodchildren != null && goodchildren . hasnext ( ) ) { element child = ( element ) goodchildren . next ( ) ; if ( goodchildren . hasnext ( ) ) { throw new exception ( str_ + tagname + str_ ) ; } return child ; } else { throw new exception ( str_ + tagname + str_ ) ; } }	Gets the child of the specified element having the specified uniquename.
public static element getoptionalchild ( element element , string tagname ) throws exception { return getoptionalchild ( element , tagname , null ) ; }	Gets the child of the specified element having thespecified name.
public static string getelementcontent ( element element , string defaultstr ) throws exception { if ( element == null ) return defaultstr ; nodelist children = element . getchildnodes ( ) ; string result = str_ ; for ( int i = num_ ; i < children . getlength ( ) ; i ++ ) { if ( children . item ( i ) . getnodetype ( ) == node . text_node || children . item ( i ) . getnodetype ( ) == node . cdata_section_node ) { result += children . item ( i ) . getnodevalue ( ) ; } else if ( children . item ( i ) . getnodetype ( ) == node . comment_node ) {	Get the content of the given element.
public static string getuniquechildcontent ( element element , string tagname ) throws exception { return getelementcontent ( getuniquechild ( element , tagname ) ) ; }	Macro to get the content of a unique child element.
public static string getoptionalchildcontent ( element element , string tagname ) throws exception { return getelementcontent ( getoptionalchild ( element , tagname ) ) ; }	Macro to get the content of an optional child element.
public void setmaximumqueuesize ( int size ) {	This resets the work queue capacity.
public void setblockingmode ( string name ) { blockingmode = blockingmode . toblockingmode ( name ) ; if ( blockingmode == null ) blockingmode = blockingmode . abort ; }	For backward compatibility with the previous string based mode.
public void setblockingmodestring ( string name ) { blockingmode = blockingmode . toblockingmode ( name ) ; if ( blockingmode == null ) blockingmode = blockingmode . abort ; }	For backward compatibility with the previous string based modeThis is needed for microcontainer as it gets confused with overloadedsetters.
protected void execute ( taskwrapper wrapper ) { if ( trace ) log . trace ( str_ + wrapper ) ; try { executor . execute ( wrapper ) ; } catch ( throwable t ) { wrapper . rejecttask ( new threadpoolfullexception ( str_ + wrapper , t ) ) ; } }	Execute a task.
protected string resolveexternalsystem ( string systemid , string resolver ) throws malformedurlexception , ioexception { resolver r = queryresolver ( resolver , str_ , systemid , null ) ; if ( r != null ) { return r . resolvesystem ( systemid ) ; } else { return null ; } }	Query an external RFC2483 resolver for a system identifier.
protected string resolveexternalpublic ( string publicid , string resolver ) throws malformedurlexception , ioexception { resolver r = queryresolver ( resolver , str_ , publicid , null ) ; if ( r != null ) { return r . resolvepublic ( publicid , null ) ; } else { return null ; } }	Query an external RFC2483 resolver for a public identifier.
protected resolver queryresolver ( string resolver , string command , string arg1 , string arg2 ) { string rfc2483 = resolver + str_ + command + str_ + arg1 + str_ + arg2 ; try { url url = new url ( rfc2483 ) ; urlconnection urlcon = url . openconnection ( ) ; urlcon . setusecaches ( bool_ ) ; resolver r = ( resolver ) newcatalog ( ) ; string ctype = urlcon . getcontenttype ( ) ;	Query an external RFC2483 resolver.
private vector appendvector ( vector vec , vector appvec ) { if ( appvec != null ) { for ( int count = num_ ; count < appvec . size ( ) ; count ++ ) { vec . addelement ( appvec . elementat ( count ) ) ; } } return vec ; }	Append two vectors, returning the result.
public vector resolveallsystemreverse ( string systemid ) throws malformedurlexception , ioexception { vector resolved = new vector ( ) ;	Find the URNs for a given system identifier in all catalogs.
public string resolvesystemreverse ( string systemid ) throws malformedurlexception , ioexception { vector resolved = resolveallsystemreverse ( systemid ) ; if ( resolved != null && resolved . size ( ) > num_ ) { return ( string ) resolved . elementat ( num_ ) ; } else { return null ; } }	Find the URN for a given system identifier.
private vector resolvealllocalsystem ( string systemid ) { vector map = new vector ( ) ; string osname = system . getproperty ( str_ ) ; boolean windows = ( osname . indexof ( str_ ) >= num_ ) ; enumeration enumt = catalogentries . elements ( ) ; while ( enumt . hasmoreelements ( ) ) { catalogentry e = ( catalogentry ) enumt . nextelement ( ) ; if ( e . getentrytype ( ) == system && ( e . getentryarg ( num_ ) . equals ( systemid ) || ( windows && e . getentryarg ( num_ ) . equalsignorecase ( systemid ) ) ) ) { map . addelement ( e . getentryarg ( num_ ) ) ; } } if ( map . size ( ) == num_ ) { return null ; } else { return map ; } }	Return all applicable SYSTEM system identifiers in thiscatalog.
public void readcatalog ( catalog catalog , string fileurl ) throws malformedurlexception , ioexception , catalogexception { url url = null ; try { url = new url ( fileurl ) ; } catch ( malformedurlexception e ) { url = new url ( str_ + fileurl ) ; } debug = catalog . getcatalogmanager ( ) . debug ; try { urlconnection urlcon = url . openconnection ( ) ; readcatalog ( catalog , urlcon . getinputstream ( ) ) ; } catch ( filenotfoundexception e ) { catalog . getcatalogmanager ( ) . debug . message ( num_ , str_ , url . tostring ( ) ) ; } }	Parse an XML Catalog file.
public void readcatalog ( catalog catalog , inputstream is ) throws ioexception , catalogexception {	Parse an XML Catalog stream.
public void connect ( ) throws ioexception { if ( connected ) return ; if ( ! file . exists ( ) ) { throw new filenotfoundexception ( file . getpath ( ) ) ; } connected = bool_ ; }	Checks if the underlying file for this connection exists.
public outputstream getoutputstream ( ) throws ioexception { connect ( ) ; securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) {	We should probably disallow this?.
void helpdelete ( node < k , v > b , node < k , v > f ) { if ( f == next && this == b . next ) { if ( f == null || f . value != f )	Helps out a deletion by appending marker or unlinking frompredecessor.
v getvalidvalue ( ) { object v = value ; if ( v == this || v == base_header ) return null ; return ( v ) v ; }	Return value if this node contains a valid key-value pair,else null.
snapshotentry < k , v > createsnapshot ( ) { v v = getvalidvalue ( ) ; if ( v == null ) return null ; return new snapshotentry ( key , v ) ; }	Create and return a new SnapshotEntry holding currentmapping if this node holds a valid value, else null.
private logger createlog ( ) { class < ? > clazz = getclass ( ) ; logger logger = loggers . get ( clazz ) ; if ( logger == null ) { logger = logger . getlogger ( clazz ) ; loggers . put ( clazz , logger ) ; } return logger ; }	Create logger.
public static void list ( jbossstringbuilder buffer , collection objects ) { if ( objects == null ) return ; buffer . append ( str_ ) ; if ( objects . isempty ( ) == bool_ ) { for ( iterator i = objects . iterator ( ) ; i . hasnext ( ) ; ) { object object = i . next ( ) ; if ( object instanceof jbossobject ) ( ( jbossobject ) object ) . toshortstring ( buffer ) ; else buffer . append ( object . tostring ( ) ) ; if ( i . hasnext ( ) ) buffer . append ( str_ ) ; } } buffer . append ( str_ ) ; }	List the set of JBossObjects.
public string getclassshortname ( ) { string longname = getclass ( ) . getname ( ) ; int dot = longname . lastindexof ( str_ ) ; if ( dot != - num_ ) return longname . substring ( dot + num_ ) ; return longname ; }	Get the class short name.
protected string tostringimplementation ( ) { jbossstringbuilder buffer = new jbossstringbuilder ( ) ; buffer . append ( getclassshortname ( ) ) . append ( str_ ) ; buffer . append ( integer . tohexstring ( system . identityhashcode ( this ) ) ) ; buffer . append ( str_ ) ; tostring ( buffer ) ; buffer . append ( str_ ) ; return buffer . tostring ( ) ; }	Implementation of String.
public static iterator names ( ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) sm . checkpropertiesaccess ( ) ; return props . names ( ) ; }	Return an iterator over all contained property names.
public static propertygroup getpropertygroup ( final string basename ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) sm . checkpropertiesaccess ( ) ; return props . getpropertygroup ( basename ) ; }	Get a property group for the given property base.
public static constructor getcompatibleconstructor ( final class type , final class valuetype ) {	Get a compatible constructor for the given value type.
public static object copy ( final serializable obj ) throws ioexception , classnotfoundexception { objectoutputstream out = null ; objectinputstream in = null ; object copy = null ; try {	Copy an serializable object deeply.
public static < t > t deref ( final object obj , class < t > expected ) { object result = deref ( obj ) ; if ( result == null ) return null ; return expected . cast ( result ) ; }	Dereference an object.
private void init ( ) { unboundlisteners = collections . synchronizedlist ( new arraylist ( ) ) ; boundlisteners = collections . synchronizedmap ( new hashmap ( ) ) ; jndimap = new hashmap ( ) ; privilegedaction action = new privilegedaction ( ) { public object run ( ) { object value = system . getproperty ( context . provider_url ) ; if ( value == null ) value = null_value ; jndimap . put ( context . provider_url , value ) ; value = system . getproperty ( context . initial_context_factory ) ; if ( value == null ) value = null_value ; jndimap . put ( context . initial_context_factory , value ) ; value = system . getproperty ( context . object_factories ) ; if ( value == null ) value = null_value ; jndimap . put ( context . object_factories , value ) ; value = system . getproperty ( context . url_pkg_prefixes ) ; if ( value == null ) value = null_value ; jndimap . put ( context . url_pkg_prefixes , value ) ; value = system . getproperty ( context . state_factories ) ; if ( value == null ) value = null_value ; jndimap . put ( context . state_factories , value ) ; value = system . getproperty ( context . dns_url ) ; if ( value == null ) value = null_value ; jndimap . put ( context . dns_url , value ) ; value = system . getproperty ( ldapcontext . control_factories ) ; if ( value == null ) value = null_value ; jndimap . put ( ldapcontext . control_factories , value ) ; return null ; } } ; accesscontroller . doprivileged ( action ) ; }	Initialized listener lists and the JNDI properties cache map.
private void updatejndicache ( string name , string value ) { if ( name == null ) return ; boolean isjndiproperty = name . equals ( context . provider_url ) || name . equals ( context . initial_context_factory ) || name . equals ( context . object_factories ) || name . equals ( context . url_pkg_prefixes ) || name . equals ( context . state_factories ) || name . equals ( context . dns_url ) || name . equals ( ldapcontext . control_factories ) ; if ( isjndiproperty == bool_ ) jndimap . put ( name , value ) ; }	Called by setProperty to update the jndiMap cache values.
public set keyset ( final boolean includedefaults ) { if ( includedefaults ) { set set = new hashset ( ) ; set . addall ( defaults . keyset ( ) ) ; set . addall ( super . keyset ( ) ) ; return collections . synchronizedset ( set ) ; } return super . keyset ( ) ; }	Returns a set of keys for all entries in this group and optionallyall of the keys in the defaults map.
public set entryset ( final boolean includedefaults ) { if ( includedefaults ) { set set = new hashset ( ) ; set . addall ( defaults . entryset ( ) ) ; set . addall ( super . entryset ( ) ) ; return collections . synchronizedset ( set ) ; } return super . entryset ( ) ; }	Returns a set of entrys for all entries in this group and optionallyall of the entrys in the defaults map.
public boolean removepropertylistener ( propertylistener listener ) { if ( listener == null ) throw new nullargumentexception ( str_ ) ; boolean removed = bool_ ; if ( listener instanceof boundpropertylistener ) { removed = removepropertylistener ( ( boundpropertylistener ) listener ) ; } else { removed = unboundlisteners . remove ( listener ) ; } return removed ; }	Remove a property listener.
private void firepropertyadded ( list list , propertyevent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num_ ; i < size ; i ++ ) { propertylistener listener = ( propertylistener ) list . get ( i ) ; listener . propertyadded ( event ) ; } }	Fire a property added event to the given list of listeners.
private void firepropertyremoved ( list list , propertyevent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num_ ; i < size ; i ++ ) { propertylistener listener = ( propertylistener ) list . get ( i ) ; listener . propertyremoved ( event ) ; } }	Fire a property removed event to the given list of listeners.
private void firepropertychanged ( list list , propertyevent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num_ ; i < size ; i ++ ) { propertylistener listener = ( propertylistener ) list . get ( i ) ; listener . propertychanged ( event ) ; } }	Fire a property changed event to the given list of listeners.
protected void firepropertychanged ( propertyevent event ) {	Fire a property changed event to all listeners.
protected string makeprefixedpropertyname ( string base , string prefix ) { string name = base ; if ( prefix != null ) { stringbuffer buff = new stringbuffer ( base ) ; if ( prefix != null ) { buff . insert ( num_ , property_name_separator ) ; buff . insert ( num_ , prefix ) ; } return buff . tostring ( ) ; } return name ; }	Make a optionaly prefixed property name.
public void load ( propertyreader reader ) throws propertyexception , ioexception { if ( reader == null ) throw new nullargumentexception ( str_ ) ; load ( reader . readproperties ( ) ) ; }	Load properties from a PropertyReader.
public void load ( string classname ) throws propertyexception , ioexception { if ( classname == null ) throw new nullargumentexception ( str_ ) ; propertyreader reader = null ; try { class type = class . forname ( classname ) ; reader = ( propertyreader ) type . newinstance ( ) ; } catch ( exception e ) { throw new propertyexception ( e ) ; }	Load properties from a PropertyReader specifed by the given class name.
public propertygroup getpropertygroup ( string basename , int index ) { string name = makeindexpropertyname ( basename , index ) ; return getpropertygroup ( name ) ; }	Get a property group for the given property base at the given index.
public boolean isentityresolved ( ) { boolean value = entityresolved . get ( ) ; return value != null ? value . booleanvalue ( ) : bool_ ; }	Returns the boolean value to inform id DTD was found in the XML file or not.
protected inputsource resolvesystemid ( string systemid , boolean trace ) { if ( systemid == null ) return null ; if ( trace ) log . trace ( str_ + systemid ) ; inputsource inputsource = null ;	Attempt to use the systemId as a URL from which the schema can be read.
protected inputsource resolvesystemidasurl ( string systemid , boolean trace ) { if ( systemid == null ) return null ; if ( trace ) log . trace ( str_ + systemid ) ; inputsource inputsource = null ;	Attempt to use the systemId as a URL from which the schema can be read.
protected inputsource resolveclasspathname ( string systemid , boolean trace ) { if ( systemid == null ) return null ; if ( trace ) log . trace ( str_ + systemid ) ; string filename = systemid ;	Resolve the systemId as a classpath resource.
public void setastext ( string text ) { document d = getasdocument ( text ) ; setvalue ( d . getdocumentelement ( ) ) ; }	Sets as an Element created by a String.
public static string normalize ( string publicid ) { string normal = publicid . replace ( str_ , str_ ) ; normal = normal . replace ( str_ , str_ ) ; normal = normal . replace ( str_ , str_ ) ; normal = normal . trim ( ) ; int pos ; while ( ( pos = normal . indexof ( str_ ) ) >= num_ ) { normal = normal . substring ( num_ , pos ) + normal . substring ( pos + num_ ) ; } return normal ; }	Normalize a public identifier.
public static string encodeurn ( string publicid ) { string urn = publicid . normalize ( publicid ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; urn = publicid . stringreplace ( urn , str_ , str_ ) ; return str_ + urn ; }	Encode a public identifier as a "publicid" URN.
public static string decodeurn ( string urn ) { string publicid = str_ ; if ( urn . startswith ( str_ ) ) { publicid = urn . substring ( num_ ) ; } else { return urn ; } publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; publicid = publicid . stringreplace ( publicid , str_ , str_ ) ; return publicid ; }	Decode a "publicid" URN into a public identifier.
private static string stringreplace ( string str , string oldstr , string newstr ) { string result = str_ ; int pos = str . indexof ( oldstr ) ;	Replace one string with another.
public void start ( final boolean reset ) { if ( ! running ) { if ( reset ) reset ( ) ; start = system . currenttimemillis ( ) ; running = bool_ ; } }	Start the watch.
public long stop ( ) { long lap = num_ ; if ( running ) { count ++ ; stop = system . currenttimemillis ( ) ; lap = stop - start ; total += lap ; running = bool_ ; } return lap ; }	Stop the watch.
public static stopwatch makesynchronized ( final stopwatch watch ) { return new wrapper ( watch ) { private static final long serialversionuid = - num_ ; public synchronized void start ( final boolean reset ) { this . watch . start ( reset ) ; } public synchronized void start ( ) { this . watch . start ( ) ; } public synchronized long stop ( ) { return this . watch . stop ( ) ; } public synchronized void reset ( ) { this . watch . reset ( ) ; } public synchronized long getlaptime ( ) { return this . watch . getlaptime ( ) ; } public synchronized long getaveragelaptime ( ) { return this . watch . getaveragelaptime ( ) ; } public synchronized int getlapcount ( ) { return this . watch . getlapcount ( ) ; } public synchronized long gettime ( ) { return this . watch . gettime ( ) ; } public synchronized boolean isrunning ( ) { return this . watch . isrunning ( ) ; } public synchronized string tostring ( ) { return this . watch . tostring ( ) ; } } ; }	Return a synchronized stop watch.
public int compareto ( final object obj ) throws classcastexception { hashcode hashcode = ( hashcode ) obj ; return compareto ( hashcode . value ) ; }	Compares this object with the specified object for order.
public static int generate ( final byte [ ] bytes ) { int hashcode = num_ ; for ( int i = num_ ; i < bytes . length ; i ++ ) { hashcode <<= num_ ; hashcode ^= bytes [ i ] ; } return hashcode ; }	Generate a hash code for a byte array.
public static int generate ( final object array [ ] , final boolean deep ) { int hashcode = num_ ; for ( int i = num_ ; i < array . length ; i ++ ) { if ( deep && ( array [ i ] instanceof object [ ] ) ) { hashcode ^= generate ( ( object [ ] ) array [ i ] , bool_ ) ; } else { hashcode ^= array [ i ] . hashcode ( ) ; } } return hashcode ; }	Generate a hash code for an object array.
public void create ( ) { m_map = createmap ( ) ; m_list = createlist ( ) ; m_list . m_maxcapacity = m_maxcapacity ; m_list . m_mincapacity = m_mincapacity ; m_list . m_capacity = m_maxcapacity ; }	Initializes the cache, creating all required objects and initializing theirvalues.
protected void setfieldvalue ( string value ) { try {	Coerce and set specified value to field.
protected string nexttoken ( ) throws ioexception { string token = str_ ; int ch , nextch ; if ( ! tokenstack . empty ( ) ) { return ( string ) tokenstack . pop ( ) ; }	Return the next token in the catalog file.
public static void initialize ( ) { privilegedaction action = new privilegedaction ( ) { public object run ( ) { string defaultformat = system . getproperty ( str_ , str_ ) ; string defaultlocale = system . getproperty ( str_ ) ; dateformat defaultdateformat ; if ( defaultlocale == null || defaultlocale . length ( ) == num_ ) { defaultdateformat = new simpledateformat ( defaultformat ) ; } else { defaultdateformat = new simpledateformat ( defaultformat , strings . parselocalestring ( defaultlocale ) ) ; } formats = new dateformat [ ] { defaultdateformat ,	Setup the parsing formats.
public boolean addvertex ( vertex < t > v ) { if ( verticies . containsvalue ( v ) == bool_ ) { verticies . put ( v . getname ( ) , v ) ; return bool_ ; } return bool_ ; }	Add a vertex to the graph.
public void setrootvertex ( vertex < t > root ) { this . rootvertex = root ; if ( verticies . containsvalue ( root ) == bool_ ) addvertex ( root ) ; }	Set a root vertex.
public boolean removevertex ( vertex < t > v ) { if ( ! verticies . containsvalue ( v ) ) return bool_ ; verticies . remove ( v . getname ( ) ) ; if ( v == rootvertex ) rootvertex = null ;	Remove a vertex from the graph.
public void depthfirstsearch ( vertex < t > v , final visitor < t > visitor ) { visitorex < t , runtimeexception > wrapper = new visitorex < t , runtimeexception > ( ) { public void visit ( graph < t > g , vertex < t > v ) throws runtimeexception { if ( visitor != null ) visitor . visit ( g , v ) ; } } ; this . depthfirstsearch ( v , wrapper ) ; }	Perform a depth first serach using recursion.
public void dfsspanningtree ( vertex < t > v , dfsvisitor < t > visitor ) { v . visit ( ) ; if ( visitor != null ) visitor . visit ( this , v ) ; for ( int i = num_ ; i < v . getoutgoingedgecount ( ) ; i ++ ) { edge < t > e = v . getoutgoingedge ( i ) ; if ( ! e . getto ( ) . visited ( ) ) { if ( visitor != null ) visitor . visit ( this , v , e ) ; e . mark ( ) ; dfsspanningtree ( e . getto ( ) , visitor ) ; } } }	Find the spanning tree using a DFS starting from v.
public vertex < t > findvertexbydata ( t data , comparator < t > compare ) { vertex < t > match = null ; for ( vertex < t > v : verticies . values ( ) ) { if ( compare . compare ( data , v . getdata ( ) ) == num_ ) { match = v ; break ; } } return match ; }	Search the verticies for one with data.
public edge < t > [ ] findcycles ( ) { arraylist < edge < t > > cycleedges = new arraylist < edge < t > > ( ) ;	Search the graph for cycles.
public static string normalize ( string s , boolean canonical ) { stringbuffer str = new stringbuffer ( ) ; int len = ( s != null ) ? s . length ( ) : num_ ; for ( int i = num_ ; i < len ; i ++ ) { char ch = s . charat ( i ) ; switch ( ch ) { case str_ : { str . append ( str_ ) ; break ; } case str_ : { str . append ( str_ ) ; break ; } case str_ : { str . append ( str_ ) ; break ; } case str_ : { str . append ( str_ ) ; break ; } case str_ : { str . append ( str_ ) ; break ; } case str_ : case str_ : { if ( canonical ) { str . append ( str_ ) ; str . append ( integer . tostring ( ch ) ) ; str . append ( str_ ) ; break ; }	Normalizes the given string.
public static element parse ( string xmlstring ) throws ioexception { try { return parse ( new bytearrayinputstream ( xmlstring . getbytes ( str_ ) ) ) ; } catch ( ioexception e ) { log . error ( str_ + xmlstring ) ; throw e ; } }	Parse the given XML string and return the root Element.
public static element parse ( inputstream xmlstream ) throws ioexception { try { document doc = getdocumentbuilder ( ) . parse ( xmlstream ) ; element root = doc . getdocumentelement ( ) ; return root ; } catch ( saxexception e ) { throw new ioexception ( e . tostring ( ) ) ; } }	Parse the given XML stream and return the root Element.
public static element parse ( inputsource source ) throws ioexception { try { document doc = getdocumentbuilder ( ) . parse ( source ) ; element root = doc . getdocumentelement ( ) ; return root ; } catch ( saxexception e ) { throw new ioexception ( e . tostring ( ) ) ; } }	Parse the given input source and return the root Element.
public static element createelement ( string localpart ) { document doc = getownerdocument ( ) ; log . trace ( str_ + localpart ) ; return doc . createelement ( localpart ) ; }	Create an Element for a given name.
public static qname resolveqname ( element el , string qualifiedname ) { qname qname ; string prefix = str_ ; string namespaceuri = str_ ; string localpart = qualifiedname ; int colindex = qualifiedname . indexof ( str_ ) ; if ( colindex > num_ ) { prefix = qualifiedname . substring ( num_ , colindex ) ; localpart = qualifiedname . substring ( colindex + num_ ) ; if ( str_ . equals ( prefix ) ) { namespaceuri = str_ ; } else { element nselement = el ; while ( namespaceuri . equals ( str_ ) && nselement != null ) { namespaceuri = nselement . getattribute ( str_ + prefix ) ; if ( namespaceuri . equals ( str_ ) ) nselement = getparentelement ( nselement ) ; } } if ( namespaceuri . equals ( str_ ) ) throw new illegalargumentexception ( str_ + qualifiedname ) ; } qname = new qname ( namespaceuri , localpart , prefix ) ; return qname ; }	Transform the giveen qualified name into a QName.
public static void copyattributes ( element destelement , element srcelement ) { namednodemap attribs = srcelement . getattributes ( ) ; for ( int i = num_ ; i < attribs . getlength ( ) ; i ++ ) { attr attr = ( attr ) attribs . item ( i ) ; string uri = attr . getnamespaceuri ( ) ; string qname = attr . getname ( ) ; string value = attr . getnodevalue ( ) ;	Copy attributes between elements.
public static boolean haschildelements ( node node ) { nodelist nlist = node . getchildnodes ( ) ; for ( int i = num_ ; i < nlist . getlength ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . getnodetype ( ) == node . element_node ) return bool_ ; } return bool_ ; }	True if the node has child elements.
public static iterator getchildelements ( node node ) { arraylist list = new arraylist ( ) ; nodelist nlist = node . getchildnodes ( ) ; for ( int i = num_ ; i < nlist . getlength ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . getnodetype ( ) == node . element_node ) list . add ( child ) ; } return list . iterator ( ) ; }	Gets child elements.
public static string gettextcontent ( node node , boolean replaceprops ) { boolean hastextcontent = bool_ ; stringbuffer buffer = new stringbuffer ( ) ; nodelist nlist = node . getchildnodes ( ) ; for ( int i = num_ ; i < nlist . getlength ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . getnodetype ( ) == node . text_node ) { buffer . append ( child . getnodevalue ( ) ) ; hastextcontent = bool_ ; } } string text = ( hastextcontent ? buffer . tostring ( ) : null ) ; if ( text != null && replaceprops ) text = stringpropertyreplacer . replaceproperties ( text ) ; return text ; }	Get the concatenated text content, or null.
public static iterator getchildelements ( node node , string nodename ) { return getchildelementsintern ( node , new qname ( nodename ) ) ; }	Gets the child elements for a given local name without namespace.
public static element getparentelement ( node node ) { node parent = node . getparentnode ( ) ; return ( parent instanceof element ? ( element ) parent : null ) ; }	Gets parent element or null if there is none.
public void addwaiting ( object holder , resource resource ) { synchronized ( waiting ) { waiting . put ( holder , resource ) ; } }	Add a transaction waiting for a lock.
public void readcatalog ( catalog catalog , string fileurl ) throws malformedurlexception , ioexception , catalogexception { url url = new url ( fileurl ) ; urlconnection urlcon = url . openconnection ( ) ; readcatalog ( catalog , urlcon . getinputstream ( ) ) ; }	Read the catalog behind the specified URL.
private static byte [ ] gethostaddress ( ) { return ( byte [ ] ) accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { try { return inetaddress . getlocalhost ( ) . getaddress ( ) ; } catch ( exception e ) { return unknown_host ; } } } ) ; }	Return the current host internet address.
public static throwable setsystempropertyclassvalue ( string property , string classname ) {	Sets the system property to a class when the class is available.
public static void displayclassinfo ( class clazz , stringbuffer results ) {	Format a string buffer containing the Class, Interfaces, CodeSource,and ClassLoader information for the given object clazz.
public static void describe ( stringbuffer buffer , class clazz ) { if ( clazz == null ) buffer . append ( str_ ) ; else { buffer . append ( str_ ) . append ( clazz . getname ( ) ) ; class [ ] intfs = clazz . getinterfaces ( ) ; if ( intfs . length > num_ ) { buffer . append ( str_ ) ; for ( int i = num_ ; i < intfs . length ; ++ i ) { buffer . append ( intfs [ i ] . getname ( ) ) ; if ( i < intfs . length - num_ ) buffer . append ( str_ ) ; } } buffer . append ( str_ ) ; } }	Describe the class.
public static string strippackagename ( final string classname ) { int idx = classname . lastindexof ( package_separator ) ; if ( idx != - num_ ) return classname . substring ( idx + num_ , classname . length ( ) ) ; return classname ; }	Get the short name of the specified class by striping off the packagename.
public static string getpackagename ( final string classname ) { if ( classname . length ( ) == num_ ) throw new emptystringexception ( ) ; int index = classname . lastindexof ( package_separator ) ; if ( index != - num_ ) return classname . substring ( num_ , index ) ; return str_ ; }	Get the package name of the specified class.
public static void forceload ( final class type ) { if ( type == null ) throw new nullargumentexception ( str_ ) ;	Force the given class to be loaded fully.
public static class getprimitivewrapper ( final class type ) { if ( ! type . isprimitive ( ) ) { throw new illegalargumentexception ( str_ ) ; } for ( int i = num_ ; i < primitive_wrapper_map . length ; i += num_ ) { if ( type . equals ( primitive_wrapper_map [ i ] ) ) return primitive_wrapper_map [ i + num_ ] ; }	Get the wrapper class for the given primitive type.
public static void getallinterfaces ( list allifaces , class c ) { while ( c != null ) { class [ ] ifaces = c . getinterfaces ( ) ; for ( int n = num_ ; n < ifaces . length ; n ++ ) { allifaces . add ( ifaces [ n ] ) ; } c = c . getsuperclass ( ) ; } }	Populates a list with all the interfaces implemented by the argumentclass c and all its superclasses.
public static class [ ] getalluniqueinterfaces ( class c ) { set uniqueifaces = new hashset ( ) ; while ( c != null ) { class [ ] ifaces = c . getinterfaces ( ) ; for ( int n = num_ ; n < ifaces . length ; n ++ ) { uniqueifaces . add ( ifaces [ n ] ) ; } c = c . getsuperclass ( ) ; } return ( class [ ] ) uniqueifaces . toarray ( new class [ uniqueifaces . size ( ) ] ) ; }	Returns an array containing all the unique interfaces implementedby the argument class c and all its superclasses.
public static boolean isprimitivewrapper ( final class type ) { for ( int i = num_ ; i < primitive_wrapper_map . length ; i += num_ ) { if ( type . equals ( primitive_wrapper_map [ i + num_ ] ) ) { return bool_ ; } } return bool_ ; }	Check if the given class is a primitive wrapper class.
public static object instantiate ( class expected , string property , string defaultclassname ) { string classname = getproperty ( property , defaultclassname ) ; class clazz = null ; try { clazz = loadclass ( classname ) ; } catch ( classnotfoundexception e ) { throw new nestedruntimeexception ( str_ + classname , e ) ; } object result = null ; try { result = clazz . newinstance ( ) ; } catch ( instantiationexception e ) { throw new nestedruntimeexception ( str_ + classname , e ) ; } catch ( illegalaccessexception e ) { throw new nestedruntimeexception ( str_ + classname , e ) ; } if ( expected . isassignablefrom ( clazz ) == bool_ ) throw new nestedruntimeexception ( str_ + classname + str_ + clazz . getclassloader ( ) + str_ + expected + str_ + expected . getclassloader ( ) ) ; return result ; }	Instantiate a java class object.
public final static method getattributegetter ( class cls , string attr ) throws nosuchmethodexception { stringbuffer buf = new stringbuffer ( attr . length ( ) + num_ ) ; buf . append ( str_ ) ; if ( character . islowercase ( attr . charat ( num_ ) ) ) { buf . append ( character . touppercase ( attr . charat ( num_ ) ) ) . append ( attr . substring ( num_ ) ) ; } else { buf . append ( attr ) ; } try { return cls . getmethod ( buf . tostring ( ) , ( class [ ] ) null ) ; } catch ( nosuchmethodexception e ) { buf . replace ( num_ , num_ , str_ ) ; return cls . getmethod ( buf . tostring ( ) , ( class [ ] ) null ) ; } }	Returns attribute's getter method.
public final static method getattributesetter ( class cls , string attr , class type ) throws nosuchmethodexception { stringbuffer buf = new stringbuffer ( attr . length ( ) + num_ ) ; buf . append ( str_ ) ; if ( character . islowercase ( attr . charat ( num_ ) ) ) { buf . append ( character . touppercase ( attr . charat ( num_ ) ) ) . append ( attr . substring ( num_ ) ) ; } else { buf . append ( attr ) ; } return cls . getmethod ( buf . tostring ( ) , new class [ ] { type } ) ; }	Returns attribute's setter method.
private final static class converttojavaclass ( string name , classloader cl ) throws classnotfoundexception { int arraysize = num_ ; while ( name . endswith ( str_ ) ) { name = name . substring ( num_ , name . length ( ) - num_ ) ; arraysize ++ ; }	Convert a given String into the appropriate Class.
private static string getproperty ( final string name , final string defaultvalue ) { return ( string ) accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { return system . getproperty ( name , defaultvalue ) ; } } ) ; }	Get a system property.
public static string [ ] getfilenames ( final string propertyname ) throws propertyexception { string filenames [ ] ;	Get an array of filenames to load.
protected final void maintain ( ) { weakobject weak ; while ( ( weak = ( weakobject ) queue . poll ( ) ) != null ) { set . remove ( weak ) ; } }	Maintain the elements in the set.
public iterator iterator ( ) { return new iterator ( ) { iterator iter = set . iterator ( ) ; object unknown = new object ( ) ; object next = unknown ; public boolean hasnext ( ) { if ( next != unknown ) { return bool_ ; } while ( iter . hasnext ( ) ) { weakobject weak = ( weakobject ) iter . next ( ) ; object obj = null ; if ( weak != null && ( obj = weak . get ( ) ) == null ) {	Return an iteration over the elements in the set.
public urllister createurllister ( string protocol ) throws malformedurlexception { try { string classname = ( string ) classes . get ( protocol ) ; if ( classname == null ) { throw new malformedurlexception ( str_ + protocol ) ; } class < ? > clazz = thread . currentthread ( ) . getcontextclassloader ( ) . loadclass ( classname ) ; return ( urllister ) clazz . newinstance ( ) ; } catch ( classnotfoundexception e ) { throw new malformedurlexception ( e . getmessage ( ) ) ; } catch ( instantiationexception e ) { throw new malformedurlexception ( e . getmessage ( ) ) ; } catch ( illegalaccessexception e ) { throw new malformedurlexception ( e . getmessage ( ) ) ; } }	Create a URL lister for the supplied protocol.
@ suppresswarnings ( str_ ) public set entryset ( ) { final set superset = super . entryset ( bool_ ) ; return new java . util . abstractset ( ) { private boolean isingroup ( map . entry entry ) { string key = ( string ) entry . getkey ( ) ; return key . startswith ( basename ) ; } public int size ( ) { iterator iter = superset . iterator ( ) ; int count = num_ ; while ( iter . hasnext ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; if ( isingroup ( entry ) ) { count ++ ; } } return count ; } public iterator iterator ( ) { return new iterator ( ) { private iterator iter = superset . iterator ( ) ; private object next ; public boolean hasnext ( ) { if ( next != null ) return bool_ ; while ( next == null ) { if ( iter . hasnext ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; if ( isingroup ( entry ) ) { next = entry ; return bool_ ; } } else { break ; } } return bool_ ; } public object next ( ) { if ( next == null ) throw new java . util . nosuchelementexception ( ) ; object obj = next ; next = null ; return obj ; } public void remove ( ) { iter . remove ( ) ; } } ; } } ; }	Returns an entry set for all properties in this group.
protected void addpropertylistener ( final boundpropertylistener listener ) {	Add a bound property listener.
protected boolean removepropertylistener ( final boundpropertylistener listener ) {	Remove a bound property listener.
public static final boolean isnull ( final string value , final boolean trim , final boolean empty ) {	Whether a string is interpreted as the null value.
public static propertyeditor findeditor ( final string typename ) throws classnotfoundexception {	Locate a value editor for a given target type.
public static void registereditor ( final string typename , final string editortypename ) throws classnotfoundexception { classloader loader = thread . currentthread ( ) . getcontextclassloader ( ) ; class < ? > type = loader . loadclass ( typename ) ; class < ? > editortype = loader . loadclass ( editortypename ) ; propertyeditormanager . registereditor ( type , editortype ) ; }	Register an editor class to be used to editor values of a given target class.
public static object convertvalue ( string text , string typename ) throws classnotfoundexception , introspectionexception {	Convert a string value into the true value for typeName using thePropertyEditor associated with typeName.
public classloader getcontextclassloader ( final thread thread ) { return ( classloader ) accesscontroller . doprivileged ( new privilegedaction ( ) { public object run ( ) { return thread . getcontextclassloader ( ) ; } } ) ; }	Retrieve the context classloader for the given thread.
public static applicationdeadlockexception isade ( throwable t ) { while ( t != null ) { if ( t instanceof applicationdeadlockexception ) { return ( applicationdeadlockexception ) t ; } else { t = t . getcause ( ) ; } } return null ; }	Detects exception contains is or a ApplicationDeadlockException.
public timeout schedule ( long time , timeouttarget target ) { if ( cancelled . get ( ) ) throw new illegalstateexception ( str_ ) ; if ( time < num_ ) throw new illegalargumentexception ( str_ ) ; if ( target == null ) throw new illegalargumentexception ( str_ ) ; return queue . offer ( time , target ) ; }	Schedules a new timeout.
private void dowork ( ) { while ( cancelled . get ( ) == bool_ ) { timeoutext work = queue . take ( ) ;	Timeout worker method.
public static context createsubcontext ( context ctx , string name ) throws namingexception { name n = ctx . getnameparser ( str_ ) . parse ( name ) ; return createsubcontext ( ctx , n ) ; }	Create a subcontext including any intermediate contexts.
public static object lookup ( string name , class < ? > clazz ) throws exception { initialcontext ctx = new initialcontext ( ) ; try { return lookup ( ctx , name , clazz ) ; } finally { ctx . close ( ) ; } }	Lookup an object in the default initial context.
protected static void checkobject ( context context , string name , object object , class clazz ) throws exception { class objectclass = object . getclass ( ) ; if ( clazz . isassignablefrom ( objectclass ) == bool_ ) { stringbuffer buffer = new stringbuffer ( num_ ) ; buffer . append ( str_ ) . append ( name ) ; buffer . append ( str_ ) . append ( context . getenvironment ( ) ) ; buffer . append ( str_ ) ; appendclassinfo ( buffer , clazz ) ; buffer . append ( str_ ) ; appendclassinfo ( buffer , object . getclass ( ) ) ; throw new classcastexception ( buffer . tostring ( ) ) ; } }	Checks an object implements the given class.
protected static void appendclassinfo ( stringbuffer buffer , class clazz ) { buffer . append ( str_ ) . append ( clazz . getname ( ) ) ; buffer . append ( str_ ) . append ( clazz . getclassloader ( ) ) ; buffer . append ( str_ ) ; class [ ] interfaces = clazz . getinterfaces ( ) ; for ( int i = num_ ; i < interfaces . length ; ++ i ) { if ( i > num_ ) buffer . append ( str_ ) ; buffer . append ( str_ ) . append ( interfaces [ i ] . getname ( ) ) ; buffer . append ( str_ ) . append ( interfaces [ i ] . getclassloader ( ) ) ; } buffer . append ( str_ ) ; }	Append Class Info.
public transition gettransition ( string name ) { transition t = ( transition ) allowedtransitions . get ( name ) ; return t ; }	Lookup an allowed transition given its name.
private synchronized void readproperties ( ) { try { propertyfileuri = catalogmanager . class . getresource ( str_ + propertyfile ) ; inputstream in = catalogmanager . class . getresourceasstream ( str_ + propertyfile ) ; if ( in == null ) { if ( ! ignoremissingproperties ) { system . err . println ( str_ + propertyfile ) ;	Load the properties from the propertyFile and build theresources from it.
private int queryverbosity ( ) { string verbstr = system . getproperty ( pverbosity ) ; if ( verbstr == null ) { if ( resources == null ) readproperties ( ) ; if ( resources == null ) return defaultverbosity ; try { verbstr = resources . getstring ( str_ ) ; } catch ( missingresourceexception e ) { return defaultverbosity ; } } try { int verb = integer . parseint ( verbstr . trim ( ) ) ; return verb ; } catch ( exception e ) { system . err . println ( str_ + verbstr + str_ ) ; return defaultverbosity ; } }	Obtain the verbosity setting from the properties.
private boolean queryrelativecatalogs ( ) { if ( resources == null ) readproperties ( ) ; if ( resources == null ) return defaultrelativecatalogs ; try { string allow = resources . getstring ( str_ ) ; return ( allow . equalsignorecase ( str_ ) || allow . equalsignorecase ( str_ ) || allow . equalsignorecase ( str_ ) ) ; } catch ( missingresourceexception e ) { return defaultrelativecatalogs ; } }	Obtain the relativeCatalogs setting from the properties.
private string querycatalogfiles ( ) { string cataloglist = system . getproperty ( pfiles ) ; frompropertiesfile = bool_ ; if ( cataloglist == null ) { if ( resources == null ) readproperties ( ) ; if ( resources != null ) { try { cataloglist = resources . getstring ( str_ ) ; frompropertiesfile = bool_ ; } catch ( missingresourceexception e ) { system . err . println ( propertyfile + str_ ) ; cataloglist = null ; } } } if ( cataloglist == null ) { cataloglist = defaultcatalogfiles ; } return cataloglist ; }	Obtain the list of catalog files from the properties.
public vector getcatalogfiles ( ) { if ( catalogfiles == null ) { catalogfiles = querycatalogfiles ( ) ; } stringtokenizer files = new stringtokenizer ( catalogfiles , str_ ) ; vector catalogs = new vector ( ) ; while ( files . hasmoretokens ( ) ) { string catalogfile = files . nexttoken ( ) ; url absuri = null ; if ( frompropertiesfile && ! relativecatalogs ( ) ) { try { absuri = new url ( propertyfileuri , catalogfile ) ; catalogfile = absuri . tostring ( ) ; } catch ( malformedurlexception mue ) { absuri = null ; } } catalogs . add ( catalogfile ) ; } return catalogs ; }	Return the current list of catalog files.
private boolean querypreferpublic ( ) { string prefer = system . getproperty ( pprefer ) ; if ( prefer == null ) { if ( resources == null ) readproperties ( ) ; if ( resources == null ) return defaultpreferpublic ; try { prefer = resources . getstring ( str_ ) ; } catch ( missingresourceexception e ) { return defaultpreferpublic ; } } if ( prefer == null ) { return defaultpreferpublic ; } return ( prefer . equalsignorecase ( str_ ) ) ; }	Obtain the preferPublic setting from the properties.
private boolean queryusestaticcatalog ( ) { string staticcatalog = system . getproperty ( pstatic ) ; if ( usestaticcatalog == null ) { if ( resources == null ) readproperties ( ) ; if ( resources == null ) return defaultusestaticcatalog ; try { staticcatalog = resources . getstring ( str_ ) ; } catch ( missingresourceexception e ) { return defaultusestaticcatalog ; } } if ( staticcatalog == null ) { return defaultusestaticcatalog ; } return ( staticcatalog . equalsignorecase ( str_ ) || staticcatalog . equalsignorecase ( str_ ) || staticcatalog . equalsignorecase ( str_ ) ) ; }	Obtain the static-catalog setting from the properties.
public inputsource resolveentity ( string publicid , string systemid ) { string resolved = null ; if ( systemid != null && systemmap . containskey ( systemid ) ) { resolved = ( string ) systemmap . get ( systemid ) ; } else if ( publicid != null && publicmap . containskey ( publicid ) ) { resolved = ( string ) publicmap . get ( publicid ) ; } if ( resolved != null ) { try { inputsource isource = new inputsource ( resolved ) ; isource . setpublicid ( publicid ) ;	SAX resolveEntity API.
public source resolve ( string href , string base ) throws transformerexception { string uri = href ; int hashpos = href . indexof ( str_ ) ; if ( hashpos >= num_ ) { uri = href . substring ( num_ , hashpos ) ; } string result = null ; if ( href != null && urimap . containskey ( href ) ) { result = ( string ) urimap . get ( href ) ; } if ( result == null ) { try { url url = null ; if ( base == null ) { url = new url ( uri ) ; result = url . tostring ( ) ; } else { url baseurl = new url ( base ) ; url = ( href . length ( ) == num_ ? baseurl : new url ( baseurl , uri ) ) ; result = url . tostring ( ) ; } } catch ( java . net . malformedurlexception mue ) {	Transformer resolve API.
private string makeabsolute ( string uri ) { if ( uri == null ) { uri = str_ ; } try { url url = new url ( uri ) ; return url . tostring ( ) ; } catch ( malformedurlexception mue ) { string dir = system . getproperty ( str_ ) ; string file = str_ ; if ( dir . endswith ( str_ ) ) { file = str_ + dir + uri ; } else { file = str_ + dir + str_ + uri ; } try { url fileurl = new url ( file ) ; return fileurl . tostring ( ) ; } catch ( malformedurlexception mue2 ) {	Attempt to construct an absolute URI.
protected class < ? > resolveclass ( objectstreamclass v ) throws ioexception , classnotfoundexception { classloader loader = thread . currentthread ( ) . getcontextclassloader ( ) ; string classname = v . getname ( ) ; try {	Use the thread context class loader to resolve the class.
protected void invokesetter ( string value ) { try {	Coerce and invoke the property setter method on the instance.
public static string getlocalname ( element element ) { string name = element . gettagname ( ) ; if ( name . indexof ( str_ ) > num_ ) { name = name . substring ( name . indexof ( str_ ) + num_ ) ; } return name ; }	Returns the "localname" part of a QName, which is the wholename if it has no prefix.
public static string getnamespaceuri ( node node , string prefix ) { if ( node == null || node . getnodetype ( ) != node . element_node ) { return null ; } if ( prefix . equals ( str_ ) ) { if ( ( ( element ) node ) . hasattribute ( str_ ) ) { return ( ( element ) node ) . getattribute ( str_ ) ; } } else { string nsattr = str_ + prefix ; if ( ( ( element ) node ) . hasattribute ( nsattr ) ) { return ( ( element ) node ) . getattribute ( nsattr ) ; } } return getnamespaceuri ( node . getparentnode ( ) , prefix ) ; }	Returns the namespace URI for the specified prefix at thespecified context node.
public static string getnamespaceuri ( element element ) { string prefix = getprefix ( element ) ; return getnamespaceuri ( element , prefix ) ; }	Returns the namespace URI for the namespace to which theelement belongs.
public static list list ( enumeration e ) { arraylist result = new arraylist ( ) ; while ( e . hasmoreelements ( ) ) result . add ( e . nextelement ( ) ) ; return result ; }	Create a list from an enumeration.
protected inputstream getinputstream ( string filename ) throws ioexception { file file = new file ( filename ) ; return new fileinputstream ( file ) ; }	Get an input stream for the given filename.
protected void loadproperties ( properties props , string filename ) throws ioexception { if ( filename == null ) throw new nullargumentexception ( str_ ) ; if ( filename . equals ( str_ ) ) throw new illegalargumentexception ( str_ ) ; inputstream in = new bufferedinputstream ( getinputstream ( filename ) ) ; props . load ( in ) ; in . close ( ) ; }	Load properties from a file into a properties map.
public map readproperties ( ) throws propertyexception , ioexception { properties props = new properties ( ) ;	Read properties from each specified filename.
public boolean addedge ( edge < t > e ) { if ( e . getfrom ( ) == this ) outgoingedges . add ( e ) ; else if ( e . getto ( ) == this ) incomingedges . add ( e ) ; else return bool_ ; return bool_ ; }	Add an edge to the vertex.
public void addoutgoingedge ( vertex < t > to , int cost ) { edge < t > out = new edge < t > ( this , to , cost ) ; outgoingedges . add ( out ) ; }	Add an outgoing edge ending at to.
public void addincomingedge ( vertex < t > from , int cost ) { edge < t > out = new edge < t > ( this , from , cost ) ; incomingedges . add ( out ) ; }	Add an incoming edge starting at from.
public boolean hasedge ( edge < t > e ) { if ( e . getfrom ( ) == this ) return outgoingedges . contains ( e ) ; else if ( e . getto ( ) == this ) return incomingedges . contains ( e ) ; else return bool_ ; }	Check the vertex for either an incoming or outgoing edgemathcing e.
public boolean remove ( edge < t > e ) { if ( e . getfrom ( ) == this ) outgoingedges . remove ( e ) ; else if ( e . getto ( ) == this ) incomingedges . remove ( e ) ; else return bool_ ; return bool_ ; }	Remove an edge from this vertex.
public edge < t > findedge ( vertex < t > dest ) { for ( edge < t > e : outgoingedges ) { if ( e . getto ( ) == dest ) return e ; } return null ; }	Search the outgoing edges looking for an edge whose'sedge.to == dest.
public edge < t > findedge ( edge < t > e ) { if ( outgoingedges . contains ( e ) ) return e ; else return null ; }	Search the outgoing edges for a match to e.
public int cost ( vertex < t > dest ) { if ( dest == this ) return num_ ; edge < t > e = findedge ( dest ) ; int cost = integer . max_value ; if ( e != null ) cost = e . getcost ( ) ; return cost ; }	What is the cost from this vertext to the dest vertex.
private static void jar ( file src , string prefix , jarinfo info ) throws ioexception { jaroutputstream jout = info . out ; if ( src . isdirectory ( ) ) {	This recursive method writes all matching files and directories tothe jar output stream.
public boolean hasnext ( ) { for ( ; index < iters . length ; index ++ ) { if ( iters [ index ] != null && iters [ index ] . hasnext ( ) ) { return bool_ ; } } return bool_ ; }	Check if there are more elements.
public void fireevent ( object event ) { if ( event == null ) { throw new illegalargumentexception ( str_ ) ; } mtaskqueue . offer ( task . obtaintask ( task . code_fire_event , event , - num_ ) ) ; if ( ! mqueueprocessed ) processtaskqueue ( ) ; }	Forwards an event into state machine.
private void internalinstalljvmtypeprovider ( xtextresourceset resourceset , file tmpclassdirectory , boolean skipindexlookup ) { iterable < string > classpathentries = concat ( getclasspathentries ( ) , getsourcepathdirectories ( ) , aslist ( tmpclassdirectory . tostring ( ) ) ) ; classpathentries = filter ( classpathentries , new predicate < string > ( ) { public boolean apply ( string input ) { return ! strings . isempty ( input . trim ( ) ) ; } } ) ; function < string , url > tourl = new function < string , url > ( ) { public url apply ( string from ) { try { return new file ( from ) . touri ( ) . tourl ( ) ; } catch ( malformedurlexception e ) { throw new runtimeexception ( e ) ; } } } ; iterable < url > classpathurls = iterables . transform ( classpathentries , tourl ) ; log . debug ( str_ + classpathurls ) ; classloader parentclassloader ; if ( usecurrentclassloaderasparent ) { parentclassloader = currentclassloader ; } else { if ( isempty ( bootclasspath ) ) { parentclassloader = classloader . getsystemclassloader ( ) . getparent ( ) ; } else { iterable < url > bootclasspathurls = iterables . transform ( getbootclasspathentries ( ) , tourl ) ; parentclassloader = new bootclassloader ( toarray ( bootclasspathurls , url . class ) ) ; } } classloader urlclassloader = new urlclassloader ( toarray ( classpathurls , url . class ) , parentclassloader ) ; new classpathtypeprovider ( urlclassloader , resourceset , skipindexlookup ? null : indexedjvmtypeaccess ) ; resourceset . setclasspathuricontext ( urlclassloader ) ;	Performs the actual installation of the JvmTypeProvider.
public void dispatchonfxthread ( action action ) { if ( platform . isfxapplicationthread ( ) ) { actionstream . push ( action ) ; } else { platform . runlater ( ( ) -> actionstream . push ( action ) ) ; } }	Dispatch the given action.
@ suppresswarnings ( str_ ) < t extends action > eventstream < t > getactionstream ( class < t > actiontype ) { return dispatcher . getinstance ( ) . getactionstream ( ) . filter ( action -> action . getclass ( ) . equals ( actiontype ) ) . map ( action -> ( t ) action ) ; }	A filtered event-stream of actions of the given type.
public stream < t2 < l , r > > strictmanytoone ( collection < ? extends r > rights ) { return strictmanytoone ( rights . stream ( ) ) ; }	Strict many to one.
public stream < t2 < l , r > > strictonetoone ( collection < ? extends r > rights ) { return strictonetoone ( rights . stream ( ) ) ; }	Strict one to one.
@ override public boolean getallowrobots ( servletcontext servletcontext , httpservletrequest request , httpservletresponse response , page page ) throws servletexception , ioexception { return pageutils . findallowrobots ( servletcontext , request , response , page ) ; }	Uses the page settings.
@ then ( str_ ) public void the_instruction_generated_should_be ( string command ) throws throwable { verify ( context . getdrinkmaker ( ) ) . executecommand ( eq ( command ) ) ; }	Assert that the generated command matches the specified command.
public int getsumdegree ( ) { if ( sumdegree < num_ ) { int sum = num_ ; for ( word word : words ) { if ( word != null && word . getdegree ( ) > - num_ ) { sum += word . getdegree ( ) ; } } sumdegree = sum ; } return sumdegree ; }	Sum of Degree of Morphemic Freedom of One-Character.
private static map < string , string > superclassargs ( map < string , string > args ) { map < string , string > result = new hashmap < > ( ) ;	Returns a map which contains only those arguments that the superclass understands.
@ override public void inform ( resourceloader loader ) throws ioexception { super . inform ( new jdbcresourceloader ( loader , reader , standardcharsets . utf_8 ) ) ; }	Load words from jdbc.
protected final void checkdatasource ( ) {	Check if the datasource is able to provide connections.
@ nonnull public static < t > list < t > listof ( class < t > clazz ) { assertisnotparameterized ( clazz , msg ( str_ ) ) ; return io . vavr . collection . list . ofall ( any . listof ( clazz ) ) ; }	todo add generics checks.
@ suppresswarnings ( str_ ) public boolean connectjdbconwithurlanddriverandusernameandpassword ( string databaseid , string url , string driverclassname , string username , string password ) throws reflectiveoperationexception { simpledriverdatasource datasource = new simpledriverdatasource ( ) ; datasource . seturl ( url ) ; datasource . setdriverclass ( ( class < driver > ) class . forname ( driverclassname ) ) ; datasource . setusername ( username ) ; datasource . setpassword ( password ) ; this . templatemap . put ( databaseid , new jdbctemplate ( datasource ) ) ; return bool_ ; }	Registers a database to further execute SQL commands | connect jdbc on | database | with url | url | and driver | driver | and username | username | and | password | .
public boolean runinthesql ( string database , final string sql ) { getdatabasejdbctemplate ( database ) . update ( sql ) ; return bool_ ; }	Simply runs a SQL command, used for udpates, inserts which the result doesn't matter. | run in | database | the sql | sql | .
public string queryinwithsql ( string database , string sql ) { jdbctemplate template = getdatabasejdbctemplate ( database ) ; if ( sql != null && ! sql . trim ( ) . touppercase ( ) . startswith ( jdbcfixture . select_command_prefix ) ) { return objects . tostring ( template . update ( sql ) ) ; } list < string > results = template . queryforlist ( sql , string . class ) ; if ( results == null || results . isempty ( ) ) { return null ; } return results . get ( num_ ) ; }	Used generally when the result is assigned to a variable | $variable= | query in | database | with sql | sql | .
public query < t > byexample ( t obj ) { if ( obj != null ) { return dao . gettablehelper ( ) . buildfilter ( this , obj ) ; } return this ; }	Executes a query which returns all rows in the entity tablethat match the fields of the example object having values otherthan the defaults.Calling method MUST close the {.
protected void onupgrade ( final sqlitedatabase db , final int oldversion , final int newversion ) { db . execsql ( upgradesql ( oldversion , newversion ) ) ; }	Upgrades the table that represents the associated entity.
public boolean backup ( sqlitedatabase db , context ctx , string suffix ) { try { new csvtablewriter ( this ) . dumptocsv ( ctx , db , suffix ) ; } catch ( sqlexception e ) { if ( e . getmessage ( ) . contains ( str_ ) ) { log . w ( tag , str_ + this . gettablename ( ) + str_ ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return bool_ ; } return bool_ ; }	Backs up the current table to a CSV file.
public void restore ( sqlitedatabase db , context ctx , string suffix ) { new csvtablereader ( this ) . importfromcsv ( ctx , db , suffix ) ; }	Restores a table from a text file.
public void setemptytext ( charsequence emptytext ) { if ( mlistview != null ) { view emptyview = mlistview . getemptyview ( ) ; if ( emptytext instanceof textview ) { ( ( textview ) emptyview ) . settext ( emptytext ) ; } } }	The default content for this Activity has a TextView that is shown whenthe list is empty.
public int dumptocsv ( context ctx , sqlitedatabase db , string suffix ) throws filenotfoundexception { int numrowswritten = num_ ; cursor c ; string filename = getcsvfilename ( db . getpath ( ) , db . getversion ( ) , suffix ) ; c = db . query ( th . gettablename ( ) , null , null , null , null , null , null ) ; fileoutputstream fos ; fos = ctx . openfileoutput ( filename , num_ ) ; printwriter printwriter = new printwriter ( fos ) ; string headerrow = buildheaderrow ( ) ; printwriter . println ( headerrow ) ; for ( boolean hasitem = c . movetofirst ( ) ; hasitem ; hasitem = c . movetonext ( ) ) { string csv = buildcsvrow ( c ) ; printwriter . println ( csv ) ; numrowswritten ++ ; } printwriter . flush ( ) ; printwriter . close ( ) ; return numrowswritten ; }	Dumps a database table to a CSV file in the default location.Returns the number of rows written to the file.
public static string unescapecsv ( string str ) { if ( str == null ) return null ; if ( ! ( str . charat ( num_ ) == quote && str . charat ( str . length ( ) - num_ ) == quote ) ) return str ; string quoteless = str . substring ( num_ , str . length ( ) - num_ ) ; return quoteless . replace ( quote_str + quote_str , quote_str ) ; }	Removes enclosing quotes and unescapes double quotes.
public static list < string > getvalues ( string csvrow ) { list < string > values = new arraylist < string > ( ) ; stringreader in = new stringreader ( csvrow ) ; string value ; try { value = nextvalue ( in ) ; while ( bool_ ) { values . add ( value ) ; value = nextvalue ( in ) ; } } catch ( ioexception e ) {	Returns values from a CSV String.
public static map < string , string > getasmap ( string csvpairs ) { map < string , string > map = new hashmap < string , string > ( ) ; string [ ] pairs = csvpairs . split ( str_ ) ; for ( string pair : pairs ) { string [ ] split = pair . split ( str_ ) ; map . put ( split [ num_ ] , split [ num_ ] ) ; } return map ; }	Parses a CSV row containing name=value pairs.
public static string maptocsv ( map < string , string > map ) { stringbuilder sb = new stringbuilder ( ) ; for ( string key : map . keyset ( ) ) { sb . append ( str_ ) ; string val = map . get ( key ) ; sb . append ( key + str_ + val ) ; } return sb . tostring ( ) . substring ( num_ ) ; }	Returns a String containing a comma-separated listof name=value pairs from a map.
public static string join ( final list < string > list ) {	Joins items of a text list, separating items by comma.
public static string join ( final string [ ] list ) {	Joins items of a text array, separating items by comma.
public static databasemodel readfromindex ( bufferedreader reader , processorlogger logger ) throws ioexception { string dbinfo = reader . readline ( ) ; logger . info ( dbinfo ) ; map < string , string > props = csvutils . getasmap ( dbinfo ) ; string dbname = props . get ( str_ ) ; int dbversion = integer . parseint ( props . get ( str_ ) ) ; string helperclass = props . get ( str_ ) ; databasemodel dbmodel = new databasemodel ( dbname , dbversion , helperclass ) ;	Populate the model of a database and its associated tables froma file in support of incremental compilation.
public void writetoindex ( printwriter out ) { out . println ( stormenvironment . begin_database ) ; map < string , string > dbmap = new hashmap < string , string > ( ) ; dbmap . put ( str_ , this . getdbname ( ) ) ; dbmap . put ( str_ , string . valueof ( this . getdbversion ( ) ) ) ; dbmap . put ( str_ , this . getqualifiedclassname ( ) ) ; string dbinfo = csvutils . maptocsv ( dbmap ) ; out . println ( dbinfo ) ;	Write the database info and associated tables to a filein support of incremental compilation.
private void inspectid ( ) { if ( entitymodel . getidfield ( ) == null ) {	Verifies that the entity has exactly one id field of type long.
private static basedaomodel getbasedaoclass ( entity entity ) { string qualifiedname = sqlitedao . class . getname ( ) ; typemirror typemirror = getbasedaotypemirror ( entity ) ; if ( typemirror != null ) qualifiedname = typemirror . tostring ( ) ; return new basedaomodel ( qualifiedname ) ; }	Builds a BaseDaoModel from the class passed as attribute baseDaoClass of the annotation Entity.
public string getbindtype ( ) { string bindtype = getconverter ( ) . getbindtype ( ) . name ( ) ; return bindtype . charat ( num_ ) + bindtype . tolowercase ( ) . substring ( num_ ) ; }	Morph bind type like INT ==> Int so it can be used in a Cursor getXxxmethod name.
public int importfromcsv ( context ctx , sqlitedatabase db , string suffix ) { string filename = getcsvfilename ( db . getpath ( ) , db . getversion ( ) , suffix ) ; fileinputstream fileinputstream ; try { fileinputstream = ctx . openfileinput ( filename ) ; return importfromcsv ( db , fileinputstream ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return - num_ ; } }	Attempts to import a database table from a CSV file in the defaultlocation.
public boolean backupalltablestocsv ( context ctx , sqlitedatabase db , string suffix ) { boolean allsucceeded = bool_ ; for ( tablehelper table : gettablehelpers ( ) ) { allsucceeded &= table . backup ( db , ctx , suffix ) ; } return allsucceeded ; }	Backup all tables to CSV files, one per table.
public void restorealltablesfromcsv ( context ctx , sqlitedatabase db , string suffix ) { for ( tablehelper table : gettablehelpers ( ) ) { table . restore ( db , ctx , suffix ) ; } }	Restore all tables from CSV files, one per table.
void writeindex ( filer filer ) { standardlocation location = standardlocation . source_output ; fileobject indexfile ; try { indexfile = filer . createresource ( location , str_ , env_file ) ; outputstream fos = indexfile . openoutputstream ( ) ; printwriter out = new printwriter ( fos ) ;	Write the current model state to a file in support of incrementalcompilation.
public query createquery ( final entitymanager manager ) { if ( manager == null ) { throw new nullpointerexception ( str_ ) ; } final query query = manager . createquery ( render ( ) ) ; for ( parameter < ? > parameter : parameters ) { parameter . apply ( query ) ; } return query ; }	Returns a JPA Query with all previously specified parameters added.
public < t > typedquery < t > createquery ( final entitymanager manager , class < t > type ) { if ( manager == null ) { throw new nullpointerexception ( str_ ) ; } typedquery < t > result = manager . createquery ( render ( ) , type ) ; for ( parameter < ? > parameter : parameters ) { parameter . apply ( result ) ; } return result ; }	Returns a JPA TypedQuery with all previously specified parameters added.
public string render ( ) { stringbuilder query = new stringbuilder ( ) ; if ( ! select . isempty ( ) ) { query . append ( str_ ) ; query . append ( stringutils . join ( select . items ) ) ; } if ( ! deletefrom . isempty ( ) ) { query . append ( str_ ) ; query . append ( deletefrom . item ) ; } if ( ! update . isempty ( ) ) { query . append ( str_ ) ; query . append ( update . item ) ; if ( ! set . isempty ( ) ) { query . append ( str_ ) ; query . append ( stringutils . join ( set . items ) ) ; } } if ( ! from . isempty ( ) ) { query . append ( str_ ) ; query . append ( stringutils . join ( from . items ) ) ; } if ( ! where . isempty ( ) ) { query . append ( str_ ) ; query . append ( where . render ( ) ) ; } if ( ! group . isempty ( ) ) { query . append ( str_ ) ; query . append ( stringutils . join ( group . items ) ) ; } if ( order . isempty ( ) == bool_ ) { query . append ( str_ ) ; query . append ( stringutils . join ( order . items ) ) ; } return query . tostring ( ) ; }	Renders this object as JPQL query string.
public int delete ( long id ) { if ( id != null ) { return getwritabledb ( ) . delete ( th . gettablename ( ) , th . getidcol ( ) + str_ , new string [ ] { id . tostring ( ) } ) ; } return num_ ; }	Deletes a single row by ID.
public long save ( t obj ) { if ( th . getid ( obj ) == num_ ) { return insert ( obj ) ; } long updated = update ( obj ) ; if ( updated == num_ ) { return num_ ; } return - num_ ; }	Insert or update.
public long update ( t obj ) { contentvalues cv = th . geteditablevalues ( obj ) ; long id = th . getid ( obj ) ; int numrowsupdated = getwritabledb ( ) . update ( th . gettablename ( ) , cv , th . getidcol ( ) + str_ , new string [ ] { id . tostring ( ) } ) ; return numrowsupdated ; }	Update all columns for the row having the ID matchingthe provided entity's ID.
public < v extends object > whereitems notin ( final string expression , final v ... array ) { items . add ( new wherein ( builder ( ) , expression , bool_ , array ) ) ; return this ; }	Adds a "NOT IN" predicate.
public querybuilder subquery ( final string lhspredicate ) { final wheresubquery subquery = new wheresubquery ( builder ( ) , lhspredicate ) ; items . add ( subquery ) ; return subquery . getquerybuilder ( ) ; }	Adds a sub-query predicate.
stack255 nextactivestack ( ) { activestack = ( activestack + num_ ) % stacks . size ( ) ; return ( stack255 ) stacks . get ( activestack ) ; }	Makes the next intentions stack active using a round robin scheme.
stack255 getemptyintentionstack ( ) {	Returns an empty intentions stack.Creates a new intentions stack and adds it to the list of stacks if needed.
public void add ( plan plan , set < belief > planbindings ) { if ( plan == null ) { return ; }	Add the set of bindings for a given plan to this store.
public plan selectplan ( planselectionpolicy policy ) { plan plan = null ; int index = num_ ; switch ( policy ) { case first : case last : plan [ ] plans = bindings . keyset ( ) . toarray ( new plan [ num_ ] ) ; plan = ( policy == planselectionpolicy . first ) ? plans [ num_ ] : plans [ plans . length - num_ ] ; index = ( policy == planselectionpolicy . first ) ? num_ : plans . length - num_ ; setplanvariables ( plan . getagent ( ) , plan , bindings . get ( plan ) , index ) ; break ; case random : plan = selectplanatrandom ( ) ; break ; default :	Selects a plan instance from the set of plan bindings, using the given policy.
private plan selectplanatrandom ( ) { plan plan = null ; set < belief > vars = null ; int index = rand . nextint ( size ( ) ) ; int idx = num_ ; boolean bindingsexist = bool_ ; for ( plan p : bindings . keyset ( ) ) { vars = bindings . get ( p ) ; bindingsexist = ( vars != null && ! vars . isempty ( ) ) ; idx += bindingsexist ? vars . size ( ) : num_ ; if ( idx > index ) { plan = p ; if ( bindingsexist ) { index = index - ( idx - vars . size ( ) ) ; setplanvariables ( plan . getagent ( ) , plan , vars , index ) ; } break ; } } return plan ; }	Selects a plan instance at random from the set of plan bindings.
private final void setplanvariables ( agent agent , plan planinstance , set < belief > results , int choice ) { if ( agent == null || planinstance == null ) { return ; } belief belief = getresultatindex ( results , choice ) ; if ( belief == null ) { return ; } object [ ] tuple = belief . gettuple ( ) ; if ( tuple == null ) { return ; } int index = num_ ; hashmap < string , object > vars = new hashmap < string , object > ( ) ; for ( object o : belief . gettuple ( ) ) { try { string fieldname = abeliefstore . getfieldname ( agent . getid ( ) , belief . getbeliefset ( ) , index ) ; vars . put ( fieldname , o ) ; } catch ( beliefbaseexception e ) { log . error ( str_ + agent . getid ( ) + str_ + e . getmessage ( ) ) ; } index ++ ; } planinstance . setplanvariables ( vars ) ; }	Sets the plan instance variables using the given results set.
private belief getresultatindex ( set < belief > results , int index ) { belief belief = null ; if ( ! ( results == null || index < num_ || index >= results . size ( ) ) ) { int idx = num_ ; for ( belief b : results ) { if ( idx == index ) { belief = b ; break ; } idx ++ ; } } return belief ; }	Gets the result at the given index from the results set.
public byte [ ] getparents ( ) { if ( parents == null ) { return null ; } byte [ ] arr = new byte [ parents . length ] ; system . arraycopy ( parents , num_ , arr , num_ , arr . length ) ; return arr ; }	Gets the parents of this object in the Goal-Plan tree.
public byte [ ] getchildren ( ) { if ( children == null ) { return null ; } byte [ ] arr = new byte [ children . length ] ; system . arraycopy ( children , num_ , arr , num_ , arr . length ) ; return arr ; }	Gets all the children of this object in the Goal-Plan tree.
public static byte [ ] grow ( byte [ ] bytes , int increment ) { if ( bytes == null ) { return new byte [ num_ ] ; } byte [ ] temp = new byte [ bytes . length + increment ] ; system . arraycopy ( bytes , num_ , temp , num_ , bytes . length ) ; return temp ; }	Grows the given array by the given size.
public static logger createlogger ( string name , level level , string file ) { loggercontext lc = ( loggercontext ) loggerfactory . getiloggerfactory ( ) ; patternlayoutencoder ple = new patternlayoutencoder ( ) ; ple . setpattern ( str_ ) ; ple . setcontext ( lc ) ; ple . start ( ) ; fileappender < iloggingevent > fileappender = new fileappender < iloggingevent > ( ) ; fileappender . setfile ( file ) ; fileappender . setencoder ( ple ) ; fileappender . setappend ( bool_ ) ; fileappender . setcontext ( lc ) ; fileappender . start ( ) ; logger = ( logger ) loggerfactory . getlogger ( name ) ; logger . detachandstopallappenders ( ) ;	Creates a new logger.
public void step ( ) { if ( body == null || body . length == num_ || index < num_ || index >= body . length ) { return ; } body [ index ++ ] . step ( ) ; }	Performs a single step of this plan, i.e., progresses this intention.
public void setgoals ( byte [ ] arr ) { if ( arr == null ) { goals = null ; return ; } goals = new byte [ arr . length ] ; system . arraycopy ( arr , num_ , goals , num_ , goals . length ) ; }	Sets the list of goals for this agent.
static void pauseforuserinput ( ) { system . out . println ( str_ ) ; scanner in = new scanner ( system . in ) ; in . nextline ( ) ; in . close ( ) ; }	Waits for user to press a key before continuing. Useful for connecting to a profiler.
public static void initintentionselectionpools ( int nagents , int ncores ) { main . poolsize = ( nagents > ncores ) ? ( nagents / ncores ) : num_ ; main . npools = ( nagents > ncores ) ? ncores : nagents ; }	Initialises the intention selection pools.
static void initintentionselectionthreads ( config config ) { int ncores = config . getnumthreads ( ) ; main . intentionselectors = new intentionselector [ ncores ] ; for ( int i = num_ ; i < main . npools ; i ++ ) { main . intentionselectors [ i ] = new intentionselector ( i , config . getrandomseed ( ) ) ; } }	Starts the intention selection threads that each handle a pool of agents.
static void startintentionselectionthreads ( ) { for ( int i = num_ ; i < main . npools ; i ++ ) { thread thread = new thread ( main . intentionselectors [ i ] ) ; thread . setname ( str_ + i ) ; thread . start ( ) ;	Starts the intention selection threads.
static void shutdownintentionselectionthreads ( ) { for ( int i = num_ ; i < main . npools ; i ++ ) { main . intentionselectors [ i ] . shutdown ( ) ; } }	Stops the intention selection threads.
public static void registerextension ( jillextension extension ) { if ( extension != null ) { globalstate . eventhandlers . add ( extension ) ; main . logger . info ( str_ + extension ) ; } else { main . logger . warn ( str_ ) ; } }	Registers a new Jill extension.
public static void reset ( ) { agenttypes = new aobjectcatalog ( str_ , num_ , num_ ) ; goaltypes = new aobjectcatalog ( str_ , num_ , num_ ) ; plantypes = new aobjectcatalog ( str_ , num_ , num_ ) ; agents = null ; beliefbase = null ; eventhandlers = new hashset < jillextension > ( ) ; }	Resets the global state.
public static boolean loadagent ( string classname , int num , aobjectcatalog agents ) {	Creates a given number of agents of a given Class, and adds the newly created agents to thegiven store.
private static boolean processplansforgoal ( goaltype gtype , string [ ] plans ) { for ( int j = num_ ; j < plans . length ; j ++ ) {	Loads the given plan classes and sets up parent-child links with the given goal type.
private static void createagentsincatalog ( aobjectcatalog agents , agenttype atype , class < ? > aclass , int num ) { int added = num_ ; try { for ( int i = num_ ; i < num ; i ++ ) {	Creates the specified number of agent instances of the given type and adds them to the catalog.
private static class < ? > loadclass ( string classname , class < ? > classtype ) { class < ? > aclass = null ; try { aclass = class . forname ( classname ) ; } catch ( classnotfoundexception e ) { logger . error ( str_ + classname , e ) ; return null ; } if ( ! classtype . isassignablefrom ( aclass ) ) { logger . error ( str_ + classname + str_ + classtype . getname ( ) ) ; return null ; } logger . info ( str_ + classname + str_ + classtype . getname ( ) ) ; return aclass ; }	Loads the class of given name and type.
public static jillextension loadextension ( string classname ) { jillextension extension = null ; class < ? > eclass ; try {	Loads a Jill extension.
public static boolean isnameequal ( aobject obj1 , aobject obj2 ) {	Checks if two objects have the same name.
public static string usage ( ) { return globalconstant . app_header + str_ + str_ + main . class . getname ( ) + str_ + str_ + str_ + str_ + str_ + str_ + str_ + str_ + globalconstant . exit_on_idle + str_ + str_ + str_ + str_ + globalconstant . plan_selection_policy + str_ + str_ + str_ + globalconstant . plan_instances_limit + str_ ; }	Returns a usage string for the Jill command line arguments.
public static void parse ( string [ ] args ) { for ( int i = num_ ; args != null && i < args . length ; i ++ ) {	Parses the given command line arguments.
private static void parseargumentwithoption ( string arg , string opt ) { switch ( arg ) { case str_ : config = loadconfigfromstring ( opt ) ; break ; case str_ : config = loadconfigfromfile ( opt ) ; break ; case str_ : globalconstant . exit_on_idle = boolean . parseboolean ( opt ) ; break ; case str_ : try { globalconstant . plan_selection_policy = globalconstant . planselectionpolicy . valueof ( opt ) ; } catch ( illegalargumentexception e ) { abort ( str_ + opt + str_ ) ; } break ; case str_ : try { globalconstant . plan_instances_limit = integer . parseint ( opt ) ; } catch ( numberformatexception e ) { abort ( str_ + opt + str_ ) ; } break ; default :	Parses the given command line argument and associated option.
public static void doeval ( beliefbase bb , int agentid , string query ) throws beliefbaseexception { final long t0 = system . currenttimemillis ( ) ; bb . eval ( agentid , query ) ; final long t1 = system . currenttimemillis ( ) ; log . info ( str_ + agentid + str_ + query + str_ + log . formattedduration ( t0 , t1 ) ) ; }	Evaluates the given query on the given belief base for the agent.
public aobject get ( int index ) { if ( index >= num_ && index < objects . length ) { return objects [ index ] ; } return null ; }	Gets the object at the given index of the catalog.
public aobject find ( string name ) { for ( int i = num_ ; i < nextid ; i ++ ) { if ( objects [ i ] . getname ( ) . equals ( name ) ) { return objects [ i ] ; } } return null ; }	Find an object by name.
public void push ( aobject obj ) { if ( obj == null || obj . getid ( ) != globalconstant . nullid ) { return ; }	Pushes a new object to the top of the catalog.
public object get ( int idx ) { int index = idx & num_ ; if ( isempty ( ) ) {	Gets the object at the given index in the catalog.
public boolean push ( object obj ) {	Pushes an object on to the top of the stack.
public object pop ( ) { if ( isempty ( ) ) { return null ; } size -- ; object obj = objects [ size ] ; objects [ size ] = null ; return obj ; }	Pops the Object at the top of the stack.
public static string gettype ( object obj ) { if ( obj == null ) { return null ; } string type = null ; if ( obj instanceof string || obj instanceof integer || obj instanceof double || obj instanceof boolean ) { type = obj . getclass ( ) . getname ( ) ; } return type ; }	Gets the type of the given object.
private static boolean match ( belief belief , aquery query ) { assert ( belief != null ) ; assert ( query != null ) ; if ( belief . getbeliefset ( ) != query . getbeliefset ( ) ) { return bool_ ; } switch ( query . getop ( ) ) { case eq : object lhs = belief . gettuple ( ) [ query . getfield ( ) ] ; object rhs = query . getvalue ( ) ;	Checks if the given query run on the given belief returns a match.
public static void main ( string [ ] args ) throws beliefbaseexception { beliefbase bb = new abeliefstore ( num_ , num_ ) ; bb . eval ( num_ , str_ ) ; console console = system . console ( ) ; if ( console == null ) { system . err . println ( str_ ) ; system . exit ( num_ ) ; } while ( bool_ ) { pattern pattern = pattern . compile ( console . readline ( str_ ) ) ; matcher matcher = pattern . matcher ( console . readline ( str_ ) ) ; boolean found = bool_ ; while ( matcher . find ( ) ) { console . format ( str_ + str_ + str_ , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; found = bool_ ; } if ( ! found ) { console . format ( str_ ) ; } } }	Sample program to test pattern matching.
public static byte [ ] tobytes ( string str ) { if ( str == null ) { return new byte [ num_ ] ; } byte [ ] val = null ; try { val = str . getbytes ( charset ) ; } catch ( unsupportedencodingexception e ) {	Encodes the String str into a sequence of bytes using the character set specified in CHARSET,storing the result into a new byte array.
private void post ( stack255 stack , goal goal ) { synchronized ( stack ) { logger . debug ( str_ , log . logprefix ( getid ( ) ) , goal . getclass ( ) . getsimplename ( ) ) ; stack . push ( goal ) ; main . setagentidle ( getid ( ) , bool_ ) ; } main . flagmessageto ( main . poolid ( getid ( ) ) ) ; }	Push the given goal to the given stack.
public boolean send ( int id , goal msg ) { aobject obj = agents . get ( id ) ; if ( obj == null ) { logger . warn ( str_ , log . logprefix ( getid ( ) ) , id ) ; return bool_ ; } logger . debug ( str_ , log . logprefix ( getid ( ) ) , msg . getclass ( ) . getsimplename ( ) , id ) ; ( ( agent ) obj ) . post ( msg ) ; return bool_ ; }	Send a message to an agent.
public boolean send ( string name , goal msg ) { aobject obj = agents . find ( name ) ; if ( obj == null ) { logger . warn ( str_ , log . logprefix ( getid ( ) ) , name ) ; return bool_ ; } ( ( agent ) obj ) . post ( msg ) ; return bool_ ; }	Send a message to this agent.
public byte [ ] getgoals ( ) { byte [ ] arr = new byte [ goals . length ] ; system . arraycopy ( goals , num_ , arr , num_ , arr . length ) ; return arr ; }	Returns this agent's top level goals.
public void createbeliefset ( string name , beliefsetfield [ ] fields ) throws beliefbaseexception { beliefbase . createbeliefset ( getid ( ) , name , fields ) ; }	Creates a new belief set with the given fields.
public void addbelief ( string beliefsetname , object ... tuple ) throws beliefbaseexception { beliefbase . addbelief ( getid ( ) , beliefsetname , tuple ) ; }	Adds a new belief to the specified belief set.
public boolean eval ( string query ) throws beliefbaseexception { boolean result = beliefbase . eval ( getid ( ) , query ) ; lastresult = ( result ) ? beliefbase . query ( getid ( ) , query ) : new hashset < belief > ( ) ; return result ; }	Evaluates the given query against this agent's belief base.
public void suspend ( boolean val ) { main . setagentidle ( getid ( ) , val ) ; main . flagmessageto ( main . poolid ( getid ( ) ) ) ; }	Forces this agent to enter an idle state irrespective of whether it has any active intentionsor not.
public beliefsetfield getfieldbyname ( string name ) { beliefsetfield field = null ; for ( int i = num_ ; i < fields . length ; i ++ ) { if ( name . equals ( fields [ i ] . getname ( ) ) ) { field = fields [ i ] ; break ; } } return field ; }	Gets the field of this belief set that has the given name.
private void registerneighbours ( random rand , int count ) throws beliefbaseexception { int size = ( count < num_ ) ? num_ : count ; for ( int i = num_ ; i < size ; i ++ ) { boolean male = ( rand . nextdouble ( ) < num_ ) ? bool_ : bool_ ; this . addbelief ( beliefset , buildname ( male ) , male ? str_ : str_ ) ; } }	Helper function to add beliefs about neighbours.
private static string buildname ( boolean male ) { stringbuilder name = new stringbuilder ( ) ; name . append ( male ? males [ rand . nextint ( males . length ) ] : females [ rand . nextint ( females . length ) ] ) . append ( str_ ) . append ( middle [ rand . nextint ( middle . length ) ] ) . append ( str_ ) . append ( surnames [ rand . nextint ( surnames . length ) ] ) ; return name . tostring ( ) ; }	Builds a new name.
public void run ( ) { set < integer > toremove = new hashset < integer > ( ) ; do { boolean idle = bool_ ;	Runs this intentions selction thread.
private boolean isstackvalid ( agent agent , stack255 agentexecutionstack ) { if ( agentexecutionstack == null ) { return bool_ ; } final int essize = agentexecutionstack . size ( ) ; logger . trace ( str_ , log . logprefix ( agent . getid ( ) ) , essize ) ; if ( essize == num_ ) { return bool_ ; } if ( essize >= num_ ) { logger . error ( str_ , log . logprefix ( agent . getid ( ) ) ) ; return bool_ ; } return bool_ ; }	Checks if this agent's execution stack is valid.
private void removefinishedagents ( set < integer > toremove ) { if ( ! toremove . isempty ( ) ) { for ( int i : toremove ) { activeagents . remove ( i ) ; } toremove . clear ( ) ; } }	Removes the given list of agents from the list of active agents.
private boolean managegoal ( int agentindex , agent agent , stack255 agentexecutionstack , goal node ) {	Manages the goal at the top of the execution stack of an agent.
public void shutdown ( ) { synchronized ( lock ) { logger . debug ( str_ , poolid ) ; shutdown = bool_ ; hasmessage = bool_ ; lock . notify ( ) ;	Terminates this intention selector thread.
public void setagentidle ( int agentid , boolean idle ) {	and this thread is still iterating over activeagents.
public boolean move ( int pina , int pinb ) {	Move a disc from pin A to pin B.
public static boolean init ( config config ) {	Initialises the Jill engine.
public static void waituntilidle ( ) {	Blocks until all agents have finished executing plans and have gone idle.
public static void finish ( ) {	Termiantes the Jill engine.
public static boolean arepoolsidle ( ) { boolean idle = bool_ ; for ( int i = num_ ; i < npools ; i ++ ) { idle &= ( intentionselectors [ i ] == null ) || intentionselectors [ i ] . isidle ( ) ; } return idle ; }	Checks if the system is idle, i.e., all the agents pools are idle.
public static int poolid ( int agentid ) { int poolid = agentid / poolsize ; if ( poolid + num_ > npools ) { poolid = npools - num_ ; } return poolid ; }	Gets the ID of the intention selection pool to which the given agent belongs.
@ suppresswarnings ( str_ ) public < e > expression < e > pickexpression ( ) { preconditions . checkstate ( this . expression != null , str_ ) ; expression < e > result = ( expression < e > ) this . expression ; expression = null ; return result ; }	Returns the expression currently active in the building context.
public < e > void setexpression ( expression < e > expression ) { preconditions . checkstate ( this . expression == null , str_ ) ; this . expression = expression ; }	Sets the expression currently active in the building context.
public static expression < ? > join ( string attribute , from < ? , ? > from ) { expression < ? > path ; try { string [ ] properties = attribute . split ( str_ ) ; if ( properties . length > num_ ) { path = joinrecursively ( properties , findorcreatejoin ( properties [ num_ ] , from ) , num_ ) . get ( properties [ properties . length - num_ ] ) ; } else { path = from . get ( properties [ num_ ] ) ; } } catch ( illegalargumentexception e ) { throw seedexception . wrap ( e , jpaerrorcode . unable_to_create_jpa_join_for_specification ) . put ( str_ , attribute ) ; } return path ; }	Create a new join or find an existing join on the specified attribute.
private static join < ? , ? > joinrecursively ( string [ ] properties , join < ? , ? > join , int index ) { if ( index < properties . length - num_ ) { return joinrecursively ( properties , findorcreatejoin ( properties [ index ] , join ) , index + num_ ) ; } else { return join ; } }	Join recursively using the split property path.
private static join < ? , ? > findorcreatejoin ( string property , from < ? , ? > from ) { for ( join < ? , ? > rootjoin : from . getjoins ( ) ) { if ( rootjoin . getattribute ( ) . getname ( ) . equals ( property ) ) { return rootjoin ; } } return from . join ( property ) ; }	Find an existing join for the property or create a new join.
public boolean isendreached ( ) { if ( to == null || from == null ) {	Indicates whether the response reaches the end of the elements availableon the server.
private static uploadstream getuploadstream ( httpservletrequest httprequest , type [ ] formalparameters ) throws ioexception { formiterator form = new formiteratorimpl ( httprequest ) ; if ( ! form . hasnext ( ) ) { throw new illegalargumentexception ( str_ ) ; } part part = form . next ( ) ; if ( ! ( part instanceof uploadstream ) ) { throw new illegalargumentexception ( str_ , part . getname ( ) ) ; } return ( uploadstream ) part ; }	Get upload stream from given HTTP request.
@ override protected void handlerequest ( requestcontext context ) throws ioexception { httpservletrequest httprequest = context . getrequest ( ) ; httpservletresponse httpresponse = context . getresponse ( ) ; argumentsreader argumentsreader = null ; object value = null ; managedmethodspi method = null ; try { method = restmethods . get ( key ( httprequest . getpathinfo ( ) ) ) ; if ( method == null ) { throw new nosuchmethodexception ( ) ; } type [ ] formalparameters = method . getparametertypes ( ) ; argumentsreader = argumentsreaderfactory . getargumentsreader ( httprequest , formalparameters ) ; object [ ] arguments = argumentsreader . read ( httprequest , formalparameters ) ; object instance = container . getinstance ( method . getdeclaringclass ( ) ) ; value = method . invoke ( instance , arguments ) ; } catch ( authorizationexception e ) { sendunauthorized ( context ) ; return ; } catch ( nosuchmethodexception e ) { sendnotfound ( context , e ) ; return ; } catch ( illegalargumentexception e ) {	Handle request for a REST resource.
public boolean hasparameter ( string name , string value ) { params . notnullorempty ( name , str_ ) ; params . notnullorempty ( value , str_ ) ; return value . equals ( parameters . get ( name ) ) ; }	Test if content type has a parameter with requested name and value.
public string getparameter ( string name ) { params . notnullorempty ( name , str_ ) ; return parameters . get ( name ) ; }	Get parameter value or null if parameter does not exist.
private static map < string , string > parseparameters ( string expression ) {	Parse content type parameters.
@ override public void config ( config config ) throws exception { log . trace ( str_ ) ; log . debug ( str_ , transactionmanager . getclass ( ) ) ; transactionmanager . config ( config ) ; }	Configure underlying transaction manager.
protected final generatedfile gettargetfile ( final string artifactname , final string filename , final string loginfo ) { final folder folder = getgeneratorconfig ( ) . findtargetfolder ( artifactname ) ; final file dir = folder . getcanonicaldir ( ) ; final file file = new file ( dir , filename ) ;	Returns the target file for a given artifact type and filename.
protected final void write ( @ notnull final generatedartifact artifact ) throws generateexception { contract . requireargnotnull ( str_ , artifact ) ; final generatedfile genfile = gettargetfile ( artifact . getname ( ) , artifact . getpathandname ( ) , null ) ; if ( genfile . isskip ( ) ) { log . debug ( str_ , genfile , artifact ) ; } else { log . debug ( str_ , genfile , artifact ) ; try { final outputstream out = new bufferedoutputstream ( new fileoutputstream ( genfile . gettmpfile ( ) ) ) ; try { out . write ( artifact . getdata ( ) ) ; } finally { out . close ( ) ; } genfile . persist ( ) ; } catch ( final ioexception ex ) { throw new generateexception ( str_ + artifact + str_ + artifact . getpathandname ( ) + str_ , ex ) ; } } }	Writes a generated artifact to a file.
@ override public void postprocessinstance ( managedclassspi managedclass , object instance ) { config config = managedclass . getconfig ( ) ; if ( config == null ) { return ; } list < config > fields = config . findchildren ( str_ ) ; if ( ! fields . isempty ( ) && ! instancetype . pojo . equals ( managedclass . getinstancetype ( ) ) ) { throw new bugerror ( str_ , instancetype . pojo ) ; } for ( config field : fields ) { classes . setfieldvalue ( instance , field . getattribute ( str_ ) , field . getattribute ( str_ ) ) ; } }	Initialize instance fields from managed class configuration object.
private static constructor < ? > getdeclaredconstructor ( class < ? > implementationclass ) { if ( implementationclass == null ) { return null ; } constructor < ? > [ ] declaredconstructors = ( constructor < ? > [ ] ) implementationclass . getdeclaredconstructors ( ) ; if ( declaredconstructors . length == num_ ) { throw new bugerror ( str_ , implementationclass ) ; } constructor < ? > constructor = null ; for ( constructor < ? > declaredconstructor : declaredconstructors ) {	Get implementation class constructor.
private string buildstringrepresentation ( config descriptor ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( descriptor . getname ( ) ) ; builder . append ( str_ ) ; if ( implementationclass != null ) { builder . append ( implementationclass . getname ( ) ) ; builder . append ( str_ ) ; } for ( class < ? > interfaceclass : interfaceclasses ) { builder . append ( interfaceclass . getname ( ) ) ; builder . append ( str_ ) ; } builder . append ( instancetype ) ; builder . append ( str_ ) ; builder . append ( instancescope ) ; builder . append ( str_ ) ; builder . append ( remotelyaccessible ? str_ : str_ ) ; if ( implementationurl != null ) { builder . append ( str_ ) ; builder . append ( implementationurl ) ; } return builder . tostring ( ) ; }	Build and return this managed class string representation.
private static method getinterfacemethod ( method method ) { for ( class < ? > interfaceclass : method . getdeclaringclass ( ) . getinterfaces ( ) ) { try { return interfaceclass . getmethod ( method . getname ( ) , method . getparametertypes ( ) ) ; } catch ( nosuchmethodexception unused ) { } } return method ; }	Get Java reflective method from interface.
private static class < ? > type ( field field ) { if ( types . iskindof ( field . gettype ( ) , list . class ) ) {	Return field class or actual type argument if given field is a list.
@ suppresswarnings ( str_ ) protected static object getdependencyvalue ( managedclassspi hostmanagedclass , class < ? > type ) { stack < class < ? > > stacktrace = dependenciesstack . get ( ) ; if ( stacktrace == null ) { stacktrace = new stack < > ( ) ; dependenciesstack . set ( stacktrace ) ; } containerspi container = hostmanagedclass . getcontainer ( ) ; if ( stacktrace . contains ( type ) ) { try {	Get dependency value of requested type.
public final void persist ( ) { if ( persisted ) {	Compares the content of the temporary file with the possibly existing target file.
public final void setdefaultlink ( string rel , string ... hrefs ) { if ( hrefs == null || hrefs . length == num_ ) { defaultlinks . remove ( rel ) ; } else { defaultlinks . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( toset ( ) ) ) ; } }	Registers one or more default links for a specific relation type.
public final void setdefaultlinktemplate ( string rel , string href ) { if ( href == null ) { defaultlinktemplates . remove ( rel ) ; } else { defaultlinktemplates . put ( rel , href ) ; } }	Registers a default link template for a specific relation type.
@ suppresswarnings ( str_ ) private void handlelinks ( httpresponse response ) { map < string , map < uri , string > > links = new hashmap < > ( ) ; map < string , string > linktemplates = new hashmap < > ( ) ; handleheaderlinks ( response , links , linktemplates ) ; httpentity entity = response . getentity ( ) ; if ( entity != null ) { header contenttype = entity . getcontenttype ( ) ; if ( ( contenttype != null ) && contenttype . getvalue ( ) . startswith ( str_ ) ) { try { handlebodylinks ( serializer . readtree ( entity . getcontent ( ) ) , links , linktemplates ) ; } catch ( ioexception ex ) { throw new runtimeexception ( ) ;	Handles links embedded in an HTTP response.
protected void handleheaderlinks ( httpresponse response , map < string , map < uri , string > > links , map < string , string > linktemplates ) { getlinkheaders ( response ) . foreach ( header -> { if ( header . getrel ( ) == null ) { return ; } if ( header . istemplated ( ) ) { linktemplates . put ( header . getrel ( ) , header . gethref ( ) ) ; } else { getoradd ( links , header . getrel ( ) ) . put ( uri . resolve ( header . gethref ( ) ) , header . gettitle ( ) ) ; } } ) ; }	Handles links embedded in HTTP response headers.
protected void handlebodylinks ( jsonnode jsonbody , map < string , map < uri , string > > links , map < string , string > linktemplates ) { if ( jsonbody . getnodetype ( ) != jsonnodetype . object ) { return ; } jsonnode linksnode = jsonbody . get ( str_ ) ; if ( linksnode == null ) { linksnode = jsonbody . get ( str_ ) ; } if ( linksnode == null ) { return ; } linksnode . fields ( ) . foreachremaining ( x -> { string rel = x . getkey ( ) ; map < uri , string > linksforrel = getoradd ( links , rel ) ; switch ( x . getvalue ( ) . getnodetype ( ) ) { case array : x . getvalue ( ) . foreach ( subobj -> { if ( subobj . getnodetype ( ) == jsonnodetype . object ) { parselinkobject ( rel , ( objectnode ) subobj , linksforrel , linktemplates ) ; } } ) ; break ; case object : parselinkobject ( rel , ( objectnode ) x . getvalue ( ) , linksforrel , linktemplates ) ; break ; } } ) ; }	Handles links embedded in JSON response bodies.
private void parselinkobject ( string rel , objectnode obj , map < uri , string > linksforrel , map < string , string > linktemplates ) { jsonnode href = obj . findvalue ( str_ ) ; if ( href == null ) { return ; } jsonnode templated = obj . findvalue ( str_ ) ; if ( templated != null && templated . isboolean ( ) && templated . asboolean ( ) ) { linktemplates . put ( rel , href . astext ( ) ) ; } else { jsonnode title = obj . findvalue ( str_ ) ; linksforrel . put ( uri . resolve ( href . astext ( ) ) , ( title != null && title . getnodetype ( ) == jsonnodetype . string ) ? title . astext ( ) : null ) ; } }	Parses a JSON object for link information.
private static map < uri , string > getoradd ( map < string , map < uri , string > > map , string key ) { map < uri , string > value = map . get ( key ) ; if ( value == null ) { map . put ( key , value = new hashmap < > ( ) ) ; } return value ; }	Returns the element with the specified key from the map.
protected void handlecapabilities ( httpresponse response ) { allowedmethods = unmodifiableset ( stream ( response . getheaders ( str_ ) ) . filter ( x -> x . getname ( ) . equals ( str_ ) ) . flatmap ( x -> stream ( x . getelements ( ) ) ) . map ( x -> x . getname ( ) ) . collect ( toset ( ) ) ) ; }	Handles allowed HTTP methods and other capabilities reported by theserver.
protected optional < boolean > ismethodallowed ( string method ) { if ( allowedmethods . isempty ( ) ) { return optional . empty ( ) ; } return optional . of ( allowedmethods . contains ( method ) ) ; }	Shows whether the server has indicated that a specific HTTP method iscurrently allowed.Uses cached data from last response.
protected void registerinstanceprocessor ( ) { registerinstanceprocessor ( new instancefieldsinjectionprocessor ( ) ) ; registerinstanceprocessor ( new instancefieldsinitializationprocessor ( ) ) ; registerinstanceprocessor ( new configurableinstanceprocessor ( ) ) ; registerinstanceprocessor ( new postconstructinstanceprocessor ( ) ) ; registerinstanceprocessor ( new cronmethodsprocessor ( cronmanager ) ) ; registerinstanceprocessor ( new loggerinstanceprocessor ( ) ) ; }	Register all instance post-processors.
protected void registerinstancefactory ( instancetype instancetype , instancefactory instancefactory ) { log . debug ( str_ , instancefactory . getclass ( ) , instancetype ) ; if ( instancefactories . put ( instancetype , instancefactory ) != null ) { throw new bugerror ( str_ , instancetype ) ; } }	Register instance factory to requested instance type.
protected void registerinstanceprocessor ( instanceprocessor instanceprocessor ) { for ( instanceprocessor existinginstanceprocessoor : instanceprocessors ) { if ( existinginstanceprocessoor . getclass ( ) . equals ( instanceprocessor . getclass ( ) ) ) { throw new bugerror ( str_ , instanceprocessor . getclass ( ) ) ; } } log . debug ( str_ , instanceprocessor . getclass ( ) ) ; instanceprocessors . add ( instanceprocessor ) ; }	Register instance processor. Only a single instance per processor class is allowed.
protected void registerclassprocessor ( classprocessor classprocessor ) { for ( classprocessor existingclassprocessoor : classprocessors ) { if ( existingclassprocessoor . getclass ( ) . equals ( classprocessor . getclass ( ) ) ) { throw new bugerror ( str_ , classprocessor . getclass ( ) ) ; } } log . debug ( str_ , classprocessor . getclass ( ) ) ; classprocessors . add ( classprocessor ) ; }	Register global processors for managed classes.
public final void addargument ( @ notnull final argument argument ) { if ( arguments == null ) { arguments = new arraylist < argument > ( ) ; } arguments . add ( argument ) ; }	Adds an argument to the template.
public final list < targetfile > createtargetfilelist ( ) { if ( tflproducerconfig == null ) { log . info ( str_ , targetfiles . size ( ) ) ; return targetfiles ; } final targetfilelistproducer producer = tflproducerconfig . gettargetfilelistproducer ( ) ; log . info ( str_ , producer . getclass ( ) . getname ( ) ) ; return producer . createtargetfiles ( ) ; }	Returns the list of target files.
public final string toxml ( ) { try { final jaxbhelper helper = new jaxbhelper ( ) ; return helper . write ( this , createjaxbcontext ( ) ) ; } catch ( final marshalobjectexception ex ) { throw new runtimeexception ( ex ) ; } }	Marshals the object to an XML String.
public final void init ( final srcgen4jcontext context , final map < string , string > vars ) { if ( template != null ) { template = utils4j . replacevars ( template , vars ) ; } if ( arguments != null ) { for ( final argument argument : arguments ) { argument . init ( vars ) ; } } if ( targetfiles != null ) { for ( final targetfile targetfile : targetfiles ) { targetfile . init ( vars ) ; } } if ( tflproducerconfig != null ) { tflproducerconfig . init ( context , this , vars ) ; } }	Initializes the model.
public final boolean hasreferenceto ( final file templatedir , final file templatefile ) { final string p1 = utils4j . getcanonicalpath ( new file ( templatedir , template ) ) ; final string p2 = utils4j . getcanonicalpath ( templatefile ) ; return p1 . equals ( p2 ) ; }	Checks if this model has a reference to the given template file.
public static parameterizedtemplatemodel create ( final reader reader ) { try { final jaxbhelper helper = new jaxbhelper ( ) ; final parameterizedtemplatemodel pc = helper . create ( reader , createjaxbcontext ( ) ) ; contract . requirevalid ( pc ) ; return pc ; } catch ( final unmarshalobjectexception ex ) { throw new runtimeexception ( ex ) ; } }	Creates an instance by reading the XML from a reader.
public static parameterizedtemplatemodel create ( final file file ) { try { final jaxbhelper helper = new jaxbhelper ( ) ; final parameterizedtemplatemodel pc = helper . create ( file , createjaxbcontext ( ) ) ; pc . setfile ( file ) ; contract . requirevalid ( pc ) ; return pc ; } catch ( final unmarshalobjectexception ex ) { throw new runtimeexception ( ex ) ; } }	Creates an instance by reading the XML from a file.
void setrequestpath ( string requestpath ) { this . requestpath = requestpath != null ? requestpath : strings . todashcase ( method . getname ( ) ) ; }	Set this method request URI path, that is, the path component by which this method is referred into request URI.
stoppableobservable < tentity > getobservable ( final long startindex , scheduler scheduler ) { return runasync ( scheduler , ( rx . observer < ? super tentity > observer , subscription subscription ) -> { long currentstartindex = startindex ; while ( ! subscription . isunsubscribed ( ) ) { partialresponse < tentity > response ; try { response = ( currentstartindex >= num_ ) ? readrange ( currentstartindex , null ) : readrange ( null , - currentstartindex ) ; } catch ( illegalstateexception ex ) {	Provides an observable stream of elements.
@ suppresswarnings ( str_ ) @ override public < t > t asobject ( string string , class < t > valuetype ) { return ( t ) new instancescope ( string ) ; }	Create a scope instance from its string value.
private void setfield ( field field , string parametername , object instance ) { final object value = context . getproperty ( parametername , field . gettype ( ) ) ; try { field . set ( instance , value ) ; } catch ( exception e ) { throw new bugerror ( e ) ; } }	Initialize field from named context parameter.
public void addcapturetologger ( final appenderattachable logger , final string appendername ) { appender currentappender = logger . getappender ( appendername ) ; appender captureappender = captureappender . newappenderfrom ( currentappender ) ; logger . addappender ( captureappender ) ; }	Adds a new CaptureAppender to an existing logger.
public void remove ( final appenderattachable logger , final string appendername ) { logger . removeappender ( captureappender . getappendernamefor ( appendername ) ) ; }	Removes a CaptureAppender from a logger.
public void clear ( final appenderattachable logger , final string appendername ) { ( ( captureappender ) logger . getappender ( captureappender . getappendernamefor ( appendername ) ) ) . clear ( ) ; }	Deletes all cached log entries.
protected final void parsemodel ( ) { if ( ( fileextensions == null ) || ( fileextensions . size ( ) == num_ ) ) { throw new illegalstateexception ( str_ ) ; }	Parses all model files in the directories and all resources. y.
protected final void resolveproxies ( ) { final list < string > unresolved = new arraylist < string > ( ) ; if ( ! resolvedallproxies ( unresolved , num_ ) ) { log . warn ( str_ , unresolved . size ( ) ) ; for ( final string ref : unresolved ) { log . warn ( str_ , ref ) ; } final iterator < notifier > it = resourceset . getallcontents ( ) ; while ( it . hasnext ( ) ) { final notifier next = it . next ( ) ; if ( next instanceof eobject ) { final eobject obj = ( eobject ) next ; if ( obj . eisproxy ( ) ) { try { it . remove ( ) ; } catch ( final unsupportedoperationexception ex ) { log . error ( str_ + obj , ex ) ; } } } } } }	Tries to resolve all proxies.
private file [ ] getfiles ( final file dir ) { final file [ ] files = dir . listfiles ( new filefilter ( ) { @ override public boolean accept ( final file file ) { final boolean pointfile = file . getname ( ) . startswith ( str_ ) ; final string extension = filenameutils . getextension ( file . getname ( ) ) ; return ( ! pointfile && fileextensions . contains ( extension ) ) || file . isdirectory ( ) ; } } ) ; return files ; }	Returns files that end with java and all directories.
private void parsedir ( final file dir ) { log . debug ( str_ , dir ) ; final file [ ] files = getfiles ( dir ) ; if ( ( files == null ) || ( files . length == num_ ) ) { log . debug ( str_ , dir ) ; } else { for ( final file file : files ) { if ( file . isfile ( ) ) { final resource resource = resourceset . getresource ( uri . createfileuri ( utils4j . getcanonicalpath ( file ) ) , bool_ ) ; final elist < diagnostic > diagnostics = resource . geterrors ( ) ; if ( diagnostics . size ( ) == num_ ) { log . debug ( str_ , file ) ; } else { error = bool_ ; log . error ( str_ , file , diagnostics ) ; } } else { parsedir ( file ) ; } } } }	Parse the directory and it's sub directory.
public boolean ismodelfullyresolved ( ) { boolean resolved = bool_ ; final set < eobject > eobjects = findalleobjects ( resourceset ) ; final iterator < eobject > it = eobjects . iterator ( ) ; while ( it . hasnext ( ) ) { final eobject eobj = it . next ( ) ; if ( eobj instanceof internaleobject ) { final internaleobject iobj = ( internaleobject ) eobj ; for ( final eobject crossref : iobj . ecrossreferences ( ) ) { if ( crossref . eisproxy ( ) ) { log . error ( str_ , crossref ) ; resolved = bool_ ; } } } } return resolved ; }	Determines if all proxies in the model are resolved.
private static set < eobject > findalleobjects ( final resourceset resourceset ) { final set < eobject > list = new hashset < eobject > ( ) ; for ( final iterator < notifier > i = resourceset . getallcontents ( ) ; i . hasnext ( ) ; ) { final notifier next = i . next ( ) ; if ( next instanceof eobject ) { list . add ( ( eobject ) next ) ; } } return list ; }	Returns a list of all objects.
protected final void setmodeldirs ( final file ... modeldirs ) { if ( modeldirs == null ) { this . modeldirs = null ; } else { this . modeldirs = new arraylist < file > ( ) ; this . modeldirs . addall ( arrays . aslist ( modeldirs ) ) ; } }	Sets the model directories to parse.
protected final void setfileextensions ( final string ... fileextensions ) { if ( fileextensions == null ) { this . fileextensions = null ; } else { this . fileextensions = new arraylist < string > ( ) ; this . fileextensions . addall ( arrays . aslist ( fileextensions ) ) ; } }	Sets the list of file extensions.
protected final void setmodelresources ( final uri ... modelresources ) { if ( modelresources == null ) { this . modelresources = null ; } else { this . modelresources = new arraylist < uri > ( ) ; this . modelresources . addall ( arrays . aslist ( modelresources ) ) ; } }	Sets the model resources to parse.
@ override public final boolean nextrecord ( ) throws ioexception { final string line = reader . readline ( ) ; if ( line == null ) { parts = null ; return bool_ ; } final list < string > newparts = splitline ( line ) ; parts = newparts . toarray ( new string [ newparts . size ( ) ] ) ; partindex = num_ ; return bool_ ; }	Reads the next row.
public void setstringarray ( string parametername , string ... values ) throws java . sql . sqlexception { int arraylen = this . getsql ( ) . getarraylen ( parametername ) ; assertutils . asserttrue ( values . length <= arraylen ) ; for ( int i = num_ ; i < arraylen ; i ++ ) { setstring2 ( sql . toparamname ( parametername , i ) , ( i < values . length ) ? values [ i ] : null ) ; } }	type IN (.
@ suppresswarnings ( str_ ) @ override public < t > t asobject ( string string , class < t > valuetype ) throws illegalargumentexception , converterexception { return ( t ) new instancetype ( string ) ; }	Create an instance type from its string value.
protected final void merge ( final velocitycontext context , final string artifactname , final string templatename , final string filename ) throws generateexception { final generatedfile genfile = gettargetfile ( artifactname , filename , templatename ) ; if ( genfile . isskip ( ) ) { log . debug ( str_ , genfile , templatename ) ; } else { log . debug ( str_ , genfile , templatename ) ;	Merges the template and context into a file.
public final file getmodeldir ( ) { if ( ( modeldir == null ) && ( modelpath != null ) ) { modeldir = utils4j . getcanonicalfile ( new file ( modelpath ) ) ; } return modeldir ; }	Returns the model directory.
public final file gettemplatedir ( ) { if ( ( templatedir == null ) && ( templatepath != null ) ) { try { templatedir = new file ( templatepath ) . getcanonicalfile ( ) ; } catch ( final ioexception ex ) { throw new runtimeexception ( str_ + templatepath , ex ) ; } } return templatedir ; }	Returns the template directory.
@ override public void write ( httpservletresponse httpresponse , object value ) throws ioexception { final document document = ( document ) value ; document . serialize ( new outputstreamwriter ( httpresponse . getoutputstream ( ) , str_ ) ) ; }	Serialize XML document to output stream of given HTTP response.
@ validate public void start ( ) { qapplication . invokelater ( new runnable ( ) { public void run ( ) { configureapplication ( ) ; m_logger . info ( str_ ) ; synchronized ( webviewfactory . this ) { m_browser = new webwindow ( m_url , webviewfactory . this ) ; configurewindow ( m_browser ) ; m_browser . show ( ) ; } m_logger . info ( str_ ) ; } } ) ; }	Starts the browser and loads theset url in the web view.
private void configurewindow ( webwindow web ) { if ( m_fullscreen ) {	Configures the browser window.
public void print ( qwebview view ) { if ( m_print ) { qprinter printer = new qprinter ( ) ; qprintdialog printdialog = new qprintdialog ( printer , view ) ; if ( printdialog . exec ( ) == qdialog . dialogcode . accepted . value ( ) ) {	Print callback.Checks if the print feature is enabled.
public static void write ( inputstream in , outputstream out ) throws ioexception { byte [ ] b = new byte [ num_ ] ; for ( int n ; ( n = in . read ( b ) ) != - num_ ; ) { out . write ( b , num_ , n ) ; } in . close ( ) ; out . close ( ) ; }	Utility method to copy a stream to another stream.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { t instance = appfactory . getinstance ( interfaceclass ) ; return method . invoke ( instance , args ) ; }	Retrieve managed instance from application factory and invoke given method on that instance.
public void attach ( httpservletrequest httprequest , httpservletresponse httpresponse ) {	Attach this instance to HTTP servlet request.
public void detach ( ) { attached = bool_ ; locale = null ; securitydomain = null ; cookies = null ; requestpath = null ; requesturl = null ; }	Detach request context instance from HTTP servlet request.
public cookies getcookies ( ) { assertattached ( ) ; if ( cookies == null ) { cookies = new cookies ( httprequest , httpresponse ) ; } return cookies ; }	Get request cookies.
public void dump ( ) { if ( ! attached ) { return ; } stringbuilder message = new stringbuilder ( ) ; message . append ( str_ ) ; message . append ( httprequest . getrequesturi ( ) ) ; message . append ( str_ ) ; message . append ( system . lineseparator ( ) ) ; message . append ( str_ ) ; message . append ( httprequest . getremotehost ( ) ) ; message . append ( system . lineseparator ( ) ) ; message . append ( str_ ) ; message . append ( httprequest . getmethod ( ) ) ; message . append ( system . lineseparator ( ) ) ; message . append ( str_ ) ; if ( httprequest . getquerystring ( ) != null ) { message . append ( httprequest . getquerystring ( ) ) ; } enumeration < string > headernames = httprequest . getheadernames ( ) ; while ( headernames . hasmoreelements ( ) ) { message . append ( system . lineseparator ( ) ) ; string headername = headernames . nextelement ( ) ; message . append ( str_ ) ; message . append ( headername ) ; message . append ( str_ ) ; message . append ( httprequest . getheader ( headername ) ) ; } log . error ( message . tostring ( ) ) ; }	Dump this request context state to error logger.
private static list < invocationmeter > getmeters ( ) { list < invocationmeter > invocationmeters = new arraylist < invocationmeter > ( ) ; containerspi container = ( containerspi ) factory . getappfactory ( ) ; for ( managedmethodspi managedmethod : container . getmanagedmethods ( ) ) { invocationmeters . add ( ( ( managedmethod ) managedmethod ) . getmeter ( ) ) ; } return invocationmeters ; }	Collect invocation meters from application managed classes.
protected void config ( eventstreamconfig config ) { if ( config . hassecretkey ( ) ) { secretkey = config . getsecretkey ( ) ; } if ( config . haskeepaliveperiod ( ) ) { keepaliveperiod = config . getkeepaliveperiod ( ) ; } parameters = config . getparameters ( ) ; }	Configure events stream instance from configuration object.
protected void setremotehost ( string remotehost ) { if ( string == null ) { string = strings . concat ( str_ , stream_id ++ , str_ , remotehost ) ; } }	Set the host address for client connected to this event stream.
protected < t > t getparameter ( string name , class < t > type ) { if ( parameters == null ) { throw new bugerror ( str_ , this ) ; } string value = parameters . get ( name ) ; if ( value == null ) { throw new bugerror ( str_ , name , type ) ; } return converterregistry . getconverter ( ) . asobject ( value , type ) ; }	Get named parameter throwing exception if not found.
public string removeprefix ( final string path , final string prefix ) { string pathwithoutprefix = path ; if ( pathwithoutprefix . startswith ( prefix ) ) { pathwithoutprefix = pathwithoutprefix . substring ( prefix . length ( ) ) ; while ( pathwithoutprefix . startswith ( str_ ) || pathwithoutprefix . startswith ( str_ ) ) { pathwithoutprefix = pathwithoutprefix . substring ( num_ ) ; } } return pathwithoutprefix ; }	Removes a prefix from a path.
public file getcommondir ( final file dir1 , final file dir2 ) throws ioexception { list < file > parts1 = getparentdirs ( dir1 ) ; list < file > parts2 = getparentdirs ( dir2 ) ; file matched = null ; final int maxcommonsize = math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; for ( int i = num_ ; i < maxcommonsize ; ++ i ) { if ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { matched = parts1 . get ( i ) ; } else { break ; } } return matched ; }	Gets the longest common parent directory path of two paths.
public string abs2rel ( final string basepath , final string abspath ) { if ( ! isabsolutepath ( abspath ) ) { return abspath ; } if ( iswindowsdrive ( abspath ) && iswindowsdrive ( basepath ) && abspath . charat ( num_ ) != basepath . charat ( num_ ) ) { return abspath ; } stringbuilder result = new stringbuilder ( ) ; string [ ] baseparts = getparts ( basepath ) ; string [ ] absparts = getparts ( abspath ) ;	Converts an absolute path into a relative one.
public file rel2abs ( final string basepath , final string relpath ) { string [ ] baseparts = getparts ( basepath ) ; string [ ] relparts = getparts ( relpath ) ; if ( isabsolutepath ( relpath ) ) { return new file ( relpath ) ; } list < string > parts = new arraylist < > ( ) ; for ( int i = num_ ; i < baseparts . length ; ++ i ) { if ( i > num_ || ! iswindowsdrive ( basepath ) ) { parts . add ( baseparts [ i ] ) ; } } for ( string part : relparts ) { if ( part . equals ( str_ ) && parts . size ( ) > num_ ) { parts . remove ( parts . size ( ) - num_ ) ; } else if ( ! part . equals ( str_ ) && ! part . equals ( str_ ) ) { parts . add ( part ) ; } } stringbuilder result = new stringbuilder ( ) ; if ( iswindowsdrive ( basepath ) ) { result . append ( baseparts [ num_ ] ) ; } for ( string part : parts ) { result . append ( file . separator ) ; result . append ( part ) ; } return new file ( result . tostring ( ) ) ; }	Converts an relative path into an absolute one.
public int dirdepth ( final file path ) { final string stringpath = path . getpath ( ) ; return stringpath . length ( ) - stringpath . replaceall ( str_ , str_ ) . length ( ) ; }	Counts the number of directories in a given path.
protected static void dumperror ( requestcontext context , throwable throwable ) { log . dump ( str_ , throwable ) ; context . dump ( ) ; }	Dump throwable stack trace and request context to application logger.
protected static void sendjsonobject ( requestcontext context , object object , int statuscode ) throws ioexception { final httpservletresponse httpresponse = context . getresponse ( ) ; if ( httpresponse . iscommitted ( ) ) { log . fatal ( str_ ) ; return ; } log . trace ( str_ , object . tostring ( ) ) ; json json = classes . loadservice ( json . class ) ; string buffer = json . stringify ( object ) ; byte [ ] bytes = buffer . getbytes ( str_ ) ; httpresponse . setstatus ( statuscode ) ; httpresponse . setcontenttype ( contenttype . application_json . getvalue ( ) ) ; httpresponse . setcontentlength ( bytes . length ) ; httpresponse . setheader ( str_ , context . getlocale ( ) . tolanguagetag ( ) ) ; httpresponse . getoutputstream ( ) . write ( bytes ) ; httpresponse . getoutputstream ( ) . flush ( ) ; }	Send object back to client encoded JSON with given HTTP status code.
public final void addparamtemplate ( final parameterizedtemplatemodel paramtemplate ) { if ( paramtemplates == null ) { paramtemplates = new arraylist < parameterizedtemplatemodel > ( ) ; } paramtemplates . add ( paramtemplate ) ; }	Adds another template to the list.
public final void addparamtemplates ( final list < parameterizedtemplatemodel > list ) { if ( list != null ) { for ( final parameterizedtemplatemodel template : list ) { addparamtemplate ( template ) ; } } }	Adds all templates to the list.
public final void init ( final srcgen4jcontext context , final map < string , string > vars ) { if ( paramtemplates != null ) { for ( final parameterizedtemplatemodel paramtemplate : paramtemplates ) { paramtemplate . init ( context , vars ) ; } } }	Initalizes the object.
public final list < parameterizedtemplatemodel > findreferencesto ( final file templatedir , final file templatefile ) { final list < parameterizedtemplatemodel > result = new arraylist < parameterizedtemplatemodel > ( ) ; if ( ( paramtemplates != null ) && utils4j . fileinsidedirectory ( templatedir , templatefile ) ) { for ( final parameterizedtemplatemodel paramtemplate : paramtemplates ) { if ( paramtemplate . hasreferenceto ( templatedir , templatefile ) ) { result . add ( paramtemplate ) ; } } } return result ; }	Returns a list that contains all models that reference the given template.
public void setsaveenabled ( boolean val ) { savebutton . setvisible ( val ) ; setreadonly ( ! val ) ; entityform . setreadonly ( ! val ) ; }	Controls whether a save button is shown and fields are editable.
protected void delete ( ) { string question = str_ + getcaption ( ) + str_ ; confirmdialog . show ( getui ( ) , question , ( confirmdialog cd ) -> { if ( cd . isconfirmed ( ) ) { try { ondelete ( ) ; close ( ) ; } catch ( ioexception | illegalargumentexception | illegalaccessexception | illegalstateexception ex ) { onerror ( ex ) ; } catch ( runtimeexception ex ) {	Deletes the element.
protected void ondelete ( ) throws ioexception , illegalargumentexception , illegalaccessexception , filenotfoundexception , illegalstateexception { endpoint . delete ( ) ; eventbus . post ( new elementdeletedevent < > ( endpoint ) ) ; }	Handler for deleting the element.
@ suppresswarnings ( str_ ) @ override public < t > t newinstance ( managedclassspi managedclass , object ... args ) { constructor < ? > constructor = managedclass . getconstructor ( ) ; if ( constructor == null ) { throw new bugerror ( str_ , managedclass ) ; } object instance = null ; try { instance = constructor . newinstance ( args ) ; } catch ( illegalargumentexception e ) { log . error ( str_ , constructor , strings . join ( classes . getparametertypes ( args ) ) ) ; throw e ; } catch ( instantiationexception e ) {	Uses managed class constructor to create new instance with provided arguments.
public file [ ] getfiles ( ) { list < file > result = new arraylist < > ( ) ; for ( filecount filecount : results ) { result . add ( filecount . getfile ( ) ) ; } collections . sort ( result , new fitfilecomparator ( ) ) ; return result . toarray ( new file [ result . size ( ) ] ) ; }	Returns all saved filenames.
public counts getsummary ( ) { counts result = new counts ( ) ; for ( filecount filecount : results ) { if ( filecount . getcounts ( ) != null ) { result . tally ( filecount . getcounts ( ) ) ; } } return result ; }	Returns the sum of all results.
public string getsummaryrow ( final file directory ) { stringbuilder builder = new stringbuilder ( ) ; counts counts = getsummary ( ) ; builder . append ( str_ ) ; builder . append ( color ( counts ) ) ; builder . append ( str_ ) ; builder . append ( directory . getname ( ) ) ; builder . append ( str_ ) ; builder . append ( counts . tostring ( ) ) ; builder . append ( str_ ) ; return builder . tostring ( ) ; }	Returns a summary row for a whole test run.
public string getsubsummaryrow ( final file path ) throws ioexception { counts sum = subdirsum ( path ) ; return string . format ( str_ , color ( sum ) , fitutils . htmlsafefile ( dirhelper . abs2rel ( new file ( str_ ) . getabsolutepath ( ) , path . getabsolutepath ( ) ) ) , sum . tostring ( ) ) ; }	Generates a HTML summary row for a subdirectory.
@ suppresswarnings ( str_ ) @ override public < i > i newinstance ( managedclassspi managedclass , object ... args ) { if ( args . length > num_ ) { throw new illegalargumentexception ( str_ ) ; } class < ? > [ ] interfaceclasses = managedclass . getinterfaceclasses ( ) ; if ( interfaceclasses == null ) { throw new bugerror ( str_ ) ; } if ( interfaceclasses . length != num_ ) { throw new bugerror ( str_ ) ; } return ( i ) classes . loadservice ( interfaceclasses [ num_ ] ) ; }	Load service defined by managed class interface and return service instance.
public final class < ? > getsetupclass ( ) { if ( setupclass != null ) { return setupclass ; } log . info ( str_ , setupclassname ) ; try { setupclass = class . forname ( setupclassname , bool_ , context . getclassloader ( ) ) ; } catch ( final classnotfoundexception ex ) { throw new runtimeexception ( str_ + setupclassname , ex ) ; } return setupclass ; }	Returns the setup class.
public final list < file > getmodeldirs ( ) { if ( ( modeldirs == null ) && ( modelpath != null ) ) { modeldirs = paths ( ) . stream ( ) . filter ( xtextparserconfig :: isfile ) . map ( xtextparserconfig :: asfile ) . collect ( collectors . tolist ( ) ) ; } return modeldirs ; }	Returns a list of model directories to parse.
public final list < uri > getmodelresources ( ) { if ( ( modelresources == null ) && ( modelpath != null ) ) { modelresources = new arraylist < > ( ) ; modelresources = paths ( ) . stream ( ) . filter ( xtextparserconfig :: isresource ) . map ( xtextparserconfig :: asresource ) . collect ( collectors . tolist ( ) ) ; } return modelresources ; }	Returns a list of model resources to parse.
public void setcandidates ( collection < t > candidates ) { twincolselect . setcontainerdatasource ( container = new beanitemcontainer < > ( entitytype , candidates ) ) ; }	Sets a set of candidates for selection.
protected static void loadxml ( inputstream inputstream , loader loader ) throws configexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; xmlreader reader = parser . getxmlreader ( ) ; reader . setcontenthandler ( loader ) ; reader . parse ( new inputsource ( inputstream ) ) ; } catch ( exception e ) { throw new configexception ( str_ , inputstream , e ) ; } }	Load configuration document from file.
protected void onerror ( exception ex ) { notification . show ( str_ , ex . getlocalizedmessage ( ) , notification . type . error_message ) ; }	Handler for errors reported by REST endpoints.
private static boolean isobject ( type [ ] formalparameters ) { if ( formalparameters . length != num_ ) { return bool_ ; } final type type = formalparameters [ num_ ] ; if ( ! ( type instanceof class ) ) { return bool_ ; } if ( types . isprimitive ( type ) ) { return bool_ ; } if ( types . isarraylike ( type ) ) { return bool_ ; } if ( types . ismap ( type ) ) { return bool_ ; } if ( converterregistry . hastype ( type ) ) { return bool_ ; } return bool_ ; }	Test if method formal parameters designates a strict object, that is, is not primitive, array, collection or map.
@ override public object [ ] read ( httpservletrequest httprequest , type [ ] formalparameters ) throws ioexception , illegalargumentexception { jsonreader reader = new jsonreader ( httprequest . getinputstream ( ) , expectedstartsequence ( formalparameters ) ) ; try { return json . parse ( reader , formalparameters ) ; } catch ( jsonexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } finally { reader . close ( ) ; } }	Uses JSON deserializer to parse method invocation arguments accordingly formal parameters list.
@ override public object read ( inputstream inputstream , type type ) throws ioexception { try { return json . parse ( new inputstreamreader ( inputstream , str_ ) , type ) ; } catch ( jsonexception | classcastexception | unsupportedencodingexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } }	Parse JSON from input stream accordingly given type.
public static string extractcellparameter ( fitcell cell ) { final matcher matcher = parameter_pattern . matcher ( cell . getfitvalue ( ) ) ; if ( matcher . matches ( ) ) { cell . setfitvalue ( matcher . group ( num_ ) ) ; return matcher . group ( num_ ) ; } else { return null ; } }	extracts and removes parameters from a cell.
@ override public java . util . map < java . lang . string , java . lang . object > gethints ( ) { return this . q . gethints ( ) ; }	javax.persistence.Query & javax.persistence.TypedQuery.
public static boolean isxhr ( httpservletrequest httprequest ) { string requestedwith = httprequest . getheader ( x_requested_with ) ; return requestedwith != null ? requestedwith . equalsignorecase ( xml_http_request ) : bool_ ; }	Test if given HTTP request is performed via XMLHttpRequest.
public static boolean isandroid ( httpservletrequest httprequest ) { string requestedwith = httprequest . getheader ( x_requested_with ) ; return requestedwith != null ? requestedwith . equalsignorecase ( android_user_agent ) : bool_ ; }	Test if HTTP request is from Android.
@ subscribe public void handle ( elementevent < tentity > message ) { if ( message . getendpoint ( ) . getentitytype ( ) == this . endpoint . getentitytype ( ) ) { refresh ( ) ; } }	Refresh when child elements are created or updated.
public static < tannotation extends annotation > list < propertydescriptor > getpropertieswithannotation ( class < ? > beantype , class < tannotation > annotationtype ) { linkedlist < propertydescriptor > result = new linkedlist < > ( ) ; getproperties ( beantype ) . foreach ( property -> { if ( property . getreadmethod ( ) != null && property . getreadmethod ( ) . getannotation ( annotationtype ) != null || isfieldannotated ( beantype , property . getname ( ) , annotationtype ) ) { result . add ( property ) ; } } ) ; return result ; }	Lists all properties on a bean type that have a specific annotation ontheir getter or backing field.
public static < tannotation extends annotation > optional < tannotation > getannotation ( class < ? > beantype , propertydescriptor property , class < tannotation > annotationtype ) { optional < tannotation > annotation = stream ( property . getreadmethod ( ) . getannotationsbytype ( annotationtype ) ) . findany ( ) ; return annotation . ispresent ( ) ? annotation : getannotationonfield ( beantype , property . getname ( ) , annotationtype ) ; }	Returns an annotation of a specific type on a property's getter or itsbacking field.
private static string log ( string message , object ... args ) { message = string . format ( message , args ) ; java . util . logging . logger . getlogger ( server . class . getcanonicalname ( ) ) . log ( java . util . logging . level . severe , message ) ; return message ; }	Log formatted message to Java logger since framework logger is not yet initialized.
public whoisresult lookup ( string domain , int timeout ) { container . put ( str_ , domain ) ; container . put ( str_ , timeout ) ; try { return ( whoisresult ) container . runscriptlet ( jrubywhois . class . getresourceasstream ( str_ ) , str_ ) ; } catch ( evalfailedexception e ) { if ( e . getmessage ( ) . startswith ( str_ ) ) { throw new servernotfoundexception ( e ) ; } if ( e . getmessage ( ) . startswith ( str_ ) ) { throw new webinterfaceerrorexception ( e ) ; } throw e ; } }	Uses the Ruby Whois gem to perform a whois lookup.
public boolean hasparserforwhoishost ( string whoishost ) { container . put ( str_ , whoishost ) ; return ( boolean ) container . runscriptlet ( jrubywhois . class . getresourceasstream ( str_ ) , str_ ) ; }	Check if Ruby Whois gem has a parser for a specific registrar.
private static managedclassspi getmanagedclass ( containerspi container , string interfacename , string requesturi ) throws classnotfoundexception { class < ? > interfaceclass = classes . foroptionalname ( interfacename ) ; if ( interfaceclass == null ) { log . error ( str_ , interfacename ) ; throw new classnotfoundexception ( requesturi ) ; } managedclassspi managedclass = container . getmanagedclass ( interfaceclass ) ; if ( managedclass == null ) { log . error ( str_ , interfacename ) ; throw new classnotfoundexception ( requesturi ) ; } if ( ! managedclass . isremotelyaccessible ( ) ) { log . error ( str_ , interfacename ) ; throw new classnotfoundexception ( requesturi ) ; } return managedclass ; }	Get remotely accessible managed class registered to a certain interface class.
private static managedmethodspi getmanagedmethod ( managedclassspi managedclass , string methodname , string requesturi ) throws nosuchmethodexception { managedmethodspi managedmethod = managedclass . getnetmethod ( methodname ) ; if ( managedmethod == null ) { log . error ( str_ , managedclass . getinterfaceclass ( ) . getname ( ) , methodname ) ; throw new nosuchmethodexception ( requesturi ) ; } if ( ! managedmethod . isremotelyaccessible ( ) ) { log . error ( str_ , managedclass . getinterfaceclass ( ) . getname ( ) , methodname ) ; throw new nosuchmethodexception ( requesturi ) ; } if ( types . iskindof ( managedmethod . getreturntype ( ) , resource . class ) ) { log . error ( str_ , managedclass . getinterfaceclass ( ) . getname ( ) , methodname ) ; throw new nosuchmethodexception ( requesturi ) ; } return managedmethod ; }	Get managed method that is remotely accessible and has requested name.
public void processnotcontainsexception ( map < string , string > parameters ) { loggingevent match = getmessagewithexception ( parameters ) ; if ( match == null ) { cell . right ( ) ; } else { cell . wrong ( match . getthrowableinformation ( ) . getthrowablestrrep ( ) [ num_ ] ) ; } }	Checks whether the log messages contain the expected exception.
public void processnotcontains ( map < string , string > parameters ) { loggingevent match = getmessagewithstring ( parameters ) ; if ( match == null ) { cell . right ( ) ; } else { cell . wrong ( match . getmessage ( ) . tostring ( ) ) ; } }	Checks whether the log messages do not contain the expected text.
@ override public void serialize ( httpservletresponse httpresponse ) throws ioexception { httpresponse . setheader ( httpheader . cache_control , httpheader . no_cache ) ; httpresponse . addheader ( httpheader . cache_control , httpheader . no_store ) ; httpresponse . setheader ( httpheader . pragma , httpheader . no_cache ) ; httpresponse . setdateheader ( httpheader . expires , num_ ) ; httpresponse . setcontenttype ( getcontenttype ( ) . getvalue ( ) ) ; serialize ( httpresponse . getoutputstream ( ) ) ; }	Set common HTTP response headers and delegates actual serialization to subclass.
public string get ( string name ) { params . notnullorempty ( name , str_ ) ; if ( cookies == null ) { return null ; } for ( cookie cookie : cookies ) { if ( name . equals ( cookie . getname ( ) ) ) { return cookie . getvalue ( ) ; } } return null ; }	Get value of the named cookie or null if cookie does not exist.
public void add ( string name , string value ) { params . notnullorempty ( name , str_ ) ; params . notnull ( value , str_ ) ; cookie cookie = new cookie ( name , value ) ; cookie . setpath ( str_ ) ; httpresponse . addcookie ( cookie ) ; }	Add cookie to HTTP response of the current request context.
public void remove ( string name ) { params . notnullorempty ( name , str_ ) ; if ( cookies == null ) { return ; } for ( cookie cookie : cookies ) { if ( name . equals ( cookie . getname ( ) ) ) { cookie . setmaxage ( num_ ) ; cookie . setvalue ( str_ ) ; cookie . setpath ( str_ ) ; httpresponse . addcookie ( cookie ) ; break ; } } }	Remove cookie from HTTP response.
public iterator < cookie > iterator ( ) { if ( cookies == null ) { return collections . emptyiterator ( ) ; } return arrays . aslist ( cookies ) . iterator ( ) ; }	Get cookies iterator. Return empty iterator if not cookies on HTTP request.
public final targetfilelistproducer gettargetfilelistproducer ( ) { if ( tflproducer != null ) { return tflproducer ; } final object obj = utils4j . createinstance ( classname ) ; if ( ! ( obj instanceof targetfilelistproducer ) ) { throw new illegalstateexception ( str_ + targetfilelistproducer . class . getname ( ) + str_ + classname ) ; } tflproducer = ( targetfilelistproducer ) obj ; return tflproducer ; }	Returns an existing target file list producer instance or creates a new one if it's the first call to this method.
public void add ( final class < ? > type , final string name ) throws classnotfoundexception { fieldgen fg ; if ( result != null ) { throw new illegalstateexception ( str_ ) ; } fg = new fieldgen ( constants . acc_public | constants . acc_super , type . gettype ( type ) , name , cg . getconstantpool ( ) ) ; cg . addfield ( fg . getfield ( ) ) ; }	Adds a public field to the constructed class.
public final class < ? > compile ( ) { if ( result == null ) { loader . loadjavaclass ( cg . getclassname ( ) , cg . getjavaclass ( ) ) ; try { result = loader . loadclass ( cg . getclassname ( ) ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( e ) ; } } return result ; }	Compiles the class and returns a class object which contains alladded fields.
public boolean verifyresponse ( string token ) throws nullpointerexception { return value . equals ( getvalue ( tokenedimagefiles . get ( token ) ) ) ; }	Test that selected image identified by given token is the right response.
private static string getvalue ( file file ) throws nullpointerexception { if ( file == null ) { return null ; } return file . getname ( ) . tolowercase ( ) . replaceall ( extension_rex , str_ ) . replaceall ( not_letters_rex , str_ ) ; }	Challenge value associated with image file.
@ sneakythrows public static uri ensuretrailingslash ( uri uri ) { uribuilder builder = new uribuilder ( uri ) ; if ( ! builder . getpath ( ) . endswith ( str_ ) ) { builder . setpath ( builder . getpath ( ) + str_ ) ; } return builder . build ( ) ; }	Adds a trailing slash to the URI if it does not already have one.
private httpservletrequest gethttpservletrequest ( ) { requestcontext context = getinstance ( requestcontext . class ) ; httpservletrequest request = context . getrequest ( ) ; if ( request == null ) { throw new bugerror ( str_ ) ; } return request ; }	Get HTTP request from current request context.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { final managedmethodspi managedmethod = managedclass . getmanagedmethod ( method ) ; log . trace ( str_ , managedmethod ) ; if ( ! managedmethod . istransactional ( ) ) {	Invocation handler implementation. Every method invocation on managed class interface is routed to this point. Hereactual container services are implemented and method is invoked against wrapped instance.
private object executemutabletransaction ( managedmethodspi managedmethod , object [ ] args ) throws throwable {	Helper method for mutable transaction execution.
private object executeimmutabletransaction ( managedmethodspi managedmethod , object [ ] args ) throws throwable { transaction transaction = transactionalresource . createreadonlytransaction ( ) ;	Helper method for immutable transaction execution.
public file [ ] getfiles ( ) { final file [ ] files = directory . listfiles ( filter ) ; if ( files == null ) { return new file [ num_ ] ; } else { return files ; } }	Returns a list of all matching files.
public file getlastfile ( ) throws filenotfoundexception { file [ ] files = directory . listfiles ( filter ) ; if ( files == null || files . length == num_ ) { throw new filenotfoundexception ( ) ; } return files [ files . length - num_ ] ; }	Returns the last matching file.
@ suppresswarnings ( str_ ) protected final config_type getconcreteconfig ( final parserconfig config ) { final config < parserconfig > cfg = config . getconfig ( ) ; if ( cfg == null ) { throw new illegalstateexception ( str_ + concreteconfigclass . getname ( ) + str_ ) ; } else { if ( ! ( concreteconfigclass . isassignablefrom ( cfg . getconfig ( ) . getclass ( ) ) ) ) { throw new illegalstateexception ( str_ + concreteconfigclass . getname ( ) + str_ + cfg . getconfig ( ) . getclass ( ) . getname ( ) + str_ ) ; } } return ( config_type ) cfg . getconfig ( ) ; }	Returns the parser configuration.
private static boolean startswith ( string requestpath , string pathcomponent ) { if ( requestpath . charat ( num_ ) != str_ ) { return bool_ ; } int i = num_ ; for ( int j = num_ ; i < requestpath . length ( ) ; ++ i , ++ j ) { if ( requestpath . charat ( i ) == str_ ) { return j == pathcomponent . length ( ) ; } if ( j == pathcomponent . length ( ) ) { return bool_ ; } if ( character . tolowercase ( requestpath . charat ( i ) ) != character . tolowercase ( pathcomponent . charat ( j ) ) ) { return bool_ ; } } return bool_ ; }	Test if request path starts with path component.
@ suppresswarnings ( str_ ) @ notnull public final < model > list < artifactfactory < model > > getfactories ( final class < model > modeltype ) { final list < artifactfactory < model > > list = new arraylist < artifactfactory < model > > ( ) ; if ( factories == null ) { factories = new arraylist < artifactfactory < ? > > ( ) ; if ( factoryconfigs != null ) { for ( final artifactfactoryconfig factoryconfig : factoryconfigs ) { factories . add ( factoryconfig . getfactory ( ) ) ; } } } for ( final artifactfactory < ? > factory : factories ) { if ( modeltype . isassignablefrom ( factory . getmodeltype ( ) ) ) { list . add ( ( artifactfactory < model > ) factory ) ; } } return list ; }	Returns a list of factories for the given model type.
private httpsession getsession ( instancekey instancekey ) { requestcontext requestcontext = appfactory . getinstance ( requestcontext . class ) ; httpservletrequest httprequest = requestcontext . getrequest ( ) ; if ( httprequest == null ) { throw new bugerror ( str_ , instancekey ) ; }	Get HTTP session from current request, creating it if necessary.
@ override public void serialize ( httpservletresponse httpresponse ) throws ioexception { httpresponse . setheader ( httpheader . cache_control , httpheader . no_cache ) ; httpresponse . addheader ( httpheader . cache_control , httpheader . no_store ) ; httpresponse . setheader ( httpheader . pragma , httpheader . no_cache ) ; httpresponse . setdateheader ( httpheader . expires , num_ ) ; httpresponse . setcontenttype ( contenttype ) ; httpresponse . setheader ( httpheader . content_length , long . tostring ( file . length ( ) ) ) ; files . copy ( file , httpresponse . getoutputstream ( ) ) ; }	Serialize this file resource to HTTP response.
public void readmeta ( ) throws ioexception , illegalargumentexception , illegalaccessexception , filenotfoundexception , illegalstateexception { executeandhandle ( request . get ( uri ) ) ; }	Fetches meta data such as links from the server.
@ override protected void handlerequest ( requestcontext context ) throws servletexception , ioexception {	Handle request for a resource.
@ override public void teardown ( ) throws exception { if ( statement != null ) { statement . close ( ) ; statement = null ; } super . teardown ( ) ; }	Closes the SQL statement.
@ override public void predestroy ( ) { if ( eventstreams . isempty ( ) ) { return ; }	Closes all event streams still opened when event stream manager is destroyed.
protected void handleallowedmethods ( ) { endpoint . isdownloadallowed ( ) . ifpresent ( this :: setdownloadenabled ) ; endpoint . isuploadallowed ( ) . ifpresent ( this :: setuploadenabled ) ; endpoint . isdeleteallowed ( ) . ifpresent ( this :: setdeleteenabled ) ; }	Enables or disabled buttons based on the "Allow" HTTP header.
protected void upload ( ) { try { onupload ( ) ; eventbus . post ( new blobuploadevent ( endpoint ) ) ; notification . show ( str_ , str_ , notification . type . tray_notification ) ; } catch ( ioexception | illegalargumentexception | illegalaccessexception | illegalstateexception ex ) { onerror ( ex ) ; } }	Called to upload new blob data to the server.
protected void delete ( ) { string question = str_ ; confirmdialog . show ( getui ( ) , question , new confirmdialog . listener ( ) { @ override public void onclose ( confirmdialog cd ) { if ( cd . isconfirmed ( ) ) { try { endpoint . delete ( ) ; close ( ) ; } catch ( ioexception | illegalargumentexception | illegalaccessexception | illegalstateexception ex ) { onerror ( ex ) ; } catch ( runtimeexception ex ) {	Deletes the blob.
protected string [ ] extractcolumnparameters ( fitrow row ) { final list < string > result = new arraylist < > ( ) ; for ( fitcell cell : row . cells ( ) ) { result . add ( fitutils . extractcellparameter ( cell ) ) ; } return result . toarray ( new string [ result . size ( ) ] ) ; }	extracts and removes parameters from a row.
protected string [ ] getargnames ( ) { if ( args == null ) { return new string [ ] { } ; } return args . keyset ( ) . toarray ( new string [ args . keyset ( ) . size ( ) ] ) ; }	Returns all argument names.
public synchronized void period ( final periodictask periodictask , long period ) { timertask task = new periodictaskimpl ( periodictask ) ; this . tasks . put ( periodictask , task ) ; this . timer . schedule ( task , num_ , period ) ; }	Schedule periodic task execution.
public synchronized void timeout ( final timeouttask timeouttask , long timeout ) { timertask task = this . tasks . get ( timeouttask ) ; if ( task != null ) { task . cancel ( ) ; this . tasks . values ( ) . remove ( task ) ; } task = new timeouttaskimpl ( timeouttask ) ; this . tasks . put ( timeouttask , task ) ; this . timer . schedule ( task , timeout ) ; }	Schedule timeout task, reseting timeout period if given timeout task is already pending.
@ override public void config ( config config ) throws configexception , ioexception { for ( config repositorysection : config . findchildren ( str_ ) ) {	Create views meta pool from given managed view configuration object.
@ override public final file next ( ) { if ( files == null || fileindex >= files . length ) { if ( ! cachenext ( ) ) { throw new nosuchelementexception ( ) ; } } return files [ fileindex ++ ] ; }	Returns the next matching file.
private static void configureapplication ( ) {	Configures the application.
private static void printwelcomebanner ( ) { stringbuffer banner = new stringbuffer ( ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; banner . append ( str_ ) ; system . out . println ( banner ) ; }	Prints Welcome Banner.
private static void printstoppedbanner ( ) { system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; }	Prints Stopped Banner.
public static chameria createchameleon ( string [ ] args ) throws exception { boolean debug = isdebugmodeenabled ( args ) ; string core = getcore ( args ) ; string app = getapp ( args ) ; string runtime = getruntime ( args ) ; string fileinstall = getdeploydirectory ( args ) ; string config = getprops ( args ) ; if ( config == null || ! new file ( config ) . exists ( ) ) { return new chameria ( core , debug , app , runtime , fileinstall , null ) ; } else { return new chameria ( core , debug , app , runtime , fileinstall , config ) ; } }	Creates the Chameleon instance.The instance is not started.
private static void registershutdownhook ( final chameria chameleon ) { runtime runtime = runtime . getruntime ( ) ; runnable hook = new runnable ( ) { public void run ( ) { try { if ( chameleon != null ) { chameleon . stop ( ) ; printstoppedbanner ( ) ; } } catch ( bundleexception e ) { system . err . println ( str_ + e . getmessage ( ) ) ; } catch ( interruptedexception e ) { system . err . println ( str_ + e . getmessage ( ) ) ;	Registers a shutdown hook to stop nicely the embedded framework.
public void trigger ( ) { try { ontrigger ( ) ; notification . show ( getcaption ( ) , str_ , notification . type . tray_notification ) ; } catch ( ioexception | illegalargumentexception | illegalaccessexception | illegalstateexception ex ) { onerror ( ex ) ; } }	Triggers the action.
protected void ontrigger ( ) throws ioexception , illegalargumentexception , illegalaccessexception , filenotfoundexception , illegalstateexception { endpoint . trigger ( ) ; eventbus . post ( new triggerevent ( endpoint ) ) ; }	Handler for triggering the action.
public void insertandreplace ( final fitrow row ) { if ( results . isempty ( ) ) { return ; } int index = row . getindex ( ) ; fittable table = row . gettable ( ) ; table . remove ( index ) ; addrows ( table , index ) ; }	Replaces a row with one or more results.
public counts getcounts ( ) { counts counts = new counts ( ) ; for ( filecount filecount : results ) { counts . tally ( filecount . getcounts ( ) ) ; } return counts ; }	Gets the sum of all results.
public void setscore ( double v ) { if ( summary_type . featoktst && ( ( summary_type ) jcastype ) . casfeat_score == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setdoublevalue ( addr , ( ( summary_type ) jcastype ) . casfeatcode_score , v ) ; }	setter for score - sets The score associated with the answer.
public stringlist getvariants ( ) { if ( summary_type . featoktst && ( ( summary_type ) jcastype ) . casfeat_variants == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( stringlist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( summary_type ) jcastype ) . casfeatcode_variants ) ) ) ; }	getter for variants - gets List of alternative answer summaries.
public void setvariants ( stringlist v ) { if ( summary_type . featoktst && ( ( summary_type ) jcastype ) . casfeat_variants == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( summary_type ) jcastype ) . casfeatcode_variants , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for variants - sets List of alternative answer summaries.
public string getquestiontype ( ) { if ( question_type . featoktst && ( ( question_type ) jcastype ) . casfeat_questiontype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( question_type ) jcastype ) . casfeatcode_questiontype ) ; }	getter for questionType - gets The class of the question, determined by either an automatic question classification process or human judgment.
public void setquestiontype ( string v ) { if ( question_type . featoktst && ( ( question_type ) jcastype ) . casfeat_questiontype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( question_type ) jcastype ) . casfeatcode_questiontype , v ) ; }	setter for questionType - sets The class of the question, determined by either an automatic question classification process or human judgment.
public token gettoken ( ) { if ( focus_type . featoktst && ( ( focus_type ) jcastype ) . casfeat_token == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( token ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( focus_type ) jcastype ) . casfeatcode_token ) ) ) ; }	getter for token - gets The corresponding token for the focus.
public string getdeplabel ( ) { if ( token_type . featoktst && ( ( token_type ) jcastype ) . casfeat_deplabel == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( token_type ) jcastype ) . casfeatcode_deplabel ) ; }	getter for depLabel - gets The dependency label of the token with respect to its head.
public void setdeplabel ( string v ) { if ( token_type . featoktst && ( ( token_type ) jcastype ) . casfeat_deplabel == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( token_type ) jcastype ) . casfeatcode_deplabel , v ) ; }	setter for depLabel - sets The dependency label of the token with respect to its head.
public string getsemantictype ( ) { if ( token_type . featoktst && ( ( token_type ) jcastype ) . casfeat_semantictype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( token_type ) jcastype ) . casfeatcode_semantictype ) ; }	getter for semanticType - gets A semantic type, typically the name of an Entity Annotation type.
public void setsemantictype ( string v ) { if ( token_type . featoktst && ( ( token_type ) jcastype ) . casfeat_semantictype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( token_type ) jcastype ) . casfeatcode_semantictype , v ) ; }	setter for semanticType - sets A semantic type, typically the name of an Entity Annotation type.
public stringarray getsections ( ) { if ( document_type . featoktst && ( ( document_type ) jcastype ) . casfeat_sections == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( stringarray ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections ) ) ) ; }	getter for sections - gets Content of sections in the document.
public void setsections ( stringarray v ) { if ( document_type . featoktst && ( ( document_type ) jcastype ) . casfeat_sections == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for sections - sets Content of sections in the document.
public string getsections ( int i ) { if ( document_type . featoktst && ( ( document_type ) jcastype ) . casfeat_sections == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections ) , i ) ; return jcastype . ll_cas . ll_getstringarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections ) , i ) ; }	indexed getter for sections - gets an indexed value - Content of sections in the document.
public void setsections ( int i , string v ) { if ( document_type . featoktst && ( ( document_type ) jcastype ) . casfeat_sections == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections ) , i ) ; jcastype . ll_cas . ll_setstringarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( document_type ) jcastype ) . casfeatcode_sections ) , i , v ) ; }	indexed setter for sections - sets an indexed value - Content of sections in the document.
public stringlist geturis ( ) { if ( concept_type . featoktst && ( ( concept_type ) jcastype ) . casfeat_uris == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( stringlist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( concept_type ) jcastype ) . casfeatcode_uris ) ) ) ; }	getter for uris - gets Array of uris that identify this named entity.
public void seturis ( stringlist v ) { if ( concept_type . featoktst && ( ( concept_type ) jcastype ) . casfeat_uris == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( concept_type ) jcastype ) . casfeatcode_uris , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for uris - sets Array of uris that identify this named entity.
public fslist gettypes ( ) { if ( concept_type . featoktst && ( ( concept_type ) jcastype ) . casfeat_types == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fslist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( concept_type ) jcastype ) . casfeatcode_types ) ) ) ; }	getter for types - gets A list of concept types that the concept belongs to.
public void settypes ( fslist v ) { if ( concept_type . featoktst && ( ( concept_type ) jcastype ) . casfeat_types == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( concept_type ) jcastype ) . casfeatcode_types , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for types - sets A list of concept types that the concept belongs to.
public annotation gettargettype ( ) { if ( answertype_type . featoktst && ( ( answertype_type ) jcastype ) . casfeat_targettype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( annotation ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( answertype_type ) jcastype ) . casfeatcode_targettype ) ) ) ; }	getter for targetType - gets The actual target type annotation.
public void settargettype ( annotation v ) { if ( answertype_type . featoktst && ( ( answertype_type ) jcastype ) . casfeat_targettype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( answertype_type ) jcastype ) . casfeatcode_targettype , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for targetType - sets The actual target type annotation.
public int getrank ( ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_rank == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getintvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_rank ) ; }	getter for rank - gets Rank of this result in the original hit-list.
public void setrank ( int v ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_rank == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setintvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_rank , v ) ; }	setter for rank - sets Rank of this result in the original hit-list.
public string getquerystring ( ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_querystring == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_querystring ) ; }	getter for queryString - gets The query string associated with the hit.
public void setquerystring ( string v ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_querystring == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_querystring , v ) ; }	setter for queryString - sets The query string associated with the hit.
public fsarray getcandidateanswers ( ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_candidateanswers == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fsarray ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers ) ) ) ; }	getter for candidateAnswers - gets CandidateAnswerVariants generated from this SearchResult.
public void setcandidateanswers ( fsarray v ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_candidateanswers == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for candidateAnswers - sets CandidateAnswerVariants generated from this SearchResult.
public candidateanswervariant getcandidateanswers ( int i ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_candidateanswers == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers ) , i ) ; return ( candidateanswervariant ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers ) , i ) ) ) ; }	indexed getter for candidateAnswers - gets an indexed value - CandidateAnswerVariants generated from this SearchResult.
public void setcandidateanswers ( int i , candidateanswervariant v ) { if ( searchresult_type . featoktst && ( ( searchresult_type ) jcastype ) . casfeat_candidateanswers == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers ) , i ) ; jcastype . ll_cas . ll_setrefarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( searchresult_type ) jcastype ) . casfeatcode_candidateanswers ) , i , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	indexed setter for candidateAnswers - sets an indexed value - CandidateAnswerVariants generated from this SearchResult.
public string getquery ( ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_query == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_query ) ; }	getter for query - gets The query in the native syntax of the corresponding search engine.
public void setquery ( string v ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_query == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_query , v ) ; }	setter for query - sets The query in the native syntax of the corresponding search engine.
public fsarray gethitlist ( ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_hitlist == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fsarray ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist ) ) ) ; }	getter for hitList - gets Hit list of search results, sorted in descreasing order of relevance score.
public void sethitlist ( fsarray v ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_hitlist == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for hitList - sets Hit list of search results, sorted in descreasing order of relevance score.
public searchresult gethitlist ( int i ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_hitlist == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist ) , i ) ; return ( searchresult ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist ) , i ) ) ) ; }	indexed getter for hitList - gets an indexed value - Hit list of search results, sorted in descreasing order of relevance score.
public void sethitlist ( int i , searchresult v ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_hitlist == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . jcas . checkarraybounds ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist ) , i ) ; jcastype . ll_cas . ll_setrefarrayvalue ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_hitlist ) , i , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	indexed setter for hitList - sets an indexed value - Hit list of search results, sorted in descreasing order of relevance score.
public abstractquery getabstractquery ( ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_abstractquery == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( abstractquery ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_abstractquery ) ) ) ; }	getter for abstractQuery - gets The abstract query from which this actual query was generated.
public void setabstractquery ( abstractquery v ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_abstractquery == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_abstractquery , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for abstractQuery - sets The abstract query from which this actual query was generated.
public string getsearchid ( ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_searchid == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_searchid ) ; }	getter for searchId - gets An identifier for this search result.
public void setsearchid ( string v ) { if ( search_type . featoktst && ( ( search_type ) jcastype ) . casfeat_searchid == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( search_type ) jcastype ) . casfeatcode_searchid , v ) ; }	setter for searchId - sets An identifier for this search result.
public void setdocid ( string v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_docid == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_docid , v ) ; }	setter for docId - sets A unique identifier for the document that conatins this passage.
public int getoffsetinbeginsection ( ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_offsetinbeginsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getintvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_offsetinbeginsection ) ; }	getter for offsetInBeginSection - gets Character offset of the start of this passage within the section that contains this passage.
public void setoffsetinbeginsection ( int v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_offsetinbeginsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setintvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_offsetinbeginsection , v ) ; }	setter for offsetInBeginSection - sets Character offset of the start of this passage within the section that contains this passage.
public int getoffsetinendsection ( ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_offsetinendsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getintvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_offsetinendsection ) ; }	getter for offsetInEndSection - gets Character offset of the end of this passage within the section that contains this passage.
public void setoffsetinendsection ( int v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_offsetinendsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setintvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_offsetinendsection , v ) ; }	setter for offsetInEndSection - sets Character offset of the end of this passage within the section that contains this passage.
public string getbeginsection ( ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_beginsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_beginsection ) ; }	getter for beginSection - gets The start section of this passage within the document that contains this passage.
public void setbeginsection ( string v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_beginsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_beginsection , v ) ; }	setter for beginSection - sets The start section of this passage within the document that contains this passage.
public string getendsection ( ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_endsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_endsection ) ; }	getter for endSection - gets The end section of this passage within the document that contains this passage.
public void setendsection ( string v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_endsection == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_endsection , v ) ; }	setter for endSection - sets The end section of this passage within the document that contains this passage.
public string getaspects ( ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_aspects == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_aspects ) ; }	getter for aspects - gets Aspects of the gold standard passage.
public void setaspects ( string v ) { if ( passage_type . featoktst && ( ( passage_type ) jcastype ) . casfeat_aspects == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( passage_type ) jcastype ) . casfeatcode_aspects , v ) ; }	setter for aspects - sets Aspects of the gold standard passage.
public triple gettriple ( ) { if ( triplesearchresult_type . featoktst && ( ( triplesearchresult_type ) jcastype ) . casfeat_triple == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( triple ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( triplesearchresult_type ) jcastype ) . casfeatcode_triple ) ) ) ; }	getter for triple - gets The relevant triple searched in the RDF store.
public void settriple ( triple v ) { if ( triplesearchresult_type . featoktst && ( ( triplesearchresult_type ) jcastype ) . casfeat_triple == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( triplesearchresult_type ) jcastype ) . casfeatcode_triple , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for triple - sets The relevant triple searched in the RDF store.
public triple getsourcerelation ( ) { if ( passagefromrelation_type . featoktst && ( ( passagefromrelation_type ) jcastype ) . casfeat_sourcerelation == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( triple ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( passagefromrelation_type ) jcastype ) . casfeatcode_sourcerelation ) ) ) ; }	getter for sourceRelation - gets The triple from which the search result was generated.
public void setsourcerelation ( triple v ) { if ( passagefromrelation_type . featoktst && ( ( passagefromrelation_type ) jcastype ) . casfeat_sourcerelation == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( passagefromrelation_type ) jcastype ) . casfeatcode_sourcerelation , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for sourceRelation - sets The triple from which the search result was generated.
public string getsubject ( ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_subject == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_subject ) ; }	getter for subject - gets The subject of the triple - always a URI.
public void setsubject ( string v ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_subject == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_subject , v ) ; }	setter for subject - sets The subject of the triple - always a URI.
public string getpredicate ( ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_predicate == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_predicate ) ; }	getter for predicate - gets The predicate of the triple - always a URI.
public void setpredicate ( string v ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_predicate == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_predicate , v ) ; }	setter for predicate - sets The predicate of the triple - always a URI.
public boolean getisobjuri ( ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_isobjuri == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getbooleanvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_isobjuri ) ; }	getter for isObjUri - gets Boolean flag - true of object field is a URI, false otherwise.
public void setisobjuri ( boolean v ) { if ( triple_type . featoktst && ( ( triple_type ) jcastype ) . casfeat_isobjuri == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setbooleanvalue ( addr , ( ( triple_type ) jcastype ) . casfeatcode_isobjuri , v ) ; }	setter for isObjUri - sets Boolean flag - true of object field is a URI, false otherwise.
public queryoperator getoperator ( ) { if ( complexqueryconcept_type . featoktst && ( ( complexqueryconcept_type ) jcastype ) . casfeat_operator == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( queryoperator ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( complexqueryconcept_type ) jcastype ) . casfeatcode_operator ) ) ) ; }	getter for operator - gets The operator associated with this concept.
public void setoperator ( queryoperator v ) { if ( complexqueryconcept_type . featoktst && ( ( complexqueryconcept_type ) jcastype ) . casfeat_operator == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( complexqueryconcept_type ) jcastype ) . casfeatcode_operator , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for operator - sets The operator associated with this concept.
public fslist getoperatorargs ( ) { if ( complexqueryconcept_type . featoktst && ( ( complexqueryconcept_type ) jcastype ) . casfeat_operatorargs == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fslist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( complexqueryconcept_type ) jcastype ) . casfeatcode_operatorargs ) ) ) ; }	getter for operatorArgs - gets The operator arguments in a complex query concept.
public void setoperatorargs ( fslist v ) { if ( complexqueryconcept_type . featoktst && ( ( complexqueryconcept_type ) jcastype ) . casfeat_operatorargs == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( complexqueryconcept_type ) jcastype ) . casfeatcode_operatorargs , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for operatorArgs - sets The operator arguments in a complex query concept.
public concept getconcept ( ) { if ( conceptmention_type . featoktst && ( ( conceptmention_type ) jcastype ) . casfeat_concept == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( concept ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( conceptmention_type ) jcastype ) . casfeatcode_concept ) ) ) ; }	getter for concept - gets The abstract concept that the text span conveys.
public double getscore ( ) { if ( conceptmention_type . featoktst && ( ( conceptmention_type ) jcastype ) . casfeat_score == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getdoublevalue ( addr , ( ( conceptmention_type ) jcastype ) . casfeatcode_score ) ; }	getter for score - gets The confidence score that the concept mention matches the concept.
public string gettext ( ) { if ( candidateansweroccurrence_type . featoktst && ( ( candidateansweroccurrence_type ) jcastype ) . casfeat_text == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( candidateansweroccurrence_type ) jcastype ) . casfeatcode_text ) ; }	getter for text - gets The candidate answer string.
public void settext ( string v ) { if ( candidateansweroccurrence_type . featoktst && ( ( candidateansweroccurrence_type ) jcastype ) . casfeat_text == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( candidateansweroccurrence_type ) jcastype ) . casfeatcode_text , v ) ; }	setter for text - sets The candidate answer string.
public string getid ( ) { if ( concepttype_type . featoktst && ( ( concepttype_type ) jcastype ) . casfeat_id == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( concepttype_type ) jcastype ) . casfeatcode_id ) ; }	getter for id - gets The id of the concept type.
public void setid ( string v ) { if ( concepttype_type . featoktst && ( ( concepttype_type ) jcastype ) . casfeat_id == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( concepttype_type ) jcastype ) . casfeatcode_id , v ) ; }	setter for id - sets The id of the concept type.
public string getname ( ) { if ( concepttype_type . featoktst && ( ( concepttype_type ) jcastype ) . casfeat_name == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( concepttype_type ) jcastype ) . casfeatcode_name ) ; }	getter for name - gets A human readable concept label.
public string getabbreviation ( ) { if ( concepttype_type . featoktst && ( ( concepttype_type ) jcastype ) . casfeat_abbreviation == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( concepttype_type ) jcastype ) . casfeatcode_abbreviation ) ; }	getter for abbreviation - gets The abbreviation of the name label.
public void setabbreviation ( string v ) { if ( concepttype_type . featoktst && ( ( concepttype_type ) jcastype ) . casfeat_abbreviation == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( concepttype_type ) jcastype ) . casfeatcode_abbreviation , v ) ; }	setter for abbreviation - sets The abbreviation of the name label.
public void setconcept ( concept v ) { if ( conceptsearchresult_type . featoktst && ( ( conceptsearchresult_type ) jcastype ) . casfeat_concept == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( conceptsearchresult_type ) jcastype ) . casfeatcode_concept , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for concept - sets The relevant concept searched in the ontology.
public fslist getvariants ( ) { if ( answer_type . featoktst && ( ( answer_type ) jcastype ) . casfeat_variants == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fslist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( answer_type ) jcastype ) . casfeatcode_variants ) ) ) ; }	getter for variants - gets List of candidate answer variants that were merged into this final answer.
public void setvariants ( fslist v ) { if ( answer_type . featoktst && ( ( answer_type ) jcastype ) . casfeat_variants == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( answer_type ) jcastype ) . casfeatcode_variants , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for variants - sets List of candidate answer variants that were merged into this final answer.
public stringlist getnamedentitytypes ( ) { if ( queryconcept_type . featoktst && ( ( queryconcept_type ) jcastype ) . casfeat_namedentitytypes == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( stringlist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( queryconcept_type ) jcastype ) . casfeatcode_namedentitytypes ) ) ) ; }	getter for namedEntityTypes - gets List of Named Entity types associated with this concept.
public void setnamedentitytypes ( stringlist v ) { if ( queryconcept_type . featoktst && ( ( queryconcept_type ) jcastype ) . casfeat_namedentitytypes == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( queryconcept_type ) jcastype ) . casfeatcode_namedentitytypes , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for namedEntityTypes - sets List of Named Entity types associated with this concept.
public string getconcepttype ( ) { if ( queryconcept_type . featoktst && ( ( queryconcept_type ) jcastype ) . casfeat_concepttype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( queryconcept_type ) jcastype ) . casfeatcode_concepttype ) ; }	getter for conceptType - gets The type of this concept.
public void setconcepttype ( string v ) { if ( queryconcept_type . featoktst && ( ( queryconcept_type ) jcastype ) . casfeat_concepttype == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( queryconcept_type ) jcastype ) . casfeatcode_concepttype , v ) ; }	setter for conceptType - sets The type of this concept.
public fslist getoccurrences ( ) { if ( candidateanswervariant_type . featoktst && ( ( candidateanswervariant_type ) jcastype ) . casfeat_occurrences == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fslist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( candidateanswervariant_type ) jcastype ) . casfeatcode_occurrences ) ) ) ; }	getter for occurrences - gets The occurrences of this variant.
public void setoccurrences ( fslist v ) { if ( candidateanswervariant_type . featoktst && ( ( candidateanswervariant_type ) jcastype ) . casfeat_occurrences == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( candidateanswervariant_type ) jcastype ) . casfeatcode_occurrences , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for occurrences - sets The occurrences of this variant.
public fslist getconcepts ( ) { if ( abstractquery_type . featoktst && ( ( abstractquery_type ) jcastype ) . casfeat_concepts == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( fslist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( abstractquery_type ) jcastype ) . casfeatcode_concepts ) ) ) ; }	getter for concepts - gets The list of query concepts that make up this abstract query.
public void setconcepts ( fslist v ) { if ( abstractquery_type . featoktst && ( ( abstractquery_type ) jcastype ) . casfeat_concepts == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( abstractquery_type ) jcastype ) . casfeatcode_concepts , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for concepts - sets The list of query concepts that make up this abstract query.
public string getoriginaltext ( ) { if ( atomicqueryconcept_type . featoktst && ( ( atomicqueryconcept_type ) jcastype ) . casfeat_originaltext == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( atomicqueryconcept_type ) jcastype ) . casfeatcode_originaltext ) ; }	getter for originalText - gets The lexical string in the question.
public void setoriginaltext ( string v ) { if ( atomicqueryconcept_type . featoktst && ( ( atomicqueryconcept_type ) jcastype ) . casfeat_originaltext == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( atomicqueryconcept_type ) jcastype ) . casfeatcode_originaltext , v ) ; }	setter for originalText - sets The lexical string in the question.
public stringlist getargs ( ) { if ( queryoperator_type . featoktst && ( ( queryoperator_type ) jcastype ) . casfeat_args == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return ( stringlist ) ( jcastype . ll_cas . ll_getfsforref ( jcastype . ll_cas . ll_getrefvalue ( addr , ( ( queryoperator_type ) jcastype ) . casfeatcode_args ) ) ) ; }	getter for args - gets The arguments for the operator.
public void setargs ( stringlist v ) { if ( queryoperator_type . featoktst && ( ( queryoperator_type ) jcastype ) . casfeat_args == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setrefvalue ( addr , ( ( queryoperator_type ) jcastype ) . casfeatcode_args , jcastype . ll_cas . ll_getfsref ( v ) ) ; }	setter for args - sets The arguments for the operator.
public string getlabel ( ) { if ( semanticrole_type . featoktst && ( ( semanticrole_type ) jcastype ) . casfeat_label == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; return jcastype . ll_cas . ll_getstringvalue ( addr , ( ( semanticrole_type ) jcastype ) . casfeatcode_label ) ; }	getter for label - gets The semantic role label.
public void setlabel ( string v ) { if ( semanticrole_type . featoktst && ( ( semanticrole_type ) jcastype ) . casfeat_label == null ) jcastype . jcas . throwfeatmissing ( str_ , str_ ) ; jcastype . ll_cas . ll_setstringvalue ( addr , ( ( semanticrole_type ) jcastype ) . casfeatcode_label , v ) ; }	setter for label - sets The semantic role label.
public int nextclearbit ( int index ) { int i = index > > num_ ; if ( i >= wlen ) return - num_ ; int subindex = index & num_ ;	Find the next clear bit in the bit set.
public boolean set ( int index ) { int wordnum = index > > num_ ;	Thread safe set operation that will set the bit if and only if the bit wasnot previously set.
protected void freebuffer ( final bytebuffer buffer ) throws ioexception { if ( buffer == null ) { return ; } if ( unmap_supported ) { try { accesscontroller . doprivileged ( new privilegedexceptionaction < void > ( ) { @ override public void run ( ) throws exception { final method getcleanermethod = buffer . getclass ( ) . getmethod ( str_ ) ; getcleanermethod . setaccessible ( bool_ ) ; final object cleaner = getcleanermethod . invoke ( buffer ) ; if ( cleaner != null ) { cleaner . getclass ( ) . getmethod ( str_ ) . invoke ( cleaner ) ; } return null ; } } ) ; } catch ( privilegedactionexception e ) { final ioexception ioe = new ioexception ( str_ ) ; ioe . initcause ( e . getcause ( ) ) ; throw ioe ; } } }	This code was copied form MMAPDirectory in Lucene.
public cachevalue newinstance ( cachedirectory directory , string filename ) { return newinstance ( directory , filename , getcacheblocksize ( directory , filename ) ) ; }	Creates a new instance of CacheValue, the cache capacity should be used forthe given file.
private static object [ ] rehash ( final object [ ] values , final int newsize ) { object [ ] newarray = new object [ newsize ] ; for ( object value : values ) { if ( value == null ) { continue ; } newarray [ predictedposition ( newarray , value , value . hashcode ( ) ) ] = value ; } return newarray ; }	Rebuild the backing array with a different size.
public string tohelm2 ( ) { stringbuilder notation = new stringbuilder ( ) ; for ( int i = num_ ; i < listmonomernotations . size ( ) ; i ++ ) { notation . append ( listmonomernotations . get ( i ) . tohelm2 ( ) + str_ ) ; } notation . setlength ( notation . length ( ) - num_ ) ; return notation . tostring ( ) ; }	method to generate a valid HELM2 of this object.
private boolean checkbracketsparenthesis ( ) { log . debug ( str_ ) ; if ( bracketcounteropen == bracketcounterclose && parenthesiscounteropen == parenthesiscounterclose && curlybracketcounteropen == curlybracketcounterclose ) { return bool_ ; } return bool_ ; }	method to check if all open brackets are closed.
private void adddetails ( string str ) throws notationexception { string [ ] parts = str . split ( str_ ) ; sourceunit = parts [ num_ ] . split ( str_ ) [ num_ ] . touppercase ( ) ; targetunit = parts [ num_ ] . split ( str_ ) [ num_ ] . touppercase ( ) ; rgroupsource = parts [ num_ ] . split ( str_ ) [ num_ ] ; rgrouptarget = parts [ num_ ] . split ( str_ ) [ num_ ] ; pattern r = pattern . compile ( str_ , pattern . case_insensitive ) ; pattern pair = pattern . compile ( str_ , pattern . case_insensitive ) ; matcher mr = r . matcher ( rgroupsource ) ; matcher mpair = pair . matcher ( rgrouptarget ) ; if ( mr . matches ( ) ) { rgroupsource = rgroupsource . touppercase ( ) ; } else { rgroupsource = rgroupsource . tolowercase ( ) ; } if ( mpair . matches ( ) ) { rgrouptarget = rgrouptarget . tolowercase ( ) ; } else { rgrouptarget = rgrouptarget . touppercase ( ) ; } }	method to set the details of the current connection.
public string tohelm2 ( ) { if ( isannotationtrue ( ) ) { return sourceid . getid ( ) + str_ + targetid . getid ( ) + str_ + sourceunit + str_ + rgroupsource + str_ + targetunit + str_ + rgrouptarget + str_ + annotation + str_ ; } else { return sourceid . getid ( ) + str_ + targetid . getid ( ) + str_ + sourceunit + str_ + rgroupsource + str_ + targetunit + str_ + rgrouptarget ; } }	method to get a valid HELM2 of the connection notation.
public void addelement ( string str , string type , double one , double two , boolean interval , boolean isdefault ) throws notationexception { this . elements . add ( validationmethod . decidewhichmonomernotationingroup ( str , type , one , two , interval , isdefault ) ) ; }	method to add a single element to the group.
public boolean checkpolymerid ( string polymerid ) { log . debug ( str_ + polymerid ) ; string pattern = str_ ; pattern p = pattern . compile ( pattern , pattern . case_insensitive ) ; matcher m = p . matcher ( polymerid ) ; if ( m . matches ( ) ) { log . debug ( str_ + polymerid ) ; return bool_ ; } log . debug ( str_ + polymerid ) ; return bool_ ; }	method to validate the polymer id in the simple polymer section the id canbe peptide, rna, chem or blob.
public boolean checkpolymeridconnection ( string polymerid ) { log . debug ( str_ ) ; string ratio = str_ ; string id = str_ ; string pattern = str_ + id + ratio + str_ + id + ratio + str_ + ratio + str_ + id + ratio + str_ ; pattern p = pattern . compile ( pattern , pattern . case_insensitive ) ; matcher m = p . matcher ( polymerid ) ; if ( m . matches ( ) ) { log . debug ( str_ ) ; return bool_ ; } log . debug ( str_ + polymerid ) ; return bool_ ; }	method to validate the polymer id in the connection section the id can bepeptide, rna, chem or blob the ratio + range was also included, theambiguity is also proven.
public boolean checkdetailsconnections ( string d ) { log . debug ( str_ ) ; string group = str_ ; string partone = str_ + group + str_ ; string parttwo = str_ ; string element = partone + str_ + parttwo ; string patternconnection = element + str_ + element ; string hydrogenbondpartner = partone + str_ ; string hydrogenbondpattern = hydrogenbondpartner + str_ + hydrogenbondpartner ; pattern pconnection = pattern . compile ( patternconnection , pattern . case_insensitive ) ; matcher mconnection = pconnection . matcher ( d ) ; pattern phydrogen = pattern . compile ( hydrogenbondpattern , pattern . case_insensitive ) ; matcher mhydrogen = phydrogen . matcher ( d ) ; if ( mconnection . matches ( ) || mhydrogen . matches ( ) ) { log . debug ( str_ ) ; return bool_ ; } log . debug ( str_ + d ) ; return bool_ ; }	method to validate the details about the connections; hydrogen bonds arehere included.
public boolean checkgroupid ( string d ) { pattern p = pattern . compile ( str_ , pattern . case_insensitive ) ; matcher m = p . matcher ( d ) ; log . debug ( str_ ) ; if ( m . matches ( ) ) { log . debug ( str_ ) ; return bool_ ; } log . debug ( str_ ) ; return bool_ ; }	method to validate the group id.
public boolean checkrepeating ( string str ) { string pattern = str_ ; if ( str . matches ( pattern ) ) { return bool_ ; } return bool_ ; }	method to validate the repeating section it can be a single number or arange.
public boolean ispeptideorrna ( ) throws simplepolymersectionexception { if ( polymerelements . size ( ) >= num_ ) { if ( polymerelements . get ( polymerelements . size ( ) - num_ ) . matches ( str_ ) ) { return bool_ ; } return bool_ ; } else { throw new simplepolymersectionexception ( str_ ) ; } }	method to check if the last added polymer element is a peptide or a rna.
protected string tojson ( ) { objectmapper mapper = new objectmapper ( ) ; try { string jsoninstring = mapper . writevalueasstring ( notationcontainer ) ; jsoninstring = mapper . writerwithdefaultprettyprinter ( ) . writevalueasstring ( notationcontainer ) ; return jsoninstring ; } catch ( exception e ) { e . printstacktrace ( ) ; } return null ; }	method to generate a JSON-Object from the NotationContainer.
public polymernotation getsimplepolymer ( string string ) { for ( polymernotation polymer : listofpolymers ) { if ( polymer . getpolymerid ( ) . getid ( ) . equals ( string ) ) { return polymer ; } } return null ; }	method to get the simple polymer type.
@ jsonignore public groupingnotation getcurrentgroupingnotation ( ) { if ( listofgroupings . size ( ) == num_ ) { return null ; } return listofgroupings . get ( listofgroupings . size ( ) - num_ ) ; }	method to get the current grouping notation.
public string tohelm2 ( ) { string output = str_ ; output += polymertohelm2 ( ) + str_ ; output += connectiontohelm2 ( ) + str_ ; output += groupingtohelm2 ( ) + str_ ; output += annotationtohelm2 ( ) + str_ ; output += str_ ; return output ; }	method to generate for all sections a HELM2 string.
public string polymertohelm2 ( ) { stringbuilder notation = new stringbuilder ( ) ; for ( int i = num_ ; i < listofpolymers . size ( ) ; i ++ ) { if ( listofpolymers . get ( i ) . isannotationhere ( ) ) { notation . append ( listofpolymers . get ( i ) . getpolymerid ( ) + str_ + listofpolymers . get ( i ) . tohelm2 ( ) + str_ + listofpolymers . get ( i ) . getannotation ( ) + str_ ) ; } else { notation . append ( listofpolymers . get ( i ) . getpolymerid ( ) + str_ + listofpolymers . get ( i ) . tohelm2 ( ) + str_ + str_ ) ; } } notation . setlength ( notation . length ( ) - num_ ) ; return notation . tostring ( ) ; }	method to generate a valid HELM2 string for the first section.
public string connectiontohelm2 ( ) { if ( listofconnections . size ( ) == num_ ) { return str_ ; } stringbuilder notation = new stringbuilder ( ) ; for ( int i = num_ ; i < listofconnections . size ( ) ; i ++ ) { notation . append ( listofconnections . get ( i ) . tohelm2 ( ) + str_ ) ; } notation . setlength ( notation . length ( ) - num_ ) ; return notation . tostring ( ) ; }	method to generate a valid HELM2 string for the second section.
public string groupingtohelm2 ( ) { if ( listofgroupings . size ( ) == num_ ) { return str_ ; } stringbuilder notation = new stringbuilder ( ) ; for ( int i = num_ ; i < listofgroupings . size ( ) ; i ++ ) { notation . append ( listofgroupings . get ( i ) . tohelm2 ( ) + str_ ) ; } notation . setlength ( notation . length ( ) - num_ ) ; return notation . tostring ( ) ; }	method to generate a valid HELM2 string for the third section.
public string annotationtohelm2 ( ) { if ( ! ( annotationsection . isempty ( ) ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < annotationsection . size ( ) ; i ++ ) { sb . append ( annotationsection . get ( i ) . tohelm2 ( ) + str_ ) ; } sb . setlength ( sb . length ( ) - num_ ) ; return sb . tostring ( ) ; } return str_ ; }	method to generate a valid HELM2 string for the fourth section.
@ jsonignore public list < string > getpolymerandgroupingids ( ) { list < string > listofids = new arraylist < string > ( ) ; for ( polymernotation polymer : listofpolymers ) { listofids . add ( polymer . getpolymerid ( ) . getid ( ) ) ; } for ( groupingnotation grouping : listofgroupings ) { listofids . add ( grouping . getgroupid ( ) . getid ( ) ) ; } return listofids ; }	method to get the ID's from all polymers and groups.
@ jsonignore public polymernotation getpolymernotation ( string id ) { for ( polymernotation polymer : listofpolymers ) { if ( polymer . getpolymerid ( ) . getid ( ) . equals ( id ) ) { return polymer ; } } return null ; }	method to get a specific polymer by its id.
private void setpolymerelements ( ) { if ( polymerid instanceof rnaentity || polymerid instanceof peptideentity ) { this . polymerelements = new polymerlistelements ( polymerid ) ; } else { this . polymerelements = new polymersingleelements ( polymerid ) ; } }	method to generate the right PolymerElements, in the case of Chem and Blobonly one Monomer is allowed.
public string doconvert ( string str ) {	method to convert the given string into the HELM2 format.
public void setannotation ( string str ) { if ( str != null ) { annotation = str ; isannotationhere = bool_ ; } else { annotation = null ; isannotationhere = bool_ ; } }	method to add annotation to this monomer.
public void setcount ( string str ) { isdefault = bool_ ; if ( str . equals ( str_ ) ) { isdefault = bool_ ; } count = str ; }	method to change the default count of one to the user-defined.
public static monomernotation decidewhichmonomernotation ( string str , string type ) throws notationexception { monomernotation mon ; if ( str . startswith ( str_ ) && str . endswith ( str_ ) ) { string str2 = str . substring ( num_ , str . length ( ) - num_ ) ; pattern patternand = pattern . compile ( str_ ) ; pattern patternor = pattern . compile ( str_ ) ; if ( patternand . matcher ( str ) . find ( ) ) { mon = new monomernotationgroupmixture ( str2 , type ) ; } else if ( patternor . matcher ( str ) . find ( ) ) { mon = new monomernotationgroupor ( str2 , type ) ; } else { if ( str . contains ( str_ ) ) { mon = new monomernotationlist ( str2 , type ) ; } else { if ( type == str_ ) { mon = new monomernotationunitrna ( str2 , type ) ; } else { if ( str2 . length ( ) > num_ ) { if ( ! ( str2 . startswith ( str_ ) && str2 . endswith ( str_ ) ) ) { throw new notationexception ( str_ + str ) ; } } mon = new monomernotationunit ( str2 , type ) ; } } } } else { if ( type == str_ ) {	method to decide which of the MonomerNotation classes should beinitialized.
public static monomernotationgroupelement decidewhichmonomernotationingroup ( string str , string type , double one , double two , boolean interval , boolean isdefault ) throws notationexception { monomernotation element ; element = decidewhichmonomernotation ( str , type ) ; if ( interval ) { return new monomernotationgroupelement ( element , one , two ) ; } else { return new monomernotationgroupelement ( element , one , isdefault ) ; } }	method to decide which of the two Constructors ofMonomerNotationGroupElement should be called.
public static helmentity decidewhichentity ( string str ) throws notationexception { helmentity item ; if ( str . touppercase ( ) . matches ( str_ ) ) { item = new peptideentity ( str . touppercase ( ) ) ; } else if ( str . touppercase ( ) . matches ( str_ ) ) { item = new rnaentity ( str . touppercase ( ) ) ; } else if ( str . touppercase ( ) . matches ( str_ ) ) { item = new blobentity ( str . touppercase ( ) ) ; } else if ( str . touppercase ( ) . matches ( str_ ) ) { item = new chementity ( str . touppercase ( ) ) ; } else if ( str . touppercase ( ) . matches ( str_ ) ) { item = new groupentity ( str . touppercase ( ) ) ; } else { throw new notationexception ( str_ + str ) ; } return item ; }	method to decide which of the Entities classes should be initialized.
public list < double > getvalue ( ) { if ( this . isinterval ) { return new arraylist < double > ( arrays . aslist ( numberone , numbertwo ) ) ; } else { return new arraylist < double > ( arrays . aslist ( numberone ) ) ; } }	method to get the ratio or the interval of this group, in the case of aninterval it returns a list of two values.
public void parse ( string test ) throws exceptionstate { parser = new statemachineparser ( ) ; test = test . trim ( ) ; if ( test . substring ( test . length ( ) - num_ ) . matches ( str_ ) || test . substring ( test . length ( ) - num_ ) . matches ( str_ ) ) { for ( int i = num_ ; i < test . length ( ) - num_ ; i ++ ) { parser . doaction ( test . charat ( i ) ) ; } if ( ! ( parser . getstate ( ) instanceof finalstate ) ) { log . error ( str_ ) ; throw new finalstateexception ( str_ ) ; } } else { log . error ( str_ ) ; throw new notvalidhelm2exception ( str_ ) ; } }	method to parse the given HELM2 string in the case of an invalid HELM2 notation exception is thrown.
private void setrnacontents ( string str ) throws notationexception { string [ ] list ;	method to set for each nucleotide the sugar, the base and the phosphat.
private void defineambiguity ( string a ) throws notationexception { pattern patternand = pattern . compile ( str_ ) ; matcher m = patternand . matcher ( a ) ; if ( m . find ( ) ) { setambiguity ( new groupingmixture ( a ) ) ; } else { setambiguity ( new groupingor ( a ) ) ; } }	method to add ambiguity to the group.
aworkerthreadstatistics getstatistics ( ) { return new aworkerthreadstatistics ( getstate ( ) , getid ( ) , stat_numtasksexecuted , stat_numsharedtasksexecuted , stat_numsteals , stat_numexceptions , stat_numparks , stat_numfalsealarmunparks , stat_numsharedqueueswitches , stat_numlocalsubmits , localqueue . approximatesize ( ) ) ; }	This method returns an approximation of this thread's execution statistics for the entire period since the thread was started.
public static < n , e extends aedge < n > > adigraph < n , e > create ( collection < e > edges ) { final set < n > result = new hashset < > ( ) ; for ( e edge : edges ) { result . add ( edge . getfrom ( ) ) ; result . add ( edge . getto ( ) ) ; } return create ( result , edges ) ; }	This is a convenience factory method that extracts the list of nodes from the edges.
public static < n , e extends aedge < n > > adigraph < n , e > create ( collection < n > nodes , collection < e > edges ) { final object [ ] nodearr = new object [ nodes . size ( ) ] ; final aedge [ ] edgearr = new aedge [ edges . size ( ) ] ; int idx = num_ ; for ( n node : nodes ) { nodearr [ idx ] = node ; idx += num_ ; } idx = num_ ; for ( e edge : edges ) { edgearr [ idx ] = edge ; idx += num_ ; } return new adigraph < n , e > ( nodearr , edgearr ) ; }	This factory method creates a graph with the given nodes and edges.
private void initpathsinternal ( ) { synchronized ( lock ) { if ( _incomingpathsinternal == null ) { amap < n , alist < aedgepath < n , e > > > incomingpaths = ahashmap . empty ( ) ;	This method does the reachability analysis in a way that is useful for many other methods.
public list < n > sortednodesbyreachability ( ) throws agraphcircularityexception { if ( hascycles ( ) ) { throw new agraphcircularityexception ( ) ; } final object [ ] result = new object [ nodes . length ] ; int nextidx = num_ ; final set < n > unprocessed = new hashset < > ( ) ; for ( object node : nodes ) {	A directed graph defines a partial order through 'reachability', and this method sorts the graph's nodes based on thatpartial order.
public void subscribe ( final string pattern , final class < ? > clazz , final string methodname ) throws nosuchmethodexception { this . subscribe ( pattern , new functionobject9 ( this , clazz , methodname ) ) ; }	Subscribes a static method to a service name pattern.
public int subscribe_count ( final string pattern ) throws invalidinputexception , terminateexception { otpoutputstream subscribe_count = new otpoutputstream ( ) ; subscribe_count . write ( otpexternal . versiontag ) ; final otperlangobject [ ] tuple = { new otperlangatom ( str_ ) , new otperlangstring ( pattern ) } ; subscribe_count . write_any ( new otperlangtuple ( tuple ) ) ; send ( subscribe_count ) ; try { return ( integer ) poll_request ( null , bool_ ) ; } catch ( messagedecodingexception e ) { e . printstacktrace ( api . err ) ; return - num_ ; } }	Determine how may service name pattern subscriptions have occurred.
public void unsubscribe ( final string pattern ) throws invalidinputexception { final string s = this . prefix + pattern ; linkedlist < functioninterface9 > callback_list = this . callbacks . get ( s ) ; if ( callback_list == null ) { throw new invalidinputexception ( ) ; } else { callback_list . removefirst ( ) ; if ( callback_list . isempty ( ) ) { this . callbacks . remove ( s ) ; } } otpoutputstream unsubscribe = new otpoutputstream ( ) ; unsubscribe . write ( otpexternal . versiontag ) ; final otperlangobject [ ] tuple = { new otperlangatom ( str_ ) , new otperlangstring ( pattern ) } ; unsubscribe . write_any ( new otperlangtuple ( tuple ) ) ; send ( unsubscribe ) ; }	Unsubscribes from a service name pattern.
public void return_ ( final integer request_type , final string name , final string pattern , final byte [ ] response_info , final byte [ ] response , final integer timeout , final byte [ ] trans_id , final otperlangpid pid ) throws returnasyncexception , returnsyncexception , invalidinputexception { if ( request_type == api . async ) return_async ( name , pattern , response_info , response , timeout , trans_id , pid ) ; else if ( request_type == api . sync ) return_sync ( name , pattern , response_info , response , timeout , trans_id , pid ) ; else throw new invalidinputexception ( ) ; }	Returns a response from a service request.
public void return_sync ( final string name , final string pattern , byte [ ] response_info , byte [ ] response , integer timeout , final byte [ ] trans_id , final otperlangpid pid ) throws returnsyncexception { try { otpoutputstream return_sync = new otpoutputstream ( ) ; return_sync . write ( otpexternal . versiontag ) ; final otperlangobject [ ] tuple = { new otperlangatom ( str_ ) , new otperlangstring ( name ) , new otperlangstring ( pattern ) , new otperlangbinary ( response_info ) , new otperlangbinary ( response ) , new otperlanguint ( timeout ) , new otperlangbinary ( trans_id ) , pid } ; return_sync . write_any ( new otperlangtuple ( tuple ) ) ; send ( return_sync ) ; } catch ( otperlangrangeexception e ) { e . printstacktrace ( api . err ) ; return ; } throw new returnsyncexception ( ) ; }	Synchronously returns a response from a service request.
public boolean poll ( final int timeout ) throws invalidinputexception , messagedecodingexception , terminateexception { if ( boolean . true == poll_request ( timeout , bool_ ) ) return bool_ ; return bool_ ; }	Blocks to process incoming CloudI service requests.
public void shutdown ( final string reason ) { otpoutputstream shutdown = new otpoutputstream ( ) ; shutdown . write ( otpexternal . versiontag ) ; final otperlangobject [ ] tuple = { new otperlangatom ( str_ ) , new otperlangstring ( reason ) } ; shutdown . write_any ( new otperlangtuple ( tuple ) ) ; send ( shutdown ) ; }	Shutdown the service successfully.
public static < t extends throwable > t forlocalhandling ( t th ) { if ( requiresnonlocalhandling ( th ) ) { aunchecker . throwunchecked ( th ) ; } return th ; }	This method checks if a given Throwable is fit for local handling, returning it if it is andthrowing it otherwise.
private void unlockrunstate ( int oldrunstate , int newrunstate ) { if ( ! u . compareandswapint ( this , runstate , oldrunstate , newrunstate ) ) { object lock = stealcounter ; runstate = newrunstate ;	Unlocks and sets runState to newRunState.
private boolean createworker ( ) { forkjoinworkerthreadfactory fac = factory ; throwable ex = null ; forkjoinworkerthread wt = null ; try { if ( fac != null && ( wt = fac . newthread ( this ) ) != null ) { wt . start ( ) ; return bool_ ; } } catch ( throwable rex ) { ex = rex ; } deregisterworker ( wt , ex ) ; return bool_ ; }	Tries to construct and start one worker.
private void tryaddworker ( long c ) { boolean add = bool_ ; do { long nc = ( ( ac_mask & ( c + ac_unit ) ) | ( tc_mask & ( c + tc_unit ) ) ) ; if ( ctl == c ) { int rs , stop ;	Tries to add one worker, incrementing ctl counts before doingso, relying on createWorker to back out on failure.
final workqueue registerworker ( forkjoinworkerthread wt ) { uncaughtexceptionhandler handler ; wt . setdaemon ( bool_ ) ;	Callback from ForkJoinWorkerThread constructor to establish andrecord its WorkQueue.
final void deregisterworker ( forkjoinworkerthread wt , throwable ex ) { workqueue w = null ; if ( wt != null && ( w = wt . workqueue ) != null ) { workqueue [ ] ws ;	Final callback from terminating worker, as well as upon failureto construct or start a worker.
final void signalwork ( workqueue [ ] ws , workqueue q ) { long c ; int sp , i ; workqueue v ; thread p ; while ( ( c = ctl ) < num_ ) {	Tries to create or activate a worker if too few are active.
final void runworker ( workqueue w ) { w . growarray ( ) ;	Top-level runloop for workers, called by ForkJoinWorkerThread.run.
private boolean awaitwork ( workqueue w , int r ) { if ( w == null || w . qlock < num_ )	Possibly blocks worker w waiting for a task to steal, orreturns false if the worker should terminate.
static workqueue commonsubmitterqueue ( ) { forkjoinpool p = common ; int r = threadlocalrandomhelper . getprobe ( ) ; workqueue [ ] ws ; int m ; return ( p != null && ( ws = p . workqueues ) != null && ( m = ws . length - num_ ) >= num_ ) ? ws [ m & r & sqmask ] : null ; }	Returns common pool queue for an external thread.
final int externalhelpcomplete ( countedcompleter < ? > task , int maxtasks ) { workqueue [ ] ws ; int n ; int r = threadlocalrandomhelper . getprobe ( ) ; return ( ( ws = workqueues ) == null || ( n = ws . length ) == num_ ) ? num_ : helpcomplete ( ws [ ( n - num_ ) & r & sqmask ] , task , maxtasks ) ; }	Performs helpComplete for an external submitter.
public < t > forkjointask < t > submit ( forkjointask < t > task ) { if ( task == null ) throw new nullpointerexception ( ) ; externalpush ( task ) ; return task ; }	Submits a ForkJoinTask for execution.
private static forkjoinpool makecommonpool ( ) { int parallelism = - num_ ; forkjoinworkerthreadfactory factory = null ; uncaughtexceptionhandler handler = null ; try {	Creates and returns the common pool, respecting user settingsspecified via system properties.
public final v get ( long timeout , timeunit unit ) throws interruptedexception , executionexception , timeoutexception { int s ; long nanos = unit . tonanos ( timeout ) ; if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; if ( ( s = status ) >= num_ && nanos > num_ ) { long d = system . nanotime ( ) + nanos ; long deadline = ( d == num_ ) ? num_ : d ;	Waits if necessary for at most the given time for the computationto complete, and then retrieves its result, if available.
public static < e extends throwable > string buildstring ( astatement1 < ajsonserhelper , e > code ) throws e { final bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; code . apply ( new ajsonserhelper ( baos ) ) ; return new string ( baos . tobytearray ( ) , utf_8 ) ; }	This is a convenience method for building simple JSON strings.
@ override public athreadpoolstatistics getstatistics ( ) { final aworkerthreadstatistics [ ] workerstats = new aworkerthreadstatistics [ localqueues . length ] ; for ( int i = num_ ; i < localqueues . length ; i ++ ) {	This method returns an approximation of statistical data for all worker threads since the pool was started.
@ safevarargs public static < t > alist < t > create ( t ... elements ) { return create ( arrays . aslist ( elements ) ) ; }	Creates an AList from a given list of elements.
public alist < t > reverse ( ) { alist < t > remaining = this ; alist < t > result = nil ( ) ; while ( ! remaining . isempty ( ) ) { result = result . cons ( remaining . head ( ) ) ; remaining = remaining . tail ( ) ; } return result ; }	Returns a copy of this AList with elements in reversed order.
public static < t , e extends throwable > boolean forall ( iterable < t > coll , apredicate < ? super t , e > pred ) throws e { for ( t o : coll ) { if ( ! pred . apply ( o ) ) { return bool_ ; } } return bool_ ; }	Matches a predicate against collection elements, and returns true iff it matches them all.
public static < t , r , e extends throwable > r foldleft ( iterable < t > coll , r startvalue , afunction2 < r , ? super t , r , e > f ) throws e { r result = startvalue ; for ( t e : coll ) { result = f . apply ( result , e ) ; } return result ; }	Applies a binary operator to a start value and all elements of this sequence, going left to right.
public static < t , r , e extends throwable > r foldright ( list < t > coll , r startvalue , afunction2 < r , ? super t , r , e > f ) throws e { r result = startvalue ; listiterator < t > i = coll . listiterator ( coll . size ( ) ) ; while ( i . hasprevious ( ) ) { result = f . apply ( result , i . previous ( ) ) ; } return result ; }	Applies a binary operator to a start value and all elements of this list, going left to right.
void push ( runnable task ) { final long _base = unsafe . getlongvolatile ( this , offs_base ) ;	Add a new task to the top of the localQueue, incrementing 'top'.
public static < t > aoption < t > fromnullable ( t nullable ) { return nullable != null ? some ( nullable ) : aoption . < t > none ( ) ; }	This is a convenience method that creates an AOption based on Java conventions.
public static < v > alonghashmap < v > fromkeysandvalues ( iterable < ? extends number > keys , iterable < v > values ) { final iterator < ? extends number > ki = keys . iterator ( ) ; final iterator < v > vi = values . iterator ( ) ; alonghashmap < v > result = alonghashmap . empty ( ) ; while ( ki . hasnext ( ) ) { final number key = ki . next ( ) ; final v value = vi . next ( ) ; result = result . updated ( key . longvalue ( ) , value ) ; } return result ; }	Returns an ALongHashMap initialized from separate 'keys' and 'values' collections.
@ suppresswarnings ( str_ ) public static < k , v > alistmap < k , v > empty ( aequality equality ) { if ( equality == aequality . equals ) return ( alistmap < k , v > ) emptyequals ; if ( equality == aequality . identity ) return ( alistmap < k , v > ) emptyidentity ; return new alistmap < > ( equality ) ; }	Returns an empty AListMap instance with a given equalityForEquals.
public static < k , v > alistmap < k , v > fromkeysandvalues ( aequality equality , iterable < atuple2 < k , v > > elements ) { alistmap < k , v > result = empty ( equality ) ; for ( atuple2 < k , v > el : elements ) { result = result . updated ( el . _1 , el . _2 ) ; } return result ; }	Returns an AHashMap instance with a given equalityForEquals, initializing it from separate 'keys'and 'values' collections.
public static < k , v > alistmap < k , v > fromkeysandvalues ( aequality equality , iterable < k > keys , iterable < v > values ) { final iterator < k > ki = keys . iterator ( ) ; final iterator < v > vi = values . iterator ( ) ; alistmap < k , v > result = empty ( equality ) ; while ( ki . hasnext ( ) ) { final k key = ki . next ( ) ; final v value = vi . next ( ) ; result = result . updated ( key , value ) ; } return result ; }	Returns an AListMap instance with a given equalityForEquals, initializing it from separate 'keys'and 'values' collections.
@ override public set < k > keyset ( ) { return new abstractset < k > ( ) { @ override public iterator < k > iterator ( ) { return new iterator < k > ( ) { final iterator < amapentry < k , v > > it = inner . iterator ( ) ; @ override public boolean hasnext ( ) { return it . hasnext ( ) ; } @ override public k next ( ) { return it . next ( ) . getkey ( ) ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; } @ override public int size ( ) { return inner . size ( ) ; } } ; }	There is usually a performance gain to be had by overriding this default implementation.
private string normalizeresourcename ( string name ) { if ( name . startswith ( str_ ) ) { return str_ + name ; } final int firstprotocol = name . indexof ( str_ ) ; final int secondprotocol = name . indexof ( str_ , firstprotocol + num_ ) ; final int protocol = secondprotocol < num_ ? firstprotocol : secondprotocol ; final int endoffirst = name . lastindexof ( str_ , protocol ) ; if ( endoffirst >= num_ ) { return name . substring ( endoffirst + num_ ) ; } return name ; }	-> hack to undo this.
@ override public string marshal ( boundtype v ) throws exception { class < ? extends object > type = v . getclass ( ) ; if ( ! types . isuserdefinedvaluetype ( type ) ) { throw new illegalargumentexception ( str_ + type + str_ + str_ + str_ ) ; } converter converter = convertutils . lookup ( type ) ; if ( ( converter != null && converter instanceof abstractconverter ) ) { string string = ( string ) convertutils . convert ( v , string . class ) ; if ( string != null ) { return string ; } } return v . tostring ( ) ; }	Marshals the specified user-defined value type object to single XML valuestring representation.
public charsequence subsequence ( int start , int end ) { int len = end - start ; return new stringbuilder ( len ) . append ( toarray ( start , len ) ) ; }	Returns sub sequence.
public static < t extends comparable > binarysearch < t > forlist ( final list < t > list ) { return new binarysearch < t > ( ) { @ override @ suppresswarnings ( { str_ } ) protected int compare ( int index , t element ) { return list . get ( index ) . compareto ( element ) ; } @ override protected int getlastindex ( ) { return list . size ( ) - num_ ; } } ; }	Creates binary search wrapper over a list of comparable elements.
public static < t > binarysearch < t > forlist ( final list < t > list , final comparator < t > comparator ) { return new binarysearch < t > ( ) { @ override @ suppresswarnings ( { str_ } ) protected int compare ( int index , t element ) { return comparator . compare ( list . get ( index ) , element ) ; } @ override protected int getlastindex ( ) { return list . size ( ) - num_ ; } } ; }	Creates binary search wrapper over a list with given comparator.
public static future < boolean > sendmessage ( final email msg ) { if ( asynchronoussend ) { return executor . submit ( new callable < boolean > ( ) { public boolean call ( ) { try { msg . setsentdate ( new date ( ) ) ; msg . send ( ) ; return bool_ ; } catch ( throwable e ) { mailexception me = new mailexception ( str_ , e ) ; logger . error ( str_ , me ) ; return bool_ ; } } } ) ; } else { final stringbuffer result = new stringbuffer ( ) ; try { msg . setsentdate ( new date ( ) ) ; msg . send ( ) ; } catch ( throwable e ) { mailexception me = new mailexception ( str_ , e ) ; logger . error ( str_ , me ) ; result . append ( str_ ) ; } return new future < boolean > ( ) { public boolean cancel ( boolean mayinterruptifrunning ) { return bool_ ; } public boolean iscancelled ( ) { return bool_ ; } public boolean isdone ( ) { return bool_ ; } public boolean get ( ) throws interruptedexception , executionexception { return result . length ( ) == num_ ; } public boolean get ( long timeout , timeunit unit ) throws interruptedexception , executionexception , timeoutexception { return result . length ( ) == num_ ; } } ; } }	Send a JavaMail message.
public void bind ( final routebinding handler ) { final method method = handler . getmethod ( ) ; logger . info ( str_ , appacceptid , defaultversion ) ; list < string > versions = handler . getversions ( ) ; if ( versions == null || versions . isempty ( ) ) { versions = collections . singletonlist ( defaultversion ) ; } for ( final string version : versions ) { final set < method > methods = new hashset < > ( ) ; if ( method == method . any ) { for ( final method m : method . values ( ) ) { methods . add ( m ) ; } } else { methods . add ( method ) ; } for ( final method m : methods ) { final bindingkey key = new bindingkey ( m , version ) ; list < patternroutebinding > b = routebindings . get ( key ) ; if ( b == null ) { b = new arraylist < > ( ) ; routebindings . put ( key , b ) ; } logger . info ( str_ , key , handler . getpath ( ) , handler ) ; addpattern ( handler , b ) ; } } }	Specify a handler that will be called for all HTTP methods.
public void bind ( final filterbinding handler ) { final method method = handler . getmethod ( ) ; final string path = handler . getpath ( ) ; logger . info ( str_ , appacceptid , defaultversion ) ; list < string > versions = handler . getversions ( ) ; if ( versions == null || versions . isempty ( ) ) { versions = collections . singletonlist ( defaultversion ) ; } for ( final string version : versions ) { final set < method > methods = new hashset < > ( ) ; if ( method == method . any ) { for ( final method m : method . values ( ) ) { methods . add ( m ) ; } } else { methods . add ( method ) ; } for ( final method m : methods ) { final bindingkey key = new bindingkey ( m , version ) ; logger . info ( str_ , key , path , handler ) ; list < patternfilterbinding > allfilterbindings = this . filterbindings . get ( key ) ; if ( allfilterbindings == null ) { allfilterbindings = new arraylist < > ( ) ; this . filterbindings . put ( key , allfilterbindings ) ; } boolean found = bool_ ; for ( final patternfilterbinding binding : allfilterbindings ) { if ( binding . getpattern ( ) . pattern ( ) . equals ( handler . getpath ( ) ) ) { binding . addfilter ( handler ) ; found = bool_ ; break ; } } if ( ! found ) { final patternfilterbinding binding = new patternfilterbinding ( handler . getpath ( ) , handler ) ; allfilterbindings . add ( binding ) ; } } } }	Specify a filter handler that will be used to wrap route executions.
@ override protected boolean showtagbody ( string rolename ) { boolean hasanyrole = bool_ ; subject subject = getsubject ( ) ; if ( subject != null ) {	Delimeter that separates role names in tag attribute.
public static int getint ( long l ) { return ( l == null || l > integer . max_value ) ? num_ : l . intvalue ( ) ; }	Converts packing Long Int.
public static string [ ] removeduplicatestrings ( string [ ] array ) { if ( objectkit . isempty ( array ) ) { return array ; } set < string > set = new treeset < string > ( ) ; for ( string element : array ) { set . add ( element ) ; } return tostringarray ( set ) ; }	Remove duplicate Strings from the given array.Also sorts the array, as it uses a TreeSet.
public static string like ( string value ) { return stringpool . percent + strings . nulltoempty ( value ) + stringpool . percent ; }	Stitching LIKE SQL percent.
public void dorun ( ) throws exception { if ( inprogress . compareandset ( bool_ , bool_ ) ) { try { run ( ) ; } finally { inprogress . set ( bool_ ) ; } } else { throw new illegalstateexception ( str_ ) ; } }	Run from the web interface.
public static < t extends model > boolean login ( t user , string password , boolean remember , httpservletrequest request , httpservletresponse response ) { boolean matcher = securitykit . checkpassword ( user . getstr ( str_ ) , user . getstr ( str_ ) , password ) ; if ( matcher ) { securitykit . setloginmember ( request , response , user , remember ) ; } return matcher ; }	Check the user's password, and execute the login request.
public static < t extends model > t getloginuser ( httpservletrequest req ) { return ( t ) req . getsession ( ) . getattribute ( login_session_key ) ; }	Obtain user information from the Session.
public static boolean checkpassword ( string salt , string password , string plainpassword ) { byte [ ] salthex = encodekit . decodehex ( salt ) ; byte [ ] hashpassword = digestskit . sha1 ( plainpassword . getbytes ( ) , salthex , encodekit . hash_interations ) ; return stringutils . equals ( encodekit . encodehex ( hashpassword ) , password ) ; }	Check Password , salt, password, planpassword.
public static < t extends model > void savememberincookie ( t user , boolean save , httpservletrequest request , httpservletresponse response ) { string new_value = getloginkey ( user , requests . remoteip ( request ) , request . getheader ( str_ ) ) ; int max_age = save ? max_age : - num_ ; requests . deletecookie ( request , response , cookie_login , bool_ ) ; requests . setcookie ( request , response , cookie_login , new_value , max_age , bool_ ) ; }	Store user information in a cookie logged in.
private static < t extends model > string getloginkey ( t user , string ip , string user_agent ) { return encrypt ( string . valueof ( user . getnumber ( stringpool . pk_column ) ) + str_ + user . getstr ( str_ ) + str_ + ip + str_ + ( ( user_agent == null ) ? num_ : user_agent . hashcode ( ) ) + str_ + system . currenttimemillis ( ) ) ; }	Generating system user login ID string.
private static cookieuser userforcookie ( string uuid , httpservletrequest request ) { if ( stringutils . isblank ( uuid ) ) { return null ; } string ck = decrypt ( uuid ) ; final string [ ] items = stringutils . split ( ck , str_ ) ; if ( items . length == num_ ) { string ua = request . getheader ( str_ ) ; int ua_code = ( ua == null ) ? num_ : ua . hashcode ( ) ; int old_ua_code = integer . parseint ( items [ num_ ] ) ; if ( ua_code == old_ua_code ) { return new cookieuser ( numberutils . tolong ( items [ num_ ] , - num_ ) , items [ num_ ] , bool_ ) ; } } return null ; }	Obtain user information from the Cookie.
public void to ( webcontext context ) { httpservletrequest request = context . request ( ) ; httpservletresponse response = context . response ( ) ; try { request . getrequestdispatcher ( path ) . forward ( request , response ) ; } catch ( servletexception e ) { throw new uncheckedexception ( e ) ; } catch ( ioexception e ) { throw new uncheckedexception ( e ) ; } }	Forwards HTTP request to the specified path.
public static long param ( httpservletrequest request , string param , long defaultvalue ) { return numberutils . tolong ( request . getparameter ( param ) , defaultvalue ) ; }	Get shaping parameters submitted by the browser.
public static void debug ( string message , object ... args ) { if ( recordcaller ) { loggerfactory . getlogger ( getcallerclassname ( ) ) . debug ( message , args ) ; } else { slf4j . debug ( message , args ) ; } }	Log with DEBUG level.
static callinfo getcallerinformations ( int level ) { stacktraceelement [ ] callstack = thread . currentthread ( ) . getstacktrace ( ) ; stacktraceelement caller = callstack [ level ] ; return new callinfo ( caller . getclassname ( ) , caller . getmethodname ( ) ) ; }	Examine stack trace to get caller.
public static byte [ ] tosimplebytearray ( char [ ] carr ) { byte [ ] barr = new byte [ carr . length ] ; for ( int i = num_ ; i < carr . length ; i ++ ) { barr [ i ] = ( byte ) carr [ i ] ; } return barr ; }	Converts char array into byte array by stripping the high byte of each character.
public static byte [ ] tosimplebytearray ( charsequence charsequence ) { byte [ ] barr = new byte [ charsequence . length ( ) ] ; for ( int i = num_ ; i < barr . length ; i ++ ) { barr [ i ] = ( byte ) charsequence . charat ( i ) ; } return barr ; }	Converts char sequence into byte array.
public static char [ ] tosimplechararray ( byte [ ] barr ) { char [ ] carr = new char [ barr . length ] ; for ( int i = num_ ; i < barr . length ; i ++ ) { carr [ i ] = ( char ) ( barr [ i ] & num_ ) ; } return carr ; }	Converts byte array to char array by simply extending bytes to chars.
public static byte [ ] toasciibytearray ( charsequence charsequence ) { byte [ ] barr = new byte [ charsequence . length ( ) ] ; for ( int i = num_ ; i < barr . length ; i ++ ) { char c = charsequence . charat ( i ) ; barr [ i ] = ( byte ) ( ( int ) ( c <= num_ ? c : num_ ) ) ; } return barr ; }	Converts char sequence into ASCII byte array.
protected static localedata lookuplocaledata ( string code ) { localedata localedata = locales . get ( code ) ; if ( localedata == null ) { string [ ] data = decodelocalecode ( code ) ; localedata = new localedata ( new locale ( data [ num_ ] , data [ num_ ] , data [ num_ ] ) ) ; locales . put ( code , localedata ) ; } return localedata ; }	Lookups for locale data and creates new if it doesn't exist.
public promise < v > in ( int seconds ) { final promise < v > smartfuture = new promise < v > ( ) ; jobsplugin . executor . schedule ( getjobcallingcallable ( smartfuture ) , seconds , timeunit . seconds ) ; return smartfuture ; }	Start this job in several seconds.
public static void crop ( file originalimage , file to , int x1 , int y1 , int x2 , int y2 ) { try { bufferedimage source = imageio . read ( originalimage ) ; string mimetype = str_ ; if ( to . getname ( ) . endswith ( str_ ) ) { mimetype = str_ ; } if ( to . getname ( ) . endswith ( str_ ) ) { mimetype = str_ ; } int width = x2 - x1 ; int height = y2 - y1 ;	Crop an image.
public static future < ? > invoke ( final invocation invocation , long millis ) { return executor . schedule ( invocation , millis , timeunit . milliseconds ) ; }	Run the code in a new thread after a delay.
public static void invokeinthread ( directinvocation invocation ) { boolean retry = bool_ ; while ( retry ) { invocation . run ( ) ; if ( invocation . retry == null ) { retry = bool_ ; } else { try { if ( invocation . retry . task != null ) { invocation . retry . task . get ( ) ; } else { thread . sleep ( invocation . retry . timeout ) ; } } catch ( exception e ) { throw new unexpectedexception ( e ) ; } retry = bool_ ; } } }	Run the code in the same thread than caller.
@ nonnull public restoperations getrestoperations ( ) { final httpclientbuilder builder = httpclientbuilder . create ( ) ; initdefaulthttpclientbuilder ( builder ) ; httprequestfactory = new httpcomponentsclienthttprequestfactory ( builder . build ( ) ) ; final resttemplate resttemplate = new resttemplate ( messageconverters ) ; resttemplate . setrequestfactory ( httprequestfactory ) ; return resttemplate ; }	Returns rest operations object, suitable for use with the specified credentials.
protected void renderajaxerror ( string error , exception e ) { renderjson ( ajaxmessage . error ( error , e ) ) ; }	Rendering errors information, in Json format.
protected < t > void renderajaxforbidden ( string message , t data ) { renderjson ( ajaxmessage . forbidden ( message , data ) ) ; }	In the form of JSON rendering forbidden information.
protected string template ( string view ) { final enumeration < string > attrs = getattrnames ( ) ; final map < string , object > root = maps . newhashmap ( ) ; while ( attrs . hasmoreelements ( ) ) { string attrname = attrs . nextelement ( ) ; root . put ( attrname , getattr ( attrname ) ) ; } return freemarkers . processstring ( view , root ) ; }	Render view as a string.
protected string parsepath ( string currentactionpath , string url ) { if ( url . startswith ( slash ) ) { return url . split ( str_ ) [ num_ ] ; } else if ( ! url . contains ( slash ) ) { return slash + currentactionpath . split ( slash ) [ num_ ] + slash + url . split ( str_ ) [ num_ ] ; } else if ( url . contains ( str_ ) || url . contains ( str_ ) ) { return null ; }	Based on the current path structure is going to jump full Action of the path.
protected void renderdatatables ( class < ? extends model > m_cls ) { dtcriterias criterias = getcriterias ( ) ; preconditions . checknotnull ( criterias , str_ ) ; dtresponse response = criterias . response ( m_cls ) ; renderjson ( response ) ; }	The source of data for rendering the jQuery Datatables.
protected void renderemptydatatables ( dtcriterias criterias ) { preconditions . checknotnull ( criterias , str_ ) ; dtresponse response = dtresponse . build ( criterias , collections . empty_list , num_ , num_ ) ; renderjson ( response ) ; }	rendering the empty datasource.
public void setitems ( list < v > items ) { final list < v > its = items == null ? immutablelist . of ( ) : items ; this . items = its ; getcomboboxcelleditor ( ) . setinput ( items ) ; }	Sets the input items to the underlying ComboBoxCellEditor.
public void to ( webcontext context ) { httpservletresponse response = context . response ( ) ; if ( ! mediatype . isempty ( ) ) { response . setheader ( str_ , mediatype ) ; } if ( status > num_ ) { response . setstatus ( status ) ; } try { response . sendredirect ( response . encoderedirecturl ( url ) ) ; } catch ( ioexception e ) { throw new uncheckedexception ( e ) ; } }	Writes this HTTP response to the specified Web context.
public list < t > list ( injector injector ) { list < t > r = new arraylist < t > ( ) ; for ( injector i = injector ; i != null ; i = i . getparent ( ) ) { for ( entry < key < ? > , binding < ? > > e : i . getbindings ( ) . entryset ( ) ) { if ( e . getkey ( ) . gettypeliteral ( ) . equals ( type ) ) r . add ( ( t ) e . getvalue ( ) . getprovider ( ) . get ( ) ) ; } } return r ; }	Returns all the extension implementations in the specified injector.
public static string currentmethod ( ) { stacktraceelement [ ] ste = new exception ( ) . getstacktrace ( ) ; int ndx = ( ste . length > num_ ) ? num_ : num_ ; return new exception ( ) . getstacktrace ( ) [ ndx ] . tostring ( ) ; }	Returns current method signature.
public static void compactmemory ( ) { try { final byte [ ] [ ] unused = new byte [ num_ ] [ ] ; for ( int i = unused . length ; i -- != num_ ; ) { unused [ i ] = new byte [ num_ ] ; } } catch ( outofmemoryerror ignore ) { } system . gc ( ) ; }	Compacts memory as much as possible by allocating huge memory blockand then forcing garbage collection.
@ nullable public static metricscollection propagate ( metrics metrics ) { final metricscollection metricscollection = getlocalmetricscollection ( ) ; if ( metricscollection != null ) { metricscollection . add ( metrics ) ; } return metricscollection ; }	Propagates metrics entry to the thread local metrics collection, does nothing if local metrics collectionis missing.
public static string encodestring ( string value ) { int estimatedsize = num_ ; final int len = value . length ( ) ;	Encodes a value, so that it won't contain spaces, commas and equal signs.
public static int copy ( inputstream input , outputstream output ) throws ioexception { byte [ ] buffer = new byte [ iobuffersize ] ; int count = num_ ; int read ; while ( bool_ ) { read = input . read ( buffer , num_ , iobuffersize ) ; if ( read == - num_ ) { break ; } output . write ( buffer , num_ , read ) ; count += read ; } return count ; }	Copies input stream to output stream using buffer.
public static int copy ( inputstream input , outputstream output , int bytecount ) throws ioexception { byte buffer [ ] = new byte [ iobuffersize ] ; int count = num_ ; int read ; while ( bytecount > num_ ) { if ( bytecount < iobuffersize ) { read = input . read ( buffer , num_ , bytecount ) ; } else { read = input . read ( buffer , num_ , iobuffersize ) ; } if ( read == - num_ ) { break ; } bytecount -= read ; count += read ; output . write ( buffer , num_ , read ) ; } return count ; }	Copies specified number of bytes from input stream to output stream using buffer.
public static void copy ( inputstream input , writer output ) throws ioexception { copy ( input , output , const . default_encoding ) ; }	Copies input stream to writer using buffer.
public static int copy ( reader input , writer output ) throws ioexception { char [ ] buffer = new char [ iobuffersize ] ; int count = num_ ; int read ; while ( ( read = input . read ( buffer , num_ , iobuffersize ) ) >= num_ ) { output . write ( buffer , num_ , read ) ; count += read ; } output . flush ( ) ; return count ; }	Copies reader to writer using buffer.Streams don't have to be wrapped to buffered, since copying is already optimized.
public static int copy ( reader input , writer output , int charcount ) throws ioexception { char buffer [ ] = new char [ iobuffersize ] ; int count = num_ ; int read ; while ( charcount > num_ ) { if ( charcount < iobuffersize ) { read = input . read ( buffer , num_ , charcount ) ; } else { read = input . read ( buffer , num_ , iobuffersize ) ; } if ( read == - num_ ) { break ; } charcount -= read ; count += read ; output . write ( buffer , num_ , read ) ; } return count ; }	Copies specified number of characters from reader to writer using buffer.
public static void copy ( reader input , outputstream output ) throws ioexception { copy ( input , output , const . default_encoding ) ; }	Copies reader to output stream using buffer.
public static void copy ( reader input , outputstream output , string encoding ) throws ioexception { writer out = new outputstreamwriter ( output , encoding ) ; copy ( input , out ) ; out . flush ( ) ; }	Copies reader to output stream using buffer and specified encoding.
public static boolean compare ( inputstream input1 , inputstream input2 ) throws ioexception { if ( ! ( input1 instanceof bufferedinputstream ) ) { input1 = new bufferedinputstream ( input1 ) ; } if ( ! ( input2 instanceof bufferedinputstream ) ) { input2 = new bufferedinputstream ( input2 ) ; } int ch = input1 . read ( ) ; while ( ch != - num_ ) { int ch2 = input2 . read ( ) ; if ( ch != ch2 ) { return bool_ ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == - num_ ) ; }	Compares the content of two byte streams.
public static boolean compare ( reader input1 , reader input2 ) throws ioexception { if ( ! ( input1 instanceof bufferedreader ) ) { input1 = new bufferedreader ( input1 ) ; } if ( ! ( input2 instanceof bufferedreader ) ) { input2 = new bufferedreader ( input2 ) ; } int ch = input1 . read ( ) ; while ( ch != - num_ ) { int ch2 = input2 . read ( ) ; if ( ch != ch2 ) { return bool_ ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == - num_ ) ; }	Compares the content of two character streams.
@ suppresswarnings ( str_ ) public t apply ( t io ) { logger . debug ( str_ ) ; try { for ( int i = num_ ; i < stages . size ( ) ; i ++ ) { object stage = stages . get ( i ) ; string name = names . get ( stage ) ; logger . debug ( str_ + i + ( ( name != null && ! name . isempty ( ) ) ? str_ + name + str_ : str_ ) + str_ ) ; if ( stage instanceof function ) { if ( ( io = ( ( function < t , t > ) stage ) . apply ( io ) ) == null ) { return io ; } } else if ( stage instanceof predicate ) { if ( ! ( ( predicate < t > ) stage ) . apply ( io ) ) { return io ; } } } return io ; } finally { logger . debug ( str_ ) ; } }	Starts pipeline with the specified stream object that flows through thispipeline.
public static string sql ( string groupnameandsqlid ) { final sqlnode sqlnode = sql_map . get ( groupnameandsqlid ) ; return sqlnode == null ? stringpool . empty : sqlnode . sql ; }	To obtain a configuration of SQL.
@ suppresswarnings ( str_ ) public static < t > t unmarshal ( string src , class < t > clazz ) { t result = null ; try { unmarshaller avm = jaxbcontext . newinstance ( clazz ) . createunmarshaller ( ) ; result = ( t ) avm . unmarshal ( new stringreader ( src ) ) ; } catch ( jaxbexception e ) { throwables . propagate ( e ) ; } return result ; }	string -> object.
public static void unzip ( file zipfile , file destdir , string ... patterns ) throws ioexception { zipfile zip = new zipfile ( zipfile ) ; enumeration zipentries = zip . entries ( ) ; while ( zipentries . hasmoreelements ( ) ) { zipentry entry = ( zipentry ) zipentries . nextelement ( ) ; string entryname = entry . getname ( ) ; if ( patterns != null && patterns . length > num_ ) { if ( wildcard . matchpathone ( entryname , patterns ) == - num_ ) { continue ; } } file file = ( destdir != null ) ? new file ( destdir , entryname ) : new file ( entryname ) ; if ( entry . isdirectory ( ) ) { if ( ! file . mkdirs ( ) ) { if ( ! file . isdirectory ( ) ) { throw new ioexception ( str_ + file ) ; } } } else { file parent = file . getparentfile ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( ! parent . mkdirs ( ) ) { if ( ! file . isdirectory ( ) ) { throw new ioexception ( str_ + parent ) ; } } } inputstream in = zip . getinputstream ( entry ) ; outputstream out = null ; try { out = new fileoutputstream ( file ) ; streamutil . copy ( in , out ) ; } finally { streamutil . close ( out ) ; streamutil . close ( in ) ; } } } close ( zip ) ; }	Extracts zip file to the target directory.
public static permissiondialogfragment getinstance ( permbean bean , int requestcode ) { if ( bean == null ) throw new nullpointerexception ( str_ ) ; bundle extras = new bundle ( num_ ) ;	A static dialog fragment instance creator method.
@ override public void onresume ( ) { super . onresume ( ) ; getdialog ( ) . setonkeylistener ( new dialoginterface . onkeylistener ( ) { @ override public boolean onkey ( dialoginterface dialog , int keycode , keyevent keyevent ) { return keycode != keyevent . action_down ; } } ) ; }	Work around for dialog not to dismiss on back button press.
public static void addcorevaluetype ( class < ? > clazz , converter converter ) { convertutils . register ( converter , clazz ) ; values . add ( clazz ) ; }	Adds supported core value type.
public static boolean match ( string regex , string value ) { pattern pattern = pattern . compile ( regex ) ; return pattern . matcher ( value ) . find ( ) ; }	Matches the regular expression.
public static boolean ismobile ( string value ) { string check = str_ ; return match ( check , pattern . case_insensitive , value ) ; }	Phone number verification.
public static boolean isphone ( string value ) { string telcheck = str_ ; string mobilecheck = str_ ; return match ( telcheck , pattern . case_insensitive , value ) || match ( mobilecheck , pattern . case_insensitive , value ) ; }	Telephone number, including mobile phones and landlines.
public static boolean isbirthday ( string value ) { string check = str_ ; if ( match ( check , pattern . case_insensitive , value ) ) { int year = integer . parseint ( value . substring ( num_ , num_ ) ) ; int month = integer . parseint ( value . substring ( num_ , num_ ) ) ; int day = integer . parseint ( value . substring ( num_ , num_ ) ) ; if ( month < num_ || month > num_ ) { return bool_ ; } if ( day < num_ || day > num_ ) { return bool_ ; } if ( ( month == num_ || month == num_ || month == num_ || month == num_ ) && day == num_ ) { return bool_ ; } if ( month == num_ ) { boolean isleap = ( year % num_ == num_ && ( year % num_ != num_ || year % num_ == num_ ) ) ; if ( day > num_ || ( day == num_ && ! isleap ) ) { return bool_ ; } } return bool_ ; } else { return bool_ ; } }	Judge whether it is birthday.
public static boolean isurl ( string value ) { string check = str_ ; return match ( check , pattern . case_insensitive , value ) ; }	Matches are linked.
public void dofilter ( servletrequest request , servletresponse response , filterchain chain ) throws ioexception , servletexception { try { pipeline . apply ( new webcontext ( configuration , ( httpservletrequest ) request , ( httpservletresponse ) response , chain ) ) ; } catch ( exception e ) { logger . warn ( str_ , e ) ; ( ( httpservletresponse ) response ) . senderror ( httpservletresponse . sc_internal_server_error ) ; } }	Processes the Web request in Bootleg.
public static string encodebase64 ( string value ) { try { return new string ( base64 . encodebase64 ( value . getbytes ( stringpool . utf_8 ) ) ) ; } catch ( unsupportedencodingexception ex ) { throw new unexpectedexception ( ex ) ; } }	Encode a String to base64.
public static byte [ ] decodebase64 ( string value ) { try { return base64 . decodebase64 ( value . getbytes ( stringpool . utf_8 ) ) ; } catch ( unsupportedencodingexception ex ) { throw new unexpectedexception ( ex ) ; } }	Decode a base64 value.
public static byte [ ] hexstringtobyte ( string hexstring ) { try { return hex . decodehex ( hexstring . tochararray ( ) ) ; } catch ( decoderexception e ) { throw new unexpectedexception ( e ) ; } }	Transform an hexadecimal String to a byte array.
public static properties readutf8properties ( inputstream is ) { properties properties = new ordersafeproperties ( ) ; try { properties . load ( is ) ; is . close ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } return properties ; }	Read a properties file with the utf-8 encoding.
public static string readcontentasstring ( inputstream is , string encoding ) { string res = null ; try { res = ioutils . tostring ( is , encoding ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { try { is . close ( ) ; } catch ( exception e ) {	Read the Stream content as a string.
public static string readcontentasstring ( file file , string encoding ) { inputstream is = null ; try { is = new fileinputstream ( file ) ; stringwriter result = new stringwriter ( ) ; printwriter out = new printwriter ( result ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( is , encoding ) ) ; string line = null ; while ( ( line = reader . readline ( ) ) != null ) { out . println ( line ) ; } return result . tostring ( ) ; } catch ( ioexception e ) { throw new unexpectedexception ( e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( exception e ) {	Read file content to a String.
public static void write ( byte [ ] data , file file ) { outputstream os = null ; try { os = new fileoutputstream ( file ) ; os . write ( data ) ; os . flush ( ) ; } catch ( ioexception e ) { throw new unexpectedexception ( e ) ; } finally { try { if ( os != null ) os . close ( ) ; } catch ( exception e ) {	Write binay data to a file.
public static void copydirectory ( file source , file target ) { if ( source . isdirectory ( ) ) { if ( ! target . exists ( ) ) { target . mkdir ( ) ; } for ( string child : source . list ( ) ) { copydirectory ( new file ( source , child ) , new file ( target , child ) ) ; } } else { try { write ( new fileinputstream ( source ) , new fileoutputstream ( target ) ) ; } catch ( ioexception e ) { throw new unexpectedexception ( e ) ; } } }	If targetLocation does not exist, it will be created.
public static string serialize ( document document ) { stringwriter writer = new stringwriter ( ) ; try { transformerfactory factory = transformerfactory . newinstance ( ) ; transformer transformer = factory . newtransformer ( ) ; domsource domsource = new domsource ( document ) ; streamresult streamresult = new streamresult ( writer ) ; transformer . transform ( domsource , streamresult ) ; } catch ( transformerexception e ) { throw new runtimeexception ( str_ , e ) ; } return writer . tostring ( ) ; }	Serialize to XML String.
public static document getdocument ( file file ) { try { return newdocumentbuilder ( ) . parse ( file ) ; } catch ( saxexception e ) { logger . warn ( str_ + file + str_ , e ) ; } catch ( ioexception e ) { logger . warn ( str_ + file + str_ , e ) ; } return null ; }	Parse an XML file to DOM.
public static document getdocument ( string xml ) { inputsource source = new inputsource ( new stringreader ( xml ) ) ; try { return newdocumentbuilder ( ) . parse ( source ) ; } catch ( saxexception e ) { logger . warn ( str_ , e ) ; } catch ( ioexception e ) { logger . warn ( str_ , e ) ; } return null ; }	Parse an XML string content to DOM.
public static document getdocument ( inputstream stream ) { try { return newdocumentbuilder ( ) . parse ( stream ) ; } catch ( saxexception e ) { logger . warn ( str_ , e ) ; } catch ( ioexception e ) { logger . warn ( str_ , e ) ; } return null ; }	Parse an XML coming from an input stream to DOM.
public static boolean validsignature ( document document , key publickey ) { node signaturenode = document . getelementsbytagnamens ( xmlsignature . xmlns , str_ ) . item ( num_ ) ; keyselector keyselector = keyselector . singletonkeyselector ( publickey ) ; try { string providername = system . getproperty ( str_ , str_ ) ; xmlsignaturefactory fac = xmlsignaturefactory . getinstance ( str_ , ( provider ) class . forname ( providername ) . newinstance ( ) ) ; domvalidatecontext valcontext = new domvalidatecontext ( keyselector , signaturenode ) ; xmlsignature signature = fac . unmarshalxmlsignature ( valcontext ) ; return signature . validate ( valcontext ) ; } catch ( exception e ) { logger . warn ( str_ , e ) ; return bool_ ; } }	Check the xmldsig signature of the XML document.
public static document sign ( document document , rsapublickey publickey , rsaprivatekey privatekey ) { xmlsignaturefactory fac = xmlsignaturefactory . getinstance ( str_ ) ; keyinfofactory keyinfofactory = fac . getkeyinfofactory ( ) ; try { reference ref = fac . newreference ( str_ , fac . newdigestmethod ( digestmethod . sha1 , null ) , collections . singletonlist ( fac . newtransform ( transform . enveloped , ( transformparameterspec ) null ) ) , null , null ) ; signedinfo si = fac . newsignedinfo ( fac . newcanonicalizationmethod ( canonicalizationmethod . inclusive , ( c14nmethodparameterspec ) null ) , fac . newsignaturemethod ( signaturemethod . rsa_sha1 , null ) , collections . singletonlist ( ref ) ) ; domsigncontext dsc = new domsigncontext ( privatekey , document . getdocumentelement ( ) ) ; keyvalue keyvalue = keyinfofactory . newkeyvalue ( publickey ) ; keyinfo ki = keyinfofactory . newkeyinfo ( collections . singletonlist ( keyvalue ) ) ; xmlsignature signature = fac . newxmlsignature ( si , ki ) ; signature . sign ( dsc ) ; } catch ( exception e ) { logger . warn ( str_ , e ) ; } return document ; }	Sign the XML document using xmldsig.
public static boolean iscachesafe ( class < ? > clazz , classloader classloader ) { preconditions . checknotnull ( clazz , str_ ) ; try { classloader target = clazz . getclassloader ( ) ; if ( target == null ) { return bool_ ; } classloader cur = classloader ; if ( cur == target ) { return bool_ ; } while ( cur != null ) { cur = cur . getparent ( ) ; if ( cur == target ) { return bool_ ; } } return bool_ ; } catch ( securityexception ex ) {	Check whether the given class is cache-safe in the given context,i.e.
public static boolean isprimitivearray ( class < ? > clazz ) { preconditions . checknotnull ( clazz , str_ ) ; return ( clazz . isarray ( ) && clazz . getcomponenttype ( ) . isprimitive ( ) ) ; }	Check if the given class represents an array of primitives,i.e.
public static boolean isprimitivewrapperarray ( class < ? > clazz ) { preconditions . checknotnull ( clazz , str_ ) ; return ( clazz . isarray ( ) && isprimitivewrapper ( clazz . getcomponenttype ( ) ) ) ; }	Check if the given class represents an array of primitive wrappers,i.e.
public static class < ? > resolveprimitiveifnecessary ( class < ? > clazz ) { preconditions . checknotnull ( clazz , str_ ) ; return ( clazz . isprimitive ( ) && clazz != void . class ? primitivetypetowrappermap . get ( clazz ) : clazz ) ; }	Resolve the given class if it is a primitive class,returning the corresponding primitive wrapper type instead.
public static boolean isassignable ( class < ? > lhstype , class < ? > rhstype ) { preconditions . checknotnull ( lhstype , str_ ) ; preconditions . checknotnull ( rhstype , str_ ) ; if ( lhstype . isassignablefrom ( rhstype ) ) { return bool_ ; } if ( lhstype . isprimitive ( ) ) { class < ? > resolvedprimitive = primitivewrappertypemap . get ( rhstype ) ; if ( resolvedprimitive != null && lhstype . equals ( resolvedprimitive ) ) { return bool_ ; } } else { class < ? > resolvedwrapper = primitivetypetowrappermap . get ( rhstype ) ; if ( resolvedwrapper != null && lhstype . isassignablefrom ( resolvedwrapper ) ) { return bool_ ; } } return bool_ ; }	Check if the right-hand side type may be assigned to the left-hand sidetype, assuming setting by reflection.
public static boolean isassignablevalue ( class < ? > type , object value ) { preconditions . checknotnull ( type , str_ ) ; return ( value != null ? isassignable ( type , value . getclass ( ) ) : ! type . isprimitive ( ) ) ; }	Determine if the given type is assignable from the given value,assuming setting by reflection.
public static class < ? > [ ] getallinterfaces ( object instance ) { preconditions . checknotnull ( instance , str_ ) ; return getallinterfacesforclass ( instance . getclass ( ) ) ; }	Return all interfaces that the given instance implements as array,including ones implemented by superclasses.
public static set < class < ? > > getallinterfacesasset ( object instance ) { preconditions . checknotnull ( instance , str_ ) ; return getallinterfacesforclassasset ( instance . getclass ( ) ) ; }	Return all interfaces that the given instance implements as Set,including ones implemented by superclasses.
public url writetotempfile ( ) throws ioexception { final file tempconfigfile = file . createtempfile ( str_ , str_ ) ; tempconfigfile . deleteonexit ( ) ;	Writes properties to the temporary file that will be deleted on process exit and returns file URL as a result.
public map < string , string > variables ( string uri ) { map < string , string > variables = new hashmap < string , string > ( ) ; matcher matcher = pattern . matcher ( uri ) ; if ( matcher . matches ( ) ) { for ( int i = num_ ; i < matcher . groupcount ( ) ; i ++ ) { variables . put ( this . variables . get ( i ) , matcher . group ( i + num_ ) ) ; } } return variables ; }	Returns template variable name and value pairs extracted from thespecified actual URI.
public permbean put ( permission permission , string message ) { if ( permission == null ) throw new illegalargumentexception ( str_ ) ; mpermissions . put ( permission , message ) ; return this ; }	Add permission and message one by one.
protected < t > void bind ( class < ? extends t > impl , class < t > extensionpoint ) { extensionloadermodule < t > lm = createloadermodule ( extensionpoint ) ; lm . init ( impl , extensionpoint ) ; install ( lm ) ; }	Allows the subtype to be selective about what to bind.
protected object builtin ( type type ) { class < ? > rawtype = types . getrawtype ( type ) ; if ( rawtype . equals ( webcontext . class ) ) { return context ; } else if ( rawtype . equals ( httpservletrequest . class ) ) { return context . request ( ) ; } else if ( rawtype . equals ( httpservletresponse . class ) ) { return context . response ( ) ; } else if ( rawtype . equals ( httpsession . class ) ) { return context . session ( ) ; } else if ( rawtype . equals ( servletcontext . class ) ) { return context . application ( ) ; } else {	Returns the value of built-in type.
protected object primitive ( type type ) { class < ? > rawtype = types . getrawtype ( type ) ; if ( rawtype . equals ( boolean . type ) ) { return ( boolean ) bool_ ; } else if ( rawtype . equals ( character . type ) ) { return ( char ) num_ ; } else if ( rawtype . equals ( byte . type ) ) { return ( byte ) num_ ; } else if ( rawtype . equals ( double . type ) ) { return ( double ) num_ ; } else if ( rawtype . equals ( float . type ) ) { return ( float ) num_ ; } else if ( rawtype . equals ( integer . type ) ) { return ( int ) num_ ; } else {	Returns the default value of the specified primitive type.
protected object convert ( object object , class < ? > type ) { try { return convertutils . convert ( object , type ) ; } catch ( exception e ) { logger . warn ( str_ + object + str_ + type + str_ , e ) ; return null ; } }	Converts the specified object to the specified type.This method is overridable.
protected object convertuserdefinedvaluetype ( object object , class < ? > type ) { if ( type . isassignablefrom ( object . getclass ( ) ) ) { return object ; } else if ( object instanceof string ) { try { constructor < ? > constructor = type . getconstructor ( string . class ) ; return constructor . newinstance ( object ) ; } catch ( exception e ) { logger . debug ( str_ + type . getname ( ) + str_ + type + str_ , e ) ; } try { return type . getmethod ( str_ , string . class ) . invoke ( null , object ) ; } catch ( exception e1 ) { logger . debug ( str_ + type . getname ( ) + str_ + str_ + type + str_ , e1 ) ; } } else { logger . warn ( str_ + object + str_ + type + str_ ) ; } return null ; }	Converts the specified object to the specified user-defined value type.This method is overridable.
protected object query ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { return context . request ( ) . getparameter ( name ) ; } } , new function < string , collection < object > > ( ) { @ suppresswarnings ( str_ ) public collection < object > apply ( string name ) { httpservletrequest request = context . request ( ) ; map < string , object > map = new treemap < string , object > ( ) ; for ( object object : collections . list ( request . getparameternames ( ) ) ) { string key = ( string ) object ; if ( key . startswith ( name + str_ ) ) { map . put ( key , request . getparameter ( key ) ) ; } } return ( map . isempty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from query string.
protected object cookie ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { cookie [ ] cookies = context . request ( ) . getcookies ( ) ; if ( cookies != null ) { for ( cookie cookie : cookies ) { if ( cookie . getname ( ) . equals ( name ) ) { return cookie . getvalue ( ) ; } } } return null ; } } , new function < string , collection < object > > ( ) { public collection < object > apply ( string name ) { httpservletrequest request = context . request ( ) ; map < string , object > map = new treemap < string , object > ( ) ; cookie [ ] cookies = request . getcookies ( ) ; if ( cookies != null ) { for ( cookie cookie : cookies ) { string key = cookie . getname ( ) ; if ( key . startswith ( name + str_ ) ) { map . put ( key , cookie . getvalue ( ) ) ; } } } return ( map . isempty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from cookie in the HTTP request.
protected object session ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { return context . session ( ) . getattribute ( name ) ; } } , new function < string , collection < object > > ( ) { @ suppresswarnings ( str_ ) public collection < object > apply ( string name ) { httpsession session = context . session ( ) ; object attribute = session . getattribute ( name ) ; if ( attribute instanceof collection < ? > ) { return ( collection < object > ) attribute ; } map < string , object > map = new treemap < string , object > ( ) ; for ( object object : collections . list ( session . getattributenames ( ) ) ) { string key = ( string ) object ; if ( key . startswith ( name + str_ ) ) { map . put ( key , session . getattribute ( key ) ) ; } } return ( map . isempty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from HTTP session.
private void initdatasource ( final plugins plugins ) { final map < string , properties > dbconfig = gojaconfig . loaddbconfig ( gojaconfig . getconfigprops ( ) ) ; for ( string db_config : dbconfig . keyset ( ) ) { final properties db_props = dbconfig . get ( db_config ) ; if ( db_props != null && ! db_props . isempty ( ) ) { druiddbintializer . init ( db_config , plugins , db_props ) ; } } if ( gojaconfig . getpropertytoboolean ( gojapropconst . db_sqlinxml , bool_ ) ) { plugins . add ( new sqlinxmlplugin ( ) ) ; } }	init databases.
public void setparam ( string field , condition condition , object value ) { this . params . add ( triple . of ( field , condition , value ) ) ; }	Adding custom query condition and value.
public void setparam ( string field , object value ) { this . setparam ( field , condition . eq , value ) ; }	Adding custom query equal value.
private void showdialog ( permbean permbean ) { permissiondialogfragment fragment = permissiondialogfragment . getinstance ( permbean , requestcode ) ; fragment . show ( mactivity . getsupportfragmentmanager ( ) , tag ) ; }	Show dialog fragment to show dialogs before asking permission.Or you can set to show dialogs only when user denied permission earlier.
private static boolean allvaluesgranted ( object [ ] values , hashmap < permission , result > resultmap ) { if ( values instanceof permission [ ] ) { set < permission > valueset = new hashset < > ( arrays . aslist ( ( permission [ ] ) values ) ) ; if ( resultmap . keyset ( ) . containsall ( valueset ) ) { for ( object value : values ) { if ( result . granted != resultmap . get ( ( permission ) value ) ) { mlog . i ( tag , str_ + value . tostring ( ) ) ; return bool_ ; } } return bool_ ; } } else if ( values instanceof string [ ] ) { set < string > valueset = new hashset < > ( arrays . aslist ( ( string [ ] ) values ) ) ; set < string > permission = new hashset < > ( ) ; for ( permission perm : resultmap . keyset ( ) ) { permission . add ( perm . tostring ( ) ) ; } if ( permission . containsall ( valueset ) ) { for ( object value : values ) { if ( result . granted != resultmap . get ( permission . get ( string . valueof ( value ) ) ) ) { mlog . i ( tag , str_ + value ) ; return bool_ ; } } return bool_ ; } } return bool_ ; }	Check if annotated result permissions contains all values from annotated array.Then it also check if all permissions in annotated method value array are granted.
private static boolean anyvaluedenied ( object [ ] values , hashmap < permission , result > resultmap ) { if ( values instanceof permission [ ] ) { set < permission > valueset = new linkedhashset < > ( arrays . aslist ( ( permission [ ] ) values ) ) ; if ( resultmap . keyset ( ) . containsall ( valueset ) ) { for ( object value : values ) { if ( result . denied == resultmap . get ( ( permission ) value ) ) { mlog . i ( tag , str_ + value . tostring ( ) ) ; return bool_ ; } } } } else if ( values instanceof string [ ] ) { set < string > valueset = new hashset < > ( arrays . aslist ( ( string [ ] ) values ) ) ; set < string > permissionset = new hashset < > ( ) ; for ( permission perm : resultmap . keyset ( ) ) { permissionset . add ( perm . tostring ( ) ) ; } if ( permissionset . containsall ( valueset ) ) { for ( object value : values ) { if ( result . denied == resultmap . get ( permission . get ( ( string ) value ) ) ) { mlog . i ( tag , str_ + value ) ; return bool_ ; } } } } return bool_ ; }	Check if annotated result permissions contains all values from annotated array.Then it also check if any permission in annotated method value array is denied.
public static list < record > findby ( sqlselect sqlselect ) { preconditions . checknotnull ( sqlselect , str_ ) ; return db . find ( sqlselect . tostring ( ) , sqlselect . getparams ( ) . toarray ( ) ) ; }	Query the database record set.
public static record findone ( sqlselect sqlselect ) { preconditions . checknotnull ( sqlselect , str_ ) ; return db . findfirst ( sqlselect . tostring ( ) , sqlselect . getparams ( ) . toarray ( ) ) ; }	Query a data record.
public static < m extends model > boolean isnew ( m m , string pk_column ) { final object val = m . get ( pk_column ) ; return val == null || val instanceof number && ( ( number ) val ) . intvalue ( ) <= num_ ; }	According to the primary key and entity determine whether for the new entity.
public static boolean declaresexception ( method method , class < ? > exceptiontype ) { preconditions . checknotnull ( method , str_ ) ; class < ? > [ ] declaredexceptions = method . getexceptiontypes ( ) ; for ( class < ? > declaredexception : declaredexceptions ) { if ( declaredexception . isassignablefrom ( exceptiontype ) ) { return bool_ ; } } return bool_ ; }	Determine whether the given method explicitly declares the givenexception or one of its superclasses, which means that an exception ofthat type can be propagated as-is within a reflective invocation.
private void processqueue ( ) { softvalue < ? , ? > sv ; while ( ( sv = ( softvalue < ? , ? > ) queue . poll ( ) ) != null ) {	Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing mapby looking them up using the SoftValue.key data member.
@ override public v put ( k key , v value ) { processqueue ( ) ;	Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.
public static boolean match ( string string , string pattern ) { if ( string . equals ( pattern ) ) {	Checks whether a string matches a given wildcard pattern.
public static < a > a readarguments ( class < a > interfaceclass , string [ ] args ) { a result = null ; try { final argumenthandler argumenthandler = new argumenthandler ( args ) ; result = argumenthandler . getinstance ( interfaceclass ) ; argumenthandler . processarguments ( new argumentprocessor ( ) { @ override public void process ( list < string > remaining ) throws invalidargumentsexception { if ( remaining . size ( ) > num_ ) { throw new invalidargumentsexception ( str_ + remaining ) ; } } } ) ; } catch ( invalidargumentsexception e ) { system . out . println ( e . getmessage ( ) ) ; showusage ( interfaceclass ) ; result = null ; } if ( result instanceof argumentswithhelp ) { if ( ( ( argumentswithhelp ) result ) . gethelp ( ) ) { showusage ( interfaceclass ) ; result = null ; } } return result ; }	Returns an instance of A if the arguments could be correctly parsedand A was not a subclass of ArgumentsWithHelp or no help was requested, nullotherwise.
public static final protobufentity getprotobufentity ( class < ? > clazz ) { final protobufentity protobufentity = clazz . getannotation ( protobufentity . class ) ; if ( protobufentity != null ) { return protobufentity ; } return null ; }	Return a ProtobufEntity annotation from any object sent, null if there is none.
public static final boolean isprotbufentity ( class < ? > clazz ) { final protobufentity protobufentity = getprotobufentity ( clazz ) ; if ( protobufentity != null ) { return bool_ ; } return bool_ ; }	Returns true if there is a ProtobufEntity annotation on this class.
public static final map < field , protobufattribute > getallprotbuffields ( class < ? extends object > fromclazz ) { map < field , protobufattribute > protobuffields = class_to_field_map_cache . get ( fromclazz . getcanonicalname ( ) ) ; if ( protobuffields != null ) { return protobuffields ; } else { protobuffields = new hashmap < > ( ) ; } final list < field > fields = jreflectionutils . getallfields ( new arraylist < field > ( ) , fromclazz ) ; for ( field field : fields ) { final annotation annotation = field . getannotation ( protobufattribute . class ) ; if ( annotation == null ) { continue ; } final protobufattribute gpbannotation = ( protobufattribute ) annotation ; protobuffields . put ( field , gpbannotation ) ; }	Returns a full mapping of all Protobuf fields from the POJO class.Essentially, the only fields that will be returned if they havethe ProtobufAttribute annotation.
public static final string getprotobufgetter ( protobufattribute protobufattribute , field field ) { final string fieldname = field . getname ( ) ; final string upperclassname = field . getdeclaringclass ( ) . getcanonicalname ( ) ;	Retrieve the getter against the Protobuf class; default is to is "get" plus upper case first character of the field name.
public static final string getpojosetter ( protobufattribute protobufattribute , field field ) { final string fieldname = field . getname ( ) ; final string upperclassname = field . getdeclaringclass ( ) . getcanonicalname ( ) ;	Retrieve the setter on the POJO class; default is to is "set" plus upper case first character of the field name.
public static objectmapper getmapper ( ) { objectmapper mapper = threadmapper . get ( ) ; if ( mapper == null ) { mapper = initmapper ( ) ; threadmapper . set ( mapper ) ; } return mapper ; }	return a ObjectMapper if exist,else new ObjectMapper.
public static jsonfactory getjsonfactory ( ) { jsonfactory jsonfactory = threadjsonfactory . get ( ) ; if ( jsonfactory == null ) { jsonfactory = new jsonfactory ( ) ;	return a JsonFactory if exist,else new JsonFactory.
public static < t > string tojson ( t obj ) { stringwriter writer = new stringwriter ( ) ; string jsonstr = str_ ; jsongenerator gen = null ; try { gen = getjsonfactory ( ) . creategenerator ( writer ) ; getmapper ( ) . writevalue ( gen , obj ) ; writer . flush ( ) ; jsonstr = writer . tostring ( ) ; } catch ( ioexception e ) { log . error ( str_ , e . getmessage ( ) , e ) ; } finally { if ( gen != null ) { try { gen . close ( ) ; } catch ( ioexception e ) { } } } return jsonstr ; }	Bean to json string.
public void setborders ( int top , int right , int bottom , int left ) { settopborder ( top ) ; setrightborder ( right ) ; setbottomborder ( bottom ) ; setleftborder ( left ) ; }	Sets all the border values.
@ edu . umd . cs . findbugs . annotations . suppresswarnings ( str_ ) private userrecord getuserrecord ( final string domain , final string username ) throws loginexception { string userid ; string credential ; connection connection = null ; preparedstatement statement = null ; resultset resultset = null ; try { connection = getdatabaseconnection ( ) ; statement = connection . preparestatement ( dbprops . get ( ) . getsqluserquery ( ) ) ; statement . setstring ( num_ , domain ) ; statement . setstring ( num_ , username ) ; resultset = statement . executequery ( ) ; if ( resultset . next ( ) ) { userid = resultset . getstring ( num_ ) ; credential = resultset . getstring ( num_ ) ; } else { final string error = str_ + username + str_ ; log . warn ( error ) ; throw new loginexception ( error ) ; } resultset . close ( ) ; statement . close ( ) ; } catch ( sqlexception e ) { final string error = str_ ; log . warn ( error , e ) ; throw util . newloginexception ( error , e ) ; } finally { dbutil . close ( resultset ) ; dbutil . close ( statement ) ; dbutil . close ( connection ) ; } return new userrecord ( domain , username , userid , credential ) ; }	The SQL statement is retrieved from the configuration, and the admin is trusted.
public void copyoutattributes ( object target , list < attribute > jmxattributevalues , map < string , method > attributesetters , objectname objectname ) { this . copyoutattributes ( target , jmxattributevalues , attributesetters , str_ , objectname ) ; }	For a JMX MBean idenfitied by an ObjectName, copy the values of the given attributes into the target objectusing the specified setter methods mapped by attribute name.
protected void copyoutattributes ( object target , list < attribute > jmxattributevalues , map < string , method > attributesetters , string identifierkey , object identifier ) { for ( attribute oneattribute : jmxattributevalues ) { string attributename = oneattribute . getname ( ) ; method setter = attributesetters . get ( attributename ) ; object value = oneattribute . getvalue ( ) ; try {	Copy the values of the given attributes into the target object using the specified setter methods mapped byattribute name.
public jframe addapptoframe ( ) { jframe frame = new jframe ( ) ; frame . settitle ( this . gettitle ( ) ) ; frame . setbackground ( color . lightgray ) ; frame . getcontentpane ( ) . setlayout ( new borderlayout ( ) ) ; frame . getcontentpane ( ) . add ( this , borderlayout . center ) ; frame . addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent e ) { system . exit ( num_ ) ; } } ) ; frame . pack ( ) ; frame . setsize ( frame . getpreferredsize ( ) . width , frame . getpreferredsize ( ) . height ) ; return frame ; }	Add this applet to a frame and initialize.
@ override public void savetoken ( token token ) { set ( access_token_token_pref , token . gettoken ( ) ) ; set ( access_token_secret_pref , token . getsecret ( ) ) ; }	Save the token using java preferences.
@ override public token gettoken ( ) { string token = get ( access_token_token_pref ) ; string secret = get ( access_token_secret_pref ) ; return token != null ? new token ( token , secret ) : null ; }	Get the persisted token using java preferences.
public static classloader getdefault ( ) { classloader loader = null ; try { loader = thread . currentthread ( ) . getcontextclassloader ( ) ; } catch ( exception e ) { } if ( loader == null ) { loader = classloaderutils . class . getclassloader ( ) ; if ( loader == null ) { loader = classloader . getsystemclassloader ( ) ; } } return loader ; }	Returns current thread's context class loader.
public static url getresource ( string name , classloader classloader ) { validate . notnull ( name , str_ ) ; if ( name . startswith ( str_ ) ) { name = name . substring ( num_ ) ; } if ( classloader != null ) { url url = classloader . getresource ( name ) ; if ( url != null ) { return url ; } } classloader loader = thread . currentthread ( ) . getcontextclassloader ( ) ; if ( loader != null && loader != classloader ) { url url = loader . getresource ( name ) ; if ( url != null ) { return url ; } } return classloader . getsystemresource ( name ) ; }	Finds the resource with the given name.
public static inputstream getresourceasstream ( string name , classloader classloader ) throws ioexception { url url = getresource ( name , classloader ) ; if ( url != null ) { return url . openstream ( ) ; } return null ; }	Returns an input stream for reading the specified resource.
public static inputstream getclassasstream ( class < ? > clazz ) throws ioexception { return getresourceasstream ( getclassfilename ( clazz ) , clazz . getclassloader ( ) ) ; }	Returns an input stream for reading the specified class.
private void initialize ( uri p_other ) { m_scheme = p_other . getscheme ( ) ; m_userinfo = p_other . getuserinfo ( ) ; m_host = p_other . gethost ( ) ; m_port = p_other . m_port ; n_port = p_other . n_port ; m_path = p_other . getpath ( ) ; m_querystring = p_other . getquerystring ( ) ; m_fragment = p_other . getfragment ( ) ; }	Initialize all fields of this URI from another URI.
private void initializescheme ( string p_urispec ) throws malformeduriexception { int urispeclen = p_urispec . length ( ) ; int index = p_urispec . indexof ( str_ ) ; if ( index < num_ ) throw new malformeduriexception ( str_ ) ; if ( index == urispeclen - num_ ) throw new malformeduriexception ( str_ ) ; setscheme ( p_urispec . substring ( num_ , index ) ) ; }	Initialize the scheme for this URI from a URI string spec.
private void initializepath ( string p_urispec ) throws malformeduriexception { if ( p_urispec == null ) { throw new malformeduriexception ( str_ ) ; } int index = num_ ; int start = num_ ; int end = p_urispec . length ( ) ; char testchar = str_ ;	Initialize the path for this URI from a URI string spec.
private void setscheme ( string p_scheme ) throws malformeduriexception { if ( p_scheme == null ) { throw new malformeduriexception ( str_ ) ; } if ( ! isconformantschemename ( p_scheme ) ) { throw new malformeduriexception ( str_ ) ; } m_scheme = p_scheme ;	Set the scheme for this URI.
private void setuserinfo ( string p_userinfo ) throws malformeduriexception { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new malformeduriexception ( str_ ) ; }	Set the userinfo for this URI.
private void sethost ( string p_host ) throws malformeduriexception { if ( p_host == null || p_host . length ( ) == num_ ) { m_host = p_host ; m_userinfo = null ; m_port = null ; n_port = - num_ ; } else if ( ! iswellformedaddress ( p_host ) ) { throw new malformeduriexception ( str_ ) ; } m_host = p_host ; }	Set the host for this URI.
private void setport ( int p_port ) throws malformeduriexception { if ( p_port >= num_ && p_port <= num_ ) { if ( m_host == null ) { throw new malformeduriexception ( str_ ) ; } } else if ( p_port != - num_ ) { throw new malformeduriexception ( str_ ) ; } n_port = p_port ; }	Set the port for this URI.
private void appendpath ( string p_addtopath ) throws malformeduriexception { if ( p_addtopath == null || p_addtopath . length ( ) == num_ ) { return ; } if ( ! isuristring ( p_addtopath ) ) { throw new malformeduriexception ( str_ ) ; } if ( m_path == null || m_path . length ( ) == num_ ) { if ( p_addtopath . startswith ( str_ ) ) { m_path = p_addtopath ; } else { m_path = str_ + p_addtopath ; } } else if ( m_path . endswith ( str_ ) ) { if ( p_addtopath . startswith ( str_ ) ) { m_path = m_path . concat ( p_addtopath . substring ( num_ ) ) ; } else { m_path = m_path . concat ( p_addtopath ) ; } } else { if ( p_addtopath . startswith ( str_ ) ) { m_path = m_path . concat ( p_addtopath ) ; } else { m_path = m_path . concat ( str_ + p_addtopath ) ; } } }	Append to the end of the path of this URI.
private void setquerystring ( string p_querystring ) throws malformeduriexception { if ( p_querystring == null ) { m_querystring = null ; } else if ( ! isgenericuri ( ) ) { throw new malformeduriexception ( str_ ) ; } else if ( getpath ( ) == null ) { throw new malformeduriexception ( str_ ) ; } else if ( ! isuristring ( p_querystring ) ) { throw new malformeduriexception ( str_ ) ; } else { m_querystring = p_querystring ; } }	Set the query string for this URI.
public void setfragment ( string p_fragment ) throws malformeduriexception { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isgenericuri ( ) ) { throw new malformeduriexception ( str_ ) ; } else if ( getpath ( ) == null ) { throw new malformeduriexception ( str_ ) ; } else if ( ! isuristring ( p_fragment ) ) { throw new malformeduriexception ( str_ ) ; } else { m_fragment = p_fragment ; } }	Set the fragment for this URI.
public string geturistring ( ) { stringbuffer urispecstring = new stringbuffer ( ) ; if ( m_scheme != null ) { urispecstring . append ( m_scheme ) ; urispecstring . append ( str_ ) ; } urispecstring . append ( getschemespecificpart ( ) ) ; return urispecstring . tostring ( ) ; }	Get the URI as a string specification.
protected static preparedstatement createbyiterator ( connection conn , string sql , iterator < ? > parameters ) throws sqlexception { preparedstatement ps = conn . preparestatement ( sql ) ; if ( parameters != null ) { int index = num_ ; while ( parameters . hasnext ( ) ) { object parameter = parameters . next ( ) ; if ( parameter == null ) { ps . setobject ( index , null ) ; } else { ps . setobject ( index , parameter ) ; } index ++ ; } } return ps ; }	Support ? as parameter.
public void init ( object applet ) { try { m_ps = ( persistenceservice ) servicemanager . lookup ( str_ ) ; m_bs = ( basicservice ) servicemanager . lookup ( str_ ) ; m_strcodebase = m_bs . getcodebase ( ) . tostring ( ) ; } catch ( unavailableserviceexception e ) { m_ps = null ; m_bs = null ; } }	Creates new MuffinManager.
public string getmuffin ( string strparam ) { try { url url = new url ( m_strcodebase + strparam ) ; filecontents fc = m_ps . get ( url ) ; if ( fc == null ) return null ;	Get the current value for this muffin.
public void setmuffin ( string strparam , string strvalue ) { filecontents fc = null ; url url = null ; try { url = new url ( m_strcodebase + strparam ) ; } catch ( exception ex ) { return ; } try { fc = m_ps . get ( url ) ; fc . getmaxlength ( ) ;	Set the current value for this muffin.
public transferable getclipboardcontents ( ) { if ( ( clipboardreadstatus & clipboard_disabled ) == clipboard_disabled ) return null ;	Get data from the system clipboard.
public boolean setclipboardcontents ( transferable data ) { if ( data == null ) return bool_ ; if ( ( clipboardwritestatus & clipboard_disabled ) == clipboard_disabled ) return bool_ ;	Set the global clipboard contents.
public static < t extends service > map < string , t > loadservicesbytype ( class < t > clazz ) { serviceloader < t > loader = serviceloader . load ( clazz ) ; iterator < t > it = loader . iterator ( ) ; map < string , t > ret = new hashmap < string , t > ( ) ; while ( it . hasnext ( ) ) { t op = it . next ( ) ; ret . put ( op . getid ( ) , op ) ; if ( op instanceof parametrizedoperation ) addparametrizedservice ( op . getid ( ) , ( parametrizedoperation ) op ) ; if ( op instanceof scriptobject ) addscriptobject ( ( ( scriptobject ) op ) . getvarname ( ) , ( scriptobject ) op ) ; } return ret ; }	Discovers the registered services of the given class.
public static void setserviceparams ( parametrizedoperation op , map < string , object > params ) { if ( params != null ) { for ( map . entry < string , object > entry : params . entryset ( ) ) { op . setparam ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } }	Sets the operation parametres based on a map of values.
public static map < string , object > getserviceparams ( parametrizedoperation op ) { map < string , object > ret = new hashmap < string , object > ( ) ; for ( parameter param : op . getparams ( ) ) { ret . put ( param . getname ( ) , op . getparam ( param . getname ( ) ) ) ; } return ret ; }	Obtains the values of all the parametres of the given operation.
public static parametrizedoperation findparmetrizedservice ( string id ) { if ( parametrizedservices == null ) return null ; else return parametrizedservices . get ( id ) ; }	Finds a parametrized service based on its ID.
public static < t > t findbyclass ( collection < ? > services , class < t > clazz ) { for ( object serv : services ) { if ( clazz . isinstance ( serv ) ) return clazz . cast ( serv ) ; } return null ; }	Finds a service in a collection of services based on its class.
private < t > t parsequery ( final string response , final class < t > responseclass ) { t queryresponse ; try { queryresponse = mapper . readvalue ( response , responseclass ) ; } catch ( jsonparseexception | jsonmappingexception e ) { try { final errorresponse error = mapper . readvalue ( response , errorresponse . class ) ; logger . error ( str_ , error ) ; return null ; } catch ( final ioexception e1 ) { logger . error ( str_ , e1 ) ; } logger . error ( str_ , e ) ; return null ; } catch ( final ioexception e ) { logger . error ( str_ , e ) ; return null ; } return queryresponse ; }	Parses the results of a query and handles any errors.
@ override public iterator < e > iterator ( ) { return new iterator < e > ( ) { int iteratorindex ; int iteratorbufferindex ; int iteratoroffset ; @ override public boolean hasnext ( ) { return iteratorindex < size ; } @ override public e next ( ) { if ( iteratorindex >= size ) { throw new nosuchelementexception ( ) ; } e [ ] buf = buffers [ iteratorbufferindex ] ; e result = buf [ iteratoroffset ] ;	Returns an iterator over buffer elements.
public static string getencoding ( string xmlstr ) { string result ; string xml = xmlstr . trim ( ) ; if ( xml . startswith ( str_ ) ) { int end = xml . indexof ( str_ ) ; int encindex = xml . indexof ( str_ ) ; if ( encindex != - num_ ) { string sub = xml . substring ( encindex + num_ , end ) ; result = commutil . substringbetween ( sub , str_ , str_ ) ; return result ; } } return null ; }	Obtain xml file encoding attribute.
public static connection getinstance ( connection conn ) { invocationhandler handler = new jdbclogconnection ( conn ) ; classloader cl = connection . class . getclassloader ( ) ; return ( connection ) proxy . newproxyinstance ( cl , new class [ ] { connection . class } , handler ) ; }	Creates a logging version of a connection.
@ override public string getauthorization ( string authorizationurl ) throws cubesensorsexception { system . out . println ( str_ + authorizationurl ) ; system . out . print ( str_ ) ; try ( scanner in = new scanner ( system . in ) ) { string authorization = in . nextline ( ) ; return authorization ; } }	Prints the authorizationUrl, the user will open the url and obtain anauthorization key.
public void visitpackagedeclaration ( packagedeclaration d ) { d . accept ( pre ) ; for ( classdeclaration classdecl : d . getclasses ( ) ) { classdecl . accept ( this ) ; } for ( interfacedeclaration interfacedecl : d . getinterfaces ( ) ) { interfacedecl . accept ( this ) ; } d . accept ( post ) ; }	Visits a package declaration.
public void visitclassdeclaration ( classdeclaration d ) { d . accept ( pre ) ; for ( typeparameterdeclaration tpdecl : d . getformaltypeparameters ( ) ) { tpdecl . accept ( this ) ; } for ( fielddeclaration fielddecl : d . getfields ( ) ) { fielddecl . accept ( this ) ; } for ( methoddeclaration methoddecl : d . getmethods ( ) ) { methoddecl . accept ( this ) ; } for ( typedeclaration typedecl : d . getnestedtypes ( ) ) { typedecl . accept ( this ) ; } for ( constructordeclaration ctordecl : d . getconstructors ( ) ) { ctordecl . accept ( this ) ; } d . accept ( post ) ; }	Visits a class declaration.
public void visitexecutabledeclaration ( executabledeclaration d ) { d . accept ( pre ) ; for ( typeparameterdeclaration tpdecl : d . getformaltypeparameters ( ) ) { tpdecl . accept ( this ) ; } for ( parameterdeclaration pdecl : d . getparameters ( ) ) { pdecl . accept ( this ) ; } d . accept ( post ) ; }	Visits a method or constructor declaration.
@ suppresswarnings ( str_ ) private static < t > t getoption ( final string key , final map < string , ? > properties ) {	Return the value of a JAAS configuration parameter.
public static declarationfilter getfilter ( final collection < modifier > mods ) { return new declarationfilter ( ) { public boolean matches ( declaration d ) { return d . getmodifiers ( ) . containsall ( mods ) ; } } ; }	Returns a filter that selects declarations containing all of acollection of modifiers.
public static declarationfilter getfilter ( final class < ? extends declaration > kind ) { return new declarationfilter ( ) { public boolean matches ( declaration d ) { return kind . isinstance ( d ) ; } } ; }	Returns a filter that selects declarations of a particular kind.For example, there may be a filter that selects only classdeclarations, or only fields.The filter will select declarations of the specified kind,and also any subtypes of that kind; for example, a field filterwill also select enum constants.
public declarationfilter and ( declarationfilter f ) { final declarationfilter f1 = this ; final declarationfilter f2 = f ; return new declarationfilter ( ) { public boolean matches ( declaration d ) { return f1 . matches ( d ) && f2 . matches ( d ) ; } } ; }	Returns a filter that selects those declarations selectedby both this filter and another.
public declarationfilter or ( declarationfilter f ) { final declarationfilter f1 = this ; final declarationfilter f2 = f ; return new declarationfilter ( ) { public boolean matches ( declaration d ) { return f1 . matches ( d ) || f2 . matches ( d ) ; } } ; }	Returns a filter that selects those declarations selectedby either this filter or another.
protected map < string , v > getasmap ( ) { map < string , v > result = map ; if ( result == null ) { synchronized ( this ) { result = map ; if ( result == null ) { map = ( result = initialize ( ) ) ; } } } return result ; }	double check for map.
public static < t > void makeaccessible ( final constructor < t > constructor ) { if ( ! modifier . ispublic ( constructor . getmodifiers ( ) ) || ! modifier . ispublic ( constructor . getdeclaringclass ( ) . getmodifiers ( ) ) ) { constructor . setaccessible ( bool_ ) ; } }	set constructor is accessible.
public objectqueryinfo prepareobjectquery ( object obj ) throws malformedobjectnameexception { objectqueryinfo result ;	Prepare to query the given object.
public static string replaceslashwithhyphen ( string origin ) { char [ ] resulltchars = origin . tochararray ( ) ; for ( int i = num_ ; i < resulltchars . length - num_ ; i ++ ) { if ( resulltchars [ i ] == str_ ) { resulltchars [ i ] = str_ ; } } return new string ( resulltchars , num_ , resulltchars . length - num_ ) ; }	replaces slashes with hyphens and removes padding=.
public static string bytes2hexstring ( byte [ ] bytes ) { stringbuffer resultbuffer = new stringbuffer ( ) ; for ( int i = num_ ; i < bytes . length ; i ++ ) { resultbuffer . append ( byte2hex ( bytes [ i ] ) ) ; } return resultbuffer . tostring ( ) ; }	Converts an array of bytes to a string of two digits hex-representations.
private list < integer > getindexes ( string name ) { list < integer > indexes = nameindexmap . get ( name ) ; if ( indexes == null ) { throw new illegalargumentexception ( str_ + name ) ; } return indexes ; }	Returns the indexes for a parameter.
private static string parsenamedsql ( string sql , map < string , list < integer > > nameindexmap ) {	Parses a sql with named parameters.
private static final object convertcollectiontoprotobufs ( collection < object > collectionofnonprotobufs ) throws jexception { if ( collectionofnonprotobufs . isempty ( ) ) { return collectionofnonprotobufs ; } final object first = collectionofnonprotobufs . toarray ( ) [ num_ ] ; if ( ! protobufserializerutils . isprotbufentity ( first ) ) { return collectionofnonprotobufs ; } final collection < object > newcollectionvalues ; if ( collectionofnonprotobufs instanceof set ) { newcollectionvalues = new hashset < > ( ) ; } else { newcollectionvalues = new arraylist < > ( ) ; } for ( object iprotobufgenobj : collectionofnonprotobufs ) { newcollectionvalues . add ( serializetoprotobufentity ( iprotobufgenobj ) ) ; } return newcollectionvalues ; }	Loops through the collection of objects and serializes them, iff they have ProtobufEntity annotations.
private static final void setprotobuffieldvalue ( protobufattribute protobufattribute , builder protoobjbuilder , string setter , object fieldvalue ) throws nosuchmethodexception , securityexception , protobufannotationexception , instantiationexception , illegalaccessexception , illegalargumentexception , invocationtargetexception { class < ? extends object > fieldvalueclass = fieldvalue . getclass ( ) ; class < ? extends object > gpbclass = fieldvalueclass ; final class < ? extends iprotobufconverter > converterclazz = protobufattribute . converter ( ) ; if ( converterclazz != nullconverter . class ) { final iprotobufconverter protobufconverter = ( iprotobufconverter ) converterclazz . newinstance ( ) ; fieldvalue = protobufconverter . converttoprotobuf ( fieldvalue ) ; gpbclass = fieldvalue . getclass ( ) ; fieldvalueclass = gpbclass ; }	This method does the actual "set" on the Protobuf builder.
private static final void setpojofieldvalue ( object pojo , string setter , object protobufvalue , protobufattribute protobufattribute ) throws instantiationexception , illegalaccessexception , jexception { final class < ? extends iprotobufconverter > fromprotobufconverter = protobufattribute . converter ( ) ; if ( fromprotobufconverter != nullconverter . class ) { final iprotobufconverter converter = fromprotobufconverter . newinstance ( ) ; protobufvalue = converter . convertfromprotobuf ( protobufvalue ) ; } class < ? extends object > argclazz = protobufvalue . getclass ( ) ; jreflectionutils . runsetter ( pojo , setter , protobufvalue , argclazz ) ; }	This method does the actual "set" on the POJO instance.
public boolean accept ( file pathname ) { string name = pathname . getname ( ) ; int ilastdot = name . lastindexof ( str_ ) ; string strextension = str_ ; if ( ( ilastdot != - num_ ) && ( ilastdot != name . length ( ) - num_ ) ) strextension = name . substring ( ilastdot + num_ ) ; if ( m_rgstrincludeextensions != null ) { for ( int i = num_ ; i < m_rgstrincludeextensions . length ; i ++ ) { if ( m_rgstrincludeextensions [ i ] . equalsignorecase ( strextension ) ) return bool_ ;	Tests whether or not the specified abstract pathname should beincluded in a pathname list.
public static resultset getinstance ( resultset rs ) { invocationhandler handler = new jdbclogresultset ( rs ) ; classloader cl = resultset . class . getclassloader ( ) ; return ( resultset ) proxy . newproxyinstance ( cl , new class [ ] { resultset . class } , handler ) ; }	Creates a logging version of a ResultSet.
private static map < expectedlabels , integer > maplabels ( final list < string > labels ) { final map < expectedlabels , integer > map = new enummap < > ( expectedlabels . class ) ; final list < expectedlabels > unusedlabels = new arraylist < > ( arrays . aslist ( expectedlabels . values ( ) ) ) ; for ( int index = num_ ; index < labels . size ( ) ; index ++ ) { final string next = labels . get ( index ) ; expectedlabels labelvalue ; try { labelvalue = expectedlabels . valueof ( next ) ; unusedlabels . remove ( labelvalue ) ; if ( map . containskey ( labelvalue ) ) { logger . warn ( str_ , next , labels ) ; } map . put ( labelvalue , index ) ; } catch ( final illegalargumentexception e ) { logger . warn ( str_ , next ) ; } } for ( final expectedlabels label : unusedlabels ) { logger . warn ( str_ , label ) ; } return map ; }	Produces a mapping of label to index for use in parsing state values to the appropriate slot in the state object.
public static class < ? > getgenericsupertype ( class < ? > type , int index ) { return getcomponenttype ( type . getgenericsuperclass ( ) , null , index ) ; }	Returns generic supertype for given class and 0-based index.
public void poll ( ) throws ioexception { synchronized ( this ) {	Poll the configured objects now and store the results in the objects themselves.
protected boolean pollindividually ( ) throws ioexception { this . concurrencytesthooks . onstartpollindividually ( ) ; list < schedulerprocessexecutionslip > processexecutionsliplist = new linkedlist < > ( ) ; for ( final object onepolledobject : this . polledobjects ) {	Poll all of the objects, one at a time.
public static field getdeclaredfield ( class < ? > clazz , string fieldname , boolean recursively ) { try { return clazz . getdeclaredfield ( fieldname ) ; } catch ( nosuchfieldexception e ) { class < ? > superclass = clazz . getsuperclass ( ) ; if ( superclass != null && recursively ) { return getdeclaredfield ( superclass , fieldname , bool_ ) ; } } catch ( securityexception e ) { log . error ( str_ , e . getmessage ( ) , e ) ; } return null ; }	obtain field If recursively is true, obtain fields from all classhierarchy.
public static method [ ] getdeclaredmethods ( class < ? > clazz , boolean recursively ) { list < method > methods = new linkedlist < method > ( ) ; method [ ] declaredmethods = clazz . getdeclaredmethods ( ) ; collections . addall ( methods , declaredmethods ) ; class < ? > superclass = clazz . getsuperclass ( ) ; if ( superclass != null && recursively ) { method [ ] declaredmethodsofsuper = getdeclaredmethods ( superclass , bool_ ) ; if ( declaredmethodsofsuper . length > num_ ) collections . addall ( methods , declaredmethodsofsuper ) ; } return methods . toarray ( new method [ methods . size ( ) ] ) ; }	obtain methods list of specified class If recursively is true, obtainmethods from all class hierarchy.
public static method getdeclaredmethod ( class < ? > clazz , boolean recursively , string methodname , class < ? > ... parametertypes ) { try { return clazz . getdeclaredmethod ( methodname , parametertypes ) ; } catch ( nosuchmethodexception e ) { class < ? > superclass = clazz . getsuperclass ( ) ; if ( superclass != null && recursively ) { return getdeclaredmethod ( superclass , bool_ , methodname , parametertypes ) ; } } catch ( securityexception e ) { log . error ( str_ , e . getmessage ( ) , e ) ; } return null ; }	obtain method list of specified class If recursively is true, obtainmethod from all class hierarchy.
public static method [ ] getannotateddeclaredmethods ( class < ? > clazz , class < ? extends annotation > annotationclass , boolean recursively ) { method [ ] allmethods = getdeclaredmethods ( clazz , recursively ) ; list < method > annotatedmethods = new linkedlist < method > ( ) ; for ( method method : allmethods ) { if ( method . isannotationpresent ( annotationclass ) ) annotatedmethods . add ( method ) ; } return annotatedmethods . toarray ( new method [ annotatedmethods . size ( ) ] ) ; }	obtain methods list of specified class and which are annotated byincoming annotation class If recursively is true, obtain methods from allclass hierarchy.
public static constructor < ? > [ ] getannotateddeclaredconstructors ( class < ? > clazz , class < ? extends annotation > annotationclass , boolean recursively ) { constructor < ? > [ ] allconstructors = getdeclaredconstructors ( clazz , recursively ) ; list < constructor < ? > > annotatedconstructors = new linkedlist < constructor < ? > > ( ) ; for ( constructor < ? > field : allconstructors ) { if ( field . isannotationpresent ( annotationclass ) ) annotatedconstructors . add ( field ) ; } return annotatedconstructors . toarray ( new constructor < ? > [ annotatedconstructors . size ( ) ] ) ; }	obtain constructors list of specified class and which are annotated byincoming annotation class If recursively is true, obtain constructorsfrom all class hierarchy.
protected void dumpbyte ( int b ) { if ( passthrough == bool_ ) { system . out . print ( str_ ) ; } if ( b < num_ ) { b += num_ ; } if ( b < num_ ) { system . out . print ( str_ ) ; } system . out . print ( str_ ) ; system . out . print ( integer . tohexstring ( b ) . touppercase ( ) ) ; }	Dumps single byte to output stream.
public static int indexofignorecase ( string s , string substr , int startindex , int endindex ) { if ( startindex < num_ ) { startindex = num_ ; } int srclen = s . length ( ) ; if ( endindex > srclen ) { endindex = srclen ; } int sublen = substr . length ( ) ; if ( sublen == num_ ) { return startindex > srclen ? srclen : startindex ; } substr = substr . tolowercase ( ) ; int total = endindex - sublen + num_ ; char c = substr . charat ( num_ ) ; mainloop : for ( int i = startindex ; i < total ; i ++ ) { if ( character . tolowercase ( s . charat ( i ) ) != c ) { continue ; } int j = num_ ; int k = i + num_ ; while ( j < sublen ) { char source = character . tolowercase ( s . charat ( k ) ) ; if ( substr . charat ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - num_ ; }	Finds first index of a substring in the given source string and range withignored case.
public static string removechars ( string s , string chars ) { int i = s . length ( ) ; stringbuilder sb = new stringbuilder ( i ) ; for ( int j = num_ ; j < i ; j ++ ) { char c = s . charat ( j ) ; if ( chars . indexof ( c ) == - num_ ) { sb . append ( c ) ; } } return sb . tostring ( ) ; }	Removes all characters contained in provided string.
@ suppresswarnings ( str_ ) private void cleanstate ( ) {	Clean up any state associated with the current login attempt.
@ suppresswarnings ( str_ ) private void initaudit ( final commonproperties commonprops ) { try { final string auditclassname = commonprops . getauditclassname ( ) ;	Initialize the instance-global audit object.
@ suppresswarnings ( str_ ) private void initmessagequeue ( final commonproperties commonprops ) { try { final string messageclassname = commonprops . getmessagequeueclassname ( ) ;	Initialize the instance-global message queue object.
private void initpwvalidator ( final commonproperties commonprops ) { try { final string validatorclass = commonprops . getpasswordvalidatorclassname ( ) ; if ( validatorclass == null ) { final string error = str_ ; log . error ( error ) ; throw new illegalstateexception ( error ) ; } else { if ( commonprops . ispasswordvalidatorsingleton ( ) ) {	Initialize the instance-global password validator object.
private void initpwauthenticator ( final commonproperties commonprops ) { try { final string authnticatorclass = commonprops . getpasswordauthenticatorclassname ( ) ; if ( authnticatorclass == null ) { final string error = str_ ; log . error ( error ) ; throw new illegalstateexception ( error ) ; } else { if ( commonprops . ispasswordauthenticatorsingleton ( ) ) {	Initialize the instance-global password authenticator object.
public static string resolvelocalecode ( final locale locale ) { return resolvelocalecode ( locale . getlanguage ( ) , locale . getcountry ( ) , locale . getvariant ( ) ) ; }	Resolves locale code from locale.
protected static localeinfo lookuplocaleinfo ( final string code ) { localeinfo info = locales . get ( code ) ; if ( info == null ) { string [ ] data = decodelocalecode ( code ) ; info = new localeinfo ( new locale ( data [ num_ ] , data [ num_ ] , data [ num_ ] ) ) ; locales . put ( code , info ) ; } return info ; }	Lookups for locale info and creates new if it doesn't exist.
public static statement getinstance ( statement stmt ) { invocationhandler handler = new jdbclogstatement ( stmt ) ; classloader cl = statement . class . getclassloader ( ) ; return ( statement ) proxy . newproxyinstance ( cl , new class [ ] { statement . class } , handler ) ; }	Creates a logging version of a Statement.
public void clear ( ) { int i = size ; object [ ] els = elements ; while ( i -- > num_ ) { els [ i ] = null ; } this . size = num_ ; }	Removes all of the elements from this stack.
@ suppresswarnings ( str_ ) public t pop ( ) throws emptystackexception { int i ; if ( ( i = -- size ) >= num_ ) { t element = ( t ) elements [ i ] ; elements [ i ] = null ; return element ; } else { size = num_ ; throw new emptystackexception ( ) ; } }	Removes the object at the top of this stack and returns that object as the value of this function.
public inputstream makeinstream ( ) { if ( m_inputstream != null ) return m_inputstream ; try { return new fileinputstream ( m_inputfile ) ; } catch ( filenotfoundexception ex ) { system . out . println ( str_ + m_inputfile . getpath ( ) ) ;	If there is no input stream, use the file to create one.
public static properties parseargs ( properties properties , string [ ] args ) { if ( properties == null ) properties = new properties ( ) ; if ( args == null ) return properties ; for ( int i = num_ ; i < args . length ; i ++ ) apputilities . addparam ( properties , args [ i ] , bool_ ) ; return properties ; }	Parse this URL formatted string into properties.
protected static boolean matchtokens ( string [ ] tokens , string [ ] patterns ) { int patndxstart = num_ ; int patndxend = patterns . length - num_ ; int tokndxstart = num_ ; int tokndxend = tokens . length - num_ ; while ( patndxstart <= patndxend && tokndxstart <= tokndxend ) {	Match tokenized string and pattern.
public void move ( int xofs , int yofs ) { x1 += xofs ; y1 += yofs ; x2 += xofs ; y2 += yofs ; }	Changes the rectangle coordinates by adding the specified X and Y offsets.
public boolean encloses ( rectangular other ) { return x1 <= other . x1 && y1 <= other . y1 && x2 >= other . x2 && y2 >= other . y2 ; }	Checks if this rectangle entirely contains another rectangle.
public boolean contains ( int x , int y ) { return x1 <= x && y1 <= y && x2 >= x && y2 >= y ; }	Checks if this rectangle contains a point.
public rectangular intersection ( rectangular other ) { if ( this . intersects ( other ) ) { return new rectangular ( math . max ( x1 , other . x1 ) , math . max ( y1 , other . y1 ) , math . min ( x2 , other . x2 ) , math . min ( y2 , other . y2 ) ) ; } else { return new rectangular ( ) ;	Computes the intersection of this rectangle with another one.
public rectangular union ( rectangular other ) { return new rectangular ( math . min ( x1 , other . x1 ) , math . min ( y1 , other . y1 ) , math . max ( x2 , other . x2 ) , math . max ( y2 , other . y2 ) ) ; }	Computes the union of this rectangle with another one.
public rectangular replacex ( rectangular other ) { rectangular ret = new rectangular ( this ) ; ret . x1 = other . x1 ; ret . x2 = other . x2 ; return ret ; }	Replaces the X coordinates of the rectangle with the X coordinates of another one.
public rectangular replacey ( rectangular other ) { rectangular ret = new rectangular ( this ) ; ret . y1 = other . y1 ; ret . y2 = other . y2 ; return ret ; }	Replaces the Y coordinates of the rectangle with the Y coordinates of another one.
public int getcolofs ( int col ) throws arrayindexoutofboundsexception { if ( col < width ) { int ofs = num_ ; for ( int i = num_ ; i < col ; i ++ ) ofs += cols [ i ] ; return ofs ; } else if ( col == width ) return abspos . getwidth ( ) ; else throw new arrayindexoutofboundsexception ( col + str_ + width ) ; }	Finds the offset of the specified column from the grid origin.
public int getrowofs ( int row ) throws arrayindexoutofboundsexception { if ( row < height ) { int ofs = num_ ; for ( int i = num_ ; i < row ; i ++ ) ofs += rows [ i ] ; return ofs ; } else if ( row == height ) return abspos . getheight ( ) ; else throw new arrayindexoutofboundsexception ( row + str_ + height ) ; }	Finds the offset of the specified row from the grid origin.
public rectangular getcellboundsrelative ( int x , int y ) { int x1 = getcolofs ( x ) ; int y1 = getrowofs ( y ) ; int x2 = ( x == width - num_ ) ? abspos . getwidth ( ) - num_ : x1 + cols [ x ] - num_ ; int y2 = ( y == height - num_ ) ? abspos . getheight ( ) - num_ : y1 + rows [ y ] - num_ ; return new rectangular ( x1 , y1 , x2 , y2 ) ; }	Computes the coordinates of the specified grid cell relatively to the area top left corner.
private void calculatecolumns ( ) {	Goes through the child areas and creates a list of collumns.
private void calculaterows ( ) {	Goes through the child areas and creates a list of rows.
protected throwable unwrapthrowable ( throwable t ) { throwable e = t ; while ( bool_ ) { if ( e instanceof invocationtargetexception ) { e = ( ( invocationtargetexception ) t ) . gettargetexception ( ) ; } else if ( t instanceof undeclaredthrowableexception ) { e = ( ( undeclaredthrowableexception ) t ) . getundeclaredthrowable ( ) ; } else { return e ; } } }	Examines a Throwable object and gets it's root cause.
public static void main ( string [ ] args ) { try { main main = new main ( ) ; main . start ( ) ; runtime . getruntime ( ) . addshutdownhook ( main . getshutdownhook ( ) ) ; main . awaittermination ( num_ , timeunit . days ) ; } catch ( interruptedexception e ) { e = null ; thread . currentthread ( ) . interrupt ( ) ; } }	Launches the debugger as a stand-alone Swing application.
public void oncodeupdate ( bytebuffer codebuffer , int start , int length , variableandfunctorinterner interner , wamcodeview codeview ) { log . fine ( str_ + start + str_ + length + str_ ) ;	Should be notified every time byte-code is added to the machine.
private void copyandresizecodebuffer ( bytebuffer codebuffer , int start , int length ) {	Copies code from the specified code buffer, into the internal one, resizing the internal code buffer if necessaryto make enough room.
public void init ( ) { log . fine ( str_ ) ;	Loads a properties file and stores it in the application context.
public queryparameter partialcopy ( final queryparameterkind ... excludedelements ) { list < queryparameterkind > excludedlist = arrays . aslist ( excludedelements ) ; queryparameter returnvalue = new queryparameter ( ) ; if ( ! excludedlist . contains ( queryparameterkind . constraints ) ) { returnvalue . rawconstraints = this . rawconstraints ; } if ( ! excludedlist . contains ( queryparameterkind . groups ) ) { returnvalue . groups = this . groups ; } if ( ! excludedlist . contains ( queryparameterkind . orders ) ) { returnvalue . orders = this . orders ; } if ( ! excludedlist . contains ( queryparameterkind . page ) ) { returnvalue . pagesize = this . pagesize ; returnvalue . page = this . page ; } if ( ! excludedlist . contains ( queryparameterkind . timezone ) ) { returnvalue . timezonename = this . timezonename ; } return returnvalue ; }	Return a QueryParameter which contains reference to the original elements except for those from the exception list.
public void addchild ( tree < e > child ) { initchildren ( ) ;	Adds a child tree to the children of this point in the tree.
public void clearchildren ( ) {	Clears all the children of this point in the tree.
private e nextinternal ( ) {	Gets the next element from the sequence, the cached one if one has already been generated, or creating andcaching a new one if not.
public void addinstructions ( functor body , sizeablelist < waminstruction > instructions ) { int oldlength ; if ( this . body == null ) { oldlength = num_ ; this . body = new functor [ num_ ] ; } else { oldlength = this . body . length ; this . body = arrays . copyof ( this . body , oldlength + num_ ) ; } this . body [ oldlength ] = body ; addinstructionsandthistoparent ( instructions ) ; }	Adds a conjunctive body functor, or head functor, to this clause, along with the instructions that implement it.
private void addinstructionsandthistoparent ( sizeablelist < waminstruction > instructions ) { if ( ! addedtoparent ) { parent . addinstructions ( this , instructions ) ; addedtoparent = bool_ ; } else { parent . addinstructions ( instructions ) ; } }	Adds some instructions to the parent predicate, and also adds this as a clause on the parent, if it has notalready been added.
public void propertychange ( propertychangeevent event ) {	Called when a property in the WorkPanelState is changed.
public void registerworkpanel ( workpanel panel ) {	Sets the specified work panel to listen to the button press events for all of the OK, Cancel and Apply buttons.Regisers this object to listen for changes to the work panels state.
private void updatepresentcomponentflags ( ) { hasconsole = componentmap . containskey ( console ) ; hasstatusbar = componentmap . containskey ( status_bar ) ; hasleftbar = componentmap . containskey ( left_vertical_bar ) ; hasleftpane = componentmap . containskey ( left_pane ) ; hasrightbar = componentmap . containskey ( right_vertical_bar ) ; hasrightpane = componentmap . containskey ( right_pane ) ; }	Keeps the set of flags indicating which window components are present, up-to-date.
public static type createinstance ( string name , int precision , int scale , string min , string max ) { synchronized ( decimal_types ) {	Creates a new decimal type with the specified name, if it does not already exist.
public boolean evaluate ( term term ) { if ( term . isvar ( ) && ( term instanceof variable ) ) { variable var = ( variable ) term ; return ! var . isbound ( ) && ! var . isanonymous ( ) ; } return bool_ ; }	Determine whether a term is a free variable.
private sizeablelist < waminstruction > optimize ( list < waminstruction > instructions ) { statemachine optimizeconstants = new optimizeinstructions ( symboltable , interner ) ; iterable < waminstruction > matcher = new matcher < waminstruction , waminstruction > ( instructions . iterator ( ) , optimizeconstants ) ; sizeablelist < waminstruction > result = new sizeablelinkedlist < waminstruction > ( ) ; for ( waminstruction instruction : matcher ) { result . add ( instruction ) ; } return result ; }	Performs an optimization pass for specialized instructions. The following instruction sequences can be optimized: unify_var Xi, get_struc a/0, Xi -> unify_const a/0get_struc a/0, Xi -> get_const a/0put_struc a/0, Xi, set_var Xi -> set_const a/0put_struc a/0, Xi -> put_const a/0 .
public int compare ( collection < t > c1 , collection < t > c2 ) {	Compares two collections using lexicographic ordering based on a comparator of their elements.
public void service ( httpservletrequest request , httpservletresponse response ) throws ioexception { log . fine ( str_ ) ;	Processes the http request that is directed to this servlet.
public int dostarttag ( ) throws jspexception { log . fine ( str_ ) ; tagutils tagutils = tagutils . getinstance ( ) ;	Renders the paging control.
private void renderbutton ( boolean render , int page , int index , string opendelim , string url , string text , boolean active ) throws jspexception { log . fine ( str_ ) ; log . fine ( str_ + render ) ; log . fine ( str_ + page ) ; log . fine ( str_ + index ) ; log . fine ( str_ + opendelim ) ; log . fine ( str_ + url ) ; log . fine ( str_ + text ) ; log . fine ( str_ + active ) ; tagutils tagutils = tagutils . getinstance ( ) ; if ( render ) { tagutils . write ( pagecontext , opendelim ) ;	Renders a button control as a hyperlink for the page control.
public void reset ( ) { maxsteps = num_ ; machinetotrain = null ; inputexamples = new arraylist < state > ( ) ; inputproperties = new hashset < string > ( ) ; outputproperties = new hashset < string > ( ) ; inputpropertiesset = bool_ ; outputpropertiesset = bool_ ; }	Resets the learning method.
protected void initialize ( ) throws learningfailureexception {	This should be called at the start of the learn method to initialize the input and output property sets.
public v get ( object key ) {	Returns the value to which this map maps the specified key.
public int getindexof ( object key ) {	Returns the index to which this map maps the specified key.
public v set ( int index , v value ) throws indexoutofboundsexception {	Inserts the element at the specified index.
public v remove ( object key ) {	Removes the mapping for the specified key from this map if present.
public v remove ( int index ) throws indexoutofboundsexception {	Removes the specified index from the data structure.
public boolean hasproperty ( string property ) {	Checks if the bean has a named property.
protected void setproperty ( object callee , string property , object value ) {	Sets the value of a property of the bean by name.
protected object getproperty ( object callee , string property ) {	Returns a single named property of the bean.
private boolean isassignablefromprimitive ( class wrappertype , class primitivetype ) { boolean result = bool_ ; if ( primitivetype . equals ( boolean . class ) && wrappertype . equals ( boolean . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( byte . class ) && wrappertype . equals ( byte . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( char . class ) && wrappertype . equals ( character . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( short . class ) && wrappertype . equals ( short . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( int . class ) && wrappertype . equals ( integer . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( long . class ) && wrappertype . equals ( long . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( float . class ) && wrappertype . equals ( float . class ) ) { result = bool_ ; } else if ( primitivetype . equals ( double . class ) && wrappertype . equals ( double . class ) ) { result = bool_ ; } else { result = bool_ ; } return result ; }	Checks if a wrapper type is assignable from a primtive type.
private void initialize ( object callee ) {	Initialized this property introspector on a specified object, building the caches of getter and setter methods.
public decisiontree decide ( state state ) {	Performs the actual decision based on a property of the state.
public void initializelookups ( decisiontree thisnode ) {	Initializes the lookup table for this decision node.
public list < variable > unify ( term query , term statement ) {	Unifies two terms and produces a list of bound variables that form the unification, when it it possible.
public boolean unifyinternal ( term left , term right , list < variable > lefttrail , list < variable > righttrail ) { if ( left == right ) { return bool_ ; } if ( ! left . isvar ( ) && ! right . isvar ( ) && left . isconstant ( ) && right . isconstant ( ) && left . equals ( right ) ) { return bool_ ; } else if ( left . isvar ( ) ) { return unifyvar ( ( variable ) left , right , lefttrail , righttrail ) ; } else if ( right . isvar ( ) ) { return unifyvar ( ( variable ) right , left , righttrail , lefttrail ) ; } else if ( left . isfunctor ( ) && right . isfunctor ( ) ) { functor leftfunctor = ( functor ) left ; functor rightfunctor = ( functor ) right ;	Attempts to unify one term with another, against a background of already unified variables in both terms.
private void compilequery ( clause clause ) throws sourcecodeexception {	Compiles a clause as a query.
private int findmaxargumentsinclause ( clause clause ) { int result = num_ ; functor head = clause . gethead ( ) ; if ( head != null ) { result = head . getarity ( ) ; } functor [ ] body = clause . getbody ( ) ; if ( body != null ) { for ( int i = num_ ; i < body . length ; i ++ ) { int arity = body [ i ] . getarity ( ) ; result = ( arity > result ) ? arity : result ; } } return result ; }	Examines all top-level functors within a clause, including any head and body, and determines which functor hasthe highest number of arguments.
private void allocatepermanentqueryregisters ( term clause , map < byte , integer > varnames ) {	Allocates stack slots to all free variables in a query clause.
private void gatherpositionandoccurrenceinfo ( term clause ) { positionaltermtraverser positionaltraverser = new positionaltermtraverserimpl ( ) ; positionandoccurrencevisitor positionandoccurrencevisitor = new positionandoccurrencevisitor ( interner , symboltable , positionaltraverser ) ; positionaltraverser . setcontextchangevisitor ( positionandoccurrencevisitor ) ; termwalker walker = new termwalker ( new depthfirstbacktrackingsearch < term , term > ( ) , positionaltraverser , positionandoccurrencevisitor ) ; walker . walk ( clause ) ; }	Gather information about variable counts and positions of occurrence of constants and variable within a clause.
private void displaycompiledpredicate ( term predicate ) {	Pretty prints a compiled predicate.
private void displaycompiledquery ( term query ) {	Pretty prints a compiled query.
public static string asstring ( bytebuffer buffer , int length ) { char [ ] chars = new char [ length ] ; for ( int i = num_ ; i < length ; i ++ ) { chars [ i ] = ( char ) buffer . get ( i ) ; } return string . valueof ( chars ) ; }	Returns the contents of a buffer as a string, converting ASCII characters in the buffer, into unicode stringcharacters.
public string getstringvalue ( ) {	Gets the string value of a string attribute.
public void setstringvalue ( string value ) throws illegalargumentexception { byte b = attributeclass . lookupbyte . get ( value ) ;	Sets the specified string as the value of this attribute.
private void read ( term term ) { if ( term . isnumber ( ) ) { numerictype numerictype = ( numerictype ) term ; if ( numerictype . isinteger ( ) ) { intliteral jplinteger = ( intliteral ) term ; getcontenthandler ( ) . startintegerterm ( jplinteger . longvalue ( ) ) ; } else if ( numerictype . isfloat ( ) ) { floatliteral jplfloat = ( floatliteral ) term ; getcontenthandler ( ) . startfloatterm ( jplfloat . doublevalue ( ) ) ; } } else if ( term . isvar ( ) ) { variable var = ( variable ) term ; getcontenthandler ( ) . startvariable ( interner . getvariablename ( var . getname ( ) ) ) ; } else if ( term . isatom ( ) ) { functor atom = ( functor ) term ; getcontenthandler ( ) . startatom ( interner . getfunctorname ( atom . getname ( ) ) ) ; } else if ( term . iscompound ( ) ) { functor functor = ( functor ) term ; getcontenthandler ( ) . startcompound ( ) ; getcontenthandler ( ) . startatom ( interner . getfunctorname ( functor . getname ( ) ) ) ; for ( com . thesett . aima . logic . fol . term child : functor . getarguments ( ) ) { read ( child ) ; } getcontenthandler ( ) . endcompound ( ) ; } else { throw new illegalstateexception ( str_ + term ) ; } }	Reads a Lojix term and invoked appropriate methods on the content handler to describe its structure and contentsto it.
public static boolean classexistsandisloadable ( string classname ) { try { class . forname ( classname ) ; return bool_ ; } catch ( classnotfoundexception e ) {	Checks if the named class exists and is loadable.
public static boolean issubtypeof ( class parent , string classname ) { try { class cls = class . forname ( classname ) ; return parent . isassignablefrom ( cls ) ; } catch ( classnotfoundexception e ) {	Checks if the named class exists and is loadable and is a sub-type of the specified class.
public static boolean issubtypeof ( string parent , string child ) { try { return issubtypeof ( class . forname ( parent ) , class . forname ( child ) ) ; } catch ( classnotfoundexception e ) {	Checks that the named child class is the same type or a sub-type of the named parent class.
public static boolean issubtypeof ( class parentclass , class childclass ) { try {	Checks that the child class is the same type or a sub-type of the parent class.
public static class < ? > forname ( string classname ) { try { return class . forname ( classname ) ; } catch ( classnotfoundexception e ) { throw new reflectionutilsexception ( str_ + classname + str_ , e ) ; } }	Gets the Class object for a named class.
public static < t > t newinstance ( class < t > cls ) { try { return cls . newinstance ( ) ; } catch ( instantiationexception e ) { throw new reflectionutilsexception ( str_ , e ) ; } catch ( illegalaccessexception e ) { throw new reflectionutilsexception ( str_ , e ) ; } }	Creates an instance of a Class, instantiated through its no-args constructor.
public static < t > t newinstance ( constructor < t > constructor , object [ ] args ) { try { return constructor . newinstance ( args ) ; } catch ( instantiationexception e ) { throw new illegalstateexception ( e ) ; } catch ( illegalaccessexception e ) { throw new illegalstateexception ( e ) ; } catch ( invocationtargetexception e ) { throw new illegalstateexception ( e ) ; } }	Calls a constuctor with the specified arguments.
public static object callmethodoverridingillegalaccess ( object o , string method , object [ ] params , class [ ] paramclasses ) {	Calls a named method on an object with a specified set of parameters, any Java access modifier are overridden.
public static object callmethod ( object o , string method , object [ ] params ) {	Calls a named method on an object with a specified set of parameters.
public static object callstaticmethod ( method method , object [ ] params ) { try { return method . invoke ( null , params ) ; } catch ( illegalaccessexception e ) { throw new illegalstateexception ( e ) ; } catch ( invocationtargetexception e ) { throw new illegalstateexception ( e ) ; } }	Calls a named static method on a class with a specified set of parameters.
public static < t > constructor < t > getconstructor ( class < t > cls , class [ ] args ) { try { return cls . getconstructor ( args ) ; } catch ( nosuchmethodexception e ) { throw new illegalstateexception ( e ) ; } }	Gets the constructor of a class that takes the specified set of arguments if any matches.
public static set < class > findmatchingsetters ( class obclass , string propertyname ) { set < class > types = new hashset < class > ( ) ;	Finds the argument types of all setter methods on a bean for a given property name.
public static < e > queue < e > gettransactionalqueue ( java . util . queue < e > queue ) { return new wrapperqueue < e > ( queue , new linkedlist < e > ( ) , bool_ , bool_ , bool_ ) ; }	Provides a transactional queue, that delays all queue manipulation operations until the transaction is committed,or erases them if it is rolled back.
public static < e > queue < e > gettransactionalrequeue ( java . util . queue < e > queue , collection < e > requeue ) { return new wrapperqueue < e > ( queue , requeue , bool_ , bool_ , bool_ ) ; }	Provides a transactional requeue, that delays all queue manipulation operations until the transaction iscommitted, or erases them if it is rolled back.
public static type gettypefromobject ( object o ) {	Gets the type of a specified object.
public void reset ( ) {	Resets the search, clearing out the queue and setting it to contain just the start state node.
public static type createinstance ( string name , int min , int max ) {	Creates a new int range type with the specified name, if it does not already exist.
public void addsupportedtz ( string tzname ) { if ( ! stringutils . isblank ( tzname ) && ! tznamesaliases . containskey ( tzname . trim ( ) ) ) { tznamesaliases . put ( tzname . trim ( ) , tzname . trim ( ) ) ; if ( log . isinfoenabled ( ) ) { log . info ( str_ + this . getendpointname ( ) + str_ + tzname ) ; } } }	Add a new supported tz. Add one aliase with the same name.
public void addtzalternatedimension ( string orignaldimensionname , dimensiontable alternatedimension , string tzname ) { addsupportedtz ( tzname ) ; if ( tznamesaliases . containsvalue ( tzname ) ) { sqltables . put ( alternatedimension . gettablename ( ) , alternatedimension ) ; alternatedimensions . put ( pair . of ( orignaldimensionname . touppercase ( ) , tzname ) , alternatedimension ) ; } else { log . error ( str_ + tzname ) ; } }	Timezone is case sensitive.
public void adddimension ( dimensiontable table , boolean mandatory ) { sqltables . put ( table . gettablename ( ) , table ) ; dimensions . put ( table . getdimensionname ( ) . touppercase ( ) , table ) ; if ( mandatory ) { mandatorydimensionnames . add ( table . getdimensionname ( ) . touppercase ( locale . english ) ) ; } }	Add a dimension as mandatory.Mandatory dimension names are stored in upper case.
public static set < variable > findfreevariables ( term query ) { queuebasedsearchmethod < term , term > freevarsearch = new depthfirstsearch < term , term > ( ) ; freevarsearch . reset ( ) ; freevarsearch . addstartstate ( query ) ; freevarsearch . setgoalpredicate ( new freevariablepredicate ( ) ) ; return ( set < variable > ) ( set ) searches . setof ( freevarsearch ) ; }	Calculates the set of free variables in a term.
public static set < variable > findfreenonanonymousvariables ( term query ) { queuebasedsearchmethod < term , term > freevarsearch = new depthfirstsearch < term , term > ( ) ; freevarsearch . reset ( ) ; freevarsearch . addstartstate ( query ) ; freevarsearch . setgoalpredicate ( new freenonanonymousvariablepredicate ( ) ) ; return ( set < variable > ) ( set ) searches . setof ( freevarsearch ) ; }	Calculates the set of free and non-anonymous variables in a term.
public int compare ( searchnode object1 , searchnode object2 ) { float h1 = ( ( heuristicsearchnode ) object1 ) . geth ( ) ; float h2 = ( ( heuristicsearchnode ) object2 ) . geth ( ) ; return ( h1 > h2 ) ? num_ : ( ( h1 < h2 ) ? - num_ : num_ ) ; }	Compares two heuristic search nodes by their heuristic values.
public static void writeobjecttofile ( string outputfilename , object towrite , boolean append ) {	Writes an object, using its 'toString' method, to the named file.
private static string readstreamasstring ( bufferedinputstream is ) { try { byte [ ] data = new byte [ num_ ] ; stringbuffer inbuffer = new stringbuffer ( ) ; int read ; while ( ( read = is . read ( data ) ) != - num_ ) { string s = new string ( data , num_ , read ) ; inbuffer . append ( s ) ; } return inbuffer . tostring ( ) ; } catch ( ioexception e ) { throw new illegalstateexception ( e ) ; } }	Reads the contents of a reader, one line at a time until the end of stream is encountered, and returns alltogether as a string.
public searchnode < o , t > createsearchnode ( t state ) { return new heuristicsearchnode < o , t > ( state , heuristic ) ; }	Creates the correct type of search nodes for this search.
public string generatetraceindent ( int delta ) { if ( ! useindent ) { return str_ ; } else { if ( delta >= num_ ) { indentstack . push ( delta ) ; } else if ( delta < num_ ) { indentstack . pop ( ) ; } stringbuffer result = new stringbuffer ( ) ; traceindent += ( delta < num_ ) ? delta : num_ ; for ( int i = num_ ; i < traceindent ; i ++ ) { result . append ( str_ ) ; } traceindent += ( delta > num_ ) ? delta : num_ ; return result . tostring ( ) ; } }	Generates a sequence of spaces to indent debugging output with.
private boolean islastbodyterminargpositiononly ( term var , functor body ) { return body == symboltable . get ( var . getsymbolkey ( ) , symboltablekeys . symkey_var_last_arg_functor ) ; }	Checks if a variable is appearing within the last body functor in which it occurs, and only does so withinargument position.
private string choosebestpropertytodecideon ( string outputproperty , iterable < state > examples , iterable < string > inputproperties ) {	For a given set of examples, input properties and an output property this method chooses the input property thatprovides the largest information gain on the value of the output property.
public functor functor ( string name , term ... args ) { int internedname = interner . internfunctorname ( name , args . length ) ; return new functor ( internedname , args ) ; }	Creates a functor.
public variable var ( string name ) { boolean isanonymous = name . startswith ( str_ ) ; int internedname = interner . internvariablename ( name ) ; return new variable ( internedname , null , isanonymous ) ; }	Creates a variable. If the variable name begins with an underscore "_", it will be anonymous, otherwise it willbe named.
public actionforward executewitherrorhandling ( actionmapping mapping , actionform form , httpservletrequest request , httpservletresponse response , actionerrors errors ) { log . fine ( str_ + str_ + str_ ) ; httpsession session = request . getsession ( ) ; dynabean dynaform = ( dynaactionform ) form ;	Handles an HTTP request sent to this action by struts.
public list < e > get ( int index ) {	Extracts the sub-list at the specified page index.
public void settexture ( paint obj ) { if ( obj instanceof gradientpaint ) { texture = new gradientpaint ( num_ , num_ , color . white , getsize ( ) . width * num_ , num_ , color . green ) ; } else { texture = obj ; } }	Sets the kind of paint to use. For the image background?.
public void paintimmediately ( int x , int y , int w , int h ) { repaintmanager repaintmanager = null ; boolean save = bool_ ; if ( ! isdoublebuffered ( ) ) { repaintmanager = repaintmanager . currentmanager ( this ) ; save = repaintmanager . isdoublebufferingenabled ( ) ; repaintmanager . setdoublebufferingenabled ( bool_ ) ; } super . paintimmediately ( x , y , w , h ) ; if ( repaintmanager != null ) { repaintmanager . setdoublebufferingenabled ( save ) ; } }	Immediately repaints the surface.
protected bufferedimage createbufferedimage ( int w , int h , int imgtype ) { bufferedimage bi = null ; if ( imgtype == num_ ) { bi = ( bufferedimage ) createimage ( w , h ) ; } else if ( ( imgtype > num_ ) && ( imgtype < num_ ) ) { bi = new bufferedimage ( w , h , imgtype ) ; } else if ( imgtype == num_ ) { bi = createbinaryimage ( w , h , num_ ) ; } else if ( imgtype == num_ ) { bi = createbinaryimage ( w , h , num_ ) ; } else if ( imgtype == num_ ) { bi = createsgisurface ( w , h , num_ ) ; } else if ( imgtype == num_ ) { bi = createsgisurface ( w , h , num_ ) ; }	Generates a fresh buffered image of the appropriate type.
private bufferedimage createbinaryimage ( int w , int h , int pixelbits ) { int bytesperrow = w * pixelbits / num_ ; if ( ( w * pixelbits % num_ ) != num_ ) { bytesperrow ++ ; } byte [ ] imagedata = new byte [ h * bytesperrow ] ; indexcolormodel cm = null ; switch ( pixelbits ) { case num_ : { cm = new indexcolormodel ( pixelbits , lut1arr . length , lut1arr , lut1arr , lut1arr ) ; break ; } case num_ : { cm = new indexcolormodel ( pixelbits , lut2arr . length , lut2arr , lut2arr , lut2arr ) ; break ; } case num_ : { cm = new indexcolormodel ( pixelbits , lut4arr . length , lut4arr , lut4arr , lut4arr ) ; break ; } default : { new exception ( str_ ) . printstacktrace ( ) ; } } databuffer db = new databufferbyte ( imagedata , imagedata . length ) ; writableraster r = raster . createpackedraster ( db , w , h , pixelbits , null ) ; return new bufferedimage ( cm , r , bool_ , null ) ; }	Creates a custom grey-scale binary image format.
private bufferedimage createsgisurface ( int w , int h , int pixelbits ) { int rmask32 = num_ ; int rmask16 = num_ ; int gmask32 = num_ ; int gmask16 = num_ ; int bmask32 = num_ ; int bmask16 = num_ ; directcolormodel dcm = null ; databuffer db = null ; writableraster wr = null ; switch ( pixelbits ) { case num_ : { short [ ] imagedataushort = new short [ w * h ] ; dcm = new directcolormodel ( num_ , rmask16 , gmask16 , bmask16 ) ; db = new databufferushort ( imagedataushort , imagedataushort . length ) ; wr = raster . createpackedraster ( db , w , h , w , new int [ ] { rmask16 , gmask16 , bmask16 } , null ) ; break ; } case num_ : { int [ ] imagedataint = new int [ w * h ] ; dcm = new directcolormodel ( num_ , rmask32 , gmask32 , bmask32 ) ; db = new databufferint ( imagedataint , imagedataint . length ) ; wr = raster . createpackedraster ( db , w , h , w , new int [ ] { rmask32 , gmask32 , bmask32 } , null ) ; break ; } default : { new exception ( str_ ) . printstacktrace ( ) ; } } return new bufferedimage ( dcm , wr , bool_ , null ) ; }	Creates a custom colour image format.
protected void setqueuesearchalgorithm ( queuesearchalgorithm < o , t > algorithm ) { algorithm . setpeekathead ( bool_ ) ; algorithm . setreverseenqueueorder ( bool_ ) ; super . setqueuesearchalgorithm ( algorithm ) ; }	Allows different queue search algorithms to replace the default one.
public static void main ( string [ ] args ) { try { simplecharstream inputstream = new simplecharstream ( system . in , null , num_ , num_ ) ; prologparsertokenmanager tokenmanager = new prologparsertokenmanager ( inputstream ) ; source < token > tokensource = new tokensource ( tokenmanager ) ; prologparser parser = new prologparser ( tokensource , new variableandfunctorinternerimpl ( str_ , str_ ) ) ; while ( bool_ ) {	Parses statements and print the parse tree to the console for quick interactive testing of the parser.
public clause clause ( ) throws sourcecodeexception {	Parses a single sentence in first order logic.
public list < term > terms ( list < term > terms ) throws sourcecodeexception { term term ; token nexttoken = tokensource . peek ( ) ; switch ( nexttoken . kind ) { case functor : term = functor ( ) ; break ; case lsqparen : term = listfunctor ( ) ; break ; case var : term = variable ( ) ; break ; case integer_literal : term = intliteral ( ) ; break ; case floating_point_literal : term = doubleliteral ( ) ; break ; case string_literal : term = stringliteral ( ) ; break ; case atom : term = atom ( ) ; break ; case lparen : consumetoken ( lparen ) ; term = term ( ) ;	Recursively parses terms, which may be functors, atoms, variables, literals or operators, into a flat list in theorder in which they are encountered.
public term functor ( ) throws sourcecodeexception { token name = consumetoken ( functor ) ; term [ ] args = arglist ( ) ; consumetoken ( rparen ) ; int nameid = interner . internfunctorname ( ( args == null ) ? name . image : name . image . substring ( num_ , name . image . length ( ) - num_ ) , ( args == null ) ? num_ : args . length ) ; functor result = new functor ( nameid , args ) ; sourcecodeposition position = new sourcecodepositionimpl ( name . beginline , name . begincolumn , name . endline , name . endcolumn ) ; result . setsourcecodeposition ( position ) ; return result ; }	Parses a single functor in first order logic with its arguments.
public term variable ( ) throws sourcecodeexception { token name = consumetoken ( var ) ;	Parses a variable in first order logic.
public term intliteral ( ) throws sourcecodeexception { token valtoken = consumetoken ( integer_literal ) ; numerictype result = new intliteral ( integer . parseint ( valtoken . image ) ) ;	Parses an integer literal.
public term doubleliteral ( ) throws sourcecodeexception { token valtoken = consumetoken ( floating_point_literal ) ; numerictype result = new doubleliteral ( double . parsedouble ( valtoken . image ) ) ;	Parses a real number literal.
public term stringliteral ( ) throws sourcecodeexception { token valtoken = consumetoken ( string_literal ) ; string valwithquotes = valtoken . image ; stringliteral result = new stringliteral ( valwithquotes . substring ( num_ , valwithquotes . length ( ) - num_ ) ) ;	Parses a string literal.
public directive peekandconsumedirective ( ) throws sourcecodeexception { if ( peekandconsumetrace ( ) ) { return directive . trace ; } if ( peekandconsumeinfo ( ) ) { return directive . info ; } if ( peekandconsumeuser ( ) ) { return directive . user ; } return null ; }	Peeks and consumes the next interactive system directive.
public void internoperator ( string operatorname , int priority , opsymbol . associativity associativity ) { int arity ; if ( ( associativity == xfy ) | ( associativity == yfx ) | ( associativity == xfx ) ) { arity = num_ ; } else { arity = num_ ; } int name = interner . internfunctorname ( operatorname , arity ) ; operatortable . setoperator ( name , operatorname , priority , associativity ) ; }	Interns an operators name as a functor of appropriate arity for the operators fixity, and sets the operator inthe operator table.
protected void initializebuiltins ( ) {	Interns and inserts into the operator table all of the built in operators and functors in Prolog.
protected token consumetoken ( int kind ) throws sourcecodeexception { token nexttoken = tokensource . peek ( ) ; if ( nexttoken . kind != kind ) { throw new sourcecodeexception ( str_ + tokenimage [ kind ] + str_ + tokenimage [ nexttoken . kind ] + str_ , null , null , null , new sourcecodepositionimpl ( nexttoken . beginline , nexttoken . begincolumn , nexttoken . endline , nexttoken . endcolumn ) ) ; } else { nexttoken = tokensource . poll ( ) ; return nexttoken ; } }	Consumes a token of the expected kind from the token sequence.
private boolean peekandconsume ( int kind ) { token nexttoken = tokensource . peek ( ) ; if ( nexttoken . kind == kind ) { try { consumetoken ( kind ) ; } catch ( sourcecodeexception e ) {	Peeks ahead for the given token type, and if one is foudn with that type, it is consumed.
public void bind ( ) {	Binds the session as a transactional context to the current thread, if it is not already bound.
public void rollback ( ) {	Forgets pending operations.
public static < t > collection < t > collectiterator ( iterator < t > iterator , collection < t > targetcollection ) { while ( iterator . hasnext ( ) ) { targetcollection . add ( iterator . next ( ) ) ; } return targetcollection ; }	Extracts all elements from an iterator, usually created from a filterator, and adds them into the targetcollection, returning that collection as the result.
public static long timeofdaytoticks ( int hour , int minute , int second , int millisecond ) { return millisecond + ( millis_per_second * second ) + ( millis_per_minute * minute ) + ( millis_per_hour * hour ) ; }	Converts a field by field time of day into millisecond ticks.
public static int tickstoyears ( long ticks ) {	Extracts the years component of a time in millisecond ticks.
public static long tickswithhourssetto ( long ticks , int hours ) { long oldhours = tickstohours ( ticks ) ; return ticks - ( oldhours * millis_per_hour ) + ( hours * millis_per_hour ) ; }	Sets the component of the timestamp, returning the new timestamp with updated component.
public static long tickswithminutessetto ( long ticks , int minutes ) { long oldminutes = tickstominutes ( ticks ) ; return ticks - ( oldminutes * millis_per_minute ) + ( minutes * millis_per_minute ) ; }	Sets the minutes component of the timestamp, returning the new timestamp with updated component.
public static long tickswithsecondssetto ( long ticks , int seconds ) { long oldseconds = tickstoseconds ( ticks ) ; return ticks - ( oldseconds * millis_per_second ) + ( seconds * millis_per_second ) ; }	Sets the seconds component of the timestamp, returning the new timestamp with updated component.
public static long tickswithyearsetto ( long ticks , int year ) { int oldyear = tickstoyears ( ticks ) ; return ticks - millistoyearstart ( oldyear ) + millistoyearstart ( year ) ; }	Sets the year component of the timestamp, returning the new timestamp with updated component.
public static long tickswithmonthsetto ( long ticks , int month ) { int year = tickstoyears ( ticks ) ; boolean isleapyear = isleapyear ( year ) ; int oldmonth = tickstomonths ( ticks ) ; return ticks - millistostartofmonth ( oldmonth , isleapyear ) + millistostartofmonth ( month , isleapyear ) ; }	Sets the month component of the timestamp, returning the new timestamp with updated component.
public static long tickswithdatesetto ( long ticks , int date ) { int olddays = tickstodate ( ticks ) ; return ticks - ( olddays * millis_per_day ) + ( date * millis_per_day ) ; }	Sets the date component of the timestamp, returning the new timestamp with updated component.
public static long millistoyearstart ( int year ) {	Calculates the number of milliseconds to the start of the specified year, taking 1970 as zero.
public byteblock read ( byte [ ] b ) throws ioexception { int count = source . read ( b ) ; return new byteblock ( b , count ) ; }	Reads some number of bytes from the input stream and stores them into the buffer array b.
private entry < k > entryforkey ( k key ) { int keyhashcode = key . hashcode ( ) ; int hash1 = hash1 ( keyhashcode ) ; entry < k > entry = hashtable [ indexfor ( hash1 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } int hash2 = hash2 ( hash1 , keyhashcode ) ; entry = hashtable [ indexfor ( hash2 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } return null ; }	Checks if the specified key can be found in the set, and returns its entry if so.
private entry < k > cuckoo ( entry < k > entry ) {	Adds a new entry to a hash table, using the cuckoo algorithm.
private void rehash ( ) {	Creates a new hashtable that is twice the size of the old one, then re-hashes everything from the old table intothe new table.
public void actionperformed ( actionevent event ) {	Listens for the button events Ok, Cancel and Apply.
public void setnextavailable ( boolean avail ) {	Sets the state of the next available flag and notifies any listeners of this change.
public void setprevavailable ( boolean avail ) {	Sets the state of the previous available flag and notifies any listeners of this change.
public void setfinished ( boolean avail ) {	Sets the state of the finished and notifies any listeners of this change.
public static wamresolvingnativemachine getinstance ( symboltableimpl < integer , string , object > symboltable ) throws implementationunavailableexception { try { if ( ! libraryloadattempted ) { libraryloadattempted = bool_ ; system . loadlibrary ( str_ ) ; libraryfound = bool_ ; } if ( libraryfound ) { return new wamresolvingnativemachine ( symboltable ) ; } else { throw new implementationunavailableexception ( str_ , null , null , null ) ; } } catch ( unsatisfiedlinkerror e ) { libraryfound = bool_ ; throw new implementationunavailableexception ( str_ , e , null , null ) ; } }	Creates an instance of this machine, loading and checking for availability of the native implementation libraryas required.
public iterator < set < variable > > iterator ( ) { return new sequenceiterator < set < variable > > ( ) { public set < variable > nextinsequence ( ) { return resolve ( ) ; } } ; }	Provides an iterator that generates all solutions on demand as a sequence of variable bindings.
public static double expectedi ( double [ ] probabilities ) { double result = num_ ;	For a given set of probabilities of the occurences of symbols this function calculates the expected informationcontent of a set of symbols given its probability distribution.
public static double [ ] pfordistribution ( int [ ] counts ) { double [ ] probabilities = new double [ counts . length ] ; int total = num_ ;	Estimates probabilities given a set of counts of occurrences of symbols.
void setticks ( long ticks ) { year = timeutils . tickstoyears ( ticks ) ; month = timeutils . tickstomonths ( ticks ) ; day = timeutils . tickstodate ( ticks ) ; }	Sets this date from a milliseconds timestamp.
public actionforward perform ( actionmapping mapping , actionform form , httpservletrequest request , httpservletresponse response ) throws ioexception , servletexception { log . fine ( str_ ) ;	Processes the action.
public static url newurl ( string spec ) { try { return new url ( spec ) ; } catch ( malformedurlexception exception ) { throw new illegalargumentexception ( str_ + spec ) ; } }	Creates a URL for the specified string representation.
public string getrequestinfo ( ) { map info = new treemap ( ) ; httpservletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; info . put ( str_ , nulltostring ( req . getauthtype ( ) ) ) ; info . put ( str_ , nulltostring ( req . getcharacterencoding ( ) ) ) ; info . put ( str_ , integer . tostring ( req . getcontentlength ( ) ) ) ; info . put ( str_ , nulltostring ( req . getcontenttype ( ) ) ) ; info . put ( str_ , nulltostring ( req . getcontextpath ( ) ) ) ; info . put ( str_ , nulltostring ( req . getpathinfo ( ) ) ) ; info . put ( str_ , nulltostring ( req . getprotocol ( ) ) ) ; info . put ( str_ , nulltostring ( req . getquerystring ( ) ) ) ; info . put ( str_ , nulltostring ( req . getremoteaddr ( ) ) ) ; info . put ( str_ , nulltostring ( req . getremotehost ( ) ) ) ; info . put ( str_ , nulltostring ( req . getremoteuser ( ) ) ) ; info . put ( str_ , nulltostring ( req . getrequesturi ( ) ) ) ; info . put ( str_ , nulltostring ( req . getscheme ( ) ) ) ; info . put ( str_ , nulltostring ( req . getservername ( ) ) ) ; info . put ( str_ , integer . tostring ( req . getserverport ( ) ) ) ; info . put ( str_ , nulltostring ( req . getservletpath ( ) ) ) ; return tohtmltable ( str_ , info ) ; }	Returns a String with all basic request information in an HTML table.
public string getheaders ( ) { map info = new treemap ( ) ; httpservletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; enumeration names = req . getheadernames ( ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; enumeration values = req . getheaders ( name ) ; stringbuffer sb = new stringbuffer ( ) ; boolean first = bool_ ; while ( values . hasmoreelements ( ) ) { if ( ! first ) { sb . append ( str_ ) ; } first = bool_ ; sb . append ( values . nextelement ( ) ) ; } info . put ( name , sb . tostring ( ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all header information as an HTML table.
public string getcookies ( ) { map info = new treemap ( ) ; httpservletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; cookie [ ] cookies = req . getcookies ( ) ;	Returns a String with all cookie information as an HTML table.
public string getparameters ( ) { map info = new treemap ( ) ; servletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; enumeration names = req . getparameternames ( ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; string [ ] values = req . getparametervalues ( name ) ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = num_ ; i < values . length ; i ++ ) { if ( i != num_ ) { sb . append ( str_ ) ; } sb . append ( values [ i ] ) ; } info . put ( name , sb . tostring ( ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all request parameter information.
public string getrequestscope ( ) { map info = new treemap ( ) ; servletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; enumeration names = req . getattributenames ( ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; object value = req . getattribute ( name ) ; info . put ( name , tostringvalue ( value ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all request scope variables.
public string getpagescope ( ) { map info = new treemap ( ) ; enumeration names = pagecontext . getattributenamesinscope ( pagecontext . page_scope ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; object value = pagecontext . getattribute ( name ) ; info . put ( name , tostringvalue ( value ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all page scope variables.
public string getsessionscope ( ) { map info = new treemap ( ) ; httpservletrequest req = ( httpservletrequest ) pagecontext . getrequest ( ) ; httpsession session = req . getsession ( ) ; enumeration names = session . getattributenames ( ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; object value = session . getattribute ( name ) ; info . put ( name , tostringvalue ( value ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all session scope variables.
public string getapplicationscope ( ) { map info = new treemap ( ) ; servletcontext context = pagecontext . getservletcontext ( ) ; enumeration names = context . getattributenames ( ) ; while ( names . hasmoreelements ( ) ) { string name = ( string ) names . nextelement ( ) ; object value = context . getattribute ( name ) ; info . put ( name , tostringvalue ( value ) ) ; } return tohtmltable ( str_ , info ) ; }	Returns a String with all application scope variables.
public string getuserprincipal ( ) {	Returns the user principal name.
public int dostarttag ( ) throws jspexception { log . fine ( str_ ) ; try {	Renders the debugging message.
private string tohtmltable ( string propname , map values ) { stringbuffer tablesb = new stringbuffer ( ) ; tablesb . append ( str_ ) . append ( propname ) . append ( str_ ) ; for ( iterator it = values . keyset ( ) . iterator ( ) ; it . hasnext ( ) ; ) { object o = it . next ( ) ; string key = ( string ) o ; tablesb . append ( str_ ) . append ( key ) . append ( str_ ) . append ( values . get ( key ) ) . append ( str_ ) ; } return tablesb . tostring ( ) ; }	Returns an HTML table with all the values of the specified property.
public void setcurrentscreenstate ( workflowscreenstate state ) { workflowscreenstate oldstate = currentscreenstate ;	Sets the new current screen state and notifies all listeners of the change in screen state.
public void walk ( term term ) {	Walks over the supplied term.
public int compare ( searchnode object1 , searchnode object2 ) { float f1 = ( ( heuristicsearchnode ) object1 ) . getf ( ) ; float f2 = ( ( heuristicsearchnode ) object2 ) . getf ( ) ; return ( f1 > f2 ) ? num_ : ( ( f1 < f2 ) ? - num_ : num_ ) ; }	Compares two heuristic search nodes by their f values.
public void updateregisters ( waminternalregisters registers ) { list < propertychangeevent > changes = delta ( this , registers ) ; ip = registers . ip ; hp = registers . hp ; hbp = registers . hbp ; sp = registers . sp ; up = registers . up ; ep = registers . ep ; bp = registers . bp ; b0 = registers . b0 ; trp = registers . trp ; writemode = registers . writemode ; notifychanges ( changes ) ; }	Updates the register file, with a new set of registers.
private void notifychanges ( iterable < propertychangeevent > changes ) { list < propertychangelistener > activelisteners = listeners . getactivelisteners ( ) ; if ( activelisteners != null ) { for ( propertychangelistener listener : activelisteners ) { for ( propertychangeevent event : changes ) { listener . propertychange ( event ) ; } } } }	Fires off a list of property change events to any interested listeners.
protected void leaveclause ( clause clause ) {	Upon leaving the clause, sets the nonArgPosition flag on any constants that need it.
private boolean intoplevelfunctor ( positionalcontext context ) { positionalcontext parentcontext = context . getparentcontext ( ) ; return parentcontext . istoplevel ( ) || istoplevel ( parentcontext ) ; }	Checks if the current position is immediately within a top-level functor.
public void setarguments ( term [ ] arguments ) {	Sets the arguments of this operator.
public fixity getfixity ( ) { switch ( associativity ) { case fx : case fy : return fixity . pre ; case xf : case yf : return fixity . post ; case xfx : case xfy : case yfx : return fixity . in ; default : throw new illegalstateexception ( str_ ) ; } }	Provides the symbols fixity, derived from its associativity.
public boolean isinfix ( ) { return ( ( associativity == associativity . xfy ) || ( associativity == associativity . yfx ) || ( associativity == associativity . xfx ) ) ; }	Reports whether this operator is an infix operator.
public int compareto ( object o ) { opsymbol opsymbol = ( opsymbol ) o ; return ( priority < opsymbol . priority ) ? - num_ : ( ( priority > opsymbol . priority ) ? num_ : num_ ) ; }	Compares this object with the specified object for order, providing a negative integer, zero, or a positiveinteger as this symbols priority is less than, equal to, or greater than the comparator.
public void propertychange ( propertychangeevent event ) { object source = event . getsource ( ) ; object oldvalue = event . getoldvalue ( ) ; string propertyname = event . getpropertyname ( ) ;	Called when a property in the work flow state is changed.
public void registerworkflowcontroller ( workflowcontroller controller ) {	Registers the work flow button panel with the specified work flow controller.
public static enumattributefactory getfactoryforclass ( class cls ) {	Generates a factory for building enum attributes of the specified enum class.
public static componentfactory createcomponentfactory ( string classname ) { return ( componentfactory ) reflectionutils . newinstance ( reflectionutils . forname ( classname ) ) ; }	Creates an instance of the named component factory.
public variable getstoragecell ( variable variable ) { variablebindingcontext < variable > context = getbindingcontext ( ) ; if ( context == null ) { return null ; } else { return context . getstoragecell ( this ) ; } }	Provides the storage cell for the specified variable.
public boolean isbound ( ) { variablebindingcontext < variable > context = getbindingcontext ( ) ;	Reports whether or not this variable is bound to a value.
private void setcolumnattribute ( attributeset attributes , int c ) { if ( c >= columnattributes . size ( ) ) { for ( int i = columnattributes . size ( ) ; i <= c ; i ++ ) { columnattributes . add ( null ) ; } } columnattributes . set ( c , attributes ) ; }	Sets a column attribute, adding padding to the underlying array as necessary to ensure it is large enough to holdthe attribute at the requested position.
private void setrowattribute ( attributeset attributes , int r ) { if ( r >= rowattributes . size ( ) ) { for ( int i = rowattributes . size ( ) ; i <= r ; i ++ ) { rowattributes . add ( null ) ; } } rowattributes . set ( r , attributes ) ; }	Sets a row attribute, adding padding to the underlying array as necessary to ensure it is large enough to holdthe attribute at the requested position.
private attributeset getcolumnattributeornull ( int c ) { if ( ( c >= num_ ) && ( c < columnattributes . size ( ) ) ) { return columnattributes . get ( c ) ; } else { return null ; } }	Gets a columns attribute if possible, without overflowing the underlying array.
private attributeset getrowattributeornull ( int r ) { if ( ( r >= num_ ) && ( r < rowattributes . size ( ) ) ) { return rowattributes . get ( r ) ; } else { return null ; } }	Gets a rows attribute if possible, without overflowing the underlying array.
private void internalinsert ( attributeset attributes , int c , int r ) { cellattributes . put ( ( long ) c , ( long ) r , attributes ) ; }	Inserts a set of attributes into the grid at the specified location.
public static type createinstance ( string name , timeonly min , timeonly max ) {	Creates a new time range type with the specified name, if it does not already exist.
public static type createinstance ( string name , int maxlength , string pattern ) { synchronized ( string_pattern_types ) { stringpatterntype newtype = new stringpatterntype ( name , maxlength , pattern ) ;	Creates a new string pattern type with the specified name, if it does not already exist.
public boolean isinstance ( charsequence value ) {	Checks a string value against this type to see if it is a valid instance of the type.
private void createinitialcontext ( term term ) { if ( ! initialcontextcreated ) { positionalcontextoperator initialcontext = new positionalcontextoperator ( term , - num_ , bool_ , bool_ , bool_ , null , contextstack . peek ( ) ) ; contextstack . offer ( initialcontext ) ; term . setreversable ( initialcontext ) ; initialcontextcreated = bool_ ; } }	Sets up the initial context once, at the start of a traversal.
public void updateregisters ( wammemorylayout layout ) { list < propertychangeevent > changes = delta ( this , layout ) ; regbase = layout . regbase ; regsize = layout . regsize ; heapbase = layout . heapbase ; heapsize = layout . heapsize ; stackbase = layout . stackbase ; stacksize = layout . stacksize ; trailbase = layout . trailbase ; trailsize = layout . trailsize ; pdlbase = layout . pdlbase ; pdlsize = layout . pdlsize ; notifychanges ( changes ) ; }	Updates the layout register file, with a new set of layout registers.
public string getvalue ( ) { for ( scopenode scope = nodetreeutils . getparentscope ( this ) ; scope != null ; scope = nodetreeutils . getparentscope ( scope ) ) { expressiongroupnode value = scope . getvariable ( _name ) ; if ( value == null ) { continue ; } return value . tostring ( ) ; } return _name ;	Search up the scope tree to locate the variable's value.
public searchnode < o , t > findgoalpath ( ) throws searchnotexhaustiveexception {	Implementation of the general bi-dircetional search.
public list < t > cacheblock ( int block ) {	Fetches and caches the specified block.
public static synchronized properties getproperties ( string resourcename ) {	Static factory method that locates an existing instance or creates a new property reader for a named resource.
public void setrate ( float hertz ) {	Specifies the throttling rate in operations per second.
public int read ( byte [ ] b ) throws ioexception { try { byteblock block = source . read ( b ) ; system . arraycopy ( block . data , num_ , b , num_ , block . count ) ; return block . count ; } catch ( remoteexception e ) { throw new ioexception ( str_ , e ) ; } }	Reads some number of bytes from the input stream and stores them into the buffer array b.
public long skip ( long n ) throws ioexception { try { return source . skip ( n ) ; } catch ( remoteexception e ) { throw new ioexception ( str_ , e ) ; } }	Skips over and discards n bytes of data from this input stream.
private void gatherdisjunctions ( disjunction disjunction , list < term > expressions ) {	Gathers the functors to compile as a sequence of choice points.
public static int getintfrombytes ( byte [ ] buf , int offset ) { int result = num_ ; result += buf [ offset ++ ] & num_ ; result += ( ( buf [ offset ++ ] & num_ ) << num_ ) ; result += ( ( buf [ offset ++ ] & num_ ) << num_ ) ; result += ( ( buf [ offset ] ) << num_ ) ; return result ; }	Extracts an int from an array of bytes.
public static void writeinttobytearray ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & num_ ) ; buf [ offset ++ ] = ( byte ) ( ( value & num_ ) > > num_ ) ; buf [ offset ++ ] = ( byte ) ( ( value & num_ ) > > num_ ) ; buf [ offset ] = ( byte ) ( ( value & num_ ) > > num_ ) ; }	Outputs an int into a byte array.
public static void write24bitinttobytearray ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & num_ ) ; buf [ offset ++ ] = ( byte ) ( ( value & num_ ) > > num_ ) ; buf [ offset ] = ( byte ) ( ( value & num_ ) > > num_ ) ; }	Outputs an int into a byte array, copying only the bottom 24 bits of the integer.
public static int get24bitintfrombytes ( byte [ ] buf , int offset ) { int i = num_ ; offset ++ ; i += buf [ offset ++ ] & num_ ; i += ( ( buf [ offset ++ ] & num_ ) << num_ ) ; i += ( ( buf [ offset ] & num_ ) << num_ ) ; return i ; }	Extracts an int from an array of bytes.
public static short getshortfrombytes ( byte [ ] buf , int offset ) { short result = num_ ; result += buf [ offset ++ ] & num_ ; result += ( ( buf [ offset ] ) << num_ ) ; return result ; }	Extracts a short from an array of bytes.
public static void writeshorttobytearray ( byte [ ] buf , int offset , short value ) { buf [ offset ++ ] = ( byte ) ( value & num_ ) ; buf [ offset ] = ( byte ) ( ( value & num_ ) > > num_ ) ; }	Outputs a short into a byte array.
public treesearchstate < e > getchildstateforoperator ( operator < tree < e > > op ) {	Returns the state obtained by applying the specified operation.
public iterator < operator < tree < e > > > validoperators ( boolean reverse ) {	Gets all operators valid from this state.
public long getid ( ) {	Returns the integer id of the attribute.
public t getvalue ( ) {	Gets the object value of a object attribute.
public void setvalue ( t value ) throws illegalargumentexception { integer b = attributeclass . lookupint . get ( value ) ;	Sets the specified object as the value of this attribute.
public static string [ ] listtoarray ( string value , string delim ) { list < string > result = new arraylist < string > ( ) ; stringtokenizer tokenizer = new stringtokenizer ( value , delim ) ; while ( tokenizer . hasmoretokens ( ) ) { result . add ( tokenizer . nexttoken ( ) ) ; } return result . toarray ( new string [ result . size ( ) ] ) ; }	Converts a string listing sub-strings seperated by a delimeter into an array of strings.
public static string arraytolist ( string [ ] array , string delim ) { string result = str_ ; for ( int i = num_ ; i < array . length ; i ++ ) { result += array [ i ] + ( ( i == ( array . length - num_ ) ) ? str_ : delim ) ; } return result ; }	Converts an array of strings into a delimeter seperated string.
public static string tocamelcase ( string name ) { string [ ] parts = name . split ( str_ ) ; string result = parts [ num_ ] ; for ( int i = num_ ; i < parts . length ; i ++ ) { if ( parts [ i ] . length ( ) > num_ ) { result += upperfirstchar ( parts [ i ] ) ; } } return result ; }	Converts a string to camel case.
private static stringbuffer listhandlers ( handler [ ] handlers , stringbuffer buffer ) { for ( handler handler : handlers ) { class < ? extends handler > handlerclass = handler . getclass ( ) ; formatter formatter = handler . getformatter ( ) ; buffer . append ( str_ ) . append ( handlerclass . getname ( ) ) . append ( str_ ) ; buffer . append ( str_ ) . append ( handler . getlevel ( ) . tostring ( ) ) . append ( str_ ) ; if ( formatter != null ) { buffer . append ( str_ ) . append ( formatter . getclass ( ) . getname ( ) ) . append ( str_ ) ; } } return buffer ; }	Lists information about logging handlers.
public wamcallpoint resolvecallpoint ( int functorname ) { wamcallpoint result = ( wamcallpoint ) symboltable . get ( functorname , symkey_callpoints ) ; if ( result == null ) { result = new wamcallpoint ( - num_ , num_ , functorname ) ; } return result ; }	Looks up the offset of the start of the code for the named functor.
protected wamcallpoint setcodeaddress ( int functorname , int offset , int length ) { wamcallpoint entry = new wamcallpoint ( offset , length , functorname ) ; symboltable . put ( functorname , symkey_callpoints , entry ) ;	Records the offset of the start of the code for the named functor.
public boolean issubcategory ( hierarchyattribute comp ) {	Tests if another hierarchy attribute is strict a sub-category of this one.
public long getid ( ) {	Returns the long id of the attribute.
public string getvalueatlevel ( string level ) { int index = attributeclass . levels . indexof ( level ) ; if ( index == - num_ ) { throw new illegalargumentexception ( str_ + level + str_ ) ; } return getvalueatlevel ( index ) ; }	Gets the label value at the named level of the hierarchy.
public string getlastvalue ( ) { list < string > pathvalue = getpathvalue ( ) ; return pathvalue . get ( pathvalue . size ( ) - num_ ) ; }	Gets the label value at the last level of the hierarchy.
private void writeobject ( objectoutputstream out ) throws ioexception {	Serialized a hierarchy attribute.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception {	Deserializes a hierarchy attribute.
public float computeh ( eightpuzzlestate state , heuristicsearchnode searchnode ) {	Returns heuristic evaluation of an eight puzzle board position as the manhattan distance of all tiles from theircorrect positions.
private int mod ( long c , int bucketsize ) { return ( int ) ( ( c < num_ ) ? ( ( bucketsize + ( c % bucketsize ) ) % bucketsize ) : ( c % bucketsize ) ) ; }	Calculates the modulo of a coordinate with the bucket size.
public void adderrormessage ( string key , string usermessage ) { errors . add ( new userreadableerrorimpl ( key , usermessage ) ) ; }	Adds another user readable error message to this exception.
public void write ( string str , int off , int len ) throws ioexception {	Writes a string of characters to the filtered writer.
public map < string , ordinalattribute > classify ( state state ) throws classifyingfailureexception {	Classifies a state using the decision tree.
public int compare ( t a , t b ) { boolean arb = partialordering . evaluate ( a , b ) ; if ( ! arb ) { return - num_ ; } boolean bra = partialordering . evaluate ( b , a ) ; return ( arb && bra ) ? num_ : num_ ; }	Translates the partial order into the +1, 0, -1 convention needed by Comparators.
public iterator iterator ( ) { try { distributediteratorimpl di ; di = new distributediteratorimpl ( super . iterator ( ) ) ; return new clientiterator ( di ) ; } catch ( remoteexception e ) {	Returns a distriubuted iterator that can provide elements of the list on demand over a remote connection.
public static int intlogbase2 ( int value ) { int temp1 ; int temp2 = value > > num_ ; if ( temp2 > num_ ) { temp1 = temp2 > > num_ ; return ( temp1 > num_ ) ? ( num_ + log_table_256 [ temp1 ] ) : ( num_ + log_table_256 [ temp2 ] ) ; } else { temp1 = value > > num_ ; return ( temp1 > num_ ) ? ( num_ + log_table_256 [ temp1 ] ) : log_table_256 [ value ] ; } }	Calcalates the log base 2 of an integer.
public static int intlogbase2v2 ( int value ) { int temp ; if ( ( temp = value > > num_ ) > num_ ) { return num_ + log_table_256 [ temp ] ; } else if ( ( temp = value > > num_ ) > num_ ) { return num_ + log_table_256 [ temp ] ; } else if ( ( temp = value > > num_ ) > num_ ) { return num_ + log_table_256 [ temp ] ; } else { return log_table_256 [ value ] ; } }	Calcalates the log base 2 of an integer.
public static int intlogbase10v2 ( int value ) { return ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : num_ ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int intlogbase10v3 ( int value ) { return ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : num_ ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int intlogbase10 ( long value ) { return ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : ( ( value >= num_ ) ? num_ : num_ ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int intlogbase10v2 ( long value ) { return ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : ( ( value < num_ ) ? num_ : num_ ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int getcharactercountint32 ( int value ) { if ( value >= num_ ) { return getcharactercountuint32 ( value ) ; } else if ( value == integer . min_value ) { return getcharactercountuint32 ( integer . max_value ) + num_ ; } else { return getcharactercountuint32 ( - value ) + num_ ; } }	Calculates the number of ASCII characters that will be needed to represent a specifed signed 32-bit integer.
public static int getcharactercountint64 ( long value ) { if ( value >= num_ ) { return getcharactercountuint64 ( value ) ; } else if ( value == long . min_value ) { return getcharactercountuint64 ( long . max_value ) + num_ ; } else { return getcharactercountuint64 ( - value ) + num_ ; } }	Calculates the number of ASCII characters that will be needed to represent a specifed signed 64-bit integer.
public static int getcharactercountdecimal ( long integervalue , int scale ) { boolean isneg = integervalue < num_ ;	Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number.
public void sethead ( functor head , sizeablelist < waminstruction > instructions ) { this . head = head ; addinstructions ( instructions ) ; }	Sets a compiled head functor to this clause.
public void emmitcode ( bytebuffer buffer , wammachine machine , wamcallpoint callpoint ) throws linkageexception {	Emmits the binary byte code for the clause into a machine, writing into the specified byte array.
protected void setcurrentscreen ( workflowscreenpanel screen ) {	This is a helper method that controller implementations may find useful for moving to a new screen.
public boolean evaluate ( t t ) {	Evaluates a logical predicate.
protected iterator getkeyiterator ( final string base , final string modifier , final string key ) { return new iterator ( ) {	For a given environment, base, modifier and key and setting of the use of default environments feature thisgenerates an iterator that walks over the order in which to try and access properties. See the {.
protected void createarrayproperties ( ) {	Scans all the properties in the parent Properties object and creates arrays for any array property definitions.
public void setrate ( float hertz ) {	Specifies the throttling rate in operations per second.
protected numerictype evaluate ( numerictype firstnumber ) {	Evaluates the arithmetic operator on its numeric argument.
protected void findproperties ( ) {	This methods attempts to load the properties from a file or URL referenced by the system property with the samename as the properties resource name, from a resource on the classpath with the same name as the propertiesresource name or from a properties file name relative to the current working directory.
protected properties getpropertiesusingsystemproperty ( ) {	Tries to load the properties from the file or URL named by the system property with name mathching the propertiesresource name.
protected properties getpropertiesusingclasspath ( ) {	Tries to load the properties from the classpath using the classloader for this class.
protected properties getpropertiesusingcwd ( ) {	Tries to load the properties as a file or URL matching the properties resource name.
protected void leavefunctor ( functor functor ) { int pos = traverser . getposition ( ) ; if ( ! traverser . isinhead ( ) && ( pos >= num_ ) ) { functor transformed = builtintransform . apply ( functor ) ; if ( functor != transformed ) { builtinfunctor builtinfunctor = ( builtinfunctor ) transformed ; term parentterm = traverser . getparentcontext ( ) . getterm ( ) ; if ( parentterm instanceof clause ) { clause parentclause = ( clause ) parentterm ; parentclause . getbody ( ) [ pos ] = builtinfunctor ; } else if ( parentterm instanceof functor ) { functor parentfunctor = ( functor ) parentterm ; parentfunctor . getarguments ( ) [ pos ] = builtinfunctor ; } } } }	Applies the built-in transform during a post-fix visit of a term.
public term getvalue ( ) { term result = this ; term assignment = this . substitution ;	Gets the actual value of a term, which is either the term itself, or in the case of variables, the value that iscurrently assigned to the variable.
public void setsubstitution ( term term ) { term termtobindto = term ;	Binds this variable to the specified value.
public queue < searchnode < o , t > > createqueue ( ) { return new priorityqueue < searchnode < o , t > > ( num_ , new greedycomparator ( ) ) ; }	Creates the correct type of queue for this search.
public void cleanup ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( ioexception e ) { loglog . error ( str_ , e ) ; } oos = null ; } if ( connector != null ) {	Drop the connection to the remote host and release the underlying connector thread if it has been created.
public void append ( loggingevent event ) { if ( event == null ) { return ; } if ( address == null ) { errorhandler . error ( str_ + this . name + str_ ) ; return ; } if ( oos != null ) { try { if ( locationinfo ) { event . getlocationinformation ( ) ; } oos . writeobject ( event ) ;	Appends a logging event to the remote event reciever.
void fireconnector ( ) { if ( connector == null ) { loglog . debug ( str_ ) ; connector = new connector ( ) ; connector . setdaemon ( bool_ ) ; connector . setpriority ( thread . min_priority ) ; connector . start ( ) ; } }	Starts a new connector thread to do?.
protected void initializeprinters ( ) { int maxcolumns = num_ ; printers . add ( new sourceclauseprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; printers . add ( new positionprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; printers . add ( new unoptimizedlabelprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; printers . add ( new unoptimizedbytecodeprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; printers . add ( new labelprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; printers . add ( new bytecodeprinter ( interner , symboltable , traverser , maxcolumns ++ , printtable ) ) ; }	Sets up the stack of column printers.
public void commit ( ) { txid txid = null ;	When operating in transactional mode causes any changes since the last commit to be made visible to the searchmethod.
public void rollback ( ) { txid txid = null ;	When operation in transactional mode causes any changes since the last commit to be dropped and never madevisible to the search method.
public void requestwriteoperation ( txoperation op ) {	Requests an operation that alters the transactional resource.
private void addcachedoperation ( txid txid , txoperation cachedwriteoperation ) { list < txoperation > writecache = txwrites . get ( txid ) ; if ( writecache == null ) { writecache = new arraylist < txoperation > ( ) ; txwrites . put ( txid , writecache ) ; } writecache . add ( cachedwriteoperation ) ; }	Adds a transactional operation to the transactional write-behind cache for the specified transaction.
private void acquireglobalwritelock ( txid txid ) throws interruptedexception {	Waits until the global write lock can be acquired by the specified transaction.
private void releaseglobalwritelock ( ) {	Releases the global write lock from being assigned to a transaction.
private void enlistwithsession ( ) { txsession session = txsessionimpl . getcurrentsession ( ) ;	Enlists this transactional resource with the current session.
@ override public boolean enter ( rulesetnode rulesetnode ) { scopenode scopenode = nodetreeutils . getfirstchild ( rulesetnode , scopenode . class ) ; selectorgroupnode selectorgroupnode = nodetreeutils . getfirstchild ( rulesetnode , selectorgroupnode . class ) ; if ( selectorgroupnode == null ) { return bool_ ; } list < selectornode > selectornodes = nodetreeutils . getchildren ( selectorgroupnode , selectornode . class ) ; if ( selectornodes . size ( ) < num_ ) { return bool_ ; } list < mediaquerynode > mediaquerynodes = nodetreeutils . getandremovechildren ( scopenode , mediaquerynode . class ) ; for ( mediaquerynode mediaquerynode : mediaquerynodes ) { scopenode mediascopenode = nodetreeutils . getfirstchild ( mediaquerynode , scopenode . class ) ; list < rulesetnode > nestedrulesets = nodetreeutils . getandremovechildren ( mediascopenode , rulesetnode . class ) ;	Locates nested MediaQueryNode inside RuleSetNode,separates RuleSetNode and MediaQueryNodeIf MediaQueryNode has nested RuleSetNodes than to everynested selectors will added selector of input RuleSetNodeIf MediaQueryNode has other nodes except WhiteSpaceCollectionNode andRuleSetNode than all of that will be wrapped with new RuleSetNode withthe same selectors as has input RuleSetNode.
public boolean offer ( e e , long timeout , timeunit unit ) throws interruptedexception { if ( e == null ) { throw new illegalargumentexception ( str_ ) ; } reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; long nanos = unit . tonanos ( timeout ) ; try { do { if ( insert ( e , bool_ ) ) { return bool_ ; } try { nanos = notfull . awaitnanos ( nanos ) ; } catch ( interruptedexception ie ) {	Inserts the specified element into this queue, waiting if necessary up to the specified wait time for space tobecome available.
public e poll ( long timeout , timeunit unit ) throws interruptedexception { reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; try { long nanos = unit . tonanos ( timeout ) ; do { if ( count != num_ ) { return extract ( bool_ , bool_ ) . getelement ( ) ; } try { nanos = notempty . awaitnanos ( nanos ) ; } catch ( interruptedexception ie ) { notempty . signal ( ) ;	Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time if no elementsare present on this queue.
public void put ( e e ) throws interruptedexception { try { tryput ( e ) ; } catch ( synchexception ex ) {	Adds the specified element to this queue, waiting if necessary for space to become available. This method delegated to {.
public object next ( ) { try { object ob = source . next ( ) ; return ob ; } catch ( remoteexception e ) { throw new illegalstateexception ( e ) ; } }	Fetches the next element from this iterator.
public boolean getpropertyasboolean ( string propname ) { string prop = getproperty ( propname ) ; return ( prop != null ) && boolean . parseboolean ( prop ) ; }	Parses a property as a boolean.
public integer getpropertyasinteger ( string propname ) { string prop = getproperty ( propname ) ; return ( prop != null ) ? integer . valueof ( prop ) : null ; }	Parses a property as an integer.
public long getpropertyaslong ( string propname ) { string prop = getproperty ( propname ) ; return ( prop != null ) ? long . valueof ( prop ) : null ; }	Parses a property as a long.
public scopenode callmixin ( string name , argumentsnode arguments ) { list < expressiongroupnode > argumentlist = ( arguments != null ) ? nodetreeutils . getchildren ( arguments , expressiongroupnode . class ) : collections . < expressiongroupnode > emptylist ( ) ; if ( argumentlist . size ( ) > _parameterdefinitions . size ( ) ) { throw new illegalmixinargumentexception ( name , _parameterdefinitions . size ( ) ) ; }	Creates a clone of this scope to be attached to the tree at the site of a mixin reference.
private void setadditionvisitor ( ) { setadditionvisitor ( new inclusivenodevisitor ( ) { @ override public boolean add ( parametersnode node ) { for ( variabledefinitionnode variable : nodetreeutils . getchildren ( node , variabledefinitionnode . class ) ) { _parameterdefinitions . add ( variable ) ; add ( variable ) ; } return super . add ( node ) ; } @ override public boolean add ( rulesetnode node ) { selectorgroupnode selectorgroup = nodetreeutils . getfirstchild ( node , selectorgroupnode . class ) ; for ( selectornode selectornode : nodetreeutils . getchildren ( selectorgroup , selectornode . class ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( node selectorchild : selectornode . getchildren ( ) ) { sb . append ( selectorchild . tostring ( ) ) ; } string selector = sb . tostring ( ) ;	Some nodes are captured in additional structures to aid later resolution.
protected void backtrack ( searchnode checknode ) { while ( ( checknode != null ) && ( checknode . unexaminedsuccessorcount == num_ ) ) { reversable undostate = ( retraversable ) checknode . getstate ( ) ; undostate . undooperator ( ) ; checknode = checknode . getparent ( ) ; } }	Back-tracks from the specified node, moving succesively upwards through the chain of parent nodes, until a nodeis encountered that has unexamined successors.
public byte [ ] retrievecode ( wamcallpoint callpoint ) { byte [ ] result = new byte [ callpoint . length ] ; codebuffer . get ( result , callpoint . entrypoint , callpoint . length ) ; return result ; }	Extracts the raw byte code from the machine for a given call table entry.
protected set < variable > executeandextractbindings ( wamcompiledquery query ) {	Runs a query, and for every non-anonymous variable in the query, decodes its binding value from the heap andreturns it in a set of variable bindings.
protected term decodeheap ( int start , map < integer , variable > variablecontext ) {	Decodes a term from the raw byte representation on the machines heap, into an abstract syntax tree.
public void capture ( ) {	Captures an objects state in this memento.
public void restore ( object ob ) throws nosuchfieldexception {	Restores the values currently in this memento to the specified object.
public object get ( class cls , string attr ) { hashmap map ;	Gets the value of the named field of the specified class.
public void put ( class cls , string attr , object val ) { hashmap map ;	Places the specified value into the memento based on the field's declaring class and name.
public collection getallfieldnames ( class cls ) {	Generates a list of all the fields of the object that this memento maps for a given class.
public void execute ( ) throws mojoexecutionexception , mojofailureexception {	Implementation of the prod-script goal.
public boolean offer ( e o ) {	Inserts the specified element onto the tail of this queue.
public searchnode < o , t > createsearchnode ( t state ) { return new searchnode < o , t > ( state ) ; }	Creates the correct type of search nodes for this search.
public queue < searchnode < o , t > > createqueue ( ) { return new priorityqueue < searchnode < o , t > > ( num_ , new uniformcostcomparator ( ) ) ; }	Creates the correct type of queue for this search.
public static termwalker simplewalker ( termvisitor visitor ) { depthfirstbacktrackingsearch < term , term > search = new depthfirstbacktrackingsearch < term , term > ( ) ; return new termwalker ( search , new defaulttraverser ( ) , visitor ) ; }	Provides a simple depth first walk over a term.
public static termwalker goalwalker ( unarypredicate < term > unarypredicate , termvisitor visitor ) { termwalker walker = simplewalker ( visitor ) ; walker . setgoalpredicate ( unarypredicate ) ; return walker ; }	Provides a depth first walk over a term, visiting only when a goal predicate matches.
public static termwalker positionalwalker ( positionaltermvisitor visitor ) { positionaltermtraverser positionaltraverser = new positionaltermtraverserimpl ( ) ; positionaltraverser . setcontextchangevisitor ( visitor ) ; visitor . setpositionaltraverser ( positionaltraverser ) ; return new termwalker ( new depthfirstbacktrackingsearch < term , term > ( ) , positionaltraverser , visitor ) ; }	Provides a positional depth first walk over a term.
public static termwalker positionalgoalwalker ( unarypredicate < term > unarypredicate , positionaltermvisitor visitor ) { termwalker walker = positionalwalker ( visitor ) ; walker . setgoalpredicate ( unarypredicate ) ; return walker ; }	Provides a positional depth first walk over a term, visiting only when a goal predicate matches.
public static termwalker positionalpostfixwalker ( positionaltermvisitor visitor ) { positionaltermtraverser positionaltraverser = new positionaltermtraverserimpl ( ) ; positionaltraverser . setcontextchangevisitor ( visitor ) ; visitor . setpositionaltraverser ( positionaltraverser ) ; return new termwalker ( new postfixsearch < term , term > ( ) , positionaltraverser , visitor ) ; }	Provides a positional postfix walk over a term.
public static properties getproperties ( inputstream is ) throws ioexception {	Get properties from an input stream.
public static properties getproperties ( file file ) throws ioexception {	Get properties from a file.
public static properties getproperties ( url url ) throws ioexception {	Get properties from a url.
public static properties getproperties ( string pathname ) throws ioexception {	Get properties from a path name.
protected dimension computegridsize ( ) { int cols = model . getwidth ( ) ; int rows = model . getheight ( ) ; int horizseparatorsize = num_ ; for ( int size : model . gethorizontalseparators ( ) . values ( ) ) { horizseparatorsize += size ; } int vertseparatorsize = num_ ; for ( int size : model . getverticalseparators ( ) . values ( ) ) { vertseparatorsize += size ; } return new dimension ( vertseparatorsize + coltox ( cols ) , horizseparatorsize + rowtoy ( rows ) ) ; }	Computes the rendered dimensions of the text grid model, on screen.
private void initializefontmetrics ( ) { if ( ! fontmetricsinitialized ) { fontmetrics fontmetrics = getfontmetrics ( getfont ( ) ) ; charwidth = fontmetrics . charwidth ( str_ ) ; charheight = fontmetrics . getheight ( ) ; descent = fontmetrics . getdescent ( ) ; fontmetricsinitialized = bool_ ; } }	Sets up metrics relating to the size of the font used to display the text grid.
public void addpropertychangelistener ( propertychangelistener l ) {	Adds a property changed listener to be notified of changes to the application state.
public void addpropertychangelistener ( string p , propertychangelistener l ) {	Adds a property changed listener to be notified of changes to the named property.
public void removepropertychangelistener ( string p , propertychangelistener l ) { if ( listeners == null ) { return ; } synchronized ( listeners ) { listeners . remove ( l ) ; } }	Removes the specified property change listener from the list of active listeners.
protected void firepropertychange ( propertychangeevent evt ) {	Notifies all property change listeners of the given PropertyChangeEvent.
public static type createinstance ( string name , double min , double max ) {	Creates a new double range type with the specified name, if it does not already exist.
public void dofade ( colordelta target , string groupname ) { fadestate fadestate = timers . get ( groupname ) ;	Requests a color fade against the specified target, under a group name.
private void showhorizontalbar ( ) {	Creates a horizontal grip-able bar for adjusting the console height.
private void showleftbar ( ) {	Creates a vertical grip-able bar for adjusting the left panel width.
private void showrightbar ( ) {	Creates a vertical grip-able bar for adjusting the right panel width.
private static void sanitizeradiocontrols ( formelement form ) { map < string , element > controlsbyname = new hashmap < string , element > ( ) ; for ( element control : form . elements ( ) ) {	Ensures that radio controls are mutually exclusive within control groups.
public void await ( t t ) throws interruptedexception { synchronized ( monitor ) { long waitnanos = evaluatewithwaittimenanos ( t ) ;	Wait for the predicate to become true on the specified object.
public boolean await ( t t , long timeout , timeunit unit ) throws interruptedexception { synchronized ( monitor ) {	Wait for up to a timeout limit for the predicate to become true on the specified object.
public void execute ( ) throws mojoexecutionexception , mojofailureexception {	Implementation of the script goal.
protected string appendclasspath ( string commandline , boolean unix ) { string pathseperator ; string seperator ; if ( unix ) { pathseperator = str_ ; seperator = str_ ; } else { pathseperator = str_ ; seperator = str_ ; } for ( iterator i = classpathelements . iterator ( ) ; i . hasnext ( ) ; ) { string cppath = ( string ) i . next ( ) ; cppath = cppath . replace ( str_ , pathseperator ) ; commandline += cppath + ( i . hasnext ( ) ? seperator : str_ ) ; } return commandline ; }	Appends the classpath onto the command line.
public static type createinstance ( string name , dateonly from , dateonly to ) {	Creates a new date range type with the specified name, if it does not already exist.
private void printintroduction ( ) { system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( str_ ) ; system . out . println ( ) ; }	Prints a welcome message.
private consolereader initializecommandlinereader ( ) throws ioexception { consolereader reader = new consolereader ( ) ; reader . setbellenabled ( bool_ ) ; return reader ; }	Sets up the JLine console reader.
private void evaluate ( sentence < clause > sentence ) throws sourcecodeexception { clause clause = sentence . gett ( ) ; if ( clause . isquery ( ) ) { engine . endscope ( ) ; engine . compile ( sentence ) ; evaluatequery ( ) ; } else {	Evaluates a query against the resolver or adds a clause to the resolvers domain.
private void evaluatequery ( ) {	Evaluates a query. In the case of queries, the interner is used to recover textual names for the resultingvariable bindings. The user is queried through the parser to if more than one solution is required.
public static multitypedata getmultitypedata ( boolean b ) {	Converts a boolean into a multi type data object.
public static multitypedata getmultitypedata ( byte b ) {	Converts a byte into a multi type data object.
public static multitypedata getmultitypedata ( char c ) {	Converts a char into a multi type data object.
public static multitypedata getmultitypedata ( short s ) {	Converts a short into a multi type data object.
public static multitypedata getmultitypedata ( int i ) {	Converts a int into a multi type data object.
public static multitypedata getmultitypedata ( long l ) {	Converts a long into a multi type data object.
public static multitypedata getmultitypedata ( float f ) {	Converts a float into a multi type data object.
public static multitypedata getmultitypedata ( double d ) {	Converts a double into a multi type data object.
public static multitypedata getmultitypedata ( string s ) { multitypedata result = new multitypedata ( ) ;	Converts a String into a multi type data object.
public static multitypedata getmultitypedata ( object o ) {	Converts a Object into a multi type data object.
public void put ( string name , object value ) { pagecontext . setattribute ( name , value , scope ) ; }	Inserts an object into the scope.
public void clearupto ( int key ) { if ( ( ( start <= key ) && ( key < ( end - num_ ) ) ) ) {	Clears entries up to and including the specified key, from the map.
private void expand ( int key ) {	Expands the size of the storage to whichever is the larger of 1.5 times the old size, or an array large enough tohold the proposed key that caused the expansion, copying the old data into a new array.
private void internalinsert ( char character , int c , int r ) { maxcolumn = ( c > maxcolumn ) ? c : maxcolumn ; maxrow = ( r > maxrow ) ? r : maxrow ; data . put ( ( long ) c , ( long ) r , character ) ; }	Inserts a single character into the grid at the specified location.
public int compare ( searchnode object1 , searchnode object2 ) { float cost1 = object1 . getpathcost ( ) ; float cost2 = object2 . getpathcost ( ) ; return ( cost1 > cost2 ) ? num_ : ( ( cost1 < cost2 ) ? - num_ : num_ ) ; }	Compares two search nodes by their path cost.
public term parseoperators ( term [ ] terms ) throws sourcecodeexception {	Parses a flat list of terms, which are literals, variables, functors, or operators into a tree in such a way thatthe operators associativity and precendence is obeyed.
public enummap < opsymbol . fixity , opsymbol > getoperatorsmatchingnamebyfixity ( string name ) { return operators . get ( name ) ; }	Checks the operator table for all possible operators matching a given name.
protected static opsymbol checkandresolvetofixity ( candidateopsymbol candidate , opsymbol . fixity ... fixities ) throws sourcecodeexception { opsymbol result = null ; for ( opsymbol . fixity fixity : fixities ) { result = candidate . getpossibleoperators ( ) . get ( fixity ) ; if ( result != null ) { break ; } } if ( result == null ) { throw new sourcecodeexception ( str_ + candidate + str_ + arrays . tostring ( fixities ) + str_ , null , null , null , candidate . getsourcecodeposition ( ) ) ; } return result ; }	Checks if a candidate operator symbol can have one of the specified fixities, and resolve it to an oeprator withthat fixity if so.
public searchnode < o , t > makenode ( successor successor ) throws searchnotexhaustiveexception { searchnode newnode ; try {	Makes a new node of the same type as this one from a Successor state.
public string geterrors ( ) {	Lists all the parsing errors from the most recent parsing in a string.
public string getoptionsinforce ( ) {	Lists the properties set from the most recent parsing or an empty string if no parsing has been done yet.
public string getusage ( ) { string result = str_ ; int optionwidth = num_ ; int argumentwidth = num_ ;	Generates a usage string consisting of the name of each option and each options argument description and comment.
public void addtrailingpairstoproperties ( properties properties ) { if ( trailingproperties != null ) { for ( object propkey : trailingproperties . keyset ( ) ) { string name = ( string ) propkey ; string value = trailingproperties . getproperty ( name ) ; properties . setproperty ( name , value ) ; } } }	If a command line has been parsed, calling this method sets all of its free arguments that were name=value pairson the specified properties.
public void addoptionstoproperties ( properties properties ) { if ( parsedproperties != null ) { for ( object propkey : parsedproperties . keyset ( ) ) { string name = ( string ) propkey ; string value = parsedproperties . getproperty ( name ) ;	If a command line has been parsed, calling this method sets all of its options that were set to the specifiedproperties.
protected void addoption ( string option , string comment , string argument , boolean mandatory , string formatregexp ) {	Adds the option to list of available command line options.
private void checkargumentformat ( commandlineoption optioninfo , charsequence matchedarg ) {	Checks the format of an argument to an option against its specified regular expression format if one has beenset.
public static < t , u > string compareiterators ( iterator < u > iterator , iterator < t > expectediterator , function < u , t > mapping ) { string errormessage = str_ ; while ( iterator . hasnext ( ) ) { u next = iterator . next ( ) ; t nextmapped = mapping . apply ( next ) ; t nextexpected = expectediterator . next ( ) ; if ( ! nextmapped . equals ( nextexpected ) ) { errormessage += str_ + nextexpected + str_ + nextmapped ; } } return errormessage ; }	Walks down two iterators, comparing them element by element, using the equals method.
public enumeration listoptions ( ) { vector < option > result ; string desc ; selectedtag tag ; int i ; result = new vector < option > ( ) ; desc = str_ ; for ( i = num_ ; i < tags_stemmers . length ; i ++ ) { tag = new selectedtag ( tags_stemmers [ i ] . getid ( ) , tags_stemmers ) ; desc += str_ + tag . getselectedtag ( ) . getidstr ( ) + str_ + tag . getselectedtag ( ) . getreadable ( ) + str_ ; } result . addelement ( new option ( str_ + desc + str_ + new selectedtag ( stemmer_orengo , tags_stemmers ) + str_ , str_ , num_ , str_ + tag . tooptionlist ( tags_stemmers ) ) ) ; result . addelement ( new option ( str_ + str_ + str_ , str_ , num_ , str_ ) ) ; result . addelement ( new option ( str_ + str_ + str_ , str_ , num_ , str_ ) ) ; result . addelement ( new option ( str_ + str_ , str_ , num_ , str_ ) ) ; return result . elements ( ) ; }	Returns an enumeration describing the available options.
public string [ ] getoptions ( ) { vector < string > result ; result = new vector < string > ( ) ; result . add ( str_ ) ; result . add ( str_ + getstemmer ( ) ) ; result . add ( str_ ) ; result . add ( str_ + getnamedentities ( ) ) ; result . add ( str_ ) ; result . add ( str_ + getstopwords ( ) ) ; result . add ( str_ ) ; result . add ( str_ + getcache ( ) ) ; return result . toarray ( new string [ result . size ( ) ] ) ; }	Gets the current settings of the classifier.
public void setstemmer ( selectedtag value ) { if ( value . gettags ( ) == tags_stemmers ) { m_stemmer = value . getselectedtag ( ) . getid ( ) ; invalidate ( ) ; } }	Sets the stemmer type to use.
protected synchronized ptstemmer . stemmer getactualstemmer ( ) throws ptstemmerexception { if ( m_actualstemmer == null ) {	Returns the stemmer to use.
public string stem ( string word ) { string ret = null ; try { ret = getactualstemmer ( ) . getwordstem ( word ) ; } catch ( ptstemmerexception e ) { e . printstacktrace ( ) ; } return ret ; }	Returns the stemmed version of the given word.Word is converted to lower case before stemming.
public static void main ( string [ ] args ) { try { stemming . usestemmer ( new ptstemmer ( ) , args ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	Runs the stemmer with the given options.
public static type createinstance ( string name , float min , float max ) {	Creates a new float range type with the specified name, if it does not already exist.
public void reset ( ) {	Resets the machine, to its initial state.
protected string traceenvframe ( ) { return str_ + data . get ( ep ) + str_ + data . get ( ep + num_ ) + str_ + data . get ( ep + num_ ) + str_ ; }	Pretty prints the current environment frame, for debugging purposes.
protected string tracechoiceframe ( ) { if ( bp == num_ ) { return str_ ; } int n = data . get ( bp ) ; return str_ + data . get ( bp ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) + str_ + data . get ( bp + n + num_ ) ; }	Pretty prints the current choice point frame, for debugging purposes.
private boolean callinternal ( int function , int arity , int numperms ) { switch ( function ) { case call_1_id : return internalcall_1 ( numperms ) ; case execute_1_id : return internalexecute_1 ( ) ; default : throw new illegalstateexception ( str_ + function ) ; } }	Invokes an internal function.
private int nextstackframe ( ) {	Computes the start of the next stack frame.
private boolean backtrack ( ) {	Backtracks to the continuation label stored in the current choice point frame, if there is one.
private void trail ( int addr ) {	Records the address of a binding onto the 'trail'.
private void unwindtrail ( int a1 , int a2 ) {	Undoes variable bindings that have been recorded on the 'trail'.
private void tidytrail ( ) { int i ;	Tidies trail when a choice point is being discarded, and a previous choice point it being made the current one.
private boolean unify ( int a1 , int a2 ) {	Attempts to unify structures or references on the heap, given two references to them.
private boolean unifyconst ( int fn , int addr ) { boolean success ; int deref = deref ( addr ) ; int tag = dereftag ; int val = derefval ;	A simplified unification algorithm, for unifying against a constant.
private string printslot ( int xi , int mode ) { return ( ( mode == stack_addr ) ? str_ : str_ ) + ( ( mode == stack_addr ) ? ( xi - ep - num_ ) : xi ) ; }	Pretty prints a variable allocation slot for tracing purposes.
public static eightpuzzlestate getrandomstartstate ( ) { eightpuzzlestate newstate ;	Generates a random starting position.
public static boolean issolvable ( eightpuzzlestate state ) {	To check for solvability the empty tile is moved to its goal position and then the number of swaps needed to putthe other tiles in position is counted.
public eightpuzzlestate getchildstateforoperator ( operator op ) {	Applies a move to generate a new board position.
public iterator < operator < string > > validoperators ( boolean reverse ) {	Supplies the valid moves for a board position.
public string prettyprint ( ) { string result = str_ ; for ( int j = num_ ; j < num_ ; j ++ ) { result += new string ( board [ j ] ) + str_ ; } result = result . replace ( str_ , str_ ) ; return result ; }	Pretty prints the board as 3 lines of characters with a space for the empty square.
protected boolean swaptiles ( int x1 , int y1 , int x2 , int y2 ) {	Swaps the two tiles at the specified coordinates.
private static list < character > stringtocharlist ( string boardstring ) {	Turns a string representation of the board into a list of characters.
private static eightpuzzlestate charlisttostate ( list < character > charlist ) {	Turns a list of characters representation of the board into a proper state.
private string tolog4jmessage ( logrecord record ) { string message = record . getmessage ( ) ;	Transforms a java.util.logging.LogRecord to a message printable on Log4J.
private org . apache . log4j . level tolog4j ( level level ) { if ( level . severe == level ) { return org . apache . log4j . level . error ; } else if ( level . warning == level ) { return org . apache . log4j . level . warn ; } else if ( level . info == level ) { return org . apache . log4j . level . info ; } else if ( level . fine == level ) { return org . apache . log4j . level . debug ; } else if ( level . finer == level ) { return org . apache . log4j . level . trace ; } else if ( level . off == level ) { return org . apache . log4j . level . off ; } return org . apache . log4j . level . off ; }	Converts java.util.logging levels to Log4J logging levels.
private void requeue ( e element ) { requeueelementwrapper < e > record = new requeueelementwrapper < e > ( element ) ; requeue . add ( record ) ; requeuedelementmap . put ( element , record ) ; }	Places an element onto the requeue buffer.
private requeueelementwrapper < e > requeue ( e element , object owner , acquirestate acquired ) { requeueelementwrapper < e > record = new requeueelementwrapper < e > ( element ) ; record . state = acquired ; record . owner = owner ; requeue . add ( record ) ; requeuedelementmap . put ( element , record ) ; return record ; }	Places an element onto the requeue buffer, in the acquired state by the specified owner.
private void incrementsizeandcount ( e record ) {	Atomically adds to the size and count, if the queue is running in atomic counting mode, or sizeable mode and theelement is sizeable.
private void decrementsizeandcount ( e record ) {	Atomically subtracts from the size and count, if the queue is running in atomic counting mode, or sizeable modeand the element is sizeable.
private void signalonsizethresholdcrossing ( long oldsize , long newsize ) { if ( signalable != null ) { if ( ( oldsize >= lowwatersizethreshold ) && ( newsize < lowwatersizethreshold ) ) { signalable . signalall ( ) ; } else if ( ( oldsize >= highwatersizethreshold ) && ( newsize < highwatersizethreshold ) ) { signalable . signal ( ) ; } } }	Signals the signallable resource if the size crosses a threshold boundary in a downward direction.
public namingenumeration list ( string name ) throws namingexception { if ( str_ . equals ( name ) ) {	Enumerates the names bound in the named context, along with the class names of objects bound to them.
public namingenumeration listbindings ( string name ) throws namingexception { if ( str_ . equals ( name ) ) {	Enumerates the names bound in the named context, along with the objects bound to them.
public object addtoenvironment ( string propname , object propval ) { if ( myenv == null ) { myenv = new hashtable ( num_ , num_ ) ; } return myenv . put ( propname , propval ) ; }	Adds a new environment property to the environment of this context.
public object removefromenvironment ( string propname ) { if ( myenv == null ) { return null ; } return myenv . remove ( propname ) ; }	Removes an environment property from the environment of this context.
private static void rungctillstable ( ) {	Repeatedly runs the garbage collector and finalization method of the JVM runtime system until the used memorycount becomes stable or 500 iterations occur, whichever happens soonest.
rule literal ( ) { return sequence ( firstof ( color ( ) , multidimension ( ) , dimension ( ) , string ( ) ) , push ( new simplenode ( match ( ) ) ) ) ; }	Tokens that don't need to evaluated.
boolean resolvemixinreference ( string name , argumentsnode arguments ) { if ( ! isparsertranslationenabled ( ) ) { return push ( new placeholdernode ( new simplenode ( name ) ) ) ; }	Locates the referenced mixin in one of the scope nodes on the stack.
boolean pushvariablereference ( string name ) { if ( ! isparsertranslationenabled ( ) ) { return push ( new simplenode ( name ) ) ; }	Looks for a variable definition that matches the reference in the scope nodes on the stack.If found, a reference node that can repeat this lookup later is placed on the stack, not thecurrent value itself.
public void setmaxrowheight ( int row , int height ) { integer previousvalue = maxrowsizes . get ( row ) ; if ( previousvalue == null ) { maxrowsizes . put ( row , height ) ; } else if ( previousvalue < height ) { maxrowsizes . put ( row , height ) ; } }	Updates the maximum row height for a row of the data table.
private void updatemaxcolumnwidth ( int column , int width ) { integer previousvalue = maxcolumnsizes . get ( column ) ; if ( previousvalue == null ) { maxcolumnsizes . put ( column , width ) ; } else if ( previousvalue < width ) { maxcolumnsizes . put ( column , width ) ; } }	Updates the maximum column width for a column of the data table.
public heuristicsearchnode < o , t > makenode ( successor successor ) throws searchnotexhaustiveexception { heuristicsearchnode < o , t > node = ( heuristicsearchnode < o , t > ) super . makenode ( successor ) ;	Returns a new node based on a successor of this node.
public actionforward execute ( actionmapping mapping , actionform form , httpservletrequest request , httpservletresponse response ) throws ioexception , servletexception { log . fine ( str_ ) ;	Processes the action providing default error handling.
private void substitutebuiltins ( term clause ) { termwalker walk = termwalkers . positionalwalker ( new builtintransformvisitor ( interner , symboltable , null , builtintransform ) ) ; walk . walk ( clause ) ; }	Substitutes built-ins within a clause, with their built-in definitions.
private void initialisesymboltable ( term clause ) {	Runs a symbol key traverser over the clause to be compiled, to ensure that all of its terms and sub-terms havetheir symbol keys initialised.
private void toplevelcheck ( term clause ) { termwalker walk = termwalkers . positionalwalker ( new toplevelcheckvisitor ( interner , symboltable , null ) ) ; walk . walk ( clause ) ; }	Finds and marks all functors within the clause that are considered to be top-level.
private string listtostring ( variableandfunctorinterner interner , boolean isfirst , boolean printvarname , boolean printbindings ) { string result = str_ ; if ( isfirst ) { result += str_ ; } result += arguments [ num_ ] . tostring ( interner , printvarname , printbindings ) ; term consargument = arguments [ num_ ] . getvalue ( ) ; if ( consargument instanceof cons ) { result += str_ + ( ( cons ) consargument ) . listtostring ( interner , bool_ , printvarname , printbindings ) ; } if ( isfirst ) { result += str_ ; } return result ; }	Pretty prints a term relative to the symbol namings provided by the specified interner.
protected boolean evaluate ( numerictype firstnumber , numerictype secondnumber ) {	Evaluates the arithmetic comparison on its two numeric arguments.
public void running ( ) { try { statelock . writelock ( ) . lock ( ) ; if ( state == state . initial ) { state = state . running ; statechange . signalall ( ) ; } } finally { statelock . writelock ( ) . unlock ( ) ; } }	Makes a transaction from the Initial state to the Running state, or no transition if the current state is notInitial.
public void terminating ( ) { try { statelock . writelock ( ) . lock ( ) ; if ( state == state . running ) { state = state . shutdown ; statechange . signalall ( ) ; } } finally { statelock . writelock ( ) . unlock ( ) ; } }	Makes a transaction from the Running state to the Shutdown state, or no transition if the current state is notRunning.
public void terminated ( ) { try { statelock . writelock ( ) . lock ( ) ; if ( ( state == state . shutdown ) || ( state == state . running ) ) { state = state . terminated ; statechange . signalall ( ) ; } } finally { statelock . writelock ( ) . unlock ( ) ; } }	Makes a transaction from the Running or Shutdown state to the Terminated state, or no transition if the currentstate is not Running or Shutdown.
public boolean offer ( e o ) {	Inserts the specified element into this heap.
private int compare ( node node1 , node node2 ) {	Compares two heap nodes.
private void insertnodes ( node node , node newnode ) {	Inserts a single node or a circular doubly linked list of nodes into a list next to the specified node.
public void restart ( ) {	Restarts the sweep alogirithm.
public static < t > set < t > setof ( searchmethod < t > method ) { set < t > result = new hashset < t > ( ) ; findall ( result , method ) ; return result ; }	Finds the set of all goals of a search.
public static < t > collection < t > bagof ( searchmethod < t > method ) { collection < t > result = new arraylist < t > ( ) ; findall ( result , method ) ; return result ; }	Finds a bag of all goals of a search.
private static < t > void findall ( collection < t > result , searchmethod < t > method ) { for ( iterator < t > i = allsolutions ( method ) ; i . hasnext ( ) ; ) { t nextsoltn = i . next ( ) ; result . add ( nextsoltn ) ; } }	Finals all solutions to a search and inserts them into the specified collection.
public t nextinsequence ( ) { t result = null ;	Generates the next element in the sequence.
public static void restorevalues ( object ob , map < string , object > values ) throws nosuchfieldexception {	Restores the properties currently in this memento to the specified object.
public object get ( class cls , string property ) throws nosuchfieldexception {	Gets the value of the named property of the specified class.
public void put ( class cls , string property , typeconverter . multitypedata value ) {	Sets the value of the named property as a multi type object.
public void put ( class cls , string property , object value ) {	Places the specified value into the memento based on the property's declaring class and name.
private void capture ( boolean ignorenull ) {	Captures the fields of the associated object.
public e pop ( ) { e ob ; if ( size ( ) == num_ ) { return null ; } ob = get ( num_ ) ; remove ( num_ ) ; return ob ; }	Pops the first object placed on the stack off of it and returns it.
private string modifierstostring ( int modifiers ) { string result = str_ ; if ( ( modifiers & inputevent . shift_mask ) != num_ ) { result += str_ ; } if ( ( modifiers & inputevent . ctrl_mask ) != num_ ) { result += str_ ; } if ( ( modifiers & inputevent . meta_mask ) != num_ ) { result += str_ ; } if ( ( modifiers & inputevent . alt_mask ) != num_ ) { result += str_ ; } if ( ( modifiers & inputevent . alt_graph_mask ) != num_ ) { result += str_ ; } return result ; }	Converts the modifiers to a specification string for KeyStroke.
public static int tointeger ( string s ) { try { return integer . parseint ( s ) ; } catch ( numberformatexception e ) {	Converts a string to an integer.
public static date todate ( string s ) {	Converts a string to a date.
public static boolean isdate ( string s ) {	Check that a string is a date in the format specified by dateFormat.
public static boolean istime ( string s ) {	Checks that a string is a time in the format specified by timeFormat.
public static boolean isdatetime ( string s ) { dateformat dateformatter = new simpledateformat ( datetimeformat ) ; try { dateformatter . parse ( s ) ; return bool_ ; } catch ( parseexception e ) {	Checks that a string is a datetime in the format specified by dateTimeFormat.
public static tokensource gettokensourceforstring ( string stringtotokenize ) { simplecharstream inputstream = new simplecharstream ( new stringreader ( stringtotokenize ) , num_ , num_ ) ; prologparsertokenmanager tokenmanager = new prologparsertokenmanager ( inputstream ) ; return new tokensource ( tokenmanager ) ; }	Creates a token source on a string.
public static tokensource gettokensourceforfile ( file file ) throws filenotfoundexception {	Creates a token source on a file.
public static source gettokensourceforinputstream ( inputstream in ) { simplecharstream inputstream = new simplecharstream ( in , num_ , num_ ) ; prologparsertokenmanager tokenmanager = new prologparsertokenmanager ( inputstream ) ; return new tokensource ( tokenmanager ) ; }	Creates a token source on an input stream.
public boolean isconstant ( waminstruction instruction ) { integer name = instruction . getfunctornamereg1 ( ) ; if ( name != null ) { functorname functorname = interner . getdeinternedfunctorname ( name ) ; if ( functorname . getarity ( ) == num_ ) { return bool_ ; } } return bool_ ; }	Checks if the term argument to an instruction was a constant.
private boolean isvoidvariable ( waminstruction instruction ) { symbolkey symbolkey = instruction . getsymbolkeyreg1 ( ) ; if ( symbolkey != null ) { integer count = ( integer ) symboltable . get ( symbolkey , symboltablekeys . symkey_var_occurrence_count ) ; boolean nonargpositiononly = ( boolean ) symboltable . get ( symbolkey , symboltablekeys . symkey_var_non_arg ) ; integer allocation = ( integer ) symboltable . get ( symbolkey , symboltablekeys . symkey_allocation ) ; boolean singleton = ( count != null ) && count . equals ( num_ ) ; boolean nonargposition = ( nonargpositiononly != null ) && true . equals ( nonargpositiononly ) ; boolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & num_ ) > > num_ ) == waminstruction . stack_addr ) ; if ( singleton && nonargposition && ! permanent ) { return bool_ ; } } return bool_ ; }	Checks if the term argument to an instruction was a singleton, non-argument position variable.
private boolean isnonarg ( waminstruction instruction ) { symbolkey symbolkey = instruction . getsymbolkeyreg1 ( ) ; if ( symbolkey != null ) { boolean nonargpositiononly = ( boolean ) symboltable . get ( symbolkey , symboltablekeys . symkey_functor_non_arg ) ; if ( true . equals ( nonargpositiononly ) ) { return bool_ ; } } return bool_ ; }	Checks if the term argument to an instruction was in a non-argument position.
public iterator < operator < term > > getchildren ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof clausetraverser ) ) { return ( ( clausetraverser ) traverser ) . traverse ( this , reverse ) ; } else { linkedlist < operator < term > > resultlist = null ; if ( ! reverse ) { resultlist = new linkedlist < operator < term > > ( ) ; } else { resultlist = new stackqueue < operator < term > > ( ) ; } if ( head != null ) { resultlist . add ( head ) ; } if ( body != null ) { for ( term bodyterm : body ) { resultlist . add ( bodyterm ) ; } } return resultlist . iterator ( ) ; } }	Provides an iterator over the child terms, if there are any.
public term getargument ( int index ) { if ( ( arguments == null ) || ( index > ( arguments . length - num_ ) ) ) { return null ; } else { return arguments [ index ] ; } }	Gets the argument within the functor with the specified index.
public iterator < operator < term > > getchildren ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof functortraverser ) ) { return ( ( functortraverser ) traverser ) . traverse ( this , reverse ) ; } else { if ( arguments == null ) { return new linkedlist < operator < term > > ( ) . iterator ( ) ; } else if ( ! reverse ) { return arrays . aslist ( ( operator < term > [ ] ) arguments ) . iterator ( ) ; } else { list < operator < term > > arglist = new linkedlist < operator < term > > ( ) ; for ( int i = arity - num_ ; i >= num_ ; i -- ) { arglist . add ( arguments [ i ] ) ; } return arglist . iterator ( ) ; } } }	Provides an iterator over the child terms, if there are any.
protected string tostringarguments ( ) { string result = str_ ; if ( arity > num_ ) { result += str_ ; for ( int i = num_ ; i < arity ; i ++ ) { term nextarg = arguments [ i ] ; result += ( ( nextarg != null ) ? nextarg . tostring ( ) : str_ ) + ( ( i < ( arity - num_ ) ) ? str_ : str_ ) ; } result += str_ ; } return result ; }	Creates a string representation of this functors arguments, mostly used for debugging purposes.
public < t extends measureappender > t retrievesummary ( schemadefinition schemadefinition , class < t > resultclazz , queryparameter queryparameter ) throws novieruntimeexception { final sqlquerybuilder < t > sqlquerybuilder = new sqlquerybuilder < t > ( schemadefinition , resultclazz , queryparameter . partialcopy ( queryparameterkind . groups , queryparameterkind . page ) ) ; list < t > result = executequery ( sqlquerybuilder ) ; if ( result . isempty ( ) ) { throw new novieruntimeexception ( str_ ) ; } if ( result . size ( ) > num_ ) { throw new novieruntimeexception ( str_ ) ; } return result . get ( num_ ) ; }	Execute a query to retrieve the summary. This do not have any group by element.
public < t extends measureappender > list < t > retrieverecords ( schemadefinition schemadefinition , class < t > resultclazz , queryparameter queryparameter ) throws novieruntimeexception { final sqlquerybuilder < t > sqlquerybuilder = new sqlquerybuilder < t > ( schemadefinition , resultclazz , queryparameter ) ; return executequery ( sqlquerybuilder ) ; }	Execute a query to retrieve the records.
private < t extends measureappender > list < t > executequery ( final sqlquerybuilder < t > sqlquerybuilder ) throws novieruntimeexception { sqlquerybuilder . buildquery ( ) ; final string querystring = sqlquerybuilder . getquerystring ( ) ; log . debug ( querystring ) ; long beforequery = system . currenttimemillis ( ) ; list < t > returnvalue = jdbctemplate . query ( querystring , sqlquerybuilder . getmapsqlparametersource ( ) , sqlquerybuilder ) ; if ( log . isinfoenabled ( ) ) { log . info ( str_ + ( system . currenttimemillis ( ) - beforequery ) + str_ ) ; } if ( log . isdebugenabled ( ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( entry < string , object > e : sqlquerybuilder . getmapsqlparametersource ( ) . getvalues ( ) . entryset ( ) ) { if ( sb . length ( ) > num_ ) { sb . append ( str_ ) ; } sb . append ( e . getkey ( ) ) ; sb . append ( str_ ) ; sb . append ( e . getvalue ( ) ) ; } sb . insert ( num_ , str_ ) ; sb . append ( str_ ) ; log . debug ( sb . tostring ( ) ) ; } return returnvalue ; }	Private methode called by the public ones to effectively run the query.
public void emmitcode ( bytebuffer codebuffer , wammachine machine ) throws linkageexception { mnemonic . emmitcode ( this , codebuffer , machine ) ; }	Writes out the instruction plus arguments in the byte code format to the specified location within a code buffer.
private void setbasictype ( class c ) { if ( boolean . class . equals ( c ) ) { type = basictypes . boolean ; } else if ( character . class . equals ( c ) ) { type = basictypes . character ; } else if ( byte . class . equals ( c ) ) { type = basictypes . byte ; } else if ( short . class . equals ( c ) ) { type = basictypes . short ; } else if ( integer . class . equals ( c ) ) { type = basictypes . integer ; } else if ( long . class . equals ( c ) ) { type = basictypes . long ; } else if ( float . class . equals ( c ) ) { type = basictypes . float ; } else if ( double . class . equals ( c ) ) { type = basictypes . double ; } else { type = basictypes . other ; } }	Sets the basic type of this type depending on the class.
public void consultinputstream ( inputstream stream ) throws sourcecodeexception {	Consults an input stream, reading first order logic clauses from it, and inserting them into the resolversknowledge base.
public string printvariablebinding ( term var ) { return var . tostring ( getinterner ( ) , bool_ , bool_ ) + str_ + var . getvalue ( ) . tostring ( getinterner ( ) , bool_ , bool_ ) ; }	Prints a variable binding in the form 'Var = value'.
public iterable < map < string , variable > > expandresultsettomap ( iterator < set < variable > > solutions ) { return new filterator < set < variable > , map < string , variable > > ( solutions , new function < set < variable > , map < string , variable > > ( ) { public map < string , variable > apply ( set < variable > variables ) { map < string , variable > results = new hashmap < string , variable > ( ) ; for ( variable var : variables ) { string varname = getinterner ( ) . getvariablename ( var . getname ( ) ) ; results . put ( varname , var ) ; } return results ; } } ) ; }	Transforms an iterator over sets of variable bindings, resulting from a query, to an iterator over a map from thestring name of variables to their bindings, for the same sequence of query solutions.
public void run ( ) { try { readstream ( ) ; } catch ( eofexception eof ) {	A dedicated thread loop for reading the stream and sending incomingpackets to the appropriate router.
private void readstream ( ) throws exception { while ( ! shutdown ) { element doc = reader . parsedocument ( ) . getrootelement ( ) ; if ( doc == null ) {	Read the incoming stream until it ends.
static long gettime ( ) { if ( random == null ) initializefortype1 ( ) ; long newtime = getuuidtime ( ) ; if ( newtime <= _lastmillis ) { incrementsequence ( ) ; newtime = getuuidtime ( ) ; } _lastmillis = newtime ; return newtime ; }	package-visibility for testing.
private static long getuuidtime ( ) { if ( _currentmillis != system . currenttimemillis ( ) ) { _currentmillis = system . currenttimemillis ( ) ; _counter = num_ ;	Gets the appropriately modified timestamep for the UUID.
@ suppresswarnings ( str_ ) public void trackinfoupdate ( playlist playlist , trackinfo info ) { this . playlist = playlist ; updateplayinfo ( info ) ; }	call this method if the trackInfo object in the playlist was updated. Only the trackinfo object will be sent viaEvent.
@ suppresswarnings ( str_ ) public void updateplayinfo ( playlist playlist , progress progress , volume volume ) { if ( playlist != null ) this . playlist = playlist ; if ( progress != null ) this . progress = progress ; if ( volume != null ) this . volume = volume ; updateplayinfo ( playlist , progress , null , volume ) ; }	updates the Info about the current song.
@ override public void renderfinaloutput ( list < t > data , eventmodel eventmodel ) { if ( startmusicrequest . verify ( eventmodel , capabilities , this , activators ) ) { if ( isoutputrunning ( ) ) { playererror ( playererror . error_already_playing , eventmodel . getsource ( ) ) ; } else { handleeventrequest ( eventmodel ) ; } } else if ( eventmodel . getlistresourcecontainer ( ) . providesresource ( collections . singletonlist ( musicusageresource . id ) ) ) { if ( isoutputrunning ( ) ) { eventmodel . getlistresourcecontainer ( ) . provideresource ( musicusageresource . id ) . foreach ( resourcemodel -> playererror ( playererror . error_already_playing , resourcemodel . getprovider ( ) ) ) ; } else { handleresourcerequest ( eventmodel ) ; } } else { handlecommands ( eventmodel ) ; } }	method that uses the data from the OutputExtensions to generate a final output that will then be rendered.
private void handleresourcerequest ( eventmodel eventmodel ) { if ( musicusageresource . ispermanent ( eventmodel ) ) { resourcemodel resourcemodel = eventmodel . getlistresourcecontainer ( ) . provideresource ( musicusageresource . id ) . stream ( ) . filter ( musicusageresource :: ispermanent ) . findany ( ) . orelse ( null ) ;	handles the a request to start playing music via Resource.
private void handleeventrequest ( eventmodel eventmodel ) { playingthread = submit ( ( runnable ) ( ) -> {	handles the a request to start playing music via Event.
protected void firestartmusicrequest ( eventmodel eventmodel ) { optional < playlist > playlist = playlistresource . getplaylist ( eventmodel ) ; optional < progress > progress = progressresource . getprogress ( eventmodel ) ; optional < trackinfo > trackinfo = trackinforesource . gettrackinfo ( eventmodel ) ; optional < volume > volume = volumeresource . getvolume ( eventmodel ) ; startedsound ( playlist . orelse ( null ) , progress . orelse ( null ) , trackinfo . orelse ( null ) , volume . orelse ( null ) , isusingjava ) ; }	this method will be called to create and fire the StartMusicRequest.
protected void init ( ) { done = bool_ ; connectionid = null ; readerthread = new thread ( ) { public void run ( ) { parsepackets ( this ) ; } } ; readerthread . setname ( str_ + connection . connectioncountervalue + str_ ) ; readerthread . setdaemon ( bool_ ) ;	Initializes the reader in order to be used.
synchronized public void startup ( ) throws xmppexception { final list < exception > errors = new linkedlist < exception > ( ) ; abstractconnectionlistener connectionerrorlistener = new abstractconnectionlistener ( ) { @ override public void connectionclosedonerror ( exception e ) { errors . add ( e ) ; } } ; connection . addconnectionlistener ( connectionerrorlistener ) ; readerthread . start ( ) ;	Starts the packet reader thread and returns once a connection to theserver has been established.
public void shutdown ( ) {	Shuts the packet reader down.
private void resetparser ( ) { try { innerreader = new xpppacketreader ( ) ; innerreader . setxppfactory ( xmlpullparserfactory . newinstance ( ) ) ; innerreader . getxppparser ( ) . setinput ( connection . reader ) ; reset = bool_ ; } catch ( exception xppe ) { logger . log ( level . warn , str_ , xppe ) ; } }	Resets the parser using the latest connection's reader.
private void parsepackets ( thread thread ) { try { while ( ! done ) { if ( reset ) { startstream ( ) ; logger . debug ( str_ ) ; reset = bool_ ; continue ; } element doc = innerreader . parsedocument ( ) . getrootelement ( ) ; if ( doc == null ) { connection . disconnect ( ) ; logger . debug ( str_ ) ; continue ; } packet packet = null ; logger . debug ( str_ + doc . asxml ( ) ) ; packet = parsefromplugins ( doc , packet ) ; if ( packet == null ) { packet = parsefromcore ( doc ) ; } if ( packet != null ) { processpacket ( packet ) ; } } } catch ( exception e ) { if ( ! done && ! connection . issocketclosed ( ) ) { connection . notifyconnectionerror ( e ) ; if ( ! connection . isconnected ( ) ) { releaseconnectionidlock ( ) ; } } } }	Parse top-level packets in order to process them further.
private void processpacket ( packet packet ) { if ( packet == null ) { return ; }	Processes a packet after it's been fully parsed by looping through theinstalled packet collectors and listeners and letting them examine thepacket to see if they are a match with the filter.
protected final void setclioption ( option option ) { if ( option != null ) { this . clioption = option ; } if ( this . clioption . getdescription ( ) != null ) { this . descr = this . clioption . getdescription ( ) ; } else { this . clioption . setdescription ( this . descr ) ; } }	Sets the CLI option.
public chat createchat ( string userjid , messagelistener listener ) { return createchat ( userjid , null , listener ) ; }	Creates a new chat and returns it.
void internalize ( contentmanagerimpl contentmanager , boolean readonly ) { this . contentmanager = contentmanager ; updated = bool_ ; newcontent = bool_ ; this . readonly = readonly ; }	Convert a new content object to an internal version.
public void reset ( map < string , object > updatedmap ) { if ( ! readonly ) { this . content = immutablemap . copyof ( updatedmap ) ; updatedcontent . clear ( ) ; updated = bool_ ; logger . debug ( str_ , updatedmap ) ; } }	Reset the object back to its last saved state.
public void setproperty ( string key , object value ) { if ( readonly ) { return ; } if ( value == null ) { throw new illegalargumentexception ( str_ ) ; } object o = content . get ( key ) ; if ( ! value . equals ( o ) ) { updatedcontent . put ( key , value ) ; updated = bool_ ; } else if ( updatedcontent . containskey ( key ) && ! value . equals ( updatedcontent . get ( key ) ) ) { updatedcontent . put ( key , value ) ; updated = bool_ ; } }	set a property, creating if it does not exist, overwriting if it does.
public void addfilter ( packetfilter filter ) { if ( filter == null ) { throw new illegalargumentexception ( str_ ) ; }	Adds a filter to the filter list for the OR operation.
public void processrequest ( httpservletrequest request ) throws ioexception , fileuploadexception , storageclientexception , accessdeniedexception { boolean debug = logger . isdebugenabled ( ) ; if ( servletfileupload . ismultipartcontent ( request ) ) { if ( debug ) { logger . debug ( str_ ) ; } feedback . add ( str_ ) ; servletfileupload upload = new servletfileupload ( ) ; fileitemiterator iterator = upload . getitemiterator ( request ) ; while ( iterator . hasnext ( ) ) { fileitemstream item = iterator . next ( ) ; if ( debug ) { logger . debug ( str_ , item ) ; } string name = item . getfieldname ( ) ; inputstream stream = item . openstream ( ) ; if ( item . isformfield ( ) ) { parametertype pt = parametertype . typeofrequestparameter ( name ) ; string propertyname = requestutils . propertyname ( pt . getpropertyname ( name ) ) ; requestutils . accumulate ( stores . get ( pt ) , propertyname , requestutils . tovalue ( name , streams . asstring ( stream ) ) ) ; feedback . add ( pt . feedback ( propertyname ) ) ; } else { if ( streamprocessor != null ) { feedback . addall ( streamprocessor . processstream ( name , storageclientutils . getobjectname ( item . getname ( ) ) , item . getcontenttype ( ) , stream , this ) ) ; } } } if ( debug ) { logger . debug ( str_ ) ; } } else { if ( debug ) { logger . debug ( str_ ) ; }	Process the request in a stream.
public void resetproperties ( ) { for ( entry < parametertype , map < string , object > > e : stores . entryset ( ) ) { e . getvalue ( ) . clear ( ) ; } }	Clear the current set of properties to add and remove.
protected void init ( ) { this . writer = connection . writer ; done = bool_ ; writerthread = new thread ( ) { public void run ( ) { writepackets ( this ) ; } } ; writerthread . setname ( str_ + connection . connectioncountervalue + str_ ) ; writerthread . setdaemon ( bool_ ) ; }	Initializes the writer in order to be used.
public void sendpacket ( packet packet ) { if ( ! done ) {	Sends the specified packet to the server.
private packet nextpacket ( ) { packet packet = null ;	Returns the next available packet from the queue for writing.
void openstream ( ) throws ioexception { stringbuilder stream = new stringbuilder ( ) ; stream . append ( str_ ) ; stream . append ( str_ ) . append ( connection . getservicename ( ) ) . append ( str_ ) ; stream . append ( str_ ) ; stream . append ( str_ ) ; stream . append ( str_ ) ; writer . write ( stream . tostring ( ) ) ; writer . flush ( ) ; }	Sends to the server a new stream element.
@ override public list < string > getallinformations ( ) { arraylist < string > strings = new arraylist < > ( descriptors ) ; strings . add ( type ) ; return strings ; }	returns a List containing all the Descriptors and the type.
@ override public boolean containsdescriptor ( string descriptor ) { return descriptors . contains ( descriptor ) || type . equals ( descriptor ) ; }	returns whether the event contains the specific descriptor.this method also checks whether it matches the type.
@ suppresswarnings ( str_ ) public event addeventlifecyclelistener ( eventlifecycle eventlifecycle , consumer < eventlifecycle > cyclecallback ) { lifecyclelisteners . compute ( eventlifecycle , ( unused , list ) -> { if ( list == null ) list = new arraylist < > ( ) ; list . add ( cyclecallback ) ; return list ; } ) ; return this ; }	adds the Consumer to the specified EventLifeCycle.In its current implementation the invocation of the Callback method is parallel, but the notificaton of the listners not.
public void shutdown ( ) { if ( executor != null ) { executor . shutdownnow ( ) ; executor = null ; } if ( timer != null ) { timer . cancel ( ) ; timer = null ; } }	Shuts down the task engine service.
private boolean validentry ( final entry < k , v > entry ) { if ( auto_commit || entry == null ) return ( entry != null ) ; string id = getcurrentthreadid ( ) ; return ! ( ( entry . is ( entry . deleted , id ) ) || ( entry . is ( entry . added , null ) && entry . is ( entry . no_change , id ) ) ) ; }	Checks that this entry is valid for the current thread.
@ suppresswarnings ( str_ ) static < t > t masknull ( t key ) { return ( key == null ? ( t ) null_key : key ) ; }	Returns internal representation for key.
static boolean eq ( object x , object y ) { return x == y || x . equals ( y ) ; }	Check for equality of non-null reference x and possibly-null y.
entry < k , v > getentry ( object key ) { object k = masknull ( key ) ; int hash = hash ( k ) ; int i = indexfor ( hash , table . length ) ; entry < k , v > e = table [ i ] ; while ( e != null && ! ( e . hash == hash && validentry ( e ) && eq ( k , e . key ) ) ) e = e . next ; return e ; }	Returns the entry associated with the specified key in theHashMap.
@ suppresswarnings ( str_ ) void resize ( int newcapacity ) { entry < k , v > [ ] oldtable = table ; int oldcapacity = oldtable . length ; if ( oldcapacity == maximum_capacity ) { threshold = integer . max_value ; return ; } entry < k , v > [ ] newtable = new entry [ newcapacity ] ; transfer ( newtable ) ; table = newtable ; threshold = ( int ) ( newcapacity * loadfactor ) ; }	Rehashes the contents of this map into a new array with alarger capacity.
@ override public void putall ( map < ? extends k , ? extends v > m ) { int numkeystobeadded = m . size ( ) ; if ( numkeystobeadded == num_ ) return ; if ( numkeystobeadded > threshold ) { int targetcapacity = ( int ) ( numkeystobeadded / loadfactor + num_ ) ; if ( targetcapacity > maximum_capacity ) targetcapacity = maximum_capacity ; int newcapacity = table . length ; while ( newcapacity < targetcapacity ) newcapacity <<= num_ ; if ( newcapacity > table . length ) resize ( newcapacity ) ; } for ( iterator < ? extends map . entry < ? extends k , ? extends v > > i = m . entryset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { map . entry < ? extends k , ? extends v > e = i . next ( ) ; put ( e . getkey ( ) , e . getvalue ( ) ) ; } }	Copies all of the mappings from the specified map to this mapThese mappings will replace any mappings thatthis map had for any of the keys currently in the specified map.
@ override public v remove ( object key ) throws concurrentmodificationexception { entry < k , v > e = removeentryforkey ( key ) ; return ( e == null ? null : e . value ) ; }	Removes the mapping for this key from this map if present.
entry < k , v > removeentryforkey ( object key ) throws concurrentmodificationexception { object k = masknull ( key ) ; int hash = hash ( k ) ; int i = indexfor ( hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > e = prev ; while ( e != null ) { entry < k , v > next = e . next ; if ( e . hash == hash && validentry ( e ) && eq ( k , e . key ) ) { if ( e . is ( entry . deleted , null ) && ! e . is ( entry . deleted , getcurrentthreadid ( ) ) ) throw new concurrentmodificationexception ( ) ; if ( auto_commit ) { modcount ++ ; size -- ; if ( prev == e ) table [ i ] = next ; else prev . next = next ; return e ; } else e . setstatus ( entry . deleted , getcurrentthreadid ( ) ) ; } prev = e ; e = next ; } return e ; }	Removes and returns the entry associated with the specified keyin the HashMap.
@ suppresswarnings ( str_ ) entry < k , v > removemapping ( object o ) { if ( ! ( o instanceof map . entry ) ) return null ; map . entry < k , v > entry = ( map . entry < k , v > ) o ; object k = masknull ( entry . getkey ( ) ) ; int hash = hash ( k ) ; int i = indexfor ( hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > e = prev ; while ( e != null ) { entry < k , v > next = e . next ; if ( e . hash == hash && validentry ( e ) && e . equals ( entry ) ) { if ( auto_commit ) { modcount ++ ; size -- ; if ( prev == e ) table [ i ] = next ; else prev . next = next ; } else e . setstatus ( entry . deleted , getcurrentthreadid ( ) ) ; return e ; } prev = e ; e = next ; } return e ; }	Special version of remove for EntrySet.
void addentry ( int hash , k key , v value , int bucketindex ) { table [ bucketindex ] = new entry < k , v > ( hash , key , value , table [ bucketindex ] ) ; if ( ! auto_commit ) table [ bucketindex ] . setstatus ( entry . added , getcurrentthreadid ( ) ) ; if ( size ++ >= threshold ) resize ( num_ * table . length ) ; }	Add a new entry with the specified key, value and hash code tothe specified bucket.
private static < k , v > immutablemap < k , v > createdelegate ( final map < k , v > base , final set < ? extends k > keys , final function < k , v > augmentation ) { final immutablemap . builder < k , v > builder = immutablemap . builder ( ) ; builder . putall ( base ) ; keys . stream ( ) . filter ( key -> ! base . containskey ( key ) ) . foreach ( key -> builder . put ( key , augmentation . apply ( key ) ) ) ; return builder . build ( ) ; }	Creates map delegate.
private static string xmlattribencodebinary ( string value ) { stringbuilder s = new stringbuilder ( ) ; char buf [ ] = value . tochararray ( ) ; for ( char c : buf ) { switch ( c ) { case str_ : s . append ( str_ ) ; break ; case str_ : s . append ( str_ ) ; break ; case str_ : s . append ( str_ ) ; break ; case str_ : s . append ( str_ ) ; break ; case str_ : s . append ( str_ ) ; break ; default : if ( c <= num_ || ( num_ <= c && c <= num_ ) ) {	Encodes a string for use in an XML attribute by escaping characters witha special meaning.
public static string encodehex ( byte [ ] bytes ) { stringbuilder hex = new stringbuilder ( bytes . length * num_ ) ; for ( byte abyte : bytes ) { if ( ( ( int ) abyte & num_ ) < num_ ) { hex . append ( str_ ) ; } hex . append ( integer . tostring ( ( int ) abyte & num_ , num_ ) ) ; } return hex . tostring ( ) ; }	Encodes an array of bytes as String representation of hexadecimal.
public static string encodebase64 ( string data ) { byte [ ] bytes = null ; try { bytes = data . getbytes ( str_ ) ; } catch ( unsupportedencodingexception uee ) { throw new illegalstateexception ( uee ) ; } return encodebase64 ( bytes ) ; }	Encodes a String as a base64 String.
public static string encodebase64 ( byte [ ] data , int offset , int len , boolean linebreaks ) { return base64 . encodebytes ( data , offset , len , ( linebreaks ? base64 . no_options : base64 . dont_break_lines ) ) ; }	Encodes a byte array into a bse64 String.
@ override public integer iterate ( final filterablecollection < ? extends t > c ) { checkused ( ) ;	Overridden to just get the count, and nothing else.
public void settrackselectorcontroller ( consumer < trackinfo > controller ) { if ( controller == null ) return ; selecttrack = controller ; capabilities . setabletoselecttrack ( bool_ ) ; }	adds the ability to select tracks.
public void setjumpprogresscontroller ( consumer < progress > controller ) { if ( controller == null ) return ; jumpprogress = controller ; capabilities . setabletojump ( bool_ ) ; }	adds the ability to jump to a specified position of the current track.
public void setplaybackchangeablecontroller ( consumer < string > controller ) { if ( controller == null ) return ; changeplayback = controller ; capabilities . setplaybackchangeable ( bool_ ) ; }	adds the ability to change the playback.
public void setvolumechangeablecontroller ( consumer < volume > controller ) { if ( controller == null ) return ; changevolume = controller ; capabilities . setchangevolume ( bool_ ) ; }	adds the ability to change the volume from outside the player.
public void broadcastavailableplaylists ( supplier < list < string > > availableplaylist , function < string , playlist > playlistfornamefunction ) { if ( availableplaylist == null || playlistfornamefunction == null ) return ; this . availableplaylist = availableplaylist ; this . playlistfornamefunction = playlistfornamefunction ; capabilities . setbroadcasting ( bool_ ) ; }	adds the ability to return the available playlists on request.
public void handlecommandresources ( eventmodel eventmodel ) { list < resourcemodel < string > > resourcemodels = eventmodel . getlistresourcecontainer ( ) . provideresource ( commandresource . resourceid ) . stream ( ) . filter ( resourcemodel -> resourcemodel . getresource ( ) instanceof string ) . map ( resourcemodel -> { try {	this method gets called when a new Command was found. It automatically fires the update Event or an error.
private void handlevolume ( eventmodel eventmodel , resourcemodel < string > resourcemodel ) { optional < volume > volumeresource = volumeresource . getvolume ( eventmodel ) ; if ( ! volumeresource . ispresent ( ) ) { musichelper . playererror ( playererror . error_illegal + str_ + resourcemodel . getresource ( ) + str_ , resourcemodel . getprovider ( ) ) ; } changevolume . accept ( volumeresource . get ( ) ) ; }	handles the volume-command.
private void handlejump ( eventmodel eventmodel , resourcemodel < string > resourcemodel ) { optional < progress > progress = progressresource . getprogress ( eventmodel ) ; if ( ! progress . ispresent ( ) ) { musichelper . playererror ( playererror . error_illegal + str_ + resourcemodel . getresource ( ) + str_ , resourcemodel . getprovider ( ) ) ; } jumpprogress . accept ( progress . get ( ) ) ; }	handles the jump-command.
private void handleselecttrack ( eventmodel eventmodel , resourcemodel < string > resourcemodel ) { optional < trackinfo > trackinfo = trackinforesource . gettrackinfo ( eventmodel ) ; if ( ! trackinfo . ispresent ( ) ) { musichelper . playererror ( playererror . error_illegal + str_ + resourcemodel . getresource ( ) + str_ , resourcemodel . getprovider ( ) ) ; } selecttrack . accept ( trackinfo . get ( ) ) ; }	handles the select Track command.
@ suppresswarnings ( str_ ) private < v > cache < v > getthreadcache ( string name ) { map < string , cache < ? > > threadcachemap = threadcachemapholder . get ( ) ; cache < v > threadcache = ( cache < v > ) threadcachemap . get ( name ) ; if ( threadcache == null ) { threadcache = new mapcacheimpl < v > ( ) ; threadcachemap . put ( name , threadcache ) ; } return threadcache ; }	Generate a cache bound to the thread.
@ suppresswarnings ( str_ ) private < v > cache < v > getrequestcache ( string name ) { map < string , cache < ? > > requestcachemap = requestcachemapholder . get ( ) ; cache < v > requestcache = ( cache < v > ) requestcachemap . get ( name ) ; if ( requestcache == null ) { requestcache = new mapcacheimpl < v > ( ) ; requestcachemap . put ( name , requestcache ) ; } return requestcache ; }	Generate a cache bound to the request.
public static string getaltfield ( string field , string streamid ) { if ( streamid == null ) { return field ; } return field + str_ + streamid ; }	Get the name of an alternative field for an alternative stream.
public static string shardpath ( string id ) { string hash = insecurehash ( id ) ; return hash . substring ( num_ , num_ ) + str_ + hash . substring ( num_ , num_ ) + str_ + hash . substring ( num_ , num_ ) + str_ + id ; }	For instance the SparsePrincipal uses it.
public static session adapttosession ( object source ) { if ( source instanceof sessionadaptable ) { return ( ( sessionadaptable ) source ) . getsession ( ) ; } else {	Adapt an object to a session.
private static object safemethod ( object target , string methodname , object [ ] args , @ suppresswarnings ( str_ ) class [ ] argstypes ) { if ( target != null ) { try { method m = target . getclass ( ) . getmethod ( methodname , argstypes ) ; if ( ! m . isaccessible ( ) ) { m . setaccessible ( bool_ ) ; } return m . invoke ( target , args ) ; } catch ( throwable e ) { logger . info ( str_ + methodname + str_ + target , e ) ; } } return null ; }	Make the method on the target object accessible and then invoke it.
public static void deletetree ( contentmanager contentmanager , string path ) throws accessdeniedexception , storageclientexception { content content = contentmanager . get ( path ) ; if ( content != null ) { for ( string childpath : content . listchildpaths ( ) ) { deletetree ( contentmanager , childpath ) ; } } contentmanager . delete ( path ) ; }	Delete an entire tree starting from the deepest part of the tree andworking back up.
@ override public void updateone ( e object , string ... properties ) { if ( object . getid ( ) == null ) { throw new runtimeexception ( str_ ) ; } if ( properties == null || properties . length == num_ ) { entitymanager . merge ( object ) ; return ; }	Only update specified properties of the Object.
public void setpinginterval ( long newpinginterval ) { if ( pinginterval == newpinginterval ) return ;	Sets the ping interval.
private synchronized void schedulepingservertask ( ) { enableexecutorservice ( ) ; stoppingservertask ( ) ; if ( pinginterval > num_ ) { periodicpingtask = periodicpingexecutorservice . schedule ( new runnable ( ) { @ override public void run ( ) { ping ping = new ping ( ) ; packetfilter responsefilter = new packetidfilter ( ping . getid ( ) ) ; connection connection = weakrefconnection . get ( ) ; final packetcollector response = pingfailedlisteners . isempty ( ) ? null : connection . createpacketcollector ( responsefilter ) ; connection . sendpacket ( ping ) ; if ( response != null ) {	Cancels any existing periodic ping task if there is one and schedules anew ping task if pingInterval is greater then zero.This is designed so only one executor is used for scheduling all pings onall connections.
public execs_cliparser addalloptions ( applicationoption < ? > [ ] options ) { if ( options != null ) { for ( applicationoption < ? > option : options ) { this . addoption ( option ) ; } } return this ; }	Adds all given option ignoring null elements.
public boolean hasoption ( option option ) { if ( option == null ) { return bool_ ; } if ( this . usedoptions . contains ( option . getopt ( ) ) ) { return bool_ ; } if ( this . usedoptions . contains ( option . getlongopt ( ) ) ) { return bool_ ; } return bool_ ; }	Tests if an option is already added to the parser.
public parseexception parse ( string [ ] args ) { parseexception ret = null ; commandlineparser parser = new defaultparser ( ) ; try { this . cmdline = parser . parse ( this . options , args ) ; } catch ( parseexception pe ) { ret = pe ; } return ret ; }	Parses command line arguments and fills set options.
public void usage ( string appname ) { helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( appname , null , this . options , null , bool_ ) ; }	Prints a usage screen based on set options.
static int doparse ( string [ ] args , execs_cliparser cli , string appname ) { exception err = cli . parse ( args ) ; if ( err != null ) { system . err . println ( appname + str_ + err . getmessage ( ) ) ; return - num_ ; } return num_ ; }	Parses command line arguments for a given CLI parser.
private void initconnection ( ) throws xmppexception { boolean isfirstinitialization = packetreader == null || packetwriter == null ; compressionhandler = null ; serverackdcompression = bool_ ;	Initializes the connection by creating a packet reader and writer andopening a XMPP stream to the server.
void starttlsreceived ( boolean required ) { if ( required && config . getsecuritymode ( ) == connectionconfiguration . securitymode . disabled ) { notifyconnectionerror ( new illegalstateexception ( str_ ) ) ; return ; } if ( config . getsecuritymode ( ) == connectionconfiguration . securitymode . disabled ) {	Notification message saying that the server supports TLS so confirm theserver that we want to secure the connection.
private xmppinputoutputstream maybegetcompressionhandler ( ) { if ( compressionmethods != null ) { for ( xmppinputoutputstream handler : compressionhandlers ) { if ( ! handler . issupported ( ) ) continue ; string method = handler . getcompressionmethod ( ) ; if ( compressionmethods . contains ( method ) ) return handler ; } } return null ; }	Returns the compression handler that can be used for one compressionmethods offered by the server.
private void requeststreamcompression ( string method ) { try { writer . write ( str_ ) ; writer . write ( str_ + method + str_ ) ; writer . flush ( ) ; } catch ( ioexception e ) { notifyconnectionerror ( e ) ; } }	Request the server that we want to start using stream compression.
void startstreamcompression ( ) throws exception { serverackdcompression = bool_ ;	Start using stream compression since the server has acknowledged streamcompression.
synchronized void notifyconnectionerror ( exception e ) {	Sends out a notification that there was an error with the connection andcloses the connection. Also prints the stack trace of the given exception.
protected void notifyreconnection ( ) {	Sends a notification indicating that the connection was reconnectedsuccessfully.
public static void registersaslmechanism ( string name , class < ? extends saslmechanism > mclass ) { implementedmechanisms . put ( name , mclass ) ; }	Registers a new SASL mechanism.
public static list < class < ? extends saslmechanism > > getregistersaslmechanisms ( ) { list < class < ? extends saslmechanism > > answer = new arraylist < class < ? extends saslmechanism > > ( ) ; for ( string mechanismspreference : mechanismspreferences ) { answer . add ( implementedmechanisms . get ( mechanismspreference ) ) ; } return answer ; }	Returns the registerd SASLMechanism classes sorted by the level ofpreference.
@ override public hashmap < integer , list < identification > > getoutputpluginbehaviour ( list < identification > identifications ) { if ( outputpluginbehaviour == null ) return new hashmap < > ( ) ; return outputpluginbehaviour . apply ( identifications ) ; }	generates the data to control the Event.
static void info ( string message , throwable t ) { log ( system . out , str_ , message , t ) ; }	emit an informational message to standard out.
static void error ( string message , throwable t ) { log ( system . err , str_ , message , t ) ; }	emit an error message to standard err.
private static void log ( printstream out , string prefix , string message , throwable t ) { final stringbuilder lineprefixbuilder = new stringbuilder ( ) ; synchronized ( fmt ) { lineprefixbuilder . append ( fmt . format ( new date ( ) ) ) ; } lineprefixbuilder . append ( prefix ) ; lineprefixbuilder . append ( str_ ) ; lineprefixbuilder . append ( thread . currentthread ( ) . getname ( ) ) ; lineprefixbuilder . append ( str_ ) ; final string lineprefix = lineprefixbuilder . tostring ( ) ; out . print ( lineprefix ) ; out . println ( message ) ; if ( t != null ) { t . printstacktrace ( new printstream ( out ) { @ override public void println ( string x ) { synchronized ( this ) { print ( lineprefix ) ; super . println ( x ) ; flush ( ) ; } } } ) ; } }	the throwable if not-null is also prefixed line by line with the prefix.
public static optional < startevent > createstartevent ( identification source ) { try { startevent startrequest = new startevent ( source ) ; return optional . of ( startrequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new StartEvent.Assumes the Output is using the java-sound output.
public static optional < startevent > createstartevent ( identification source , boolean isusingjava ) { try { startevent startevent ; if ( isusingjava ) { startevent = new startevent ( source ) ; } else { startevent = new startevent ( source , is_using_non_java_output ) ; } return optional . of ( startevent ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new StartEvent.
private void notifylisteners ( string str ) { writerlistener [ ] writerlisteners = null ; synchronized ( listeners ) { writerlisteners = new writerlistener [ listeners . size ( ) ] ; listeners . toarray ( writerlisteners ) ; } for ( int i = num_ ; i < writerlisteners . length ; i ++ ) { writerlisteners [ i ] . write ( str ) ; } }	Notify that a new string has been written.
@ override public boolean providesresource ( resourcemodel resource ) { return resources . stream ( ) . map ( resourcemodel :: getresourceid ) . anymatch ( resources -> resources . equals ( resource . getresourceid ( ) ) ) ; }	checks whether it can provide the resource.
@ override public boolean containsresourcesfromsource ( string sourceid ) { return resources . stream ( ) . map ( resourcemodel :: getresourceid ) . anymatch ( source -> source . equals ( sourceid ) ) ; }	checks whether there are any resources registered from the source.
@ override public boolean providesresource ( list < string > resourcesids ) { return resources . stream ( ) . map ( resourcemodel :: getresourceid ) . anymatch ( resourcesids :: contains ) ; }	checks whether the ResourceContainer can provide at least ONE resource.
@ override public list < resourcemodel > provideresource ( string [ ] resourceids ) { return resources . stream ( ) . filter ( resource -> arrays . stream ( resourceids ) . anymatch ( resourceid -> resourceid . equals ( resource . getresourceid ( ) ) ) ) . collect ( collectors . tolist ( ) ) ; }	returns all EXISTING resources for the ID.If there are no resources for the ID the ID will get skipped.
protected map < string , object > getcached ( string keyspace , string columnfamily , string key ) throws storageclientexception { map < string , object > m = null ; string cachekey = getcachekey ( keyspace , columnfamily , key ) ; cacheholder cacheholder = getfromcacheinternal ( cachekey ) ; if ( cacheholder != null ) { m = cacheholder . get ( ) ; if ( m != null ) { logger . debug ( str_ , new object [ ] { cachekey , cacheholder , m } ) ; } } if ( m == null ) { m = client . get ( keyspace , columnfamily , key ) ; if ( m != null ) { logger . debug ( str_ , cachekey , m ) ; } puttocacheinternal ( cachekey , new cacheholder ( m ) , bool_ ) ; } return m ; }	Try to retrieve an object from the cache.
private string getcachekey ( string keyspace , string columnfamily , string key ) throws storageclientexception { if ( client instanceof rowhasher ) { return ( ( rowhasher ) client ) . rowhash ( keyspace , columnfamily , key ) ; } return keyspace + str_ + columnfamily + str_ + key ; }	Combine the parameters into a key suitable for storage and lookup in thecache.
protected void removecached ( string keyspace , string columnfamily , string key ) throws storageclientexception { if ( sharedcache != null ) {	Remove this object from the cache.
protected void putcached ( string keyspace , string columnfamily , string key , map < string , object > encodedproperties , boolean probablynew ) throws storageclientexception { string cachekey = null ; if ( sharedcache != null ) { cachekey = getcachekey ( keyspace , columnfamily , key ) ; } if ( sharedcache != null && ! probablynew ) { cacheholder ch = getfromcacheinternal ( cachekey ) ; if ( ch != null && ch . islocked ( this . managerid ) ) { logger . debug ( str_ , ch ) ; return ;	Put an object in the cache.
public map < uri , string > getcflocations ( ) { if ( this . needsrerun == bool_ ) { this . locationmap . clear ( ) ; string pathsep = system . getproperty ( str_ ) ; string classpath = system . getproperty ( str_ ) ; stringtokenizer st = new stringtokenizer ( classpath , pathsep ) ; file file = null ; while ( st . hasmoretokens ( ) ) { string path = st . nexttoken ( ) ; file = new file ( path ) ; this . include ( file ) ; } } this . needsrerun = bool_ ; return this . locationmap ; }	Runs the locator and collects all locations using the filters if set.The method can be called multiple times and will only result in a new map if any of the filters have been changed.If no filter has been changed, the current map will be returned.
protected final void include ( string name , file file ) { if ( ! file . exists ( ) ) { return ; } if ( ! file . isdirectory ( ) ) { if ( this . jarfilter . size ( ) > num_ ) { boolean ok = bool_ ; for ( string s : this . jarfilter ) { if ( file . getname ( ) . startswith ( s ) ) { ok = bool_ ; } } if ( ok == bool_ ) { return ; } } this . includejar ( file ) ; return ; } if ( name == null ) { name = str_ ; } else { name += str_ ; } file [ ] dirs = file . listfiles ( cf_utils . directories_only ) ; for ( int i = num_ ; i < dirs . length ; i ++ ) { try { this . locationmap . put ( new uri ( str_ + dirs [ i ] . getcanonicalpath ( ) ) , name + dirs [ i ] . getname ( ) ) ; } catch ( ioexception ignore ) { return ; } catch ( urisyntaxexception ignore ) { return ; } this . include ( name + dirs [ i ] . getname ( ) , dirs [ i ] ) ; } }	Include a name and file.
private void includejar ( file file ) { if ( file . isdirectory ( ) ) { return ; } url jarurl = null ; jarfile jar = null ; try { jarurl = new url ( str_ + new url ( str_ + file . getcanonicalpath ( ) ) . toexternalform ( ) + str_ ) ; jarurlconnection conn = ( jarurlconnection ) jarurl . openconnection ( ) ; jar = conn . getjarfile ( ) ; } catch ( malformedurlexception ignore ) { return ; } catch ( ioexception ignore ) { return ; } if ( jar == null ) { return ; } try { this . locationmap . put ( jarurl . touri ( ) , str_ ) ; } catch ( urisyntaxexception ignore ) { } for ( enumeration < jarentry > e = jar . entries ( ) ; e . hasmoreelements ( ) ; ) { jarentry entry = e . nextelement ( ) ; if ( this . pkgfilter != null && entry . getname ( ) . startswith ( this . pkgfilter ) ) { continue ; } if ( entry . isdirectory ( ) ) { if ( entry . getname ( ) . touppercase ( locale . english ) . equals ( str_ ) ) { continue ; } try { this . locationmap . put ( new uri ( jarurl . toexternalform ( ) + entry . getname ( ) ) , cf_utils . getpkgname ( entry ) ) ; } catch ( urisyntaxexception ignore ) { continue ; } } } }	Include from a jar file.
public static void addsaslmech ( string mech ) { initialize ( ) ; if ( ! defaultmechs . contains ( mech ) ) { defaultmechs . add ( mech ) ; } }	Add a SASL mechanism to the list to be used.
public static void addsaslmechs ( collection < string > mechs ) { initialize ( ) ; for ( string mech : mechs ) { addsaslmech ( mech ) ; } }	Add a Collection of SASL mechanisms to the list to be used.
private void createdebug ( ) {	Creates the listeners that will print in the console when new activity isdetected.
protected void activate ( map < string , object > properties ) throws exception { configproperties = properties ; string [ ] safepostprocessornames = ( string [ ] ) configproperties . get ( safe_postprocessors ) ; if ( safepostprocessornames == null ) { safeopenprocessors . add ( str_ ) ; safeopenprocessors . add ( str_ ) ; } else { for ( string pp : safepostprocessornames ) { safeopenprocessors . add ( pp ) ; } }	Create resources used by this component.
private void registerstandardevents ( ) { commonevents . descriptors . stoplistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . generalleavinglistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . generallistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . leavinglistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . presencelistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . strictleavinglistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . presence . strictlistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . response . fullresponselistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . response . majorresponselistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . response . minorresponselistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . type . notificationlistener ( this ) . ifpresent ( this :: registereventlistener ) ; commonevents . type . responselistener ( this ) . ifpresent ( this :: registereventlistener ) ; }	registers the standard-events.
public void registereventlistener ( eventlistener eventlistener ) { registereventid ( eventlistener . getdescription ( ) , eventlistener . getdescriptorid ( ) , eventlistener . getdescriptor ( ) ) ; }	Registers or adds an event to the local_events.properties file with the informations found in the EventListener.
public void registereventid ( string description , string key , string value ) { bufferedwriter bufferedwriter ; fileoutputstream out = null ; try { out = new fileoutputstream ( eventpropertiespath , bool_ ) ; bufferedwriter = new bufferedwriter ( new outputstreamwriter ( out ) ) ; dowithlock ( out . getchannel ( ) , lock -> { unlockedreloadfile ( ) ; if ( geteventid ( key ) != null ) { return ; } try { bufferedwriter . write ( str_ + key + str_ + description + str_ + key + str_ + value ) ; bufferedwriter . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } ) ; } catch ( filenotfoundexception e ) { error ( str_ , e ) ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( ioexception e ) { error ( str_ , e ) ; } } }	Registers or adds an event to the local_events.properties file.
private void dowithlock ( filechannel channel , consumer < filelock > consumer ) { filelock lock = null ; try { while ( lock == null ) { try { lock = channel . trylock ( ) ; } catch ( overlappingfilelockexception e ) { thread . sleep ( num_ ) ; } } consumer . accept ( lock ) ; } catch ( ioexception | interruptedexception e ) { error ( str_ , e ) ; } finally { try { if ( lock != null ) { lock . release ( ) ; } } catch ( ioexception e ) { error ( str_ , e ) ; } } }	executes with a lock.
@ override public boolean canrun ( eventmodel event ) {	Checks if the outputExtension can execute with the current event.
public static dsesession newdsesession ( dsecluster cluster , string keyspace ) { return cluster . connect ( stringutils . isblank ( keyspace ) ? null : keyspace ) ; }	Create a new session for a DSE cluster, initializes it and sets the keyspaceto the provided one.
public static optional < playererror > createmusicplayererror ( identification source , string error ) { if ( error == null || error . isempty ( ) ) return optional . empty ( ) ; try { playererror playererror = new playererror ( source ) ; playererror . addresource ( new musicerrorresource ( source , error ) ) ; return optional . of ( playererror ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new MusicPlayerError.
public void startplaying ( trackinfo trackinfo ) { optional < identification > ownidentification = identificationmanagerm . getinstance ( ) . getidentification ( this ) ; optional < identification > playeridentification = identificationmanagerm . getinstance ( ) . getidentification ( player ) ; if ( ! ownidentification . ispresent ( ) || ! playeridentification . ispresent ( ) ) { error ( str_ ) ; return ; } startmusicrequest . createstartmusicrequest ( ownidentification . get ( ) , playeridentification . get ( ) , trackinfo , player . isusingjava ) . ifpresent ( event -> fire ( event , num_ ) ) ; }	starts the playing command.
public void stopplaying ( ) { optional < identification > ownidentification = identificationmanagerm . getinstance ( ) . getidentification ( this ) ; optional < identification > playeridentification = identificationmanagerm . getinstance ( ) . getidentification ( player ) ; if ( ! ownidentification . ispresent ( ) || ! playeridentification . ispresent ( ) ) { error ( str_ ) ; return ; } stopmusic . createstopmusic ( ownidentification . get ( ) , playeridentification . get ( ) ) . ifpresent ( event -> fire ( event , num_ ) ) ; }	stops the playing of the music.
public void command ( string command , playlist playlist , progress progress , trackinfo trackinfo , volume volume ) { optional < identification > ownidentification = identificationmanagerm . getinstance ( ) . getidentification ( this ) ; optional < identification > playeridentification = identificationmanagerm . getinstance ( ) . getidentification ( player ) ; if ( ! ownidentification . ispresent ( ) || ! playeridentification . ispresent ( ) ) { error ( str_ ) ; return ; } optional < playercommand > playercommand = playercommand . createplayercommand ( ownidentification . get ( ) , playeridentification . get ( ) , command , player . getcapabilities ( ) , getcontext ( ) ) ; if ( playlist != null ) { playercommand . get ( ) . addresource ( new playlistresource ( ownidentification . get ( ) , playlist ) ) ; } if ( progress != null ) { playercommand . get ( ) . addresource ( new progressresource ( ownidentification . get ( ) , progress ) ) ; } if ( trackinfo != null ) { playercommand . get ( ) . addresource ( new trackinforesource ( ownidentification . get ( ) , trackinfo ) ) ; } if ( volume != null ) { playercommand . get ( ) . addresource ( new volumeresource ( ownidentification . get ( ) , volume ) ) ; } fire ( playercommand . get ( ) , num_ ) ; }	commands the player to fulfill the command.
public static broadcasterplaylist createplaylistrequest ( identification provider , string playlistname ) { hashmap < string , object > hashmap = new hashmap < > ( ) ; hashmap . put ( resource_id , playlistname ) ; return new broadcasterplaylist ( provider , hashmap ) ; }	creates the Playlist-Request.
public static broadcasterplaylist createplaylistanswer ( identification provider , playlist playlist ) { return new broadcasterplaylist ( provider , playlist . export ( ) ) ; }	creates the Playlist-Answer.
public urlbuilder append ( boolean encode , string ... postfix ) { for ( string part : postfix ) { if ( stringutils . isnotblank ( part ) ) { if ( url . charat ( url . length ( ) - num_ ) != str_ && ! part . startswith ( str_ ) ) { url . append ( str_ ) ; } if ( encode ) { try { url . append ( urlencoder . encode ( part , str_ ) ) ; } catch ( unsupportedencodingexception e ) { throw new illegalstateexception ( e ) ; } } else { url . append ( part ) ; } } } return this ; }	Appends one or more postfixes and separates them by slashes.
public urlbuilder queryparam ( string name , boolean value ) { if ( value != null ) { return queryparam ( name , value . tostring ( ) ) ; } else { return null ; } }	Create a query parameter with a boolean value.
public urlbuilder queryparam ( string name , number value ) { if ( value != null ) { return queryparam ( name , value . tostring ( ) ) ; } else { return null ; } }	Create a query parameter with a number value.
public urlbuilder queryparam ( string name , string value ) { return queryparam ( name , value , bool_ ) ; }	Create a query parameter with a String value.
public urlbuilder queryparam ( string name , string value , boolean encode ) { if ( stringutils . isnotempty ( value ) ) { if ( encode ) { try { value = urlencoder . encode ( value , str_ ) ; } catch ( unsupportedencodingexception e ) { throw new illegalstateexception ( e ) ; } } params . add ( new entryimpl ( name , value ) ) ; } return this ; }	Create a query parameter with a String value.
public static optional < playlist > getplaylist ( eventmodel eventmodel ) { if ( eventmodel . getlistresourcecontainer ( ) . containsresourcesfromsource ( id ) ) { return eventmodel . getlistresourcecontainer ( ) . provideresource ( id ) . stream ( ) . findany ( ) . flatmap ( playlist :: importresource ) ; } else { return optional . empty ( ) ; } }	gets the first playlist if found in the EventModel.
private void launchbuttonactionperformed ( java . awt . event . actionevent evt ) {	This is the launch button action method.
private void isstartupfinished ( ) { boolean started = bool_ ; try { while ( ! started ) { if ( exists ( localhosturl ) ) started = bool_ ; thread . sleep ( num_ * num_ ) ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } if ( started ) { statuslabel . settext ( str_ ) ; statuslabel . setforeground ( color . green ) ; launchbutton . setenabled ( bool_ ) ; browserbutton . setenabled ( bool_ ) ; } }	Pings the Apache Sling server URL every 5 seconds to see if it has finished booting.Once it receives an OK status, it enables the button to launch the browser anddisables the launch Nakamura button.
public static boolean exists ( string urlname ) { try { httpurlconnection . setfollowredirects ( bool_ ) ;	Pings the Apache Sling server URL, looking for an OK status.
private void browserbuttonactionperformed ( java . awt . event . actionevent evt ) { try { desktop . getdesktop ( ) . browse ( new url ( localhosturl ) . touri ( ) ) ; } catch ( ioexception e ) { system . err . println ( str_ + e . getmessage ( ) ) ; } catch ( urisyntaxexception e ) { system . err . println ( str_ + e . getmessage ( ) ) ; } }	Performs the action when the browser button is pressed, which is launch a web browserand browse to the server URL.
protected imageicon createimageicon ( string path , string description ) { java . net . url imgurl = getclass ( ) . getresource ( path ) ; if ( imgurl != null ) { return new imageicon ( imgurl , description ) ; } else { system . err . println ( str_ + path ) ; return null ; } }	Returns an ImageIcon, or null if the path was invalid.
public static void main ( string args [ ] ) { savedargs = args ; java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { new launchnakamura ( ) . setvisible ( bool_ ) ; } } ) ; }	The Main method which executes the program.
public intarray with ( int ... values ) { if ( values . length != this . length ) throw new illegalargumentexception ( str_ ) ; value = values . clone ( ) ; return this ; }	Replace contents with given values.
public hashmap < string , object > export ( ) { hashmap < string , object > data = new hashmap < > ( ) ; data . put ( level_descriptor , level . name ( ) ) ; data . put ( present_descriptor , present ) ; data . put ( strict_descriptor , strict ) ; data . put ( known_descriptor , known ) ; return data ; }	exports the Presence to a HashMap.
public jsonresult get ( int index ) { if ( value instanceof jsonarray ) { jsonarray array = ( jsonarray ) value ; object result = array . get ( index ) ; return new jsonresult ( result ) ; } else if ( value instanceof jsonobject ) { return get ( string . valueof ( index ) ) ; } return new jsonresult ( null ) ; }	Advance current JSON value to specified element in JSON array.Set current JSON value to null otherwise.
public jsonresult get ( string key ) { if ( value instanceof jsonobject ) { jsonobject obj = ( jsonobject ) value ; object result = obj . get ( key ) ; return new jsonresult ( result ) ; } else if ( value instanceof jsonarray ) { try { int index = integer . parseint ( key ) ; return get ( index ) ; } catch ( numberformatexception e ) { throw createexception ( str_ + key + str_ ) ; } } return new jsonresult ( null ) ; }	Advance current JSON value to specified value of current JSON object.Set current JSON value to null otherwise.
public integer getint ( integer defaultvalue ) { if ( value instanceof number ) { return ( ( number ) value ) . intvalue ( ) ; } if ( value instanceof string ) { string s = ( string ) value ; return integer . parseint ( s ) ; } if ( value == null ) { return defaultvalue ; } throw createexception ( str_ ) ; }	Return an integer for current JSON value, parsing string values as required.
public double getdouble ( double defaultvalue ) { if ( value instanceof number ) { return ( ( number ) value ) . doublevalue ( ) ; } if ( value instanceof string ) { string s = ( string ) value ; return double . parsedouble ( s ) ; } if ( value == null ) { return defaultvalue ; } throw createexception ( str_ ) ; }	Return a double number for current JSON value, parsing string values as required.
public string getstring ( string defaultvalue ) { if ( value instanceof string || value instanceof number ) { return value . tostring ( ) ; } if ( value == null ) { return null ; } if ( value instanceof jsonarray ) { return ( ( jsonarray ) value ) . tojsonstring ( ) ; } if ( value instanceof jsonobject ) { return ( ( jsonobject ) value ) . tojsonstring ( ) ; } if ( value == null ) { return defaultvalue ; } throw createexception ( str_ ) ; }	Return string value for current JSON value.
public static optional < commandresource > createcommandresource ( identification provider , string command , capabilities capabilities , context context ) { commandresource commandresource = new commandresource ( provider , command , capabilities ) ; if ( ! verifycommand ( command ) ) { context . getlogger ( ) . error ( str_ ) ; return optional . empty ( ) ; } if ( ! verifycapabilities ( command , capabilities ) ) { context . getlogger ( ) . error ( str_ ) ; return optional . empty ( ) ; } return optional . of ( commandresource ) ; }	creates a new Resource.
public static boolean verifycommand ( string command ) { return command . equals ( play ) || command . equals ( pause ) || command . equals ( stop ) || command . equals ( select_track ) || command . equals ( next ) || command . equals ( previous ) || command . equals ( change_playback ) || command . equals ( change_volume ) ; }	verifies that an command is not malformed.
public static boolean verifycapabilities ( string command , capabilities capabilities ) { switch ( command ) { case play : return capabilities . hasplaypausecontrol ( ) ; case pause : return capabilities . hasplaypausecontrol ( ) ; case select_track : return capabilities . isabletoselecttrack ( ) ; case next : return capabilities . hasnextprevious ( ) ; case previous : return capabilities . hasnextprevious ( ) ; case jump : return capabilities . isabletojump ( ) ; case change_playback : return capabilities . isplaybackchangeable ( ) ; case change_volume : return capabilities . canchangevolume ( ) ; case stop : return bool_ ; } return bool_ ; }	verifies that the player is capable of handling the command.
public static boolean verify ( string command , capabilities capabilities ) { return verifycommand ( command ) && verifycapabilities ( command , capabilities ) ; }	verifies tha the command is legal and able to be executed.
public void executebatchasync ( futurecallback < resultset > callback , statement ... statements ) throws exceedmaxasyncjobsexception { if ( ! asyncsemaphore . tryacquire ( ) ) { if ( callback == null ) { throw new exceedmaxasyncjobsexception ( maxsyncjobs ) ; } else { callback . onfailure ( new exceedmaxasyncjobsexception ( maxsyncjobs ) ) ; } } else { try { resultsetfuture rsf = cqlutils . executebatchasync ( getsession ( ) , statements ) ; if ( callback != null ) { futures . addcallback ( rsf , wrapcallbackresultset ( callback ) , asyncexecutor ) ; } } catch ( exception e ) { asyncsemaphore . release ( ) ; logger . error ( e . getmessage ( ) , e ) ; } } }	Async-execute a batch statement. The default session (obtained via {.
public set < class < ? > > getsubclasses ( class < ? > clazz ) { set < class < ? > > ret = new hashset < class < ? > > ( ) ; set < class < ? > > w = null ; if ( clazz != null ) { this . clear ( ) ; map < uri , string > locations = this . locator . getcflocations ( ) ; for ( entry < uri , string > entry : locations . entryset ( ) ) { try { w = search ( clazz , entry . getkey ( ) , locations . get ( entry . getkey ( ) ) ) ; if ( w != null && ( w . size ( ) > num_ ) ) { ret . addall ( w ) ; } } catch ( malformedurlexception ex ) { } } } return ret ; }	Returns all subclasses found for the given class.
public set < class < ? > > getsubclasses ( string fqcn ) { if ( fqcn == null ) { return new hashset < class < ? > > ( ) ; } else if ( stringutils . startswith ( fqcn , str_ ) || stringutils . endswith ( fqcn , str_ ) ) { return new hashset < class < ? > > ( ) ; } class < ? > clazz = null ; try { clazz = class . forname ( fqcn ) ; } catch ( classnotfoundexception ex ) { this . clear ( ) ; this . errors . add ( ex ) ; return new hashset < class < ? > > ( ) ; } return getsubclasses ( clazz ) ; }	Returns all subclasses found for the given fully qualified class name.
private final set < class < ? > > search ( class < ? > clazz , uri location , string packagename ) throws malformedurlexception { if ( clazz == null || location == null ) { return new hashset < class < ? > > ( ) ; } file directory = new file ( location . tourl ( ) . getfile ( ) ) ; if ( directory . exists ( ) ) { return this . searchdirectory ( clazz , directory , location , packagename ) . keyset ( ) ; } else { return this . searchjar ( clazz , location ) . keyset ( ) ; } }	Returns all known subclasses for a given class, location and package name.
protected final map < class < ? > , uri > searchdirectory ( class < ? > clazz , file directory , uri location , string packagename ) { map < class < ? > , uri > ret = new hashmap < > ( ) ; string [ ] files = directory . list ( ) ; for ( int i = num_ ; i < files . length ; i ++ ) { if ( files [ i ] . endswith ( str_ ) ) { string classname = files [ i ] . substring ( num_ , files [ i ] . length ( ) - num_ ) ; try { class < ? > c = class . forname ( packagename + str_ + classname ) ; if ( clazz . isassignablefrom ( c ) && ! clazz . getname ( ) . equals ( packagename + str_ + classname ) ) { ret . put ( c , location ) ; } } catch ( exception ex ) { errors . add ( ex ) ; } } } return ret ; }	Returns all known subclasses found in a given directory.
public list < resource > tolist ( ) { list < resource > resourcelist = new arraylist < > ( ) ; resourcelist . add ( this ) ; return resourcelist ; }	creates a list with this Element in it.
public int size ( ) { int result = num_ ;	Returns the accumulated size of all the bottom level maps.
protected void processpacket ( packet packet ) { if ( packet == null ) { return ; } if ( packetfilter == null || packetfilter . accept ( packet ) ) { while ( ! resultqueue . offer ( packet ) ) {	Processes a packet to see if it meets the criteria for this packetcollector.
public static optional < volume > getvolume ( eventmodel eventmodel ) { if ( eventmodel . getlistresourcecontainer ( ) . containsresourcesfromsource ( id ) ) { return eventmodel . getlistresourcecontainer ( ) . provideresource ( id ) . stream ( ) . map ( resourcemodel :: getresource ) . filter ( ob -> ob instanceof integer ) . map ( ob -> ( integer ) ob ) . findany ( ) . flatmap ( volume :: createvolume ) ; } else { return optional . empty ( ) ; } }	gets the first Volume if found in the EventModel.
public static iq errorrsm ( iq iq , logger logger ) { string rsmmessage = str_ ; logger . error ( rsmmessage + str_ + iq ) ; return xmpputils . createerrorresponse ( iq , rsmmessage , condition . item_not_found , type . cancel ) ; }	Logs the RSM page not found error and returns an IQ error response.
public static iq createerrorresponse ( final iq request , final string message , condition condition , type type ) { final iq result = request . createcopy ( ) ; result . setid ( request . getid ( ) ) ; result . setfrom ( request . getto ( ) ) ; result . setto ( request . getfrom ( ) ) ; packeterror e = new packeterror ( condition , type ) ; if ( message != null ) { e . settext ( message ) ; } result . seterror ( e ) ; return result ; }	Creates an error response for a given IQ request.
public static optional < boolean > istarget ( eventmodel eventmodel , identifiable identifiable ) { if ( eventmodel . getlistresourcecontainer ( ) . providesresource ( collections . singletonlist ( selectorresource . resource_id ) ) ) { return optional . of ( eventmodel . getlistresourcecontainer ( ) . provideresource ( selectorresource . resource_id ) . stream ( ) . map ( resourcemodel :: getresource ) . filter ( resource -> resource instanceof identification ) . map ( object -> ( identification ) object ) . anymatch ( identifiable :: isowner ) ) ; } else { return optional . empty ( ) ; } }	returns true if the identifiable is the target of the EventModel.
public void setloginenabled ( long from , long to , boolean day , timezone timezone ) { string enabledsetting = enabledperiod . getenablevalue ( from , to , day , timezone ) ; if ( enabledsetting == null ) { removeproperty ( login_enabled_period_field ) ; } else { setproperty ( login_enabled_period_field , enabledsetting ) ; } }	Sets the login enabled time.
public static < e > set < e > decorate ( set < e > set ) { return new synchronizedset < e > ( set ) ; }	Factory method to create a synchronized set.
public void setname ( string name ) {	Sets the name associated with this entry.
void updatestate ( string name , subscription type , ask status ) { this . name = name ; this . subscription = type ; this . ask = status ; }	Updates the state of the entry with the new values.
public collection < rostergroup > getgroups ( ) { list < rostergroup > results = new arraylist < rostergroup > ( ) ;	Returns an unmodifiable collection of the roster groups that this entrybelongs to.
public static void appendrsmelement ( element queryelement , rsm rsm ) { element setelement = queryelement . addelement ( str_ , rsm . namespace ) ; if ( rsm . getfirst ( ) != null ) { element firstelement = setelement . addelement ( str_ ) ; firstelement . addattribute ( str_ , rsm . getindex ( ) . tostring ( ) ) ; firstelement . settext ( rsm . getfirst ( ) ) ; } if ( rsm . getlast ( ) != null ) { element lastelement = setelement . addelement ( str_ ) ; lastelement . settext ( rsm . getlast ( ) ) ; } setelement . addelement ( str_ ) . settext ( string . valueof ( rsm . getcount ( ) ) ) ; }	Appends RSM info to query response.
public static rsm parsersm ( element queryelement ) { rsm rsm = new rsm ( ) ; element setelement = queryelement . element ( str_ ) ; if ( setelement == null ) { return rsm ; } element after = setelement . element ( str_ ) ; if ( after != null ) { rsm . setafter ( after . gettext ( ) ) ; } element before = setelement . element ( str_ ) ; if ( before != null ) { string beforetext = before . gettext ( ) ; rsm . setbefore ( beforetext == null ? str_ : beforetext ) ; } element index = setelement . element ( str_ ) ; if ( index != null ) { rsm . setindex ( integer . parseint ( index . gettext ( ) ) ) ; } element max = setelement . element ( str_ ) ; if ( max != null ) { rsm . setmax ( integer . parseint ( max . gettext ( ) ) ) ; } return rsm ; }	Parses an RSM from a query XML element.
public static optional < leavingevent > createleavingevent ( identification source , boolean strict , list < string > descriptors ) { try { if ( strict ) { descriptors . add ( strict_descriptor ) ; } else { descriptors . add ( general_descriptor ) ; } descriptors . add ( id ) ; descriptors . add ( commonevents . descriptors . not_interrupt ) ; leavingevent stoprequest = new leavingevent ( source , descriptors ) ; return optional . of ( stoprequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new LeavingEvent.
public void reload ( ) { if ( ! connection . isauthenticated ( ) ) { throw new illegalstateexception ( str_ ) ; } if ( connection . isanonymous ( ) ) { throw new illegalstateexception ( str_ ) ; } roster packet = new roster ( ) ; if ( rosterstore != null && connection . isrosterversioningsupported ( ) ) { packet . getelement ( ) . element ( str_ ) . addattribute ( str_ , rosterstore . getrosterversion ( ) ) ; packetfilter filter = new packetidfilter ( packet . getid ( ) ) ; connection . addpacketlistener ( new rosterresultlistener ( ) , filter ) ; } connection . sendpacket ( packet ) ; }	Reloads the entire roster from the server.
public void createentry ( string user , string name , string [ ] groups ) throws xmppexception { if ( ! connection . isauthenticated ( ) ) { throw new illegalstateexception ( str_ ) ; } if ( connection . isanonymous ( ) ) { throw new illegalstateexception ( str_ ) ; }	Creates a new roster entry and presence subscription.
public collection < rosterentry > getentries ( ) { set < rosterentry > allentries = new hashset < rosterentry > ( ) ;	Returns an unmodifiable collection of all entries in the roster,including entries that don't belong to any groups.
public presence getpresenceresource ( string userwithresource ) { string key = getpresencemapkey ( userwithresource ) ; string resource = stringutils . parseresource ( userwithresource ) ; map < string , presence > userpresences = presencemap . get ( key ) ; if ( userpresences == null ) { presence presence = new presence ( presence . type . unavailable ) ; presence . setfrom ( userwithresource ) ; return presence ; } else { presence presence = userpresences . get ( resource ) ; if ( presence == null ) { presence = new presence ( presence . type . unavailable ) ; presence . setfrom ( userwithresource ) ; return presence ; } else { return presence ; } } }	Returns the presence info for a particular user's resource, orunavailable presence if the user is offline or if no presence informationis available, such as when you are not subscribed to the user's presenceupdates.
private void setofflinepresences ( ) { presence packetunavailable ; for ( string user : presencemap . keyset ( ) ) { map < string , presence > resources = presencemap . get ( user ) ; if ( resources != null ) { for ( string resource : resources . keyset ( ) ) { packetunavailable = new presence ( presence . type . unavailable ) ; packetunavailable . setfrom ( user + str_ + resource ) ; presencepacketlistener . processpacket ( packetunavailable ) ; } } } }	Changes the presence of available contacts offline by simulating anunavailable presence sent from the server.
private void firerosterchangedevent ( collection < string > addedentries , collection < string > updatedentries , collection < string > deletedentries ) { for ( rosterlistener listener : rosterlisteners ) { if ( ! addedentries . isempty ( ) ) { listener . entriesadded ( addedentries ) ; } if ( ! updatedentries . isempty ( ) ) { listener . entriesupdated ( updatedentries ) ; } if ( ! deletedentries . isempty ( ) ) { listener . entriesdeleted ( deletedentries ) ; } } }	Fires roster changed event to roster listeners indicating that thespecified collections of contacts have been added, updated or deletedfrom the roster.
public void setdigest ( string connectionid , string password ) { setdigest ( stringutils . hash ( connectionid + password ) ) ; }	Sets the digest value using a connection ID and password.
@ override public optional < ? extends resourcemodel > generateresource ( resourcemodel resourcemodel , optional < eventmodel > event ) { switch ( resourcemodel . getresourceid ( ) ) { case broadcasteravailableplaylists . resource_id : return createbroadcasteravailableplaylists ( ) ; case broadcasterplaylist . resource_id : return createbroadcasterplaylist ( resourcemodel ) ; default : return musicresourcegenerator . super . generateresource ( resourcemodel , event ) ; } }	generates the resources.
static playerrequest createplayerrequest ( playlist playlist , boolean permanent , identification player , capabilities capabilities , context context , identifiable identifiable ) { return new playerrequest ( null , playlist , permanent , player , capabilities , context , identifiable ) ; }	helper method for PlaylistSelector.
@ suppresswarnings ( str_ ) public static optional < long > gettimepassed ( eventmodel eventmodel ) { if ( eventmodel . getlistresourcecontainer ( ) . containsresourcesfromsource ( id ) ) { return eventmodel . getlistresourcecontainer ( ) . provideresource ( id ) . stream ( ) . map ( resourcemodel :: getresource ) . filter ( ob -> ob instanceof long ) . map ( ob -> ( long ) ob ) . findany ( ) ; } else { return optional . empty ( ) ; } }	returns the time passed if available.
public void registerupdatelistener ( consumer < propertiesassistant > listener ) { if ( listener != null ) listeners . add ( new weakreference < > ( listener ) ) ; }	the listener will always be called, when the Properties-file changes.
public void initproperties ( ) { propertiespath = getcontext ( ) . getfiles ( ) . getpropertieslocation ( ) + file . separator + getcontext ( ) . getaddons ( ) . getaddon ( ) . getid ( ) + str_ ; this . propertiesfile = new file ( propertiespath ) ; if ( ! this . propertiesfile . exists ( ) ) try { this . propertiesfile . createnewfile ( ) ; } catch ( ioexception e ) { error ( str_ , e ) ; } try { bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( this . propertiesfile ) , str_ ) ) ; try { properties . load ( in ) ; } catch ( ioexception e ) { error ( str_ , e ) ; } } catch ( filenotfoundexception | unsupportedencodingexception e ) { error ( str_ , e ) ; } if ( defaultpropertiespath != null && new file ( defaultpropertiespath ) . exists ( ) ) { @ suppresswarnings ( str_ ) enumeration < string > keys = ( enumeration < string > ) properties . propertynames ( ) ; if ( ! keys . hasmoreelements ( ) ) { try { createdefaultpropertyfile ( defaultpropertiespath ) ; } catch ( ioexception e ) { error ( str_ , e ) ; } if ( new file ( defaultpropertiespath ) . exists ( ) && ! writetopropertiesfile ( defaultpropertiespath ) ) return ; reloadproperties ( ) ; } } }	Initializes properties in the addOn.
private void reloadproperties ( ) { properties temp = new properties ( ) ; bufferedreader bufferedreader = null ; try { file properties = new file ( propertiespath ) ; bufferedreader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( properties ) , str_ ) ) ; temp . load ( bufferedreader ) ; this . properties = temp ; listeners . removeif ( weakreference -> weakreference . get ( ) == null ) ; listeners . foreach ( weakreference -> { consumer < propertiesassistant > consumer = weakreference . get ( ) ; if ( consumer != null ) consumer . accept ( this ) ; } ) ; } catch ( ioexception e ) { error ( str_ + propertiespath , e ) ; } finally { if ( bufferedreader != null ) { try { bufferedreader . close ( ) ; } catch ( ioexception e ) { error ( str_ , e ) ; } } } }	reloads the propertiesFile into the properties object.
public static streamerror parsestreamerror ( element el ) throws ioexception , xmlpullparserexception { string code = null ; element condel = ( element ) el . elements ( ) . iterator ( ) . next ( ) ; if ( condel . getnamespace ( ) . geturi ( ) . equals ( streamerror . namespace ) ) { code = condel . getname ( ) ; } string text = condel . elementtext ( str_ ) ; return new streamerror ( code , text ) ; }	Parses stream error packets.
@ suppresswarnings ( str_ ) public static collection < string > parsemechanisms ( element mechanismsel ) throws exception { list < element > mechanisms = mechanismsel . elements ( str_ ) ; list < string > mechanismsstr = new linkedlist < string > ( ) ; for ( element mechanismel : mechanisms ) { mechanismsstr . add ( mechanismel . gettext ( ) ) ; } return mechanismsstr ; }	Parse the available SASL mechanisms reported from the server.
@ suppresswarnings ( str_ ) public static collection < string > parsecompressionmethods ( element compressionel ) throws ioexception , xmlpullparserexception { list < element > methodsels = compressionel . elements ( str_ ) ; list < string > methodsstr = new linkedlist < string > ( ) ; for ( element methodel : methodsels ) { methodsstr . add ( methodel . gettext ( ) ) ; } return methodsstr ; }	Parse the available compression methods reported from the server.
public static packetextension parsepacketextension ( string elementname , string namespace , xmlpullparser parser ) throws exception { defaultpacketextension extension = new defaultpacketextension ( elementname , namespace ) ; boolean done = bool_ ; while ( ! done ) { int eventtype = parser . next ( ) ; if ( eventtype == xmlpullparser . start_tag ) { string name = parser . getname ( ) ;	Parses a packet extension sub-packet.
private static object decode ( class < ? > type , string value ) throws exception { if ( type . getname ( ) . equals ( str_ ) ) { return value ; } if ( type . getname ( ) . equals ( str_ ) ) { return boolean . valueof ( value ) ; } if ( type . getname ( ) . equals ( str_ ) ) { return integer . valueof ( value ) ; } if ( type . getname ( ) . equals ( str_ ) ) { return long . valueof ( value ) ; } if ( type . getname ( ) . equals ( str_ ) ) { return float . valueof ( value ) ; } if ( type . getname ( ) . equals ( str_ ) ) { return double . valueof ( value ) ; } if ( type . getname ( ) . equals ( str_ ) ) { return class . forname ( value ) ; } return null ; }	Decodes a String into an object of the specified type.
public static boolean verify ( eventmodel eventmodel , capabilities capabilities , identifiable player , list < identifiable > activators ) { if ( ! eventmodel . containsdescriptor ( startmusicrequest . id ) ) return bool_ ; if ( ! capabilities . handlesplayrequestfromoutside ( ) ) { if ( activators . stream ( ) . nonematch ( identifiable -> identifiable . isowner ( eventmodel . getsource ( ) ) ) ) return bool_ ; } if ( ! playlistresource . getplaylist ( eventmodel ) . map ( playlist -> playlist . verify ( capabilities ) ) . orelse ( bool_ ) ) { return bool_ ; } return selectorresource . istarget ( eventmodel , player ) . orelse ( bool_ ) ; }	verifies that the StartMusicRequest is correct and checks whether the you are meant to react to it.
public static optional < playbackstate > getplaybackstatefromresource ( resourcemodel x ) { if ( ! x . getresourceid ( ) . equals ( id ) ) return optional . empty ( ) ; object resource = x . getresource ( ) ; if ( resource instanceof string ) { string state = ( string ) resource ; try { return optional . of ( playbackstate . valueof ( state ) ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } } else { return optional . empty ( ) ; } }	returns the PlaybackState from the resource.
public string getsecretkey ( string subdomain ) {	Returns the secret key for a sub-domain.
public boolean ismultipleallowed ( string subdomain ) { boolean allowed = allowmultiple . get ( subdomain ) ; return allowed != null && allowed ; }	Returns if we want components to be able to connect multiple times to thesame JID.
public v put ( k key , v value ) { if ( key == null ) { throw new nullpointerexception ( str_ ) ; } if ( value == null ) { throw new nullpointerexception ( str_ ) ; } purgebeforewrite ( ) ; return super . put ( key , value ) ; }	Puts a key-value mapping into this map.
public set < k > keyset ( ) { if ( keyset == null ) { keyset = new referencekeyset < k , v > ( this ) ; } return keyset ; }	Returns a set view of this map's keys.
public collection < v > values ( ) { if ( values == null ) { values = new referencevalues < k , v > ( this ) ; } return values ; }	Returns a collection view of this map's values.
protected void purge ( reference ref ) {	Purges the specified reference.
protected hashentry < k , v > getentry ( object key ) { if ( key == null ) { return null ; } else { return super . getentry ( key ) ; } }	Gets the entry mapped to the key specified.
protected int hashentry ( object key , object value ) { return ( key == null ? num_ : key . hashcode ( ) ) ^ ( value == null ? num_ : value . hashcode ( ) ) ; }	Gets the hash code for a MapEntry.
public hashentry < k , v > createentry ( hashentry < k , v > next , int hashcode , k key , v value ) { return new referenceentry < k , v > ( this , ( referenceentry < k , v > ) next , hashcode , key , value ) ; }	Creates a ReferenceEntry instead of a HashEntry.
@ override public boolean controlevents ( eventmodel eventmodel ) { if ( level . compareto ( presenceindicatorlevel . weak ) >= num_ ) { return present ; } else	Controls whether the fired Event should be dispatched to all the listeners. This method should execute quickly.
public void setpresence ( boolean present ) { if ( this . present == present ) return ; this . present = present ; updatevague ( ) ; if ( present ) { firepresence ( bool_ ) ; } else { fireleaving ( ) ; } }	sets the presence.
private void updatevague ( ) { generateresource ( presenceresource . id ) . orelse ( completablefuture . completedfuture ( new arraylist < > ( ) ) ) . thenaccept ( list -> mostvague . set ( list . stream ( ) . map ( presence :: importpresence ) . filter ( optional :: ispresent ) . map ( optional :: get ) . map ( presence :: getlevel ) . nonematch ( level -> level . compareto ( getlevel ( ) ) > num_ ) ) ) ; }	updates the boolean whether it is the mode vague.
void deliver ( message message ) {	Delivers a message directly to this chat, which will add the message tothe collector and deliver it to all listeners registered with the Chat.This is used by the Connection class to deliver messages without a threadID.
protected final st generatescript ( string clazz , hashmap < string , boolean > targetmap ) { st ret = this . stg . getinstanceof ( str_ ) ; ret . add ( str_ , targetmap ) ; ret . add ( str_ , this . applicationdir ) ; ret . add ( str_ , this . configuration . get ( prop_run_script_name ) ) ; ret . add ( str_ , clazz ) ; return ret ; }	Generates a script.
protected final int initoutputdir ( ) { string parent = system . getproperty ( str_ ) ; string target = parent + file . separator + this . target ; file targetdir = new file ( target ) ; file parentdir = targetdir . getparentfile ( ) ; if ( targetdir . exists ( ) ) {	Tests and if necessary creates an output directory.The root path is the current directory as given by the system property "user.dir".The created output directory has the name of the specified target for the generator.The method fails if the output directory cannot be created or if it exists and is write protected.
protected final properties loadproperties ( string filename ) { properties ret = new properties ( ) ; url url = null ; file f = new file ( filename . tostring ( ) ) ; if ( f . exists ( ) ) { try { url = f . touri ( ) . tourl ( ) ; } catch ( exception ignore ) { } } else { classloader loader = thread . currentthread ( ) . getcontextclassloader ( ) ; url = loader . getresource ( filename ) ; if ( url == null ) { loader = gen_runscripts . class . getclassloader ( ) ; url = loader . getresource ( filename ) ; } } try { ret . load ( url . openstream ( ) ) ; } catch ( ioexception e ) { system . err . println ( this . getappname ( ) + str_ + filename + str_ + e + str_ ) ; } catch ( exception e ) { system . err . println ( this . getappname ( ) + str_ + filename + str_ + e + str_ ) ; } return ret ; }	Loads properties from a file.
protected final int writefile ( string fn , st st ) { try { filewriter fs = new filewriter ( fn ) ; bufferedwriter bw = new bufferedwriter ( fs ) ; bw . write ( st . render ( ) ) ; bw . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return - num_ ; } return num_ ; }	Writes an ST object to a file.
public static optional < progress > getprogress ( eventmodel eventmodel ) { if ( eventmodel . getlistresourcecontainer ( ) . containsresourcesfromsource ( id ) ) { return eventmodel . getlistresourcecontainer ( ) . provideresource ( id ) . stream ( ) . findany ( ) . flatmap ( progress :: importresource ) ; } else { return optional . empty ( ) ; } }	gets the first Progress if found in the EventModel.
public static < e > collection < e > decorate ( collection < e > coll ) { return new synchronizedcollection < e > ( coll ) ; }	Factory method to create a synchronized collection.
public static collection < serviceresolver > discover ( inetaddress start , int count , int mstimeout ) { collection < serviceresolver > result = new arraylist < serviceresolver > ( ) ; collection < inetaddress > hosts = ipv4scanner . scanrange ( start , count , mstimeout ) ; for ( inetaddress host : hosts ) { serviceresolver resolver = new serviceresolver ( host ) ; logger . info ( str_ , host . gethostaddress ( ) , host . getcanonicalhostname ( ) ) ; jsonresult config = resolver . getconfig ( ) ; if ( config != null ) { result . add ( resolver ) ; } } return result ; }	Discover FireREST services located in a range of IPv4 InetAddresses.E.g., The range of 256 addresses that starts with 10.0.1.128 ends with 10.0.2.127.
public jsonresult getconfig ( ) { if ( attempts == num_ ) { try { resolve ( ) ; } catch ( exception e ) {	Return the cached service configuration, resolving the service if required.
@ override public org . intellimate . izou . sdk . specification . context . threadpool getthreadpool ( ) { return threadpool ; }	returns the API used to manage the ThreadPool.
public static optional < stopmusic > createstopmusic ( identification source , identification target ) { if ( target == null || target . equals ( source ) ) return optional . empty ( ) ; try { stopmusic stoprequest = new stopmusic ( source ) ; stoprequest . addresource ( new selectorresource ( source , target ) ) ; return optional . of ( stoprequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new StopRequest.
public static boolean verify ( eventmodel eventmodel , identifiable player ) { if ( ! eventmodel . containsdescriptor ( stopmusic . id ) ) return bool_ ; return selectorresource . istarget ( eventmodel , player ) . orelse ( bool_ ) ; }	verifies that the StopMusicRequest is correct and checks whether the you are meant to react to it.
public dsecluster getcluster ( string hostsandports , string username , string password , string authorizationid ) { return getcluster ( clusteridentifier . getinstance ( hostsandports , username , password , authorizationid ) ) ; }	Obtain a DSE cluster instance.
public void addconnectionlistener ( connectionlistener connectionlistener ) { if ( connectionlistener == null ) { return ; } if ( ! connectionlisteners . contains ( connectionlistener ) ) { connectionlisteners . add ( connectionlistener ) ; } }	Adds a connection listener to this connection that will be notified whenthe connection closes or fails.
public void addpacketlistener ( packetlistener packetlistener , packetfilter packetfilter ) { if ( packetlistener == null ) { throw new nullpointerexception ( str_ ) ; } listenerwrapper wrapper = new listenerwrapper ( packetlistener , packetfilter ) ; recvlisteners . put ( packetlistener , wrapper ) ; }	Registers a packet listener with this connection.
public void addpacketsendinglistener ( packetlistener packetlistener , packetfilter packetfilter ) { if ( packetlistener == null ) { throw new nullpointerexception ( str_ ) ; } listenerwrapper wrapper = new listenerwrapper ( packetlistener , packetfilter ) ; sendlisteners . put ( packetlistener , wrapper ) ; }	Registers a packet listener with this connection.
protected void firepacketsendinglisteners ( packet packet ) {	Process all packet listeners for sending packets.
public void addpacketinterceptor ( packetinterceptor packetinterceptor , packetfilter packetfilter ) { if ( packetinterceptor == null ) { throw new nullpointerexception ( str_ ) ; } interceptors . put ( packetinterceptor , new interceptorwrapper ( packetinterceptor , packetfilter ) ) ; }	Registers a packet interceptor with this connection.
protected void firepacketinterceptors ( packet packet ) { if ( packet != null ) { for ( interceptorwrapper interceptorwrapper : interceptors . values ( ) ) { interceptorwrapper . notifylistener ( packet ) ; } } }	Process interceptors. Interceptors may modify the packet that is about tobe sent. Since the thread that requested to send the packet will invokeall interceptors, it is important that interceptors perform their work assoon as possible so that the thread does not remain blocked for a longperiod.
public static object tovalue ( string name , object value ) { string [ ] parts = stringutils . split ( name , str_ , num_ ) ; string fieldname = null ; string fieldtype = str_ ; if ( parts . length == num_ ) { fieldtype = parts [ num_ ] ; fieldname = parts [ num_ ] ; } else if ( parts . length == num_ ) { fieldname = parts [ num_ ] ; } else { throw new illegalargumentexception ( str_ ) ; } try { int l = array . getlength ( value ) ; requestparametertype < ? > rpt = types . get ( fieldtype ) ; if ( rpt == null ) { rpt = types . get ( requestparametertype . string ) ; } if ( ! fieldname . endswith ( str_ ) && l == num_ ) { return rpt . newinstance ( array . get ( value , num_ ) ) ; } class < ? > componenttype = rpt . getcomponenttype ( ) ; object [ ] a = ( object [ ] ) array . newinstance ( componenttype , l ) ; for ( int i = num_ ; i < l ; i ++ ) { a [ i ] = rpt . newinstance ( array . get ( value , i ) ) ; } return a ; } catch ( illegalargumentexception e ) { requestparametertype < ? > rpt = types . get ( fieldtype ) ; if ( rpt == null ) { rpt = types . get ( requestparametertype . string ) ; } return rpt . newinstance ( value ) ; } }	Creates the most suitable type.
public void connectionlost ( ) {	Notification message that the connection with the server was lostunexpectedly.
protected string getcurrentthreadid ( ) { string attach_id = ( string ) threadsession . getvalue ( getthreadsessionkey ( ) ) ; if ( attach_id != null ) return attach_id ; thread thread = thread . currentthread ( ) ; return thread . tostring ( ) + str_ + thread . hashcode ( ) + str_ ; }	Retrieve the current thread id for use by thetransaction code.
private boolean validnode ( final node < k , v > node , final string thread_id ) { if ( auto_commit || node == null ) return ( node != null ) ; return ! ( ( node . is ( node . deleted , thread_id ) ) || ( node . is ( node . added , null ) && node . is ( node . no_change , thread_id ) ) ) ; }	Checks that this node is valid for the current thread.
public k getkeyforvalue ( final object value ) throws classcastexception , nullpointerexception { return ( k ) doget ( value , value ) ; }	Returns the key to which this map maps the specified value.Returns null if the map contains no mapping for this value.
private object doget ( final object o , final int index ) { checknonnullcomparable ( o , index ) ; node < k , v > node = lookupvalid ( o , index , getcurrentthreadid ( ) ) ; return ( node == null ) ? null : node . getdata ( oppositeindex ( index ) ) ; }	common get logic, used to get by key or get by value.
private node < k , v > lookupvalid ( final object data , final int index , final string thread_id ) { return nextequalvalid ( getfloorequalnode ( lookup ( data , index ) , index ) , index , thread_id ) ; }	do the actual lookup of a piece of valid data.
private node < k , v > lookup ( final object data , final int index ) { node < k , v > rval = null ; node < k , v > node = rootnode [ index ] ; while ( node != null ) { int cmp = compare ( node . no_change , data , node . getstatus ( ) , node . getdata ( index ) , index ) ; if ( cmp == num_ ) { rval = node ; break ; } else { node = ( cmp < num_ ) ? node . getleft ( index ) : node . getright ( index ) ; } } return rval ; }	do the actual lookup of a piece of data.
private int compare ( final int o1_status , final object o1 , final int o2_status , final object o2 , final int index ) { if ( comparators [ index ] == null ) { if ( o1 instanceof transactionalcomparable ) return ( ( transactionalcomparable ) o1 ) . compareto ( o1_status , o2 , o2_status ) ; else return ( ( comparable ) o1 ) . compareto ( o2 ) ; } else { return comparators [ index ] . compare ( o1 , o2 ) ; } }	Compare two objects.
private node < k , v > leastnode ( final node < k , v > node , final int index ) { node < k , v > lval = node ; if ( lval != null ) { while ( lval . getleft ( index ) != null ) { lval = lval . getleft ( index ) ; } } return lval ; }	find the least node from a given node.
private node < k , v > mostnode ( final node < k , v > node , final int index ) { node < k , v > rval = node ; if ( rval != null ) { while ( rval . getright ( index ) != null ) { rval = rval . getright ( index ) ; } } return rval ; }	find the most node from a given node.
private node < k , v > nextgreater ( final node < k , v > node , final int index ) { node < k , v > rval ; if ( node == null ) { rval = null ; } else if ( node . getright ( index ) != null ) {	get the next larger node from the specified node.
private node < k , v > mostvalidnode ( final node < k , v > node , final int index , final string thread_id ) { node < k , v > rval = node ; while ( rval != null && ! validnode ( rval , thread_id ) ) { rval = nextgreater ( rval , index ) ; } return rval ; }	get the most valid node from the specified node.
private node < k , v > leastvalidnode ( final node < k , v > node , final int index , final string thread_id ) { node < k , v > lval = node ; while ( lval != null && ! validnode ( lval , thread_id ) ) { lval = nextsmaller ( lval , index ) ; } return lval ; }	find the least valid node from a given node.
private static < k , v > void copycolor ( final node < k , v > from , final node < k , v > to , final int index ) { if ( to != null ) { if ( from == null ) {	copy the color from one node to another, dealing with the factthat one or both nodes may, in fact, be null.
private static < k , v > boolean isred ( final node < k , v > node , final int index ) { return ( ( node == null ) ? bool_ : node . isred ( index ) ) ; }	is the specified node red? if the node does not exist, no, it'sblack, thank you.
private static < k , v > boolean isblack ( final node < k , v > node , final int index ) { return ( ( node == null ) ? bool_ : node . isblack ( index ) ) ; }	is the specified black red? if the node does not exist, sure,it's black, thank you.
private static < k , v > node < k , v > getgrandparent ( final node < k , v > node , final int index ) { return getparent ( getparent ( node , index ) , index ) ; }	get a node's grandparent.
private static < k , v > node < k , v > getparent ( final node < k , v > node , final int index ) { return ( ( node == null ) ? null : node . getparent ( index ) ) ; }	get a node's parent.
private static < k , v > node < k , v > getrightchild ( final node < k , v > node , final int index ) { return ( node == null ) ? null : node . getright ( index ) ; }	get a node's right child.
private static < k , v > node < k , v > getleftchild ( final node < k , v > node , final int index ) { return ( node == null ) ? null : node . getleft ( index ) ; }	get a node's left child.
private void rotateleft ( final node < k , v > node , final int index ) { node < k , v > rightchild = node . getright ( index ) ; node . setright ( rightchild . getleft ( index ) , index ) ; if ( rightchild . getleft ( index ) != null ) { rightchild . getleft ( index ) . setparent ( node , index ) ; } rightchild . setparent ( node . getparent ( index ) , index ) ; if ( node . getparent ( index ) == null ) {	do a rotate left. standard fare in the world of balanced trees.
private void rotateright ( final node < k , v > node , final int index ) { node < k , v > leftchild = node . getleft ( index ) ; node . setleft ( leftchild . getright ( index ) , index ) ; if ( leftchild . getright ( index ) != null ) { leftchild . getright ( index ) . setparent ( node , index ) ; } leftchild . setparent ( node . getparent ( index ) , index ) ; if ( node . getparent ( index ) == null ) {	do a rotate right. standard fare in the world of balanced trees.
private void doredblackinsert ( final node < k , v > insertednode , final int index ) { node < k , v > currentnode = insertednode ; makered ( currentnode , index ) ; while ( ( currentnode != null ) && ( currentnode != rootnode [ index ] ) && ( isred ( currentnode . getparent ( index ) , index ) ) ) { if ( isleftchild ( getparent ( currentnode , index ) , index ) ) { node < k , v > y = getrightchild ( getgrandparent ( currentnode , index ) , index ) ; if ( isred ( y , index ) ) { makeblack ( getparent ( currentnode , index ) , index ) ; makeblack ( y , index ) ; makered ( getgrandparent ( currentnode , index ) , index ) ; currentnode = getgrandparent ( currentnode , index ) ; } else { if ( isrightchild ( currentnode , index ) ) { currentnode = getparent ( currentnode , index ) ; rotateleft ( currentnode , index ) ; } makeblack ( getparent ( currentnode , index ) , index ) ; makered ( getgrandparent ( currentnode , index ) , index ) ; if ( getgrandparent ( currentnode , index ) != null ) { rotateright ( getgrandparent ( currentnode , index ) , index ) ; } } } else {	complicated red-black insert stuff. Based on Sun's TreeMapimplementation, though it's barely recognizable any more.
private void doredblackdelete ( final node < k , v > deletednode ) { for ( int index = first_index ; index < number_of_indices ; index ++ ) {	complicated red-black delete stuff. Based on Sun's TreeMapimplementation, though it's barely recognizable any more.
private void checknonnullcomparable ( final object o , final int index ) { if ( o == null ) { throw new nullpointerexception ( dataname [ index ] + str_ ) ; } if ( comparators [ index ] == null && ! ( o instanceof comparable ) ) { throw new classcastexception ( dataname [ index ] + str_ ) ; } }	check if an object is fit to be proper input ..
private void insertvalue ( final node < k , v > newnode , final string thread_id ) throws illegalargumentexception { node < k , v > node = rootnode [ value ] ; while ( bool_ ) { int cmp = compare ( node . added , newnode . getdata ( value ) , node . getstatus ( ) , node . getdata ( value ) , value ) ; if ( cmp == num_ ) { if ( nextequalvalid ( getfloorequalnode ( node , value ) , value , thread_id ) != null ) { string debug_message = str_ + newnode . getdata ( value ) + str_ + node . getkey ( ) ; log . debug ( debug_message ) ; throw new illegalargumentexception ( debug_message ) ; } if ( node . is ( node . added , null ) ) throw new concurrentmodificationexception ( ) ; if ( node . getright ( value ) != null ) { node = node . getright ( value ) ; } else if ( node . getleft ( value ) != null ) { node = node . getleft ( value ) ; } else { node . setright ( newnode , value ) ; newnode . setparent ( node , value ) ; doredblackinsert ( newnode , value ) ; break ; } } else if ( cmp < num_ ) { if ( node . getleft ( value ) != null ) { node = node . getleft ( value ) ; } else { node . setleft ( newnode , value ) ; newnode . setparent ( node , value ) ; doredblackinsert ( newnode , value ) ; break ; } } else {	insert a node by its value.
@ override public boolean containskey ( final object key ) throws classcastexception , nullpointerexception { checkkey ( key ) ; return lookupvalid ( key , key , getcurrentthreadid ( ) ) != null ; }	Returns true if this map contains a mapping for the specifiedkey.
@ override public boolean containsvalue ( final object value ) { checkvalue ( value ) ; return lookupvalid ( value , value , getcurrentthreadid ( ) ) != null ; }	Returns true if this map maps one or more keys to thespecified value.
@ override public v get ( final object key ) throws classcastexception , nullpointerexception { checkkey ( key ) ; return ( v ) doget ( key , key ) ; }	Returns the value to which this map maps the specifiedkey.
@ override public v remove ( final object key ) throws concurrentmodificationexception { checkkey ( key ) ; return ( v ) doremove ( key , key ) ; }	Removes the mapping for this key from this map if present.
@ override public void clear ( ) { if ( auto_commit ) { modify ( ) ; nodecount = num_ ; rootnode [ key ] = null ; rootnode [ value ] = null ; } else { string thread_id = getcurrentthreadid ( ) ; arraylist < entry < k , v > > list = new arraylist < entry < k , v > > ( entryset ( ) ) ; for ( iterator < entry < k , v > > i = list . iterator ( ) ; i . hasnext ( ) ; ) { node < k , v > node = ( node < k , v > ) i . next ( ) ; if ( node . is ( node . added , thread_id ) ) doredblackdelete ( node ) ; else { node . setstatus ( node . deleted , thread_id ) ; } } } }	Removes all mappings from this map.
public final void copyentries ( transactionalbiditreemap < k , v > new_map ) { k key ; v val ; int transaction_status ; string transaction_id ; new_map . setautocommit ( isautocommit ( ) ) ; if ( ! isautocommit ( ) ) {	Copy all entries including transaction statuses from this map into the supplied map.Do not use this method unless you know exactly what you are doing.
protected synchronized void deleteexpiredentries ( ) {	Clears all entries out of cache where the entries are older than themaximum defined age.
protected synchronized void cullcache ( ) {	Removes the least recently used elements if the cache size is greaterthan or equal to the maximum allowed size until the cache is at least 10%empty.
protected void activate ( map < string , object > props ) {	When the bundle gets activated we retrieve the OSGi properties.
public optional < playerrequest > getplayerrequest ( string playlistname , boolean permanent ) { return getplaylist ( playlistname ) . map ( playlist -> playerrequest . createplayerrequest ( playlist , permanent , player , capabilities , context , identifiable ) ) ; }	asks the player for more information about the specified playlist and creates a PlayerRequest with the answer.
public static defaultrosterstore init ( final file basedir ) { defaultrosterstore store = new defaultrosterstore ( basedir ) ; if ( store . setrosterversion ( str_ ) ) { return store ; } else { return null ; } }	Creates a new roster store on disk.
public static defaultrosterstore open ( final file basedir ) { defaultrosterstore store = new defaultrosterstore ( basedir ) ; string s = store . readfile ( store . getversionfile ( ) ) ; if ( s != null && s . startswith ( store_id + str_ ) ) { return store ; } else { return null ; } }	Opens a roster store.
public static collection < inetaddress > scanrange ( inetaddress addr , int count , int mstimeout ) { collection < inetaddress > addresses = new arraylist < inetaddress > ( ) ; collection < inetaddress > result = new arraylist < inetaddress > ( ) ; if ( addr == null ) { try { addresses . addall ( localhostnetworkaddresses ( ) ) ; } catch ( exception e ) { throw new firerestexception ( e ) ;	Scan a range of InetAddresses starting with the given address.
public static inetaddress subnetaddress0 ( inetaddress addr , int subnetbits ) { if ( subnetbits < num_ || num_ <= subnetbits ) { throw new firerestexception ( str_ ) ; } long mask = num_ ; for ( int i = num_ ; i < num_ ; i ++ ) { mask <<= num_ ; mask |= i < subnetbits ? num_ : num_ ; } long host0 = aslongaddress ( addr ) & mask ; try { return asinetaddress ( host0 ) ; } catch ( unknownhostexception e ) { throw new firerestexception ( e ) ; } }	Return first address on subnet containing given address.
public hashmap < string , object > export ( ) { hashmap < string , object > data = new hashmap < > ( ) ; data . put ( namedescriptor , name ) ; data . put ( artistdescriptor , artist ) ; data . put ( albumdescriptor , albumdescriptor ) ; data . put ( albumcoverdescriptor , albumcover ) ; data . put ( albumcoverformatdescriptor , albumcoverformatdescriptor ) ; data . put ( datadescriptor , this . data ) ; data . put ( yeardescriptor , this . year ) ; data . put ( genredescriptor , this . genre ) ; data . put ( durationdescriptor , this . duration ) ; data . put ( bmpdescriptor , this . bmp ) ; return data ; }	exports the TrackInfo to a Hashmap.
public static optional < trackinfo > importfromhashmap ( hashmap < string , object > hashmap ) { try { string name = ( string ) hashmap . get ( namedescriptor ) ; string album = ( string ) hashmap . get ( albumdescriptor ) ; string artist = ( string ) hashmap . get ( artistdescriptor ) ; byte [ ] albumcover = ( byte [ ] ) hashmap . get ( albumcoverdescriptor ) ; string albumcoverformat = ( string ) hashmap . get ( albumcoverformatdescriptor ) ; string data = ( string ) hashmap . get ( datadescriptor ) ; string year = ( string ) hashmap . get ( yeardescriptor ) ; string genre = ( string ) hashmap . get ( genredescriptor ) ; long duration = ( long ) hashmap . get ( durationdescriptor ) ; string bmp = ( string ) hashmap . get ( bmpdescriptor ) ; return optional . of ( new trackinfo ( name , artist , album , albumcover , albumcoverformat , data , year , genre , bmp , duration ) ) ; } catch ( classcastexception e ) { return optional . empty ( ) ; } }	returns the optional TrackInfo if the HashMap contains no malformed data.
protected final void addallapplications ( set < class < ? > > set ) { for ( class < ? > cls : set ) { if ( ! cls . isinterface ( ) && ! modifier . isabstract ( cls . getmodifiers ( ) ) ) { if ( ! this . classmap . containsvalue ( cls ) ) { this . classnames . add ( cls . getname ( ) ) ; } } } }	Adds a set of application at runtime, as in all found applications that can be executed.
protected int executeapplication ( object svc , string [ ] args , string orig ) { if ( svc != null && ( svc instanceof execs_application ) ) { if ( svc instanceof gen_runscripts ) {	Executes an application.
protected final void printlist ( ) { st list = this . stg . getinstanceof ( str_ ) ; list . add ( str_ , this . appname ) ; if ( this . classmap . size ( ) > num_ ) { list < map < string , string > > l = new arraylist < > ( ) ; for ( string key : this . classmap . keyset ( ) ) { map < string , string > m = new hashmap < > ( ) ; m . put ( str_ , key ) ; m . put ( str_ , this . classmap . get ( key ) . getname ( ) ) ; l . add ( m ) ; } list . add ( str_ , l ) ; } list . add ( str_ , this . classnames ) ; system . out . println ( list . render ( ) ) ; }	Prints a list of pre-registered and found applications.
protected final void printusage ( ) { st usage = this . stg . getinstanceof ( str_ ) ; usage . add ( str_ , this . appname ) ; usage . add ( str_ , this . packagefilter ) ; usage . add ( str_ , this . jarfilter ) ; usage . add ( str_ , new treeset < > ( arrays . aslist ( new cf ( ) . excludednames ) ) ) ; system . out . println ( usage . render ( ) ) ; }	Prints usage information to standard out.
public static void main ( string [ ] args ) { execs run = new execs ( ) ; int ret = run . execute ( args ) ; system . exit ( ret ) ; }	Public main to start the application executor.
public static optional < muteevent > createmuteevent ( identification source , identification target ) { if ( target == null || target . equals ( source ) ) return optional . empty ( ) ; try { muteevent muterequest = new muteevent ( source ) ; muterequest . addresource ( new selectorresource ( source , target ) ) ; return optional . of ( muterequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new MuteEvent.
public static optional < muteevent > createmuteevent ( identification source ) { if ( source == null ) return optional . empty ( ) ; try { muteevent muterequest = new muteevent ( source ) ; return optional . of ( muterequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new MuteEvent, will mute everything.
public goodwillschema getschema ( final string schemaname ) { goodwillschema schema = knownschemata . get ( schemaname ) ; if ( schema == null ) { refreshschematacache ( ) ; schema = knownschemata . get ( schemaname ) ; } return schema ; }	Given a schema name, get the associated GoodwillSchema.
public boolean writefile ( file file , list < string > lines ) { if ( file . exists ( ) ) { file . delete ( ) ; } try { filewriter out = new filewriter ( file ) ; for ( string s : lines ) { out . write ( s ) ; out . write ( system . getproperty ( str_ ) ) ; } out . close ( ) ; file . setexecutable ( bool_ ) ; } catch ( ioexception ex ) { system . err . println ( this . getappname ( ) + str_ + file + str_ + ex . getmessage ( ) ) ; return bool_ ; } return bool_ ; }	Writes the given lines to the given file, if possible.
protected boolean inexecjar ( ) { class < gen_execjarscripts > clazz = gen_execjarscripts . class ; string classname = clazz . getsimplename ( ) + str_ ; string classpath = clazz . getresource ( classname ) . tostring ( ) ; if ( ! classpath . startswith ( str_ ) ) { system . err . println ( this . getappname ( ) + str_ ) ; return bool_ ; } string manifestpath = classpath . substring ( num_ , classpath . lastindexof ( str_ ) + num_ ) + str_ ; manifest manifest ; try { manifest = new manifest ( new url ( manifestpath ) . openstream ( ) ) ; } catch ( ioexception ex ) { system . err . println ( this . getappname ( ) + str_ + ex . getmessage ( ) ) ; return bool_ ; } attributes attr = manifest . getmainattributes ( ) ; if ( stringutils . isblank ( attr . getvalue ( str_ ) ) ) { system . err . println ( this . getappname ( ) + str_ ) ; return bool_ ; } return bool_ ; }	Tests if the class is run from an executable JAR.
protected void addoption ( applicationoption < ? > option ) { if ( option != null ) { this . getcli ( ) . addoption ( option ) ; this . options . add ( option ) ; } }	Adds a new option to CLI parser and option list.
public arraylist < goodwillschemafield > getschema ( ) { final arraylist < goodwillschemafield > items = new arraylist < goodwillschemafield > ( thriftitems . values ( ) ) ; collections . sort ( items , new comparator < goodwillschemafield > ( ) { @ override public int compare ( final goodwillschemafield left , final goodwillschemafield right ) { return short . valueof ( left . getid ( ) ) . compareto ( right . getid ( ) ) ; } } ) ; return items ; }	Get the schema as a collection of fields.We guarantee the ordering by field id.
public goodwillschemafield getfieldbyname ( final string name ) { for ( final goodwillschemafield field : thriftitems . values ( ) ) { if ( field . getname ( ) . equals ( name ) ) { return field ; } } return null ; }	Given a name, return the field matching the name.
public final static string getpkgname ( jarentry entry ) { if ( entry == null ) { return str_ ; } string s = entry . getname ( ) ; if ( s == null ) { return str_ ; } if ( s . length ( ) == num_ ) { return s ; } if ( s . startswith ( str_ ) ) { s = s . substring ( num_ , s . length ( ) ) ; } if ( s . endswith ( str_ ) ) { s = s . substring ( num_ , s . length ( ) - num_ ) ; } return s . replace ( str_ , str_ ) ; }	Returns the package name for a jar entry.
private immutablemap < c , v > mapcontenttovalues ( final immutablemap < k , v > base ) { final immutablemap . builder < c , v > builder = immutablemap . builder ( ) ; for ( final entry < k , v > entry : base . entryset ( ) ) { builder . put ( this . key ( entry . getkey ( ) ) , entry . getvalue ( ) ) ; } return builder . build ( ) ; }	Maps the content of the base map to its values.
public static optional < eventlistener > createeventlistener ( string descriptor , string description , string descriptorid , identifiable identifiable ) throws illegalargumentexception { if ( ! descriptorid . matches ( str_ ) ) throw new illegalargumentexception ( str_ + descriptorid + str_ ) ; return identificationmanagerm . getinstance ( ) . getidentification ( identifiable ) . flatmap ( id -> event . createevent ( commonevents . type . notification_type , id , collections . singletonlist ( descriptor ) ) ) . map ( event -> new eventlistener ( event , descriptor , description , descriptorid ) ) ; }	Create the EventListener.
public iterativestate < t , r > setstate ( iterativestate < t , r > new_state ) { iterativestate < t , r > old_state = this . state ; this . state = new_state ; return old_state ; }	Sets the supplied state for this IterativeCallback.
public r iterate ( final filterablecollection < ? extends t > c ) { initstate ( ) ; checkused ( ) ;	public wrapper for the iteration.
private r doiteration ( iterator < ? extends t > it ) {	do the actual iteration.
public static optional < trackinfo > gettrackinfo ( eventmodel eventmodel ) { if ( eventmodel . getlistresourcecontainer ( ) . containsresourcesfromsource ( resource_id ) ) { return eventmodel . getlistresourcecontainer ( ) . provideresource ( resource_id ) . stream ( ) . findany ( ) . flatmap ( trackinfo :: importfromresource ) ; } else { return optional . empty ( ) ; } }	gets the first TrackInfo if found in the EventModel.
public hashmap < string , long > export ( ) { hashmap < string , long > data = new hashmap < > ( ) ; data . put ( lengthdescriptor , length ) ; data . put ( knownpositiondescriptor , knownposition ) ; data . put ( knownmillistimestampdescriptor , knownmillistimestamp ) ; return data ; }	exports the progress.
public static optional < progress > importresource ( resourcemodel resourcemodel ) { object resource = resourcemodel . getresource ( ) ; try {	creates a Progress-object from the resourceModel.
public bufferedimage errorimage ( string ... lines ) { if ( imagebuffer == null || imagebuffer . getwidth ( ) != imagewidth || imagebuffer . getheight ( ) != imageheight ) { imagebuffer = new bufferedimage ( imagewidth , imageheight , bufferedimage . type_int_rgb ) ; } graphics2d g = ( graphics2d ) imagebuffer . getgraphics ( ) ; g . setbackground ( new color ( num_ , num_ , num_ ) ) ; g . setcolor ( new color ( num_ , num_ , num_ ) ) ; g . clearrect ( num_ , num_ , imagewidth , imageheight ) ; int maxlen = num_ ; for ( string line : lines ) { if ( line != null ) { for ( string innerline : line . split ( str_ ) ) { maxlen = math . max ( innerline . length ( ) , maxlen ) ; } } } int padding = num_ ; float sizeforwidth = num_ * ( imagewidth - padding - padding ) / maxlen ;	Return an red image with the given text auto-sized to fit the current imageWidthximageHeight.
public bufferedimage getimage ( url url ) { string now = new date ( ) . tostring ( ) ; if ( url == null ) { return errorimage ( now , str_ ) ; } try { httpurlconnection urlconn = ( httpurlconnection ) url . openconnection ( ) ; urlconn . setreadtimeout ( mstimeout ) ; urlconn . setconnecttimeout ( mstimeout ) ; urlconn . setrequestmethod ( str_ ) ; urlconn . connect ( ) ; bufferedimage image = imageio . read ( urlconn . getinputstream ( ) ) ; if ( image == null ) { return errorimage ( now , str_ ) ; } imagewidth = image . getwidth ( ) ; imageheight = image . getheight ( ) ; return image ; } catch ( sockettimeoutexception e ) { logger . warn ( str_ , url , e . getclass ( ) . getcanonicalname ( ) , e . getmessage ( ) ) ; return errorimage ( now , mstimeout + str_ ) ; } catch ( exception e ) { logger . warn ( str_ , url , e . getclass ( ) . getcanonicalname ( ) , e . getmessage ( ) ) ; return errorimage ( now , str_ , url . tostring ( ) , e . getmessage ( ) ) ; } }	Return image from given URL.
public jsonresult getjson ( url url ) { try { logger . debug ( str_ , url ) ; stringbuilder text = new stringbuilder ( ) ; string line ; httpurlconnection urlconn = ( httpurlconnection ) url . openconnection ( ) ; urlconn . setreadtimeout ( mstimeout ) ; urlconn . setconnecttimeout ( mstimeout ) ; urlconn . setrequestmethod ( str_ ) ; urlconn . connect ( ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( urlconn . getinputstream ( ) ) ) ; while ( ( line = br . readline ( ) ) != null ) { text . append ( line ) ; } return new jsonresult ( text . tostring ( ) ) ; } catch ( throwable e ) { throw new firerestexception ( url . tostring ( ) , e ) ; } }	HTTP GET json from given URL resource.
public static < k , v > void reverse ( map < k , v > source , map < v , k > target ) { iterator < k > i = source . keyset ( ) . iterator ( ) ; while ( i . hasnext ( ) ) { k key = i . next ( ) ; v value = source . get ( key ) ; target . put ( value , key ) ; } }	Take key and value pairs from source and create map from value to key in target.
private set < r > multiplication ( ) { final set < r > answer = new linkedhashset < > ( this . one . size ( ) * this . two . size ( ) ) ; for ( final a left : this . one ) { for ( final b right : this . two ) { final r element = this . function . apply ( left , right ) ; if ( answer . contains ( element ) ) { throw new illegalstateexception ( string . format ( str_ , element ) ) ; } answer . add ( element ) ; } } return immutableset . copyof ( answer ) ; }	Creates Cartesian product of two lists.
@ override public synchronized void start ( ) { if ( ! running && ! used ) { this . running = bool_ ; this . used = bool_ ; this . setdaemon ( bool_ ) ; super . start ( ) ; } }	Sets the thread running.
private void returntopool ( ) { if ( pool != null ) { try { pool . returnobject ( this ) ; } catch ( exception e1 ) { log . error ( str_ , e1 ) ; } this . pool = null ; } }	Returns the thread to the pool.
public static optional < endedevent > createendedevent ( identification source ) { try { endedevent stoprequest = new endedevent ( source ) ; return optional . of ( stoprequest ) ; } catch ( illegalargumentexception e ) { return optional . empty ( ) ; } }	creates a new EndedEvent.
public trackinfo getcurrent ( ) { trackinfo trackinfo = null ; try { trackinfo = queue . get ( position ) ; } catch ( indexoutofboundsexception e ) { trackinfo = null ; } return trackinfo ; }	returns the current played track or null.
public playlist update ( trackinfo old , trackinfo newtrackinfo ) { list < trackinfo > list = new arraylist < > ( queue ) ; list . set ( list . indexof ( old ) , newtrackinfo ) ; return new playlist ( queue , name , playbackmodes , position ) ; }	updates the TrackInfo-Object.
public playlist shuffle ( ) { int position = getposition ( ) ; long seed = system . nanotime ( ) ; if ( position >= num_ && position < queue . size ( ) ) { list < trackinfo > trackinfos = queue . sublist ( num_ , position ) ; list < trackinfo > notplayed = queue . sublist ( position , queue . size ( ) ) ; list < trackinfo > shufflednotplayed = new arraylist < > ( notplayed ) ; collections . shuffle ( shufflednotplayed , new random ( seed ) ) ; trackinfos . addall ( shufflednotplayed ) ; return new playlist ( trackinfos ) ; } else { list < trackinfo > trackinfos = new arraylist < > ( queue ) ; collections . shuffle ( trackinfos , new random ( seed ) ) ; return new playlist ( trackinfos ) ; } }	Shuffles the playlist and returns the shuffled playlist, so the original stays intact.Only the part of the playlist after the current position is shuffled.
public boolean verify ( capabilities capabilities ) { for ( playbackmode playbackmode : playbackmodes ) { switch ( playbackmode ) { case repeat : if ( ! capabilities . canrepeatplayback ( ) ) { return bool_ ; } else { break ; } case repeat_song : if ( ! capabilities . canrepeatplaybackofsong ( ) ) { return bool_ ; } else { break ; } case shuffle : if ( ! capabilities . canshuffleplayback ( ) ) { return bool_ ; } else { break ; } } } return bool_ ; }	returns true if all the active playbackModes are supported.
public hashmap < string , object > export ( ) { hashmap < string , object > data = new hashmap < > ( ) ; for ( int i = num_ ; i < queue . size ( ) ; i ++ ) { data . put ( queue_descriptor + i , queue . get ( i ) . export ( ) ) ; } for ( int i = num_ ; i < playbackmodes . size ( ) ; i ++ ) { data . put ( playback_mode_descriptor + i , playbackmodes . get ( i ) . name ( ) ) ; } data . put ( name_descriptor , name ) ; data . put ( position_descriptor , position ) ; data . put ( data_descriptor , this . data ) ; return data ; }	exports the Playlist to a HashMap.
public static final string escapeforxml ( string string ) { if ( string == null ) { return null ; } char ch ; int i = num_ ; int last = num_ ; char [ ] input = string . tochararray ( ) ; int len = input . length ; stringbuffer out = new stringbuffer ( ( int ) ( len * num_ ) ) ; for ( ; i < len ; i ++ ) { ch = input [ i ] ; if ( ch > str_ ) { continue ; } else if ( ch == str_ ) { if ( i > last ) { out . append ( input , last , i - last ) ; } last = i + num_ ; out . append ( lt_encode ) ; } else if ( ch == str_ ) { if ( i > last ) { out . append ( input , last , i - last ) ; } last = i + num_ ; out . append ( gt_encode ) ; } else if ( ch == str_ ) { if ( i > last ) { out . append ( input , last , i - last ) ; }	Escapes all necessary characters in the String so that it can be used inan XML doc.
public void challengereceived ( string challenge ) throws ioexception { byte response [ ] ; if ( challenge != null ) { response = sc . evaluatechallenge ( stringutils . decodebase64 ( challenge ) ) ; } else { response = sc . evaluatechallenge ( new byte [ num_ ] ) ; } packet responsestanza ; if ( response == null ) { responsestanza = new response ( ) ; } else { responsestanza = new response ( stringutils . encodebase64 ( response , bool_ ) ) ; }	The server is challenging the SASL mechanism for the stanza he just sent.Send a response to the server's challenge.
public bytearrayoutputstream tojson ( ) throws ioexception { final bytearrayoutputstream out = new bytearrayoutputstream ( ) ; mapper . writevalue ( out , this ) ; return out ; }	Create a JSON representation of the GoodwillSchemaField.
@ override public void run ( ) { while ( ! stop ) { eventmodel event ; try { event = blockingqueuehandling ( ) ;	main method for outputPlugin, runs the data-conversion and output-rendererit will instruct the outputManager to let the outputExtensions generate the data.
public void handleevent ( event event ) { string topic = event . gettopic ( ) ; logger . debug ( str_ , event , handlers ) ; collection < indexinghandler > contentindexhandler = handlers . get ( topic ) ; if ( contentindexhandler != null && contentindexhandler . size ( ) > num_ ) { try { int ttl = utils . toint ( event . getproperty ( topicindexer . ttl ) , integer . max_value ) ; for ( indexinghandler indexinghandler : contentindexhandler ) { if ( indexinghandler instanceof qosindexhandler ) { ttl = math . min ( ttl , utils . defaultmax ( ( ( qosindexhandler ) indexinghandler ) . getttl ( event ) ) ) ; } } queuemanager q = null ;	Handles an event from OSGi and places it in the appropriate queue.
protected void joinall ( ) throws interruptedexception { if ( queues != null ) { for ( queuemanager q : queues ) { q . getqueuedispatcher ( ) . join ( ) ; } } }	used only for testing.
public void setproperty ( string name , object value ) { if ( ! readonly && ! filter_properties . contains ( name ) ) { object cv = authorizablemap . get ( name ) ; if ( value == null ) { if ( cv != null && ! ( cv instanceof removeproperty ) ) { modifiedmap . put ( name , new removeproperty ( ) ) ; } } else if ( ! value . equals ( cv ) ) { modifiedmap . put ( name , value ) ; } else if ( modifiedmap . containskey ( name ) && ! value . equals ( modifiedmap . get ( name ) ) ) { modifiedmap . put ( name , value ) ; } } }	Set a property. The property will only be set if writable. If the property or this athorizable is read only, nothing will happen.
public void removeproperty ( string key ) { if ( ! readonly && ( authorizablemap . containskey ( key ) || modifiedmap . containskey ( key ) ) ) { modifiedmap . put ( key , new removeproperty ( ) ) ; } }	remove the property.
public void addprincipal ( string principal ) { if ( ! readonly && ! principals . contains ( principal ) ) { principals . add ( principal ) ; principalsmodified = bool_ ; } }	add a principal to this authorizable.
public void removeprincipal ( string principal ) { if ( ! readonly && principals . contains ( principal ) ) { principals . remove ( principal ) ; principalsmodified = bool_ ; } }	remove a principal from this authorizable.
public void rootwindowclosing ( windowevent evt ) { connection . removepacketlistener ( listener ) ; ( ( observablereader ) reader ) . removereaderlistener ( readerlistener ) ; ( ( observablewriter ) writer ) . removewriterlistener ( writerlistener ) ; }	Notification that the root window is closing.
@ suppresswarnings ( str_ ) public void userencountered ( ) { list < string > descriptors = new arraylist < > ( ) ; descriptors . add ( commonevents . descriptors . not_interrupt ) ; boolean known = ! fireunknownifnotpresent || present ; boolean firstpresent = ( ! strict && ! present ) || ( strict && ! strictpresent ) ; long lastseen = this . lastseen . until ( localdatetime . now ( ) , chronounit . seconds ) ; optional < event > presenceevent = identificationmanagerm . getinstance ( ) . getidentification ( this ) . flatmap ( id -> presenceevent . createpresenceevent ( id , strict , known , firstpresent , descriptors , lastseen ) ) . map ( event -> event . addeventlifecyclelistener ( eventlifecycle . approved , lifecycle -> { if ( known ) { this . lastseen = localdatetime . now ( ) ; if ( strict ) this . strictpresent = bool_ ; present = bool_ ; } } ) ) ; if ( ! presenceevent . ispresent ( ) ) { error ( str_ ) ; } else { fire ( presenceevent . get ( ) , num_ ) ; } }	call this method when you have encountered the user.
@ override public void eventfired ( eventmodel event ) { if ( event . containsdescriptor ( leavingevent . id ) || event . containsdescriptor ( presenceevent . id ) ) { if ( event . containsdescriptor ( leavingevent . id ) ) { if ( event . containsdescriptor ( leavingevent . general_descriptor ) ) { present = bool_ ; strictpresent = bool_ ; } else if ( event . containsdescriptor ( leavingevent . strict_descriptor ) ) { nonstrictavailable ( ) . thenaccept ( available -> { if ( ! available ) present = bool_ ; strictpresent = bool_ ; } ) ; } } else { present = bool_ ; if ( event . containsdescriptor ( presenceevent . strict_descriptor ) ) strictpresent = bool_ ; } if ( event . containsdescriptor ( presenceevent . strict_descriptor ) ) lastseen = localdatetime . now ( ) ; } }	Invoked when an activator-event occurs.
public static boolean ispermanent ( resourcemodel resourcemodel ) { object resource = resourcemodel . getresource ( ) ; try { return ( boolean ) resource ; } catch ( classcastexception e ) { return bool_ ; } }	returns true if the resource is true, otherwise returns false.
public void setname ( string name ) { synchronized ( entries ) { for ( rosterentry entry : entries ) { roster packet = new roster ( ) ; packet . settype ( iq . type . set ) ; list < string > groupnames = new linkedlist < string > ( entry . getgroupnames ( ) ) ; groupnames . remove ( this . name ) ; groupnames . add ( name ) ; packet . additem ( new jid ( entry . getuser ( ) ) , entry . getname ( ) , entry . getask ( ) , entry . getsubscription ( ) , groupnames ) ; connection . sendpacket ( packet ) ; } } }	Sets the name of the group.
public boolean containskey ( object key ) { int hashcode = hash ( ( key == null ) ? null : key ) ; hashentry entry = data [ hashindex ( hashcode , data . length ) ] ;	Checks whether the map contains the specified key.
public boolean containsvalue ( object value ) { if ( value == null ) { for ( int i = num_ , isize = data . length ; i < isize ; i ++ ) { hashentry entry = data [ i ] ; while ( entry != null ) { if ( entry . getvalue ( ) == null ) { return bool_ ; } entry = entry . next ; } } } else { for ( int i = num_ , isize = data . length ; i < isize ; i ++ ) { hashentry entry = data [ i ] ; while ( entry != null ) { if ( isequalvalue ( value , entry . getvalue ( ) ) ) { return bool_ ; } entry = entry . next ; } } } return bool_ ; }	Checks whether the map contains the specified value.
public v put ( k key , v value ) { int hashcode = hash ( ( key == null ) ? null : key ) ; int index = hashindex ( hashcode , data . length ) ; hashentry < k , v > entry = data [ index ] ; while ( entry != null ) { if ( entry . hashcode == hashcode && isequalkey ( key , entry . getkey ( ) ) ) { v oldvalue = entry . getvalue ( ) ; updateentry ( entry , value ) ; return oldvalue ; } entry = entry . next ; } addmapping ( index , hashcode , key , value ) ; return null ; }	Puts a key-value mapping into this map.
public void clear ( ) { modcount ++ ; hashentry [ ] data = this . data ; for ( int i = data . length - num_ ; i >= num_ ; i -- ) { data [ i ] = null ; } size = num_ ; }	Clears the map, resetting the size to zero and nullifying references toavoid garbage collection issues.
protected int hash ( object key ) {	Gets the hash code for the key specified.
protected boolean isequalkey ( object key1 , object key2 ) { return ( key1 == key2 || ( ( key1 != null ) && key1 . equals ( key2 ) ) ) ; }	Compares two keys, in internal converted form, to see if they are equal.This implementation uses the equals method.
protected boolean isequalvalue ( object value1 , object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; }	Compares two values, in external form, to see if they are equal.
protected void ensurecapacity ( int newcapacity ) { int oldcapacity = data . length ; if ( newcapacity <= oldcapacity ) { return ; } if ( size == num_ ) { threshold = calculatethreshold ( newcapacity , loadfactor ) ; data = new hashentry [ newcapacity ] ; } else { hashentry < k , v > oldentries [ ] = data ; hashentry < k , v > newentries [ ] = new hashentry [ newcapacity ] ; modcount ++ ; for ( int i = oldcapacity - num_ ; i >= num_ ; i -- ) { hashentry < k , v > entry = oldentries [ i ] ; if ( entry != null ) { oldentries [ i ] = null ;	Changes the size of the data structure to the capacity proposed.
protected int calculatenewcapacity ( int proposedcapacity ) { int newcapacity = num_ ; if ( proposedcapacity > maximum_capacity ) { newcapacity = maximum_capacity ; } else { while ( newcapacity < proposedcapacity ) { newcapacity <<= num_ ;	Calculates the new capacity of the map.
protected iterator < map . entry < k , v > > createentrysetiterator ( ) { if ( size ( ) == num_ ) { return emptyiterator . instance ; } return new entrysetiterator < k , v > ( this ) ; }	Creates an entry set iterator.
public static void loadfromstream ( string key , map < string , object > output , inputstream binarystream , string type ) throws ioexception { datainputstream dis = new datainputstream ( binarystream ) ; string ckey = dis . readutf ( ) ; if ( ! key . equals ( ckey ) ) { throw new ioexception ( str_ ) ; } readmapfromstream ( output , dis ) ; string cftype = null ; try { cftype = dis . readutf ( ) ; } catch ( ioexception e ) { logger . debug ( str_ ) ; } if ( cftype != null && ! cftype . equals ( type ) ) { throw new ioexception ( str_ + type + str_ + cftype + str_ ) ; } logger . debug ( str_ ) ; dis . close ( ) ; binarystream . close ( ) ; }	Load a Map from binary stream.
@ override public void initaddon ( org . intellimate . izou . system . context context ) { this . context = new context ( context ) ; }	Internal initiation of addOn - fake constructor, comes before prepare.
protected void notifyreconnectionfailed ( exception exception ) { if ( isreconnectionallowed ( ) ) { for ( connectionlistener listener : connection . connectionlisteners ) { listener . reconnectionfailed ( exception ) ; } } }	Fires listeners when a reconnection attempt has failed.
protected void notifyattempttoreconnectin ( int seconds ) { if ( isreconnectionallowed ( ) ) { for ( connectionlistener listener : connection . connectionlisteners ) { listener . reconnectingin ( seconds ) ; } } }	Fires listeners when The Connection will retry a reconnection.
