code	desc
private int current depth ( ) { try { integer one based = ( ( integer ) depth field . get ( this ) ) ; return one based - num ; } catch ( illegal access exception e ) { throw new assertion error ( e ) ; } }	returns a 0 - based depth within the object graph of the current object being serialized .
public static int union size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = num , res = num ; for ( ; i < min ; i ++ ) { res += long . bit count ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res += long . bit count ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res += long . bit count ( y [ i ] ) ; } return res ; }	compute the union size of two bitsets .
@ override public void closing ok ( ) { list < add user fields . attribute spec > specs = new array list < add user fields . attribute spec > ( ) ; for ( int i = num ; i < m list model . size ( ) ; i ++ ) { add user fields . attribute spec a = ( add user fields . attribute spec ) m list model . element at ( i ) ; specs . add ( a ) ; } if ( m modify l != null ) { m modify l . set modified status ( add user fields customizer . this , bool ) ; } m filter . set attribute specs ( specs ) ; }	actions to perform when the user has closed the dialog with the ok button .
public string to string ( ) { string buffer text = new string buffer ( ) ; if ( ( m class attribute == null ) ) { return str ; } try { text . append ( str ) ; text . append ( str + m kernel . to string ( ) + str ) ; for ( int i = num ; i < m class attribute . num values ( ) ; i ++ ) { for ( int j = i + num ; j < m class attribute . num values ( ) ; j ++ ) { text . append ( str + m class attribute . value ( i ) + str + m class attribute . value ( j ) + str ) ; text . append ( m classifiers [ i ] [ j ] ) ; if ( m fit logistic models ) { text . append ( str ) ; if ( m classifiers [ i ] [ j ] . m logistic == null ) { text . append ( str ) ; } else { text . append ( m classifiers [ i ] [ j ] . m logistic ) ; } } text . append ( str ) ; } } } catch ( exception e ) { return str ; } return text . to string ( ) ; }	prints out the classifier .
public final sector union ( sector that ) { if ( that == null ) return this ; angle min lat = this . min latitude ; angle max lat = this . max latitude ; angle min lon = this . min longitude ; angle max lon = this . max longitude ; if ( that . min latitude . degrees < this . min latitude . degrees ) min lat = that . min latitude ; if ( that . max latitude . degrees > this . max latitude . degrees ) max lat = that . max latitude ; if ( that . min longitude . degrees < this . min longitude . degrees ) min lon = that . min longitude ; if ( that . max longitude . degrees > this . max longitude . degrees ) max lon = that . max longitude ; return new sector ( min lat , max lat , min lon , max lon ) ; }	returns a new sector whose angles are the extremes of the this sector and another.
private static boolean is double equal ( double value , double value to compare ) { return ( math . abs ( value - value to compare ) < num ) ; }	checks if is double values are equal .
public void test int value pos ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; int result = - num ; assert true ( str , a number . int value ( ) == result ) ; }	integer value of a positive bigdecimal.
private void walk ( file directory , int depth , collection < t > results ) throws io { check if cancelled ( directory , depth , results ) ; if ( handle directory ( directory , depth , results ) ) { handle directory start ( directory , depth , results ) ; int child depth = depth + num ; if ( depth limit < num || child depth <= depth limit ) { check if cancelled ( directory , depth , results ) ; file [ ] child files = filter == null ? directory . list files ( ) : directory . list files ( filter ) ; child files = filter directory contents ( directory , depth , child files ) ; if ( child files == null ) { handle restricted ( directory , child depth , results ) ; } else { for ( file child file : child files ) { if ( child file . is directory ( ) ) { walk ( child file , child depth , results ) ; } else { check if cancelled ( child file , child depth , results ) ; handle file ( child file , child depth , results ) ; check if cancelled ( child file , child depth , results ) ; } } } } handle directory end ( directory , depth , results ) ; } check if cancelled ( directory , depth , results ) ; }	main recursive method to examine the directory hierarchy .
public static object [ ] ordinal array ( tuple set tuples , string field ) { return ordinal array ( tuples , field , default literal comparator . get instance ( ) ) ; }	get a sorted array containing all column values for a given tuple iterator and field .
public void test divide exception invalid rm ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; try { a number . divide ( b number , num ) ; fail ( str ) ; } catch ( illegal argument exception e ) { assert equals ( str , str , e . get message ( ) ) ; } }	divide with invalid rounding mode.
@ override public void dataset changed ( dataset change event event ) { super . dataset changed ( event ) ; if ( this . subplots == null ) { return ; } xy dataset = null ; if ( event . get dataset ( ) instanceof xy ) { dataset = ( xy ) event . get dataset ( ) ; } for ( xy subplot : this . subplots ) { if ( subplot . index of ( dataset ) >= num ) { subplot . configure range axes ( ) ; } } }	receives notification of a change to the plot ' s dataset.
public boolean on schedule as library ( config config , config runtime , i scheduler , packing plan packing ) { boolean ret = bool ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . on schedule ( packing ) ; if ( ret ) { ret = scheduler utils . set lib scheduler location ( runtime , scheduler , bool ) ; } else { log . severe ( str ) ; } } finally { scheduler . close ( ) ; } return ret ; }	invoke the onscheduler ( ) in ischeduler directly as a library.
public static boolean is string type ( type t ) { return t . equals ( ref type . v ( str ) ) ; }	returns true if specified type is java.
private void validate sql statement ( string sql , int jdbc statement index ) { assert . is true ( string utils . is not blank ( sql ) , str + jdbc statement index + str ) ; }	validates the given sql statement where its position in the list of statement is the given index.
public static long [ ] values of ( long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = num ; i < array . length ; i ++ ) { dest [ i ] = long . value of ( array [ i ] ) ; } return dest ; }	converts to object array .
@ override public boolean is trace enabled ( ) { return logger . is loggable ( level . finest ) ; }	is this logger instance enabled for the finest level ?.
private static void use missile ( player player ) { stackable item projectiles item = null ; if ( player . get range weapon ( ) != null ) { projectiles item = player . get ammunition ( ) ; } if ( projectiles item == null ) { projectiles item = player . get missile if not holding other weapon ( ) ; } if ( projectiles item != null ) { projectiles item . remove one ( ) ; } }	remove an used up missile from an attacking player .
public tcp matcher ( final network config config ) { super ( config ) ; }	creates a new matcher for running coap over tcp .
private int determine max level rec ( int level , node v ) { int new level = level ; for ( edge e = v . get first out edge ( ) ; e != null ; e = v . get next out edge ( e ) ) { new level = math . max ( new level , determine max level rec ( level , e . get target ( ) ) + num ) ; } return new level ; }	recursively does the work.
protected void request pass code confirmation ( ) { clear boxes ( ) ; m pass code hdr . set text ( r . string . pass code reenter your pass code ) ; m pass code hdr explanation . set visibility ( view . invisible ) ; m confirming pass code = bool ; }	ask to the user for retyping the pass code just entered before saving it as the current pass code .
private void add worker failed ( worker w ) { final reentrant lock main lock = this . main lock ; main lock . lock ( ) ; try { if ( w != null ) workers . remove ( w ) ; decrement worker count ( ) ; try terminate ( ) ; } finally { main lock . unlock ( ) ; } }	rolls back the worker thread creation . - removes worker from workers , if present - decrements worker count - rechecks for termination , in case the existence of this worker was holding up termination.
public void test insert4 ( ) throws sql { database creator . fill simple table1 ( conn ) ; statement . execute ( str + database creator . simple tabl + str + database creator . simple tabl ) ; result set r = statement . execute query ( str + database creator . simple tabl + str + database creator . simple tabl + str ) ; r . next ( ) ; assert equals ( str , num , r . get int ( num ) ) ; r . close ( ) ; }	insertfunctionalitytest # testinsert4 ( ).
private synchronized void put map entry ( string local id , map entry entry ) { if ( ! is local id ( local id ) ) { throw new illegal state exception ( str + local id + str ) ; } json json = new json ( ) ; try { json . put ( str , entry . retain count ) ; if ( entry . object id != null ) { json . put ( str , entry . object id ) ; } } catch ( json je ) { throw new illegal state exception ( str , je ) ; } file file = new file ( disk path , local id ) ; if ( ! disk path . exists ( ) ) { disk path . mkdirs ( ) ; } try { parse file utils . write json ( file , json ) ; } catch ( io e ) { } }	writes one entry to the local id map on disk .
public void end element ( string namespace uri , string local name , string name ) throws org . xml . sax . sax { if ( m in entity ref ) return ; m prefix map . pop namespaces ( m elem context . m current elem depth , null ) ; try { final java . io . writer writer = m writer ; if ( m elem context . m start tag open ) { if ( m tracer != null ) super . fire start elem ( m elem context . m element name ) ; int n attrs = m attributes . get length ( ) ; if ( n attrs > num ) { process attributes ( m writer , n attrs ) ; m attributes . clear ( ) ; } if ( m space before close ) writer . write ( str ) ; else writer . write ( str ) ; } else { if ( m cdata tag open ) close cdata ( ) ; if ( should indent ( ) ) indent ( m elem context . m current elem depth - num ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( name ) ; writer . write ( str ) ; } } catch ( io e ) { throw new sax ( e ) ; } if ( ! m elem context . m start tag open && m do indent ) { m ispreserve = m preserves . is empty ( ) ? bool : m preserves . pop ( ) ; } m isprevtext = bool ; if ( m tracer != null ) super . fire end elem ( name ) ; m elem context = m elem context . m prev ; }	receive notification of the end of an element .
public static void f ( string msg , object ... args ) { if ( ! allow wtf ) return ; stack trace element caller = get caller stack trace element ( ) ; string tag = generate tag ( caller ) ; if ( s level > level fatal ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . wtf ( tag , msg ) ; }	send a fatal error log message.
public void delete leaves ( string name ) { for ( int i = num ; i < leaves . size ( ) ; i ++ ) { catalog tree leaf leaf = leaves . get ( i ) ; if ( name . equals ( leaf . get name ( ) ) ) { leaves . remove ( i ) ; } } }	leaves can be used for many - to - many relations.
public string to string ( ) { final string buffer s = new string buffer ( ) ; final int size = size ( ) ; for ( int i = num ; i < size ; i ++ ) s . append ( get int ( i ) ) ; return s . to string ( ) ; }	returns a string representation of this vector.
protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final bit set generous ) { if ( eoffset == - num ) { eoffset = component . length - num ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return bool ; } } return bool ; }	validate the uri characters within a specific component.
public boolean remove shutdown hook ( thread hook ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check permission ( runtime permission collection . shutdown hooks permission ) ; } if ( hook == null ) throw new null pointer exception ( str ) ; if ( vm > num ) { throw new illegal state exception ( ) ; } synchronized ( hooks list ) { return hooks list . remove ( hook ) ; } }	de - registers a previously - registered virtual - machine shutdown hook .
public boolean bound scroll ( ) { float cur scroll = get stack scroll ( ) ; float new scroll = get bounded stack scroll ( cur scroll ) ; if ( float . compare ( new scroll , cur scroll ) != num ) { set stack scroll ( new scroll ) ; return bool ; } return bool ; }	bounds the current scroll if necessary.
public void wait for volumes to be visible ( cg request ) { scan ( request . get copies ( ) , request . get rsets ( ) ) ; }	scans all sites until all volumes involved in the recoverpoint protection are visible.
protected void start additional services ( final cache cache , final map < string , object > options ) throws exception { }	this method is called immediately following cache creation in the spawned process , but prior to setting the running flag in the status file.
public void update view ( ) { if ( f input element != null && f parent composite != null ) { indicator view state old state = f state map . get ( f input element ) ; boolean reload = f files to reoad . contains ( f input element ) ; if ( reload || old state == null ) { json object json object = droidsafe plugin utilities . parse indicator file ( f input element ) ; if ( json object == null ) return ; f files to reoad . remove ( f input element ) ; f state = new indicator view state ( f input element , json object , get security spec ( ) , old state ) ; f state map . put ( f input element , f state ) ; } else { f state = old state ; } set part name ( f state . indicator type ) ; show page ( page viewer ) ; f tree viewer . set input ( f state . json object ) ; if ( f tree viewer . get sorter ( ) == null ) sort by field ( get sort by field ( ) ) ; } else { set part name ( default part name ) ; } }	update the content of the outline view .
@ override public void paint ( graphics g ) { g . draw image ( image , num , num , this ) ; if ( ! paint called ) { paint called = bool ; synchronized ( this ) { notify all ( ) ; } } }	paints the image on the window .
@ override public boolean connection allowed ( string event name ) { if ( m listenees . contains key ( event name ) ) { return bool ; } return bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
public boolean is prefixed ( ) { return name . index of ( str ) >= num ; }	it returns true if the attribute is prefixed ( used the " : " character ) .
public void release any connection ( connection connection ) throws sql { try { connection . close ( ) ; } catch ( exception ex ) { throw new runtime exception ( ex ) ; } }	release a non - shard - specific connection .
public quick action view add actions ( collection < action > actions ) { check shown ( ) ; m actions . add all ( actions ) ; return this ; }	adds a collection of actions to the quickactionview.
public void add series renderer ( int index , simple series renderer renderer ) { m renderers . add ( index , renderer ) ; }	adds a simple renderer to the multiple renderer .
public static boolean copy stream ( input stream is , output stream os , copy listener listener , int buffer size ) throws io { int current = num ; int total = is . available ( ) ; if ( total <= num ) { total = default image total size ; } final byte [ ] bytes = new byte [ buffer size ] ; int count ; if ( should stop loading ( listener , current , total ) ) return bool ; while ( ( count = is . read ( bytes , num , buffer size ) ) != - num ) { os . write ( bytes , num , count ) ; current += count ; if ( should stop loading ( listener , current , total ) ) return bool ; } os . flush ( ) ; return bool ; }	copies stream , fires progress events by listener , can be interrupted by listener .
private float calc angle ( float value ) { return value / m data . get y ( ) * num ; }	calculates the needed angle for a given value.
public synchronized void return buf ( byte [ ] buf ) { if ( buf == null || buf . length > m size limit ) { return ; } m buffers by last use . add ( buf ) ; int pos = collections . binary search ( m buffers by size , buf , buf comparator ) ; if ( pos < num ) { pos = - pos - num ; } m buffers by size . add ( pos , buf ) ; m current size += buf . length ; trim ( ) ; }	returns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size .
protected < t extends abstract option value < ? , ? > > abstract options ( function < t , t > value filter , abstract options base options , iterable < t > values ) { require non null ( base options , str ) ; require non null ( value filter , str ) ; require non null ( values , str ) ; value map = new identity hash map < > ( base options . value map ) ; put all ( value filter , stream support . stream ( values . spliterator ( ) , bool ) ) ; }	creates a new instance .
public char seq concat ( char seq another ) { return new char seq ( str + another . str ) ; }	append string of the given charseq to this charseq.
@ override protected void do get ( http servlet request req , http servlet response resp ) throws servlet exception , io { resp . set content type ( str ) ; print writer send to client = resp . get writer ( ) ; for ( video v : this . videos ) { send to client . write ( v . get name ( ) + str + v . get url ( ) + str ) ; } }	this method processes all of the http get requests routed to the servlet by the web container.
protected void notify state change ( int old state , int new state ) { m state = new state ; if ( old state != new state ) { fire property change ( str , integer . value of ( old state ) , integer . value of ( new state ) ) ; } }	change the stored state value and do notification , but don ' t change anything in the hardware.
public void test ( ) { assert equals ( str , big integer . value of ( num ) , ecps . get order ( ) ) ; }	test for getorder ( ) method.
private void format and log throwable ( logging level level , color color , string msg , throwable t ) { if ( ! use colors ) { format and log throwable ( level , msg , t ) ; return ; } if ( photon logger . level . id < level . id ) { return ; } local date time date time = local date time . now ( ) ; string formatted = format log line ( level , date time , msg ) ; logging service . log throwable ( date time , t , formatted , color ) ; }	formats and logs a message with a throwable .
public static string construct queue redis key ( string queue name , string shard name , int priority , pin later job state state ) { return string . format ( str , pinlater queue key prefix , shard name , queue name , priority , state . get value ( ) ) ; }	constructs the redis queue sorted set key name given a queue name , shard id and priority .
public static string decode charset ( string s , string charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . get bytes ( ascii charset ) ; return ( new string ( buf , num , buf . length , charset ) ) ; } catch ( unsupported encoding exception uee ) { return s ; } }	decodes the string into specified charset.
public void add restricted domain ( string domain name ) { if ( string utils . is empty ( domain name ) ) { return ; } if ( restricted domains == null ) { restricted domains = new array list < > ( ) ; } restricted domains . add ( domain name ) ; }	adds specified domain name to the list of restricted domains.
stoppable read lock ( read write lock lock , cancel criterion stopper ) { this . lock = lock . read lock ( ) ; this . stopper = stopper ; }	create a new read lock from the given lock.
public void testis auto increment ( ) { try { assert false ( rsmd . is auto increment ( num ) ) ; } catch ( sql e1 ) { fail ( str + e1 . get message ( ) ) ; e1 . print stack trace ( ) ; } try { conn . close ( ) ; rsmd . get schema name ( num ) ; fail ( str ) ; } catch ( sql e ) { } }	tests fail : always returns false , failing statements commented out.
public static void copy ( byte [ ] in , output stream out ) throws io { assert . not null ( in , str ) ; assert . not null ( out , str ) ; out . write ( in ) ; }	copy the contents of the given byte array to the given outputstream.
public boolean is empty ( ) { return items . is empty ( ) ; }	returns true whether this page doesn ' t contain items , returns false if it does .
private static native boolean render frame ( int [ ] pixels , long gif file in ptr , int [ ] meta data ) ;	decodes a frame if needed .
public static boolean is valid nc ( string nc name ) { if ( nc name . length ( ) == num ) return bool ; char ch = nc name . char at ( num ) ; if ( is nc ( ch ) == bool ) return bool ; for ( int i = num ; i < nc name . length ( ) ; i ++ ) { ch = nc name . char at ( i ) ; if ( is nc ( ch ) == bool ) { return bool ; } } return bool ; }	check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 0 recommendation.
public repeated field builder < m , b , i > add message ( m message ) { if ( message == null ) { throw new null pointer exception ( ) ; } ensure mutable message list ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } on changed ( ) ; increment mod counts ( ) ; return this ; }	appends the specified element to the end of this list .
protected void prepare data set ( ) { data set1 = arrays . as list ( new string [ ] { str , str , str } ) ; data set2 = arrays . as list ( new string [ ] { str , str , str } ) ; data set3 = arrays . as list ( new string [ ] { str , str , str , str } ) ; }	prepare the dataset required for running test cases.
private service registrar [ ] build service registrar ( ) { int k = num ; service registrar [ ] proxys = new service registrar [ proxy reg set . size ( ) ] ; iterator iter = proxy reg set . iterator ( ) ; while ( iter . has next ( ) ) { proxy reg reg = ( proxy reg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }	returns array of serviceregistrar created from the proxyregset.
private static boolean check value ( string val ) throws malformed object name exception { if ( val == null ) throw new null pointer exception ( str ) ; final int len = val . length ( ) ; if ( len == num ) return bool ; final char [ ] s = val . to char array ( ) ; final int [ ] result = parse value ( s , num ) ; final int end value = result [ num ] ; final boolean value pattern = result [ num ] == num ; if ( end value < len ) throw new malformed object name exception ( str + s [ end value ] + str ) ; return value pattern ; }	check if the supplied value is a valid value .
private synchronized void rebuild journal ( ) throws io { if ( journal writer != null ) { journal writer . close ( ) ; } writer writer = new buffered writer ( new file writer ( journal file tmp ) , io buffer size ) ; writer . write ( magic ) ; writer . write ( str ) ; writer . write ( version 1 ) ; writer . write ( str ) ; writer . write ( integer . to string ( app version ) ) ; writer . write ( str ) ; writer . write ( integer . to string ( value count ) ) ; writer . write ( str ) ; writer . write ( str ) ; for ( entry entry : lru entries . values ( ) ) { if ( entry . current editor != null ) { writer . write ( dirty + str + entry . key + str ) ; } else { writer . write ( clean + str + entry . key + entry . get lengths ( ) + str ) ; } } writer . close ( ) ; journal file tmp . rename to ( journal file ) ; journal writer = new buffered writer ( new file writer ( journal file , bool ) , io buffer size ) ; }	creates a new journal that omits redundant information.
public void remove ( ) throws recurrence info exception { list < recurrence rule > rules list = new array list < recurrence rule > ( ) ; rules list . add all ( r rules list ) ; rules list . add all ( e rules list ) ; try { for ( recurrence rule rule : rules list ) rule . remove ( ) ; info . remove ( ) ; } catch ( recurrence rule exception rre ) { throw new recurrence info exception ( rre . get message ( ) , rre ) ; } catch ( generic entity exception gee ) { throw new recurrence info exception ( gee . get message ( ) , gee ) ; } }	removes the recurrence from persistant store .
public void add nodes in doc order ( dtm iterator , x support ) { if ( ! m mutable ) throw new runtime exception ( xsl . create xpath ( xpath . er nodesetdtm not mutable , null ) ) ; int node ; while ( dtm . null != ( node = iterator . next node ( ) ) ) { add node in doc order ( node , support ) ; } }	copy nodelist members into this nodelist , adding in document order.
protected boolean need to refetch data ( ) { long now = system . current time millis ( ) ; long last = last data fetch time ; if ( ( last + fetch interval millis ) < now ) { last data fetch time = now ; return bool ; } return bool ; }	fetches data if it hasn ' t been fetched in a while .
@ override public document type create document type ( string qualified name , string public id , string system id ) { check q ( qualified name ) ; return new document type impl ( null , qualified name , public id , system id ) ; }	introduced in dom level 2.
public byte [ ] to bytes ( ) { try { byte array output stream out = new byte array output stream ( ) ; field . store ( out , null ) ; return out . to byte array ( ) ; } catch ( io e ) { throw new illegal state exception ( e ) ; } }	serializes this nested object into byte [ ].
@ suppress warnings ( str ) public static < e extends enum < ? extends style . has css name > > e from style name ( final string style name , final class < e > enum class , final e default value ) { if ( style name == null || enum class == null ) { return default value ; } for ( final enum < ? extends style . has css name > constant : enum class . get enum constants ( ) ) { final style . has css name an enum = ( style . has css name ) constant ; final string css class = an enum . get css name ( ) ; if ( css class != null && style helper . contains style ( style name , css class ) ) { return ( e ) an enum ; } } return default value ; }	returns first enum constant found in at space - separated list of style names .
@ hle @ hle ( nid = num , version = num , check inside interrupt = bool ) public int sce mpeg next avc rp au ( @ check argument ( str ) int mpeg , int stream uid ) { if ( ! stream map . contains key ( stream uid ) ) { log . warn ( string . format ( str , stream uid ) ) ; return - num ; } int result = hle mpeg get avc au ( null ) ; if ( result != num ) { if ( log . is debug enabled ( ) ) { log . debug ( string . format ( str , result ) ) ; } return result ; } video frame count ++ ; started mpeg = bool ; return num ; }	scempegnextavcrpau - skip one video frame.
private map < uri , export mask > create export mask map ( set < uri > placed masks ) { map < uri , export mask > export mask map = new hash map < > ( ) ; iterator < export mask > export mask iterator = db client . query iterative objects ( export mask . class , placed masks , bool ) ; while ( export mask iterator . has next ( ) ) { export mask export mask = export mask iterator . next ( ) ; export mask map . put ( export mask . get id ( ) , export mask ) ; } return export mask map ; }	given a set of exportmask uris , return a map of exportmask uri to exportmask object.
public immutable array2 < k > insert ( int index , k obj ) { int len = length + num ; int new len = len ; boolean extendable ; if ( index == len - num ) { atomic boolean x = can extend ; if ( x != null ) { can extend = null ; if ( array . length > index && x . get and set ( bool ) ) { array [ index ] = obj ; return new immutable array2 < k > ( array , len , bool ) ; } } extendable = bool ; new len = len + num ; } else { extendable = bool ; } @ suppress warnings ( str ) k [ ] a2 = ( k [ ] ) new object [ new len ] ; data utils . copy with gap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new immutable array2 < k > ( a2 , len , extendable ) ; }	insert an entry at this index .
public void write no scale ( image c , component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get width ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr first ) { page . draw image ( c , x , y , c . get width ( null ) , c . get height ( null ) , null ) ; } }	write a graphic to the printout.
public void put document in cache ( int n , source source ) { int cached node = get node ( source ) ; if ( dtm . null != cached node ) { if ( ! ( cached node == n ) ) throw new runtime exception ( str + str + source . get system id ( ) ) ; return ; } if ( null != source . get system id ( ) ) { m source tree . add element ( new source tree ( n , source . get system id ( ) ) ) ; } }	put the source tree root node in the document cache.
private void update progress ( string progress label , int progress ) { if ( my host != null && ( ( progress != previous progress ) || ( ! progress label . equals ( previous progress label ) ) ) ) { my host . update progress ( progress label , progress ) ; } previous progress = progress ; previous progress label = progress label ; }	used to communicate a progress update between a plugin tool and the main whitebox user interface .
public static void copy ( input stream is , resource out , boolean close is ) throws io { output stream os = null ; try { os = to buffered output stream ( out . get output stream ( ) ) ; } catch ( io ioe ) { io . close el ( os ) ; throw ioe ; } copy ( is , os , close is , bool ) ; }	copy a input resource to a output resource.
public string fade audio ( string path , string type , double fade in length , double stop time , double fade out length ) throws io { final list < string > curves = arrays . as list ( new string [ ] { str , str , str , str , str } ) ; if ( ! curves . contains ( type ) ) { throw new runtime exception ( str + type ) ; } file file = new file ( path ) ; string out file = file . get canonical path ( ) + str ; array list < string > cmd = new array list < string > ( ) ; cmd . add ( sox bin ) ; cmd . add ( path ) ; cmd . add ( out file ) ; cmd . add ( str ) ; cmd . add ( type ) ; cmd . add ( fade in length + str ) ; if ( stop time != - num ) cmd . add ( stop time + str ) ; if ( fade out length != - num ) cmd . add ( fade out length + str ) ; try { int rc = exec sox ( cmd , callback ) ; if ( rc != num ) { out file = null ; } } catch ( io e ) { e . print stack trace ( ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } return out file ; }	fade audio file sox < path > outfile fade < type > < fadeinlength > < stoptime > < fadeoutlength >.
@ override public void draw ( canvas canvas ) { super . draw ( canvas ) ; if ( m edge glow top != null ) { final int scroll x = get scroll x ( ) ; if ( ! m edge glow top . is finished ( ) ) { final int restore count = canvas . save ( ) ; final int top padding = m list padding . top + m glow padding top ; final int bottom padding = m list padding . bottom + m glow padding bottom ; final int height = get height ( ) - top padding - bottom padding ; int edge x = math . min ( num , scroll x + m first position distance guess ) ; canvas . rotate ( - num ) ; canvas . translate ( - get height ( ) + top padding , edge x ) ; m edge glow top . set size ( height , height ) ; if ( m edge glow top . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore to count ( restore count ) ; } if ( ! m edge glow bottom . is finished ( ) ) { final int restore count = canvas . save ( ) ; final int top padding = m list padding . left + m glow padding top ; final int bottom padding = m list padding . right + m glow padding bottom ; final int height = get height ( ) - top padding - bottom padding ; final int width = get width ( ) ; int edge x = math . max ( width , scroll x + m last position distance guess ) ; canvas . rotate ( num ) ; canvas . translate ( - top padding , - edge x ) ; m edge glow bottom . set size ( height , height ) ; if ( m edge glow bottom . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore to count ( restore count ) ; } } }	todo : to be implemented.
public static class properties load properties ( class [ ] cls , properties properties , boolean inherit ) { class properties cp = new class properties ( properties ) ; for ( class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }	for all the classes , loads all properties from each class annotations for the given platform .
public void test case20 ( ) { byte b bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { num , num , num , num , num , num , num } ; int b sign = num ; big integer a number = big integer . zero ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add a number to zero.
private static void fix gps ( xmp exif schema ) throws xmp { xmp gps date time = xmp . find child node ( exif schema , str , bool ) ; if ( gps date time == null ) { return ; } try { xmp bin gps ; xmp bin other date ; bin gps = xmp . convert to date ( gps date time . get value ( ) ) ; if ( bin gps . get year ( ) != num || bin gps . get month ( ) != num || bin gps . get day ( ) != num ) { return ; } xmp other date = xmp . find child node ( exif schema , str , bool ) ; if ( other date == null ) { other date = xmp . find child node ( exif schema , str , bool ) ; } bin other date = xmp . convert to date ( other date . get value ( ) ) ; calendar cal = bin gps . get calendar ( ) ; cal . set ( calendar . year , bin other date . get year ( ) ) ; cal . set ( calendar . month , bin other date . get month ( ) ) ; cal . set ( calendar . day of month , bin other date . get day ( ) ) ; bin gps = new xmp ( cal ) ; gps date time . set value ( xmp . convert from date ( bin gps ) ) ; } catch ( xmp e ) { return ; } }	fixes the gps timestamp in exif .
protected boolean cell consumes event type ( cell < ? > cell , string event type ) { set < string > consumed events = cell . get consumed events ( ) ; return consumed events != null && consumed events . contains ( event type ) ; }	check if a cell consumes the specified event type .
public int read ( ) throws io { int b0 = f input stream . read ( ) ; if ( b0 > num ) { throw new io ( localizer . get message ( str , integer . to string ( b0 ) ) ) ; } return b0 ; }	read a single character.
protected void create y axis ( int i ) { log . e ( str , i + str ) ; float ver height = ( ( graphheight / label size ) * i ) + border ; if ( i == largest value set . size ( ) - num ) canvas . draw line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw line ( horstart , ver height , border , ver height , paint ) ; paint . set color ( color . black ) ; int y labels = ( int ) size - num - i ; string y labels = string . format ( str , y labels * y axis ratio ) ; paint . set text align ( paint . align . right ) ; canvas . draw text ( y labels , horstart - num , ver height - num , paint ) ; paint . set text align ( paint . align . left ) ; }	this function is used to plot the y axis and its breakdown with value . uses drawline ( ) method to create the y axis and lines to show breakdown of y axis and drawtext ( ) method to plot labels related with breakdowns.
public long max ( ) { return delta max . get ( ) ; }	get running - maximum time - delta , in nanoseconds .
public void print ( file file ) throws io { check exec ( ) ; security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check print job access ( ) ; } check action support ( action . print ) ; check file validation ( file ) ; peer . print ( file ) ; }	prints a file with the native desktop printing facility , using the associated application ' s print command .
public void extend ( rule grounding other ) { if ( other . is failed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . get alternatives ( ) ) ; }	extends the existing groundings with the alternative groundings.
@ override public string expect ( pattern pattern ) { final string token = read ( pattern ) ; if ( token == null ) { throw new parser exception ( str + pattern . pattern ( ) + str + document ) ; } return token ; }	this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor.
public void test get table types order ( ) throws exception { database meta data dmd = con . get meta data ( ) ; result set rs = dmd . get table types ( ) ; string previous type = str ; while ( rs . next ( ) ) { string type = rs . get string ( num ) ; assert true ( type . compare to ( previous type ) >= num ) ; previous type = type ; } rs . close ( ) ; }	test for bug [ 974036 ] bug in 0 . 8rc1 databasemetadata method gettabletypes ( ).
private file channel update cache ( string file path ) { file channel file channel = file name and stream cache . get ( file path ) ; try { if ( null == file channel ) { file input stream stream = new file input stream ( file path ) ; file channel = stream . get channel ( ) ; file name and stream cache . put ( file path , file channel ) ; } } catch ( io e ) { logger . error ( e , e . get message ( ) ) ; } return file channel ; }	this method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache , other wise get from cache.
public void remove swipe listener ( swipe listener listener ) { if ( m listeners == null ) { return ; } m listeners . remove ( listener ) ; }	removes a listener from the set of listeners.
private static string descriptor for field signature ( string signature ) { return signature . replace ( str , str ) ; }	returns what the serialization specification calls " descriptor " given a field signature .
public void add parameters ( final name value pair [ ] parameters ) { log . trace ( str ) ; if ( parameters == null ) { log . warn ( str ) ; } else { super . clear request body ( ) ; for ( int i = num ; i < parameters . length ; i ++ ) { params . add ( parameters [ i ] ) ; } } }	adds an array of parameters to be used in the post request body.
@ pure public atom annotation interface to annotation class ( ) { byte [ ] annotation class name tmp = new byte [ val . length + num ] ; system . arraycopy ( val , num , annotation class name tmp , num , val . length - num ) ; annotation class name tmp [ val . length - num ] = str ; annotation class name tmp [ val . length ] = str ; annotation class name tmp [ val . length + num ] = str ; return atom . find or create utf8 atom ( annotation class name tmp ) ; }	creates an annotation name from a class name.
public boolean resource support ar ( integer id ) { if ( id == null ) { return bool ; } return resource support ar ( id . int value ( ) ) ; }	checks whether a given resource id supports advanced reservations or not .
public static map < string , object > create electronic text ( dispatch context dctx , map < string , ? extends object > context ) { map < string , object > result = create electronic text method ( dctx , context ) ; return result ; }	a service wrapper for the createelectronictextmethod method.
public pattern guard expr ( string namespace , string name , expression [ ] parameters , pattern expr guarded ) { this ( namespace , name , arrays . as list ( parameters ) , guarded ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
public static int intersect line line ( d a , d b , d intersect ) { double a1x = a . get x1 ( ) , a1y = a . get y1 ( ) ; double a2x = a . get x2 ( ) , a2y = a . get y2 ( ) ; double b1x = b . get x1 ( ) , b1y = b . get y1 ( ) ; double b2x = b . get x2 ( ) , b2y = b . get y2 ( ) ; return intersect line line ( a1x , a1y , a2x , a2y , b1x , b1y , b2x , b2y , intersect ) ; }	compute the intersection of two line segments .
public static set update and get removable o ( set orig set , set remove o ) { set return o = remove o ; if ( remove o != null && ! remove o . is empty ( ) ) { return o = new hash set ( ) ; iterator itr1 = orig set . iterator ( ) ; while ( itr1 . has next ( ) ) { string orig oc = ( string ) itr1 . next ( ) ; iterator itr2 = remove o . iterator ( ) ; while ( itr2 . has next ( ) ) { string remove oc = ( string ) itr2 . next ( ) ; if ( orig oc . equals ignore case ( remove oc ) ) { return o . add ( orig oc ) ; break ; } } } orig set . remove all ( return o ) ; } return return o ; }	method which removes the specified object class from original set and returns the set of object classes that were removed .
public static int unix timestamp ( ) { return ( int ) ( system . current time millis ( ) / num ) ; }	get the seconds since 1970 - 01 - 01 00 : 00 : 00 utc.
public boolean is pdf ( ) { string key = get summary ( ) ; return key != null && key . length ( ) > num ; }	is there a pdf license.
protected void draw grid background ( canvas c ) { if ( m draw grid background ) { c . draw rect ( m view port handler . get content rect ( ) , m grid background paint ) ; } if ( m draw borders ) { c . draw rect ( m view port handler . get content rect ( ) , m border paint ) ; } }	draws the grid background.
public zip stream impl open read impl ( path impl path ) throws io { string path name = path . get path ( ) ; return open read impl ( path name ) ; }	opens a stream to an entry in the jar .
private static char [ ] zz unpack c ( string packed ) { char [ ] map = new char [ num ] ; int i = num ; int j = num ; while ( i < num ) { int count = packed . char at ( i ++ ) ; char value = packed . char at ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > num ) ; } return map ; }	unpacks the compressed character translation table .
@ override public void on tmp files copied ( result code result ) { dismiss loading dialog ( ) ; finish ( ) ; }	process the result of copyanduploadcontenturistask.
static work queue common submitter queue ( ) { fork join pool p ; work queue [ ] ws ; int m ; submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = common pool ) != null && ( ws = p . work queues ) != null && ( m = ws . length - num ) >= num ) ? ws [ m & z . seed & sqmask ] : null ; }	returns common pool queue for a thread that has submitted at least one task .
private boolean is field package private ( element attribute ) { set < modifier > modifiers = attribute . get modifiers ( ) ; return ! modifiers . contains ( public ) && ! modifiers . contains ( protected ) && ! modifiers . contains ( private ) ; }	checks if the given field has package - private visibility.
public void test divide round half up pos ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round half up ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is positive ; distance = - 1.
public static string convert codes ( string string ) { if ( string == null ) return string ; int current = num ; char [ ] cs = string . to char array ( ) ; string builder sb = new string builder ( ) ; for ( char c : cs ) { if ( current <= cs . length && c == str ) { char tc = character . to lower case ( cs [ current + num ] ) ; if ( tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str || tc == str ) { sb . append ( str ) ; } else { sb . append ( c ) ; } } else { sb . append ( c ) ; } current ++ ; } return sb . to string ( ) ; }	converts all color and format codes.
private void load text ( input stream is ) { buffered reader reader ; string line ; unit list = new array list ( ) ; unit types list = new array list ( ) ; if ( is == null ) { throw new error ( str ) ; } reader = new buffered reader ( new input stream reader ( is ) ) ; try { line = reader . read line ( ) ; line count ++ ; while ( line != null ) { if ( ! line . starts with ( str ) ) { parse and add ( line , reader ) ; } line = reader . read line ( ) ; } reader . close ( ) ; units = new database cluster unit [ unit list . size ( ) ] ; units = ( database cluster unit [ ] ) unit list . to array ( units ) ; unit list = null ; unit types = new unit type [ unit types list . size ( ) ] ; unit types = ( unit type [ ] ) unit types list . to array ( unit types ) ; unit types list = null ; } catch ( io e ) { throw new error ( e . get message ( ) + str + line count ) ; } finally { } }	loads the database from the given input stream .
private float calculate selector radius ( ) { if ( mf selector radius == num ) { int n height = m selected view . get height ( ) ; int n width = m selected view . get width ( ) ; int n larger side = math . max ( n width , n height ) ; mf selector radius = ( ( n larger side ^ num ) / num ) ; } return mf selector radius ; }	calculate selector radius the selector radius can be calculated by a simple math calculation of the larger side .
private int measure width ( int measure spec ) { int result ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = ( int ) m text paint . measure text ( m text ) + get padding left ( ) + get padding right ( ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return result ; }	determines the width of this view.
public void test get put byte array ( ) { final int capacity = num ; final byte array buffer buf = new byte array buffer ( capacity ) ; assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( capacity - num ) ) ; final int pos = num ; for ( int i = num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next int ( capacity - num ) ] ; r . next bytes ( expected ) ; buf . put ( pos , expected ) ; assert equals ( num , bytes util . compare bytes with len and offset ( num , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assert true ( bytes util . bytes equal ( expected , actual ) ) ; } assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( pos + capacity - num ) ) ; }	test bulk get / put byte [ ] methods .
@ override public void on added ( final rp object ) { if ( is user ( object ) ) { if ( object . has ( str ) ) { adminlevel = object . get int ( str ) ; } } }	an object was added .
private string local number ( ) throws parse exception { string builder s = new string builder ( ) ; if ( debug ) dbg enter ( str ) ; try { int lc = num ; while ( lexer . has more chars ( ) ) { char la = lexer . look ahead ( num ) ; if ( la == str || la == str || la == str || la == str || la == str || la == str || lexer . is hex digit ( la ) ) { lexer . consume ( num ) ; s . append ( la ) ; lc ++ ; } else if ( lc > num ) break ; else throw create parse exception ( str + la ) ; } return s . to string ( ) ; } finally { if ( debug ) dbg leave ( str ) ; } }	parser for the local phone # .
public void path values to pixel ( list < path > paths ) { for ( int i = num ; i < paths . size ( ) ; i ++ ) { path value to pixel ( paths . get ( i ) ) ; } }	transforms multiple paths will all matrices .
public static byte [ ] decode ( string s ) { return decode ( s . to char array ( ) ) ; }	decodes a byte array from base64 format.
public static void check state ( boolean expression , object error message ) { if ( exo player library info . assertions enabled && ! expression ) { throw new illegal state exception ( string . value of ( error message ) ) ; } }	ensures the truth of an expression involving the state of the calling instance .
public static void slide in from top animator ( @ non null list < animator > animators , @ non null view view , recycler view recycler view ) { alpha animator ( animators , view , num ) ; animators . add ( object animator . of float ( view , str , - recycler view . get measured height ( ) > > num , num ) ) ; if ( flexible adapter . debug ) log . v ( tag , str ) ; }	item will slide from top of the screen to its natural position .
mutable big integer ( mutable big integer val ) { int len = val . int len ; value = arrays . copy of range ( val . value , val . offset , val . offset + int len ) ; }	construct a new mutablebiginteger with a magnitude equal to the specified mutablebiginteger .
@ request mapping ( value = str ) public void sso binding error ( locale locale , @ path variable ( value = str ) string tenant , http servlet response response ) throws io { logger . info ( str + locale . to string ( ) + str + tenant ) ; sso default tenant error ( locale , response ) ; }	handle request sent with a wrong binding.
public checkpoint manager ( network parameters params , @ nullable input stream input stream ) throws io { this . params = check not null ( params ) ; if ( input stream == null ) input stream = open stream ( params ) ; check not null ( input stream ) ; input stream = new buffered input stream ( input stream ) ; input stream . mark ( num ) ; int first = input stream . read ( ) ; input stream . reset ( ) ; if ( first == binary magic . char at ( num ) ) data hash = read binary ( input stream ) ; else if ( first == textual magic . char at ( num ) ) data hash = read textual ( input stream ) ; else throw new io ( str ) ; }	loads the checkpoints from the given stream.
public index segment index ( i store , checkpoint checkpoint , index metadata metadata , boolean read only ) { super ( store , checkpoint , metadata , read only ) ; }	load from the store .
private string liveness ( ) { boolean is closed = bool ; try { if ( is closed ( ) ) { is closed = bool ; } } catch ( sql s ) { is closed = bool ; } if ( is closed ) { return str ; } return str ; }	provides a string representation of whether this connection is closed or not.
private static void insert value ( final map < string , list < string > > params map , final string param val , final string parameter name ) { if ( param val != null ) { list < string > list = new array list < > ( ) ; list . add ( param val ) ; params map . put ( parameter name , list ) ; } }	puts the given parameter value into a new list object then adds it to the map .
public dimension minimum layout size ( container target ) { dimension size ; synchronized ( this ) { check container ( target ) ; check requests ( ) ; size = new dimension ( x total . minimum , y total . minimum ) ; } insets insets = target . get insets ( ) ; size . width = ( int ) math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , integer . max value ) ; size . height = ( int ) math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , integer . max value ) ; return size ; }	returns the minimum dimensions needed to lay out the components contained in the specified target container .
public boolean select ( int position ) { view v = m all list . get ( position ) ; if ( m multi choice adapter != null ) { perform vibrate ( ) ; perform select ( v , position , bool ) ; return bool ; } return bool ; }	select a view from position in the adapter.
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
@ override public void ignorable whitespace ( xml text , augmentations augs ) throws xni { if ( ! f include ignorable whitespace || f filter reject ) { return ; } if ( ! f defer node expansion ) { node child = f current node . get last child ( ) ; if ( child != null && child . get node type ( ) == node . text node ) { text text node = ( text ) child ; text node . append data ( text . to string ( ) ) ; } else { text text node = f document . create text node ( text . to string ( ) ) ; if ( f document impl != null ) { text impl text node impl = ( text impl ) text node ; text node impl . set ignorable whitespace ( bool ) ; } f current node . append child ( text node ) ; } } else { int txt = f deferred document impl . create deferred text node ( text . to string ( ) , bool ) ; f deferred document impl . append child ( f current node index , txt ) ; } }	ignorable whitespace . for this method to be called , the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable . for example , the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model .
private static final void wait for editor to be active ( i internal file editor , i page ) { long start = system . current time millis ( ) ; long end = start ; do { end = system . current time millis ( ) ; } while ( page . get active editor ( ) != internal file editor && ( end - start ) < num ) ; if ( page . get active editor ( ) != internal file editor ) logger . warn ( str ) ; }	get editor for provided file , returns once editor is active or after timeout.
private solution largest objective value ( int objective , population population ) { solution largest = null ; double value = double . negative infinity ; for ( solution solution : population ) { if ( solution . get objective ( objective ) > value ) { largest = solution ; value = solution . get objective ( objective ) ; } } return largest ; }	returns the solution with the largest objective value for the given objective .
public static int convert latm to y ( int latm ) { long v = math . round ( ( mercator . max y - mercator . lat2y ( latm / latlon to latlonm ) ) * max ap units / ( mercator . max y * num ) ) ; if ( v > max ap units ) return max ap units ; if ( v < num ) return - num ; return ( int ) v ; }	returns the y position based on latitude.
public void register callback handler ( sms change listener ) throws sms { object listener = change listener ; if ( ! notification initialized ) { string notification flag = system properties . get ( notification property , str ) ; if ( notification flag . equals ignore case ( str ) ) { try { url url = webtop naming . get notification url ( ) ; pll . add notification handler ( jaxrpc . sms service , new sms ( ) ) ; client . send ( str , url . to string ( ) , null , null ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + url ) ; } } catch ( exception e ) { if ( debug . warning enabled ( ) ) { debug . warning ( str + str + e . get message ( ) + str ) ; } start polling thread if enabled ( get cache polling interval ( ) ) ; } } else { start polling thread if enabled ( get cache polling interval ( ) ) ; } notification initialized = bool ; } }	registration for event change notifications . only smsnotificationmanager would be calling this method to register itself.
public static ns parse ( input stream in ) throws parse exception , io { byte [ ] buf = property list parser . read all ( in ) ; in . close ( ) ; return parse ( buf ) ; }	parses an ascii property list from an input stream .
protected double current score function ( ) { double score = num ; for ( int i = num ; i < this . values [ this . current var1 ] . length ; i ++ ) { for ( int j = num ; j < this . values [ this . current var2 ] . length ; j ++ ) { score -= this . current counts [ this . current var1 ] [ this . current var2 ] [ i ] [ j ] * math . log ( this . current pi [ i ] [ j ] ) ; } } return score ; }	function to be minimized : - loglikelihood.
public grammaticality estimator ( set file names , int i min char , int i max char , int i char window , int i min word , int i max word , int i word window ) { i min char n = i min char ; i max char n = i max char ; i min word n = i min word ; i max word n = i max word ; i word dist = i word window ; i char dist = i char window ; distro docs = new tree map < integer , distribution document > ( ) ; distro word docs = new tree map < integer , distribution word document > ( ) ; string buffer sb = new string buffer ( ) ; iterator i texts = file names . iterator ( ) ; while ( i texts . has next ( ) ) { string s file = ( string ) i texts . next ( ) ; try { buffered reader bf = new buffered reader ( new file reader ( s file ) ) ; string s tmp ; while ( ( s tmp = bf . read line ( ) ) != null ) sb . append ( s tmp ) ; bf . close ( ) ; } catch ( file not found exception ex ) { ex . print stack trace ( system . err ) ; } catch ( io ex ) { ex . print stack trace ( system . err ) ; } sb . append ( ( char ) num ) ; } full text data string = sb . to string ( ) ; for ( int i cnt = i min char n ; i cnt <= i max char n ; i cnt ++ ) { distro docs . put ( i cnt , new distribution document ( i char dist , i cnt ) ) ; } for ( int i cnt = i min word n ; i cnt <= i max word n ; i cnt ++ ) { distro word docs . put ( i cnt , new distribution word document ( i word dist , i cnt ) ) ; } }	creates a new instance of grammaticalityestimator , using a given set of documents for training .
private int check zone link ( spannable string builder out , string in , int start ) { int pos = start + num ; string builder temp = new string builder ( ) ; string target string = in . substring ( pos , math . min ( in . length ( ) , pos + num ) ) ; boolean prev is dash = bool ; for ( int i = num ; i < target string . length ( ) ; i ++ ) { char c = target string . char at ( i ) ; if ( ( c >= str && c <= str ) || ( c >= str && c <= str ) ) { temp . append ( c ) ; prev is dash = bool ; } else if ( c == str ) { if ( i == num ) { return - num ; } if ( prev is dash ) { temp . delete char at ( temp . length ( ) - num ) ; break ; } temp . append ( c ) ; prev is dash = bool ; } else { if ( prev is dash ) { temp . delete char at ( temp . length ( ) - num ) ; } break ; } } string zone = temp . to string ( ) ; if ( zone . length ( ) < num || zone . equals ignore case ( str ) ) { return - num ; } out . append ( zone ) ; return pos + zone . length ( ) - num ; }	change this should review zone . java.
public static void check valid ( double [ ] x ) { for ( double v : x ) { if ( double . is na n ( v ) ) { throw new runtime exception ( str + v ) ; } } }	loop and ensure all elements are non - infiite and non - nan , throws an exception if one is.
protected void process connection event ( connection event event ) { for ( enumeration < connection listener > e = connection listeners . elements ( ) ; e . has more elements ( ) ; ) { connection listener l = e . next element ( ) ; switch ( event . get type ( ) ) { case connection event . connected : l . connected ( ( connected event ) event ) ; break ; case connection event . disconnected : l . disconnected ( ( disconnected event ) event ) ; break ; case connection event . packet received : l . packet received ( ( packet received event ) event ) ; break ; } } }	processes game events occurring on this connection by dispatching them to any registered gamelistener objects .
public double percentage ( constant range range ) { sorted set < constant > sorted = values ( ) ; sorted set < constant > contained = new tree set < constant > ( ) ; constant prev = null ; for ( constant pct : sorted ) { if ( range . contains ( pct ) ) contained . add ( pct ) ; else if ( contained . is empty ( ) ) prev = pct ; } if ( contained . size ( ) == num ) return num ; double prev percent = prev == null ? num : pcts . get ( prev ) ; return pcts . get ( contained . last ( ) ) - prev percent ; }	gets the percent of values within the specified value range .
public static void close quiet ( @ nullable closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( io ignored ) { } } }	closes resource without reporting any error .
@ override public void release lucee page context ( page context pc , boolean register ) { if ( pc . get id ( ) < num ) return ; pc . release ( ) ; thread local page context . release ( ) ; running pcs . remove ( integer . value of ( pc . get id ( ) ) ) ; if ( pcs . size ( ) < num && pc . get request timeout exception ( ) == null ) pcs . push ( pc ) ; }	similar to the releasepagecontext method , but take lucee pagecontext as entry.
public void add event listener ( sip new listener ) { event listeners . add ( new listener ) ; }	adds a new event listener to this dialog .
private boolean journal rebuild required ( ) { final int redundant op compact threshold = num ; return redundant op count >= redundant op compact threshold && redundant op count >= lru entries . size ( ) ; }	we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .
private static byte [ ] string to byte array ( string str ) { if ( str == null ) { return null ; } byte [ ] src byte = str . get bytes ( ) ; int src length = src byte . length ; byte [ ] result = new byte [ src length + num ] ; system . arraycopy ( src byte , num , result , num , src length ) ; result [ src length ] = num ; return result ; }	returns this java string as a null - terminated byte array.
public static properties load properties ( class loader class loader , string classpath resource ) { return load properties ( null , classpath resource ) ; }	atomically load the properties file at the given location within the designated class loader .
@ override public boolean equals ( object o ) { if ( o instanceof graph ) { return string . equals ( o . to string ( ) ) ; } return bool ; }	returns true if the object is a graph with the same content .
public final static name value pair parse name value pair ( final string value , header value parser parser ) throws parse exception { if ( value == null ) { throw new illegal argument exception ( str ) ; } if ( parser == null ) parser = save header value parser . default ; char array buffer buffer = new char array buffer ( value . length ( ) ) ; buffer . append ( value ) ; save parser cursor cursor = new save parser cursor ( num , value . length ( ) ) ; return parser . parse name value pair ( buffer , cursor ) ; }	parses a name - value - pair with the given parser .
private void pull event ( ) { final int new scroll value ; final int item dimension ; final float initial motion value , last motion value ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : initial motion value = m initial motion x ; last motion value = m last motion x ; break ; case vertical : default : initial motion value = m initial motion y ; last motion value = m last motion y ; break ; } switch ( m current mode ) { case pull from end : new scroll value = math . round ( math . max ( initial motion value - last motion value , num ) / friction ) ; item dimension = get footer size ( ) ; break ; case pull from start : default : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / friction ) ; item dimension = get header size ( ) ; break ; } set header scroll ( new scroll value ) ; if ( new scroll value != num && ! is refreshing ( ) ) { float scale = math . abs ( new scroll value ) / ( float ) item dimension ; switch ( m current mode ) { case pull from end : m footer layout . on pull ( scale ) ; break ; case pull from start : default : m header layout . on pull ( scale ) ; break ; } if ( m state != state . pull to refresh && item dimension >= math . abs ( new scroll value ) ) { set state ( state . pull to refresh ) ; } else if ( m state == state . pull to refresh && item dimension < math . abs ( new scroll value ) ) { set state ( state . release to refresh ) ; } } }	actions a pull event.
private static mapping object object at ( p loc , mapping object [ ] [ ] map ) { return map [ loc . get line ( ) ] [ loc . get column ( ) ] ; }	returns the mappingobject at the location in map indicated by loc .
public string parse ( file file , json m ) { try { template template = get template ( file ) ; if ( template != null ) { string writer w = new string writer ( ) ; buffered writer writer = new buffered writer ( w ) ; template . merge ( new velocity context ( m ) , writer ) ; writer . flush ( ) ; writer . close ( ) ; return w . to string ( ) ; } } catch ( exception e ) { log . error ( e . get message ( ) , e ) ; } return null ; }	parse the file to string with the json.
private linked list < diff > diff main ( string text1 , string text2 , boolean checklines , long deadline ) { if ( text1 == null || text2 == null ) { throw new illegal argument exception ( str ) ; } linked list < diff > diffs ; if ( text1 . equals ( text2 ) ) { diffs = new linked list < diff > ( ) ; if ( text1 . length ( ) != num ) { diffs . add ( new diff ( operation . equal , text1 ) ) ; } return diffs ; } int commonlength = diff common prefix ( text1 , text2 ) ; string commonprefix = text1 . substring ( num , commonlength ) ; text1 = text1 . substring ( commonlength ) ; text2 = text2 . substring ( commonlength ) ; commonlength = diff common suffix ( text1 , text2 ) ; string commonsuffix = text1 . substring ( text1 . length ( ) - commonlength ) ; text1 = text1 . substring ( num , text1 . length ( ) - commonlength ) ; text2 = text2 . substring ( num , text2 . length ( ) - commonlength ) ; diffs = diff compute ( text1 , text2 , checklines , deadline ) ; if ( commonprefix . length ( ) != num ) { diffs . add first ( new diff ( operation . equal , commonprefix ) ) ; } if ( commonsuffix . length ( ) != num ) { diffs . add last ( new diff ( operation . equal , commonsuffix ) ) ; } diff cleanup merge ( diffs ) ; return diffs ; }	find the differences between two texts.
public repository ( string domain , boolean fair lock ) { lock = new reentrant read write lock ( fair lock ) ; domain tb = new hash map < string , map < string , named object > > ( num ) ; if ( domain != null && domain . length ( ) != num ) this . domain = domain . intern ( ) ; else this . domain = service name . domain ; domain tb . put ( this . domain , new hash map < string , named object > ( ) ) ; }	construct a new repository with the given default domain .
public int count tokens ( ) { int count = num ; boolean in token = bool ; for ( int i = position , length = string . length ( ) ; i < length ; i ++ ) { if ( delimiters . index of ( string . char at ( i ) , num ) >= num ) { if ( return delimiters ) count ++ ; if ( in token ) { count ++ ; in token = bool ; } } else { in token = bool ; } } if ( in token ) count ++ ; return count ; }	returns the number of unprocessed tokens remaining in the string .
public static synchronized void index document ( code index document code index document ) throws io { queue < code index document > queue = new concurrent linked queue < > ( ) ; queue . add ( code index document ) ; index documents ( queue ) ; queue = null ; }	possibly better in ultra low memory environments ? reuses the above method by creating a queue with one element and passes it in .
protected void reset common ( ) throws xni { int count = f common components . size ( ) ; for ( int i = num ; i < count ; i ++ ) { xml c = ( xml ) f common components . get ( i ) ; c . reset ( this ) ; } }	reset all common components before parsing.
protected void handle ( exception exception , string title , string message ) { utils . handle error ( get shell ( ) , exception , title , message ) ; }	shows the given errors to the user .
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; i18n = environment . get i18n ( ) ; bean context child support = new bean context child support ( this ) ; }	handle serialization a little bit better , replacing the i18n and beancontextchildsupport .
private void paint foreground enabled ( d g , int width , int height ) { shape s = decode arrow path ( width , height ) ; g . set paint ( enabled color ) ; g . fill ( s ) ; }	paint the arrow in enabled state .
private static void log throw ( level level , string class name , string method name , string message , object [ ] args , throwable thrown ) { java . util . logging . log record lr = new java . util . logging . log record ( level , message ) ; lr . set logger name ( logger . get name ( ) ) ; lr . set source class name ( class name ) ; lr . set source method name ( method name ) ; lr . set parameters ( args ) ; lr . set thrown ( thrown ) ; logger . log ( lr ) ; }	logs a thrown exception .
public void test to big integer zero ( ) { string a = str ; big integer b number = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; big integer result = a number . to big integer ( ) ; assert true ( str , result . equals ( b number ) ) ; }	convert a small bigdecimal to biginteger.
public void on accuracy changed ( sensor sensor , int accuracy ) { if ( sensor . get type ( ) != sensor . type accelerometer ) { return ; } if ( this . status == accel listener . stopped ) { return ; } this . accuracy = accuracy ; }	called when the accuracy of the sensor has changed .
public boolean allows trailing arguments ( ) { return allows trailing arguments ; }	indicates whether this sub - command will allow unnamed trailing arguments.
@ android only ( str + str ) public void test set max crl math ( ) { crl selector = new crl ( ) ; big integer max crl = new big integer ( str ) ; crl crl = new crl ( max crl ) ; selector . set max crl ( null ) ; assert true ( str , selector . match ( crl ) ) ; selector . set max crl ( max crl ) ; assert true ( str , selector . match ( crl ) ) ; selector . set max crl ( new big integer ( str ) ) ; assert false ( str , selector . match ( crl ) ) ; }	setmaxcrlnumber ( biginteger maxcrl ) method testing.
private void evaluate popup ( mouse event e ) { if ( e . is popup trigger ( ) ) { j menu = create bookmark popup menu ( ) ; if ( menu != null ) { menu . show ( this , e . get x ( ) , e . get y ( ) ) ; } } }	checks if the given mouse event is a popup trigger and creates a new popup menu if necessary .
private boolean remove task ( task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < first pending ) { first pending -- ; for ( int j = threads . size ( ) ; -- j >= num ; ) { task thread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != thread . current thread ( ) ) thread . interrupt ( ) ; break ; } } } return bool ; } } return bool ; }	remove a task if it has index > = min.
public void test half up ( ) { string a = str ; string b = str ; rounding mode rm = rounding mode . half up ; string c = str ; big decimal a number = new big decimal ( new big integer ( a ) ) ; big decimal b number = new big decimal ( new big integer ( b ) ) ; big decimal result = a number . divide ( b number , rm ) ; assert equals ( str , c , result . to string ( ) ) ; }	java . math . bigdecimal # divide ( java . math . bigdecimal , java . math . roundingmode ) divide ( bigdecimal , roundingmode ).
protected void ensure path exists ( string path ) { string [ ] paths = path . split ( str ) ; string buffer spath = new string buffer ( str ) ; for ( string temp : paths ) { if ( string utils . is blank ( temp ) ) { continue ; } spath . append ( temp ) ; ensure exists ( spath . to string ( ) , null , acl , create mode . persistent ) ; spath . append ( str ) ; } }	ensures that the given path exists with no data , the current acl and no flags.
public class < ? > load class ( string name , boolean resolve ) throws class not found exception { int i = name . last index of ( str ) ; if ( i != - num ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check package access ( name . substring ( num , i ) ) ; } } if ( ucp . known to not exist ( name ) ) { class < ? > c = find loaded class ( name ) ; if ( c != null ) { if ( resolve ) { resolve class ( c ) ; } return c ; } throw new class not found exception ( name ) ; } return ( super . load class ( name , resolve ) ) ; }	override loadclass so we can checkpackageaccess .
private int measure short ( int measure spec ) { int result ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = ( int ) ( num * m radius + get padding top ( ) + get padding bottom ( ) + num ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return result ; }	determines the height of this view.
private boolean is list child under clipped ( float x , float y ) { final view list child = find list child under ( x , y ) ; return list child != null && is descendant clipped ( list child ) ; }	this only checks clipping along the bottom edge .
rules ( workspace workspace ) { this . root = workspace . get root ( ) ; this . team hook = workspace . get team hook ( ) ; }	creates a new scheduling rule factory for the given workspace.
public static void write byte array to file ( file file , byte [ ] data , boolean append ) throws io { output stream out = null ; try { out = open output stream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { io . close quietly ( out ) ; } }	writes a byte array to a file creating the file if it does not exist .
public void add ( @ non null t item ) { synchronized ( lock ) { if ( items == null ) { items = new array list < > ( ) ; } items . add ( item ) ; } if ( notify on change ) { notify item inserted ( items . size ( ) ) ; } }	adds the specified item to the end of the list.
private void check pending custom messages ( ) { if ( joining nodes . is empty ( ) && is local node coordinator ( ) ) { tcp discovery custom event message msg ; while ( ( msg = pending custom msgs . poll ( ) ) != null ) { process custom message ( msg ) ; if ( msg . verified ( ) ) msg hist . add ( msg ) ; } } }	checks and flushes custom event messages if no nodes are attempting to join the grid .
private static int determine consecutive digit count ( char sequence msg , int startpos ) { int count = num ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . char at ( idx ) ; while ( is digit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char at ( idx ) ; } } } return count ; }	determines the number of consecutive characters that are encodable using numeric compaction .
protected int parse and add node ( xml resource parser parser , hash map < string , tag parser > tag parser map , array list < long > screen ids ) throws xml pull parser exception , io { if ( tag include . equals ( parser . get name ( ) ) ) { final int res id = get attribute resource value ( parser , attr workspace , num ) ; if ( res id != num ) { return parse layout ( res id , screen ids ) ; } else { return num ; } } m values . clear ( ) ; parse container and screen ( parser , m temp ) ; final long container = m temp [ num ] ; final long screen id = m temp [ num ] ; m values . put ( favorites . container , container ) ; m values . put ( favorites . screen , screen id ) ; m values . put ( favorites . cellx , convert to distance from end ( get attribute value ( parser , attr x ) , m column count ) ) ; m values . put ( favorites . celly , convert to distance from end ( get attribute value ( parser , attr y ) , m row count ) ) ; tag parser tag parser = tag parser map . get ( parser . get name ( ) ) ; if ( tag parser == null ) { if ( logd ) log . d ( tag , str + parser . get name ( ) ) ; return num ; } long new element id = tag parser . parse and add ( parser ) ; if ( new element id >= num ) { if ( ! screen ids . contains ( screen id ) && container == favorites . container desktop ) { screen ids . add ( screen id ) ; } return num ; } return num ; }	parses the current node and returns the number of elements added .
private float calculate scramble image height multiplier ( float multiplier ) { switch ( current puzzle ) { case puzzle utils . type 777 : case puzzle utils . type 666 : case puzzle utils . type 555 : case puzzle utils . type 222 : case puzzle utils . type 444 : case puzzle utils . type 333 : return ( multiplier / num ) * num ; case puzzle utils . type clock : return multiplier / num ; case puzzle utils . type mega : return ( multiplier / num ) ; case puzzle utils . type pyra : return ( float ) ( multiplier / math . sqrt ( num ) ) ; case puzzle utils . type skewb : return ( multiplier / num ) * num ; case puzzle utils . type squar : return multiplier ; } return multiplier ; }	calculates scramble image height multiplier to respect aspect ratio.
public void test numeric scalars ( ) throws exception { object mapper m = new object mapper ( ) ; m . enable default typing ( ) ; assert equals ( str , m . write value as string ( new object [ ] { integer . value of ( num ) } ) ) ; assert equals ( str , m . write value as string ( new object [ ] { long . value of ( num ) } ) ) ; assert equals ( str , m . write value as string ( new object [ ] { double . value of ( num ) } ) ) ; assert equals ( str , m . write value as string ( new object [ ] { float . value of ( num ) } ) ) ; }	unit test to verify that limited number of core types do not include type information , even if declared as object . this is only done for types that json scalar values natively map to : string , integer and boolean ( and nulls never have type information ).
protected void close callbacks except listener ( ) { close cache callback ( get cache loader ( ) ) ; close cache callback ( get cache writer ( ) ) ; close cache callback ( get eviction controller ( ) ) ; }	the listener is not closed until after the afterregiondestroy event.
private static int index of ( object o , object [ ] elements , int index , int fence ) { if ( o == null ) { for ( int i = index ; i < fence ; i ++ ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i < fence ; i ++ ) if ( o . equals ( elements [ i ] ) ) return i ; } return - num ; }	static version of indexof , to allow repeated calls without needing to re - acquire array each time .
private void populate profiles ( final profile list profiles ) { profiles combo box . remove all items ( ) ; for ( profile p : profiles ) { profiles combo box . add item ( p ) ; } final int count = profiles combo box . get item count ( ) ; if ( count != num ) { profiles combo box . set selected index ( count - num ) ; } }	populate the profiles combobox and select the default .
private long check file header ( buffered file data input bfdi ) throws replicator exception , interrupted exception { int magic = num ; short major = num ; short minor = num ; try { bfdi . wait available ( header length , header wait millis ) ; magic = bfdi . read int ( ) ; major = bfdi . read short ( ) ; minor = bfdi . read short ( ) ; base seqno = bfdi . read long ( ) ; } catch ( io e ) { throw new thl ( str + file . get absolute path ( ) , e ) ; } if ( magic != magic number ) throw new thl ( str + file . get absolute path ( ) + str ) ; if ( major != major version ) throw new thl ( str + file . get absolute path ( ) + str ) ; if ( minor != minor version ) logger . warn ( str + file . get absolute path ( ) + str + major + str + minor + str + major version + str + minor version ) ; return base seqno ; }	read the file header and return the log sequence number stored in the file header .
public float real absolute ( ) { return math . abs ( m left ) ; }	absolute value of real component.
public static string map2 oid ( string alg name ) { return alg2 oid map . get ( alg name . to upper case ( locale . us ) ) ; }	returns oid for algname.
@ override public generator < i > construct ( string [ ] args ) { return new uniform generator ( double . value of ( args [ num ] ) ) ; }	provide reflective behavior to construct instance of generator given an array of string arguments .
private boolean yy refill ( ) throws java . io . io { if ( yy start read > num ) { system . arraycopy ( yy buffer , yy start read , yy buffer , num , yy end read - yy start read ) ; yy end read -= yy start read ; yy current pos -= yy start read ; yy marked pos -= yy start read ; yy pushback pos -= yy start read ; yy start read = num ; } if ( yy current pos >= yy buffer . length ) { char new buffer [ ] = new char [ yy current pos * num ] ; system . arraycopy ( yy buffer , num , new buffer , num , yy buffer . length ) ; yy buffer = new buffer ; } int num read = yy reader . read ( yy buffer , yy end read , yy buffer . length - yy end read ) ; if ( num read < num ) { return bool ; } else { yy end read += num read ; return bool ; } }	refills the input buffer .
protected void process mouse event ( mouse event e ) { if ( my inplace component != null && ( mouse event . mouse pressed == e . get id ( ) || mouse event . mouse released == e . get id ( ) ) ) { finish editing ( bool ) ; } super . process mouse event ( e ) ; }	when there is an inplace editor we " listen " all mouse event and finish editing by any mouse_pressed or mouse_released event.
protected void add module ( map < class < ? extends i > , i > module map , collection < i > module list , i module ) { collection < class < ? extends i > > servs = module service map . get ( module ) ; if ( servs != null ) { for ( class < ? extends i > c : servs ) module map . put ( c , module ) ; } module list . add ( module ) ; }	add a module to the set of modules to load and register its services.
protected boolean has all tables ( ) throws couldnt load data exception , invalid database exception { navi logger . info ( str ) ; final int counter = sql . get table count ( get connection ( ) , lists . new array list ( tables ) ) ; if ( counter == num ) { return bool ; } else if ( counter == tables . length ) { return bool ; } else { throw new invalid database exception ( string . format ( str , counter , tables . length ) ) ; } }	makes sure that all required binnavi database tables exist.
public list < string > classify ( list < list < feature > > features ) throws cleartk processing exception { string [ ] [ ] feature string array = to strings ( features ) ; pipe pipe = transducer . get input pipe ( ) ; instance instance = new instance ( feature string array , null , null , null ) ; instance = pipe . instance from ( instance ) ; sequence < ? > data = ( sequence < ? > ) instance . get data ( ) ; sequence < ? > untyped sequence = transducer . transduce ( data ) ; sequence < string > sequence = reflection util . unchecked cast ( untyped sequence ) ; list < string > return values = new array list < string > ( ) ; for ( int i = num ; i < sequence . size ( ) ; i ++ ) { string encoded outcome = sequence . get ( i ) ; return values . add ( outcome encoder . decode ( encoded outcome ) ) ; } return return values ; }	this method classifies several instances at once.
public void on bind header view holder ( recycler view . view holder holder , int position ) { on bind header view holder ( holder , position , collections . empty list ( ) ) ; }	bind header with provided viewholder at specified position.
private void update line list ( ) { if ( horizontal line radiobutton . is selected ( ) ) { set horizontal line selected ( ) ; } else { set vertical line selected ( ) ; } update button states ( ) ; }	updates the displayed list of lines .
public void rectangle ( double x , double y , double half width , double half height ) { if ( half width < num ) throw new illegal argument exception ( str ) ; if ( half height < num ) throw new illegal argument exception ( str ) ; double xs = scale x ( x ) ; double ys = scale y ( y ) ; double ws = factor x ( num * half width ) ; double hs = factor y ( num * half height ) ; if ( ws <= num && hs <= num ) pixel ( x , y ) ; else offscreen . draw ( new d . double ( xs - ws / num , ys - hs / num , ws , hs ) ) ; draw ( ) ; }	draws a rectangle of given half width and half height , centered on ( x , y ) .
protected final void refresh loading views size ( ) { final int maximum pull scroll = ( int ) ( get maximum pull scroll ( ) * num ) ; int p left = get padding left ( ) ; int p top = get padding top ( ) ; int p right = get padding right ( ) ; int p bottom = get padding bottom ( ) ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : if ( m mode . show header loading layout ( ) ) { m header layout . set width ( maximum pull scroll ) ; p left = - maximum pull scroll ; } else { p left = num ; } if ( m mode . show footer loading layout ( ) ) { m footer layout . set width ( maximum pull scroll ) ; p right = - maximum pull scroll ; } else { p right = num ; } break ; case vertical : if ( m mode . show header loading layout ( ) ) { m header layout . set height ( maximum pull scroll ) ; p top = - maximum pull scroll ; } else { p top = num ; } if ( m mode . show footer loading layout ( ) ) { m footer layout . set height ( maximum pull scroll ) ; p bottom = - maximum pull scroll ; } else { p bottom = num ; } break ; } if ( debug ) { log . d ( log tag , string . format ( str , p left , p top , p right , p bottom ) ) ; } set padding ( p left , p top , p right , p bottom ) ; }	re - measure the loading views height , and adjust internal padding as necessary.
public void replace split element ( int a index , fragment a split element ) { splits . set ( a index , a split element ) ; }	replaces a split element with another one.
private void start item list ( string builder result , string root id ) { result . append ( str + str + root id + str ) ; }	called to start an item list .
private static int num initial splits ( long num records ) { final int max splits = num ; final long records per split = num ; return ( int ) math . min ( max splits , num records / records per split + num ) ; }	pick a number of initial splits based on the number of records expected to be processed .
public void mouse clicked ( mouse event e ) { if ( e . get click count ( ) > num ) { system . gc ( ) ; } }	invoked when the mouse has been clicked on a component .
private static string [ ] scan for sources ( final file source dir , final set < string > source includes , final set < string > source excludes ) { final directory scanner ds = new directory scanner ( ) ; ds . set follow symlinks ( bool ) ; ds . set basedir ( source dir ) ; ds . set includes ( source includes . to array ( new string [ source includes . size ( ) ] ) ) ; ds . set excludes ( source excludes . to array ( new string [ source excludes . size ( ) ] ) ) ; ds . add default excludes ( ) ; try { ds . scan ( ) ; } catch ( illegal state exception e ) { return new string [ num ] ; } return ds . get included files ( ) ; }	scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes.
private boolean has next postponed ( ) { return ! postponed routes . is empty ( ) ; }	returns true if there is another postponed route to try .
public boolean has single element ( ) { return m selected widgets . size ( ) == num ; }	check if the selection has a single element.
public igfs path ( uri uri ) { a . not null ( uri , str ) ; path = normalize path ( uri . get path ( ) ) ; }	constructs a path from an uri.
public int to int ( element el , string attribute name ) { return caster . to int value ( el . get attribute ( attribute name ) , integer . min value ) ; }	reads a xml element attribute ans cast it to a int value.
public static string read fully ( reader reader ) throws io { try { string writer writer = new string writer ( ) ; char [ ] buffer = new char [ num ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - num ) { writer . write ( buffer , num , count ) ; } return writer . to string ( ) ; } finally { reader . close ( ) ; } }	returns the remainder of ' reader ' as a string , closing it when done .
public void add getters ( int assigned property number , string property name ) { for ( event type type : known types ) { event property getter getter = type . get getter ( property name ) ; variant property getter row row = all getters . get ( type ) ; if ( row == null ) { synchronized ( this ) { row = new variant property getter row ( type , new event property getter [ assigned property number + num ] ) ; all getters . put ( type , row ) ; } } row . add getter ( assigned property number , getter ) ; } properties . add ( property name ) ; }	adds the getters for a property that is identified by a property number which indexes into array of getters per type .
protected void mark used ( entry entry ) { entry . last used = system . nano time ( ) ; }	marks the specified entry as used by setting its last used time to the current time in nanoseconds .
@ override public string execute ( ) { return success ; }	default : just returns " success ".
private void handle state left ( inet address endpoint , string [ ] pieces ) { assert pieces . length >= num ; collection < token > tokens = get tokens for ( endpoint ) ; if ( logger . is debug enabled ( ) ) logger . debug ( str , endpoint , tokens ) ; excise ( tokens , endpoint , extract expire time ( pieces ) ) ; }	handle node leaving the ring . this will happen when a node is decommissioned.
public static void register ( string algorithm uri , class < ? extends signature algorithm spi > implementing class ) throws algorithm already registered exception , class not found exception , xml { java utils . check register permission ( ) ; if ( log . is loggable ( java . util . logging . level . fine ) ) { log . log ( java . util . logging . level . fine , str + algorithm uri + str + implementing class ) ; } class < ? extends signature algorithm spi > registered class = algorithm hash . get ( algorithm uri ) ; if ( registered class != null ) { object ex args [ ] = { algorithm uri , registered class } ; throw new algorithm already registered exception ( str , ex args ) ; } algorithm hash . put ( algorithm uri , implementing class ) ; }	registers implementing class of the transform algorithm with algorithmuri.
@ suppress warnings ( str ) public key value persistence settings ( file settings file ) { input stream in ; try { in = new file input stream ( settings file ) ; } catch ( io e ) { throw new ignite exception ( str + settings file . get absolute path ( ) , e ) ; } init ( load settings ( in ) ) ; }	constructs ignite cache key / value persistence settings .
public boolean contains word breaking char ( final @ non null char sequence input ) { if ( ! text utils . is empty ( input ) ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { char c = input . char at ( i ) ; if ( is word breaking char ( c ) ) { return bool ; } } } return bool ; }	returns true if the input string contains a word - breaking character .
private void check interior intersections ( ) { for ( iterator i = seg strings . iterator ( ) ; i . has next ( ) ; ) { segment string ss0 = ( segment string ) i . next ( ) ; for ( iterator j = seg strings . iterator ( ) ; j . has next ( ) ; ) { segment string ss1 = ( segment string ) j . next ( ) ; check interior intersections ( ss0 , ss1 ) ; } } }	checks all pairs of segments for intersections at an interior point of a segment.
public synchronized boolean remove element ( object object ) { int index ; if ( ( index = index of ( object , num ) ) == - num ) { return bool ; } remove element at ( index ) ; return bool ; }	removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector.
private < t > unary operator < t > compose ( unary operator < t > before , unary operator < t > after ) { return null ; }	compose two functions together into a single function.
private void add cdc col specs ( array list < column spec > cdc specs , one row change cdc row change data ) { int cdc pos = cdc specs . size ( ) ; if ( cdc columns at front ) cdc pos = num ; column spec spec = cdc row change data . new column spec ( ) ; spec . set index ( cdc pos + num ) ; spec . set name ( str ) ; spec . set type ( java . sql . types . varchar ) ; spec . set length ( num ) ; cdc specs . add ( cdc pos , spec ) ; spec = cdc row change data . new column spec ( ) ; spec . set index ( cdc pos + num + num ) ; spec . set name ( str ) ; spec . set type ( java . sql . types . timestamp ) ; cdc specs . add ( cdc pos + num , spec ) ; spec = cdc row change data . new column spec ( ) ; spec . set index ( cdc pos + num + num ) ; spec . set name ( str ) ; spec . set type ( java . sql . types . bigint ) ; cdc specs . add ( cdc pos + num , spec ) ; }	add cdc column specifications .
public static string convert to java field name ( string name ) { int dot index = name . index of ( str ) ; if ( dot index >= num ) { name = name . substring ( num , dot index ) ; } string [ ] split = name . split ( str ) ; string builder out = new string builder ( ) ; boolean first = bool ; for ( string section : split ) { if ( first ) { first = bool ; out . append ( section ) ; } else { out . append ( string util . capitalize ( section ) ) ; } } return out . to string ( ) ; }	utility method to convert a variable name into java field name .
public static secret keys generate key ( ) throws general security exception { fix prng ( ) ; key generator key gen = key generator . get instance ( cipher ) ; key gen . init ( aes key length bits ) ; secret key confidentiality key = key gen . generate key ( ) ; byte [ ] integrity key bytes = random bytes ( hmac key length bits / num ) ; secret key integrity key = new secret key spec ( integrity key bytes , hmac algorithm ) ; return new secret keys ( confidentiality key , integrity key ) ; }	a function that generates random aes & hmac keys and prints out exceptions but doesn ' t throw them since none should be encountered.
public static void check argument ( boolean expression , @ nullable object error message ) { if ( ! expression ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
protected void execute ( string [ ] sqls , sq db ) { string throw sql = str ; try { if ( sqls != null ) { for ( string sql : sqls ) { throw sql = sql ; db . exec sql ( base utility . change case ( sql ) ) ; } } } catch ( sql e ) { throw new database generate exception ( database generate exception . sql error + throw sql ) ; } }	use the parameter sqlitedatabase to execute the passing sqls.
private synchronized void rebuild journal ( ) throws io { if ( journal writer != null ) { journal writer . close ( ) ; } writer writer = new buffered writer ( new output stream writer ( new file output stream ( journal file tmp ) , util . us ascii ) ) ; try { writer . write ( magic ) ; writer . write ( str ) ; writer . write ( version 1 ) ; writer . write ( str ) ; writer . write ( integer . to string ( app version ) ) ; writer . write ( str ) ; writer . write ( integer . to string ( value count ) ) ; writer . write ( str ) ; writer . write ( str ) ; for ( entry entry : lru entries . values ( ) ) { if ( entry . current editor != null ) { writer . write ( dirty + str + entry . key + str ) ; } else { writer . write ( clean + str + entry . key + entry . get lengths ( ) + str ) ; } } } finally { writer . close ( ) ; } if ( journal file . exists ( ) ) { rename to ( journal file , journal file backup , bool ) ; } rename to ( journal file tmp , journal file , bool ) ; journal file backup . delete ( ) ; journal writer = new buffered writer ( new output stream writer ( new file output stream ( journal file , bool ) , util . us ascii ) ) ; }	creates a new journal that omits redundant information.
private void refresh done button ( boolean done ) { but done . set text ( done ? messages . get string ( str ) : messages . get string ( str ) ) ; }	refreshes the done button.
private void create migration task page ( ) { migration task editor migration task editor = new migration task editor ( migration task , get container ( ) ) ; int index = add page ( migration task editor . get control ( ) ) ; set page text ( index , str ) ; task listeners . add ( migration task editor ) ; }	create the basic editor .
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = m pool . get buf ( ( count + i ) * num ) ; system . arraycopy ( buf , num , newbuf , num , count ) ; m pool . return buf ( buf ) ; buf = newbuf ; }	ensures there is enough space in the buffer for the given number of additional bytes .
public static int to i ( string ip address ) { if ( ip address == null ) throw new illegal argument exception ( str + str ) ; string [ ] octets = ip address . split ( str ) ; if ( octets . length != num ) throw new illegal argument exception ( str + str ) ; int result = num ; for ( int i = num ; i < num ; ++ i ) { int oct = integer . value of ( octets [ i ] ) ; if ( oct > num || oct < num ) throw new illegal argument exception ( str + str ) ; result |= oct << ( ( num - i ) * num ) ; } return result ; }	accepts an ipv4 address of the form xxx.
public void close cursor ( cursor cursor ) { cursor . close ( ) ; cursor map . remove ( integer . value of ( cursor . get cursor id ( ) ) ) ; }	close the given cursor and remove it from the map.
private boolean has next ( pattern pattern ) { if ( ! has next ( ) ) { return bool ; } matcher matcher = pattern . matcher ( gser value . substring ( pos , length ) ) ; return matcher . find ( ) ; }	determines if the remaining gser string matches the provided pattern .
void push int ( int i ) { switch ( i ) { case - num : mv . visit insn ( iconst ) ; return ; case num : mv . visit insn ( iconst 0 ) ; return ; case num : mv . visit insn ( iconst 1 ) ; return ; case num : mv . visit insn ( iconst 2 ) ; return ; case num : mv . visit insn ( iconst 3 ) ; return ; case num : mv . visit insn ( iconst 4 ) ; return ; case num : mv . visit insn ( iconst 5 ) ; return ; } if ( i >= byte . min value && i <= byte . max value ) { mv . visit int insn ( bipush , i ) ; return ; } if ( i >= short . min value && i <= short . max value ) { mv . visit int insn ( sipush , i ) ; return ; } mv . visit ldc insn ( integer . value of ( i ) ) ; }	push i onto our operand stack.
public static string xml node ( string name , string attributes , string content , boolean indent ) { string start = attributes == null ? name : name + attributes ; if ( content == null ) { return str + start + str ; } if ( indent && content . index of ( str ) >= num ) { content = str + indent ( content ) ; } return str + start + str + content + str + name + str ; }	create an xml node with optional attributes and content.
public void add ( int position , @ non null t item ) { synchronized ( lock ) { if ( items == null ) { items = new array list < > ( ) ; } items . add ( position , item ) ; } if ( notify on change ) { notify item inserted ( position ) ; } }	adds the specified item to the list with the specified position.
void notify failure ( throwable exception ) { synchronized ( wait object ) { is complete = bool ; if ( exception instanceof mqtt exception ) { pending exception = ( mqtt exception ) exception ; } else { pending exception = new mqtt exception ( exception ) ; } wait object . notify all ( ) ; if ( exception instanceof mqtt exception ) { last exception = ( mqtt exception ) exception ; } if ( listener != null ) { listener . on failure ( this , exception ) ; } } }	notify unsuccessful completion of the operation.
public static void transform ( stream source src , stream source stylesheet , fop fop ) throws fop { result res = new sax ( fop . get default handler ( ) ) ; try { transformer factory factory = transformer factory . new instance ( ) ; transformer transformer ; if ( stylesheet == null ) { transformer = factory . new transformer ( ) ; } else { transformer = factory . new transformer ( stylesheet ) ; } transformer . set uri ( new local resolver ( transformer . get uri ( ) ) ) ; transformer . transform ( src , res ) ; } catch ( exception e ) { throw new fop ( e ) ; } }	transform an xsl - fo streamsource to the specified output format .
public list < string > split string with default delimiter escaped ( string input string ) { string delimiter = configuration helper . get property ( configuration value . field data delimiter ) ; string escape char = configuration helper . get property ( configuration value . field data delimiter escape char ) ; list < string > split string = new array list < > ( ) ; if ( string utils . is not blank ( input string ) ) { string regex = str + pattern . quote ( escape char ) + str + pattern . quote ( delimiter ) ; for ( string s : input string . split ( regex ) ) { split string . add ( s . replace ( escape char + delimiter , delimiter ) ) ; } } return split string ; }	splits the input string based on the default delimiter , and also escapes delimiter .
protected final boolean read available blocking ( ) throws io { char [ ] buffer = my buffer ; string builder token = my text buffer ; token . set length ( num ) ; boolean read = bool ; int n ; while ( ( n = my reader . read ( buffer ) ) > num ) { if ( my scheduled submitter != null ) my scheduled submitter . cancel ( bool ) ; read = bool ; synchronized ( my text buffer ) { process line ( buffer , token , n ) ; } my scheduled submitter = my executor service . submit ( my token submitter ) ; } submit token ( ) ; return read ; }	reads data with blocking.
public void delete obligation ( final obligation obligation , int basic block id ) throws obligation acquired or released in loop exception { map < obligation set , state > updated state map = new hash map < obligation set , state > ( ) ; for ( iterator < state > i = state iterator ( ) ; i . has next ( ) ; ) { state state = i . next ( ) ; check circularity ( state , obligation , basic block id ) ; obligation set obligation set = state . get obligation set ( ) ; obligation set . remove ( obligation ) ; if ( ! obligation set . is empty ( ) ) { updated state map . put ( obligation set , state ) ; } } replace map ( updated state map ) ; }	remove an obligation from every state in the stateset .
private void clip view on the right ( rect cur view bound , float cur view width , int right ) { cur view bound . right = ( int ) ( right - m clip padding ) ; cur view bound . left = ( int ) ( cur view bound . right - cur view width ) ; }	set bounds for the right textview including clip padding .
public content impl create compound package content ( ole blob impl blob , string pretty name , string class name , string type name , byte buffer blob bb , int data block len ) { return new compound content impl ( blob , pretty name , class name , type name , blob bb . position ( ) , data block len ) ; }	creates a nes compoundcontent for the given blob information .
protected boolean check coverage ( ) { int i ; int n ; int [ ] count ; range r ; string attr index ; subspace cluster definition cl ; count = new int [ get num attributes ( ) ] ; for ( i = num ; i < get num attributes ( ) ; i ++ ) { for ( n = num ; n < get clusters ( ) . length ; n ++ ) { cl = ( subspace cluster definition ) get clusters ( ) [ n ] ; r = new range ( cl . get attr index range ( ) ) ; r . set upper ( get num attributes ( ) ) ; if ( r . is in range ( i ) ) { count [ i ] ++ ; } } } attr index = str ; for ( i = num ; i < count . length ; i ++ ) { if ( count [ i ] == num ) { if ( attr index . length ( ) != num ) { attr index += str ; } attr index += ( i + num ) ; } } if ( attr index . length ( ) != num ) { throw new illegal argument exception ( str + str + attr index + str ) ; } return bool ; }	checks , whether all attributes are covered by cluster definitions and returns true in that case .
private set < integer > find values ( string string ) { set < integer > results = new tree set < integer > ( ) ; for ( string str : string . split ( str ) ) { if ( ! str . equals ( str ) ) { results . add ( find value ( str ) ) ; } } return results ; }	search for a string in the enumeration .
private static int index of ( object [ ] array , int len , object elt ) { for ( int i = num ; i < len ; i ++ ) { if ( elt . equals ( array [ i ] ) ) return i ; } return - num ; }	returns the first index of elt in the array if < len , else - 1 .
@ deprecated public void append ( final string name , final string value ) { list < string > l = map . get ( name ) ; if ( l != null ) { l . add ( value ) ; } else { l = lists . new array list ( value ) ; map . put ( name , l ) ; } }	add a new value for name.
public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof certificate ) ) { return bool ; } certificate object = ( certificate ) obj ; try { return arrays . equals ( get encoded ( ) , object . get encoded ( ) ) ; } catch ( certificate encoding exception e ) { return bool ; } }	compares the argument to this certificate.
public statement between ( object former , object later ) { statement . append ( str ) ; append ( former ) ; statement . append ( str ) ; append ( later ) ; return this ; }	appending the between operator clause .
public byte [ ] encode1 ( final string s ) { final byte array buffer tmp = new byte array buffer ( s . length ( ) ) ; final int nwritten = uc . encode ( s , tmp ) ; final int npack = long packer . get byte length ( nwritten ) ; final byte [ ] a = new byte [ npack + nwritten ] ; final data output buffer dob = new data output buffer ( num , a ) ; try { dob . pack long ( nwritten ) ; dob . append ( tmp . array ( ) , num , tmp . pos ( ) ) ; return a ; } finally { try { dob . close ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } } }	encode a unicode string .
public static map < object , long > value histogram ( geo time serie gts ) { map < object , long > occurrences = new hash map < object , long > ( ) ; for ( int i = num ; i < gts . values ; i ++ ) { object value = gts . value at index ( gts , i ) ; if ( ! occurrences . contains key ( value ) ) { occurrences . put ( value , num ) ; } else { occurrences . put ( value , num + occurrences . get ( value ) ) ; } } if ( gts . is bucketized ( gts ) && gts . bucketcount != gts . values ) { occurrences . put ( null , ( long ) ( gts . bucketcount - gts . values ) ) ; } return occurrences ; }	build an occurrence count by value for the given time serie .
private void compute weights ( node node ) { int wsum = num ; for ( node child : node . children ) { compute weights ( child ) ; wsum += child . weight ; } node . weight = math . max ( num , wsum ) ; }	recursively assign node weights .
public searcher ( ) throws io { searcher = new index searcher ( directory reader . open ( fs . open ( paths . get ( index dir ) ) ) ) ; parser = new query parser ( content field , new standard analyzer ( ) ) ; }	creates a new instance of searchengine.
public query string query builder field ( string field ) { if ( fields == null ) { fields = new array list < > ( ) ; } fields . add ( field ) ; return this ; }	adds a field to run the query string against .
public static < r , a , b > completion stage < r > combine ( completion stage < a > a , completion stage < b > b , bi function < a , b , r > function ) { return a . then combine ( b , function ) ; }	combines multiple stages by applying a function .
protected string build create schema statement ( ) throws replicator exception { return null ; }	return a statement that will create the schema , null if no create schema can be given.
public void test neg pos first shorter ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; int a sign = - num ; int b sign = num ; byte r bytes [ ] = { num , - num , num , num , num , num , num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	and for a negative and a positive numbers ; the first is shorter.
public stream info manager ( twitch api api , stream info listener listener ) { this . listener = listener ; this . api = api ; pending requests = new hash map < > ( ) ; invalid stream info = new stream info ( str , listener ) ; invalid stream info . set requested ( ) ; }	create a new manager object .
public sentence as sentence ( ) { return sentence . new conjunction ( sentences ) ; }	returns the list of sentences in the knowledge base chained together as a single sentence .
public boolean is pronoun ( ) { return type string . contains ( suffix pronoun ) ; }	determine if the expression is a pronoun .
protected void append short type ( string builder sb , field type field type , int field width ) { sb . append ( str ) ; }	output the sql type for a java short .
public static vector tokenize string ( string source , string separator ) { if ( separator . length ( ) == num ) { return tokenize string ( source , separator . char at ( num ) ) ; } vector tokenized = new vector ( ) ; int len = source . length ( ) ; string builder buf = new string builder ( ) ; for ( int iter = num ; iter < len ; iter ++ ) { char current = source . char at ( iter ) ; if ( separator . index of ( current ) > - num ) { if ( buf . length ( ) > num ) { tokenized . add element ( buf . to string ( ) ) ; buf = new string builder ( ) ; } } else { buf . append ( current ) ; } } if ( buf . length ( ) > num ) { tokenized . add element ( buf . to string ( ) ) ; } return tokenized ; }	breaks a string to multiple strings ( similar to string tokenizer ).
private void backup favorites ( backup data output data ) throws io { content resolver cr = m context . get content resolver ( ) ; cursor cursor = cr . query ( favorites . content uri , favorite projection , get user selection arg ( ) , null , null ) ; try { cursor . move to position ( - num ) ; while ( cursor . move to next ( ) ) { final long id = cursor . get long ( id index ) ; final long update time = cursor . get long ( id modified ) ; key key = get key ( key . favorite , id ) ; m keys . add ( key ) ; final string backup key = key to backup key ( key ) ; if ( ! m existing keys . contains ( backup key ) || update time >= m last backup restore time ) { write row to backup ( key , pack favorite ( cursor ) , data ) ; } else { if ( debug ) log . d ( tag , str + id ) ; } } } finally { cursor . close ( ) ; } }	write all modified favorites to the data stream .
public void update ( ) { if ( last time != - num ) { long delta = system . nano time ( ) - last time ; rolling average . add value ( delta ) ; } last time = system . nano time ( ) ; }	update the fps counter . < p / > call this method every frame !.
public list < validation error message > validate ( ) { error message ids . clear ( ) ; if ( payment product == null ) { throw new null pointer exception ( str ) ; } for ( payment product field field : payment product . get payment product fields ( ) ) { if ( ! is field in account on file and not altered ( field ) ) { error message ids . add all ( field . validate value ( get value ( field . get id ( ) ) ) ) ; } } return error message ids ; }	validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .
key store state ( ) { }	create an empty state .
crypto result ( final t result , final list < k > master keys , final ciphertext headers headers ) { result = result ; master keys = collections . unmodifiable list ( master keys ) ; headers = headers ; encryption context = headers . get encryption context map ( ) ; }	note , does not make a defensive copy of any of the data .
public void state changed ( change event e ) { if ( ignore update ) { return ; } double value = ( double ) ( num - setpoint slider . get value ( ) ) / num ; set set point ( value ) ; sim . set set point ( value ) ; }	handle a change in the slider by updating the dataset value.
public static string [ ] parse delimited list ( string list , char delimiter ) { string delim = str + delimiter ; string tokenizer st = new string tokenizer ( list + delim + str , delim , bool ) ; array list < string > v = new array list < string > ( ) ; string last token = str ; string word = str ; while ( st . has more tokens ( ) ) { string tok = st . next token ( ) ; if ( last token != null ) { if ( tok . equals ( delim ) ) { word = word + last token ; if ( last token . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( str ) ) v . add ( word ) ; word = str ; } } last token = tok ; } return v . to array ( new string [ num ] ) ; }	parse a list of substrings separated by a given delimiter . the delimiter can also appear in substrings ( just double them ) : parsedelimitedstring ( " this | is " , ' | ' ) returns [ " this " , " is " ] parsedelimitedstring ( " this | | is " , ' | ' ) returns [ " this | is " ].
private void initialize layout ( ) { grid layout gl = new grid layout ( num , num ) ; gl . set vgap ( num ) ; set layout ( gl ) ; add ( new j ( str ) ) ; add ( frozen dd ) ; add ( new j ( str ) ) ; add ( tf up bound ) ; add ( new j ( str ) ) ; add ( tf low bound ) ; add ( new j ( str ) ) ; add ( tf increment ) ; add ( new j ( str ) ) ; add ( tf delay ) ; set border ( border factory . create empty border ( num , num , num , num ) ) ; }	lays out the panel.
@ override public boolean is running ( ) { return ( frame != null && frame . is visible ( ) ) ; }	returns true if the gui is started and not paused , and false otherwise .
public static mosaic definition create mosaic definition ( final account creator ) { return create mosaic definition ( creator , utils . create mosaic id ( str , str ) , create mosaic properties ( ) ) ; }	creates a default mosaic definition .
public result result ( sql node node , collection < clause > clauses , rel node rel ) { final string alias2 = sql validator util . get alias ( node , - num ) ; final string alias3 = alias2 != null ? alias2 : str ; final string alias4 = sql validator util . uniquify ( alias3 , alias set , sql validator util . expr suggester ) ; final string alias5 = alias2 == null || ! alias2 . equals ( alias4 ) ? alias4 : null ; return new result ( node , clauses , alias5 , collections . singleton list ( pair . of ( alias4 , rel . get row type ( ) ) ) ) ; }	creates a result based on a single relational expression .
private static void trust all https certificates ( ) { ssl context ; if ( trust managers == null ) { trust managers = new trust manager [ ] { new fake x509 trust manager ( ) } ; } try { context = ssl . get instance ( str ) ; context . init ( null , trust managers , new secure random ( ) ) ; } catch ( general security exception gse ) { throw new illegal state exception ( gse . get message ( ) ) ; } url . set default ssl ( context . get socket factory ( ) ) ; }	set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .
private static boolean is in need of form ( ui component ) { return ( component instanceof action source || component instanceof action source2 || component instanceof editable value holder ) ; }	is the component in need of a form .
private void add internal listeners ( ) { cb distribution . add item listener ( cb item listener ) ; }	adds all internal listeners.
public static double safe sqrt ( double x ) { return ( x < num ? - math . sqrt ( - x ) : math . sqrt ( x ) ) ; }	the " safe " square root of the input value , handling negative values by simply making them positive and then negating the return value .
public static long run multi threaded ( iterable < callable < ? > > calls , grid test safe thread factory thread factory ) throws exception { if ( ! busy lock . enter busy ( ) ) throw new illegal state exception ( str ) ; collection < thread > threads = new array list < > ( ) ; long time ; try { for ( callable < ? > call : calls ) threads . add ( thread factory . new thread ( call ) ) ; time = system . current time millis ( ) ; for ( thread t : threads ) t . start ( ) ; } finally { busy lock . leave busy ( ) ; } for ( thread t : threads ) t . join ( ) ; time = system . current time millis ( ) - time ; thread factory . check error ( ) ; return time ; }	runs callable tasks each in separate threads .
private void bappend ( char ch ) { try { m buff [ ++ m buff idx ] = ch ; } catch ( exception exp ) { char buff [ ] = new char [ m buff . length << num ] ; system . arraycopy ( m buff , num , buff , num , m buff . length ) ; m buff = buff ; m buff [ m buff idx ] = ch ; } }	appends a character to parser ' s buffer .
public void initialize owner references for field ( state manager sm , field meta data fmd ) { if ( fmd . get association type ( ) == field meta data . one to many ) { collection < ? > collection = ( collection < ? > ) sm . fetch ( fmd . get index ( ) ) ; if ( collection != null ) { for ( object item : collection ) { if ( item != null ) { relations manager . set owner state manager for persistent instance ( item , sm , fmd ) ; } } } } else if ( fmd . get association type ( ) == field meta data . one to one || fmd . is embedded pc ( ) ) { object value = sm . fetch ( fmd . get index ( ) ) ; if ( value != null ) { relations manager . set owner state manager for persistent instance ( value , sm , fmd ) ; } } }	sets the provided state manager as the owner for the provided field value .
public string build union sub query ( string type discriminator column , string [ ] union columns , set < string > columns present in table , int computed columns offset , string type discriminator value , string selection , string group by , string having ) { int union columns count = union columns . length ; string [ ] projection in = new string [ union columns count ] ; for ( int i = num ; i < union columns count ; i ++ ) { string union column = union columns [ i ] ; if ( union column . equals ( type discriminator column ) ) { projection in [ i ] = str + type discriminator value + str + type discriminator column ; } else if ( i <= computed columns offset || columns present in table . contains ( union column ) ) { projection in [ i ] = union column ; } else { projection in [ i ] = str + union column ; } } return build query ( projection in , selection , group by , having , null , null ) ; }	construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .
public node ( coordinate pt ) { this ( pt , new directed edge star ( ) ) ; }	constructs a node with the given location .
public synchronized void increase ( ) { if ( accuracy > num ) { long time passed = system . current time millis ( ) - last added ; if ( time passed > accuracy ) { clear up ( ) ; if ( count > num ) { data . add first ( last added + accuracy ) ; } last added = system . current time millis ( ) ; count = num ; } count ++ ; } else { clear up ( ) ; data . add first ( system . current time millis ( ) ) ; } }	adds an element to the counter or caches it to be added .
public void revert ( final virtual file root , final list < file path > files ) throws vcs exception { for ( list < string > paths : vcs file util . chunk paths ( root , files ) ) { git simple handler handler = new git simple handler ( my project , root , git command . checkout ) ; handler . add parameters ( str ) ; handler . end options ( ) ; handler . add parameters ( paths ) ; handler . run ( ) ; } }	reverts the list of files we are passed .
public static float [ ] concat all float ( float [ ] ... arrays ) { int total length = num ; final int sub array count = arrays . length ; for ( int i = num ; i < sub array count ; ++ i ) { total length += arrays [ i ] . length ; } float [ ] result = arrays . copy of ( arrays [ num ] , total length ) ; int offset = arrays [ num ] . length ; for ( int i = num ; i < sub array count ; ++ i ) { system . arraycopy ( arrays [ i ] , num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of float arrays into a single array .
public tagged value iterator ( final string a line , final boolean attempt first word , final string ... tags ) { this . a line = a line ; this . attempt first word = attempt first word ; this . tags = tags ; tag pos = num ; next result = get next result ( ) ; if ( attempt first word ) { int a = num ; while ( a < a line . length ( ) ) { if ( a line . char at ( a ) == str || a line . char at ( a ) == str || character . is whitespace ( a line . char at ( a ) ) ) a ++ ; else break ; } int b = a + num ; while ( b < a line . length ( ) ) { if ( character . is letter or digit ( a line . char at ( b ) ) || a line . char at ( b ) == str ) b ++ ; else break ; } if ( b - a > num ) { next result = a line . substring ( a , b ) ; } tag pos = b ; } }	iterator over all values following an occurrence of tag in aline . example : aline = gi | 4444 | gi | 5555 and tag = gi | with return 4444 and then 5555 value consists of letters , digits or underscore.
public void ascend tree ( ) { if ( null != parent path ) { parent path . append ( parent path ) ; return ; } file parent tree = calc parent tree ( ) ; if ( null != parent tree ) { tree file = parent tree ; return ; } parent path = new string builder ( provide last name ( ) ) ; parent path . append ( parent path ) ; }	move higher in the tree , beyond even an apparent root of tree .
public boolean can read ( ) { return is != null ; }	returns true if there ' s an associated file .
void write to ( byte [ ] b , int off ) { system . arraycopy ( buf , num , b , off , count ) ; }	writes the contents of the internal buffer to the given array starting at the given offset.
void on item dismissed ( final int position ) { final t removed = m data . get ( position ) ; final boolean was removed = remove ( position ) ; if ( was removed && m data change listener != null ) { m data change listener . on item removed ( removed , position ) ; } }	dismisses item from the given position .
public static double normal pdf ( double x , double variance , double mean value ) { double standard deviation = math . sqrt ( variance ) ; return ( num / ( standard deviation * math . sqrt ( num * math . pi ) ) ) * math . pow ( math . e , - ( ( x - mean value ) * ( x - mean value ) ) / ( num * variance ) ) ; }	calculate a normal probability density function ( pdf ) based on a variance and mean value.
public static object [ ] sort copy ( object [ ] objects , comparer comparer ) { int len = objects . length ; object [ ] copy = new object [ len ] ; system . arraycopy ( objects , num , copy , num , len ) ; sort ( copy , comparer ) ; return copy ; }	sorts an array of strings , returning a new array with the sorted items.
public synchronized void add zoom listener ( zoom listener listener ) { m zoom listeners . add ( listener ) ; }	adds a new zoom listener .
private void clear registers ( instruction start , instruction end ) { for ( instruction p = start ; ; p = p . next instruction in code order ( ) ) { for ( enumeration < operand > ops = p . get operands ( ) ; ops . has more elements ( ) ; ) { operand op = ops . next element ( ) ; if ( op instanceof register operand ) { register operand r op = ( register operand ) op ; clear dep graph node for register ( r op . get register ( ) ) ; } } if ( p == end ) break ; } for ( enumeration < register > e = generic physical def use . enumerate all implicit def uses ( ir ) ; e . has more elements ( ) ; ) { register r = e . next element ( ) ; clear dep graph node for register ( r ) ; } }	initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null.
public void fire annotation selected ( workflow annotation anno ) { list < workflow annotation > list = new linked list < > ( ) ; list . add ( anno ) ; fire annotations changed ( annotation event . selected annotation changed , list ) ; }	fire when an annotation has been selected .
public boolean verify server evidence message ( big integer server m2 ) throws crypto exception { if ( ( this . a == null ) || ( this . m1 == null ) || ( this . s == null ) ) { throw new crypto exception ( str + str ) ; } big integer computed m2 = sr . calculate m2 ( digest , n , a , m1 , s ) ; if ( computed m2 . equals ( server m2 ) ) { this . m2 = server m2 ; return bool ; } return bool ; }	authenticates the server evidence message m2 received and saves it only if correct .
public void handle text ( string text ) { if ( skipping characters > num ) { if ( skipping characters >= text . length ( ) ) { skipping characters -= text . length ( ) ; return ; } else { text = text . substring ( skipping characters ) ; skipping characters = num ; } } if ( rtf destination != null ) { rtf destination . handle text ( text ) ; return ; } warning ( str ) ; }	handles any pure text ( containing no control characters ) in the input stream.
public final boolean remove ( final uri service uri ) { boolean modified = bool ; synchronized ( this ) { if ( aliases . remove ( service uri ) != null ) { modified = bool ; } final service factory factory = services . remove ( service uri ) ; if ( factory != null ) { modified = bool ; if ( factory instanceof custom service factory ) { custom services . remove ( factory ) ; } } } return modified ; }	remove a service from the registry and / or set of known aliases .
@ nullable private static string reference to attribute ( string attrib , boolean include dummies ) { while ( attrib . starts with ( str ) ) { attrib = attrib . substring ( num ) ; } if ( attrib . starts with ( str ) ) { if ( include dummies ) { attrib = attrib . substring ( num ) ; } else return null ; } if ( ! string util . starts with char ( attrib , str ) ) { return null ; } attrib = attrib . substring ( num ) ; if ( string util . starts with char ( attrib , str ) ) { string clean attribute = null ; for ( int i = num ; i < attrib . length ( ) ; i ++ ) { char curr char = attrib . char at ( i ) ; if ( curr char == str || curr char == str ) { clean attribute = null ; break ; } else if ( curr char == str ) { clean attribute = attrib . substring ( num , i ) ; break ; } } attrib = clean attribute ; } else { for ( int i = num ; i < attrib . length ( ) ; i ++ ) { char curr char = attrib . char at ( i ) ; if ( curr char == str || curr char == str || curr char == str ) { attrib = attrib . substring ( num , i ) ; break ; } } } return attrib ; }	removes each two leading ' \ ' , removes leading $ , removes { } examples : $ qqq - > qqq \ $ qqq - > qqq if dummy attributes are collected too , null otherwise \ \ $ qqq - > qqq $ { qqq } - > qqq.
public escaped writer ( writer fos ) { super ( fos ) ; }	constructs an escapedwriter around the given writer .
public boolean is expired ( final date date ) { if ( date == null ) { throw new illegal argument exception ( str ) ; } return ( cookie expiry date != null && cookie expiry date . get time ( ) <= date . get time ( ) ) ; }	returns true if this cookie has expired .
public void record ( record builder impl record builder ) { store bitmap ( record builder ) ; output stream view hierarchy dump = null ; try { view hierarchy dump = m album . open view hierarchy file ( record builder . get name ( ) ) ; m view hierarchy . deflate ( record builder . get view ( ) , view hierarchy dump ) ; m album . add record ( record builder ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } finally { if ( view hierarchy dump != null ) { try { view hierarchy dump . close ( ) ; } catch ( io e ) { log . e ( str , str , e ) ; } } } }	records the recordbuilderimpl , and verifies if required.
protected boolean is correct method ( method method , object [ ] args ) { return ( proxy signature . equals ( method . get name ( ) ) && args . length == num ) ; }	compare the method that was called to the intended method when the osxadapter instance was created ( e.
public void test case17 ( ) { byte a bytes [ ] = { - num , num , num , num , num , - num , num , - num , num , num } ; byte b bytes [ ] = { num , - num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , - num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . remainder ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	remainder of division of two positive numbers.
public metadata . property . builder clear ( ) { metadata property builder defaults = new metadata . property . builder ( ) ; type = defaults . type ; boxed type = defaults . boxed type ; name = defaults . name ; capitalized name = defaults . capitalized name ; all caps name = defaults . all caps name ; getter name = defaults . getter name ; code generator = defaults . code generator ; fully checked cast = defaults . fully checked cast ; accessor annotations . clear ( ) ; unset properties . clear ( ) ; unset properties . add all ( defaults . unset properties ) ; return ( metadata . property . builder ) this ; }	resets the state of this builder .
public static float r distance ( vec3 a , vec3 b ) { float x = a . m [ num ] - b . m [ num ] ; float y = a . m [ num ] - b . m [ num ] ; float z = a . m [ num ] - b . m [ num ] ; float result = ( float ) math . sqrt ( x * x + y * y + z * z ) ; return result ; }	\ brief distance ( vec3 a , vec3 b ).
public void check backup info ( final file backup info file , boolean backup in multi vdc ) { try ( input stream fis = new file input stream ( backup info file ) ) { properties properties = new properties ( ) ; properties . load ( fis ) ; check version ( properties ) ; check hosts ( properties , backup in multi vdc ) ; } catch ( io ex ) { log . warn ( str , ex ) ; } }	checks version and ips.
static string to lower case ( string s ) { int len = s . length ( ) ; string builder sb = null ; for ( int i = num ; i < len ; i ++ ) { char c = s . char at ( i ) ; if ( ( c >= str && c <= str ) || ( c == str ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( ( c >= str && c <= str ) || ( c == str ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( c >= str && c <= str ) { if ( sb == null ) { sb = new string builder ( len ) ; sb . append ( s , num , i ) ; } sb . append ( ( char ) ( c - case diff ) ) ; } else { throw new illegal argument exception ( str ) ; } } return sb == null ? s : sb . to string ( ) ; }	convert to lower case , and check that all chars are ascii alphanumeric , ' - ' or '.
public void test constructor sign bytes negative3 ( ) { byte a bytes [ ] = { - num , num , num } ; int a sign = - num ; byte r bytes [ ] = { - num , num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	create a negative number from a sign and an array of bytes.
public static byte [ ] build opus comment ( string comment ) { byte [ ] data = new byte [ num + comment . length ( ) ] ; write opus comment ( data , num , comment ) ; return data ; }	builds and returns a opus comment .
public static void assert props ( uniform pair < event bean > received , string [ ] property names , object [ ] expected insert , object [ ] expected removed ) { assert props ( received . get first ( ) , property names , expected insert ) ; assert props ( received . get second ( ) , property names , expected removed ) ; }	assert that the property values of a new event and a removed event match the expected insert and removed values .
public int size ( ) { return al . size ( ) ; }	returns the number of elements in this set .
public static string to upper case ( string src ) { if ( src == null ) { return null ; } else { return src . to upper case ( ) ; } }	safely convert the string to uppercase .
public final iterator < knowledge edge > required edges iterator ( ) { set < knowledge edge > edges = new hash set < > ( ) ; for ( ordered pair < set < my node > > o : required rules specs ) { final set < my node > first = o . get first ( ) ; for ( my node s1 : first ) { final set < my node > second = o . get second ( ) ; for ( my node s2 : second ) { if ( ! s1 . equals ( s2 ) ) { edges . add ( new knowledge edge ( s1 . get name ( ) , s2 . get name ( ) ) ) ; } } } } return edges . iterator ( ) ; }	iterator over the knowledgeedge ' s representing required edges .
@ deprecated public void unlock ( lock state < t > lock state ) { if ( lock state == null ) { throw new illegal argument exception ( str ) ; } if ( lock state . set lock != this ) { throw new illegal argument exception ( str ) ; } if ( lock state . thread != thread . current thread ( ) ) { throw new illegal argument exception ( str ) ; } thread set . remove ( thread . current thread ( ) ) ; for ( reentrant lock lock : lock state . locks ) { lock . unlock ( ) ; } }	unlocks the objects acquired from locking.
public static string format java doc box ( string text ) { require non null ( text ) ; return format text box ( text , java doc width , javadoc words , java doc single line words ) ; }	creates and returns a string formatted so it will fit in a box suitable for a java doc header .
private static string force number string to two digits ( string text ) { while ( text . length ( ) < num ) { text = str + text ; } if ( text . length ( ) > num ) { text = text . substring ( text . length ( ) - num , text . length ( ) ) ; } return text ; }	forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long.
public void add drop item ( final string name , final double probability , final int min , final int max ) { drops items . add ( new drop item ( name , probability , min , max ) ) ; }	adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .
public static < e extends identifiable > list < e > find by primary keys ( entity manager em , list < big integer > ids , class < e > type ) { require argument ( em != null , str ) ; require argument ( ids != null && ! ids . is empty ( ) , str ) ; require argument ( type != null , str ) ; typed query < e > query = em . create named query ( str , type ) ; query . set hint ( str , str ) ; try { query . set parameter ( str , ids ) ; query . set parameter ( str , bool ) ; return query . get result list ( ) ; } catch ( no result exception ex ) { return new array list < > ( num ) ; } }	finds jpa entities by their primary keys .
private void load workflow ( properties ctx , int ad id , http session sess ) { m wf = new m ( ctx , ad id , null ) ; mwf [ ] nodes = wf . get nodes ( bool , env . get context as int ( ctx , str ) ) ; mwf wfn = null ; array list nodes id = new array list ( ) ; for ( int i = num ; i < nodes . length ; i ++ ) { wfn = nodes [ i ] ; nodes id . add ( new integer ( wfn . get ad wf id ( ) ) ) ; } int image map [ ] [ ] = generate image map ( nodes id ) ; sess . set attribute ( workflow , wf ) ; sess . set attribute ( nodes , nodes ) ; sess . set attribute ( nodes id , nodes id ) ; sess . set attribute ( image map , image map ) ; sess . set attribute ( active node , new integer ( - num ) ) ; }	load workflw and initialize the session attributes .
public int hash code ( ) { int h = hash ; if ( h == - num ) { try { h = arrays . hash code ( x509 cert impl . get encoded internal ( this ) ) ; } catch ( certificate exception e ) { h = num ; } hash = h ; } return h ; }	returns a hashcode value for this certificate from its encoded form .
public void remove from tags ( string remove tag ) { tags . remove ( remove tag ) ; fire property change ( tag , null , remove tag ) ; fire property change ( tags as string , null , remove tag ) ; }	removes the from tags .
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) { preconditions . check argument ( data . length == num && signature . length <= num && pub . length <= num ) ; byte buffer byte buff = native ecdsa . get ( ) ; if ( byte buff == null ) { byte buff = byte buffer . allocate direct ( num + num + num + num ) ; byte buff . order ( byte order . native order ( ) ) ; native ecdsa . set ( byte buff ) ; } byte buff . rewind ( ) ; byte buff . put ( data ) ; byte buff . put int ( signature . length ) ; byte buff . put int ( pub . length ) ; byte buff . put ( signature ) ; byte buff . put ( pub ) ; return secp256k1 ecdsa verify ( byte buff ) == num ; }	verifies the given secp256k1 signature in native code . calling when enabled = = false is undefined ( probably library not loaded ).
protected void delete directory ( file web app file ) { if ( web app file . is directory ( ) ) { file [ ] children = web app file . list files ( ) ; for ( file element : children ) { delete directory ( element ) ; } web app file . delete ( ) ; } else { web app file . delete ( ) ; } }	recursively delete the webapp directory .
@ suppress warnings ( str ) static public void assert same iterator any order ( final object [ ] expected , final iterator actual ) { assert same iterator any order ( str , expected , actual ) ; }	verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited.
public static string formatting finished percentage ( final rollout group rollout group , final float finished percentage ) { float tmp finished percentage = num ; switch ( rollout group . get status ( ) ) { case ready : case scheduled : case error : tmp finished percentage = num ; break ; case finished : tmp finished percentage = num ; break ; case running : tmp finished percentage = finished percentage ; break ; default : break ; } return string . format ( str , tmp finished percentage ) ; }	formats the finished percentage of a rollout group into a string with one digit after comma .
public static string generate host name ( string vm name , string host id ) { string hostname = vm name + str + host id ; preconditions . check state ( hostname . equals ( hostname . to lower case ( ) ) , str ) ; return hostname ; }	generates the hostname for a node .
protected void transfer from file ( file id file ) throws io { try ( buffered reader br = new buffered reader ( new file reader ( id file ) ) ) { string line ; while ( ( line = br . read line ( ) ) != null ) { line = line . trim ( ) ; if ( line . length ( ) > num ) { transfer ( line ) ; } } } }	transfer all the sequences listed in the supplied file , interpreting entries appropriately .
private static string unwrap ( string expression ) { if ( expression . starts with ( str ) ) { expression = expression . substring ( expression . index of ( str ) + num , expression . length ( ) - num ) ; if ( expression . ends with ( str ) ) { expression = expression . substring ( num , expression . last index of ( str ) ) ; } else { expression = expression . substring ( num , expression . last index of ( str ) ) ; } } return expression ; }	removes the outermost property from a nested getter expression.
public boolean are all segment present ( int dataset size ) { return m pie segment list . size ( ) == dataset size ; }	if we have all piechart config then there is no point in reloading it.
protected int draw next event time diff ( ) { int time diff = msg interval [ num ] == msg interval [ num ] ? num : rng . next int ( msg interval [ num ] - msg interval [ num ] ) ; return msg interval [ num ] + time diff ; }	generates a ( random ) time difference between two events.
private int create lines ( string text , int insert position , int offset ) { int count = num ; int start = num ; delimiter info delimiter info = next delimiter info ( text , num ) ; while ( delimiter info != null && delimiter info . delimiter index > - num ) { int index = delimiter info . delimiter index + ( delimiter info . delimiter length - num ) ; if ( insert position + count >= f lines . size ( ) ) f lines . add ( new line ( offset + start , offset + index , delimiter info . delimiter ) ) ; else f lines . add ( insert position + count , new line ( offset + start , offset + index , delimiter info . delimiter ) ) ; ++ count ; start = index + num ; delimiter info = next delimiter info ( text , start ) ; } if ( start < text . length ( ) ) { if ( insert position + count < f lines . size ( ) ) { line l = ( line ) f lines . get ( insert position + count ) ; int delta = text . length ( ) - start ; l . offset -= delta ; l . length += delta ; } else { f lines . add ( new line ( offset + start , offset + text . length ( ) - num , null ) ) ; ++ count ; } } return count ; }	creates the line structure for the given text.
public static double sqrt ( double x ) { return math . sqrt ( x ) ; }	returns the positive square root of the specified value .
private result points and transitions transitions between ( result point from , result point to ) { int from x = ( int ) from . get x ( ) ; int from y = ( int ) from . get y ( ) ; int to x = ( int ) to . get x ( ) ; int to y = ( int ) to . get y ( ) ; boolean steep = math . abs ( to y - from y ) > math . abs ( to x - from x ) ; if ( steep ) { int temp = from x ; from x = from y ; from y = temp ; temp = to x ; to x = to y ; to y = temp ; } int dx = math . abs ( to x - from x ) ; int dy = math . abs ( to y - from y ) ; int error = - dx > > num ; int ystep = from y < to y ? num : - num ; int xstep = from x < to x ? num : - num ; int transitions = num ; boolean in black = image . get ( steep ? from y : from x , steep ? from x : from y ) ; for ( int x = from x , y = from y ; x != to x ; x += xstep ) { boolean is black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is black != in black ) { transitions ++ ; in black = is black ; } error += dy ; if ( error > num ) { if ( y == to y ) { break ; } y += ystep ; error -= dx ; } } return new result points and transitions ( from , to , transitions ) ; }	counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .
public static string to bits ( final long x ) { final string builder sb = new string builder ( ) ; long t = x ; for ( int i = num ; i < num ; i ++ ) { if ( ( i & num ) == num && i > num ) { sb . append ( str ) ; } sb . append ( t < num ? str : str ) ; t = t << num ; } assert t == num ; return sb . to string ( ) ; }	convert a number into a bit string with separators between each group of 8 .
public static final byte [ ] encode url ( bit set urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = www form url ; } byte array output stream buffer = new byte array output stream ( ) ; for ( int i = num ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < num ) { b = num + b ; } if ( urlsafe . get ( b ) ) { if ( b == str ) { b = str ; } buffer . write ( b ) ; } else { buffer . write ( str ) ; char hex1 = character . to upper case ( character . for digit ( ( b > > num ) & num , num ) ) ; char hex2 = character . to upper case ( character . for digit ( b & num , num ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . to byte array ( ) ; }	encodes an array of bytes into an array of url safe 7 - bit characters.
public message tokenizer ( i client , string content ) { if ( content == null ) throw new illegal argument exception ( str ) ; if ( content . length ( ) == num ) throw new illegal argument exception ( str ) ; if ( client == null ) throw new illegal argument exception ( str ) ; this . content = content ; this . client = client ; step forward ( num ) ; }	initializes with the string contents .
public void await ( int id ) throws interrupted exception { if ( parties == num ) return ; final boolean start condition = competition condition ; int competing for = ( locks . length * num - num - id ) / num ; while ( competing for >= num ) { final lock node = locks [ competing for ] ; if ( node . try lock ( ) ) { synchronized ( node ) { while ( competition condition == start condition ) node . wait ( ) ; } node . unlock ( ) ; wake up target ( competing for * num + num ) ; wake up target ( competing for * num + num ) ; return ; } else { if ( competing for == num ) break ; competing for = ( competing for - num ) / num ; } } competition condition = ! competition condition ; wake up target ( num ) ; }	waits for all threads to reach this barrier .
private void load translations cache if empty ( ) { if ( translation cache . is empty ( ) ) { for ( object translation translation : translations ) { if ( translation . get locale ( ) != null && translation . get property ( ) != null && ! string utils . is empty ( translation . get value ( ) ) ) { string key = object translation . get cache key ( translation . get locale ( ) , translation . get property ( ) ) ; translation cache . put ( key , translation . get value ( ) ) ; } } } }	populates the translationscache map unless it is already populated .
public nav mouse mode ( boolean should consume events ) { super ( mode id , should consume events ) ; set mode cursor ( cursor . get predefined cursor ( cursor . crosshair cursor ) ) ; rect attributes . set line paint ( color . gray ) ; rect attributes . set matting paint ( color . light gray ) ; rect attributes . set matted ( bool ) ; }	construct a navmousemode . lets you set the consume mode . if the events are consumed , then a mouseevent is sent only to the first mapmouselistener that successfully processes the event . if they are not consumed , then all of the listeners get a chance to act on the event .
public void add event ( sim event new event ) { new event . set serial ( serial ++ ) ; sorted set . add ( new event ) ; }	adds a new event to the queue.
public static void stop timer ( string name ) { long stop time = system . nano time ( ) ; long start time = open timers . remove ( name ) ; if ( start time == null ) { throw new illegal argument exception ( str ) ; } summary statistics statistics = data . get ( name ) ; if ( statistics == null ) { statistics = new summary statistics ( ) ; data . put ( name , statistics ) ; } statistics . add value ( stop time - start time ) ; }	stops the timer with the specified name .
public string to string summary ( ) { int resultset length ; string result ; string titles ; int i ; int j ; if ( m == null ) return str ; resultset length = num + math . max ( ( int ) ( math . log ( get col count ( ) ) / math . log ( num ) ) , ( int ) ( math . log ( get row count ( ) ) / math . log ( num ) ) ) ; result = str ; titles = str ; result += str ; result += str + str ; result += str ; result += str ; for ( i = num ; i < get col count ( ) ; i ++ ) { if ( get col hidden ( i ) ) continue ; titles += str ; result += str ; titles += str + utils . pad left ( str + get summary title ( i ) , resultset length * num + num ) ; } result += str ; result += titles + str ; for ( i = num ; i < get col count ( ) ; i ++ ) { if ( get col hidden ( i ) ) continue ; for ( j = num ; j < get col count ( ) ; j ++ ) { if ( get col hidden ( j ) ) continue ; if ( j == num ) result += ( char ) ( ( int ) str + i % num ) ; if ( j == i ) result += str ; else result += str + m [ i ] [ j ] + str + m [ i ] [ j ] + str ; } result += str ; } result += str ; return result ; }	returns the summary as string .
public static file create temp path ( string path ) throws io { string sep = file . separator ; file temp dir = new file ( system . get property ( str ) + sep + path ) ; if ( ! temp dir . exists ( ) ) if ( ! temp dir . mkdirs ( ) ) { boolean status = temp dir . delete ( ) ; throw new io ( str + temp dir + str + status ) ; } temp dir . delete on exit ( ) ; return temp dir ; }	create a hierarchy of directories ( a path ) in the designated temp dir.
public void hspan ( double start , double end , paint color , string legend ) { legend text legend text = new legend text ( color , legend ) ; comments . add ( legend text ) ; plot elements . add ( new h ( start , end , color , legend text ) ) ; }	draws a horizontal span into the graph and optionally adds a legend .
public state interactive extent to whole connections ( ) { set < brd item > selected items = new tree set < brd item > ( ) ; for ( brd item curr item : items list ) { if ( curr item instanceof brd connectable ) { selected items . add all ( curr item . get connection items ( ) ) ; } } if ( selected items . is empty ( ) ) { return return state ; } items list = selected items ; actlog start scope ( logfile scope . extend to whole connections ) ; filter ( ) ; i brd . repaint ( ) ; return this ; }	select also all items belonging to any connection of the current selected items .
public static i new instance ( int capacity , collator enum collator choice , locale locale , object strength , decomposition enum mode ) { if ( collator choice == collator enum . ascii ) { return new key builder ( capacity ) ; } if ( locale == null ) { locale = locale . get default ( ) ; if ( log . is info enabled ( ) ) log . info ( str + locale . get display name ( ) ) ; } final boolean icu = collator choice == collator enum . icu ; if ( icu && ! default key builder factory . is icu ( ) ) { throw new unsupported operation exception ( default key builder factory . icu not available ) ; } final byte [ ] buf = create buffer ( capacity ) ; final int len = num ; switch ( collator choice ) { case icu : return new key builder ( new icu ( locale , strength , mode ) , len , buf ) ; case jdk : return new key builder ( new jdk ( locale , strength , mode ) , len , buf ) ; default : throw new unsupported operation exception ( str + collator choice ) ; } }	create a new instance that optionally supports unicode sort keys .
private list < node > possible parents ( node x , list < node > nodes , i knowledge ) { list < node > possible parents = new linked list < > ( ) ; string x = x . get name ( ) ; for ( node z : nodes ) { string z = z . get name ( ) ; if ( possible parent of ( z , x , knowledge ) ) { possible parents . add ( z ) ; } } return possible parents ; }	removes from the list of nodes any that cannot be parents of x given the background knowledge .
protected void configure from properties ( input stream is , string root directory ) throws io { properties props = new properties ( ) ; props . load ( is ) ; props . put ( root dir path property , root directory ) ; string old prefix = get property prefix ( ) ; set properties ( null , props ) ; set property prefix ( old prefix ) ; }	called with an input stream for a properties file , used for reading tiles.
connection open new connection ( ) throws sql { connection new conn = driver manager . get connection ( url , user , password ) ; if ( url . starts with ( str ) ) { try ( statement s = new conn . create statement ( ) ) { } } else if ( url . starts with ( str ) ) { try ( statement s = new conn . create statement ( ) ) { s . execute ( str ) ; } } return new conn ; }	open a new database connection.
@ override public void add relations ( task task , iterable < object id > project ids , string field name ) { list < project > new project list = new linked list < > ( ) ; iterable < project > projects to add = project repository . find all ( project ids , null ) ; for ( project project : projects to add ) { new project list . add ( project ) ; } try { if ( property utils . get property ( task , field name ) != null ) { iterable < project > projects = ( iterable < project > ) property utils . get property ( task , field name ) ; for ( project project : projects ) { new project list . add ( project ) ; } } } catch ( exception e ) { throw new runtime exception ( e ) ; } try { property utils . set property ( task , field name , new project list ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } task repository . save ( task ) ; }	a simple implementation of the addrelations method which presents the general concept of the method.
protected void do flood bddp ( long pin switch , of pi , floodlight context cntx ) { topology instance ti = get current instance ( bool ) ; set < long > switches = ti . get switches in openflow domain ( pin switch ) ; if ( switches == null ) { switches = new hash set < long > ( ) ; switches . add ( pin switch ) ; } for ( long sid : switches ) { iof sw = floodlight provider . get switch ( sid ) ; if ( sw == null ) continue ; collection < short > enabled ports = sw . get enabled port numbers ( ) ; if ( enabled ports == null ) continue ; set < short > ports = new hash set < short > ( ) ; ports . add all ( enabled ports ) ; set < short > ports known to topo = ti . get ports with links ( sid ) ; if ( ports known to topo != null ) { for ( short p : ports known to topo ) { node port tuple npt = new node port tuple ( sid , p ) ; if ( ti . is broadcast domain port ( npt ) == bool ) { ports . remove ( p ) ; } } } set < short > ports to eliminate = get ports to eliminate for bddp ( sid ) ; if ( ports to eliminate != null ) { ports . remove all ( ports to eliminate ) ; } if ( pin switch == sid ) { ports . remove ( pi . get in port ( ) ) ; } do multi action packet out ( pi . get packet data ( ) , sw , ports , cntx ) ; } }	the bddp packets are forwarded out of all the ports out of an openflowdomain.
public void sleep millis ( final long millis ) { try { thread . sleep ( millis ) ; } catch ( final interrupted exception e ) { logger . error ( e , e ) ; } }	waits the specified number of milliseconds .
private static void verify write set not found ( final b btree ) { log . info ( str ) ; for ( int i = num ; i < num ; i ++ ) { if ( btree . contains ( i ) ) { throw new runtime exception ( str + i ) ; } } }	verify that the write set is not found ( no keys in [ 0 : 1000 ) ) .
private double calculate entropy ( double ... masses ) { double res = num ; for ( double d : masses ) { res -= ( d == num ) ? num : d * math . log ( d ) ; } return res / lo ; }	calculates the entropy corresponding to the input masses .
public static boolean is valid nmtoken ( string nmtoken ) { if ( nmtoken . length ( ) == num ) return bool ; for ( int i = num ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . char at ( i ) ; if ( ! is name ( ch ) ) { return bool ; } } return bool ; }	check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation.
private static double parse double value ( string parse string , string open tag , string close tag , data type validation exception exception ) throws data type validation exception { string tag value ; tag value = parse string value ( parse string , open tag , close tag , exception ) ; double double value ; try { double value = double . parse double ( tag value ) ; } catch ( number format exception e ) { throw e ; } return double value ; }	parses out and converts the text located between first occurrences of the open and closed tags into double .
public void put string ( string s ) throws array index out of bounds exception , unsupported encoding exception { byte [ ] bytes = s . get bytes ( str ) ; int length = bytes . length ; int end at = m index + length + num ; if ( end at > m content . length ) throw new array index out of bounds exception ( end at + str + m content . length ) ; system . arraycopy ( bytes , num , m content , m index , length ) ; m index += length ; m content [ m index ++ ] = str ; debug append string ( s ) ; }	place a string into the message ( using utf - 8 encoding ).
public void add rtcp listener ( rtcp event listener listener ) { listeners . add element ( listener ) ; }	add a rtcp event listener.
@ override protected void ensure number of columns ( int number of columns ) { if ( data . length >= number of columns ) { return ; } double [ ] new data = new double [ number of columns ] ; system . arraycopy ( data , num , new data , num , data . length ) ; data = new data ; }	creates a new array of the given size if necessary and copies the data into the new array .
@ override public void error ( string domain , string key , xml exception ) throws xni { if ( f error handler != null ) { sax sax exception = create sax ( exception ) ; try { f error handler . error ( sax exception ) ; } catch ( sax e ) { throw create xml ( e ) ; } catch ( sax e ) { throw create xni ( e ) ; } } }	reports an error . errors are non - fatal and usually signify that the document is invalid with respect to its grammar ( s ) .
public static boolean connect ( file descriptor fd , inet address inet address , int port ) throws socket exception { try { return io bridge . connect ( fd , inet address , port , num ) ; } catch ( socket timeout exception ex ) { throw new assertion error ( ex ) ; } }	connects socket ' fd ' to ' inetaddress ' on ' port ' , with no timeout.
public boolean is whitespace ( int node handle ) { int type = get node type ( node handle ) ; node node = get node ( node handle ) ; if ( text node == type || cdata section node == type ) { fast string buffer buf = string buffer pool . get ( ) ; while ( node != null ) { buf . append ( node . get node value ( ) ) ; node = logical next dom ( node ) ; } boolean b = buf . is whitespace ( num , buf . length ( ) ) ; string buffer pool . free ( buf ) ; return b ; } return bool ; }	determine if the string - value of a node is whitespace.
public c ( final back end debugger provider debugger provider ) { super ( new border layout ( ) ) ; preconditions . check not null ( debugger provider , str ) ; m label . set foreground ( color . black ) ; add ( m label ) ; m synchronizer = new c ( m label , debugger provider ) ; }	creates a new status panel .
@ override public boolean open ( string access ) { if ( access . equals ( str ) ) { try { i stream = new file image input stream ( new file ( file path ) ) ; parser = new label parser ( ) ; metadata = parser . parse header ( i stream ) ; i stream . close ( ) ; i stream = null ; } catch ( io e ) { try { i stream . close ( ) ; } catch ( exception x ) { } return ( bool ) ; } } return ( super . open ( access ) ) ; }	open the pds file .
void deregister spring ( spring spring ) { if ( spring == null ) { throw new illegal argument exception ( str ) ; } m active springs . remove ( spring ) ; m spring registry . remove ( spring . get id ( ) ) ; }	deregisters a spring from this basespringsystem , so it won ' t be iterated anymore.
@ nullable public string file name ( ) { return java logger . file name ( delegate ) ; }	returns current log file .
public static b parse b ( string n triples b , value factory value factory ) throws illegal argument exception { if ( n triples b . starts with ( str ) ) { return value factory . create b ( n triples b . substring ( num ) ) ; } else { throw new illegal argument exception ( str + n triples b ) ; } }	parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .
public void reset ps ( ) { pilot rolls . remove all elements ( ) ; }	resets the psr list .
public static void sort ( byte [ ] array ) { dual pivot quicksort . sort ( array ) ; }	sorts the specified array in ascending numerical order .
public void close popup ( ) { if ( opened sub popup != null ) { opened sub popup . close popup ( ) ; } remove from parent ( ) ; }	close this popup menu .
public void free object ( int id ) { if ( cache id == id ) { cache id = - num ; cache = null ; } map . remove ( id ) ; }	remove an object from the map .
private void stretch view vertically ( view view , int cross size ) { layout params lp = ( layout params ) view . get layout params ( ) ; int new height = cross size - lp . top margin - lp . bottom margin ; new height = math . max ( new height , num ) ; view . measure ( measure spec . make measure spec ( view . get measured width ( ) , measure spec . exactly ) , measure spec . make measure spec ( new height , measure spec . exactly ) ) ; }	expand the view vertically to the size of the crosssize ( considering the view margins ).
public static inet address hex to inet6 address ( string addr hex string ) throws illegal argument exception { try { return numeric to inet address ( string . format ( str , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) , addr hex string . substring ( num , num ) ) ) ; } catch ( exception e ) { log . e ( str , str + addr hex string + str + e ) ; throw new illegal argument exception ( e ) ; } }	convert a 32 char hex string into a inet6address . throws a runtime exception if the string isn ' t 32 chars , isn ' t hex or can ' t be made into an inet6address.
public void track failure ( ) { retry time = utils . current time millis ( ) + ( long ) backoff ; backoff = math . min ( backoff * params . multiplier , params . maximum ) ; }	track a failure - multiply the back off interval by the multiplier.
public double read double ( ) throws io { return primitive types . read double ( ) ; }	reads a double ( 64 bit ) from the source stream .
private boolean is at maximum ( adjustable bar ) { return ( bar . get value ( ) + bar . get visible amount ( ) >= bar . get maximum ( ) ) ; }	check if a scroll bar is at its maximum value .
public boolean matches cs ( string seq ) { return queue . starts with ( seq , pos ) ; }	case sensitive match test .
protected void parse and add map tile set ( url tile set properties ) throws io , url { properties desc props = new properties ( ) ; logger logger = get logger ( ) ; logger . info ( str ) ; input stream desc url = tile set properties . open stream ( ) ; desc props . load ( desc url ) ; logger . info ( str + tile set properties . to string ( ) + str + desc props . to string ( ) ) ; map tile set mts = create map tile set from properties ( desc props ) ; if ( mts != null && mts . all good ( ) ) { string mts name = mts . get name ( ) ; map tile sets . put ( mts . get name ( ) , mts ) ; logger . info ( str + mts name + str ) ; } desc url . close ( ) ; }	given a url to a properties file describing a maptileset , create it and add it to the list .
protected date compute ( double value ) { if ( double . is na n ( value ) ) { return null ; } long date long = ( long ) value ; date date = new date ( date long ) ; calendar cal = calendar . get instance ( ) ; cal . set time ( date ) ; return cal . get time ( ) ; }	computes the result for one input double value .
public void enable pan ( bluetooth adapter adapter ) { if ( m pan == null ) m pan = ( bluetooth pan ) connect proxy ( adapter , bluetooth profile . pan ) ; assert not null ( m pan ) ; long start = system . current time millis ( ) ; m pan . set bluetooth tethering ( bool ) ; long stop = system . current time millis ( ) ; assert true ( m pan . is tethering on ( ) ) ; write output ( string . format ( str , ( stop - start ) ) ) ; }	enables pan tethering on the local device and checks to make sure that tethering is enabled .
private int dist between points ( int x1 , int z1 , int x2 , int z2 , boolean b allow diags ) { int w = math . abs ( x2 - x1 ) ; int h = math . abs ( z2 - z1 ) ; if ( b allow diags ) { if ( w < h ) w = num ; else h = num ; } return w + h + num ; }	calculate the number of cells on the shortest path between ( x1 , z1 ) and ( x2 , z2 ).
public url ( string protocol , string host , int port , string file , url handler ) throws url { if ( port < - num ) { throw new url ( str + port ) ; } if ( protocol == null ) { throw new null pointer exception ( str ) ; } if ( host != null && host . contains ( str ) && host . char at ( num ) != str ) { host = str + host + str ; } this . protocol = protocol ; this . host = host ; this . port = port ; file = url utils . authority safe path ( host , file ) ; int hash = file . index of ( str ) ; if ( hash != - num ) { this . file = file . substring ( num , hash ) ; this . ref = file . substring ( hash + num ) ; } else { this . file = file ; } fix url ( bool ) ; if ( handler == null ) { setup stream handler ( ) ; if ( stream handler == null ) { throw new url ( str + protocol ) ; } } else { stream handler = handler ; } }	creates a new url of the given component parts.
private workflow . method create volumes method ( uri system uri , uri pool uri , list < uri > volume ur , virtual pool capability values wrapper capabilities ) { return new workflow . method ( str , system uri , pool uri , volume ur , capabilities ) ; }	return a workflow . method for createvolumes .
public file command info ( int fd , string command , int result , string parameters ) { this ( bool , fd , command , result , parameters ) ; }	example : 0x1001 , " close " , 0x0 , " ".
public void init ( gui manual herblore manual ) { for ( manual widget base widget : widgets ) widget . init ( manual ) ; }	initializes the widgets in this page.
private static ssl trust all hosts ( url connection ) { ssl old factory = connection . get ssl ( ) ; try { ssl sc = ssl . get instance ( str ) ; sc . init ( null , trust all certs , new java . security . secure random ( ) ) ; ssl new factory = sc . get socket factory ( ) ; connection . set ssl ( new factory ) ; } catch ( exception e ) { log . e ( log tag , e . get message ( ) , e ) ; } return old factory ; }	this function will install a trust manager that will blindly trust all ssl certificates.
public final double sample max ( ) { return active count max . get and set ( active count . get ( ) ) ; }	sample the active count.
@ get public representation user code form ( ) throws o , invalid grant exception , not found exception , server exception { final o request = request factory . create ( get request ( ) ) ; if ( request . get parameter ( o . device code . user code ) != null ) { return verify ( null ) ; } else { return get template representation ( form , request , null ) ; } }	handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code.
public void test mission name construction ( ) { string xml = str ; xml += create start mission xml ( str , str ) ; xml += create end mission xml ( ) ; input stream mission input stream = new byte array input stream ( xml . get bytes ( ) ) ; string mission name = null ; try { mission name = mission parser . get mission name ( mission input stream ) ; } catch ( mission parse exception e ) { e . print stack trace ( ) ; } assert . assert equals ( str , mission name ) ; }	test for correct reading of a mission name .
@ override public boolean equals ( object other ) { if ( other == this ) { return bool ; } if ( other instanceof zone offset transition ) { zone offset transition d = ( zone offset transition ) other ; return transition . equals ( d . transition ) && offset before . equals ( d . offset before ) && offset after . equals ( d . offset after ) ; } return bool ; }	checks if this object equals another.
public void release ( ) { super . release ( ) ; init ( ) ; }	releases any resources we may have ( or inherit ).
public void close ( ) { while ( ! m receivers . is empty ( ) ) { m context . unregister receiver ( m receivers . remove ( num ) ) ; } if ( m output writer != null ) { try { m output writer . close ( ) ; } catch ( io e ) { log . w ( m tag , str , e ) ; } } }	closes the utility instance and unregisters any broadcastreceivers .
private void resolve files ( list < string > classpaths , map < string , string > files , string [ ] paths , string prefix ) { for ( string path : paths ) { string relative path = file handler . get name ( path ) ; if ( prefix != null ) { relative path = file handler . append ( prefix , relative path ) ; } if ( classpaths != null ) { classpaths . add ( relative path ) ; } if ( file handler . is directory ( path ) ) { string [ ] children = file handler . get children ( path ) ; if ( children != null && children . length != num ) { resolve files ( null , files , children , relative path ) ; } } else { files . put ( relative path , path ) ; } } }	resolves all files it finds into a map , with relative paths as the key and absolute path as the value .
public void test get instance ( ) throws exception { try { exemption mechanism . get instance ( ( string ) null , str ) ; fail ( str ) ; } catch ( no such provider exception pe ) { } try { exemption mechanism . get instance ( str , ( string ) null ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } }	javax / crypto / exemptionmechanism # getinstance ( string algorithm , string provider ) checks exception order.
public synchronized void reload configuration ( ) { properties = null ; final parameters . clear ( ) ; }	reload configuration from previously added resources.
protected void remove message processor ( message processor old message processor ) { synchronized ( message processors ) { if ( message processors . remove ( old message processor ) ) { old message processor . stop ( ) ; } } }	removes a messageprocessor from this sipstack .
x509 issuer serial ( x509 certificate cert ) { this ( cert . get issuer x500 principal ( ) , cert . get serial number ( ) ) ; }	construct an x509issuerserial from an x509certificate .
private void add to set ( object xml persist persist , i file , string set name ) throws io , core exception { collection < graph edge matcher descriptor > update set = load edge matchers ( persist , file ) ; persist updated bundle ( persist , file , update set , set name ) ; }	add the set to an existing file .
public void put bytes ( byte [ ] bytes ) { ensure capacity ( bytes . length ) ; system . arraycopy ( bytes , num , this . byte buffer , this . position , bytes . length ) ; this . position += bytes . length ; }	put an array of bytes in the buffer .
public static string array to delimited string ( object [ ] arr , string delim ) { if ( arr == null ) { return str ; } string buffer sb = new string buffer ( ) ; for ( int i = num ; i < arr . length ; i ++ ) { if ( i > num ) { sb . append ( delim ) ; } sb . append ( arr [ i ] ) ; } return sb . to string ( ) ; }	convenience method to return a string array as a delimited ( e.
public void clear all ( ) { final list < encoded image > old ; synchronized ( this ) { old = new array list < > ( m map . values ( ) ) ; m map . clear ( ) ; } for ( int i = num ; i < old . size ( ) ; i ++ ) { encoded image encoded image = old . get ( i ) ; if ( encoded image != null ) { encoded image . close ( ) ; } } }	removes all items from the stagingarea .
public static compiere color parse ( string attributes ) { compiere color cc = new compiere color ( ) ; try { if ( attributes != null && attributes . length ( ) > num ) cc . parse attributres ( attributes ) ; } catch ( exception e ) { log . severe ( str + attributes + str + e . to string ( ) ) ; } return cc ; }	parse attributes and return adempierecolor.
public synchronized static lua state new lua state ( ) { int i = get next state index ( ) ; lua state l = new lua state ( i ) ; states . add ( i , l ) ; return l ; }	method that creates a new instance of luastate.
static long check preamble size ( memory mem ) { final long cap = mem . get capacity ( ) ; if ( cap < num ) { throw not big enough ( cap , num ) ; } final long pre0 = mem . get long ( num ) ; final int pre longs = ( int ) ( pre0 & num ) ; final int required = math . max ( pre longs << num , num ) ; if ( cap < required ) { throw not big enough ( cap , required ) ; } return pre0 ; }	checks memory for capacity to hold the preamble and returns the first 8 bytes .
public int read ( ) throws io { if ( input stream == null ) { reopen ( ) ; } count ( num ) ; return input stream . read ( ) ; }	read from the file .
public void limit ( double x1 , double y1 , double x2 , double y2 ) { clip [ num ] = math . max ( clip [ num ] , x1 ) ; clip [ num ] = math . max ( clip [ num ] , y1 ) ; clip [ num ] = math . min ( clip [ num ] , x2 ) ; clip [ num ] = math . min ( clip [ num ] , y2 ) ; }	limit the clip such that it fits within the specified region .
public void shutdown ( ) { final long begin = system . current time millis ( ) ; log . info ( str ) ; log . info ( str + get task count ( scheduled pool ) + str ) ; log . info ( str + get task count ( instant pool ) + str ) ; log . info ( str + get task count ( long running pool ) + str ) ; log . info ( str + ( work stealing pool . get queued task count ( ) + work stealing pool . get queued submission count ( ) ) + str ) ; scheduled pool . shutdown ( ) ; instant pool . shutdown ( ) ; long running pool . shutdown ( ) ; work stealing pool . shutdown ( ) ; boolean success = bool ; try { success |= await termination ( num ) ; scheduled pool . set execute existing delayed tasks after shutdown policy ( bool ) ; scheduled pool . set continue existing periodic tasks after shutdown policy ( bool ) ; success |= await termination ( num ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } log . info ( str + success + str + ( system . current time millis ( ) - begin ) + str ) ; log . info ( str + get task count ( scheduled pool ) + str ) ; log . info ( str + get task count ( instant pool ) + str ) ; log . info ( str + get task count ( long running pool ) + str ) ; log . info ( str + ( work stealing pool . get queued task count ( ) + work stealing pool . get queued submission count ( ) ) + str ) ; work stealing pool . shutdown now ( ) ; }	shutdown all thread pools .
public static collection < inet address > to inet addresses ( collection < string > addrs , collection < string > host names ) throws ignite checked exception { set < inet address > res = new hash set < > ( addrs . size ( ) ) ; iterator < string > host names it = host names . iterator ( ) ; for ( string addr : addrs ) { string host name = host names it . has next ( ) ? host names it . next ( ) : null ; inet address inet addr = null ; if ( ! f . is empty ( host name ) ) { try { inet addr = inet address . get by name ( host name ) ; } catch ( unknown host exception ignored ) { } } if ( inet addr == null || inet addr . is loopback address ( ) ) { try { inet addr = inet address . get by name ( addr ) ; } catch ( unknown host exception ignored ) { } } if ( inet addr != null ) res . add ( inet addr ) ; } if ( res . is empty ( ) ) throw new ignite checked exception ( str + addrs + str + host names + str ) ; return res ; }	returns tha list of resolved inet addresses.
public static string remove new line chars ( string s ) { string ret string = null ; if ( ( s != null ) && ( s . length ( ) > num ) && ( s . index of ( str ) != - num ) ) { char [ ] chars = s . to char array ( ) ; int len = chars . length ; string buffer sb = new string buffer ( len ) ; for ( int i = num ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != str ) { sb . append ( c ) ; } } ret string = sb . to string ( ) ; } else { ret string = s ; } return ret string ; }	removes new line charactors .
void calculate counters ( ) { if ( ! is db ( ) ) return ; long time = system . current time millis ( ) ; int total = num ; write . lock ( ) ; try { count reset feeds and categories ( ) ; total += count feeds with unread ( ) ; count categories with unread ( ) ; count special categories ( total ) ; } finally { write . unlock ( ) ; } log . i ( tag , string . format ( str , total , ( system . current time millis ( ) - time ) ) ) ; }	set unread counters for feeds and categories according to real amount of unread articles.
protected void append html ( final string builder sbuf , final char ch ) { switch ( ch ) { case str : sbuf . append ( str ) ; break ; case str : sbuf . append ( str ) ; break ; case str : sbuf . append ( str ) ; break ; default : sbuf . append ( ch ) ; break ; } }	append a character to a buffer , escaping html meta - characters when needed .
private collection < var > migrate columns ( sql current table ) { list < var > vars = new array list < > ( ) ; string table type = current table . get entity type ( ) ; map < string , resource type . data type > columns = current table . get columns ( ) ; map < string , string > foreign columns = current table . get foreign key columns ( ) ; for ( string column : columns . key set ( ) ) { resource type . data type column type = columns . get ( column ) ; if ( foreign columns . contains key ( column ) ) { vars . add all ( migrate as relation ( table type , column , foreign columns . get ( column ) ) ) ; } else { vars . add all ( migrate as resource ( table type , column type , column ) ) ; } } return vars ; }	loop through each of the columns in the given table , migrating each as a resource or relation .
public int retrieve row count ( string table name ) throws sql { result set rs = null ; int row count = - num ; try { rs = statement . execute query ( str + table name ) ; rs . next ( ) ; row count = rs . get int ( num ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } return row count ; }	does a count on a given table .
public jar modifier ( file jar file ) throws jar exception , io { this . jar file = jar file ; jar file jar = new jar file ( jar file ) ; enumeration < ? extends jar entry > enumerator = jar . entries ( ) ; while ( enumerator . has more elements ( ) ) { jar entry current entry = ( jar entry ) enumerator . next element ( ) ; jar entry reset entry = new jar entry ( current entry . get name ( ) ) ; jar entries . put ( current entry . get name ( ) , reset entry ) ; } string manifest path = meta inf + seperator + str ; jar entry jar entry = jar . get jar entry ( manifest path ) ; if ( jar entry != null ) { enumeration < jar entry > entries = jar . entries ( ) ; while ( entries . has more elements ( ) ) { jar entry = ( jar entry ) entries . next element ( ) ; if ( manifest path . equals ignore case ( jar entry . get name ( ) ) ) { break ; } else { jar entry = null ; } } } manifest manifest = new manifest ( ) ; if ( jar entry != null ) { manifest . read ( jar . get input stream ( jar entry ) ) ; } this . manifest = manifest ; jar . close ( ) ; }	creates a new jarmodifier with the given archive to be modified.
@ override public int add attribute ( attribute a ) { if ( a == null ) { throw new illegal argument exception ( str ) ; } else { int index = - num ; attribute original = a ; a = ( attribute ) a . clone ( ) ; if ( unused column list . size ( ) > num ) { synchronized ( unused column list ) { if ( unused column list . size ( ) > num ) { index = unused column list . remove ( num ) ; attributes . set ( index , a ) ; } else { index = attributes . size ( ) ; attributes . add ( a ) ; } } } else { index = attributes . size ( ) ; attributes . add ( a ) ; } a . set table index ( index ) ; original . set table index ( index ) ; return index ; } }	adds the attribute to the list of attributes assigning it a free column index.
default b with ( string key , int value ) { return with ( key , integer . to string ( value ) ) ; }	associate the given value with the specified key .
public static < x > void sort top n ( x [ ] array , int offset , int limit , comparator < ? super x > comp ) { partition top n ( array , offset , limit , comp ) ; arrays . sort ( array , offset , ( int ) math . min ( ( long ) offset + limit , array . length ) , comp ) ; }	find the top limit values using given comparator and place them as in a full array sort , in descending order .
protected boolean is server transaction ( ) { return this instanceof sip ; }	a shortcut way of telling if we are a server transaction .
object add marked occurrence highlight ( int start , int end , mark occurrences highlight painter p ) throws bad location exception { document doc = text area . get document ( ) ; ui mapper = text area . get ui ( ) ; highlight info i = new layered highlight info ( ) ; i . painter = p ; i . p0 = doc . create position ( start ) ; i . p1 = doc . create position ( end - num ) ; marked occurrences . add ( i ) ; mapper . damage range ( text area , start , end ) ; return i ; }	adds a special " marked occurrence " highlight .
public static void read fully ( input stream in , byte buf [ ] , int off , int len ) throws io { int to read = len ; while ( to read > num ) { int ret = in . read ( buf , off , to read ) ; if ( ret < num ) { throw new io ( str ) ; } to read -= ret ; off += ret ; } }	does the readfully based on the input read .
public static void assume true ( boolean supplier assumption supplier , supplier < string > message supplier ) throws test aborted exception { if ( ! assumption supplier . get as boolean ( ) ) { throw test aborted exception ( message supplier . get ( ) ) ; } }	validate the given assumption .
public static string add to cart bulk ( http servlet request request , http servlet response response ) { string category id = request . get parameter ( str ) ; shopping cart cart = get cart object ( request ) ; delegator delegator = ( delegator ) request . get attribute ( str ) ; local dispatcher dispatcher = ( local dispatcher ) request . get attribute ( str ) ; shopping cart helper cart helper = new shopping cart helper ( delegator , dispatcher , cart ) ; string control directive ; map < string , object > result ; map < string , object > param map = util http . get parameter map ( request ) ; string catalog id = catalog worker . get current catalog id ( request ) ; result = cart helper . add to cart bulk ( catalog id , category id , param map ) ; control directive = process result ( result , request ) ; if ( control directive . equals ( error ) ) { return str ; } else { return str ; } }	adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add.
public void add frequent set ( frequent item set item set ) { frequent sets . add ( item set ) ; maximum set size = math . max ( item set . get number of items ( ) , maximum set size ) ; }	adds a frequent item set to this container.
private int skip from peek buffer ( int length ) { int bytes skipped = math . min ( peek buffer length , length ) ; update peek buffer ( bytes skipped ) ; return bytes skipped ; }	skips from the peek buffer .
protected workflow . method create remove volumes from cg ( uri vplex uri , uri cg uri , list < uri > vplex volume ur ) { return new workflow . method ( remove volumes from cg step , vplex uri , cg uri , vplex volume ur ) ; }	a method that creates the workflow method for removing vplex volumes from a consistency group .
private static int show urls prompt ( component parent , list < string > urls ) { string text = str ; for ( string url : urls ) { url = split url ( url ) ; text += url + str ; } string ok option = str ; if ( urls . size ( ) > num ) { ok option = str + urls . size ( ) + str ; } string [ ] options = { ok option , str } ; if ( urls . size ( ) == num ) { options = new string [ ] { ok option , str , str } ; } int chosen option = j . show option dialog ( parent , text , str , j . ok cancel option , j . question message , null , options , num ) ; return chosen option ; }	actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .
int convert mouse ( mouse event event ) { int result ; if ( panel font == null ) return ( no mouse ) ; int col off = event . get x ( ) - grid width - panel margin ; int col num = col off / horiz step ; int col rem = col off % horiz step ; if ( ( col num >= panel columns ) || ( col rem < text margin ) || ( col rem > ( horiz step - grid width - text margin ) ) ) { return ( no mouse ) ; } int row off = event . get y ( ) - grid width - panel margin ; int row num = row off / verti step ; int row rem = row off % verti step ; if ( ( row rem < text margin ) || ( row rem > ( verti step - grid width - text margin ) ) ) { return ( no mouse ) ; } result = corner index + ( row num * panel columns ) + col num ; if ( result >= cell count ) return ( no mouse ) ; return ( result ) ; }	convert mouse . convert mouse coordinates to a cell index . return < no_mouse > if the mouse is not well - centered on a defined character .
private static string compute regex string ( string original string , string old name , string new name ) { string builder builder = new string builder ( original string . length ( ) ) ; string old name or new name reg ex = string . format ( str , pattern . quote ( old name ) , pattern . quote ( new name ) ) ; int i = original string . index of ( old name ) ; if ( i >= num ) { int prev i = num ; while ( i >= num ) { builder . append ( pattern . quote ( original string . substring ( prev i , i ) ) ) ; builder . append ( old name or new name reg ex ) ; prev i = i ; i = original string . index of ( old name , i + old name . length ( ) ) ; } builder . append ( pattern . quote ( original string . substring ( prev i + old name . length ( ) , original string . length ( ) ) ) ) ; } return builder . to string ( ) ; }	computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .
public synchronized string generate call identifier ( string address ) { string date = long . to string ( system . current time millis ( ) + call id ++ + rand . next long ( ) ) ; byte cid [ ] = digester . digest ( date . get bytes ( ) ) ; string cid string = utils . to hex string ( cid ) ; return cid string + str + address ; }	generate a call identifier.
int parse hour ( string source , char pattern char , int offset ) throws parse exception { int min = ( pattern char == hour 1 letter || pattern char == hou 1 letter ) ? num : num ; int max = ( ( pattern char == hour letter || pattern char == hour 1 letter ) ? num : num ) + min ; return parse number ( source , offset , str , min , max ) - min ; }	parse a hour value.
public void do history ( key event e ) { if ( e . get source ( ) == m ) { switch ( e . get key code ( ) ) { case key event . vk up : if ( m > num ) { m -- ; string command = m . element at ( m ) ; m . set text ( command ) ; } break ; case key event . vk down : if ( m < m . size ( ) ) { m ++ ; string command = str ; if ( m < m . size ( ) ) { command = m . element at ( m ) ; } m . set text ( command ) ; } break ; default : break ; } } }	changes the currently displayed command line when certain keys are pressed.
public static reference binding [ ] substitute ( substitution substitution , reference binding [ ] original types ) { if ( original types == null ) return null ; reference binding [ ] substituted types = original types ; for ( int i = num , length = original types . length ; i < length ; i ++ ) { reference binding original type = original types [ i ] ; type binding substituted type = substitute ( substitution , original type ) ; if ( ! ( substituted type instanceof reference binding ) ) { return null ; } if ( substituted type != original type ) { if ( substituted types == original types ) { system . arraycopy ( original types , num , substituted types = new reference binding [ length ] , num , i ) ; } substituted types [ i ] = ( reference binding ) substituted type ; } else if ( substituted types != original types ) { substituted types [ i ] = original type ; } } return substituted types ; }	returns an array of types , where original types got substituted given a substitution.
private static collection < tcp > all known transports ( ) { set < tcp > s ; synchronized ( local endpoints ) { s = new hash set < tcp > ( local endpoints . size ( ) ) ; for ( linked list < tcp > ep list : local endpoints . values ( ) ) { tcp ep = ep list . get first ( ) ; s . add ( ep . transport ) ; } } return s ; }	returns the current list of known transports.
public void request seconds until idle lockout ( ) { operations . add ( password policy state operation type . get seconds until idle lockout ) ; }	returns the seconds until idle lockout .
@ request mapping ( value = str , method = { request method . get } ) @ response body private static list < string > show hive databases ( ) throws io { i hive client = hive client factory . get hive client ( ) ; list < string > results = null ; try { results = hive client . get hive db names ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new io ( e ) ; } return results ; }	show all databases in hive.
public void test neg neg first shorter ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , num , - num , - num , - num , num , num , num , num , - num , - num , num , - num , - num , num , - num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	and for two negative numbers ; the first is shorter.
private static double hacky adjuster ( double f ) { double tmp = math . sqrt ( num - f ) ; return ( f <= num ) ? tmp : tmp + ( num * ( f - num ) ) ; }	this hackyadjuster is tightly coupled with the width of the confidence interval normally specified with number of standard deviations.
private static object from string ( string s ) throws io , class not found exception { byte [ ] data = base64 . decode ( s , base64 . default ) ; object input stream ois = new object input stream ( new byte array input stream ( data ) ) ; object o = ois . read object ( ) ; ois . close ( ) ; return o ; }	read the object from base64 string .
private boolean copy document ( search document new document , search document document , map < string , set < string > > removed properties ) { boolean mutated = bool ; for ( string old field name : document . get property names ( ) ) { new document . add property ( old field name ) ; list < string > old values = document . get property ( old field name ) ; if ( old values != null ) { set < string > objects removed = ( removed properties != null ) ? removed properties . get ( old field name ) : null ; for ( string old value : old values ) { if ( ( objects removed != null ) && ( objects removed . contains ( old value ) ) ) { mutated = bool ; } else { add property ( old field name , old value , new document ) ; } } } } return mutated ; }	creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter.
public svd ( matrix arg ) { this ( arg , bool , bool , bool ) ; }	construct the singular value decomposition.
public void unlock for clear ( internal distributed member locker ) { synchronized ( this . clear lock sync ) { internal distributed system instance = internal distributed system . get any instance ( ) ; if ( instance != null && logger . is debug enabled ( ) ) { logger . debug ( str , locker , system . identity hash code ( this ) ) ; } if ( this . lock owner != null && ! locker . equals ( this . lock owner ) ) { if ( instance != null && logger . is debug enabled ( ) ) { logger . debug ( str , lock owner ) ; } return ; } unlock version generation ( locker ) ; } }	unlocks version generation for clear ( ) operations.
public unicast ref ( ) { }	create a new ( empty ) unicast remote reference .
private static int last index of ( object o , @ not null object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= num ; i -- ) { if ( elements [ i ] == null ) { return i ; } } } else { for ( int i = index ; i >= num ; i -- ) { if ( o . equals ( elements [ i ] ) ) { return i ; } } } return - num ; }	static version of lastindexof .
public void write ( byte buffer buffer ) throws io { buffer . position ( num ) ; if ( m file channel . size ( ) + buffer . capacity ( ) < m max size ) { while ( buffer . has remaining ( ) ) { m file channel . write ( buffer ) ; } update wave file size ( ) ; } else { int remaining = ( int ) ( m max size - m file channel . size ( ) ) ; remaining -= ( int ) ( remaining % m audio format . get frame size ( ) ) ; byte [ ] bytes = buffer . array ( ) ; byte buffer current = byte buffer . wrap ( arrays . copy of ( bytes , remaining ) ) ; byte buffer next = byte buffer . wrap ( arrays . copy of range ( bytes , remaining , bytes . length ) ) ; while ( current . has remaining ( ) ) { m file channel . write ( current ) ; } update wave file size ( ) ; rollover ( ) ; while ( next . has remaining ( ) ) { m file channel . write ( next ) ; } update wave file size ( ) ; } }	writes the buffer contents to the file.
public static double dmod d ( double lhs , double rhs ) { return rhs != num ? lhs - rhs * math . floor ( lhs / rhs ) : double . n ; }	take modulo for double numbers according to lua math , and return a double result .
public void test max less ( ) { byte a bytes [ ] = { num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . max ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert true ( str , result . signum ( ) == num ) ; }	max ( biginteger val ).
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io thread . is alive ( ) && m state != idle ) { wait ( ) ; } } catch ( interrupted exception ex ) { } } else { notify all ( ) ; } }	function used to stop code that calls accepttrainingset.
public void move ( mouse event e ) { d pnt = get projection point ( e ) ; int x = ( int ) pnt . get x ( ) ; int y = ( int ) pnt . get y ( ) ; if ( poly . get render type ( ) == om . rendertype offset ) { gpm = new offset grab point ( x , y ) ; gpm . clear ( ) ; } else { gpm = gpo ; gpm . clear ( ) ; gpm . set ( x , y ) ; } add poly grab points to ogp ( gpm ) ; moving point = gpm ; }	called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly.
public float buffer put ( float [ ] src , int src offset , int float count ) { arrays . check offset and count ( src . length , src offset , float count ) ; if ( float count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + float count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .
public static boolean contain ip ( int cidr prefix , int cidr mask bits , int ip ) { boolean matched = bool ; int bits to shift = num - cidr mask bits ; if ( bits to shift > num ) { cidr prefix = cidr prefix > > bits to shift ; ip = ip > > bits to shift ; cidr prefix = cidr prefix << bits to shift ; ip = ip << bits to shift ; } if ( cidr prefix != ip ) { matched = bool ; } return matched ; }	check whether the cidr address contains the ip address.
protected static boolean lock ( string service name , object name ) { distributed lock service service = distributed lock service . get service named ( service name ) ; boolean locked = service . lock ( name , num , - num ) ; return boolean . value of ( locked ) ; }	accessed via reflection . do not remove.
protected int check known cookie ( ) { int ret val = num ; debug . message ( str , adaptive ) ; http servlet request req = get http servlet request ( ) ; if ( req != null ) { cookie cookie = cookie utils . get cookie from req ( req , known cookie name ) ; if ( cookie != null ) { if ( known cookie value . equals ignore case ( cookie utils . get cookie value ( cookie ) ) ) { ret val = known cookie score ; } } } if ( known cookie value == null ) { known cookie value = str ; } if ( known cookie save ) { post auth n . put ( str , known cookie name ) ; post auth n . put ( str , known cookie value ) ; } if ( ! known cookie invert ) { ret val = known cookie score - ret val ; } return ret val ; }	check to see if the client has a cookie with optional value.
public file [ ] select import files ( final string title , boolean multiple selection , file name extension filter [ ] file name extension filters ) { if ( boolean . parse boolean ( system . get property ( str , boolean . to string ( os . is mac ( ) ) ) ) ) { file dialog import dialog = file dialogs . get ( title ) ; if ( import dialog == null ) { import dialog = new file dialog ( this , title , file dialog . load ) ; file dialogs . put ( title , import dialog ) ; } import dialog . set visible ( bool ) ; if ( import dialog . get file ( ) != null ) { return new file [ ] { new file ( import dialog . get directory ( ) , import dialog . get file ( ) ) } ; } } else { j import chooser = file choosers . get ( title ) ; if ( import chooser == null ) { import chooser = new j ( utils . get cwd ( ) ) ; import chooser . set multi selection enabled ( multiple selection ) ; for ( file name extension filter file name extension filter : file name extension filters ) { import chooser . set file filter ( file name extension filter ) ; } import chooser . set dialog title ( title ) ; file choosers . put ( title , import chooser ) ; } int return val = import chooser . show open dialog ( this ) ; if ( return val == j . approve option ) { if ( import chooser . is multi selection enabled ( ) ) { return import chooser . get selected files ( ) ; } else { return new file [ ] { import chooser . get selected file ( ) } ; } } } return null ; }	use the native file dialog on the mac because the swing one is bad.
public gt ( string a unlocalized , short a offset , short a item amount ) { super ( a unlocalized ) ; set creative tab ( api . tab gregtech materials ) ; set has subtypes ( bool ) ; set max damage ( num ) ; m enabled items = new bit set ( a item amount ) ; m visible items = new bit set ( a item amount ) ; m offset = ( short ) math . min ( num , a offset ) ; m item amount = ( short ) math . min ( a item amount , num - m offset ) ; m icon list = new i [ a item amount ] [ num ] ; s instances . put ( get unlocalized name ( ) , this ) ; }	creates the item using these parameters .
public static byte [ ] read fully ( input stream in ) throws io { try { return read fully no close ( in ) ; } finally { in . close ( ) ; } }	returns a byte [ ] containing the remainder of ' in ' , closing it when done .
public static parsed sql parse sql statement ( string sql ) { set < string > named parameters = new hash set < string > ( ) ; parsed sql parsed sql = new parsed sql ( sql ) ; char [ ] statement = sql . to char array ( ) ; int named parameter count = num ; int unnamed parameter count = num ; int total parameter count = num ; int i = num ; while ( i < statement . length ) { int skip to position = skip comments and quotes ( statement , i ) ; if ( i != skip to position ) { if ( skip to position >= statement . length ) { break ; } i = skip to position ; } char c = statement [ i ] ; if ( c == str || c == str ) { int j = i + num ; if ( j < statement . length && statement [ j ] == str && c == str ) { i = i + num ; continue ; } while ( j < statement . length && ! is parameter separator ( statement [ j ] ) ) { j ++ ; } if ( j - i > num ) { string parameter = sql . substring ( i + num , j ) ; if ( ! named parameters . contains ( parameter ) ) { named parameters . add ( parameter ) ; named parameter count ++ ; } parsed sql . add named parameter ( parameter , i , j ) ; total parameter count ++ ; } i = j - num ; } else { if ( c == str ) { unnamed parameter count ++ ; total parameter count ++ ; } } i ++ ; } parsed sql . set named parameter count ( named parameter count ) ; parsed sql . set unnamed parameter count ( unnamed parameter count ) ; parsed sql . set total parameter count ( total parameter count ) ; return parsed sql ; }	parse the sql statement and locate any placeholders or named parameters.
final void put long ( int offset , long value ) { unsafe . put long ( offset + address , value ) ; }	writes a long at the specified offset from this native object ' s base address .
public boolean on event ( action result result ) { synchronized ( this ) { string request id = result . get response info ( ) . m request id ; if ( request id == null ) { return bool ; } boolean event removed = m request ids . remove ( request id ) ; if ( event removed ) { class key = null ; for ( class type : m last request id by type . key set ( ) ) { if ( request id . equals ( m last request id by type . get ( type ) ) ) { key = type ; break ; } } if ( key != null ) { m last request id by type . remove ( key ) ; } } return event removed ; } }	required method to be called if you are using requestkeeper to funnel your requests .
public static string gensalt ( int log rounds , secure random random ) { string buffer rs = new string buffer ( ) ; byte rnd [ ] = new byte [ bcrypt salt len ] ; random . next bytes ( rnd ) ; rs . append ( str ) ; if ( log rounds < num ) { rs . append ( str ) ; } if ( log rounds > num ) { throw new illegal argument exception ( str ) ; } rs . append ( integer . to string ( log rounds ) ) ; rs . append ( str ) ; rs . append ( encode base64 ( rnd , rnd . length ) ) ; return rs . to string ( ) ; }	generate a salt for use with the bcrypt.
public void check key ( object key ) throws partitioned region exception { if ( ! has hash ) { return ; } if ( key == null ) { return ; } int expected = key . hash code ( ) ; if ( expected == key hash ) { return ; } throw new partitioned region exception ( str + expected + str + key hash ) ; }	if possible , validate the given key ' s hashcode against any that was returned by the peer .
public string buffer number to string ( final string str number to convert ) { string str number = str , sign bit = str ; if ( str number to convert . starts with ( str ) ) { str number = str + str number to convert . substring ( num , str number to convert . length ( ) ) ; sign bit = str ; } else str number = str + str number to convert ; final decimal format dft = new decimal format ( str ) ; final string strtemp = str + dft . format ( double . parse double ( str number ) ) ; string buffer strb number = new string buffer ( strtemp ) ; final int int len = strb number . length ( ) ; for ( int i = int len - num ; i > num ; i = i - num ) strb number . insert ( i , str ) ; if ( sign bit . equals ( str ) ) strb number = strb number . insert ( num , str ) ; return strb number ; }	function to format amount into to indaian rupees format.
private void run init script if required ( string url , connection connection ) throws sql { matcher matcher = initscript matching pattern . matcher ( url ) ; if ( matcher . matches ( ) ) { string init script path = matcher . group ( num ) ; try { url resource = resources . get resource ( init script path ) ; string sql = resources . to string ( resource , charsets . utf 8 ) ; script utils . execute sql script ( connection , init script path , sql ) ; } catch ( io | illegal argument exception e ) { logger . warn ( str , init script path ) ; throw new sql ( str + init script path , e ) ; } catch ( script exception e ) { logger . error ( str , init script path , e ) ; throw new sql ( str + init script path , e ) ; } } }	run an init script from the classpath .
private static int parse int ( string value , int begin index , int end index ) throws number format exception { if ( begin index < num || end index > value . length ( ) || begin index > end index ) { throw new number format exception ( value ) ; } int i = begin index ; int result = num ; int digit ; if ( i < end index ) { digit = character . digit ( value . char at ( i ++ ) , num ) ; if ( digit < num ) { throw new number format exception ( str + value ) ; } result = - digit ; } while ( i < end index ) { digit = character . digit ( value . char at ( i ++ ) , num ) ; if ( digit < num ) { throw new number format exception ( str + value ) ; } result *= num ; result -= digit ; } return - result ; }	parse an integer located between 2 given offsets in a string.
public static void println ( object x ) { out . println ( x ) ; }	prints an object to this output stream and then terminates the line .
public static void check finite ( final double [ ] val ) throws math illegal argument exception { for ( int i = num ; i < val . length ; i ++ ) { final double x = val [ i ] ; if ( double . is infinite ( x ) || double . is na n ( x ) ) { throw new math illegal argument exception ( localized core formats . not finite number , x ) ; } } }	check that all the elements are real numbers .
private void init keyboard buttons ( keyboard view view ) { m buttons = new array list < > ( ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 0 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 1 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 2 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 3 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 4 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 5 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 6 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 7 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 8 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button 9 ) ) ; m buttons . add ( ( keyboard button view ) view . find view by id ( r . id . pin code button clear ) ) ; for ( view button : m buttons ) { button . set on click listener ( this ) ; } }	init the keyboard buttons ( onclicklistener ).
public static boolean is auto new ( properties ctx , int window no ) { if ( ctx == null ) throw new illegal argument exception ( str ) ; string s = get context ( ctx , window no , str , bool ) ; if ( s != null ) { if ( s . equals ( str ) ) return bool ; else return bool ; } return is auto new ( ctx ) ; }	is window auto new record ( if not set use default ).
private static string find relative path ( string file path , string dir path ) { string rel path ; if ( ! dir path . ends with ( file . separator ) ) { dir path = dir path + file . separator ; } if ( file path . starts with ( dir path ) ) { rel path = file path . substring ( dir path . length ( ) ) ; } else { rel path = file path ; } return rel path ; }	determine the path to the file relative to the given directory path .
public void reset singleton ( ) { root = null ; tmp file counter . set ( num ) ; accessed files . clear ( ) ; should all throw io = bool ; classes that should throw io . clear ( ) ; synchronized ( leaking resources ) { for ( leaking resource resource : leaking resources ) { try { resource . release ( ) ; } catch ( exception e ) { logger . warn ( str + e . get message ( ) , e ) ; } } leaking resources . clear ( ) ; } }	reset the internal state of this singleton.
public void test and not neg neg first longer ( ) { byte a bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and not ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	andnot for two negative numbers ; the first is longer.
public static string generate string of characters ( int count ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < count ; i ++ ) { sb . append ( characters . char at ( ( int ) ( math . random ( ) * characters . length ( ) ) ) ) ; } return sb . to string ( ) ; }	creates a random string which only consists of letters.
private exchange rate manager ( ) { if ( system . get property ( str ) == null ) throw new unsupported operation exception ( str ) ; add known rates ( ) ; }	constructs a new exchangeratemanager and initialises the most used rates.
public void remove attribute ( string name ) { if ( name != null ) if ( attributes list != null ) { for ( int i = num ; i < attributes list . size ( ) ; i ++ ) { object o = attributes list . element at ( i ) ; if ( o instanceof attribute field ) { attribute field a = ( attribute field ) o ; try { string n = a . get name ( ) ; if ( n != null ) { if ( name . equals ( n ) ) { attributes list . remove ( a ) ; } } } catch ( sdp parse exception e ) { } } } } }	removes the attribute specified by the value parameter .
@ override public void evict ( string key ) { key = safety key ( key ) ; final file file = new file ( cache directory , key ) ; file . delete ( ) ; }	delete the object previously saved .
public static boolean is unique contraint error ( exception e ) { if ( db . is postgre sql ( ) ) return is sql ( e , str ) ; return is error code ( e , num ) ; }	check if unique constraint exception ( aka ora - 00001 ).
configuration error ( string msg , exception x ) { super ( msg ) ; this . exception = x ; }	construct a new instance with the specified detail string and exception .
void add fill components ( container panel , int [ ] cols , int [ ] rows ) { dimension filler = new dimension ( num , num ) ; boolean filled cell 11 = bool ; cell constraints cc = new cell constraints ( ) ; if ( cols . length > num && rows . length > num ) { if ( cols [ num ] == num && rows [ num ] == num ) { panel . add ( box . create rigid area ( filler ) , cc . xy ( num , num ) ) ; filled cell 11 = bool ; } } for ( int index = num ; index < cols . length ; index ++ ) { if ( cols [ index ] == num && filled cell 11 ) { continue ; } panel . add ( box . create rigid area ( filler ) , cc . xy ( cols [ index ] , num ) ) ; } for ( int index = num ; index < rows . length ; index ++ ) { if ( rows [ index ] == num && filled cell 11 ) { continue ; } panel . add ( box . create rigid area ( filler ) , cc . xy ( num , rows [ index ] ) ) ; } }	adds fill components to empty cells in the first row and first column of the grid.
private void insert used context prefixes ( ) { int unknown prefixes count = unknown prefixes in xml . size ( ) ; if ( unknown prefixes count > num ) { string builder context prefixes = new string builder ( num ) ; element info top element = peek stack ( ) ; for ( int i = num ; i < unknown prefixes count ; i ++ ) { string prefix = unknown prefixes in xml . get ( i ) ; string namespace = top element . get namespace ( prefix ) ; if ( namespace != null ) { append namespace decl ( context prefixes , prefix , namespace ) ; } } int end of first start tag = char buf . index of ( str ) ; char buf . insert ( end of first start tag , context prefixes . to string ( ) ) ; } unknown prefixes in xml . clear ( ) ; }	inserts prefix mappings from an xml literal ' s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .
public void add put time nanos ( long duration ) { put time nanos . add and get ( duration ) ; if ( delegate != null ) delegate . add put time nanos ( duration ) ; }	increments the put time accumulator .
public static list < integer > precompute hashes ( byte [ ] data , long tweak ) { array list < integer > list = new array list < > ( max hash funcs ) ; for ( int i = num ; i < max hash funcs ; ++ i ) { list . add ( murmurhash3bit ( i , data , tweak ) ) ; } return list ; }	precompute hashes used to set mask bits for a data .
public int elevation at ( float lat , float lon ) { if ( frame is valid == bool ) { if ( lat >= dsi . sw lat && lat <= dsi . ne lat && lon >= dsi . sw lon && lon <= dsi . ne lon ) { int lat index = math . round ( ( lat - dsi . sw lat ) * num / uhl . lat post interval ) ; int lon index = math . round ( ( lon - dsi . sw lon ) * num / uhl . lon post interval ) ; if ( elevations [ lon index ] == null ) read data record ( lon index ) ; return ( int ) elevations [ lon index ] [ lat index ] ; } } return - num ; }	the elevation at the closest sw post to the given lat / lon.
observed object create observed object ( object name object ) { return new observed object ( object ) ; }	factory method for observedobject creation .
private void delete children ( element container ) { while ( container . has child nodes ( ) ) { container . remove child ( container . get last child ( ) ) ; } }	delete the children of the element.
private void save initial child state ( faces context faces context , ui component ) { if ( component instanceof editable value holder && ! component . is transient ( ) ) { string client id = component . get client id ( faces context ) ; saved state state = new saved state ( ) ; initial child state . put ( client id , state ) ; state . populate ( ( editable value holder ) component ) ; } iterator < ui > iterator = component . get facets and children ( ) ; while ( iterator . has next ( ) ) { save child state ( faces context , iterator . next ( ) ) ; } }	recursively create the initial state for the given component .
public boolean is overlap ( ) { set < brd item > start contacts = get start contacts ( ) ; set < brd item > end contacts = get end contacts ( ) ; for ( brd item end contact : end contacts ) { if ( start contacts . contains ( end contact ) ) return bool ; } return bool ; }	looks , if this trace is connected to the same object at its start and its end point.
static object ensure not null ( location location , object value ) { if ( value == null ) { throw new eval exception ( location , str ) ; } return value ; }	ensure the given value is not null and return it .
public static final array list read list xml ( input stream in ) throws xml pull parser exception , io { xml pull parser parser = xml . new pull parser ( ) ; parser . set input ( in , null ) ; return ( array list ) read value xml ( parser , new string [ num ] ) ; }	read an arraylist from an inputstream containing xml.
private static string pad right ( string s , int min length ) { return string . format ( str + min length + str , s ) ; }	adds padding to the end of a string with a repeating character if the string ' s length is less than the minimum length.
@ override public enumeration < string > enumerate measures ( ) { vector < string > new vector = new vector < string > ( num ) ; new vector . add element ( str ) ; return new vector . elements ( ) ; }	returns an enumeration of the additional measure names.
protected synchronized void on send task completed ( record buffer < r > buffer ) { logger . trace ( str , name ( ) , buffer ) ; active send tasks . decrement and get ( ) ; }	this method should not raise any exceptions .
public void add preferences button ( ) { j prefs button = new j ( str ) ; prefs button . set hide action text ( bool ) ; prefs button . set action ( raster plot actions . get properties dialog action ( this ) ) ; button panel . add ( prefs button ) ; }	add button for showing preferences .
public void clear unused ( config impl config ) { system out . print date ( config . get out writer ( ) , str + size ( ) + str + max size + str ) ; if ( size ( ) > max size ) { object [ ] keys = keys ( ) ; long key list list = new long key list ( ) ; for ( int i = num ; i < keys . length ; i ++ ) { page source ps = get page source ( keys [ i ] , bool ) ; long update time = ps . get last access time ( ) ; if ( update time + timeout < system . current time millis ( ) ) { long add = ( ( ps . get access count ( ) - num ) * num ) ; if ( add > timeout ) add = timeout ; list . add ( update time + add , keys [ i ] ) ; } } while ( size ( ) > max size ) { object key = list . shift ( ) ; if ( key == null ) break ; remove ( key ) ; } } }	clear unused pages from page pool.
public static grid field [ ] create fields ( properties ctx , int window no , int tab no , int ad id ) { array list < vo > list vo = new array list < vo > ( ) ; int ad id = num ; boolean read only = bool ; string sql = vo . get sql ( ctx ) ; prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql , null ) ; pstmt . set int ( num , ad id ) ; result set rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { vo vo = vo . create ( ctx , window no , tab no , ad id , ad id , read only , rs ) ; list vo . add ( vo ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } grid field [ ] ret value = new grid field [ list vo . size ( ) ] ; for ( int i = num ; i < list vo . size ( ) ; i ++ ) ret value [ i ] = new grid field ( ( vo ) list vo . get ( i ) ) ; return ret value ; }	create fields . used by apanel . cmd_find and viewer . cmd_find.
public short interleaved raster ( sample model sample model , data buffer data buffer , point origin ) { this ( sample model , data buffer , new rectangle ( origin . x , origin . y , sample model . get width ( ) , sample model . get height ( ) ) , origin , null ) ; }	constructs a shortinterleavedraster with the given samplemodel and databuffer.
private void copy carbon data file to carbon store path ( string local file name ) throws carbon data writer exception { long copy start time = system . current time millis ( ) ; logger . info ( str + local file name + str + carbon data directory path ) ; try { carbon file local carbon file = file factory . get carbon file ( local file name , file factory . get file type ( local file name ) ) ; string carbon file path = carbon data directory path + local file name . substring ( local file name . last index of ( file . separator ) ) ; copy local file to carbon store ( carbon file path , local file name , carbon common constants . bytebuffer size , get max of block and file size ( file size in bytes , local carbon file . get size ( ) ) ) ; } catch ( io e ) { throw new carbon data writer exception ( str ) ; } logger . info ( str + local file name + str + ( system . current time millis ( ) - copy start time ) ) ; }	this method will copy the given file to carbon store location.
@ override public boolean fling backward ( selector obj , boolean is vertical ) throws ui object not found exception { ui scrollable scrollable = new ui scrollable ( obj . to ui selector ( ) ) ; if ( is vertical ) scrollable . set as vertical list ( ) ; else scrollable . set as horizontal list ( ) ; return scrollable . fling backward ( ) ; }	performs a backwards fling action with the default number of fling steps ( 5 ).
protected static double to double ( string s ) { try { return double . parse double ( s ) ; } catch ( exception e ) { test case . fail ( str + s + str + throwable to string ( e ) ) ; return double . n ; } }	attempts to parse the string as double.
public void add listener ( final i < t > listener ) { m listeners . add listener ( listener ) ; }	adds a listener that is notified about changes in the filter .
public boolean is stable ( ) { return my features . contains ( feature stable ) ; }	returns true if gapis is considered stable ( non - experimental ) :.
public static void calc text size ( paint paint , string demo text , f output f ) { rect r = m calc text size rect ; r . set ( num , num , num , num ) ; paint . get text bounds ( demo text , num , demo text . length ( ) , r ) ; output f . width = r . width ( ) ; output f . height = r . height ( ) ; }	calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e.
protected void perform defaults ( ) { super . perform defaults ( ) ; initialize values ( ) ; verify validation ( ) ; }	defaults was clicked . restore the svn preferences to their default values.
public string to string ( ) { final string builder buf = new string builder ( str ) ; for ( int i = num , end = pos - num ; i < end ; i ++ ) { buf . append ( data [ i ] ) ; buf . append ( str ) ; } if ( size ( ) > num ) { buf . append ( data [ pos - num ] ) ; } buf . append ( str ) ; return buf . to string ( ) ; }	returns a string representation of the list , front to back .
public static void write ( int x1 , int y1 , image image , int image width , int image height , link properties properties , data output stream dos ) throws io , interrupted exception { int [ ] pixels = new int [ image width * image height ] ; pixel grabber pixelgrabber = new pixel grabber ( image , num , num , image width , image height , pixels , num , image width ) ; pixelgrabber . grab pixels ( ) ; link raster . write ( x1 , y1 , image width , image height , pixels , properties , dos ) ; }	write an image , x / y placement with an imageicon .
public void state changed ( change event evt ) { int scale = slider . get value ( ) ; value . set text ( str + string . value of ( scale ) ) ; size . set text ( str + ( width * scale ) + str + ( height * scale ) + str ) ; preview . repaint ( ) ; }	monitor changes to the scale slider .
public static void write to file ( string content , file dst file ) throws io { buffered writer buffered writer = new buffered writer ( new file writer ( dst file , bool ) ) ; buffered writer . write ( content ) ; buffered writer . close ( ) ; }	save string into the file.
public static boolean is file url ( url url ) { string protocol = url . get protocol ( ) ; return ( url protocol file . equals ( protocol ) || url protocol vfsfile . equals ( protocol ) || url protocol vfs . equals ( protocol ) ) ; }	determine whether the given url points to a resource in the file system , that is , has protocol " file " , " vfsfile " or " vfs " .
private void update status ( string relay state , int current status ) { integer tmp = ( integer ) current status map . get ( relay state ) ; if ( tmp != null ) { int previous status = tmp . int value ( ) ; switch ( previous status ) { case logout succeeded status : if ( current status > previous status ) { current status map . put ( relay state , new integer ( current status ) ) ; } break ; case logout failed status : if ( current status < logout failed status ) { current status map . put ( relay state , new integer ( logout partial status ) ) ; } break ; default : break ; } } else { current status map . put ( relay state , new integer ( current status ) ) ; } }	updates logout status based on current status and what stored in the internal map .
public static int [ ] oid str to ints ( string oid ) throws io { int length = oid . length ( ) ; if ( oid . char at ( length - num ) == str ) { throw new io ( str + oid ) ; } int [ ] result = new int [ length / num + num ] ; int number = num ; for ( int i = num ; i < length ; i ++ ) { int value = num ; int pos = i ; for ( ; i < length ; i ++ ) { char ch = oid . char at ( i ) ; if ( ( ch < str ) || ( ch > str ) ) { break ; } value = num * value + ( ch - str ) ; } if ( i == pos ) { throw new io ( str + oid ) ; } result [ number ++ ] = value ; if ( i == length ) { break ; } char ch = oid . char at ( i ) ; if ( ch != str ) { throw new io ( str + oid ) ; } } if ( number < num ) { throw new io ( str + oid ) ; } return arrays . copy of range ( result , num , number ) ; }	converts oid into array of ints .
public static set < string > list servers ( sso sso token , string site name ) throws sms , sso , configuration exception { set < string > members = new hash set < > ( ) ; string site id = get site id ( sso token , site name ) ; if ( site id != null ) { set < string > all servers = server configuration . get servers ( sso token ) ; for ( string svr : all servers ) { if ( server configuration . belong to site ( sso token , svr , site name ) ) { members . add ( svr ) ; } } } return members ; }	returns the server instance names that belong to a site .
public static generic object editor dialog create dialog ( container parent ) { return create dialog ( parent , null ) ; }	creates a modal dialog for the parent .
public static boolean contains in line features ( styled layer descriptor sld ) { if ( sld != null ) { for ( styled layer layer : sld . layers ( ) ) { if ( layer instanceof user layer ) { user layer user layer = ( user layer ) layer ; if ( user layer . get inline feature datastore ( ) != null ) { return bool ; } } } } return bool ; }	checks to see if sld contains inline features .
public byte decode buffer ( input stream in ) [ ] throws io { byte array output stream out stream = new byte array output stream ( ) ; decode buffer ( in , out stream ) ; return ( out stream . to byte array ( ) ) ; }	decode the contents of the inputstream into a buffer .
public static void run finalization ( ) { runtime . run finalization ( ) ; }	provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .
private void display all string defined in string xml ( ) { simple icon font text view text view = ( simple icon font text view ) find view by id ( r . id . text view 1 ) ; list < string > list = new array list < > ( ) ; list . add ( get string ( r . string . gems logo ) ) ; string text = text utils . join ( str , list ) ; text view . set text ( text ) ; }	display the string defined in the string xml file : iconfont_string . xml.
public static void check http ( http servlet request request ) throws servlet exception { int max content length = saml . get max content length ( ) ; if ( max content length != num ) { int length = request . get content length ( ) ; if ( length == - num ) { throw new servlet exception ( bundle . get string ( str ) ) ; } if ( length > max content length ) { if ( debug . message enabled ( ) ) { debug . message ( str + str + length ) ; } throw new servlet exception ( bundle . get string ( str ) ) ; } } }	checks content length of a http request to avoid dos attack.
public void add foreign key constraint ( string name , string source field , string target field , string target table ) { foreign key constraint foreign key = new foreign key constraint ( name , source field , target field , target table ) ; add foreign key constraint ( foreign key ) ; }	public : add a foreign key constraint to the table.
@ override public void on create ( bundle saved instance state ) { super . on create ( saved instance state ) ; m handler = new handler ( ) ; set content view ( r . layout . voice recognition ) ; button speak button = ( button ) find view by id ( r . id . btn speak ) ; m list = ( list view ) find view by id ( r . id . list ) ; m supported language view = ( spinner ) find view by id ( r . id . supported languages ) ; package manager pm = get package manager ( ) ; list < resolve info > activities = pm . query intent activities ( new intent ( recognizer intent . action recognize speech ) , num ) ; if ( activities . size ( ) != num ) { speak button . set on click listener ( this ) ; } else { speak button . set enabled ( bool ) ; speak button . set text ( str ) ; } refresh voice settings ( ) ; }	called with the activity is first created .
public void push ( notification notification , notification response listener listener ) { final string notification topic = notification . get topic ( ) ; final string topic = notification topic == null ? default topic : notification topic ; request req = utils . build request ( client , topic , notification , gateway ) ; semaphore . acquire uninterruptibly ( ) ; req . send ( new response listener ( semaphore , notification , listener ) ) ; }	sends a notification to the apple push notification service .
private static void append json ( string builder json , string key , string value ) throws unsupported encoding exception { boolean is value numeric = bool ; try { if ( value . equals ( str ) || ! value . ends with ( str ) ) { double . parse double ( value ) ; is value numeric = bool ; } } catch ( number format exception e ) { is value numeric = bool ; } if ( json . char at ( json . length ( ) - num ) != str ) { json . append ( str ) ; } json . append ( escape json ( key ) ) ; json . append ( str ) ; if ( is value numeric ) { json . append ( value ) ; } else { json . append ( escape json ( value ) ) ; } }	appends a json encoded key / value pair to the given string builder .
public void update from resource ( ) { for ( string resource : resources ) { input stream is = class loader . get system resource as stream ( resource ) ; linked hash map < entry type , linked hash map < string , config entry > > parse result = parse ( is ) ; for ( entry type type : my map . key set ( ) ) { linked hash map < string , config entry > data mappings = my map . get ( type ) ; linked hash map < string , config entry > resource mappings = parse result . get ( type ) ; linked hash map < string , config entry > temp mappings = new linked hash map < string , config entry > ( ) ; linked hash set < string > keys = new linked hash set < string > ( ) ; keys . add all ( data mappings . key set ( ) ) ; keys . add all ( resource mappings . key set ( ) ) ; for ( string key : keys ) { if ( resource mappings . contains key ( key ) ) { temp mappings . put ( key , resource mappings . get ( key ) ) ; } else { temp mappings . put ( key , data mappings . get ( key ) ) ; } } my map . put ( type , temp mappings ) ; } } }	maintains order of all keys , but overwrites all data keys with values from resources .
private void deselect ( final int index , final boolean should fire events ) { check widget ( ) ; if ( index < num || index >= items . size ( ) ) { return ; } final dl item = selection . remove ( index ) ; if ( should fire events ) { fire selection event ( item ) ; } final list < dl > deselected items = new array list < dl > ( ) ; item . set last action ( last action . deselection ) ; deselected items . add ( item ) ; if ( should fire events ) { fire selection change event ( deselected items ) ; } redraw tables ( ) ; }	deselects the item at the given zero - relative index in the receiver.
public boolean is leaf ( object nd ) { node node = ( node ) nd ; return ! node . has child nodes ( ) ; }	gets the leaf attribute of the domtreemodel object.
public void add listener ( listener listener ) { m listeners . add ( listener ) ; notify service discovered ( m matching drones ) ; }	add a listener all callbacks of the interface listener will be called within this function should be called in the main thread.
@ override boolean equals ( object obj ) ;	checks if this date - time is equal to another date - time , including the chronology.
private double [ ] parse vector ( string s ) { string [ ] entries = whitespace pattern . split ( s ) ; double [ ] d = new double [ entries . length ] ; for ( int i = num ; i < entries . length ; i ++ ) { try { d [ i ] = parse util . parse double ( entries [ i ] ) ; } catch ( number format exception e ) { throw new abort exception ( str ) ; } } return d ; }	parse a string into a vector . todo : move this into utility package ?.
@ override public void write external ( object output out ) throws io { super . write external ( out ) ; out . write double ( knn distance ) ; }	calls the super method and writes the knn distance of this entry to the specified stream .
public session wrapper ( session ses ) { this . ses = ses ; this . time = system . current time millis ( ) ; }	creates instance of cassandra driver session wrapper .
public static list < batch response > post with single request ( final request specification request spec , final response specification response spec , final batch request br ) { final list < batch request > batch requests = new array list < > ( ) ; batch requests . add ( br ) ; final string jsonified request = batch helper . to json string ( batch requests ) ; final list < batch response > response = batch helper . post batch requests without enclosing transaction ( request spec , response spec , jsonified request ) ; assert . assert not null ( response ) ; assert . assert true ( response . size ( ) > num ) ; return response ; }	returns a batchresponse based on the given batchrequest , by posting the request to the server .
public file program directory ( ) { return program directory ; }	returns the directory in which the main program is located .
@ override public void clear route sensors ( ) { control sensor list = new array list < > ( ) ; }	method to delete all control sensors from this route.
public static keystore type from string ( string x ) throws configuration exception { for ( keystore type current type : keystore type . values ( ) ) { if ( x . equals ignore case ( current type . to string ( ) ) ) return current type ; } throw new configuration exception ( message format . format ( str , x ) ) ; }	converts a string into the corresponding keystore_type.
public object mapper next level ( object mapper level ) { object mapper previous = level stack . peek ( ) ; level stack . push ( level ) ; return previous ; }	sets the new current nested level and pushes old current nested level down the stack returns that level .
protected static int to digit ( final char ch , final int index ) throws hex decode exception { final int digit = character . digit ( ch , num ) ; if ( digit == - num ) { throw new hex decode exception ( str + ch + str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
public json to json ( ) throws json { json json = new json ( ) ; json jpods = new json ( ) ; for ( diaspora pod pod : pods ) { jpods . put ( pod . to json ( ) ) ; } json . put ( str , jpods ) ; json . put ( str , system . current time millis ( ) ) ; return json ; }	convert diasporapodlist to json.
public static key store load ( file key store file , password password ) throws crypto exception , file not found exception { key store type key store type = null ; try { key store type = crypto file util . detect key store type ( new file input stream ( key store file ) ) ; } catch ( file not found exception ex ) { throw ex ; } catch ( io ex ) { throw new crypto exception ( res . get string ( str ) , ex ) ; } if ( key store type == null ) { return null ; } return load ( key store file , password , key store type ) ; }	load a keystore , auto - detecting the type , from a file accessed by a password .
@ override public void remove property change listener ( property change listener pcl ) { m pc support . remove property change listener ( pcl ) ; }	remove a property change listener.
@ visible for testing static boolean is precaching enabled ( context context ) { shared preferences prefs = preference manager . get default shared preferences ( context ) ; return prefs . get boolean ( pref is precaching enabled , bool ) ; }	returns true if precaching is able to run.
public void and ( long bit set other ) { int pos = math . min ( num words , other . num words ) ; while ( -- pos >= num ) { bits [ pos ] &= other . bits [ pos ] ; } if ( num words > other . num words ) { arrays . fill ( bits , other . num words , num words , num ) ; } }	this = this and other.
@ override public boolean equals ( object obj ) { if ( this == obj ) return bool ; if ( ! ( obj instanceof principal entry ) ) return bool ; principal entry that = ( principal entry ) obj ; return ( principal class . equals ( that . principal class ) && principal name . equals ( that . principal name ) ) ; }	test for equality between the specified object and this object.
public boolean is valid lockdown profile ( ) { try { return bool ; } catch ( illegal argument exception e ) { log . w ( tag , str , e ) ; return bool ; } }	test if profile is valid for lockdown , which requires ipv4 address for both server and dns.
public static boolean is extension ( string filename , string [ ] extensions ) { if ( filename == null ) { return bool ; } if ( extensions == null || extensions . length == num ) { return index of extension ( filename ) == - num ; } string file ext = get extension ( filename ) ; for ( string extension : extensions ) { if ( file ext . equals ( extension ) ) { return bool ; } } return bool ; }	checks whether the extension of the filename is one of those specified.
public from clause ( stream stream one , outer join qualifier outer join qualifier , stream stream two ) { this ( stream one ) ; add ( stream two ) ; outer join qualifiers . add ( outer join qualifier ) ; }	ctor for an outer join between two streams .
private static void decode ansi x12 segment ( bit source bits , string builder result ) throws format exception { int [ ] c values = new int [ num ] ; do { if ( bits . available ( ) == num ) { return ; } int first byte = bits . read bits ( num ) ; if ( first byte == num ) { return ; } parse two bytes ( first byte , bits . read bits ( num ) , c values ) ; for ( int i = num ; i < num ; i ++ ) { int c value = c values [ i ] ; if ( c value == num ) { result . append ( str ) ; } else if ( c value == num ) { result . append ( str ) ; } else if ( c value == num ) { result . append ( str ) ; } else if ( c value == num ) { result . append ( str ) ; } else if ( c value < num ) { result . append ( ( char ) ( c value + num ) ) ; } else if ( c value < num ) { result . append ( ( char ) ( c value + num ) ) ; } else { throw format exception . get format instance ( ) ; } } } while ( bits . available ( ) > num ) ; }	see iso 16022 : 2006 , 5.
public static kdb database create kdb database ( credentials credentials , kdb header kdb header , input stream input stream ) throws io { data input data input = new little endian data input stream ( input stream ) ; check signature ( data input ) ; deserialize header ( kdb header , data input ) ; input stream decrypted input stream = kdb header . create decrypted input stream ( credentials . get key ( ) , input stream ) ; message digest digest = encryption . get message digest instance ( ) ; digest input stream digest input stream = new digest input stream ( decrypted input stream , digest ) ; data input = new little endian data input stream ( digest input stream ) ; kdb database kdb database = new kdb database ( ) ; kdb group last group = ( kdb group ) kdb database . get root group ( ) ; for ( long group = num ; group < kdb header . get group count ( ) ; group ++ ) { last group = deserialize group ( last group , data input ) ; } for ( long entry = num ; entry < kdb header . get entry count ( ) ; entry ++ ) { deserialize entry ( kdb database , data input ) ; } if ( ! arrays . equals ( digest . digest ( ) , kdb header . get content hash ( ) ) ) { throw new illegal state exception ( str ) ; } digest input stream . close ( ) ; return kdb database ; }	construct a kdb database from the supplied inputstream .
private diff part decode add ( final int block size s , final int block size l ) throws unsupported encoding exception , decoding exception { if ( block size s < num || block size l < num ) { throw new decoding exception ( str + block size s + str + block size l ) ; } int s = r . read ( block size s ) ; int l = r . read ( block size l ) ; byte array output stream output = new byte array output stream ( ) ; for ( int i = num ; i < l ; i ++ ) { output . write ( r . read byte ( ) ) ; } diff part part = new diff part ( diff action . insert ) ; part . set start ( s ) ; part . set text ( output . to string ( wikipedia encoding ) ) ; return part ; }	decodes an add operation .
public void sort ( ) { arrays . sort ( v , num , size ( ) ) ; }	sorts the array in place.
public void rebuild panel ( ) { if ( active worker != null && ! active worker . is done ( ) ) { active worker . cancel ( bool ) ; } panel images . remove all ( ) ; panel images . revalidate ( ) ; scroll pane . repaint ( ) ; active worker = new image loader ( media files ) ; active worker . execute ( ) ; }	trigger to rebuild the panel.
protected void process bytes ( byte [ ] buf , int off , int len ) { n bytes in += len ; if ( len < num || state . is done ( ) ) return ; if ( state == state . row ready ) throw new pngj input exception ( str ) ; if ( inf . needs dictionary ( ) || ! inf . needs input ( ) ) throw new runtime exception ( str ) ; inf . set input ( buf , off , len ) ; if ( is callback mode ( ) ) { while ( inflate data ( ) ) { int next row len = process row callback ( ) ; prepare for next row ( next row len ) ; if ( is done ( ) ) process done callback ( ) ; } } else inflate data ( ) ; }	feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( ).
@ override protected string to string ( file obj ) { return obj . get absolute path ( ) ; }	turns an object into a string for storing in the props .
public final void go to next page ( ) { final boolean is last page = view pager . get current item ( ) == ( pages . size ( ) - num ) ; if ( ! is last page ) { view pager . set current item ( view pager . get current item ( ) + num , bool ) ; } }	navigates to the next page ( if not already there ) .
private static input stream null input stream ( ) throws null pointer exception { if ( current time millis ( ) > num ) { return null ; } throw new null pointer exception ( ) ; }	the following two methods exist because in , out , and err must be initialized to null.
public list < type id < ? > > as list ( ) { return collections . unmodifiable list ( arrays . as list ( types ) ) ; }	returns an immutable list .
private static void delete rules ( list < string > batch list , list < rule > rules to delete ) { string delete statement = str + rules table + str ; for ( rule rule : rules to delete ) { batch list . add ( string . format ( delete statement , rule . get uid ( ) ) ) ; } }	the sql commands to be added to the batchlist for deleting the rules in rulestodelete .
public boolean is visited ( object element ) { return my visited elements . contains key ( element ) ; }	returns true if this element was already visited .
public aws iot connection ( abstract aws iot client client ) { this . client = client ; }	instantiates a new connection object .
public static < t > completable future < t > exceptionally completed future ( throwable throwable ) { final completable future < t > future = new completable future < t > ( ) ; future . complete exceptionally ( throwable ) ; return future ; }	returns a new completablefuture that is already exceptionally completed with the given exception .
protected void init forecast errors ( array list < float > model , time series . data sequence data ) { double sum err = num ; double sum abs err = num ; double sum abs percent err = num ; double sum err squared = num ; int processed points = num ; int n = data . size ( ) ; for ( int i = num ; i < n ; i ++ ) { double error = model . get ( i ) - data . get ( i ) . value ; sum err += error ; sum abs err += math . abs ( error ) ; sum abs percent err += math . abs ( error / data . get ( i ) . value ) ; sum err squared += error * error ; processed points ++ ; } this . bias = sum err / processed points ; this . mad = sum abs err / processed points ; this . mape = sum abs percent err / processed points ; this . mse = sum err squared / processed points ; this . sae = sum abs err ; errors init = bool ; }	initializes all errors given the model .
public boolean check modifiers ( mouse event e ) { return e . get modifiers ( ) == modifiers ; }	check the mouse event modifiers against the instance member modifiers.
public void emit retained vars ( generate js visitor gen ) { if ( ! retained vars . is empty ( ) ) { gen . out ( str ) ; boolean first = bool ; for ( string var name : retained vars ) { if ( ! first ) { gen . out ( str ) ; } first = bool ; gen . out ( var name ) ; } gen . end line ( bool ) ; retained vars . clear ( ) ; } }	writes all retained variables to the output of the specified generator , then clears them .
public uri ( string scheme , string authority , string path , string query , string fragment ) throws uri { if ( scheme != null && path != null && ! path . is empty ( ) && path . char at ( num ) != str ) { throw new uri ( path , str ) ; } string builder uri = new string builder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( str ) ; } if ( authority != null ) { uri . append ( str ) ; authority encoder . append encoded ( uri , authority ) ; } if ( path != null ) { path encoder . append encoded ( uri , path ) ; } if ( query != null ) { uri . append ( str ) ; all legal encoder . append encoded ( uri , query ) ; } if ( fragment != null ) { uri . append ( str ) ; all legal encoder . append encoded ( uri , fragment ) ; } parse uri ( uri . to string ( ) , bool ) ; }	creates a new uri instance of the given unencoded component parts .
public list < structured translation > hg ( hyper graph hg , int top n ) { reset state ( ) ; if ( hg == null || hg . goal node == null ) { return empty list ( ) ; } final list < structured translation > kbest = new array list < > ( top n ) ; for ( int k = num ; k <= top n ; k ++ ) { structured translation translation = get kth structured translation ( hg . goal node , k ) ; if ( translation == null ) { break ; } kbest . add ( translation ) ; } return kbest ; }	this is an entry point for extracting k - best hypotheses as structuredtranslation objects.
@ override public int read ( ) throws io { synchronized ( lock ) { check not closed ( ) ; if ( pos != count ) { return str . char at ( pos ++ ) ; } return - num ; } }	reads a single character from the source string and returns it as an integer with the two higher - order bytes set to 0.
public static boolean is snapshot full copy supported ( uri block snap uri , db client db client ) { block snapshot block obj = db client . query object ( block snapshot . class , block snap uri ) ; storage system storage = db client . query object ( storage system . class , block obj . get storage controller ( ) ) ; return ( storage != null && ( storage . device is type ( type . openstack ) || storage . device is type ( type . vnxblock ) || storage . device is type ( type . ibmxiv ) || storage . device is type ( type . vmax ) ) ) ; }	check if the storage system type is openstack , vnxblock , vmax or ibmxiv.
public iterable < service descriptor > list services ( ) { array list < service descriptor > service descriptors = new array list < service descriptor > ( ) ; for ( file descriptor file descriptor : file descriptors ) { service descriptors . add all ( file descriptor . get services ( ) ) ; } return service descriptors ; }	lists all of the services found in the file descriptors.
private string strip code value sentences ( string string ) { return string . replace all ( str , str ) ; }	returns a string with lines sentences of the following form removed : this result code corresponds to the ldap result code value of & # x7b ; & # x40 ; code 0 & # x7d ; .
public void test divide round half even neg2 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round half even ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_half_even , result is negative ; equidistant.
public static double quantile ( double p , double alpha , double beta ) { if ( double . is na n ( alpha ) || double . is na n ( beta ) || double . is na n ( p ) || alpha < num || beta < num ) { return double . n ; } if ( p < num || p > num ) { return double . n ; } if ( p == num ) { return num ; } if ( p == num ) { return num ; } if ( p > num ) { return num - raw quantile ( num - p , beta , alpha , log beta ( beta , alpha ) ) ; } else { return raw quantile ( p , alpha , beta , log beta ( alpha , beta ) ) ; } }	compute quantile ( inverse cdf ) for beta distributions .
public boolean validate ( string cert , string signed data , string signature ) throws no such algorithm exception , io , exception { byte [ ] cert bytes = base64 . decode ( cert ) ; byte [ ] signed data bytes = base64 . decode ( signed data ) ; byte [ ] signature bytes = base64 . decode ( signature ) ; return validate ( cert bytes , signed data bytes , signature bytes ) ; }	example implementation . it only knows to verify sha256withec algorithm .
public int size ( ) { return seq . size ( ) ; }	return the number of objects in this sequence .
public void test add servlet run as role ( ) throws exception { string xml = webapp test header + str + str + str + str + str ; web xml web xml = web xml io . parse web xml ( new byte array input stream ( xml . get bytes ( str ) ) , get entity resolver ( ) ) ; web xml utils . add servlet run as role name ( web xml , str , str ) ; string role name = web xml utils . get servlet run as role name ( web xml , str ) ; assert equals ( str , role name ) ; }	tests that a run - as role - name can be added to a servlet .
public void test case15 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( - num , result . signum ( ) ) ; }	subtract two negative numbers of different length.
public multi term query ( final string field ) { this . field = objects . require non null ( field , str ) ; }	constructs a query matching terms that cannot be represented with a single term .
public static void print line ( object message ) { if ( ! is disabled ( ) ) { print line ( string . value of ( message ) ) ; } }	prints the message passed as a non - string object and a new line .
public void accumulate ( api entity ) throws exception { api current = root ; for ( string groupby : groupbys ) { string tagv = locate groupby field ( groupby , entity ) ; if ( tagv == null || tagv . is empty ( ) ) { tagv = unassigned groupby root field name ; } map < string , api > children = current . get entity list ( ) ; if ( children . get ( tagv ) == null ) { children . put ( tagv , factory . create ( ) ) ; current . set num direct descendants ( current . get num direct descendants ( ) + num ) ; } api child = children . get ( tagv ) ; if ( counting ) count ( child ) ; for ( string sum function field : sum function fields ) { sum ( child , entity , sum function field ) ; } current = child ; } }	currently only group by tags groupbys ' first item always is site , which is a reserved field.
public void test invalid xml ( ) throws exception { test invalid gpx ( invalid xml gpx ) ; }	test an invalid xml input .
public string to string ( boolean expand ) { string builder acc = new string builder ( ) ; to string ( acc , num , expand ) ; return acc . to string ( ) ; }	convert a re to a string .
public static boolean is accessor pair ( t member , t member2 ) { return ( member instanceof t && member2 instanceof t ) || ( member instanceof t && member2 instanceof t ) ; }	returns true if one of the members is a getter and the other one is a setter.
public static date format create utc ( string date format ) { date format formatter = new simple date format ( date format ) ; formatter . set time zone ( time zone . get time zone ( str ) ) ; return formatter ; }	creates a dateformat that assumes the incoming date is in utc time .
public void write linked kml ( final string filename , final kml type kml ) { if ( filename . equals ( str ) ) { throw new illegal argument exception ( str ) ; } if ( filename . equals ( str ) ) { throw new illegal argument exception ( str ) ; } write kml ( filename , kml ) ; }	adds the specified kml - object to the file .
string destination file path ( ) { return destination file path ; }	get destination file path of this download request .
@ override public void refresh users or groups list from server ( ) { show loading dialog ( get string ( r . string . common loading ) ) ; get share with users async task get task = new get share with users async task ( this ) ; object [ ] params = { get file ( ) , get account ( ) , get storage manager ( ) } ; get task . execute ( params ) ; }	get users and groups from the server to fill in the " share with " list.
public boot panel ( ) { init components ( ) ; }	creates new form bootpanel.
private list < header > default headers ( ) { date format date format = new simple date format ( str ) ; list < header > headers = new array list < > ( ) ; headers . add ( new basic header ( str , date format . format ( new date ( ) ) ) ) ; return headers ; }	create default headers for server response .
public aem parsys clear ( ) { list < web element > list = current scope . find elements ( by . css selector ( selector for component in parsys ) ) ; list . for each ( null ) ; return this ; }	remove all components in parsys .
protected request handle send request ( default http client client , http context http context , http uri request uri request , string content type , response handler interface response handler , context context ) { if ( content type != null ) { uri request . set header ( str , content type ) ; } response handler . set request headers ( uri request . get all headers ( ) ) ; response handler . set request uri ( uri request . get uri ( ) ) ; future < ? > request = thread pool . submit ( new async http request ( client , http context , uri request , response handler ) ) ; if ( context != null ) { list < weak reference < future < ? > > > request list = request map . get ( context ) ; if ( request list == null ) { request list = new linked list < weak reference < future < ? > > > ( ) ; request map . put ( context , request list ) ; } request list . add ( new weak reference < future < ? > > ( request ) ) ; } return new request handle ( request ) ; }	puts a new request in queue as a new thread in pool to be executed.
private void register new client ( json object j data ) { client new client = gson . from json ( j data , client . class ) ; if ( new client . is valid ( ) ) { add client ( new client ) ; broadcast new client ( new client ) ; send client list ( new client ) ; } else { logger . log ( level . warning , str ) ; } }	create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .
@ override public void parse ( input stream in , string base uri ) throws io , rdf , rdf { if ( in == null ) { throw new illegal argument exception ( str ) ; } if ( base uri == null ) { throw new illegal argument exception ( str ) ; } input source input source = new input source ( new bom ( in , bool ) ) ; input source . set system id ( base uri ) ; parse ( input source ) ; }	parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .
public static date parse date ( string date value , collection date formats ) throws date parse exception { if ( date value == null ) { throw new illegal argument exception ( str ) ; } if ( date formats == null ) { date formats = default patterns ; } if ( date value . length ( ) > num && date value . starts with ( str ) && date value . ends with ( str ) ) { date value = date value . substring ( num , date value . length ( ) - num ) ; } simple date format date parser = null ; final iterator format iter = date formats . iterator ( ) ; while ( format iter . has next ( ) ) { final string format = ( string ) format iter . next ( ) ; if ( date parser == null ) { date parser = new simple date format ( format , locale . us ) ; date parser . set time zone ( time zone . get time zone ( str ) ) ; } else { date parser . apply pattern ( format ) ; } try { return date parser . parse ( date value ) ; } catch ( final parse exception pe ) { } } throw new date parse exception ( str + date value ) ; }	parses the date value using the given date formats .
public json remove ( string name ) { if ( name == null ) { throw new null pointer exception ( str ) ; } int index = index of ( name ) ; if ( index != - num ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }	removes a member with the specified name from this object.
edge map < block > find loops ( deque < block > code , map < block , block > idom , set map < block , edge > pred ) { edge map < block > loops = new edge map < block > ( ) ; for ( block b : code ) for ( edge s : b . succ ( ) ) if ( is loop ( s , idom ) ) { verbose status ( str + s ) ; block h = s . to ; set < block > loop = loops . get ( h ) ; set < block > work = new tree set < block > ( ) ; for ( edge p : pred . get ( h ) ) { if ( is loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is empty ( ) ) { block x = get block ( work ) ; for ( edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }	loop code layout the loop is defined by the back edge from t - > h.
private void generate hive test files ( ) throws file not found exception { try ( print writer writer a = new print writer ( new file ( test work dir , str ) ) ; print writer writer b = new print writer ( new file ( test work dir , str ) ) ) { char sep = str ; int id b = num ; int id a = num ; int v = num ; for ( int i = num ; i < num ; i ++ ) { writer a . print ( id a ++ ) ; writer a . print ( sep ) ; writer a . println ( id b ) ; writer b . print ( id b ++ ) ; writer b . print ( sep ) ; writer b . println ( v += num ) ; writer b . print ( id b ++ ) ; writer b . print ( sep ) ; writer b . println ( v += num ) ; } writer a . flush ( ) ; writer b . flush ( ) ; } }	generates two data files to join its with hive .
public void rename editor panel ( editor panel ) { if ( panels list . size ( ) == num ) { return ; } for ( int i = num ; i < panels list . size ( ) ; i ++ ) { object o = panels list . get ( i ) ; if ( o == panel ) { j r = ( j ) panels sub menu . get item ( i ) ; r . set text ( panel . get title ( ) ) ; return ; } } }	rename an editor type panel in show panels sub menu.
private boolean fits as single line ( int col ) { return ( col + single line width ( ) <= tla . wrap column ) || ( body formulas . sf == null && ( prcd formulas == null || prcd formulas . size ( ) == num ) ) ; }	returns true iff format ( col ) should return a single - line version of the formula .
@ override protected void before ( ) throws throwable { previous threads = thread . get all stack traces ( ) ; }	override to set up your specific external resource .
public void spherical to world ( vector3 vec ) { if ( pj unprojected == null ) { string proj str = str + proj info . get semi major axis ( ) + str + proj info . get semi minor axis ( ) + str ; pj unprojected = proj4 . new instance ( proj str ) ; } if ( pj projected == null ) { pj projected = proj4 . new instance ( proj4 string ) ; } try { vec . to array ( coord ) ; coord [ num ] = math . to radians ( coord [ num ] ) ; coord [ num ] = math . to radians ( coord [ num ] ) ; pj unprojected . transform ( pj projected , coord ) ; vec . set x ( coord [ num ] ) ; vec . set y ( coord [ num ] ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	convert lon / lat ( degree ) coordinate to virtual world coordinates .
public string replace ( char sequence target , char sequence replacement ) { if ( target == null ) { throw new null pointer exception ( str ) ; } if ( replacement == null ) { throw new null pointer exception ( str ) ; } string target string = target . to string ( ) ; int match start = index of ( target string , num ) ; if ( match start == - num ) { return this ; } string replacement string = replacement . to string ( ) ; int target length = target string . length ( ) ; if ( target length == num ) { int result length = count + ( count + num ) * replacement string . length ( ) ; string builder result = new string builder ( result length ) ; result . append ( replacement string ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacement string ) ; } return result . to string ( ) ; } string builder result = new string builder ( count ) ; int search start = num ; do { result . append ( value , offset + search start , match start - search start ) ; result . append ( replacement string ) ; search start = match start + target length ; } while ( ( match start = index of ( target string , search start ) ) != - num ) ; result . append ( value , offset + search start , count - search start ) ; return result . to string ( ) ; }	copies this string replacing occurrences of the specified target sequence with another sequence.
public static string encode url ( final string str ) { return encode ( str , str ) ; }	encode a string for html requests.
public void draw rendered image ( rendered image img , affine transform xform ) { if ( img == null ) { return ; } m print metrics . draw image ( this , img ) ; m drawing area . add infinite ( ) ; }	draws an image , applying a transform from image space into user space before drawing.
private void skip to end of line ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char at ( pos ) ; if ( c == str || c == str ) { pos ++ ; break ; } } }	advances the position until after the next newline character.
public independence test ind test subset ( list vars ) { return null ; }	creates a new indtestcramert instance for a subset of the variables .
@ override public void act on ( file f ) { buffered reader reader = null ; try { reader = new buffered reader ( new file reader ( f ) ) ; announce seeds from reader ( reader ) ; } catch ( file not found exception fnf ) { logger . log ( level . severe , str , fnf ) ; } finally { io . close quietly ( reader ) ; } }	treat the given file as a source of additional seeds , announcing to seedlisteners .
public static string format millis ( int millis ) { string result = str ; int hr = millis / num ; millis %= num ; int min = millis / num ; millis %= num ; int sec = millis / num ; if ( hr > num ) { result += hr + str ; } if ( min >= num ) { if ( min > num ) { result += min + str ; } else { result += str + min + str ; } } if ( sec > num ) { result += sec ; } else { result += str + sec ; } return result ; }	formats time in milliseconds to hh : mm : ss string format .
public void add property change listener ( string property name , property change listener listener ) { property change support . add property change listener ( property name , listener ) ; }	adds the property change listener .
public file create new folder ( file containing dir ) throws io { if ( containing dir == null ) { throw new io ( str ) ; } file new folder = create file object ( containing dir , new folder string ) ; int i = num ; while ( new folder . exists ( ) && i < num ) { new folder = create file object ( containing dir , message format . format ( new folder next string , new integer ( i ) ) ) ; i ++ ; } if ( new folder . exists ( ) ) { throw new io ( str + new folder . get absolute path ( ) ) ; } else { new folder . mkdirs ( ) ; } return new folder ; }	creates a new folder with a default folder name .
public resources poet add typed array ( string name , @ not null list < string > values ) { element element = document . create element ( str ) ; element . set attribute ( str , name ) ; for ( string value : values ) { element value element = document . create element ( str ) ; value element . append child ( document . create text node ( value ) ) ; element . append child ( value element ) ; } resource element . append child ( element ) ; return this ; }	add a typed array to the config.
public boolean add sub action ( final conf action action conf ) throws general exception , configuration exception { if ( action conf . get type ( ) != null ) { final sub action sub = sub action . factory ( action conf . get type ( ) , action conf ) ; if ( sub == null ) { if ( cfg . debug ) { check . log ( tag + str + action conf . get type ( ) ) ; } return bool ; } list . add ( sub ) ; if ( sub instanceof sub action slow ) { set queue ( main queue ) ; } return bool ; } else { if ( cfg . debug ) { check . log ( tag + str ) ; } return bool ; } }	adds the sub action .
void fill entry tree ( set < page leaf entry > entries , row row ) { int ptr = row head ; byte [ ] buffer = buffer ; while ( ptr < block size ) { int code = buffer [ ptr ] & code mask ; int len = get length ( code , row ) ; if ( code == insert || code == remove ) { page leaf entry entry = new page leaf entry ( this , row , ptr , len , code ) ; entries . add ( entry ) ; } ptr += len ; } }	fills the entry tree map with entries from the block .
public static < s > boolean contains atleast one ( collection < s > left , collection < s > right ) { if ( left == null || right == null ) { return bool ; } for ( s id : left ) { if ( right . contains ( id ) ) { return bool ; } } return bool ; }	checks if right hand collection has atleast one same item as left hand collection .
public void assert duration is in range ( long expected millis ) { long minimum = ( long ) ( ( double ) expected millis * num ) ; long maximum = math . max ( ( long ) ( ( double ) expected millis * num ) , num ) ; long wait millis = math . max ( expected millis * num , num ) ; long duration = get duration millis ( wait millis ) ; if ( duration < minimum ) { assert . fail ( str + expected millis + str + minimum + str + duration ) ; } else if ( duration > maximum ) { assert . fail ( str + expected millis + str + maximum + str + duration ) ; } }	asserts that the actual duration is within 10 % of the given expected time .
public void log diff ( string id , string field , string db , string hw ) { string buffer diff buffer = new string buffer ( string . format ( str , id , field ) ) ; if ( db == null || db . is empty ( ) || db . equals ignore case ( no matching entry ) ) { diff buffer . append ( string . format ( str , hw ) ) ; } else if ( hw == null || hw . is empty ( ) || hw . equals ignore case ( no matching entry ) ) { diff buffer . append ( string . format ( str , db ) ) ; } else { diff buffer . append ( string . format ( str , db != null ? db : str , hw != null ? hw : str ) ) ; } msgs . append ( diff buffer . to string ( ) + str ) ; if ( log != null ) { log . info ( diff buffer . to string ( ) ) ; } }	log a discrepancy in the data .
public img ( lyrics3 image image ) { images . add ( image ) ; }	creates a new fieldbodyimg datatype .
public abstract resource ( string mimetype ) { this ( mimetype , system . current time millis ( ) ) ; }	initializes this abstractresource with the given mimetype.
private parameters ( ) { for ( iterator i = arguments . iterator ( ) ; i . has next ( ) ; ) { string arg = ( string ) i . next ( ) ; arg = arg . to lower case ( ) ; if ( ! arg . starts with ( str ) ) throw new illegal argument exception ( str + arg ) ; int colon index = arg . index of ( str ) ; string key ; string value ; if ( colon index >= num ) { key = arg . substring ( num , colon index ) ; value = arg . substring ( colon index + num ) ; } else { key = arg . substring ( num ) ; value = str ; } if ( ! allowed keys . contains ( key ) ) throw new illegal argument exception ( str + arg . substring ( num ) + str + string util . to comma delimited string ( allowed keys ) ) ; hashtable . put ( key , value ) ; } for ( iterator i = required keys . iterator ( ) ; i . has next ( ) ; ) { string required key = ( string ) i . next ( ) ; if ( ! hashtable . contains key ( required key ) ) throw new illegal argument exception ( str + required key ) ; } }	creates a parameters object for the given main - method arguments .
private double mel to lin freq ( double input freq ) { return ( num * ( math . pow ( num , ( input freq / num ) ) - num ) ) ; }	compute linear frequency from mel frequency .
public rounded icon generator ( int icon width px , int icon height px , int corner radius px , int background color , float text size px ) { m icon width px = icon width px ; m icon height px = icon height px ; m corner radius px = corner radius px ; m background rect = new f ( num , num , m icon width px , m icon height px ) ; m background paint = new paint ( paint . anti alias flag ) ; m background paint . set color ( background color ) ; m text paint = new text paint ( paint . anti alias flag ) ; m text paint . set color ( color . white ) ; m text paint . set fake bold text ( bool ) ; m text paint . set text size ( text size px ) ; font metrics text font metrics = m text paint . get font metrics ( ) ; m text height = ( float ) math . ceil ( text font metrics . bottom - text font metrics . top ) ; m text y = - text font metrics . top ; }	constructs the generator and initializes the common members ignoring display density .
public static byte [ ] random bytes ( int size ) { byte [ ] bytes = new byte [ size ] ; seeded random . next bytes ( bytes ) ; return bytes ; }	generate an array of random bytes.
@ override public string to string ( ) { string buffer bf string = new string buffer ( ) ; bf string . append ( str ) ; if ( m starting != null ) { bf string . append ( str ) ; bf string . append ( start set to string ( ) ) ; bf string . append ( str ) ; } if ( m threshold != - double . max value ) { bf string . append ( str + utils . double to string ( m threshold , num , num ) + str ) ; } return bf string . to string ( ) ; }	returns a description of the search as a string.
protected void arraycopy ( byte [ ] buf , int pos , int length ) { m message . write ( buf , pos , length ) ; m position = m position + length ; }	copy buf to mmessage .
public boolean expired ( ) { return system . current time millis ( ) - time > dflt expiration timeout ; }	checks if cassandra driver session expired .
public json put ( string key , boolean value ) throws json { put ( key , value ? boolean . true : boolean . false ) ; return this ; }	put a key / boolean pair in the jsonobject .
private void write attribute ( java . lang . string prefix , java . lang . string namespace , java . lang . string att name , java . lang . string att value , javax . xml . stream . xml xml writer ) throws javax . xml . stream . xml { if ( xml writer . get prefix ( namespace ) == null ) { xml writer . write namespace ( prefix , namespace ) ; xml writer . set prefix ( prefix , namespace ) ; } xml writer . write attribute ( namespace , att name , att value ) ; }	util method to write an attribute with the ns prefix.
private void handle selection ( view view , item item , int position ) { if ( ! item . is selectable ( ) ) { return ; } if ( item . is selected ( ) && ! m allow deselection ) { return ; } boolean selected = bool ; if ( m position based state management ) { selected = m selections . contains ( position ) ; } else { selected = item . is selected ( ) ; } if ( m select with item update || view == null ) { if ( ! m multi select ) { deselect ( ) ; } if ( selected ) { deselect ( position ) ; } else { select ( position ) ; } } else { if ( ! m multi select ) { if ( m position based state management ) { iterator < integer > entries = m selections . iterator ( ) ; while ( entries . has next ( ) ) { integer pos = entries . next ( ) ; if ( pos != position ) { deselect ( pos , entries ) ; } } } else { set < integer > selections = get selections ( ) ; for ( int pos : selections ) { if ( pos != position ) { deselect ( pos ) ; } } } } item . with set selected ( ! selected ) ; view . set selected ( ! selected ) ; if ( m selection listener != null ) m selection listener . on selection changed ( item , ! selected ) ; if ( m position based state management ) { if ( selected ) { if ( m selections . contains ( position ) ) { m selections . remove ( position ) ; } } else { m selections . add ( position ) ; } } } }	handles the selection and deselects item if multiselect is disabled.
public boolean can invoke ( m assetwk , m asset acct , int a , big decimal accum dep ) { if ( assetwk == null ) { log . warning ( str ) ; return bool ; } int offset = num ; int life periods = assetwk . get use life months ( assetwk . is fiscal ( ) ) ; boolean ok = ( offset <= a ) ; if ( c . is level finest ( ) ) log . finest ( str + a + str + life periods + str + offset + str + ok ) ; return ok ; }	check if the method can be invoked to give parameters.
public boolean write header ( output stream os ) { try { write int ( os , cache magic ) ; write string ( os , key ) ; write string ( os , etag == null ? str : etag ) ; write long ( os , server date ) ; write long ( os , last modified ) ; write long ( os , ttl ) ; write long ( os , soft ttl ) ; write string string map ( response headers , os ) ; os . flush ( ) ; return bool ; } catch ( io e ) { volley log . d ( str , e . to string ( ) ) ; return bool ; } }	writes the contents of this cacheheader to the specified outputstream .
public byte [ ] bytes ( ) throws http request exception { final byte array output stream output = byte stream ( ) ; try { copy ( buffer ( ) , output ) ; } catch ( io e ) { throw new http request exception ( e ) ; } return output . to byte array ( ) ; }	get response as byte array.
public void fade out all layers ( ) { m transition state = transition starting ; arrays . fill ( m is layer on , bool ) ; invalidate self ( ) ; }	starts fading out all layers .
public tree map < float , list < list < integer > > > pack modified first fit descending ( ) { throw new unsupported operation exception ( str ) ; }	note : upper bound is 71 / 60 opt + 6 / 9 ( ~ 1 . 18 opt ).
public void add text change listener ( final filter query change listener text change listener ) { listeners . add ( text change listener ) ; }	adds the given listener.
@ override public iterator < profile > iterator ( ) { return profiles . iterator ( ) ; }	get an iterator of profiles .
private boolean starts with space ( string str ) { return str . length ( ) != num && str . char at ( num ) == str ; }	checks if the string starts with a space character , false if the string is empty or starts with a non - space character .
public string wrap ( string path ) { return uri prefix + path ; }	appends scheme to incoming path.
private int key to level ( string key ) { string [ ] token = key . split ( str ) ; return ( token . length - num ) ; }	given a key , find the level.
public boolean mouse dragged ( mouse event e ) { if ( grabbed plot graphics ) { int x = e . get x ( ) ; int y = e . get y ( ) ; int dx = x - prev x ; int dy = y - prev y ; plot x += dx ; plot y += dy ; prev x = x ; prev y = y ; graph . resize ( plot x , plot y , plot width , plot height ) ; om plot graphics = graph . get plot graphics ( ) ; plot graphics . generate ( get projection ( ) , bool ) ; repaint ( ) ; } return bool ; }	called whenever the mouse is dragged on this layer and one of the requested mouse modes is active .
private void init caching http headers filter ( servlet context servlet context , enum set < dispatcher type > disps ) { log . debug ( str ) ; filter registration . dynamic caching http headers filter = servlet context . add filter ( str , new caching http headers filter ( j hipster properties ) ) ; caching http headers filter . add mapping for url patterns ( disps , bool , str ) ; caching http headers filter . add mapping for url patterns ( disps , bool , str ) ; caching http headers filter . set async supported ( bool ) ; }	initializes the caching http headers filter .
protected void add common component ( xml component ) { if ( f common components . contains ( component ) ) { return ; } f common components . add ( component ) ; add recognized params and set defaults ( component ) ; }	adds common component to the parser configuration.
s await fulfill ( s s , boolean timed , long nanos ) { final long deadline = timed ? system . nano time ( ) + nanos : num ; thread w = thread . current thread ( ) ; int spins = ( should spin ( s ) ? ( timed ? max timed spins : max untimed spins ) : num ) ; for ( ; ; ) { if ( w . is interrupted ( ) ) s . try cancel ( ) ; s m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - system . nano time ( ) ; if ( nanos <= num ) { s . try cancel ( ) ; continue ; } } if ( spins > num ) spins = should spin ( s ) ? ( spins - num ) : num ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) lock support . park ( this ) ; else if ( nanos > spin for timeout threshold ) lock support . park nanos ( this , nanos ) ; } }	spins / blocks until node s is matched by a fulfill operation .
public void load ( general subtrees general subtrees ) { list < general subtree > general subtrees list = general subtrees . get general subtrees ( ) ; collections . sort ( general subtrees list , new general subtree base comparator ( ) ) ; data = new object [ general subtrees list . size ( ) ] [ num ] ; int i = num ; for ( general subtree general subtree : general subtrees list ) { data [ i ] [ num ] = general subtree ; data [ i ] [ num ] = general subtree ; data [ i ] [ num ] = general subtree ; i ++ ; } fire table data changed ( ) ; }	load the generalsubtreestablemodel with general subtrees .
@ override public synchronized int read ( ) { return pos < count ? buffer . char at ( pos ++ ) & num : - num ; }	reads a single byte from the source string and returns it as an integer in the range from 0 to 255.
public boolean is ping disabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }	returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .
public static void write to file ( file file , string contents ) throws io { file output stream fos = new file output stream ( file ) ; fos . write ( contents . get bytes ( ) ) ; fos . close ( ) ; }	writes the contents to the file at the given location ( this creates the file or deletes its existing contents . ).
public void make tree of writables ( iterable < pair < string , integer > > flat data ) { text key = new text ( ) ; for ( pair < string , integer > pair : flat data ) { key . set ( pair . key ) ; array list < int writable > val list ; if ( ! mock input . contains key ( key ) ) { val list = new array list < > ( ) ; mock input . put ( key , val list ) ; key = new text ( ) ; } else val list = ( array list < int writable > ) mock input . get ( key ) ; val list . add ( new int writable ( pair . value ( ) ) ) ; } }	generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects.
public static double angle ( coordinate p0 , coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return math . atan2 ( dy , dx ) ; }	returns the angle of the vector from p0 to p1 , relative to the positive x - axis.
public in memory cursor ( string [ ] column names ) { m current position = - num ; m column names = column names ; }	creates a new cursor setting the columns names that will be used by this cursor.
@ override public boolean is enabled ( ) { if ( ( attribute selection panel != null ) && ! is value only ( ) ) { return attribute selection panel . is enabled ( ) ; } else { if ( slider != null ) { return slider . is enabled ( ) ; } } return bool ; }	checks if is enabled .
private void render foreground ( final execution unit process , final d g2 , boolean printing ) { if ( draw highlight && ! printing && ( model . is drag started ( ) || model . is drop target set ( ) && model . is import dragged ( ) ) || model . is operator source hovered ( ) ) { switch ( gui . get drag highlighte mode ( ) ) { case full : case border : draw drag border ( process , g2 ) ; break ; case none : default : break ; } } }	renders the drag border if needed .
public modbus transaction create transaction ( ) { modbus serial transaction transaction = new modbus serial transaction ( ) ; transaction . set transport ( this ) ; return transaction ; }	creates a new transaction suitable for the serial port.
public void start ( ) { if ( runner == null ) { runner = new thread ( this , str ) ; runner . start ( ) ; } }	we ' re starting the thread.
public synchronized int export object ( string name , object obj ) throws cannot compile exception { class clazz = obj . get class ( ) ; exported object eo = new exported object ( ) ; eo . object = obj ; eo . methods = clazz . get methods ( ) ; exported objects . add element ( eo ) ; eo . identifier = exported objects . size ( ) - num ; if ( name != null ) exported names . put ( name , eo ) ; try { stub gen . make proxy class ( clazz ) ; } catch ( not found exception e ) { throw new cannot compile exception ( e ) ; } return eo . identifier ; }	exports an object . this method produces the bytecode of the proxy class used to access the exported object . a remote applet can load the proxy class and call a method on the exported object .
protected final file create dbffdc ( ) { file dbffdc dir = new file ( ffdc directory name ) ; if ( ! dbffdc dir . exists ( ) ) { final boolean is dbff = dbffdc dir . mkdirs ( ) ; if ( is dbff ) { dbffdc dir = new file ( ffdc directory name ) ; return dbffdc dir ; } } else if ( ! dbffdc dir . is directory ( ) ) { return null ; } return dbffdc dir ; }	creates the sub - directory where this particular back - up instance will be kept .
public static string read character sized string ( input stream stream ) throws io { string builder result = new string builder ( ) ; int str len = read uin ( stream ) ; int character = stream . read ( ) ; character |= stream . read ( ) << num ; do { if ( character != num ) { result . append ( ( char ) character ) ; character = stream . read ( ) ; character |= stream . read ( ) << num ; } } while ( character != num || ( result . length ( ) + num ) > str len ) ; if ( str len != ( result . length ( ) + num ) ) { throw new illegal state exception ( str ) ; } return result . to string ( ) ; }	this method reads a utf - 16 string , which length is given on the number of characters it consists of.
protected void process children ( query node query tree ) throws query node exception { list < query node > children = query tree . get children ( ) ; children list new children ; if ( children != null && children . size ( ) > num ) { new children = allocate children list ( ) ; try { for ( query node child : children ) { child = process iteration ( child ) ; if ( child == null ) { throw new null pointer exception ( ) ; } new children . add ( child ) ; } list < query node > ordered children list = set children order ( new children ) ; query tree . set ( ordered children list ) ; } finally { new children . being used = bool ; } } }	this method is called every time a child is processed .
private void initialize messages ( list < string > messages ) { messages . add all ( arrays . as list ( tip of the day messages . get general messages ( ) ) ) ; if ( os . is windows ( ) ) { messages . add all ( arrays . as list ( tip of the day messages . get windows messages ( ) ) ) ; } else if ( os . is mac osx ( ) ) { messages . add all ( arrays . as list ( tip of the day messages . get mac osx ( ) ) ) ; } else if ( os . is linux ( ) ) { messages . add all ( arrays . as list ( tip of the day messages . get linux messages ( ) ) ) ; } else { messages . add all ( arrays . as list ( tip of the day messages . get other messages ( ) ) ) ; } if ( ! os . is mac osx ( ) ) { messages . add all ( arrays . as list ( tip of the day messages . get non mac osx ( ) ) ) ; } messages . add all ( arrays . as list ( tip of the day messages . get frost wire messages ( ) ) ) ; collections . shuffle ( messages ) ; current tip = - num ; }	iterates through all the tips ' keys and stores the ones that are valid for this os .
public persisted queue ( final file queue env path , final string queue name , final int cache size ) { queue env path . mkdirs ( ) ; final environment config db env config = new environment config ( ) ; db env config . set transactional ( bool ) ; db env config . set allow create ( bool ) ; this . db env = new environment ( queue env path , db env config ) ; database config db config = new database config ( ) ; db config . set transactional ( bool ) ; db config . set allow create ( bool ) ; db config . set deferred write ( bool ) ; this . queue database = db env . open database ( null , queue name , db config ) ; this . queue name = queue name ; this . cache size = cache size ; this . ops counter = num ; }	creates instance of persistent queue .
protected final string builder write ( string builder sb , final object ... objects ) { for ( object string : objects ) sb . append ( string ) ; return sb ; }	this method adds to the sb the objects .
@ override public boolean connection allowed ( event set descriptor esd ) { return connection allowed ( esd . get name ( ) ) ; }	returns true if , at this time , the object will accept a connection via the named event.
public static request new post open graph action request ( session session , open graph action open graph action , callback callback ) { if ( open graph action == null ) { throw new facebook exception ( str ) ; } if ( utility . is null or empty ( open graph action . get type ( ) ) ) { throw new facebook exception ( str ) ; } string path = string . format ( my action format , open graph action . get type ( ) ) ; return new post request ( session , path , open graph action , callback ) ; }	creates a new request configured to publish an open graph action .
public void show loading ( ) { switch state ( loading , null , null , null , null , null , collections . < integer > empty list ( ) ) ; }	hide content and show the progress bar.
public void read external ( object input in ) throws io , class not found exception { int vocab size = in . read int ( ) ; for ( int i = num ; i < vocab size ; i ++ ) { string line = in . read utf ( ) ; vocabulary . id ( line ) ; } num tokens = in . read double ( ) ; count funcs = new long [ in . read int ( ) ] [ num ] ; for ( int i = num ; i < count funcs . length ; i ++ ) { count funcs [ i ] [ num ] = in . read long ( ) ; count funcs [ i ] [ num ] = in . read long ( ) ; } types funcs = new long [ in . read int ( ) ] [ num ] ; for ( int i = num ; i < types funcs . length ; i ++ ) { types funcs [ i ] [ num ] = in . read long ( ) ; types funcs [ i ] [ num ] = in . read long ( ) ; } quantization base = in . read double ( ) ; bf = new bloom filter ( ) ; bf . read external ( in ) ; }	read a bloom filter lm from an external file .
public static double compute mad ( double [ ] x , double median ) { for ( int i = num ; i < x . length ; i ++ ) { x [ i ] = math . abs ( x [ i ] - median ) ; } double mad = quick select . median ( x ) ; if ( ! ( mad > num ) ) { double min = double . positive infinity ; for ( double xi : x ) { if ( xi > num && xi < min ) { min = xi ; } } if ( min < double . positive infinity ) { mad = min ; } else { mad = num ; } } if ( mad == double . positive infinity ) { double max = num ; for ( double xi : x ) { if ( xi < double . positive infinity && xi > max ) { max = xi ; } } if ( max < double . positive infinity ) { mad = max ; } else { mad = num ; } } return mad ; }	compute the median absolute deviation from median .
public sdp exception ( throwable root cause ) { super ( root cause . get localized message ( ) ) ; }	constructs a new sdpexception as a result of a system exception and uses the localized system exception message .
private boolean link first ( node < e > node ) { if ( count >= capacity ) return bool ; node < e > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; not empty . signal ( ) ; return bool ; }	links node as first element , or returns false if full .
protected void notify property change listener ( string property , object old value , object new value ) { set < property change listener > v ; synchronized ( this ) { v = new hash set < > ( listeners ) ; } for ( property change listener listener : v ) { listener . property change ( new property change event ( this , property , old value , new value ) ) ; } }	trigger the notification of all propertychangelisteners.
public boolean indicate dirty read ( i template ) { return ( ( template . is read operation ( ) && use dirty read ) || template . is dirty read requested ( ) ) ; }	given an entry and a template , return true if dirty - read should be performed.
public j ( string title , int min , int max , int value ) { this ( title , new integer ( min ) , new integer ( max ) , new integer ( value ) ) ; m smin = min ; m srange = max - min ; m slider . set minimum ( min ) ; m slider . set maximum ( max ) ; set value ( new integer ( value ) ) ; }	create a new jvalueslider .
protected void apply attributes to symbol ( tactical graphic attributes graphic attributes , tactical symbol attributes symbol attributes ) { double value = graphic attributes . get interior opacity ( ) ; if ( value != null ) { symbol attributes . set opacity ( value ) ; } value = graphic attributes . get scale ( ) ; if ( value != null ) { symbol attributes . set scale ( value ) ; } material material = graphic attributes . get interior material ( ) ; symbol attributes . set interior material ( material ) ; font font = graphic attributes . get text modifier font ( ) ; if ( font != null ) { symbol attributes . set text modifier font ( font ) ; } material = graphic attributes . get text modifier material ( ) ; if ( material != null ) { symbol attributes . set text modifier material ( material ) ; } }	apply graphic attributes to the symbol .
public final void increase idle count ( idle status status , long current time ) { if ( status == idle status . both idle ) { idle count for both . increment and get ( ) ; last idle time for both = current time ; } else if ( status == idle status . reader idle ) { idle count for read . increment and get ( ) ; last idle time for read = current time ; } else if ( status == idle status . writer idle ) { idle count for write . increment and get ( ) ; last idle time for write = current time ; } else { throw new illegal argument exception ( str + status ) ; } }	todo add method documentation.
public remote service descriptor ( string base url , http json request factory request factory ) throws illegal argument exception { this . base url = base url ; this . request factory = request factory ; try { final url base url url = new url ( base url ) ; final string protocol = base url url . get protocol ( ) ; if ( ! ( protocol . equals ( str ) || protocol . equals ( str ) ) ) { throw new illegal argument exception ( string . format ( str , base url ) ) ; } } catch ( url e ) { throw new illegal argument exception ( string . format ( str , base url ) ) ; } }	creates new descriptor of remote restful service .
private journal read journal ( parcel file descriptor old state ) { journal journal = new journal ( ) ; if ( old state == null ) { return journal ; } file input stream in stream = new file input stream ( old state . get file descriptor ( ) ) ; try { int available bytes = in stream . available ( ) ; if ( debug ) log . d ( tag , str + available bytes ) ; if ( available bytes < max journal size ) { byte [ ] buffer = new byte [ available bytes ] ; int bytes read = num ; boolean valid = bool ; invalid protocol buffer nano exception last proto exception = null ; while ( available bytes > num ) { try { int result = in stream . read ( buffer , bytes read , num ) ; if ( result > num ) { available bytes -= result ; bytes read += result ; } else { log . w ( tag , str ) ; available bytes = num ; } } catch ( io e ) { buffer = null ; available bytes = num ; } try { message nano . merge from ( journal , read checked bytes ( buffer , bytes read ) ) ; valid = bool ; available bytes = num ; if ( verbose ) log . v ( tag , str + bytes read + str ) ; } catch ( invalid protocol buffer nano exception e ) { last proto exception = e ; journal . clear ( ) ; } } if ( debug ) log . d ( tag , str + bytes read ) ; if ( ! valid ) { log . w ( tag , str , last proto exception ) ; } } } catch ( io e ) { log . w ( tag , str , e ) ; } return journal ; }	read the old journal from the input file.
public server start ( ) throws sql { try { started = bool ; service . start ( ) ; string name = service . get name ( ) + str + service . get url ( ) + str ; thread t = new thread ( this , name ) ; t . set daemon ( service . is daemon ( ) ) ; t . start ( ) ; for ( int i = num ; i < num ; i += i ) { wait ( i ) ; if ( is running ( bool ) ) { return this ; } } if ( is running ( bool ) ) { return this ; } throw db exception . get ( error code . exception opening port 2 , name , str + str ) ; } catch ( db exception e ) { throw db exception . to sql ( e ) ; } }	tries to start the server .
@ override public boolean is complete ( ) { return bool ; }	test if the profile is complete .
public byte matrix encode ( string contents , int width , int height , map < encode hint type , object > hints ) throws writer exception { if ( contents == null || contents . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( width < num || height < num ) { throw new illegal argument exception ( str + width + str + height ) ; } error correction level error correction level = error correction level . l ; if ( hints != null ) { error correction level requested ec = ( error correction level ) hints . get ( encode hint type . error correction ) ; if ( requested ec != null ) { error correction level = requested ec ; } } qr code = new qr ( ) ; encoder . encode ( contents , error correction level , hints , code ) ; return render result ( code , width , height ) ; }	encode a string into a qr code with dimensions width x height.
public int buffer put ( int [ ] src , int src offset , int int count ) { if ( is read only ( ) ) { throw new read only buffer exception ( ) ; } arrays . check offset and count ( src . length , src offset , int count ) ; if ( int count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + int count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes ints from the given int array , starting from the specified offset , to the current position and increases the position by the number of ints written .
public request header ( string key , string value ) { objects . require non null ( key ) ; objects . require non null ( value ) ; headers . put ( key , value ) ; return this ; }	sets a header to use with http request.
public void update ui ( ) { super . update ui ( ) ; set background ( new color ( num , num , num , num ) ) ; set wrap style word ( bool ) ; set highlighter ( null ) ; set editable ( bool ) ; look and feel . install border ( this , str ) ; look and feel . install colors and font ( this , str , str , str ) ; if ( resize handler != null ) { resize handler . component resized ( null ) ; } size policy policy = ( size policy ) get client property ( size policy . class ) ; if ( policy != null ) { gui . restrict size ( this , policy ) ; } }	tells the look and feel to reset some of the values for this component so that it doesn ' t use jtextarea ' s default values . do not call this method yourself !.
public static void generate extension manager ( file root folder ) throws io { file out file = new file ( root folder , registry path ) ; string builder builder = new string builder ( ) ; builder . append ( str ) ; generate imports ( builder ) ; generate class ( builder ) ; file utils . write string to file ( out file , builder . to string ( ) ) ; }	generate to source of the class .
public synchronized future < v > submit ( callable < v > task ) throws rejected execution exception { return pool . submit ( task ) ; }	submits a task for execution .
private void check bucket name ( string name ) throws invalid bucket name exception { if ( name == null ) { throw new invalid bucket name exception ( null string , str ) ; } if ( name . length ( ) < num || name . length ( ) > num ) { string msg = str ; throw new invalid bucket name exception ( name , msg ) ; } if ( name . matches ( str ) ) { string msg = str + str ; throw new invalid bucket name exception ( name , msg ) ; } if ( ! name . matches ( str ) ) { string msg = str + str ; throw new invalid bucket name exception ( name , msg ) ; } }	validates if given bucket name is dns compatible .
private void validate user namespace authorization create request ( user namespace authorization create request request ) { assert . not null ( request , str ) ; validate user namespace authorization key ( request . get user namespace authorization key ( ) ) ; validate namespace permissions ( request . get namespace permissions ( ) ) ; }	validates the user namespace authorization create request.
protected string format ( object o ) { return o . to string ( ) ; }	default object formatter using object.
public void calculate derived ( ) { x stats . calculate derived ( ) ; y stats . calculate derived ( ) ; differences stats . calculate derived ( ) ; correlation = double . n ; if ( ! double . is na n ( x stats . std dev ) && ! double . is na n ( y stats . std dev ) && ! utils . eq ( x stats . std dev , num ) ) { double slope = ( xy sum - x stats . sum * y stats . sum / count ) / ( x stats . sum sq - x stats . sum * x stats . mean ) ; if ( ! utils . eq ( y stats . std dev , num ) ) { correlation = slope * x stats . std dev / y stats . std dev ; } else { correlation = num ; } } if ( utils . gr ( differences stats . std dev , num ) ) { double tval = differences stats . mean * math . sqrt ( count ) / differences stats . std dev ; if ( m degrees of freedom >= num ) { differences probability = statistics . f ( tval * tval , num , m degrees of freedom ) ; } else { if ( count > num ) { differences probability = statistics . f ( tval * tval , num , ( int ) count - num ) ; } else { differences probability = num ; } } } else { if ( differences stats . sum sq == num ) { differences probability = num ; } else { differences probability = num ; } } differences significance = num ; if ( differences probability <= sig level ) { if ( x stats . mean > y stats . mean ) { differences significance = num ; } else { differences significance = - num ; } } }	calculates the derived statistics ( significance etc ) .
protected boolean can delete consistency group ( final block consistency group consistency group ) { return ( ! consistency group . get inactive ( ) && ! consistency group . created ( ) ) ; }	check to see if the consistency group is active and not created.
public static void close quietly ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( runtime exception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
public amqp message receive no wait ( ) throws exception { check closed ( ) ; return prefetch . poll ( ) ; }	if a message is already available in this receiver ' s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .
@ override protected void remove range ( int start , int end ) { if ( start < num ) { throw new index out of bounds exception ( str + start ) ; } else if ( end > size ) { throw new index out of bounds exception ( str + end + str + size ) ; } else if ( start > end ) { throw new index out of bounds exception ( str + start + str + end ) ; } if ( start == end ) { return ; } if ( end == size ) { arrays . fill ( array , first index + start , first index + size , null ) ; } else if ( start == num ) { arrays . fill ( array , first index , first index + end , null ) ; first index += end ; } else { system . arraycopy ( array , first index + end , array , first index + start , size - end ) ; int last index = first index + size ; int new last = last index + start - end ; arrays . fill ( array , new last , last index , null ) ; } size -= end - start ; mod count ++ ; }	removes the objects in the specified range from the start to the end , but not including the end index .
private boolean zz refill ( ) throws java . io . io { if ( zz start read > num ) { system . arraycopy ( zz buffer , zz start read , zz buffer , num , zz end read - zz start read ) ; zz end read -= zz start read ; zz current pos -= zz start read ; zz marked pos -= zz start read ; zz pushback pos -= zz start read ; zz start read = num ; } if ( zz current pos >= zz buffer . length ) { final char new buffer [ ] = new char [ zz current pos * num ] ; system . arraycopy ( zz buffer , num , new buffer , num , zz buffer . length ) ; zz buffer = new buffer ; } final int num read = zz reader . read ( zz buffer , zz end read , zz buffer . length - zz end read ) ; if ( num read < num ) { return bool ; } else { zz end read += num read ; return bool ; } }	refills the input buffer .
protected void stop bk ( ) throws exception { if ( bkc != null ) { bkc . close ( ) ; } for ( bookie server server : bs ) { server . shutdown ( ) ; auto recovery main auto recovery = auto recovery processes . get ( server ) ; if ( auto recovery != null && is auto recovery enabled ( ) ) { auto recovery . shutdown ( ) ; log . debug ( str + server . get local address ( ) ) ; } } bs . clear ( ) ; for ( file f : tmp dirs ) { file utils . delete directory ( f ) ; } }	stop cluster . also , stops all the auto recovery processes for the bookie cluster , if isautorecoveryenabled is true .
public void or ( criteria criteria ) { ored criteria . add ( criteria ) ; }	this method was generated by mybatis generator . this method corresponds to the database table attachment.
public void release selections ( set < entity > items ) { for ( entity item : items ) { release selection ( item ) ; } }	remove selection to a list of items.
public hub link mapping ( string file name , int number of hubs , network network ) { this . number of hubs = number of hubs ; if ( file name . contains ( str ) ) { read mapping table ( file name ) ; un mapped links at zero hub = bool ; return ; } handle unmapped links start ( ) ; try { file reader fr = new file reader ( file name ) ; buffered reader br = new buffered reader ( fr ) ; string line ; string tokenizer tokenizer ; string token ; int link id ; line = br . read line ( ) ; while ( line != null ) { tokenizer = new string tokenizer ( line ) ; for ( int i = num ; i < this . number of hubs ; i ++ ) { token = tokenizer . next token ( ) ; link id = ( int ) double . parse double ( token ) ; link hub mapping . put ( integer . to string ( link id ) , i ) ; } if ( tokenizer . has more tokens ( ) ) { throw new runtime exception ( str ) ; } line = br . read line ( ) ; } } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( str ) ; } link hub mapping . remove ( str ) ; handle unmapped links end ( network ) ; }	reads the mappings from the file . the file has columns ( first column for first hub and all the links corresponding to that hub below it ).
public boolean delete load name ( string load ) { if ( ! load list . contains ( load ) ) { return bool ; } load list . remove ( load ) ; log . debug ( str + get name ( ) + str + load ) ; set dirty and fire property change ( loads changed property , load list . size ( ) + num , load list . size ( ) ) ; return bool ; }	delete a load name that the train will either service or exclude . see setloadoption.
private compute state validate compute name ( string aws id , string vm name ) throws throwable { if ( this . is aws client mock ) { return null ; } compute state compute state = get compute by aws ( this . host , aws id ) ; string tag name value = compute state . name ; assert not null ( str , tag name value ) ; assert equals ( vm name , tag name value ) ; return compute state ; }	validates the tag information on a compute state matches an expected virtual machine name .
public static string from tag ( int array tag tag ) { string builder builder = new string builder ( ) ; builder . append ( array start ) ; boolean start = bool ; for ( int value : tag . get value ( ) ) { int tag i = new int tag ( value ) ; if ( start ) { start = bool ; } else { builder . append ( element seperator ) ; } builder . append ( from tag ( i ) ) ; } builder . append ( array end ) ; return builder . to string ( ) ; }	creates a mojangson string from the given intarray tag .
public static int remove args and return insertion index ( list < string > args , int arg index , boolean try removing arg value ) { if ( arg index < num || arg index >= args . size ( ) ) { return num ; } if ( try removing arg value ) { string arg value = get arg value ( args , arg index + num ) ; if ( arg value != null ) { args . remove ( arg index + num ) ; } } args . remove ( arg index ) ; return arg index ; }	removes the argument at the given index .
void replace policy in resource tree ( service type manager svtm , sso token , policy old policy , policy new policy ) throws policy exception , sso { remove policy from resource tree ( svtm , token , old policy ) ; add policy to resource tree ( svtm , token , new policy ) ; }	replaces a policy ' s relevant content in the resource tree .
public atomic double array ( int length ) { larray = new atomic long array ( length ) ; long zero = double . double to raw long bits ( num ) ; for ( int i = num ; i < length ; i ++ ) larray . set ( i , zero ) ; }	creates a new atomicdoublearray of the given length , with all values initialized to zero.
private void copy action ( file src file , file dest file ) throws file not found exception , io { file input stream istream = new file input stream ( src file ) ; file output stream ostream = new file output stream ( dest file ) ; file channel input = istream . get channel ( ) ; file channel output = ostream . get channel ( ) ; try { input . transfer to ( num , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } }	moved this code into it ' s own method so moveto could use it when the move is across file systems.
private void recompute seperation ( double [ ] [ ] means , double [ ] [ ] cdist , long statistic diststat ) { final int k = means . length ; for ( int i = num ; i < k ; i ++ ) { double vector mi = double vector . wrap ( means [ i ] ) ; for ( int j = num ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance function . distance ( mi , double vector . wrap ( means [ j ] ) ) ; } } if ( diststat != null ) { diststat . increment ( ( k * ( k - num ) ) > > num ) ; } }	recompute the separation of cluster means .
private static buffered image make square ( buffered image input ) { if ( input . get height ( ) == input . get width ( ) ) { return input ; } else { int max = math . max ( input . get height ( ) , input . get width ( ) ) ; int dx = ( max - input . get width ( ) ) / num ; int dy = ( max - input . get height ( ) ) / num ; return create img ( max , max , input . get type ( ) , null ) ; } }	returns an image where the input image is centered .
protected abstract void handle lost entry ( http route route ) ;	handles cleaning up for a lost pool entry with the given route.
public void write start element ( string local name ) throws xml { if ( local name == null || local name . length ( ) == num ) { throw new xml ( str ) ; } state = state element ; if ( current ele != null && current ele . get state ( ) == element starttag open ) { close start tag ( ) ; } current ele = new element ( current ele , local name , bool ) ; open start tag ( ) ; writer . write ( local name ) ; }	writes a start tag to the output .
public void add process interaction listener ( final process interaction listener l ) { if ( l == null ) { throw new illegal argument exception ( str ) ; } process interaction listeners . add ( l ) ; }	adds a listener that will be informed when the user right - clicks an operator or a port .
public str builder replace first ( final string search str , final string replace str ) { final int search len = ( search str == null ? num : search str . length ( ) ) ; if ( search len > num ) { final int index = index of ( search str , num ) ; if ( index >= num ) { final int replace len = ( replace str == null ? num : replace str . length ( ) ) ; replace impl ( index , index + search len , search len , replace str , replace len ) ; } } return this ; }	replaces the first instance of the search string with the replace string .
protected abstract void internal put ( int index , byte b ) ;	stores the byte at the index given .
public common turnout operation config ( turnout operation op ) { super ( op ) ; my op = ( common turnout operation ) op ; max tries spinner = new j ( ) ; interval spinner = new j ( ) ; box vbox = box . create vertical box ( ) ; box hbox1 = box . create horizontal box ( ) ; box hbox2 = box . create horizontal box ( ) ; vbox . add ( hbox2 ) ; vbox . add ( hbox1 ) ; vbox . add ( box . create vertical glue ( ) ) ; hbox1 . add ( new j ( bundle . get message ( str ) ) ) ; hbox1 . add ( box . create horizontal glue ( ) ) ; interval spinner . set minimum size ( new dimension ( num , num ) ) ; interval spinner . set model ( new spinner number model ( my op . get interval ( ) , common turnout operation . min interval , common turnout operation . max interval , common turnout operation . interval step size ) ) ; hbox1 . add ( interval spinner ) ; hbox2 . add ( new j ( bundle . get message ( str ) ) ) ; hbox2 . add ( box . create horizontal glue ( ) ) ; max tries spinner . set minimum size ( new dimension ( num , num ) ) ; max tries spinner . set model ( new spinner number model ( my op . get max tries ( ) , common turnout operation . min max tries , common turnout operation . max max tries , num ) ) ; hbox2 . add ( max tries spinner ) ; box hbox3 = box . create horizontal box ( ) ; hbox3 . add ( box . create horizontal strut ( num ) ) ; vbox . add ( hbox3 ) ; add ( vbox ) ; }	create the config jpanel , if there is one , to configure this operation type.
public static string gensalt ( int log rounds , secure random random ) { if ( log rounds < num || log rounds > num ) { throw new illegal argument exception ( str ) ; } string builder rs = new string builder ( ) ; byte rnd [ ] = new byte [ bcrypt salt len ] ; random . next bytes ( rnd ) ; rs . append ( str ) ; if ( log rounds < num ) { rs . append ( str ) ; } rs . append ( log rounds ) ; rs . append ( str ) ; encode base64 ( rnd , rnd . length , rs ) ; return rs . to string ( ) ; }	generate a salt for use with the bcrypt . hashpw ( ) method.
protected void draw description ( canvas c ) { if ( ! m description . equals ( str ) ) { if ( m description position == null ) { c . draw text ( m description , get width ( ) - m view port handler . offset right ( ) - num , get height ( ) - m view port handler . offset bottom ( ) - num , m desc paint ) ; } else { c . draw text ( m description , m description position . x , m description position . y , m desc paint ) ; } } }	draws the description text in the bottom right corner of the chart.
long parse bytes ( string free space , string path ) throws io { try { long bytes = long . parse long ( free space ) ; if ( bytes < num ) { throw new io ( str + df + str + str + path + str ) ; } return bytes ; } catch ( number format exception ex ) { throw new io ( str + df + str + str + path + str , ex ) ; } }	parses the bytes from a string .
public string find interlanguage link ( string lang ) { int start = page . index of ( str + lang + str ) ; if ( start < num ) return null ; int end = page . index of ( str , start ) ; if ( end < num ) return null ; string link = page . substring ( start + num + lang . length ( ) , end ) ; if ( link . index of ( str ) != - num ) { return null ; } if ( link . length ( ) == num ) return null ; return link ; }	returns the inter - language link to a specific language ( if any ) .
private void update actions ( final i address space ) { m load address space action . set enabled ( ! address space . is loaded ( ) ) ; }	updates the menu actions depending on the state of the given address space .
public static < t > parallel flux < t > from ( publisher < ? extends t > source , int parallelism ) { return from ( source , parallelism , queue supplier . small buffer size , queue supplier . small ( ) ) ; }	take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .
private static void clean directory on exit ( file directory ) throws io { if ( ! directory . exists ( ) ) { string message = directory + str ; throw new illegal argument exception ( message ) ; } if ( ! directory . is directory ( ) ) { string message = directory + str ; throw new illegal argument exception ( message ) ; } file [ ] files = directory . list files ( ) ; if ( files == null ) { throw new io ( str + directory ) ; } io exception = null ; for ( file file : files ) { try { force delete on exit ( file ) ; } catch ( io ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }	cleans a directory without deleting it .
private void add gumball ( float x pos , float y pos ) { gumball gumball = new gumball ( ) ; gumball . m x = x pos ; gumball . m y = y pos ; gumball . m sound pool id = uuid . random uuid ( ) ; m sound pool id . put ( gumball . m sound pool id , bool ) ; m game view . add gumball ( gumball ) ; m sound pool . play ( m sound ball drop , num , num , num , num , num ) ; }	add a gumball to the game and play the ball drop sound .
int put ( t segment , list < ? super t > recycle bin ) { int count ; if ( last count == num ) { count = num ; last count = num ; last = segment ; } else if ( objects . deep equals ( last , segment ) ) { ++ last count ; count = num ; recycle bin . add ( segment ) ; } else { count = last count ; last count = num ; last = segment ; } return count ; }	adds an element to the stream.
@ known failure ( str ) public void test delete6 ( ) throws sql { database creator . fill fk ( conn ) ; statement . execute ( str + database creator . fkstrict table + str + database creator . parent table + str ) ; result set r = statement . execute query ( str + database creator . fkstrict table + str ) ; r . next ( ) ; assert equals ( str , num , r . get int ( num ) ) ; r . close ( ) ; }	deletefunctionalitytest # testdelete6 ( ) . todo foreign key functionality is not supported.
public channel chan ( final string topic , final json node payload ) { log . log ( level . fine , str , new object [ ] { topic , payload } ) ; final channel channel = new channel ( topic , payload , socket . this ) ; synchronized ( channels ) { channels . add ( channel ) ; } return channel ; }	retrieve a channel instance for the specified topic.
public pla point float change size ( double p new size ) { if ( v x == num && v y == num ) { return this ; } double length = math . sqrt ( v x * v x + v y * v y ) ; double new x = ( v x * p new size ) / length ; double new y = ( v y * p new size ) / length ; return new pla point float ( new x , new y ) ; }	approximates a floatpoint on the line from zero to this point with distance p_new_length from zero .
int insert ( row row , byte [ ] source buffer , int source offset , blob output stream [ ] blobs ) { int row head = row head ; int blob tail = blob tail ; int row length = row . length ( ) ; row head -= row length ; if ( row head < blob tail ) { return - num ; } byte [ ] buffer = buffer ; system . arraycopy ( source buffer , source offset , buffer , row head , row length ) ; buffer [ row head ] = ( byte ) ( ( buffer [ row head ] & ~ code mask ) | insert ) ; blob tail = row . insert blobs ( buffer , row head , blob tail , blobs ) ; if ( blob tail < num ) { return - num ; } set blob tail ( blob tail ) ; row head ( row head ) ; validate block ( row ) ; return row head ; }	inserts a new row into the block .
private void add default uri ( ) throws ignite spi exception { assert uri encoded list != null ; uri uri ; try { uri = u . resolve work directory ( dflt deploy dir , bool ) . to uri ( ) ; } catch ( ignite checked exception e ) { throw new ignite spi exception ( str , e ) ; } uri encoded list . add ( uri ) ; }	add configuration for file scanner .
protected void transfer ( string seq range ) throws io { try { final int range pos = seq range . index of ( str ) ; if ( range pos == - num ) { transfer ( long . parse long ( seq range ) ) ; } else { final string start = seq range . substring ( num , range pos ) ; final string end = seq range . substring ( range pos + num ) ; final long start idx ; if ( start . length ( ) == num ) { start idx = num ; } else { start idx = long . parse long ( start ) ; } final long end idx ; if ( end . length ( ) == num ) { end idx = m reader . number sequences ( ) - num ; } else { end idx = long . parse long ( end ) ; } if ( start idx > end idx ) { throw new number format exception ( str + seq range ) ; } for ( long i = start idx ; i <= end idx ; i ++ ) { transfer ( i ) ; } } } catch ( final number format exception e ) { warn invalid sequence ( seq range ) ; } }	transfer an interpreted sequence or set of sequences from the reader to the writer.
public static double distance point line perpendicular ( coordinate p , coordinate a , coordinate b ) { double len2 = ( b . x - a . x ) * ( b . x - a . x ) + ( b . y - a . y ) * ( b . y - a . y ) ; double s = ( ( a . y - p . y ) * ( b . x - a . x ) - ( a . x - p . x ) * ( b . y - a . y ) ) / len2 ; return math . abs ( s ) * math . sqrt ( len2 ) ; }	computes the perpendicular distance from a point p to the ( infinite ) line containing the points ab.
big integer copy ( ) { prepare java representation ( ) ; int [ ] copy digits = new int [ number length ] ; system . arraycopy ( digits , num , copy digits , num , number length ) ; return new big integer ( sign , number length , copy digits ) ; }	returns a copy of the current instance to achieve immutability.
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . replace data ( num , num , str ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; }	runs the test case .
public string patch fix ids ( ) { return properties . get property ( str ) ; }	returns the set of bug ids for fixes included in this build of the directory server .
public final void read fully ( byte [ ] b ) throws java . io . io { read fully ( b , num , b . length ) ; }	see the general contract of the readfully method of datainput.
public static boolean is jellybean or later ( ) { return build . version . sdk int >= build . version codes . jelly bean ; }	returns whether the sdk is the jellybean release or later .
public partial correlation pdf ( int n , int k ) { this . n = n ; this . k = k ; double gamma ratio = gamma ratio ( n , k ) ; this . constant = ( num / math . pow ( math . pi , num ) ) * gamma ratio ; this . outside exp = ( double ) ( n - k - num ) / num ; }	constructs a new zero partial correlation distribution function with the given values for n and k .
private static boolean is enabled ( ) { if ( system utils . is os windows ) { return bool ; } try { list < string > lines = command util . execute command and get lines ( collections . singleton list ( str ) ) ; for ( string line : lines ) { if ( line . contains ( str ) ) { if ( line . contains ( str ) ) { logger . info ( str ) ; return bool ; } return bool ; } } } catch ( exception ex ) { } return bool ; }	check whether selinux is enabled or not .
public boolean validate ( ) { output file = new file ( output path ) ; if ( output file . exists ( ) || output file . is directory ( ) ) { invalid message = str ; return valid = bool ; } if ( ! sign mode ) { key file = new file ( key file path ) ; if ( ! key file . exists ( ) || key file . is directory ( ) ) { invalid message = str ; return valid = bool ; } } return valid = bool ; }	initialises and checks validity of files.
public void add response code listener ( action listener a ) { response code listeners . add element ( a ) ; }	adds a response listener on the requests.
public double calculate log likelihood ( ) { double log l = num ; for ( statistic statistic : data list ) { for ( int j = num ; j < statistic . get dimension ( ) ; j ++ ) { log l -= math . log ( statistic . get statistic value ( j ) ) ; } } return log l ; }	calculate the log likelihood of the current state .
public static boolean has dead states from initial ( automaton a ) { bit set reachable from initial = get live states from initial ( a ) ; bit set reachable from accept = get live states to accept ( a ) ; reachable from initial . and not ( reachable from accept ) ; return reachable from initial . is empty ( ) == bool ; }	returns true if there are dead states reachable from an initial state .
public decimal subtract ( decimal decimal ) { assert defined ( ) ; if ( null == m value ) { return ( decimal ) ; } big decimal value = m value . subtract ( decimal . get big decimal value ( ) ) ; return new decimal ( value , scale ) ; }	subtracts two decimal objects.
public final boolean equals ( object object ) { if ( object == null ) { return bool ; } if ( ! ( object instanceof knowledge edge ) ) { return bool ; } knowledge edge pair = ( knowledge edge ) object ; return from . equals ( pair . from ) && to . equals ( pair . to ) ; }	reteurns true if ( from1 , to1 ) = = ( from2 , to2 ) .
protected int skip line ( int c ) throws io { while ( c != - num && c != str && c != str ) { c = reader . read ( ) ; } if ( c == str ) { c = reader . read ( ) ; line no ++ ; report location ( line no , num ) ; } else if ( c == str ) { c = reader . read ( ) ; if ( c == str ) { c = reader . read ( ) ; } line no ++ ; report location ( line no , num ) ; } return c ; }	reads characters from reader until the first eol has been read.
@ override public void list volumes ( command input input , completion handler completion handler ) { create or update target ssl ( input ) ; uri uri = uri utils . extend uri ( input . get docker uri ( ) , str ) ; send get ( uri , null , completion handler ) ; }	https : / / docs.
public static byte buffer base64 string to byte buffer ( string base64 encoded key ) { return byte buffer . wrap ( base64 decode string ( base64 encoded key ) ) ; }	converts a base64 encoded key into a bytebuffer.
public boolean step ( ) { long current = system . current time millis ( ) ; if ( m start == num || ( current - m start < num ) ) { m progress = num ; } else if ( current - m start > m duration ) { if ( m loop ) { m progress = num ; start ( ) ; return bool ; } m progress = num ; return bool ; } else { m progress = ( current - m start ) / ( double ) m duration ; } return bool ; }	step in the animation.
protected void load raw characters ( string builder sb ) throws io { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case character sequence . char seq escaped newline sequence 1 : case character sequence . char seq escaped newline sequence 2 : case character sequence . char seq escaped newline sequence 3 : continue ; case - num : return ; default : if ( ! x . is7bit value ( c ) ) { c = read large char sequence ( c ) ; } } if ( ut . needs surrogate encoding ( c ) ) { sb . append ( ut . high surrogate ( c ) ) ; c = ut . low surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }	this is used to load a previously marked set of bytes into the stringbuilder without escaping.
public signature faking oracle ( final string document string ) throws signature faking exception { security . add provider ( new bouncy castle provider ( ) ) ; signature value elements = new linked list < node > ( ) ; key info elements = new linked list < node > ( ) ; certificates = new linked list < string > ( ) ; cert handlers = new linked list < certificate handler > ( ) ; try { doc = dom utilities . string to dom ( document string ) ; crawl signature elements ( ) ; log . debug ( str + signature value elements . size ( ) + str ) ; crawl key info elements ( ) ; log . debug ( str + key info elements . size ( ) + str ) ; } catch ( sax e ) { throw new signature faking exception ( e ) ; } }	creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements.
public arbitrary length path node ( final term node left , final term node right , final var node t var left , final var node t var right , final long lower bound , final long upper bound ) { this ( new b [ ] { new join group node ( ) } , nv . as map ( new nv ( annotations . left term , left ) , new nv ( annotations . right term , right ) , new nv ( annotations . transitivity var left , t var left ) , new nv ( annotations . transitivity var right , t var right ) , new nv ( annotations . drop vars , new array list < var node > ( ) ) , new nv ( annotations . lower bound , lower bound ) , new nv ( annotations . upper bound , upper bound ) ) ) ; final set < var node > drop vars = new linked hash set < > ( ) ; drop vars . add ( t var left ) ; drop vars . add ( t var right ) ; set property ( annotations . drop vars , drop vars ) ; }	fully construct an arbitrary length path node with all required annotations .
public void add changing listener ( on wheel changed listener listener ) { changing listeners . add ( listener ) ; }	adds wheel changing listener.
private integer scan yaml directive number ( mark start mark ) { char ch = reader . peek ( ) ; if ( ! character . is digit ( ch ) ) { throw new scanner exception ( str , start mark , str + ch + str + ( ( int ) ch ) + str , reader . get mark ( ) ) ; } int length = num ; while ( character . is digit ( reader . peek ( length ) ) ) { length ++ ; } integer value = integer . parse int ( reader . prefix forward ( length ) ) ; return value ; }	read a % yaml directive number : this is either the major or the minor part.
public static final string to bit string ( int i [ ] ) { string builder sb = new string builder ( i . length ) ; for ( int b : i ) { sb . append ( b ) ; } return sb . to string ( ) ; }	tobitstring - returns a string representation of i [ ] .
public static byte buffer convert to signed16 bit samples ( buffer buffer ) { return convert to signed16 bit samples ( buffer . get samples ( ) ) ; }	converts the float samples in a complex buffer to a little endian 16 - bit buffer.
boolean check token ( byte wrapper token , key node id , inet address ip , int port , key lookup key ) { update token timestamps ( ) ; boolean valid = check token ( token , node id , ip , port , lookup key , timestamp current . get ( ) ) || check token ( token , node id , ip , port , lookup key , timestamp previous ) ; if ( ! valid ) dht . log debug ( str + ip . get host address ( ) ) ; return valid ; }	check if a received token is ok .
private void write attribute ( java . lang . string namespace , java . lang . string att name , java . lang . string att value , javax . xml . stream . xml xml writer ) throws javax . xml . stream . xml { if ( namespace . equals ( str ) ) { xml writer . write attribute ( att name , att value ) ; } else { register prefix ( xml writer , namespace ) ; xml writer . write attribute ( namespace , att name , att value ) ; } }	util method to write an attribute without the ns prefix.
public void expand all ( ) { cancel editing ( ) ; final tree model tm = get model ( ) ; final object root = tm . get root ( ) ; if ( root != null ) { expand all paths ( new tree path ( root ) , tm ) ; } }	expands all paths in the tree .
protected void describe vocabularies ( final iv [ ] predicate partition counts ) { final set < string > namespaces = new linked hash set < string > ( ) ; { for ( iv tmp : predicate partition counts ) { final uri p = ( uri ) tmp . get value ( ) ; string namespace = p . get namespace ( ) ; if ( namespace . ends with ( str ) ) { namespace = namespace . substring ( num , namespace . length ( ) - num ) ; } namespaces . add ( namespace ) ; } } final string [ ] a = namespaces . to array ( new string [ namespaces . size ( ) ] ) ; arrays . sort ( a ) ; for ( string namespace : a ) { g . add ( a dataset , void vocabulary decl . vocabulary , f . create uri ( namespace ) ) ; } }	describe the vocabularies which are in use in the kb based on the predicate partition statistics .
public void test invoke any4 ( ) throws throwable { count down latch latch = new count down latch ( num ) ; executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new array list < callable < string > > ( ) ; l . add ( latch awaiting string task ( latch ) ) ; l . add ( null ) ; try { e . invoke any ( l ) ; should throw ( ) ; } catch ( null pointer exception success ) { } latch . count down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeany ( c ) throws nullpointerexception if c has null elements.
public signal group sub table action ( string s ) { }	create an action with a specific title.
public static list < string > generate x ( int from , int to ) { list < string > xvals = new array list < string > ( ) ; for ( int i = from ; i < to ; i ++ ) { xvals . add ( str + i ) ; } return xvals ; }	generates an x - values array filled with numbers in range specified by the parameters.
public void test compare to diff signs1 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
private hash map add attr ( svc reg reg , entry class eclass , int fldidx , object value ) { hash map [ ] attr maps = service by attr . get ( eclass ) ; if ( attr maps == null ) { attr maps = new hash map [ eclass . get num fields ( ) ] ; service by attr . put ( eclass , attr maps ) ; } hash map map = attr maps [ fldidx ] ; if ( map == null ) { map = new hash map ( num ) ; attr maps [ fldidx ] = map ; } array list regs = ( array list ) map . get ( value ) ; if ( regs == null ) { regs = new array list ( num ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }	put the service under the given attribute value for the given defining class and field , if it isn ' t already there.
public query string decoder util ( uri uri ) { this ( uri , charset . default charset ( ) ) ; }	creates a new decoder that decodes the specified uri.
public static float [ ] cmyk from rgb ( int rgb color ) { int red = ( num & rgb color ) > > num ; int green = ( num & rgb color ) > > num ; int blue = ( num & rgb color ) ; float black = math . min ( num - red / num , math . min ( num - green / num , num - blue / num ) ) ; float cyan = num ; float magenta = num ; float yellow = num ; if ( black != num ) { cyan = ( num - ( red / num ) - black ) / ( num - black ) ; magenta = ( num - ( green / num ) - black ) / ( num - black ) ; yellow = ( num - ( blue / num ) - black ) / ( num - black ) ; } return new float [ ] { cyan , magenta , yellow , black } ; }	convert rgb color to cmyk color .
public static void show error message ( string msg ) { show error message ( msg , num ) ; }	simplifies a common use case of showing an error message with an error icon that fades out after a few seconds.
public final static name value pair parse name value pair ( final string value , header value parser parser ) throws parse exception { if ( value == null ) { throw new illegal argument exception ( str ) ; } if ( parser == null ) parser = basic header value parser . default ; char array buffer buffer = new char array buffer ( value . length ( ) ) ; buffer . append ( value ) ; parser cursor cursor = new parser cursor ( num , value . length ( ) ) ; return parser . parse name value pair ( buffer , cursor ) ; }	parses a name - value - pair with the given parser .
public static string strip chars in bag ( string s , string bag ) { int i ; string builder string builder = new string builder ( str ) ; for ( i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( bag . index of ( c ) == - num ) string builder . append ( c ) ; } return string builder . to string ( ) ; }	removes all characters which appear in string bag from string s .
public static double cos ( double radians ) { return math . cos ( radians ) ; }	returns the trigonometric cosine of the specified angle in radians .
@ override protected void on destroy ( ) { super . on destroy ( ) ; do really stop ( bool ) ; m fragments . dispatch destroy ( ) ; if ( m loader manager != null ) { m loader manager . do destroy ( ) ; } }	destroy all fragments and loaders .
public void remove vetoable change listener ( string property name , vetoable change listener in vcl ) { bean context child support . remove vetoable change listener ( property name , in vcl ) ; }	method for beancontextchild interface .
static public boolean does file exist ( context c , string file name , long file size , boolean delete file on mismatch ) { file file for new file = new file ( helpers . generate save file name ( c , file name ) ) ; if ( file for new file . exists ( ) ) { if ( file for new file . length ( ) == file size ) { return bool ; } if ( delete file on mismatch ) { file for new file . delete ( ) ; } } return bool ; }	helper function to ascertain the existence of a file and return true / false appropriately.
static windows file attributes from find data ( long address ) { int file attrs = unsafe . get int ( address + offsetof find data attributes ) ; long creation time = unsafe . get long ( address + offsetof find data createtime ) ; long last access time = unsafe . get long ( address + offsetof find data lastaccesstime ) ; long last write time = unsafe . get long ( address + offsetof find data lastwritetime ) ; long size = ( ( long ) ( unsafe . get int ( address + offsetof find data sizehigh ) ) << num ) + ( unsafe . get int ( address + offsetof find data sizelow ) & num ) ; int reparse tag = is reparse point ( file attrs ) ? unsafe . get int ( address + offsetof find data reserve ) : num ; return new windows file attributes ( file attrs , creation time , last access time , last write time , size , reparse tag , num , num , num ) ; }	create a windowsfileattributes from a win32_find_data structure.
public static final void write map xml ( map val , xml serializer out , write map callback callback ) throws xml pull parser exception , io { if ( val == null ) { return ; } set s = val . entry set ( ) ; iterator i = s . iterator ( ) ; while ( i . has next ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; write value xml ( e . get value ( ) , ( string ) e . get key ( ) , out , callback ) ; } }	flatten a map into an xmlserializer.
public void fire event programmatically ( event event ) { if ( ! event . is consumed ( ) ) rippler pane . fire event ( event ) ; }	fire event to the rippler pane manually.
private boolean has full entry ( json value entry , query side query side ) { if ( query side == query side . source && source query full entry != null ) { return source query full entry ; } else if ( query side == query side . target && target query full entry != null ) { return target query full entry ; } if ( entry != null ) { short ignore fields = num ; if ( entry . is defined ( str ) ) { ignore fields ++ ; } if ( entry . is defined ( str ) ) { ignore fields ++ ; } ignore fields += num ; return entry . size ( ) > ignore fields ; } else { return bool ; } }	whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting.
public static boolean is module ( i resource ) { return ( resource != null && tla extension . equals ( resource . get file extension ( ) ) ) ; }	determines if the given member is a tla + module.
public int write annotation ( annotation annotation ) { int off = data . position ( ) ; write byte ( annotation . visibility ) ; write encoded array ( annotation . encoded annotation ) ; return off ; }	write annotation item into current section .
public static long from inet4 address ( final inet address inet address ) { ensure is inet4 address ( inet address ) ; return integer . to unsigned long ( inet address . hash code ( ) ) ; }	pack ipv4 address and match - all socket flag into a long .
public boolean revision contains template name ( int rev id , string template name ) throws wiki api exception { return revision contains template names ( rev id , arrays . as list ( new string [ ] { template name } ) ) ; }	determines whether a given revision contains a given template name.
public list < generic entry > retrieve all account info requests ( date from date ) throws apps for your domain exception , io , service exception { string url = base url + str + domain ; if ( from date != null ) { url += str + date format . format ( from date ) ; } return get all pages ( new url ( url ) , generic feed . class ) ; }	retrieve all the account info requests from the given start date .
public string list plus ( string ... args ) { string list new list = new string list ( ) ; new list . add all ( this ) ; new list . add all ( arrays . as list ( args ) ) ; return new list ; }	add a list of strings .
private void walk parse tree ( list < swift base listener > listeners , top level context tree ) { parse tree walker walker = new parse tree walker ( ) ; listeners . for each ( null ) ; }	walks the provided parse tree using the list of listeners .
@ override public final char read char ( ) throws io { dis . read fully ( work , num , num ) ; return ( char ) ( ( work [ num ] & num ) << num | ( work [ num ] & num ) ) ; }	read on char . like datainputstream . readchar except little endian .
public static int truncated compare to ( final date date1 , final date date2 , final int field ) { final date truncated date1 = truncate ( date1 , field ) ; final date truncated date2 = truncate ( date2 , field ) ; return truncated date1 . compare to ( truncated date2 ) ; }	determines how two dates compare up to no more than the specified most significant field .
protected list < decompounded word > make split ( string a word ) { list < decompounded word > result = new array list < decompounded word > ( ) ; for ( int i = num ; i < a word . length ( ) ; i ++ ) { string left word = a word . substring ( num , i + num ) ; string right word = a word . substring ( i + num ) ; boolean left good = dict . contains ( left word ) && left word . length ( ) >= min word length ; boolean right good = right word . length ( ) > min rest length || right word . length ( ) == num ; if ( left good && right good ) { decompounded word split = decompounded word . create from string ( left word + str + right word ) ; split . set split pos ( i ) ; result . add ( split ) ; } for ( string morpheme : morphemes . get all ( ) ) { try { string left without morpheme = left word . substring ( num , left word . length ( ) - morpheme . length ( ) ) ; if ( left word . ends with ( morpheme ) && dict . contains ( left without morpheme ) && right good ) { decompounded word split = decompounded word . create from string ( left without morpheme + str + morpheme + str + right word ) ; split . set split pos ( i ) ; result . add ( split ) ; } } catch ( string index out of bounds exception e ) { continue ; } } } return result ; }	splits a word in two word .
public static boolean is book search url ( string url ) { return url . starts with ( str ) || url . starts with ( str ) ; }	does a given url point to google book search , regardless of domain .
public static string class name path ( string class name ) { string filename = class name . replace ( str , file . separator ) ; filename = filename . replace first ( str , str ) ; if ( filename . index of ( str ) > num ) { filename = filename . substring ( num , filename . index of ( str ) ) ; } return str + file . separator + filename + str ; }	returns the relative path for a fully qualified classname.
public void remove title prefix ( string prfx ) { title prefix . remove ( prfx ) ; fire property change ( title prefix , null , title prefix ) ; }	removes the title prefix .
public void send ( set recipients , boolean multicast ) throws interrupted exception , reply exception { final boolean is debug enabled = logger . is debug enabled ( ) ; if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; recipients = new hash set ( recipients ) ; distributed member me = origin dm . get distribution manager id ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( is debug enabled ) { logger . debug ( str , recipients ) ; } rp = new reply processor21 ( origin dm , recipients ) ; processor id = rp . get processor id ( ) ; set recipients ( recipients ) ; set multicast ( multicast ) ; set failures = origin dm . put outgoing ( this ) ; if ( failures != null && failures . size ( ) > num ) { for ( iterator i = failures . iterator ( ) ; i . has next ( ) ; ) { internal distributed member mbr = ( internal distributed member ) i . next ( ) ; if ( is debug enabled ) { logger . debug ( str , mbr ) ; } } } rp . wait for replies ( ) ; }	send the message and wait for replies.
private boolean is relevant ( object service , entry [ ] attributes ) { loop : for ( entry e : service attributes ) { for ( entry en : attributes ) { if ( e . equals ( en ) ) continue loop ; } return bool ; } boolean flag = bool ; for ( entry en : attributes ) { if ( service name . equals ( en ) ) { flag = bool ; break ; } } if ( ! flag ) return bool ; flag = bool ; for ( class cl : classes ) { if ( cl . is instance ( service ) ) { flag = bool ; break ; } } return flag ; }	is relevant service . used as filter for the incoming events .
private static boolean eq ( object o1 , object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }	test for equality , coping with nulls .
public int find car by road number ( string road number ) { if ( sys list != null ) { if ( ! road number . equals ( road number ) ) { return get index ( num , road number ) ; } int index = get index ( index , road number ) ; if ( index > num ) { return index ; } return get index ( num , road number ) ; } return - num ; }	search for car by road number.
@ slashed class name @ fb ( str ) public static string to slashed class name ( @ slashed class name ( when = when . unknown ) string class name ) { if ( class name . index of ( str ) >= num ) { return descriptor factory . canonicalize string ( class name . replace ( str , str ) ) ; } return class name ; }	convert class name to slashed format.
public static double p ( int y [ ] , int r [ ] ) { double avg prec = num ; int l = y . length ; list < integer > ones = new array list < integer > ( ) ; for ( int j = num ; j < l ; j ++ ) { if ( y [ j ] == num ) { ones . add ( j ) ; } } if ( ones . size ( ) <= num ) return num ; for ( int j : ones ) { double s = num ; for ( int k : ones ) { if ( r [ k ] <= r [ j ] ) { s ++ ; } } avg prec += ( s / ( num + r [ j ] ) ) ; } avg prec /= ones . size ( ) ; return avg prec ; }	average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .
public location new location ( string name ) { location location = get location by name ( name ) ; if ( location == null ) { id ++ ; location = new location ( integer . to string ( id ) , name ) ; integer old size = integer . value of ( location hash table . size ( ) ) ; location hash table . put ( location . get id ( ) , location ) ; set dirty and fire property change ( listlength changed property , old size , integer . value of ( location hash table . size ( ) ) ) ; } return location ; }	finds an existing location or creates a new location if needed requires location ' s name creates a unique id for this location.
@ override public void close ( ) { closing = bool ; if ( reservations == null || reservations . compare and set ( num , - num ) ) do close ( ) ; }	closes tree map and reclaims memory .
private void remove oma ( long download id ) { set < string > oma downloads = get stored download info ( pending oma downloads ) ; for ( string oma download : oma downloads ) { oma entry = oma . parse oma ( oma download ) ; if ( entry . m download id == download id ) { oma downloads . remove ( oma download ) ; store download info ( pending oma downloads , oma downloads ) ; return ; } } }	remove oma download info from sharedprefs .
public static boolean is android sdk dir in local properties file ( @ not null file project dir ) { string android home = get android home from local properties file ( project dir ) ; if ( ! strings . is null or empty ( android home ) ) { string msg = string . format ( str , android home ) ; log . info ( msg ) ; return bool ; } return bool ; }	indicates whether the path of the android sdk home directory is specified in a local.
public static boolean has token information ( bundle bundle ) { if ( bundle == null ) { return bool ; } string token = bundle . get string ( token key ) ; if ( ( token == null ) || ( token . length ( ) == num ) ) { return bool ; } long expires milliseconds = bundle . get long ( expiration date key , num ) ; if ( expires milliseconds == num ) { return bool ; } return bool ; }	returns a boolean indicating whether a bundle contains properties that could be a valid saved token .
public void reset policy ( ) { m preferences . put string ( pref last response , integer . to string ( policy . retry ) ) ; set retry until ( default retry until ) ; set max retries ( default max retries ) ; set retry count ( long . parse long ( default retry count ) ) ; set validity timestamp ( default validity timestamp ) ; m preferences . commit ( ) ; }	we call this to guarantee that we fetch a fresh policy from the server.
@ override public boolean connection allowed ( string event name ) { if ( event name . equals ( str ) && m listenees . contains key ( event name ) ) { return bool ; } return bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
public static vector2 pow ( vector2 o , double power ) { return new vector2 ( math . pow ( o . x , power ) , math . pow ( o . z , power ) ) ; }	raises the x and y values of a vector2 to the given power .
public static object invoke static ( string clazz , string method name , class [ ] types , object [ ] values ) throws no such method exception { try { return invoke static ( class . for name ( clazz ) , method name , types , values ) ; } catch ( class not found exception e ) { throw new no such method exception ( str + clazz + str ) ; } }	invokes the specified parameterless method if it exists .
public prototype undump ( input stream stream , string chunkname ) throws io { if ( stream . read ( ) != lua signature [ num ] || stream . read ( ) != lua signature [ num ] || stream . read ( ) != lua signature [ num ] || stream . read ( ) != lua signature [ num ] ) return null ; string sname = get source name ( chunkname ) ; load state s = new load state ( stream , sname ) ; s . load header ( ) ; switch ( s . luac number format ) { case number format floats or doubles : case number format ints only : case number format num patch in : break ; default : throw new lua error ( str ) ; } return s . load function ( lua string . value of ( sname ) ) ; }	load input stream as a lua binary chunk if the first 4 bytes are the lua binary signature .
public void add button ( url url , string info , action listener al ) { j b = new j ( new image icon ( url , info ) ) ; b . set tool tip text ( info ) ; b . set margin ( new insets ( num , num , num , num ) ) ; b . add action listener ( al ) ; b . set border painted ( bool ) ; add ( b ) ; }	add a button to the panel .
private void map request to responses ( matcher < request > request matcher , response source responses ) { mappings . add ( new matcher response source pair ( request matcher , responses ) ) ; }	set up a reaction to requests matching certain criteria.
@ override protected void commit to input ( ) { jmx bean sensor assignment assignment = get input ( ) ; if ( null != assignment ) { assignment . set domain ( domain text . get text ( ) ) ; assignment . set object name parameters ( new hash map < > ( parameters map ) ) ; if ( all attributes button . get selection ( ) ) { assignment . set attributes ( collections . < string > empty set ( ) ) ; } else { assignment . set attributes ( new hash set < > ( attributes set ) ) ; } } }	commits changes in page to input .
public static string [ ] split ( string original , string separator ) { vector nodes = new vector ( ) ; int index = original . index of ( separator ) ; while ( index >= num ) { nodes . add element ( original . substring ( num , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . index of ( separator ) ; } nodes . add element ( original ) ; string [ ] ret = new string [ nodes . size ( ) ] ; for ( int i = num ; i < nodes . size ( ) ; i ++ ) { ret [ i ] = ( string ) nodes . element at ( i ) ; } return ret ; }	provides a utility method breaks a given string to array of string according to the given separator.
public void insert twin ( instruction inst , instruction twin ) { list iterator < gcir > iter = list . list iterator ( ) ; while ( iter . has next ( ) ) { gcir new ptr = iter . next ( ) ; if ( new ptr . get instruction ( ) == inst ) { iter . add ( new ptr . create twin ( twin ) ) ; return ; } } throw new optimizing compiler exception ( str + inst + str ) ; }	this method inserts an entry for a " twin " instruction immediately after the original entry.
public java . lang . object new instance ( ) throws java . lang . instantiation exception , java . lang . illegal access exception { object o = new instance impl ( ) ; if ( o == null ) { throw new instantiation exception ( ) ; } return o ; }	creates a new instance of a class .
format specifier parser ( string format ) { this . format = format ; this . length = format . length ( ) ; }	constructs a new parser for the given format string .
public static void to string ( iterator < ? > iter , string separator , string builder sb ) { while ( iter . has next ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . has next ( ) ) { sb . append ( separator ) ; } } }	converts an iterator to a string by concatenating all of the string representations of objects in the iterator , divided by a separator .
public boolean is full ( ) { if ( max size > num && notifications . size ( ) >= max size ) { return bool ; } return bool ; }	check whether this matcher has reached " max - size " or not .
private void schedule playlist save ( ) { if ( ! m playlist loading ) { if ( m playlist save pending . compare and set ( bool , bool ) ) { m thread pool manager . schedule once ( new playlist save task ( ) , num , time unit . seconds ) ; } } }	schedules a playlist save task.
public boolean is to read ( ) { iterator < variable value > i = variables . iterator ( ) ; while ( i . has next ( ) ) { variable value v = i . next ( ) ; if ( v . is to read ( ) ) { return bool ; } } return bool ; }	this variable needs to be read if any of it ' s subsidiary variables needs to be read .
public void action performed ( action event e ) { navigate to prior demo ( ) ; }	invoked when an action occurs .
public string to string ( ) { string buffer text = new string buffer ( ) ; for ( int i = num ; i < m . length ; i ++ ) { if ( i > num ) text . append ( str ) ; text . append ( utils . double to string ( m [ i ] , num ) ) ; } text . append ( str ) ; return text . to string ( ) ; }	converts a vector to a string.
@ deprecated public static integer integer ( int i ) { return integer . value of ( i ) ; }	return a integer object with same value.
public static void v ( string tag , string msg , object ... args ) { if ( s level > level verbose ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . v ( tag , msg ) ; }	send a verbose log message .
public void save indexes ( ) { array list to save = new array list ( ) ; synchronized ( this ) { object [ ] value table = this . indexes . value table ; for ( int i = num , l = value table . length ; i < l ; i ++ ) { index index = ( index ) value table [ i ] ; if ( index != null ) to save . add ( index ) ; } } boolean all saved = bool ; for ( int i = num , length = to save . size ( ) ; i < length ; i ++ ) { index index = ( index ) to save . get ( i ) ; read write monitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enter read ( ) ; if ( index . has changed ( ) ) { if ( monitor . exit read enter write ( ) ) { try { save index ( index ) ; } catch ( io e ) { if ( verbose ) { util . verbose ( str , system . err ) ; e . print stack trace ( ) ; } all saved = bool ; } finally { monitor . exit write enter read ( ) ; } } else { all saved = bool ; } } } finally { monitor . exit read ( ) ; } } if ( this . participants containers != null && this . participant updated ) { write participants index names file ( ) ; this . participant updated = bool ; } this . need to save = ! all saved ; }	commit all index memory changes to disk.
private double match bitap score ( int e , int x , int loc , string pattern ) { float accuracy = ( float ) e / pattern . length ( ) ; int proximity = math . abs ( loc - x ) ; if ( match distance == num ) { return proximity == num ? accuracy : num ; } return accuracy + ( proximity / ( float ) match distance ) ; }	compute and return the score for a match with e errors and x location .
private void move pos ( float delta y ) { if ( ( delta y < num && m ptr indicator . is in start position ( ) ) ) { if ( debug ) { c . e ( log tag , string . format ( str ) ) ; } return ; } int to = m ptr indicator . get current pos y ( ) + ( int ) delta y ; if ( m ptr indicator . will over top ( to ) ) { if ( debug ) { c . e ( log tag , string . format ( str ) ) ; } to = ptr indicator . pos start ; } m ptr indicator . set current pos ( to ) ; int change = to - m ptr indicator . get last pos y ( ) ; update pos ( change ) ; }	if deltay > 0 , move the content down.
public void put all ( map < ? extends k , ? extends v > m ) { try presize ( m . size ( ) ) ; for ( map . entry < ? extends k , ? extends v > e : m . entry set ( ) ) put val ( e . get key ( ) , e . get value ( ) , bool ) ; }	copies all of the mappings from the specified map to this one.
public undoable edit insert string ( int where , string str ) throws bad location exception { if ( where >= count || where < num ) { throw new bad location exception ( str , count ) ; } char [ ] chars = str . to char array ( ) ; replace ( where , num , chars , num , chars . length ) ; if ( marks != null ) { update marks for insert ( where , str . length ( ) ) ; } return new insert undo ( where , str . length ( ) ) ; }	inserts a string into the content .
public string to string ( ) { return byte . to string ( get value ( ) ) ; }	obtains the string representation of this object .
boolean write data ( ) throws io { int tosend ; int sent ; byte [ ] block = new byte [ k block size ] ; do { tosend = math . min ( send stream size - total sent , block . length ) ; system . arraycopy ( send data , total sent , block , num , tosend ) ; if ( tosend > num ) { sent = local send ( block , tosend ) ; update local clock ( ) ; if ( sent != - num ) { total sent += sent ; } else { logger . log ( level . fine , str ) ; } } else { sent = tosend = num ; } } while ( sent > num ) ; if ( logger . is loggable ( level . finer ) ) { logger . log ( level . finer , str + total sent + str + ( send stream size - total sent ) ) ; } return tosend == num ; }	writes the data until there ' s space available.
public static int copy and close output ( reader input , writer output ) throws io { try { return copy ( input , output ) ; } finally { output . close ( ) ; } }	copy input to output and close the output stream before returning.
public int check bookies up ( int count , int timeout ) throws exception { zoo keeper zkc = connect zoo keeper ( zk host , zk port , zk timeout sec ) ; try { int most recent size = num ; for ( int i = num ; i < timeout ; i ++ ) { try { list < string > children = zkc . get children ( str , bool ) ; children . remove ( str ) ; most recent size = children . size ( ) ; if ( ( most recent size > count ) || log . is debug enabled ( ) ) { log . info ( str + most recent size + str + str + count ) ; if ( ( most recent size > count ) || log . is trace enabled ( ) ) { for ( string child : children ) { log . info ( str + child ) ; } } } if ( most recent size == count ) { break ; } } catch ( keeper exception e ) { } thread . sleep ( num ) ; } return most recent size ; } finally { zkc . close ( ) ; } }	check that a number of bookies are available.
public d inverse transform ( d src , d dst ) { try { src . set location ( src . get x ( ) + rot x , src . get y ( ) + rot y ) ; dst = rot transform . inverse transform ( src , dst ) ; } catch ( noninvertible transform exception e ) { logger . log ( level . fine , e . get message ( ) , e ) ; } return dst ; }	returns dst , the unrotated pixel location of the map .
public static throwable should fail ( class clazz , closure code ) { throwable th = null ; try { code . call ( ) ; } catch ( groovy runtime exception gre ) { th = script bytecode adapter . unwrap ( gre ) ; } catch ( throwable e ) { th = e ; } if ( th == null ) { fail ( str + code + str + clazz . get name ( ) ) ; } else if ( ! clazz . is instance ( th ) ) { fail ( str + code + str + clazz . get name ( ) + str + th ) ; } return th ; }	asserts that the given code closure fails when it is evaluated and that a particular type of exception is thrown .
public int write ( byte [ ] dest mac , byte [ ] packet , int offset , int byte count ) { if ( dest mac == null ) { throw new null pointer exception ( str ) ; } if ( packet == null ) { throw new null pointer exception ( str ) ; } arrays . check offset and count ( packet . length , offset , byte count ) ; if ( dest mac . length != num ) { throw new illegal argument exception ( str + dest mac . length ) ; } return send packet ( fd , m interface name , m protocol type , dest mac , packet , offset , byte count ) ; }	writes a raw packet to the desired interface.
private boolean process yesno ( stylesheet handler handler , string uri , string name , string raw name , string value ) throws org . xml . sax . sax { if ( ! ( value . equals ( str ) || value . equals ( str ) ) ) { handle error ( handler , xslt . invalid boolean , new object [ ] { name , value } , null ) ; return null ; } return new boolean ( value . equals ( str ) ? bool : bool ) ; }	process an attribute string of type t_yesno into a boolean value .
protected array list < key name pair > load rma ( int c b id ) { array list < key name pair > list = new array list < key name pair > ( ) ; string sql stmt = str + str + str + str + str ; prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql stmt , null ) ; pstmt . set int ( num , c b id ) ; result set rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { list . add ( new key name pair ( rs . get int ( num ) , rs . get string ( num ) ) ) ; } rs . close ( ) ; } catch ( sql e ) { log . log ( level . severe , sql stmt . to string ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( exception ex ) { log . severe ( str ) ; } } } return list ; }	load pbartner dependent order / invoice / shipment field .
@ override public list < work order > search wo ( final map < string , object > criteria map ) { logger . debug ( str ) ; final list < work order > filtered list = new array list < work order > ( ) ; criteria map . put ( action flag , str ) ; for ( final work order workorder : search wo ( criteria map ) ) if ( ! is wo ( workorder . get id ( ) ) ) filtered list . add ( workorder ) ; return filtered list ; }	this method will search list of wo ' s for the given criteria and eligible for mb.
public week ( date time , time zone zone , locale locale ) { param checks . null not permitted ( time , str ) ; param checks . null not permitted ( zone , str ) ; param checks . null not permitted ( locale , str ) ; calendar calendar = calendar . get instance ( zone , locale ) ; calendar . set time ( time ) ; int temp week = calendar . get ( calendar . week of year ) ; if ( temp week == num && calendar . get ( calendar . month ) == calendar . december ) { this . week = num ; this . year = ( short ) ( calendar . get ( calendar . year ) + num ) ; } else { this . week = ( byte ) math . min ( temp week , last week in year ) ; int yyyy = calendar . get ( calendar . year ) ; if ( calendar . get ( calendar . month ) == calendar . january && this . week >= num ) { yyyy -- ; } this . year = ( short ) yyyy ; } peg ( calendar ) ; }	creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .
public resource queue ( final non blocking lock manager with new design < r > lock service , final r resource ) { if ( lock service == null ) throw new illegal argument exception ( ) ; if ( resource == null ) throw new illegal argument exception ( ) ; this . lock service = lock service ; this . resource = resource ; this . queue = new linked blocking queue < t > ( ) ; this . statistics task = new queue size moving average task ( resource . to string ( ) , queue ) ; }	create a queue of lock requests for a resource .
public void encode and sign ( x500 name subject , signature signature ) throws certificate exception , io , signature exception { der output stream out , scratch ; byte [ ] certificate request info ; byte [ ] sig ; if ( encoded != null ) throw new signature exception ( str ) ; this . subject = subject ; scratch = new der output stream ( ) ; scratch . put integer ( big integer . zero ) ; subject . encode ( scratch ) ; scratch . write ( subject public key info . get encoded ( ) ) ; attribute set . encode ( scratch ) ; out = new der output stream ( ) ; out . write ( der value . tag , scratch ) ; certificate request info = out . to byte array ( ) ; scratch = out ; signature . update ( certificate request info , num , certificate request info . length ) ; sig = signature . sign ( ) ; algorithm id alg id = null ; try { alg id = algorithm id . get ( signature . get algorithm ( ) ) ; } catch ( no such algorithm exception nsae ) { throw new signature exception ( nsae ) ; } alg id . encode ( scratch ) ; scratch . put bit string ( sig ) ; out = new der output stream ( ) ; out . write ( der value . tag , scratch ) ; encoded = out . to byte array ( ) ; }	create the signed certificate request.
public synchronized void schedule periodic task ( timer task task , long period ) { try { m timer . schedule at fixed rate ( task , num , period ) ; } catch ( illegal state exception ie ) { m timer = new timer ( ) ; m timer . schedule at fixed rate ( task , num , period ) ; } }	schedule a task that starts immediately.
public static string abbreviate ( string str , font metrics fm , int width ) { int lastblank = num , nchars = num , cumx = num ; while ( cumx < width && nchars < str . length ( ) ) { if ( character . is whitespace ( str . char at ( nchars ) ) ) { lastblank = nchars ; } cumx += fm . char width ( str . char at ( nchars ) ) ; nchars ++ ; } if ( nchars < str . length ( ) && lastblank > num ) { nchars = lastblank ; } return ( nchars > num ? str . substring ( num , nchars ) : str ) ; }	abbreviate a string by simply truncating it .
protected void stop wraparound test ( ) { if ( test running && wrap test ) { wrap timer . stop ( ) ; status text1 . set text ( str + integer . to string ( num errors ) + str ) ; status text1 . set visible ( bool ) ; status text2 . set text ( integer . to string ( num iterations ) + str ) ; status text2 . set visible ( bool ) ; } }	local method to stop a wraparound test.
protected void check row index ( final int row ) throws math illegal argument exception { if ( row < num || row >= get row dimension ( ) ) { throw new math illegal argument exception ( localized core formats . row index , row , num , get row dimension ( ) - num ) ; } }	check if a row index is valid .
private void nuke symbols ( ) { count = num ; longest collision list = num ; arrays . fill ( main hash , num ) ; arrays . fill ( main names , null ) ; arrays . fill ( coll list , null ) ; coll count = num ; coll end = num ; }	helper method called to empty all shared symbols , but to leave arrays allocated.
private static float determine enemy blitz strength ( final territory blitz here , final list < route > blitz terr routes , final list < territory > block terr , final game data data , final id e player ) { final hash set < integer > ignore = new hash set < > ( ) ; ignore . add ( num ) ; final composite match < unit > blitz unit = new composite match and < > ( matches . unit is owned by ( e player ) , matches . unit can blitz , matches . unit can move ) ; final composite match < territory > valid blitz route = new composite match and < > ( matches . territory has no enemy units ( e player , data ) , matches . territory is not impassable to land units ( e player , data ) ) ; final list < route > routes = new array list < > ( ) ; final list < unit > blitz units = find attackers ( blitz here , num , ignore , e player , data , blitz unit , valid blitz route , block terr , routes , bool ) ; for ( final route r : routes ) { if ( r . number of steps ( ) == num ) { blitz terr routes . add ( r ) ; } } return strength ( blitz units , bool , bool , bool ) ; }	determine the enemy potential for blitzing a territory - all enemies are combined.
public name join ( string identifier ) { validate lower underscore ( identifier ) ; list < name piece > new piece list = new array list < > ( ) ; new piece list . add all ( name pieces ) ; new piece list . add ( new name piece ( identifier , case format . lower underscore ) ) ; return new name ( new piece list ) ; }	returns a new name containing the pieces from this name plus the given identifier added on the end .
private local date time parse date ( string date str , boolean try again ) { local date time date = local date time . now ( zone id . of ( str ) ) ; if ( m date time formatter == null ) { init formatter ( date str ) ; } if ( m date time formatter != null ) { try { date = local date time . parse ( date str , m date time formatter ) ; } catch ( date time parse exception e ) { timber . d ( string . format ( str , date str ) ) ; if ( try again ) { timber . d ( str ) ; m date time formatter = null ; parse date ( date str , bool ) ; } } } return date ; }	parses a string date into a java date object.
public string to string ( ) { string string = caller ; if ( level > num || thread != - num ) { string += str ; } if ( level > num ) { string += level ; } if ( thread != - num ) { string += str + thread ; } if ( level > num || thread != - num ) { string += str ; } string += str ; if ( spawn message ) { string += str ; } if ( answer . length ( ) > num ) { string += answer + str ; } if ( callee . length ( ) > num ) { string += callee + str ; } string += message ; if ( returns instantly ) { string += str ; } return string ; }	returns a string representation of the message data . todo : broadcasts , ( answer ) note number , escaping.
public static boolean is white space ( int c ) { switch ( c ) { case nul char : case str : case str : case ff char : case str : case str : return bool ; default : return bool ; } }	is the argument a white space character according to the pdf spec ? . iso spec 32000 - 1 : 2008 - table 1.
public void remove ( request filter filter ) { filters . remove ( filter ) ; }	unregister filter ( it won ' t get anymore events ).
protected void remove classifiers ( int [ ] indices ) { int i ; if ( indices == null ) { m . remove all elements ( ) ; } else { for ( i = indices . length - num ; i >= num ; i -- ) m . remove ( indices [ i ] ) ; } set modified ( bool ) ; }	removes the specified classifiers .
@ override public void add property change listener ( property change listener pcl ) { m pc support . add property change listener ( pcl ) ; }	add a property change listener.
public int num checkpoints ( ) { return checkpoints . size ( ) ; }	returns the number of checkpoints that were loaded .
public void add element ( object an object ) { p data . add ( an object ) ; fire interval added ( this , p data . size ( ) - num , p data . size ( ) - num ) ; if ( p data . size ( ) == num && m selected object == null && an object != null ) set selected item ( an object ) ; }	add element at the end.
public builder add listen urls ( list < string > urls ) { list < string > need add = new array list < string > ( ) ; for ( string url : urls ) { if ( ! url util . is url ( url ) ) { continue ; } need add . add ( url ) ; } if ( ! collection util . is empty ( need add ) ) { if ( m listen urls == null ) { m listen urls = new hash set < string > ( ) ; } m listen urls . add all ( need add ) ; } return this ; }	add the urls for listening.
public void add assigned virtual arrays ( set < string > virtual array ur ) { if ( ( virtual array ur != null ) && ( ! virtual array ur . is empty ( ) ) ) { hash set < string > add virtual arrays = new hash set < string > ( ) ; add virtual arrays . add all ( virtual array ur ) ; if ( assigned virtual arrays == null ) { set assigned virtual arrays ( new string set ( ) ) ; assigned virtual arrays . add all ( add virtual arrays ) ; } else { assigned virtual arrays . add all ( add virtual arrays ) ; } update virtual array tags ( ) ; } }	adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .
@ override public boolean is cell editable ( int row , int column ) { env var env var = data list . get ( row ) ; if ( column == col value ) { return bool ; } return ! env var . is predefined ( ) ; }	checks if is cell editable .
private boolean drop in trash ( ) { if ( m highlighted block view != null ) { m highlighted block view . set highlighted connection ( null ) ; m highlighted block view = null ; } m dragged connections . clear ( ) ; return m controller . trash root block ( m pending drag . get root dragged block ( ) ) ; }	ends a drag in the trash can , clearing state and deleting blocks as needed .
< t > list < t > concat values ( final t [ ] ... data ) { final list < t > rv = new array list < > ( ) ; for ( t [ ] values : data ) { rv . add all ( arrays . as list ( values ) ) ; } return rv ; }	helper for concatenating several arrays .
public dag iterator ( graph pattern ) { for ( edge edge : pattern . get edges ( ) ) { if ( edges . is directed edge ( edge ) || edges . is undirected edge ( edge ) ) { continue ; } throw new illegal argument exception ( str + str + edge ) ; } decorated graphs . add ( new decorated graph ( pattern ) ) ; }	the given pattern must be a pattern.
private boolean validate custom catalog ( string title , string value ) { return bool ; }	check a field that defines a custom catalog.
public function execution pooled executor ( blocking queue < runnable > q , int pool size , pool stat helper stats , thread factory tf ) { this ( q , pool size , stats , tf , integer . get integer ( distribution config . gemfire prefix + str , num * num ) , bool ) ; }	sets timeout to idle_thread_timeout.
protected boolean is ssdp ( string body ) { if ( body != null && body . starts with ( str ) && body . contains ( str ) ) { return bool ; } return bool ; }	very naive ssdp discovery packet detection.
@ override public void add child ( wx child , int index ) { if ( child == null || index < - num ) { return ; } if ( child instanceof wx ) { if ( ! check refresh or loading ( child ) ) { m refreshs . add ( child ) ; } return ; } if ( m children == null ) { m children = new array list < > ( ) ; } int count = m children . size ( ) ; index = index >= count ? - num : index ; if ( index == - num ) { m children . add ( child ) ; } else { m children . add ( index , child ) ; } }	intercept refresh view and loading view.
private void restore sorting selection ( int [ ] selection , int lead , model change change ) { for ( int i = selection . length - num ; i >= num ; i -- ) { selection [ i ] = convert row index to view ( selection [ i ] , change ) ; } lead = convert row index to view ( lead , change ) ; if ( selection . length == num || ( selection . length == num && selection [ num ] == get selected row ( ) ) ) { return ; } selection model . set value is adjusting ( bool ) ; selection model . clear selection ( ) ; for ( int i = selection . length - num ; i >= num ; i -- ) { if ( selection [ i ] != - num ) { selection model . add selection interval ( selection [ i ] , selection [ i ] ) ; } } swing utilities2 . set lead anchor without selection ( selection model , lead , lead ) ; selection model . set value is adjusting ( bool ) ; }	restores the selection after a model event / sort order changes.
public synchronized byte [ ] to byte array ( ) { int remaining = count ; if ( remaining == num ) { return empty byte array ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = num ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , num , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == num ) { break ; } } return newbuf ; }	gets the curent contents of this byte stream as a byte array.
@ after public void clean ( ) { mute ( null ) ; mute ( null ) ; mute ( null ) ; }	cleanups after each tests .
public void consume ( int event count , long timeout in millis , predicate < event > condition ) throws timeout exception { if ( event count < num ) throw new illegal argument exception ( str ) ; if ( event count == num ) return ; int events remaining = event count ; final long stop time = system . current time millis ( ) + timeout in millis ; while ( events remaining > num && system . current time millis ( ) < stop time ) { event next event = queue . poll ( ) ; if ( next event != null ) { if ( condition . test ( next event ) ) { -- events remaining ; consumed events . accept ( next event ) ; } else { ignored events . accept ( next event ) ; } } } if ( events remaining > num ) { throw new timeout exception ( str + ( event count - events remaining ) + str + event count + str + timeout in millis + str ) ; } }	blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds.
private void update ui from command ( command command ) { if ( command == null ) { return ; } actions combo box . set text ( command . get action ( ) ) ; data text field . set text ( command . get data ( ) ) ; category text field . set text ( command . get category ( ) ) ; mime text field . set text ( command . get mime type ( ) ) ; component text field . set text ( command . get component ( ) ) ; user text field . set text ( command . get user ( ) ) ; flags list . remove selection interval ( num , flags list . get items count ( ) ) ; list < intent flags > flags = command . get flags ( ) ; if ( flags != null && flags . size ( ) > num ) { for ( intent flags flag : command . get flags ( ) ) { flags list . set selected value ( flag , bool ) ; } } else { flags list . set selected index ( num ) ; } update flags text field ( ) ; table model . remove all rows ( ) ; list < extra field > extras = command . get extras ( ) ; if ( extras != null && extras . size ( ) > num ) { for ( extra field extra : extras ) { table model . add row ( extra ) ; } } update table visibility ( ) ; }	fills up vies from given command.
public void test compare to zero zero ( ) { big integer a number = big integer . zero ; big integer b number = big integer . zero ; assert equals ( num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
public static int rand gaussian ( final int mean , final int sd ) { return ( int ) ( rand . next gaussian ( ) * sd + mean ) ; }	generates a normally distributed random number and rounds it .
private float compute overscroll percent ( ) { if ( m over scroll offset >= num ) { return m over scroll offset / m max over scroll ; } else { return m over scroll offset / m max under scroll ; } }	determine the current amount of overscroll.
public i ( int c ) { vector = new int [ math . max ( default capacity , c ) ] ; }	constructs a new vector with the specified capacity .
public void process invite ( request event request event , server transaction server transaction ) { final request request = request event . get request ( ) ; final sip provider sip provider = ( sip provider ) request event . get source ( ) ; server transaction st = server transaction ; try { if ( st == null ) { try { st = sip provider . get new server transaction ( request ) ; } catch ( transaction unavailable exception tae ) { tae . print stack trace ( ) ; return ; } catch ( transaction already exists exception taex ) { return ; } } final string to tag = str + system . nano time ( ) ; response response = message factory . create response ( response . ringing , request ) ; to header to header = ( to header ) response . get header ( to header . name ) ; to header . set tag ( to tag ) ; st . send response ( response ) ; response = message factory . create response ( response . ok , request ) ; final address address = address factory . create address ( str + my address + str + my port + str ) ; final contact header contact header = header factory . create contact header ( address ) ; response . add header ( contact header ) ; to header = ( to header ) response . get header ( to header . name ) ; to header . set tag ( to tag ) ; st . send response ( response ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; } }	process the invite request .
public static ignite logger logger ( grid kernal context ctx , atomic reference < ignite logger > log ref , object obj ) { ignite logger log = log ref . get ( ) ; if ( log == null ) { log ref . compare and set ( null , ctx . log ( obj . get class ( ) ) ) ; log = log ref . get ( ) ; } return log ; }	initializes logger into / from log reference passed in .
protected boolean read receive delay ( ) { try { receive delay = integer . parse int ( receive delay field . get text ( ) ) ; } catch ( exception e ) { status text1 . set text ( rb . get string ( str ) ) ; status text1 . set visible ( bool ) ; receive delay = num ; error in status1 = bool ; reset notes2 ( ) ; return ( bool ) ; } if ( receive delay < num ) { status text1 . set text ( rb . get string ( str ) ) ; status text1 . set visible ( bool ) ; receive delay = num ; error in status1 = bool ; reset notes2 ( ) ; return ( bool ) ; } if ( receive delay > num ) { status text1 . set text ( rb . get string ( str ) ) ; status text1 . set visible ( bool ) ; receive delay = num ; error in status1 = bool ; reset notes2 ( ) ; return ( bool ) ; } return bool ; }	read receive delay from window returns ' true ' if successful , ' false ' if an error was detected . if an error is detected , a suitable error message is placed in the notes area.
private void write indent ( int times ) throws io { for ( int i = options . get base indent ( ) + times ; i > num ; i -- ) { writer . write ( options . get indent ( ) ) ; } }	writes indents and automatically includes the baseindend from the options .
@ override public int hash code ( ) { int result = num ; iterator < ? > it = iterator ( ) ; while ( it . has next ( ) ) { object object = it . next ( ) ; result = ( num * result ) + ( object == null ? num : object . hash code ( ) ) ; } return result ; }	returns the hash code of this list.
public static int parse string ( string value ) { return integer . parse int ( value ) ; }	parse string value returning a int .
public boolean is invalid node ( ) { ast first = f nodes . get ( num ) ; ast candidate = first . get parent ( ) ; if ( candidate == null ) return bool ; if ( candidate . get node type ( ) == ast . method declaration ) return bool ; return bool ; }	tests whether the node to be replaced is invalid .
public void push ( final float value ) { int bits = float . float to int bits ( value ) ; if ( bits == num || bits == num || bits == num ) { mv . visit insn ( opcodes . fconst 0 + ( int ) value ) ; } else { mv . visit ldc insn ( value ) ; } }	generates the instruction to push the given value on the stack .
public void on motion ( motion event event , interaction iact ) { }	notifies listener of a mouse motion event.
public synchronized void remove batch clusterer listener ( batch clusterer listener cl ) { m batch clusterer listeners . remove ( cl ) ; }	remove a batch clusterer listener.
public held locks grant refresh ( long expiration date ms ) { return new held locks grant ( grant id , creation date ms , expiration date ms , lock map , lock timeout , version id ) ; }	this should only be called by the lock service.
void remove known object ( parse object object ) { synchronized ( mutex ) { known objects . remove ( object ) ; } }	removes an object that is known to not be in the relation.
static heap bytes store < byte [ ] > wrap ( @ not null byte [ ] bytes ) { return heap bytes store . wrap ( bytes ) ; }	wraps a byte [ ].
private static string parse ( json value base ) { if ( ! base . is string ( ) ) { return null ; } return build string ( base . as string ( ) ) ; }	start the string parsing.
public void test value of long negative2 ( ) { long long val = - num ; big integer a number = big integer . value of ( long val ) ; byte r bytes [ ] = { - num , num , - num , - num } ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	valueof ( long val ) : convert a negative long value to a biginteger.
public void before insert ( int index , char element ) { if ( index > size || index < num ) throw new index out of bounds exception ( str + index + str + size ) ; ensure capacity ( size + num ) ; system . arraycopy ( elements , index , elements , index + num , size - index ) ; elements [ index ] = element ; size ++ ; }	inserts the specified element before the specified position into the receiver.
private void grow entries ( ) { int new len = ( next . length << num ) + num ; int [ ] new next = new int [ new len ] ; grid unsafe . copy memory ( next , int arr off , new next , int arr off , size << num ) ; next = new next ; next empty = new int [ new len ] ; arrays . fill ( next empty , - num ) ; object [ ] new objs = new object [ new len ] ; system . arraycopy ( objs , num , new objs , num , size ) ; objs = new objs ; }	increases hash table capacity by lengthening entry arrays .
public sided plane ( final vector p , final boolean on side , final vector a , final vector b ) { super ( a , b ) ; sig num = on side ? math . signum ( evaluate ( p ) ) : - math . signum ( evaluate ( p ) ) ; if ( sig num == num ) throw new illegal argument exception ( str ) ; }	construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .
public static boolean is input stream gzip ( final pushback input stream input stream ) throws io { if ( input stream == null ) return bool ; byte [ ] signature = new byte [ num ] ; int read status = input stream . read ( signature ) ; input stream . unread ( signature ) ; int stream header = ( ( int ) signature [ num ] & num ) | ( ( signature [ num ] << num ) & num ) ; return read status == num && gzip . gzip magic == stream header ; }	checks the inputstream if it contains gzip compressed data.
void insert op ( int pos , int length , int op ) { int total len = m ops . get op ( op map . mapindex length ) ; for ( int i = total len - num ; i >= pos ; i -- ) { m ops . set op ( i + length , m ops . get op ( i ) ) ; } m ops . set op ( pos , op ) ; m ops . set op ( op map . mapindex length , total len + length ) ; }	insert room for operation.
private void clear ( ) { valid = bool ; if ( ( listener objects == null ) || listener objects . is empty ( ) ) { deregister listener ( ) ; } ssm = null ; if ( sms . cache sms ) { org configs . clear ( ) ; global configs . clear ( ) ; } }	clears instance cache and deregisters listeners.
public static void register decayable object ( decayable obj ) { decay objects . add ( obj ) ; }	registers an object that should be decayed.
public static void assert expected output contains ( string expected string , string x ) { if ( ! x . contains ( expected string ) ) { fail ( str + expected string + str + x + str ) ; } }	fails if expectedstring is not found in x.
public boolean remove ( string classname ) { string pkgname ; hash set < string > names ; classname = clean up ( classname ) ; pkgname = extract package ( classname ) ; names = m . get ( pkgname ) ; if ( names != null ) { return names . remove ( classname ) ; } else { return bool ; } }	removes the classname from the cache .
public void test failed stage ( ) { cf ex = new cf ( ) ; completion stage < integer > f = completable future . failed stage ( ex ) ; atomic integer x = new atomic integer ( num ) ; atomic reference < throwable > r = new atomic reference < throwable > ( ) ; f . when complete ( null ) ; assert equals ( x . get ( ) , num ) ; assert equals ( r . get ( ) , ex ) ; }	failedstage returns a completionstage completed exceptionally with the given exception.
@ override public void paint component ( graphics g ) { super . paint component ( g ) ; d graphics = ( d ) g ; graphics . set background ( m color spectrum background ) ; rendering hints render hints = new rendering hints ( rendering hints . key antialiasing , rendering hints . value antialias on ) ; render hints . put ( rendering hints . key rendering , rendering hints . value render quality ) ; graphics . set rendering hints ( render hints ) ; draw frequencies ( graphics ) ; draw cursor ( graphics ) ; }	renders the channel configs , lines , labels , and cursor.
public void class loader destroy ( dynamic class loader loader ) { method destroy = get destroy method ( resource . get class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( resource ) ; } catch ( throwable e ) { log . log ( level . warning , e . to string ( ) , e ) ; } }	handles the case where a class loader is dropped .
public boolean delete attachment point ( datapath id sw , of port ) { attachment point ap = new attachment point ( sw , port , new date ( num ) ) ; if ( this . old a != null ) { array list < attachment point > ap list = new array list < attachment point > ( ) ; ap list . add all ( this . old a ) ; int index = ap list . index of ( ap ) ; if ( index > num ) { ap list . remove ( index ) ; this . old a = ap list ; } } if ( this . attachment points != null ) { array list < attachment point > ap list = new array list < attachment point > ( ) ; ap list . add all ( this . attachment points ) ; int index = ap list . index of ( ap ) ; if ( index > num ) { ap list . remove ( index ) ; this . attachment points = ap list ; return bool ; } } return bool ; }	delete ( sw , port ) from the list of list of attachment points and oldaps .
public synchronized int total recover files ( ) { int total = num ; for ( file file : file details . values ( ) ) { if ( file . reused ( ) == bool ) { total ++ ; } } return total ; }	total number of files to be recovered ( potentially not yet done ).
public static anim game item process ( m md5 model , m anim model , vector3f default colour ) throws exception { list < matrix4f > inv joint matrices = calc in joint matrices ( md5 model ) ; list < animated frame > animated frames = process animation frames ( md5 model , anim model , inv joint matrices ) ; list < mesh > list = new array list < > ( ) ; for ( m md5 mesh : md5 model . get meshes ( ) ) { mesh mesh = generate mesh ( md5 model , md5 mesh ) ; handle texture ( mesh , md5 mesh , default colour ) ; list . add ( mesh ) ; } mesh [ ] meshes = new mesh [ list . size ( ) ] ; meshes = list . to array ( meshes ) ; anim game item result = new anim game item ( meshes , animated frames , inv joint matrices ) ; return result ; }	constructs and animgameitem instace based on a md5 model an md5 animation.
@ override @ timed public void delete assignment ( experiment experiment , user . id user id , context context , application . name app name , assignment current assignment ) { delete user from look up ( experiment . get id ( ) , user id , context ) ; boolean count up = bool ; assignments count executor . execute ( new assignment count envelope ( assignments repository , experiment repository , db repository , experiment , current assignment , count up , event log , null , assign user to export , assign bucket count ) ) ; delete assignment old ( experiment . get id ( ) , user id , context , app name , current assignment . get bucket label ( ) ) ; remove index user to experiment ( user id , experiment . get id ( ) , context , app name ) ; remove index user to bucket ( user id , experiment . get id ( ) , context , current assignment . get bucket label ( ) ) ; remove index experiments to user ( user id , experiment . get id ( ) , context , app name ) ; }	deletes the existing assignment between a user and an experiment .
string format ( object obj , string buffer to append to ) throws illegal argument exception { date source = null ; if ( obj instanceof date ) { source = ( date ) obj ; } else if ( obj instanceof string ) { try { source = parse ( ( string ) obj ) ; } catch ( parse exception pe ) { throw new runtime exception ( pe . to string ( ) ) ; } } if ( source == null ) { throw new illegal argument exception ( ( obj == null ) ? str : obj . to string ( ) ) ; } return format ( source , to append to ) ; }	format a given object .
private static final boolean compare and set wait status ( node node , int expect , int update ) { return unsafe . compare and swap int ( node , wait status offset , expect , update ) ; }	cas waitstatus field of a node .
public static thread dump create ( ) { thread dump thread dump = thread dump ref . get ( ) ; if ( thread dump == null ) { thread dump = new thread dump pro ( ) ; thread dump ref . compare and set ( null , thread dump ) ; thread dump = thread dump ref . get ( ) ; } return thread dump ; }	returns the singleton instance , creating if necessary.
private void check start ( ) { if ( m can process audio && ! m output . is running ( ) && m output . available ( ) <= m buffer start threshold ) { m output . start ( ) ; } }	starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .
protected boolean matches filter ( final string input , final string [ ] filter ) { for ( final string match : filter ) { if ( ! input . contains ( match ) ) return bool ; } return bool ; }	checks if all keywords in filter array are in input.
private e unlink first ( ) { node < e > f = first ; if ( f == null ) return null ; node < e > n = f . next ; e item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not full . signal ( ) ; return item ; }	removes and returns first element , or null if empty .
private static synchronized void init doc builder factory ( ) { doc builder factory = document builder factory . new instance ( ) ; doc builder factory . set ignoring comments ( bool ) ; doc builder factory . set coalescing ( bool ) ; }	initialize the document builder factory so that it can be reused and does not need to be reinitialized for each parse action .
public double intercept std err ( ) { return math . sqrt ( svar0 ) ; }	returns the standard error of the estimate for the intercept .
private void create missing values ( ) { string sql = str + str + str + str + str + str + str ; prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql , get ( ) ) ; pstmt . set int ( num , get a id ( ) ) ; result set rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { m v = new m ( this , rs . get int ( num ) , str ) ; v . save ex ( ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { log . log ( level . severe , null , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } }	create missing attribute values.
private static string normalise path ( string path ) { return path . replace ( str , str ) ; }	this method replaces all \ to / .
public void start launch notifier ( ) { if ( m launch notification == null ) throw new null pointer exception ( ) ; m launch notifier thread . set daemon ( bool ) ; m launch notifier thread . start ( ) ; }	creates a background thread that will call the launch notifier when the process terminates .
public static string expand hidden dir ( final string filename ) { final int macro = filename . index of ( hidden dir macro , num ) ; string expanded filter ; if ( macro == - num ) { return filename ; } if ( cfg . debug ) { check . log ( tag + str ) ; } expanded filter = filename . replace first ( str , string utils . chomp ( path . hidden ( ) , str ) ) ; if ( cfg . debug ) { check . log ( tag + str + expanded filter ) ; } return expanded filter ; }	transforms " something $ dir $ / other / " to " something / path / to / hidden / other / ".
private boolean try queue current buffer ( long elapsed waiting ) { if ( current buffer . is empty ( ) ) return bool ; if ( is open && never pub queue . size ( ) < never pub capacity ) { never pub queue . add ( current buffer ) ; total queued records . add and get ( current buffer . size records ( ) ) ; total queued buffers . increment and get ( ) ; on queue buffer success ( current buffer , elapsed waiting ) ; current buffer = new record buffer < > ( flow ) ; return bool ; } else if ( elapsed waiting > num ) { on queue buffer timeout ( current buffer , elapsed waiting ) ; return bool ; } else return bool ; }	keep private . call only when holding lock .
public void update value ( final object value , final boolean is selected , boolean sync ) { if ( is read only ( ) ) { return ; } if ( generic form factory . is text form ( form type ) ) { text string = ( string ) value ; if ( text string != null && text string . equals ( last text string ) ) { sync = bool ; } last text string = text string ; } else { text string = ( string ) value ; this . is selected = is selected ; if ( is selected != last is selected && last text string != null && text string != null && text string . equals ( last text string ) ) { sync = bool ; } last text string = text string ; last is selected = is selected ; } if ( ( sync && gui type != form factory . ulc ) && gui comp != null ) { sync gui ( value ) ; } }	allow us to update value ( and sync to gui version if exists.
public boolean has next ( ) throws io { data input stream . mark ( num ) ; int val = data input stream . read ( ) ; data input stream . reset ( ) ; return val != - num ; }	checks if another objects is available by attempting to read another byte from the stream .
private final string builder append parameter signature ( string builder buffer , char [ ] [ ] parameter types , char [ ] [ ] parameter names ) { if ( parameter types != null ) { for ( int i = num ; i < parameter types . length ; i ++ ) { if ( i > num ) { buffer . append ( str ) ; buffer . append ( str ) ; } buffer . append ( parameter types [ i ] ) ; if ( parameter names != null && parameter names [ i ] != null ) { buffer . append ( str ) ; buffer . append ( parameter names [ i ] ) ; } } } return buffer ; }	creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .
public void complete heartbeat ( database database , long seqno , string event id ) throws sql { if ( logger . is debug enabled ( ) ) logger . debug ( str ) ; statement st = null ; result set rs = null ; timestamp sts = new timestamp ( num ) ; timestamp now = new timestamp ( system . current time millis ( ) ) ; array list < column > where clause = new array list < column > ( ) ; array list < column > values = new array list < column > ( ) ; if ( logger . is debug enabled ( ) ) logger . debug ( str + now ) ; try { st = database . create statement ( ) ; rs = st . execute query ( source ts query ) ; if ( rs . next ( ) ) sts = rs . get timestamp ( num ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sql e ) { } } } long lag millis = now . get time ( ) - sts . get time ( ) ; hb id . set value ( key ) ; where clause . add ( hb id ) ; hb seqno . set value ( seqno ) ; hb event id . set value ( event id ) ; hb target tstamp . set value ( now ) ; hb lag millis . set value ( lag millis ) ; values . add ( hb seqno ) ; values . add ( hb event id ) ; values . add ( hb target tstamp ) ; values . add ( hb lag millis ) ; database . update ( hb table , where clause , values ) ; }	execute this call to fill in heartbeat data on the slave.
public cipher parameters decrypt ( byte [ ] in , int in off , int in len , int key len ) throws illegal argument exception { if ( ! key . is private ( ) ) { throw new illegal argument exception ( str ) ; } big integer n = key . get modulus ( ) ; big integer d = key . get exponent ( ) ; byte [ ] c = new byte [ in len ] ; system . arraycopy ( in , in off , c , num , c . length ) ; big integer c = new big integer ( num , c ) ; big integer r = c . mod pow ( d , n ) ; return generate key ( n , r , key len ) ; }	decrypt an encapsulated session key .
public private key load private key ( ) throws exception { if ( default keys ) { return get private key from string ( rsa . default pkey ) ; } if ( pri key == null ) { file reader f = new file reader ( path + str + this . id ) ; buffered reader r = new buffered reader ( f ) ; string tmp = str ; string key = str ; while ( ( tmp = r . read line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; pri key = get private key from string ( key ) ; } return pri key ; }	loads the private key of this process.
public void remove categories listener ( snapshot categories listener listener ) { listeners . remove ( listener ) ; }	removes a listener for changes of registered snapshot categories .
public boolean has unsupported critical extension ( ) { set extns = get critical extension oi ( ) ; if ( extns == null ) { return bool ; } extns . remove ( rf . issuing distribution point ) ; extns . remove ( rf . delta crl indicator ) ; return ! extns . is empty ( ) ; }	will return true if any extensions are present and marked as critical as we currently dont handle any extensions !.
private boolean is not in array ( string str , string [ ] array ) { for ( int i = num ; i < array . length ; i ++ ) { if ( str . equals ( array [ i ] ) ) { return bool ; } } return bool ; }	returns true iff str is not an element of array .
node clone or import node ( short operation , node node , boolean deep ) { node impl copy = shallow copy ( operation , node ) ; if ( deep ) { node list list = node . get child nodes ( ) ; for ( int i = num ; i < list . get length ( ) ; i ++ ) { copy . append child ( clone or import node ( operation , list . item ( i ) , deep ) ) ; } } notify user data handlers ( operation , node , copy ) ; return copy ; }	returns a copy of the given node or subtree with this document as its owner .
public static synchronized void cleanup ( ) { w . lock ( ) ; try { secp256k1 destroy context ( secp256k1 context . get context ( ) ) ; } finally { w . unlock ( ) ; } }	libsecp256k1 cleanup - this destroys the secp256k1 context object this should be called at the end of the program for proper cleanup of the context .
public void init ( ) throws exception { load parameter from zk ( ) ; invalid login cleanup executor . schedule with fixed delay ( new invalid login cleaner ( ) , cleanup thread schedule interval in mins , cleanup thread schedule interval in mins , time unit . minutes ) ; log . info ( str , max authn login attemts count ) ; log . info ( str , max authn login attemts life time in mins ) ; log . info ( str , cleanup thread schedule interval in mins ) ; }	initialize the background task to be run every hour.
public list < string > make url ( string shard ) { list < string > urls = str utils . split smart ( shard , str , bool ) ; for ( int i = num ; i < urls . size ( ) ; i ++ ) { urls . set ( i , build url ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > num ) collections . shuffle ( urls , r ) ; return urls ; }	creates a randomized list of urls for the given shard .
public input stream reader reader ( final string charset ) throws http request exception { try { return new input stream reader ( stream ( ) , get valid charset ( charset ) ) ; } catch ( unsupported encoding exception e ) { throw new http request exception ( e ) ; } }	get reader to response body using given character set . < p > this will fall back to using the utf - 8 character set if the given charset is null.
private byte [ ] to zlib ( rendered image image , color bkg , string color model ) throws io { return d . to byte array ( image , image constants . raw , image constants . encoding flate asci , d . get raw ( bkg , color model ) ) ; }	creates the zlib bytes for pdf images.
public void add vertex ( object id ) throws illegal argument exception { if ( initialized ) { throw new illegal argument exception ( ) ; } vertex vertex = new vertex ( id ) ; object existing = vertex map . put ( id , vertex ) ; if ( existing != null ) { throw new illegal argument exception ( ) ; } vertex list . add ( vertex ) ; }	defines a new vertex with the given id.
public void configure local services ( ) { client memo . set ln traffic controller ( this ) ; client memo . configure command station ( ln command station type . command station dc , bool , bool ) ; client memo . configure managers ( ) ; }	set up all of the other objects to operate with a server connected to this application .
private static int index of ( int from index , char sequence csq ) { if ( csq == null ) return num ; int length = csq . length ( ) ; int j = from index ; int i = ( j < length ) ? csq . char at ( j ++ ) : num ; i <<= num ; i |= ( j < length ) ? csq . char at ( j ++ ) : num ; return i ; }	returns the index starting at the specified index ( two characters at a time ) .
public void append ( string string ) { for ( int i = num ; i < string . length ( ) ; i ++ ) append ( string . char at ( i ) ) ; }	appends an int ( little endian ) in the buffer.
public listenable future < string > push ( final string name , final expression func ) { string let = string . format ( str , name , func . to haskell ( ) ) ; return pull raw ( let ) ; }	uploads a new let binding to ghci.
public final string to string ( int depth ) { if ( depth <= num ) return str ; return ( str + super . to string ( depth ) + str + mantissa + str + exponent + str + ( big val != null ? big val . to string ( ) : str ) + str + image ) ; }	displays this node as a string , implementing explorenode interface ; depth parameter is a bound on the depth of the portion of the tree that is displayed .
public meta data column descriptor ( string column name , int jdbc type , object default value ) { column name = column name . to upper case ( ) ; jdbc type = jdbc type ; default value = default value ; }	creates a new descriptor instance .
private array list < string > filter years ( array list < string > items ) { iterator < string > iterator ; calendar now = calendar . get instance ( ) ; int year = now . get ( calendar . year ) ; string year in string = string . value of ( year ) ; log . d ( tag , str + year in string ) ; int prev year = year - num ; string prev year in string = string . value of ( prev year ) ; log . d ( tag , str + prev year in string ) ; for ( iterator = items . iterator ( ) ; iterator . has next ( ) ; ) { string s = iterator . next ( ) ; if ( s . matches ( str ) && ! s . contains ( year in string ) && ! s . contains ( prev year in string ) ) { log . d ( tag , str + s ) ; iterator . remove ( ) ; } } log . d ( tag , str + items . to string ( ) ) ; return items ; }	remove categories that contain a year in them ( starting with 19__ or 20__ ) , except for this year and previous year rationale : https : / / github . com / commons - app / apps - android - commons / issues / 47.
public data provider event ( final localizable message reason , final set < type > types ) { reject . if null ( reason , types ) ; reject . if true ( types . is empty ( ) ) ; this . reason = reason ; final enum set < type > tmp = enum set . none of ( type . class ) ; tmp . add all ( types ) ; this . types = collections . unmodifiable set ( tmp ) ; }	creates a new data provider event .
public < t > list < string > validate bean ( t bean , string err if bean null ) { list < string > errors = new array list < string > ( ) ; if ( bean == null ) { errors . add ( err if bean null ) ; return errors ; } set < constraint violation < t > > violations = validator . validate ( bean ) ; for ( constraint violation < t > violation : violations ) { errors . add ( violation . get message ( ) ) ; } return errors ; }	validate the bean is not null ; then validate its fields.
protected void smart insert after bracket ( i document , document command command ) { if ( command . offset == - num || document . get length ( ) == num ) { return ; } try { int p = ( command . offset == document . get length ( ) ? command . offset - num : command . offset ) ; int line = document . get line of offset ( p ) ; int start = document . get line offset ( line ) ; int whiteend = find end of white space ( document , start , command . offset ) ; if ( whiteend == command . offset ) { int ind line = find matching open bracket ( document , line , command . offset , num ) ; if ( ind line != - num && ind line != line ) { string buffer replace text = new string buffer ( get indent of line ( document , ind line ) ) ; replace text . append ( document . get ( whiteend , command . offset - whiteend ) ) ; replace text . append ( command . text ) ; command . length = command . offset - start ; command . offset = start ; command . text = replace text . to string ( ) ; } } } catch ( bad location exception e ) { gwt . log error ( e ) ; } }	set the indent of a bracket based on the command provided in the supplied document .
private string attempt to choose formatting pattern ( ) { if ( national number . length ( ) >= min leading digits length ) { get available formats ( national number . to string ( ) ) ; string formatted number = attempt to format accrued digits ( ) ; if ( formatted number . length ( ) > num ) { return formatted number ; } return maybe create new template ( ) ? input accrued national number ( ) : accrued input . to string ( ) ; } else { return append national number ( national number . to string ( ) ) ; } }	attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .
private void fill picks ( ) throws exception { m org l = m . get ( env . get ctx ( ) , m , num , num , display type . table dir ) ; f warehouse = new v ( str , bool , bool , bool , org l ) ; l warehouse . set text ( msg . translate ( env . get ctx ( ) , str ) ) ; f warehouse . add vetoable change listener ( this ) ; m m id = f warehouse . get value ( ) ; m bp l = m . get ( env . get ctx ( ) , m , num , num , display type . search ) ; f b = new v ( str , bool , bool , bool , bp l ) ; l b . set text ( msg . translate ( env . get ctx ( ) , str ) ) ; f b . add vetoable change listener ( this ) ; l doc type . set text ( msg . translate ( env . get ctx ( ) , str ) ) ; cmb doc type . add item ( new key name pair ( m . id , msg . translate ( env . get ctx ( ) , str ) ) ) ; cmb doc type . add item ( new key name pair ( mrma . id , msg . translate ( env . get ctx ( ) , str ) ) ) ; cmb doc type . add action listener ( this ) ; }	fill picks . column_id from c_order.
@ override protected field config base create copy ( field config base field config base ) { field config font preview copy = null ; if ( field config base != null ) { copy = new field config font preview ( field config base . get common data ( ) ) ; } return copy ; }	creates a copy of the field .
public void test constructor sign bytes zero null3 ( ) { byte a bytes [ ] = { } ; int a sign = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
public object cast to type ( int t , x support ) throws javax . xml . transform . transformer exception { object result ; switch ( t ) { case class string : result = str ( ) ; break ; case class number : result = new double ( num ( ) ) ; break ; case class nodeset : result = iter ( ) ; break ; case class boolean : result = new boolean ( bool ( ) ) ; break ; case class unknown : result = m obj ; break ; default : error ( xpath . er cant convert to type , new object [ ] { get type string ( ) , integer . to string ( t ) } ) ; result = null ; } return result ; }	cast object to type t .
public static void force delete on exit ( file file ) throws io { if ( file . is directory ( ) ) { delete directory on exit ( file ) ; } else { file . delete on exit ( ) ; } }	schedules a file to be deleted when jvm exits.
public boolean init ( step meta interface smi , step data interface sdi ) { this . meta = ( ( sort key step meta ) smi ) ; this . data = ( ( sort key step data ) sdi ) ; return super . init ( smi , sdi ) ; }	initialize and do work where other steps need to wait for.
private void print annotation from editor ( final workflow annotation anno , final d g2 ) { d g pr = ( d ) g2 . create ( ) ; d loc = anno . get location ( ) ; g pr . translate ( loc . get x ( ) , loc . get y ( ) ) ; g pr . set clip ( num , num , ( int ) loc . get width ( ) , ( int ) loc . get height ( ) ) ; dimension size = new dimension ( ( int ) loc . get width ( ) , ( int ) loc . get height ( ) ) ; pane . set size ( size ) ; pane . set text ( annotation draw utils . create styled comment string ( anno ) ) ; pane . set caret position ( num ) ; pane . paint ( g pr ) ; g pr . dispose ( ) ; }	bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context.
public void add ( i pt ) { if ( in progress ) { throw new concurrent modification exception ( str ) ; } points . add ( pt ) ; }	add point to the result set .
public static configuration load ( reader reader ) throws io { try { properties properties = new properties ( ) ; properties . load ( reader ) ; return from ( properties ) ; } finally { reader . close ( ) ; } }	obtain a configuration instance by loading the properties from the supplied reader .
public void add ( offsetted item item ) { throw if prepared ( ) ; try { if ( item . get alignment ( ) > get alignment ( ) ) { throw new illegal argument exception ( str ) ; } } catch ( null pointer exception ex ) { throw new null pointer exception ( str ) ; } items . add ( item ) ; }	adds an item to this instance.
public static void add annotation to xml ( element annotations element , string name , string value ) { if ( value == null ) { delete annotation from xml ( annotations element , name ) ; } else { final document doc = annotations element . get owner document ( ) ; element elem = doc . create element ( str ) ; annotations element . append child ( elem ) ; elem . set attribute ( str , name ) ; elem . set text content ( value ) ; } }	updates the xml representation to contain this annotation .
public boolean read boolean ( ) throws io { return primitive types . read boolean ( ) ; }	reads a boolean from the source stream .
public enumeration < string > enumerate measures ( ) { vector < string > new vector = new vector < string > ( num ) ; new vector . add element ( str ) ; return new vector . elements ( ) ; }	returns an enumeration of the additional measure names.
public static double ln gamma ( double alpha ) { double x = alpha , f = num , z ; if ( x < num ) { f = num ; z = x - num ; while ( ++ z < num ) { f *= z ; } x = z ; f = - math . log ( f ) ; } z = num / ( x * x ) ; return f + ( x - num ) * math . log ( x ) - x + num + ( ( ( - num * z + num ) * z - num ) * z + num ) / x ; }	log gamma function : ln ( gamma ( alpha ) ) for alpha > 0 , accurate to 10 decimal places.
public void start ticker ( long delay , boolean right to left ) { if ( ! ticker enabled ) { return ; } if ( ! is cell renderer ( ) ) { form parent = get component form ( ) ; if ( parent != null ) { parent . register animated internal ( this ) ; } } ticker start time = system . current time millis ( ) ; ticker delay = delay ; ticker running = bool ; this . right to left = right to left ; if ( is rtl ( ) ) { this . right to left = ! this . right to left ; } }	this method will start the text ticker.
static cipher suite value of ( int id1 , int id2 ) { id1 &= num ; id2 &= num ; int id = ( id1 << num ) | id2 ; cipher suite c = id map . get ( id ) ; if ( c == null ) { string h1 = integer . to string ( id1 , num ) ; string h2 = integer . to string ( id2 , num ) ; c = new cipher suite ( str + h1 + str + h2 , id ) ; } return c ; }	return a ciphersuite with the given id.
public static context create pending action context ( context context , recon action action , string mapping name , json value source object , string recon id , situation situation ) { map < string , object > pending action map = new hash map < string , object > ( ) ; pending action map . put ( mapping name , mapping name ) ; pending action map . put ( source object , source object ) ; pending action map . put ( recon id , recon id ) ; pending action map . put ( original situation , situation . to string ( ) ) ; pending action context pending action context = new pending action context ( context , pending action map , action . to string ( ) ) ; return pending action context ; }	creates and populates a pendingactioncontext .
public void show droidsafe text markers ( i opened editor , string class name ) { if ( opened editor != null && opened editor instanceof i && f processed classes != null ) { i editor = ( i ) opened editor ; if ( f processed classes . contains ( class name ) ) { if ( f classes need update . contains ( class name ) ) { class marker processor class processor = get ( class name ) ; class processor . update taint markers ( editor ) ; f classes need update . remove ( class name ) ; } } else { f processed classes . add ( class name ) ; map < string , map < int range , map < string , set < call location model > > > > class tainted data map = f tainted data map . get ( class name ) ; map < string , set < int range > > class unreachable method map = f unreachable source method map . get ( class name ) ; if ( class tainted data map != null || class unreachable method map != null ) { i input = editor . get editor input ( ) ; if ( input instanceof file editor input ) { class marker processor class processor = get ( class name ) ; class processor . show droidsafe text markers ( editor ) ; } } } } }	displays the annotations of the droidsafe text markers for the given class name in the given java editor .
private static void resolve new expression ( new expression obj subject expression , hash set < string > obj types set ) { class reference obj class ref = obj subject expression . get class reference ( ) ; if ( null == obj class ref || null == obj class ref . get fqn ( ) ) { obj types set . add ( types . str resolving aborted on psi level ) ; return ; } obj types set . add ( obj class ref . get fqn ( ) ) ; }	will resolve type of new expression.
private static list < size > pick up to three ( list < size > sizes ) { list < size > result = new array list < size > ( ) ; size largest = sizes . get ( num ) ; result . add ( largest ) ; size last size = largest ; for ( size size : sizes ) { double target area = math . pow ( num , result . size ( ) ) * area ( largest ) ; if ( area ( size ) < target area ) { if ( ! result . contains ( last size ) && ( target area - area ( last size ) < area ( size ) - target area ) ) { result . add ( last size ) ; } else { result . add ( size ) ; } } last size = size ; if ( result . size ( ) == num ) { break ; } } if ( result . size ( ) < num && ! result . contains ( last size ) ) { result . add ( last size ) ; } return result ; }	given a list of sizes of a similar aspect ratio , it tries to pick evenly spaced out options.
private boolean verify log record ( string [ ] record , int mac pos ) throws exception { string builder data = new string builder ( ) ; for ( int m = num ; m < record . length - num ; m ++ ) { data . append ( record [ m ] ) ; } cur mac = record [ mac pos ] ; verified = helper . verify mac ( data . to string ( ) , helper . to byte array ( cur mac ) ) ; return verified ; }	verifies the passed logrecord to check for tampering .
public static void copy to clipboard ( transferable t ) { clipboard helper . copy to clipboard ( t ) ; }	copies the given transferable to the system ' s clipboard .
public static string format percent ( int download size , int file size ) { float num = ( float ) download size / file size ; float percent = ( ( float ) ( int ) ( num * num ) ) / num ; return string . value of ( percent + str ) ; }	format the download percent.
private void update actions ( ) { string selected text = get selected text ( ) ; if ( selected text == null ) selected text = str ; boolean stuff selected = ! selected text . equals ( str ) ; boolean all selected = selected text . equals ( get text ( ) ) ; undo action . set enabled ( is enabled ( ) && is editable ( ) && is undo available ( ) ) ; cut action . set enabled ( is enabled ( ) && is editable ( ) && stuff selected ) ; copy action . set enabled ( is enabled ( ) && stuff selected ) ; paste action . set enabled ( is enabled ( ) && is editable ( ) && is paste available ( ) ) ; delete action . set enabled ( is enabled ( ) && stuff selected ) ; select all action . set enabled ( is enabled ( ) && ! all selected ) ; }	updates the actions in each text just before showing the popup menu .
public static < t > collection < t > make immutable ( collection < t > mutable collection ) { collection < t > new collection ; try { @ suppress warnings ( str ) class < collection < t > > cls = ( class < collection < t > > ) mutable collection . get class ( ) ; new collection = cls . new instance ( ) ; } catch ( instantiation exception | illegal access exception e ) { throw new illegal state exception ( e ) ; } for ( t element : mutable collection ) { new collection . add ( utils . make immutable ( element ) ) ; } return collections . unmodifiable collection ( new collection ) ; }	a recursive call to make a collection and all it ' s values immutable .
public synchronized void track hex images ( i hex , media tracker tracker ) { image base = hex to image cache . get ( hex ) ; list < image > super imgs = hex to image list cache . get ( hex ) ; list < image > ortho imgs = ortho list cache . get ( hex ) ; tracker . add image ( base , num ) ; if ( super imgs != null ) { for ( iterator < image > i = super imgs . iterator ( ) ; i . has next ( ) ; ) { tracker . add image ( i . next ( ) , num ) ; } } if ( ortho imgs != null ) { for ( iterator < image > i = ortho imgs . iterator ( ) ; i . has next ( ) ; ) { tracker . add image ( i . next ( ) , num ) ; } } }	adds all images associated with the hex to the specified tracker.
public static date parse text ( string date str ) { try { return m simple text format . parse ( date str ) ; } catch ( parse exception e ) { e . print stack trace ( ) ; throw new runtime exception ( str ) ; } }	parse string to datetime.
public boolean is processed ( trace trace , node node , direction direction ) { boolean ret = bool ; if ( processor . get node type ( ) == node . get type ( ) && processor . get direction ( ) == direction ) { if ( uri filter == null || uri filter . test ( node . get uri ( ) ) ) { ret = bool ; } } if ( log . is loggable ( level . finest ) ) { log . finest ( str + trace + str + node + str + direction + str + ret ) ; } return ret ; }	this method checks that this processor matches the supplied business txn name and node details .
@ override public synchronized void power on self test ( ) throws error { for ( iterator < waveform synthesizer > it = waveform synthesizers . iterator ( ) ; it . has next ( ) ; ) { waveform synthesizer ws = it . next ( ) ; ws . power on self test ( ) ; } }	perform a power - on self test by processing some example input data .
private quad edge [ ] fetch triangle to visit ( quad edge edge , stack edge stack , boolean include frame , set visited edges ) { quad edge curr = edge ; int edge count = num ; boolean is frame = bool ; do { tri edges [ edge count ] = curr ; if ( is frame edge ( curr ) ) is frame = bool ; quad edge sym = curr . sym ( ) ; if ( ! visited edges . contains ( sym ) ) edge stack . push ( sym ) ; visited edges . add ( curr ) ; edge count ++ ; curr = curr . l next ( ) ; } while ( curr != edge ) ; if ( is frame && ! include frame ) return null ; return tri edges ; }	stores the edges for a visited triangle.
public collection engine generate cr ( input stream in stream ) throws crl { crl crl ; list crls = new array list ( ) ; while ( ( crl = engine generate crl ( in stream ) ) != null ) { crls . add ( crl ) ; } return crls ; }	returns a ( possibly empty ) collection view of the crls read from the given input stream instream.
public void delete entity config ( string realm , string federation id ) throws ws { if ( federation id == null ) { return ; } if ( realm == null ) { realm = str ; } string [ ] objs = { federation id , realm } ; try { map old attrs = config inst . get configuration ( realm , federation id ) ; set old values = ( set ) old attrs . get ( attr entity config ) ; if ( old values == null || old values . is empty ( ) ) { log util . error ( level . info , log util . no entity descriptor delete entity config , objs , null ) ; throw new ws ( str , objs ) ; } idpsso idpconfig = get idpsso ( realm , federation id ) ; if ( idpconfig != null ) { remove from circle of trust ( idpconfig , realm , federation id ) ; } spsso spconfig = get spsso ( realm , federation id ) ; if ( spconfig != null ) { remove from circle of trust ( spconfig , realm , federation id ) ; } set attr = new hash set ( ) ; attr . add ( attr entity config ) ; config inst . delete configuration ( realm , federation id , attr ) ; log util . access ( level . info , log util . entity config deleted , objs , null ) ; ws . put entity config ( realm , federation id , null ) ; } catch ( configuration exception e ) { debug . error ( str , e ) ; string [ ] data = { e . get message ( ) , federation id , realm } ; log util . error ( level . info , log util . config error delete entity config , data , null ) ; throw new ws ( e ) ; } }	deletes the extended entity configuration under the realm .
public static synchronized data source views manager shared instance ( ) { if ( shared instance == null ) shared instance = new data source views manager ( ) ; return shared instance ; }	returns singleton instance of datasourceviewsmanager .
public string tag ( string inner , string c1 , string c2 ) { boolean color = ( ( attr & attr color ) == attr color ) && toast bootstrap . color ; string s = str ; if ( color ) s += str + c1 + str ; s += inner ; if ( color ) s += str + c2 + str ; s += str ; if ( color ) s += str + c1 + str ; return color ? pretty . format ( s ) : s ; }	return a tag , maybe formatted with color.
private final string load xml definition ( ) { final cache cache = cache factory . get any instance ( ) ; final string writer string writer = new string writer ( ) ; final print writer print writer = new print writer ( string writer ) ; cache xml generator . generate ( cache , print writer , bool , bool , bool ) ; print writer . close ( ) ; return load xml definition ( string writer . to string ( ) ) ; }	use the cachexmlgenerator to create xml from the entity associated with the current cache .
private long id ( http servlet request request ) { long id = null ; string path info = request . get path info ( ) ; if ( path info != null && path info . length ( ) > num ) { string id string = path info . substring ( num ) ; id = long . value of ( id string ) ; } return id ; }	extract id from the http request .
public void uncompress ( ) { data . position ( num ) ; inflater input stream inflater = new inflater input stream ( data . as input stream ( ) ) ; byte [ ] buffer = new byte [ num ] ; io buffer tmp = io buffer . allocate ( num ) ; tmp . set auto expand ( bool ) ; try { while ( inflater . available ( ) > num ) { int decompressed = inflater . read ( buffer ) ; if ( decompressed <= num ) { break ; } tmp . put ( buffer , num , decompressed ) ; } } catch ( io e ) { tmp . free ( ) ; throw new runtime exception ( str , e ) ; } finally { if ( inflater != null ) { try { inflater . close ( ) ; } catch ( io e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepare io ( ) ; }	decompress contents using zlib .
public void poll ( final tcp socket statistics handler handler ) { this . statistics handler = handler ; try { file loader . load ( ) ; final byte buffer buffer = file loader . get buffer ( ) ; line parser . reset ( ) ; line parser . handle token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics handler = null ; } monitored sockets . purge entries older than ( update count ) ; update count ++ ; }	read from monitored file , report any changed values for monitored socket statistics.
@ override public void close ( ) throws io { synchronized ( lock ) { if ( ! is closed ( ) ) { in . close ( ) ; buf = null ; } } }	closes this reader . this implementation closes the buffered source reader and releases the buffer . nothing is done if this reader has already been closed .
public int compare to ( char buffer other buffer ) { int compare remaining = ( remaining ( ) < other buffer . remaining ( ) ) ? remaining ( ) : other buffer . remaining ( ) ; int this pos = position ; int other pos = other buffer . position ; char this byte , other byte ; while ( compare remaining > num ) { this byte = get ( this pos ) ; other byte = other buffer . get ( other pos ) ; if ( this byte != other byte ) { return this byte < other byte ? - num : num ; } this pos ++ ; other pos ++ ; compare remaining -- ; } return remaining ( ) - other buffer . remaining ( ) ; }	compare the remaining chars of this buffer to another char buffer ' s remaining chars .
public csv ( string matsim4opus temp directory , string matsim output directory ) { this . matsim4opus temp directory = matsim4opus temp directory ; this . matsim output directory = matsim output directory ; try { log . info ( str ) ; zone writer = io . get buffered writer ( matsim4opus temp directory + file name ) ; log . info ( str + matsim4opus temp directory + file name + str ) ; zone writer . write ( labels . zone id + str + labels . accessibility by freespeed + str + labels . accessibility by car + str + labels . accessibility by bike + str + labels . accessibility by walk + str + labels . accessibility by pt ) ; zone writer . new line ( ) ; log . info ( str ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	writes the header for zones csv file.
@ override public void agg ( object new val ) { if ( new val instanceof byte [ ] ) { byte buffer buffer = byte buffer . wrap ( ( byte [ ] ) new val ) ; buffer . rewind ( ) ; while ( buffer . has remaining ( ) ) { agg val += buffer . get long ( ) ; count += buffer . get double ( ) ; first time = bool ; } return ; } agg val += ( long ) new val ; count ++ ; first time = bool ; }	average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value.
private static policy notification extract policy notification ( string xml ) throws policy evaluation exception { policy notification policy notification = null ; try { string notification data block = get notification data block ( xml ) ; if ( notification data block != null ) { document doc = xml . get xml ( new byte array input stream ( notification data block . get bytes ( ) ) ) ; node root node = xml . get root node ( doc , node policy service ) ; if ( root node != null ) { node notification node = xml . get child node ( root node , node policy notification ) ; if ( notification node != null ) { policy notification = policy notification . parse xml ( notification node ) ; } else { debug . error ( str + str + str ) ; throw new policy evaluation exception ( res bundle utils . rb name , str , null , null ) ; } } else { debug . error ( str + str ) ; } } else { debug . error ( str + str + str ) ; } } catch ( exception xe ) { debug . error ( str , xe ) ; throw new policy evaluation exception ( res bundle utils . rb name , str , null , xe ) ; } return policy notification ; }	returns the notification xml node.
public synchronized void flush ( ) throws io { check not closed ( ) ; trim to size ( ) ; journal writer . flush ( ) ; }	force buffered operations to the filesystem .
private object find parcel ( @ non null byte [ ] object array , @ non null string class name ) { try { class class tmp = get class for name ( class name ) ; constructor declared constructor = class tmp . get declared constructor ( parcel . class ) ; declared constructor . set accessible ( bool ) ; return declared constructor . new instance ( wear bus tools . byte to parcel ( object array ) ) ; } catch ( exception e ) { log . d ( wear bus tools . buswear tag , str + e . get message ( ) ) ; } return null ; }	attempts to locate the class specified by classname to instantiate with the given objectarray.
private static final string decode field name ( final string p xml field name ) { string builder str = new string builder ( ) ; int field name length = p xml field name . length ( ) ; char current char ; for ( int i = num ; i < field name length ; i ++ ) { current char = p xml field name . char at ( i ) ; if ( current char == str ) { str . append ( character . to upper case ( p xml field name . char at ( ++ i ) ) ) ; } else { str . append ( current char ) ; } } return str . to string ( ) ; }	decodes a field name from xml notation ( e.
public boolean is login set ( ) { return ( username != null && ( password != null && ! username . equals ( str ) && ! password . equals ( str ) ) ) || oauth ; }	return true if either login / pass is set or if oauth is enabled.
public void add content item ( content item content item ) { if ( content items == null ) { content items = new array list < content item > ( ) ; } content items . add ( content item ) ; }	adds a content item .
public static string canonicalize class name ( string name ) { string classname = name . replace ( str , str ) ; classname = classname . replace ( str , str ) ; if ( classname . starts with ( str ) ) classname = classname . substring ( num ) ; if ( classname . ends with ( str ) ) classname = classname . substring ( num , classname . length ( ) - num ) ; return classname ; }	create a proper class name from a messy thing.
public static final void pause ( final int milliseconds ) { if ( milliseconds >= num || logger . is debug enabled ( ) ) { logger . info ( str , milliseconds ) ; } final long target = system . current time millis ( ) + milliseconds ; try { for ( ; ; ) { long ms left = target - system . current time millis ( ) ; if ( ms left <= num ) { break ; } thread . sleep ( ms left ) ; } } catch ( interrupted exception e ) { assert . fail ( str , e ) ; } }	pause for the specified milliseconds.
public boolean is highlight with invisible edge ( ) { return highlight with invisible edge ; }	indicates if neighbor nodes with edges currently not visible still get highlighted .
private configuration prepare job for cancelling ( ) throws exception { prepare file ( str , num ) ; executed tasks . set ( num ) ; cancelled tasks . set ( num ) ; fail mapper id . set ( num ) ; splits count . set ( num ) ; configuration cfg = new configuration ( ) ; setup file systems ( cfg ) ; job job = job . get instance ( cfg ) ; job . set output key class ( text . class ) ; job . set output value class ( int writable . class ) ; job . set mapper class ( cancelling test mapper . class ) ; job . set num reduce tasks ( num ) ; job . set input format class ( in format . class ) ; file input format . set input paths ( job , new path ( str + get test grid name ( num ) + str ) ) ; file output format . set output path ( job , new path ( str + get test grid name ( num ) + str ) ) ; job . set jar by class ( get class ( ) ) ; return job . get configuration ( ) ; }	prepare job with mappers to cancel .
public void remove changing listener ( on wheel changed listener listener ) { changing listeners . remove ( listener ) ; }	removes wheel changing listener.
protected void generate fields ( ) { for ( iterator < element > iterator = m elements . iterator ( ) ; iterator . has next ( ) ; ) { element element = iterator . next ( ) ; if ( ! element . used ) { iterator . remove ( ) ; continue ; } psi field [ ] fields = m class . get fields ( ) ; boolean duplicate field = bool ; for ( psi field field : fields ) { string name = field . get name ( ) ; if ( name != null && name . equals ( element . get field name ( ) ) ) { duplicate field = bool ; break ; } } if ( duplicate field ) { iterator . remove ( ) ; continue ; } m class . add ( m factory . create field from text ( str + element . name + str + element . get field name ( ) + str , m class ) ) ; } }	create fields for injections inside main class.
public boolean is flying ( ) { return ( fly through dialog != null ) ; }	determine if in flight.
public synchronized void init ( ) { channel factory = new nio client socket channel factory ( executors . new cached thread pool ( ) , executors . new cached thread pool ( ) ) ; datagram channel factory = new nio datagram channel factory ( executors . new cached thread pool ( ) ) ; timer = new hashed wheel timer ( ) ; }	initialize ; cached threadpool is safe as it is releasing resources automatically if idle.
public static string remove pattern ( final string source , final string regex ) { return replace pattern ( source , regex , string utils . empty ) ; }	removes each substring of the source string that matches the given regular expression using the dotall option .
private void consume nested scroll ( int dx unconsumed , int dy unconsumed , int dx final unconsumed , int dy final unconsumed ) { if ( m over scroll effect == over scroll effect . bounce && dy final unconsumed != num ) { m unconsumed over scroll offset += - dy final unconsumed ; int max offset = m over scroll offset limit ; if ( m unconsumed over scroll offset > num ) { m unconsumed over scroll offset = math . min ( max offset , m unconsumed over scroll offset ) ; } else if ( m unconsumed over scroll offset < num ) { m unconsumed over scroll offset = math . max ( - max offset , m unconsumed over scroll offset ) ; } set scrolling offset ( get unconsumed scrolling offset ( ) ) ; } pull edge effects ( dx unconsumed , dy unconsumed ) ; }	consume the final unconsumed nested scroll after all behaviors done .
private void retrieve waypoints ( search query query , array list < waypoint > waypoints ) { string query like selection2 = str + query . text query + str ; string [ ] waypoint selection args = new string [ ] { query like selection2 , query like selection2 , query like selection2 } ; cursor cursor = null ; try { cursor = provider utils . get waypoint cursor ( waypoint selection query , waypoint selection args , waypoint selection order , max scored waypoints ) ; if ( cursor != null ) { waypoints . ensure capacity ( cursor . get count ( ) ) ; while ( cursor . move to next ( ) ) { waypoint waypoint = provider utils . create waypoint ( cursor ) ; if ( location utils . is valid location ( waypoint . get location ( ) ) ) { waypoints . add ( waypoint ) ; } } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	retrieves waypoints matching the given query from the database .
void release ( ) { image loader . cancel pending requests ( ) ; loading = new boolean [ nox items . size ( ) ] ; }	cancels all the pending noxitem downloads to the imageloader .
public int size ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }	returns the number of elements in this deque .
public void add ( string name , long cnt ) { if ( values == null ) { values = new array list < > ( num ) ; } values . add ( new count ( this , name , cnt ) ) ; }	insert at the end of the list.
void close dialog ( ) ;	closes dialog ( if opened ) .
public media config create channel file attachment ( string file , media config config ) { config . add credentials ( this ) ; string xml = postfile ( this . url + str , file , config . name , config . to xml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { media config media = new media config ( ) ; media . parse xml ( root ) ; return media ; } catch ( exception exception ) { this . exception = sdk . parse failure ( exception ) ; throw this . exception ; } }	create a new file / image / media attachment for a chat channel .
public void add param ( ast node param ) { assert not null ( param ) ; if ( params == null ) { params = new array list < ast node > ( ) ; } params . add ( param ) ; param . set parent ( this ) ; }	adds a parameter to the function parameter list.
delete event ( @ non null json json ) throws json { super ( type delete , json ) ; if ( text utils . is empty ( m block id ) ) { throw new json ( typename delete + str + json block id ) ; } m old xml = json . opt string ( json old value ) ; json ids = json . get json ( json ids ) ; int count = ids . length ( ) ; list < string > temp = new array list < > ( count ) ; for ( int i = num ; i < count ; ++ i ) { temp . add ( ids . get string ( i ) ) ; } m ids = collections . unmodifiable list ( temp ) ; }	constructs a deleteevent from the json serialized representation .
public static boolean is full copy restorable ( volume volume , db client db client ) { boolean result = bool ; string replica state = volume . get replica state ( ) ; if ( is volume full copy ( volume , db client ) && replica state != null && ! replica state . is empty ( ) ) { replication state state = replication state . get enum value ( replica state ) ; if ( state != null && state == replication state . synchronized ) { result = bool ; } } return result ; }	check if the full copy volume could be restored .
private final static string [ ] read qd ( string string , int [ ] pos ) throws naming exception { return read q ( string , pos ) ; }	dstring = 1 * utf8 qdstring = whsp " ' " dstring " ' " whsp qdstringlist = [ qdstring * ( qdstring ) ] qdstrings = qdstring / ( whsp " ( " qdstringlist " ) " whsp ).
private static boolean is buffer too large ( byte buffer buf ) { return is buffer too large ( buf . capacity ( ) ) ; }	returns true if the buffer is too large to be added to the buffer cache , false otherwise .
public static void reset index buffer time ( ) { safe query time . set ( num ) ; }	only for test purposes this should not be called from any product code . calls from product code will possibly cause continous reevaluation ( performance issue ) or incorrect query results ( functional issue ).
protected abstract admin response create response ( distribution manager dm ) ;	must return a proper response to this request .
protected boolean check external storage and notify ( string file name ) { if ( file name != null && file name . starts with ( str ) ) { alert download failure ( r . string . download no sdcard dlg title ) ; return bool ; } string status = environment . get external storage state ( ) ; if ( ! status . equals ( environment . media mounted ) ) { int title ; if ( status . equals ( environment . media shared ) ) { title = r . string . download sdcard busy dlg title ; } else { title = r . string . download no sdcard dlg title ; } alert download failure ( title ) ; return bool ; } return bool ; }	check the external storage and notify user on error .
public static string plnoun ( final int quantity , final string noun ) { final string enoun = full form ( noun ) ; if ( quantity == num ) { return singular ( enoun ) ; } else { return plural ( noun ) ; } }	returns either the plural or singular form of the given noun , depending on the quantity .
public boolean verify xml ( org . w3c . dom . element element , java . lang . string cert alias ) throws xml { return verify xml ( element , def id attribute , cert alias ) ; }	verify the signature of the xml document.
public void add ( video video ) { video list . add ( video ) ; notify data set changed ( ) ; }	adds a video to the adapter and notify the change .
private static boolean is in horizontal target zone ( float x , float y , float handle x , float handle x , float handle y , float target radius ) { if ( x > handle x && x < handle x && math . abs ( y - handle y ) <= target radius ) { return bool ; } return bool ; }	determines if the specified coordinate is in the target touch zone for a horizontal bar handle .
public void read transport systems ( final int [ ] columns indices , final buffered reader reader ) throws io { string line = reader . read line ( ) ; while ( line != null && line . length ( ) > num ) { line = reader . read line ( ) ; } }	reads the transport systems of the visum file.
private boolean has prefix ( byte [ ] nal ) { if ( nal [ num ] == num && nal [ num ] == num && nal [ num ] == num && nal [ num ] == num ) return bool ; else return bool ; }	makes sure the nal has a header or not .
private void unshare main ( ) { int [ ] old = main hash ; int len = main hash . length ; main hash = new int [ len ] ; system . arraycopy ( old , num , main hash , num , len ) ; main hash shared = bool ; }	method that needs to be called , if the main hash structure is ( may be ) shared . this happens every time something is added , even if addition is to the collision list ( since collision list index comes from lowest 8 bits of the primary hash entry ).
public component config builder add item in multifield ( string multifield label , int index , string item type , string item label , string value ) { string type = string . format ( str , index , item type ) ; string label = string . format ( str , multifield label , item label ) ; config . add ( new configuration entry ( current tab , type , label , value ) ) ; return this ; }	adds multifield entry , equivalent of : | tab_name | multifield # index # itemtype | multifieldlabel # itemlabel | value |.
public int size ( ) { return names . size ( ) ; }	returns the number of members ( name / value pairs ) in this object .
public static i [ ] random points ( int n , int d , int scale ) { i points [ ] = new i [ n ] ; for ( int i = num ; i < n ; i ++ ) { string builder sb = new string builder ( ) ; for ( int j = num ; j < d ; j ++ ) { sb . append ( r gen . next double ( ) * scale ) ; if ( j < d - num ) { sb . append ( str ) ; } } points [ i ] = new hyperpoint ( sb . to string ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
private void parse parameters ( string parameters ) { log . v ( str , str + str + parameters ) ; if ( parameters != null ) { int i ; do { i = parameters . index of ( str ) ; if ( i < num ) { parse parameter ( parameters ) ; } else { parse parameter ( parameters . substring ( num , i ) ) ; parameters = parameters . substring ( i + num ) ; } } while ( i >= num ) ; } }	parses a comma - separated list of authentification scheme parameters .
public void add http session token ( string site , string token ) { if ( ! site . contains ( str ) ) { site = site + ( str ) ; } http session tokens set site tokens = session tokens . get ( site ) ; if ( site tokens == null ) { site tokens = new http session tokens set ( ) ; session tokens . put ( site , site tokens ) ; } log . info ( str + site + str + token ) ; site tokens . add token ( token ) ; unmark removed default session token ( site , token ) ; }	adds a new session token for a particular site .
public gradle distribution deserialize from string ( string distribution string ) { preconditions . check not null ( distribution string ) ; string local installation prefix = str ; if ( distribution string . starts with ( local installation prefix ) && distribution string . ends with ( str ) ) { string local installation dir = distribution string . substring ( local installation prefix . length ( ) , distribution string . length ( ) - num ) ; return gradle distribution . for local installation ( new file ( local installation dir ) ) ; } string remote distribution prefix = str ; if ( distribution string . starts with ( remote distribution prefix ) && distribution string . ends with ( str ) ) { string remote distribution uri = distribution string . substring ( remote distribution prefix . length ( ) , distribution string . length ( ) - num ) ; return gradle distribution . for remote distribution ( create uri ( remote distribution uri ) ) ; } string version prefix = str ; if ( distribution string . starts with ( version prefix ) && distribution string . ends with ( str ) ) { string version = distribution string . substring ( version prefix . length ( ) , distribution string . length ( ) - num ) ; return gradle distribution . for version ( version ) ; } string wrapper string = str ; if ( distribution string . equals ( wrapper string ) ) { return gradle distribution . from build ( ) ; } string message = string . format ( str , distribution string ) ; throw new runtime exception ( message ) ; }	deserializes the gradle distribution from the the given string representation .
public double meters to pixels ( ) { double screen center lat = screen top left . latitude - screen size . latitude / num ; double meters to lon = num / ( util . lon to meters at equator * math . cos ( screen center lat / num * math . pi ) ) ; return screen size . longitude / window width * meters to lon ; }	returns the ratio of meters to pixels at the center of the screen.
public boolean send via data socket ( byte [ ] bytes , int start , int len ) { if ( data output stream == null ) { log . i ( tag , str ) ; return bool ; } if ( len == num ) { return bool ; } try { data output stream . write ( bytes , start , len ) ; } catch ( io e ) { log . i ( tag , str ) ; log . i ( tag , e . to string ( ) ) ; return bool ; } local data socket . report traffic ( len ) ; return bool ; }	sends a byte array over the already - established data socket.
private void push context ( base context c ) { context stack . push ( c ) ; }	add a new parsing context onto the parse context stack .
@ override public void bookmarks or history picker ( combo views start view ) { if ( m tab control . get current web view ( ) == null ) { return ; } if ( is in custom action mode ( ) ) { end action mode ( ) ; } bundle extras = new bundle ( ) ; extras . put boolean ( browser bookmarks page . extra disable window , ! m tab control . can create new tab ( ) ) ; m ui . show combo view ( start view , extras ) ; }	open the go page .
public fst ( string file name , string encoding , boolean verbose ) throws io { file input stream fis = new file input stream ( file name ) ; try { load headerless ( fis , encoding , verbose ) ; } finally { fis . close ( ) ; } }	initialise the finite state transducer .
public static double [ ] normalize zscore ( double [ ] x ) { double mn = mean ( x , num ) ; double sd = standard deviation ( x , num ) ; for ( int i = num ; i < x . length ; i ++ ) if ( ! double . is na n ( x [ i ] ) ) x [ i ] = ( x [ i ] - mn ) / sd ; return x ; }	calcualtes x_i = ( x_i - mean ( x ) ) / std ( x ) this function can deal with nans.
void add location ( string location ) { if ( f location list . contains ( location ) ) { return ; } f location list . add ( location ) ; f table viewer . refresh ( ) ; f table viewer . set checked ( location , bool ) ; f table viewer . set selection ( new structured selection ( location ) ) ; validate locations ( ) ; }	adds the given location to the table.
public java formatter ( string line delimiter , int initial indent level , boolean use code formatter , i project ) { f line delimiter = line delimiter ; f use code formatter = use code formatter ; f initial indent level = initial indent level ; f project = project ; }	creates a javaformatter with the target line delimiter .
public string encode ( final string p string , final string charset ) throws encoder exception { if ( p string == null ) { return null ; } try { return encode text ( p string , charset ) ; } catch ( unsupported encoding exception e ) { throw new encoder exception ( e . get message ( ) ) ; } }	encodes a string into its quoted - printable form using the specified charset.
private static void check path need ( ) { if ( sampling interval == - num ) { last preload time = read more paths ( ) ; } if ( ! double . is na n ( last preload time ) && sim clock . get time ( ) >= last preload time - ( sampling interval * min ahead intervals ) ) { for ( int i = num ; i < nrof preload && ! double . is na n ( last preload time ) ; i ++ ) { last preload time = read more paths ( ) ; } } }	checks if more paths should be preloaded and preloads them if needed .
public boolean is input column name allowed ( string column name ) { if ( column name == null || column name . length ( ) == num ) return bool ; get input column names ( bool ) ; for ( int i = num ; i < m inputcolumnnames . length ; i ++ ) { if ( column name . equals ( m inputcolumnnames [ i ] ) ) return bool ; } return bool ; }	is input column name allowed.
public static int rgb ( string hex ) { int color = ( int ) long . parse long ( hex . replace ( str , str ) , num ) ; int r = ( color > > num ) & num ; int g = ( color > > num ) & num ; int b = ( color > > num ) & num ; return color . rgb ( r , g , b ) ; }	converts the given hex - color - string to rgb .
@ override public void add property change listener ( string name , property change listener pcl ) { m bc support . add property change listener ( name , pcl ) ; }	add a property change listener to this bean.
public void test empty or null blob ( ) throws exception { try { prepared statement stmt = connection . prepare statement ( str ) ; try { stmt . set int ( num , num ) ; stmt . set bytes ( num , new byte [ num ] ) ; int inserted count = stmt . execute update ( ) ; assert true ( str , inserted count == num ) ; stmt . set int ( num , num ) ; stmt . set null ( num , types . binary ) ; inserted count = stmt . execute update ( ) ; assert true ( str , inserted count == num ) ; } finally { stmt . close ( ) ; } stmt = connection . prepare statement ( str ) ; stmt . set int ( num , num ) ; try { result set rs = stmt . execute query ( ) ; assert true ( str , rs . next ( ) ) ; assert true ( str , arrays . equals ( rs . get bytes ( num ) , new byte [ num ] ) ) ; rs . close ( ) ; stmt . set int ( num , num ) ; rs = stmt . execute query ( ) ; assert true ( str , rs . next ( ) ) ; assert true ( str , rs . get object ( num ) == null ) ; rs . close ( ) ; } finally { stmt . close ( ) ; } } catch ( exception ex ) { ex . print stack trace ( ) ; throw ex ; } }	test if driver returns correctly empty and null blobs .
private synchronized void rebuild journal ( ) throws io { if ( journal writer != null ) { journal writer . close ( ) ; } writer writer = new buffered writer ( new output stream writer ( new file output stream ( journal file tmp ) , utils . us ascii ) ) ; try { writer . write ( magic ) ; writer . write ( str ) ; writer . write ( version 1 ) ; writer . write ( str ) ; writer . write ( integer . to string ( app version ) ) ; writer . write ( str ) ; writer . write ( integer . to string ( value count ) ) ; writer . write ( str ) ; writer . write ( str ) ; for ( entry entry : lru entries . values ( ) ) { if ( entry . current editor != null ) { writer . write ( dirty + str + entry . key + str ) ; } else { writer . write ( clean + str + entry . key + entry . get lengths ( ) + str ) ; } } } finally { writer . close ( ) ; } if ( journal file . exists ( ) ) { rename to ( journal file , journal file backup , bool ) ; } rename to ( journal file tmp , journal file , bool ) ; journal file backup . delete ( ) ; journal writer = new buffered writer ( new output stream writer ( new file output stream ( journal file , bool ) , utils . us ascii ) ) ; }	creates a new journal that omits redundant information.
public void test case22 ( ) { byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; int b sign = - num ; big integer a number = big integer . zero ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract a number from zero.
@ suppress warnings ( str ) public void restore ( string file name ) throws io , class not found exception { object input stream ois = new object input stream ( new file input stream ( file name ) ) ; locations = ( map < v , point > ) ois . read object ( ) ; ois . close ( ) ; initialize locations ( ) ; locked = bool ; fire state changed ( ) ; }	restore the graph vertex locations from a file.
public void wait for data ( ) { if ( this . initialized ) { return ; } wait on initialization ( this . initialization latch after get initial image ) ; }	wait until data is ready in this region.
private void blackman harris4s min ( int size ) { int start = ( window function . length - size ) / num ; int stop = ( window function . length + size ) / num ; double scale = num / ( double ) size / num ; for ( int i = num ; start < stop ; start ++ , i ++ ) window function [ i ] = scale * ( num - num * math . cos ( two pi * i / size ) + num * math . cos ( num * two pi * i / size ) - num * math . cos ( num * two pi * i / size ) ) ; }	fill an array with the values of a minimum 4 - sample blackman - harris window function.
private byte [ ] calculate cms ( byte [ ] key ) { byte [ ] result = new byte [ num ] ; sha1 . update ( key , num , key . length ) ; sha1 . do final ( digest , num ) ; system . arraycopy ( digest , num , result , num , num ) ; return result ; }	some key wrap algorithms make use of the key checksum defined in cms [ cms - algorithms ].
public int hash code ( ) { return lower nick . hash code ( ) ; }	returns the hash code of this user object .
public boolean increment received ( ) { long diff = system . current time millis ( ) - start time ; if ( diff >= num ) { packets per second = interval packets ; start time = system . current time millis ( ) ; interval packets = num ; return bool ; } else { interval packets ++ ; } this . received packets ++ ; return bool ; }	used for incrementing the number of packets received from the client.
sentence parse sentence ( final string text , final conversation context ctx ) { if ( is empty ( ) ) { return conversation parser . parse ( text , ctx ) ; } string txt = text . trim ( ) ; final sentence sentence = new sentence implementation ( ctx , txt ) ; txt = conversation parser . detect sentence type ( txt , sentence ) ; if ( type matching ) { read type match expressions ( txt , ctx , sentence ) ; } else if ( exact matching ) { read simple expressions ( txt , ctx , sentence ) ; } else if ( similar matching ) { read simple expressions ( txt , ctx , sentence ) ; } else if ( joker matching ) { read joker expressions ( txt , ctx , sentence ) ; } else if ( case insensitive ) { read simple expressions ( txt , ctx , sentence ) ; } return sentence ; }	parse the given text string and create a sentence object using the current matching flags .
public kafka cluster using directory ( file data dir ) { if ( running ) throw new illegal state exception ( str ) ; if ( data dir != null && data dir . exists ( ) && ! data dir . is directory ( ) && ! data dir . can write ( ) && ! data dir . can read ( ) ) { throw new illegal argument exception ( str ) ; } this . data dir = data dir ; return this ; }	set the parent directory where the brokers logs and server ' s logs and snapshots will be kept .
void on consume finished ( purchase purchase , iab result result ) ;	called to notify that a consumption has finished .
protected boolean check prosodic position ( element current rule part , string prosodic position type ) { named node map att nodes = current rule part . get attributes ( ) ; for ( int z = num ; z < att nodes . get length ( ) ; z ++ ) { node el = att nodes . item ( z ) ; string current att = el . get node name ( ) ; string current val = el . get node value ( ) ; if ( current att . equals ( str ) ) { if ( ! current val . starts with ( str ) ) { if ( ! prosodic position type . equals ( current val ) ) return bool ; } else { current val = current val . substring ( num , current val . length ( ) ) ; if ( prosodic position type . equals ( current val ) ) return bool ; } } } return bool ; }	checks rule part with tag " prosodicposition " ; there is only the " type " attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear.
public static big decimal parse big decimal for entity ( string big decimal string ) throws number format exception { if ( big decimal string == null ) { return null ; } big decimal string = big decimal string . trim ( ) ; big decimal string = big decimal string . replace all ( str , str ) ; if ( big decimal string . length ( ) < num ) { return null ; } return new big decimal ( big decimal string ) ; }	return nulls for empty strings , as the entity engine can deal with nulls.
public static void register operators ( string name , input stream operators xml , class loader class loader ) { register operators ( name , operators xml , class loader , null ) ; }	registers all operators from a given xml input stream.
private void do permission work before android m ( @ non null activity activity , @ non null string [ ] permissions , @ nullable permissions result action action ) { for ( string perm : permissions ) { if ( action != null ) { if ( ! m permissions . contains ( perm ) ) { action . on result ( perm , permissions . not found ) ; } else if ( activity compat . check self permission ( activity , perm ) != package manager . permission granted ) { action . on result ( perm , permissions . denied ) ; } else { action . on result ( perm , permissions . granted ) ; } } } }	when request permissions on devices before android m ( android 6 . 0 , api level 23 ) do the granted or denied work directly according to the permission status.
public void delete sub group containers ( set group containers ) throws am , sso { iterator iter = group containers . iterator ( ) ; while ( iter . has next ( ) ) { string group container dn = ( string ) iter . next ( ) ; am group container = new am ( token , group container dn ) ; group container . delete ( ) ; } }	deletes sub group containers in this group container .
public glow task ( plugin owner , runnable task , boolean sync , long delay , long period ) { super ( task , null ) ; task id = next task id . get and increment ( ) ; description = task . to string ( ) ; this . owner = owner ; this . delay = delay ; this . period = period ; counter = num ; this . sync = sync ; }	creates a new task with the specified number of ticks between consecutive calls to execute ( ) .
public static void init ( string [ ] args ) { try { compiler . init compiler ( args ) ; if ( vm . build for adaptive system && vm . build with base boot image compiler ) { opt compiler . init compiler ( args ) ; } } catch ( throwable e ) { while ( e != null ) { e . print stack trace ( ) ; e = e . get cause ( ) ; } } }	initialize boot image compiler .
static native boolean open dev ( ) ;	open fm device , call before power up.
int send next byte ( ) { int result = num ; try { long t diff = inter byte time - ( ( system . current time millis ( ) - last rx time ) * num ) ; if ( t diff > num ) { log . debug ( str + t diff + str ) ; thread . sleep ( t diff / num , ( int ) ( t diff % num ) ) ; } } catch ( interrupted exception ex ) { log . error ( str + ex . to string ( ) ) ; } if ( curr tx char pos >= curr tx tgm . length ) { result = dequeue telegram ( ) ; } if ( result == num ) { write char ( curr tx tgm [ curr tx char pos ++ ] , bool ) ; if ( curr tx char pos >= curr tx tgm . length ) { set prot stat ( prot status . receiving ) ; } } return result ; }	send next available byte.
public static string encode ( serializable o ) { byte array output stream bos = new byte array output stream ( ) ; try { object output stream oos = new object output stream ( bos ) ; try { oos . write object ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return base64 . encode bytes ( bos . to byte array ( ) ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	encode a object to a base64 string.
public static map < string , object > create image ( dispatch context dctx , map < string , ? extends object > context ) { map < string , object > result = create image method ( dctx , context ) ; return result ; }	a service wrapper for the createimagemethod method.
public void add profiles ( @ non null i ... profiles ) { if ( m account header builder . m profiles == null ) { m account header builder . m profiles = new array list < > ( ) ; } collections . add all ( m account header builder . m profiles , id distributor . check ids ( profiles ) ) ; m account header builder . update header and list ( ) ; }	add new profiles to the existing list of profiles.
private static boolean is identifier name ( string k ) { int n = k . length ( ) ; if ( n == num ) { return bool ; } if ( ! character . is java identifier start ( k . char at ( num ) ) ) { return bool ; } for ( int i = num ; i < n ; ++ i ) { if ( ! character . is java identifier part ( k . char at ( i ) ) ) { return bool ; } } return bool ; }	an ecmascript identifiername is an identifier or reserved word.
static boolean less than unsigned long ( long x1 , long x2 ) { return ( x1 + long . min value ) < ( x2 + long . min value ) ; }	returns true if x1 is less than x2 , when both values are treated as unsigned long .
private void move single node ( object source , point new point ) { display node node = ( display node ) source ; int delta x = new point . x - click point . x ; int delta y = new point . y - click point . y ; int new x = node . get location ( ) . x + delta x ; int new y = node . get location ( ) . y + delta y ; node . set location ( new x , new y ) ; }	move a single , unselected node .
public static < t > list < t > to list ( t obj1 , t obj2 , t obj3 ) { list < t > list = new linked list < t > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; list . add ( obj3 ) ; return list ; }	create a list from passed objx parameters.
public void add macro record ( macro record record ) { if ( record != null ) macro records . add ( record ) ; }	adds a macro record to this macro .
public builder add email ( email email ) { emails . add ( email ) ; return this ; }	adds or updates a emil of an existing user if the.
public static hash provider best ( hash parameters params ) { return best ( params , enum set . of ( hash support . stateful ) ) ; }	returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .
public byte [ ] read raw bytes ( final int size ) throws io { if ( size < num ) { throw invalid protocol buffer nano exception . negative size ( ) ; } if ( buffer pos + size > current limit ) { skip raw bytes ( current limit - buffer pos ) ; throw invalid protocol buffer nano exception . truncated message ( ) ; } if ( size <= buffer size - buffer pos ) { final byte [ ] bytes = new byte [ size ] ; system . arraycopy ( buffer , buffer pos , bytes , num , size ) ; buffer pos += size ; return bytes ; } else { throw invalid protocol buffer nano exception . truncated message ( ) ; } }	read a fixed size of bytes from the input .
static boolean pair sum ( int ar [ ] , int x ) { arrays . sort ( ar ) ; int len = ar . length ; for ( int i = num , j = len - num ; i < j ; ) { if ( ar [ i ] + ar [ j ] == x ) { return bool ; } else if ( ar [ i ] + ar [ j ] < x ) { i ++ ; } else { j -- ; } } return bool ; }	using sorting . if we use merge sort or heap sort then ( - ) ( nlogn ) in worst case . if we use quick sort then o ( n ^ 2 ) in worst case .
public synchronized void load from file ( ) { entries . clear ( ) ; path file = paths . get ( file name ) ; try ( buffered reader reader = files . new buffered reader ( file , charset ) ) { string line ; do { line = reader . read line ( ) ; addressbook entry parsed entry = parse line ( line ) ; if ( parsed entry != null ) { entries . put ( parsed entry . get name ( ) , parsed entry ) ; } } while ( line != null ) ; } catch ( io ex ) { logger . warning ( str + ex . get localized message ( ) ) ; } logger . info ( str + entries . size ( ) + str + file name ) ; scan categories ( ) ; }	loads the addressbook from file .
public boolean remove ( final int position ) { final adapter transaction remove transaction = new remove transaction < > ( this , position ) ; final boolean success = remove transaction . perform ( ) ; m transactions . offer ( remove transaction ) ; return success ; }	removes item from the given position .
private void encode types ( list < type > types , map < string , object > m , string key , declaration from ) { if ( types == null || types . is empty ( ) ) return ; list < map < string , object > > sats = new array list < > ( types . size ( ) ) ; for ( type st : types ) { sats . add ( type map ( st , from ) ) ; } m . put ( key , sats ) ; }	encodes the list of types and puts them under the specified key in the map .
public static void clear assertion information ( ) { assert infos . clear ( ) ; assert occured = bool ; }	clears internal assertion information storage.
public void build ( string code , string custom status ) { try { if ( custom status != null ) { result . put ( resources . get string ( r . string . intent extra status ) , custom status ) ; } else { result . put ( resources . get string ( r . string . intent extra status ) , resources . get string ( r . string . shared pref default status ) ) ; } result . put ( resources . get string ( r . string . intent extra code ) , code ) ; operation list result . put ( result ) ; } catch ( json e ) { log . e ( tag , str + e . to string ( ) ) ; } }	add operation results to the array to be returned .
public static operator generate branch plan ( akiban information schema ais , table table ) { final operator index scan = generate index scan ( ais , table ) ; final schema schema = schema cache . global schema ( ais ) ; primary key pkey = table . get primary key including internal ( ) ; index row type index type = schema . index row type ( pkey . get index ( ) ) ; return generate branch plan ( table , index scan , index type ) ; }	scan a group starting with primary key of a table , then get all of the children ( if any ).
protected void add to maintenance queue ( node port tuple npt ) { if ( maintenance queue . contains ( npt ) == bool ) { maintenance queue . add ( npt ) ; } }	add a switch port to maintenance queue .
public long startstack ( ) { return long . parse long ( fields [ num ] ) ; }	the address of the start ( i.
public boolean match ( mime type other ) { if ( this == other ) return bool ; if ( type != null && other . type != null && ! type . equals ( other . type ) ) return bool ; if ( subtype != null && other . subtype != null && ! subtype . equals ( other . subtype ) ) return bool ; return bool ; }	checks if given mimetype is covered by current mimetype.
@ override public boolean is armed ( ) { return other . is armed ( ) ; }	all these methods simply delegate to the " other " model that is being decorated .
public encoder test suite builder valid ( int min , int max ) { valid . set ( min , max + num ) ; invalid . clear ( min , max + num ) ; encoded . clear ( min , max + num ) ; return this ; }	tells the builder that a range of code - points is valid .
public static boolean is java script enabled ( http servlet request request ) { http session session = request . get session ( ) ; boolean java script enabled = ( boolean ) session . get attribute ( str ) ; if ( java script enabled != null ) { return java script enabled . boolean value ( ) ; } return bool ; }	returns true if the user has javascript enabled .
public boolean equals ( object obj ) { if ( this == obj ) return bool ; if ( obj instanceof ec ) { return ( p . equals ( ( ( ec ) obj ) . p ) ) ; } return bool ; }	compares this prime finite field for equality with the specified object .
public string name ( ) { return the name ; }	returns the name of this element type .
private static string checksum m ( string data ) { message digest md5 = null ; try { md5 = message digest . get instance ( str ) ; } catch ( no such algorithm exception ex ) { throw new runtime exception ( str , ex ) ; } return hex encode ( md5 . digest ( data . get bytes ( ) ) ) ; }	md5 version of the " h ( ) " function from rfc2617 .
public static boolean valid skin spec file ( string file name ) { file file = new file ( configuration . skins dir ( ) , file name ) ; if ( ! file . exists ( ) || ! file . is file ( ) ) { return bool ; } document builder factory dbf = document builder factory . new instance ( ) ; try { document builder builder = dbf . new document builder ( ) ; document doc = builder . parse ( file ) ; node list list of components = doc . get elements by tag name ( ui element ) ; if ( list of components . get length ( ) > num ) { return bool ; } else { return bool ; } } catch ( exception e ) { return bool ; } }	checks whether the given path points to a file that is a valid skin specification .
public str builder insert ( final int index , final object obj ) { if ( obj == null ) { return insert ( index , null text ) ; } return insert ( index , obj . to string ( ) ) ; }	inserts the string representation of an object into this builder.
@ override public void handle mouse moved ( chart canvas canvas , mouse event e ) { if ( ! canvas . is tooltip enabled ( ) ) { return ; } string text = get tooltip text ( canvas , e . get x ( ) , e . get y ( ) ) ; canvas . set tooltip ( text , e . get screen x ( ) , e . get screen y ( ) ) ; }	handles a mouse moved event by updating the tooltip .
private boolean load unpacked umd ( string filename ) throws io , general jpcsp exception { if ( do umd buffering ) { return bool ; } file file = new file ( filename ) ; if ( file . exists ( ) ) { random access file raf = new random access file ( file , str ) ; file channel ro channel = raf . get channel ( ) ; byte buffer readbuffer = ro channel . map ( file channel . map mode . read only , num , ( int ) ro channel . size ( ) ) ; emulator . load ( str , readbuffer ) ; raf . close ( ) ; log . info ( str ) ; return bool ; } return bool ; }	don ' t call this directly , see loadumd ( file file ).
public boolean disable vma ( uri block object uri , storage system storage system ) { virtual pool virtual pool = null ; storage pool storage pool = null ; volume volume = null ; if ( uri . is type ( block object uri , volume . class ) ) { volume = db client . query object ( volume . class , block object uri ) ; } else if ( uri . is type ( block object uri , block snapshot . class ) ) { block snapshot snapshot = db client . query object ( block snapshot . class , block object uri ) ; volume = db client . query object ( volume . class , snapshot . get parent ( ) ) ; } else if ( uri . is type ( block object uri , block mirror . class ) ) { block mirror mirror = db client . query object ( block mirror . class , block object uri ) ; virtual pool = db client . query object ( virtual pool . class , mirror . get virtual pool ( ) ) ; storage pool = db client . query object ( storage pool . class , mirror . get pool ( ) ) ; } if ( volume != null ) { virtual pool = db client . query object ( virtual pool . class , volume . get virtual pool ( ) ) ; storage pool = db client . query object ( storage pool . class , volume . get pool ( ) ) ; } return ( check if provider supports compression operations ( storage system ) && ! virtual pool . get compression enabled ( ) && storage pool . get compression enabled ( ) ) ; }	this method is will check if the storage pool associated with the volume supports compression.
public static lat lon rhumb end position ( lat lon p , double rhumb azimuth radians , double path length radians ) { if ( p == null ) { throw new illegal argument exception ( str ) ; } return rhumb end position ( p , angle . from radians ( rhumb azimuth radians ) , angle . from radians ( path length radians ) ) ; }	computes the location on a rhumb line with the given starting location , rhumb azimuth , and arc distance along the line .
private static int index of ( object [ ] array , object elt ) { return index of ( array , array . length , elt ) ; }	returns the first index of elt in the array , else - 1 .
public dimension maximum layout size ( container target ) { return new dimension ( integer . max value , integer . max value ) ; }	returns the maximum dimensions for this layout given the components in the specified target container .
public static string read stream ( input stream in ) { buffered reader reader = new buffered reader ( new input stream reader ( in ) ) ; string builder sb = new string builder ( ) ; string line = null ; try { while ( ( line = reader . read line ( ) ) != null ) { sb . append ( line + str ) ; } } catch ( io e ) { fresh air log . e ( str , e ) ; } finally { try { in . close ( ) ; } catch ( io e ) { } try { reader . close ( ) ; } catch ( io e ) { } } return sb . to string ( ) ; }	utility method for pulling plain text from an inputstream object.
public void update ( long n ) { uncounted . add and get ( n ) ; }	update the moving average with a new value .
private void log expiration ( entry e ) { if ( e . renewals done ( ) ) { logger . log ( level . fine , str , e . lease ) ; } else { logger . log ( levels . failed , str , e . lease ) ; } }	logs a lease expiration , distinguishing between expected and premature expirations .
void remove ripple ( ripple ripple ) { final ripple [ ] ripples = m exiting ripples ; final int count = m exiting ripples count ; final int index = get ripple index ( ripple ) ; if ( index >= num ) { system . arraycopy ( ripples , index + num , ripples , index , count - ( index + num ) ) ; ripples [ count - num ] = null ; m exiting ripples count -- ; invalidate self ( ) ; } }	removes a ripple from the exiting ripple list .
protected final void write s ( byte buffer buf , string text ) { if ( text == null ) { buf . put char ( str ) ; } else { final int len = text . length ( ) ; for ( int i = num ; i < len ; i ++ ) { buf . put char ( text . char at ( i ) ) ; } buf . put char ( str ) ; } }	write string to buffer.
protected source records consume records by topic ( int num records ) throws interrupted exception { source records records = new source records ( ) ; consume records ( num records , null ) ; return records ; }	try to consume and capture exactly the specified number of records from the connector .
@ override public boolean equals ( object o ) { if ( this == o ) { return bool ; } if ( ! ( o instanceof prototype size ) ) { return bool ; } prototype size size = ( prototype size ) o ; return prototype . equals ( size . prototype ) ; }	indicates whether some other constantsize is " equal to " this one .
private static int compare version ( string version str1 , string version str2 ) { if ( version str1 == null ) { throw new ml ( str ) ; } if ( version str2 == null ) { throw new ml ( str ) ; } scanner scanner1 = null ; scanner scanner2 = null ; try { scanner1 = new scanner ( version str1 ) ; scanner2 = new scanner ( version str2 ) ; scanner1 . use delimiter ( str ) ; scanner2 . use delimiter ( str ) ; while ( scanner1 . has next int ( ) && scanner2 . has next int ( ) ) { int version1 = scanner1 . next int ( ) ; int version2 = scanner2 . next int ( ) ; if ( version1 < version2 ) { return - num ; } else if ( version1 > version2 ) { return num ; } } return scanner1 . has next int ( ) ? num : num ; } finally { scanner1 . close ( ) ; scanner2 . close ( ) ; } }	compare two version strings ( ie , " 1.
public static boolean is valid vector ( vector2f vector ) { if ( vector == null ) { return bool ; } if ( float . is na n ( vector . x ) || float . is na n ( vector . y ) ) { return bool ; } if ( float . is infinite ( vector . x ) || float . is infinite ( vector . y ) ) { return bool ; } return bool ; }	check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .
public boolean is obsessional ( ) { return type string . contains ( suffix obsessional ) ; }	determine if the expression is a obsessional one .
@ edu . umd . cs . findbugs . annotations . fb ( value = str , justification = str ) public void change loco speed ( dcc throttle t , block blk , float speed ) { if ( blk == referenced && speed == desired speed step ) { return ; } float block length = blk . get length mm ( ) ; if ( blk == referenced ) { distance remaining = distance remaining - get distance travelled ( throttle . get is forward ( ) , throttle . get speed setting ( ) , ( ( float ) ( system . nano time ( ) - last time timer started ) / num ) ) ; block length = distance remaining ; log . debug ( str ) ; } else { referenced = blk ; } change loco speed ( t , block length , speed ) ; }	set speed of a throttle to a speeed set by a float , using the block for the length details.
public boolean remove ( object target child ) { return remove ( target child , bool ) ; }	removes a child from this beancontext.
private void notify class observers ( class descriptor class descriptor ) { for ( i observer : class observer list ) { observer . observe class ( class descriptor ) ; } }	notify all iclassobservers that we are visiting given class .
public void dup2 ( ) { mv . visit insn ( opcodes . du ) ; }	generates a dup2 instruction .
static boolean is app xml ( string mime ) { return mime != null && ( mime . equals ( str ) || mime . equals ( str ) || mime . equals ( str ) || mime . starts with ( str ) && mime . ends with ( str ) ) ; }	indicates if the mime type belongs to the application xml family .
public static native page create native page for url ( string url , native page candidate page , tab tab , tab model selector tab model selector , activity activity ) { return create native page for url ( url , candidate page , tab , tab model selector , activity , tab . is incognito ( ) ) ; }	returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise.
protected void throw parse exception ( parse exception e ) throws parse exception { if ( locator != null ) { string element location = str ; if ( cur handler != null ) { element location += str + cur handler . q name ; } string location = str + string . value of ( locator . get line number ( ) ) + str + string . value of ( locator . get column number ( ) ) + element location + str ; log utils . log exception ( logger , level . fine , location , e ) ; throw new parse exception ( location + e . get message ( ) , e ) ; } else { log utils . log exception ( logger , level . fine , null , e ) ; throw e ; } }	throws a parse exception with line / column information .
public custom editor ( ) { set layout ( new border layout ( ) ) ; add ( m , border layout . center ) ; m . add action listener ( m ) ; m . add action listener ( m ) ; m . add action listener ( m ) ; m . add action listener ( m ) ; m . add action listener ( m ) ; m . add list selection listener ( m ) ; m . add mouse listener ( m ) ; m . set tool tip text ( str ) ; m . set tool tip text ( str ) ; m . set tool tip text ( str ) ; m . set tool tip text ( str ) ; m . set tool tip text ( str ) ; }	sets up the array editor .
public memoid one ( function < ? super input , ? extends output > fn , bi predicate < input , input > equality ) { fn = objects . require non null ( fn ) ; equality = objects . require non null ( equality ) ; }	create a new memoidone , using the supplied transformation function .
public static ep single value ( class single value type ) { if ( single value type != null && single value type . is array ( ) ) { return new ep ( single value type , single value type . get component type ( ) ) ; } return new ep ( single value type ) ; }	indicate that the expression return type is a single ( non - enumerable ) value of the given type.
private static class < ? > convert field type ( string field type ) { if ( field type map . contains key ( field type ) ) { return field type map . get ( field type ) ; } return null ; }	convert field type from string to a class type .
void add xml ( int last token index , xml element , boolean add after new line ) throws exception { add xml ( last token index , element , add after new line , bool ) ; }	adds the given xmlelement after the token whoes index matches the given lasttokenindex value.
public static map < string , object > find content parents ( dispatch context dctx , map < string , ? extends object > context ) { map < string , object > results = fast map . new instance ( ) ; list < object > parent list = fast list . new instance ( ) ; results . put ( str , parent list ) ; local dispatcher dispatcher = dctx . get dispatcher ( ) ; string content id = ( string ) context . get ( str ) ; string content assoc type id = ( string ) context . get ( str ) ; string direction = ( string ) context . get ( str ) ; if ( util validate . is empty ( direction ) ) { direction = str ; } map < string , object > travers map = fast map . new instance ( ) ; travers map . put ( str , content id ) ; travers map . put ( str , direction ) ; travers map . put ( str , content assoc type id ) ; try { map < string , object > this results = dispatcher . run sync ( str , travers map ) ; string error msg = service util . get error message ( this results ) ; if ( util validate . is not empty ( error msg ) ) { debug . log error ( str + error msg , module ) ; return service util . return error ( error msg ) ; } map < string , object > node map = util generics . check map ( this results . get ( str ) ) ; walk parent tree ( node map , parent list ) ; } catch ( generic service exception e ) { return service util . return failure ( e . get message ( ) ) ; } return results ; }	this is a generic service for traversing a content tree , typical of a blog response tree.
public dictionary ( directory temp dir , string temp file name prefix , input stream affix , list < input stream > dictionaries , boolean ignore case ) throws io , parse exception { this . ignore case = ignore case ; this . needs input cleaning = ignore case ; this . needs output cleaning = bool ; flag lookup . add ( new bytes ref ( ) ) ; path aff = files . create temp file ( temp path , str , str ) ; output stream out = new buffered output stream ( files . new output stream ( aff ) ) ; input stream aff1 = null ; input stream aff2 = null ; boolean success = bool ; try { final byte [ ] buffer = new byte [ num * num ] ; int len ; while ( ( len = affix . read ( buffer ) ) > num ) { out . write ( buffer , num , len ) ; } out . close ( ) ; aff1 = new buffered input stream ( files . new input stream ( aff ) ) ; string encoding = get dictionary encoding ( aff1 ) ; charset decoder decoder = get java encoding ( encoding ) ; aff2 = new buffered input stream ( files . new input stream ( aff ) ) ; read affix file ( aff2 , decoder ) ; int sequence outputs o = int sequence outputs . get singleton ( ) ; builder < ints ref > b = new builder < > ( fst . input type . byt , o ) ; read dictionary files ( temp dir , temp file name prefix , dictionaries , decoder , b ) ; words = b . finish ( ) ; aliases = null ; morph aliases = null ; success = bool ; } finally { io . close while handling exception ( out , aff1 , aff2 ) ; if ( success ) { files . delete ( aff ) ; } else { io . delete files ignoring exceptions ( aff ) ; } } }	creates a new dictionary containing the information read from the provided inputstreams to hunspell affix and dictionary files.
public void collapse building ( building bldg ) { buildings . remove element ( bldg ) ; enumeration < coords > bldg coords = bldg . get coords ( ) ; while ( bldg coords . has more elements ( ) ) { final coords coords = bldg coords . next element ( ) ; collapse building ( coords ) ; } }	the given building has collapsed.
@ rpc method public void detach iso ( string vm id , boolean is delete file , async method callback < host . async client . detach iso call > handler ) throws rpc exception { ensure client ( ) ; iso detach iso = new iso ( vm id ) ; detach iso . set delete file ( is delete file ) ; client proxy . set timeout ( detach iso timeout ms ) ; logger . info ( str , vm id , get host ip ( ) , detach iso ) ; try { client proxy . detach iso ( detach iso , handler ) ; } catch ( t e ) { throw new rpc exception ( e . get message ( ) ) ; } }	this method performs an asynchronous thrift call to detach an iso from a vm.
private string read nfc error msg ( byte buffer reply ) throws io { int error type = reply . get int ( ) ; int error code = reply . get int ( ) ; int msg len = reply . get int ( ) ; if ( msg len == num ) { return str ; } byte buffer msg buffer = byte buffer . allocate ( msg len ) ; read fully ( msg buffer ) ; string error msg = new string ( msg buffer . array ( ) , num , msg len - num , charsets . us ascii ) ; return string . format ( str , error type , error code , error msg ) ; }	read nfc error from reply message .
private void show ( boolean show ) { if ( show ) { if ( m x != null ) { m x . cancel ( ) ; } m state = state pie ; m current item = null ; pie item root = get root ( ) ; for ( pie item open item : m open ) { if ( open item . has items ( ) ) { for ( pie item item : open item . get items ( ) ) { item . set selected ( bool ) ; } } } m label . set text ( str ) ; m open . clear ( ) ; m open . add ( root ) ; layout pie ( ) ; fade in ( ) ; } else { m state = state idle ; m tap mode = bool ; if ( m x != null ) { m x . cancel ( ) ; } if ( m label != null ) { m label . set text ( str ) ; } } set visible ( show ) ; m handler . send empty message ( show ? msg open : msg close ) ; }	guaranteed has center set.
private synchronized void persist profile and notify change ( authn provider modified provider , boolean new object ) { modified provider . set last modified ( system . current time millis ( ) ) ; if ( new object ) { db client . create object ( modified provider ) ; } else { db client . persist object ( modified provider ) ; } notify change ( ) ; }	update the timestamp and notify.
public void add undoable action ( undoable action action ) { undo stack . push ( action ) ; redo stack . remove all elements ( ) ; }	add a new undoable action .
public int array list ( int [ ] data ) { array = new int [ ( int ) ( data . length * num ) + num ] ; size = data . length ; system . arraycopy ( data , num , array , num , size ) ; }	constructs a list containing the elements of the specified array.
private void add ping time data ( long sample ) { last ping times lock . lock ( ) ; try { if ( last ping times == null ) { last ping times = new long [ ping moving average window ] ; arrays . fill ( last ping times , sample ) ; } else { system . arraycopy ( last ping times , num , last ping times , num , last ping times . length - num ) ; last ping times [ last ping times . length - num ] = sample ; } } finally { last ping times lock . unlock ( ) ; } }	adds a ping time sample to the averaging window .
public string builder encode body ( string builder buffer ) { return buffer . append ( content encoding ) ; }	canonical encoding of body of the header .
protected void tear down ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch ( exception e ) { } }	tears down the fixture , for example , close a network connection.
public string substring ( string subject , int start , int stop ) { if ( stop == - num || stop >= subject . length ( ) ) { return subject . substring ( start ) ; } return subject . substring ( start , stop ) ; }	get a substring from a string.
public void remove custom sash form listener ( i listener ) { if ( custom sash form listeners != null ) { custom sash form listeners . remove ( listener ) ; } }	removes the custom sashform listener .
public static void write string to file ( file file , string data ) throws io { write string to file ( file , data , charset . default charset ( ) , bool ) ; }	writes a string to a file creating the file if it does not exist using the default encoding for the vm .
protected void delete session variables ( string session id , string ... var names ) { if ( session id . equals ( str ) ) { return ; } key key = key factory . new key ( session id ) ; transaction transaction = datastore . new transaction ( ) ; try { entity state entity = transaction . get ( key ) ; entity . builder builder = entity . builder ( state entity ) ; string builder del names = new string builder ( ) ; for ( string var name : var names ) { del names . append ( var name + str ) ; builder = builder . remove ( var name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( null pointer exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }	delete a value stored in the project ' s datastore .
@ override public string to string ( ) { string builder sb = new string builder ( num ) ; format ( ( get year ( ) + num ) , num , sb ) ; sb . append ( str ) ; format ( ( get month ( ) + num ) , num , sb ) ; sb . append ( str ) ; format ( get date ( ) , num , sb ) ; return sb . to string ( ) ; }	produces a string representation of the date in sql format.
@ override public void close ( ) throws io { if ( m buffer count > num ) { try { m queue . write ( m buffer , num , m buffer count ) ; } catch ( interrupted exception e ) { throw new io ( str ) ; } m buffer count = num ; } m queue . close ( ) ; try { m thread . join ( ) ; } catch ( interrupted exception e ) { throw new io ( str ) ; } finally { super . close ( ) ; } check exception ( ) ; }	this also io errors that happened in the gzip thread .
public static int parse string as int ( string in ) throws index parse field exception { try { return integer . parse int ( in ) ; } catch ( number format exception e ) { throw new index parse field exception ( in , e ) ; } }	parses a string as a int .
public void write all ( result set rs , boolean include column names , boolean trim ) throws sql , io { if ( include column names ) { write column names ( rs ) ; } while ( rs . next ( ) ) { write next ( result service . get column values ( rs , trim ) ) ; } }	writes the entire resultset to a csv file.
public void test special case1 ( ) { byte a bytes [ ] = { - num , - num , - num , - num } ; byte b bytes [ ] = { num , - num , - num , - num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	test for a special case.
private static void verify device ( i d , long mac , short vlan , integer ip , long sw id , int port ) { assert not null ( d ) ; assert equals ( mac address . of ( mac ) , d . get mac ( ) ) ; if ( vlan == null ) assert array equals ( new vlan vid [ ] { vlan vid . of vlan ( - num ) } , d . get vlan id ( ) ) ; else assert array equals ( new vlan vid [ ] { vlan vid . of vlan ( vlan ) } , d . get vlan id ( ) ) ; if ( ip == null ) assert array equals ( new i [ ] { i . of ( num ) } , d . get i ( ) ) ; else assert array equals ( new i [ ] { i . of ( ip ) } , d . get i ( ) ) ; switch port expected ap = new switch port ( datapath id . of ( sw id ) , of . of ( port ) ) ; assert array equals ( new switch port [ ] { expected ap } , d . get attachment points ( ) ) ; }	verify that the given device exactly matches the given fields.
public zone rules builder add window ( zone offset standard offset , local date time until , time definition until definition ) { objects . require non null ( standard offset , str ) ; objects . require non null ( until , str ) ; objects . require non null ( until definition , str ) ; tz window = new tz ( standard offset , until , until definition ) ; if ( window list . size ( ) > num ) { tz previous = window list . get ( window list . size ( ) - num ) ; window . validate window order ( previous ) ; } window list . add ( window ) ; return this ; }	adds a window to the builder that can be used to filter a set of rules.
public hashtable < i , list < i > > intersections ( iterator < i > it ) { collection < i > c = new array list < i > ( ) ; while ( it . has next ( ) ) { c . add ( it . next ( ) ) ; } return intersections ( c . to array ( new i [ ] { } ) ) ; }	compute the intersection of all segments when given an iterator of segments .
public boolean is ttf ( ) { return ttf ; }	indicates if this is a ttf native font that can be derived and manipulated . this is true for a font loaded from file ( ttf ) or using the native : font name.
private void register providers ( ) { final dev machine dev machine = app context . get dev machine ( ) ; if ( dev machine == null ) { return ; } final set < macro > providers = get macros ( dev machine ) ; check not null ( providers ) ; if ( providers . is empty ( ) ) { return ; } provider registry . register ( providers ) ; }	register macro providers which returns the implementation .
public long map ( int initial capacity , float load factor ) { if ( initial capacity < num ) throw new illegal argument exception ( str + initial capacity ) ; if ( capacity > num << num ) throw new illegal argument exception ( str + initial capacity ) ; capacity = math utils . next power of two ( initial capacity ) ; if ( load factor <= num ) throw new illegal argument exception ( str + load factor ) ; this . load factor = load factor ; threshold = ( int ) ( capacity * load factor ) ; mask = capacity - num ; hash shift = num - integer . number of trailing zeros ( capacity ) ; stash capacity = math . max ( num , ( int ) math . ceil ( math . log ( capacity ) ) + num ) ; push iterations = math . max ( math . min ( capacity , num ) , ( int ) math . sqrt ( capacity ) / num ) ; key table = new long [ capacity + stash capacity ] ; value table = ( v [ ] ) new object [ key table . length ] ; }	creates a new map with the specified initial capacity and load factor.
protected as ( as obj ) { set . add element ( obj ) ; }	create a sequence containing one object.
protected void populate stream blob ( int test id , byte [ ] base content , int required size ) throws sql { final byte [ ] test bytes = generate blob content ( base content , required size ) ; try ( fb database db = create database connection ( ) ) { listener = new simple statement listener ( ) ; transaction = get transaction ( db ) ; try { statement = db . create statement ( transaction ) ; statement . add statement listener ( listener ) ; final blob parameter buffer blob parameter buffer = db . create blob parameter buffer ( ) ; blob parameter buffer . add argument ( blob parameter buffer . type , blob parameter buffer . type stream ) ; final fb blob blob = db . create blob for output ( transaction , blob parameter buffer ) ; blob . open ( ) ; int bytes written = num ; while ( bytes written < test bytes . length ) { byte [ ] buffer = new byte [ math . min ( blob . get maximum segment size ( ) , test bytes . length - bytes written ) ] ; system . arraycopy ( test bytes , bytes written , buffer , num , buffer . length ) ; blob . put segment ( buffer ) ; bytes written += buffer . length ; } blob . close ( ) ; statement . prepare ( insert blob table ) ; final datatype coder datatype coder = db . get datatype coder ( ) ; field value param1 = new field value ( datatype coder . encode int ( test id ) ) ; field value param2 = new field value ( datatype coder . encode long ( blob . get blob id ( ) ) ) ; statement . execute ( row value . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } } }	populates a stream blob for testing .
private static long sign from bit anti cyclic ( final double value ) { return double . double to raw long bits ( value ) > > num | num ; }	redefined here , to avoid cyclic dependency with ( strict ) fastmath .
public void add near key ( key cache object key , grid cache shared context ctx ) throws ignite checked exception { near keys . add ( key ) ; }	adds a near key .
private void analyze class fields ( string class name , int action ) { try { class < ? > dynamic class = class . for name ( class name ) ; field [ ] fields = dynamic class . get declared fields ( ) ; for ( field field : fields ) { if ( is private and non primitive ( field ) ) { one to any conditions ( class name , field , action ) ; many to any conditions ( class name , field , action ) ; } } } catch ( class not found exception ex ) { ex . print stack trace ( ) ; throw new database generate exception ( database generate exception . class not found + class name ) ; } }	introspection of the passed in class.
protected boolean is level enabled ( int log level ) { return ( log level >= current log level ) ; }	is the given log level currently enabled ?.
public static void load all ( final j parent , final i debugger , final i offset , final int size ) { check arguments ( parent , debugger , offset ) ; final c waiter = new c ( debugger , offset , size ) ; c . show endless ( parent , str + str , waiter ) ; if ( waiter . get exception ( ) != null ) { c . log exception ( waiter . get exception ( ) ) ; final string inner message = str + str ; final string inner description = c . create description ( string . format ( str , offset . to hex string ( ) ) , new string [ ] { str } , new string [ ] { str } ) ; navi error dialog . show ( parent , inner message , inner description , waiter . get exception ( ) ) ; } }	loads all data of a memory section .
public void test set attribute node n ( ) throws throwable { document doc ; element element ; attr attribute1 ; attr attribute2 ; attr attr node ; string attr name ; string attr ns ; named node map attributes ; int length ; doc = ( document ) load ( str , builder ) ; element = doc . create element ns ( str , str ) ; attribute1 = doc . create attribute ns ( str , str ) ; attribute2 = doc . create attribute ns ( str , str ) ; attribute2 . set value ( str ) ; element . set attribute node ns ( attribute1 ) ; element . set attribute node ns ( attribute2 ) ; attr node = element . get attribute node ns ( str , str ) ; attr name = attr node . get node name ( ) ; attr ns = attr node . get namespace uri ( ) ; assert equals ( str , str , attr name ) ; assert equals ( str , str , attr ns ) ; attributes = element . get attributes ( ) ; length = ( int ) attributes . get length ( ) ; assert equals ( str , num , length ) ; }	runs the test case .
public boolean is critical ( ) { return bool ; }	is this a critical command that can only be executed when no other command is running ?.
public static string find edit table ( string tables ) { if ( ! string utils . is empty ( tables ) ) { int spacepos = tables . index of ( str ) ; int commapos = tables . index of ( str ) ; if ( spacepos > num && ( spacepos < commapos || commapos < num ) ) { return tables . substring ( num , spacepos ) ; } else if ( commapos > num && ( commapos < spacepos || spacepos < num ) ) { return tables . substring ( num , commapos ) ; } return tables ; } else { throw new illegal state exception ( str ) ; } }	finds the name of the first table , which is editable .
public void write operations car file ( ) { make backup file ( default operations filename ( ) ) ; try { if ( ! check file ( default operations filename ( ) ) ) { java . io . file file = new java . io . file ( default operations filename ( ) ) ; java . io . file parent dir = file . get parent file ( ) ; if ( ! parent dir . exists ( ) ) { if ( ! parent dir . mkdir ( ) ) { log . error ( str ) ; } } if ( file . create new file ( ) ) { log . debug ( str ) ; } } write file ( default operations filename ( ) ) ; } catch ( exception e ) { log . error ( str + e ) ; } }	store the all of the operation car objects in the default place , including making a backup if needed.
private boolean has new followers ( list < follower > followers ) { return ! followers . is empty ( ) && followers . get ( num ) . new follower ; }	checks if this has new followers.
private void on track point element start ( attributes attributes ) throws sax { string latitude = attributes . get value ( att lat ) ; string longitude = attributes . get value ( att lon ) ; if ( latitude == null || longitude == null ) { throw new sax ( create error message ( str ) ) ; } try { latitude value = double . parse double ( latitude ) ; longitude value = double . parse double ( longitude ) ; } catch ( number format exception e ) { throw new sax ( create error message ( str + latitude + str + longitude ) , e ) ; } }	on track point element start .
protected final void fire property change ( property change event evt ) { pcs . fire property change ( evt ) ; }	fire an existing propertychangeevent to any registered listeners.
static int check desc ( final string desc , final int start , final boolean can be void ) { if ( desc == null || start >= desc . length ( ) ) { throw new illegal argument exception ( str ) ; } int index ; switch ( desc . char at ( start ) ) { case str : if ( can be void ) { return start + num ; } else { throw new illegal argument exception ( str + desc ) ; } case str : case str : case str : case str : case str : case str : case str : case str : return start + num ; case str : index = start + num ; while ( index < desc . length ( ) && desc . char at ( index ) == str ) { ++ index ; } if ( index < desc . length ( ) ) { return check desc ( desc , index , bool ) ; } else { throw new illegal argument exception ( str + desc ) ; } case str : index = desc . index of ( str , start ) ; if ( index == - num || index - start < num ) { throw new illegal argument exception ( str + desc ) ; } try { check internal name ( desc , start + num , index , null ) ; } catch ( illegal argument exception unused ) { throw new illegal argument exception ( str + desc ) ; } return index + num ; default : throw new illegal argument exception ( str + desc ) ; } }	checks that a the given substring is a valid type descriptor .
public static void sort fields ( field binding [ ] sorted fields , int left , int right ) { arrays . sort ( sorted fields , left , right , field comparator ) ; }	sort the field array using a quicksort.
private void draw background ( final graphics g ) { g . set color ( m bg color offset ) ; g . fill rect ( - m first column * m char width , num , m offset view width , get height ( ) ) ; }	draws the background of the view .
public void add unique attribute ( final string element name , final string attr name ) { if ( ( element name != null ) && ( attr name != null ) ) { unique element attr map . put ( element name , attr name ) ; } }	add unique attribute to the element which will force elements to be identical .
private static delete vm response check delete vm response ( delete vm response delete vm response ) throws rpc exception { logger . info ( str , delete vm response ) ; switch ( delete vm response . get result ( ) ) { case ok : break ; case system error : throw new system error exception ( delete vm response . get error ( ) ) ; case vm not found : throw new vm not found exception ( delete vm response . get error ( ) ) ; case vm not powered off : throw new vm not powered off exception ( delete vm response . get error ( ) ) ; default : throw new rpc exception ( string . format ( str , delete vm response . get result ( ) ) ) ; } return delete vm response ; }	this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { child . delete data ( num , num ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
public void limit trans and scale ( matrix matrix , f content ) { float [ ] vals = new float [ num ] ; matrix . get values ( vals ) ; float cur trans x = vals [ matrix . mtrans x ] ; float cur scale x = vals [ matrix . mscale x ] ; float cur trans y = vals [ matrix . mtrans y ] ; float cur scale y = vals [ matrix . mscale y ] ; m scale x = math . max ( m min scale x , cur scale x ) ; m scale y = math . max ( m min scale y , cur scale y ) ; float width = num ; float height = num ; if ( content != null ) { width = content . width ( ) ; height = content . height ( ) ; } float max trans x = - width * ( m scale x - num ) ; float new trans x = math . min ( math . max ( cur trans x , max trans x - m trans offset x ) , m trans offset x ) ; float max trans y = height * ( m scale y - num ) ; float new trans y = math . max ( math . min ( cur trans y , max trans y + m trans offset y ) , - m trans offset y ) ; vals [ matrix . mtrans x ] = new trans x ; vals [ matrix . mscale x ] = m scale x ; vals [ matrix . mtrans y ] = new trans y ; vals [ matrix . mscale y ] = m scale y ; matrix . set values ( vals ) ; }	limits the maximum scale and x translation of the given matrix.
public blaze value factory value factory ( ) { return vf ; }	return the factory used to round - trip between tinkerpop values and rdf values .
public stateful refresh token ( json value token ) throws invalid grant exception { super ( token ) ; if ( ! oauth refresh token . equals ( get token name ( ) ) ) { throw new invalid grant exception ( str + get token id ( ) ) ; } }	constructs a new refreshtoken backed with the data in the specified jsonvalue .
public void put style ( string style id , style selector style selector ) { try { int id = integer . parse int ( style id ) ; m max style id = math . max ( m max style id , id ) ; } catch ( number format exception e ) { } m styles . put ( style id , style selector ) ; }	put the styleselector ( style or stylemap ) in the list of shared styles , associated to its styleid.
private static string extract client name ( string client id , string host ) { string host excluded id = str ; if ( ( is i ( host ) || is i ( host ) ) && client id . starts with ( host ) ) { host excluded id = client id . substring ( host . length ( ) ) ; } else { int first dot index = host . index of ( str ) ; if ( first dot index != - num ) { string host short name = host . substring ( num , first dot index ) ; host excluded id = client id . substring ( host short name . length ( ) ) ; } } string vm pid = str ; string regex = str ; string name = not available ; string temp = host excluded id ; int open index = temp . index of ( str ) ; if ( open index != - num ) { regex = vm pid + regex ; } if ( temp . matches ( regex ) ) { string [ ] splitted = temp . split ( str ) ; name = splitted [ splitted . length - num ] ; } return name ; }	excludes the host name from the client id and returns the string.
public static < t > fast future < t > from completable future ( final completable future < t > cf ) { final fast future < t > f = new fast future < > ( ) ; cf . then accept ( null ) ; cf . exceptionally ( null ) ; return f ; }	internal conversion method to convert completablefutures to fastfuture .
public static boolean is place action ( inventory action action ) { switch ( action ) { case swap with cursor : case place one : case place all : case place some : return bool ; } return bool ; }	check if a given inventoryaction involves placing items into the slot .
private list < view > add view ( view view , list < view > cache ) { if ( cache == null ) { cache = new linked list < view > ( ) ; } cache . add ( view ) ; return cache ; }	adds view to specified cache.
public static byte [ ] read input stream ( input stream i ) throws io { byte array output stream b = new byte array output stream ( ) ; copy ( i , b ) ; return b . to byte array ( ) ; }	converts a small input stream to a byte array.
public void play media ( boolean show player window ) { string filename = stop and prepare filename ( ) ; if ( filename . length ( ) > num ) { m mplayer mediator = m . instance ( ) ; if ( mplayer mediator != null ) { mplayer mediator . show player window ( show player window ) ; } mplayer . open ( filename , get adjusted volume ( ) ) ; } notify state ( get state ( ) ) ; }	force showing or not the media player window.
public static string to ut ( string s ) { return new string ( s . get bytes ( ) , charset . for name ( panbox constants . standard charset ) ) ; }	string conversion into standard charset.
public static int encode cache flags ( collection < grid client cache flag > flag set ) { int bits = num ; if ( flag set . contains ( grid client cache flag . skip store ) ) bits |= num ; return bits ; }	encodes cache flags to bit map .
public void add ( data source source , boolean visible ) { add ( data . size ( ) , source , visible ) ; }	adds a new data series to the plot .
@ override public void add value ( double value , double weight ) { m += value * weight ; m += value * value * weight ; m += weight ; if ( m tm . get ( value ) == null ) { m tm . put ( value , weight ) ; } else { m tm . put ( value , m tm . get ( value ) + weight ) ; } }	adds a value to the density estimator .
private j build row ( final string string , final j check box ) { final j panel = new j ( new border layout ( ) ) ; panel . add ( new j ( string ) , border layout . west ) ; panel . add ( check box , border layout . east ) ; check box . add item listener ( m check box listener ) ; return panel ; }	builds a checkbox row .
private static synchronized string format and parse ( simple date format format date , simple date format parse date , string text ) { try { date date = parse date . parse ( text ) ; string result = format date . format ( date ) ; return result ; } catch ( parse exception e ) { logger . warning ( str + text ) ; } return str ; }	synchronized because simpledatformat aren ' t thread safe.
public static boolean is child group ( string group ) { return group . index of ( group delimiter ) != - num ; }	indicates if a group is a child group , a non - top - level data group in a set of nested data groups ( e.
private void throw array index out of bounds exception ( int item index ) { throw new array index out of bounds exception ( str + str + space items . size ( ) + str + item index ) ; }	throw array index out of bounds exception.
private locus info create next uncovered locus info ( final locus stop before locus ) { while ( last reference sequence <= stop before locus . get sequence index ( ) && last reference sequence <= reference sequence mask . get max sequence index ( ) ) { if ( last reference sequence == stop before locus . get sequence index ( ) && last position + num >= stop before locus . get position ( ) ) { return null ; } final int nextbit = reference sequence mask . next position ( last reference sequence , last position ) ; if ( nextbit == - num ) { if ( last reference sequence == stop before locus . get sequence index ( ) ) { last position = stop before locus . get position ( ) ; return null ; } last reference sequence ++ ; last position = num ; } else if ( last reference sequence < stop before locus . get sequence index ( ) || nextbit < stop before locus . get position ( ) ) { last position = nextbit ; return new locus info ( get reference sequence ( last reference sequence ) , last position ) ; } else if ( nextbit >= stop before locus . get position ( ) ) { return null ; } } return null ; }	create the next relevant zero - coverage locusinfo.
public void global config changed ( string service name , string version , string group name , string service component , int change type ) { }	this method will be invoked when a service ' s global configuation data has been changed.
public static void launch email intent ( final activity activity , string addr , string text ) { log . i ( log tag , str + activity . get local class name ( ) ) ; intent email intent = new intent ( intent . action send ) ; email intent . put extra ( intent . extra email , new string [ ] { addr } ) ; email intent . set type ( str ) ; package manager emailpackage manager = activity . get package manager ( ) ; list < resolve info > emailresolve infos = emailpackage manager . query intent activities ( email intent , num ) ; if ( emailresolve infos . size ( ) > num ) { activity . start activity ( email intent ) ; } }	launch an email intent if the device is capable .
public int count ( ) { return n ; }	returns the number of data values .
public void add ( int position , t item ) { m data . add ( position , item ) ; notify item inserted ( position ) ; }	insert a item associated with the specified position of adapter.
public void add translator ( class pool cp , translator t ) throws not found exception , cannot compile exception { source = cp ; translator = t ; t . start ( cp ) ; }	adds a translator , which is called whenever a class is loaded .
public void write le ( string s ) throws io { int length = s . length ( ) ; for ( int i = num ; i < length ; i ++ ) { int c = s . char at ( i ) ; out . write ( c & num ) ; out . write ( ( c > > > num ) & num ) ; } written += length * num ; }	writes a string in little endian.
public static string read line ( ) { string line ; try { line = scanner . next line ( ) ; } catch ( no such element exception e ) { line = null ; } return line ; }	reads and returns the next line , excluding the line separator if present .
@ deprecated public boolean is valid ( string regex ) { if ( regex == null ) { return bool ; } pattern pattern = pattern . compile ( regex ) ; matcher matcher = pattern . matcher ( get text ( ) ) ; return matcher . matches ( ) ; }	if the main text matches the regex.
public void write to file ( string filename ) { grid utils . write spatial grid table ( this , filename ) ; }	just for debugging convenience.
public void add footer view ( view v , object data , boolean is selectable ) { fixed view info info = new fixed view info ( ) ; info . view = v ; info . data = data ; info . is selectable = is selectable ; m footer view infos . add ( info ) ; if ( m adapter != null && m data set observer != null ) { m data set observer . on changed ( ) ; } }	add a fixed view to appear at the bottom of the list.
public void add close hook ( close hook hook ) { if ( close hooks == null ) { close hooks = new array list < > ( ) ; } close hooks . add ( hook ) ; }	add a close callback hook.
public void rejected execution ( runnable r , thread pool executor e ) { if ( ! e . is shutdown ( ) ) { r . run ( ) ; } }	executes task r in the caller ' s thread , unless the executor has been shut down , in which case the task is discarded .
private void update range ( double x , double y ) { m min x = math . min ( m min x , x ) ; m max x = math . max ( m max x , x ) ; m min y = math . min ( m min y , y ) ; m max y = math . max ( m max y , y ) ; }	updates the range on both axes .
static boolean check standard upcean ( char sequence s ) throws format exception { int length = s . length ( ) ; if ( length == num ) { return bool ; } int sum = num ; for ( int i = length - num ; i >= num ; i -= num ) { int digit = ( int ) s . char at ( i ) - ( int ) str ; if ( digit < num || digit > num ) { throw format exception . get format instance ( ) ; } sum += digit ; } sum *= num ; for ( int i = length - num ; i >= num ; i -= num ) { int digit = ( int ) s . char at ( i ) - ( int ) str ; if ( digit < num || digit > num ) { throw format exception . get format instance ( ) ; } sum += digit ; } return sum % num == num ; }	computes the upc / ean checksum on a string of digits , and reports whether the checksum is correct or not .
public void read config ( string filename ) throws file not found exception { if ( filename == null || filename . equals ( str ) ) return ; read config ( new file reader ( filename ) ) ; }	read the specified file and parse the configuration .
private void apply trading bonus ( player player ) { player . increment tradescore ( ) ; }	rewards player for a successfull trade.
public static string slurp url ( url u ) { try { return slurp url ( u ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }	returns all the text at the given url .
private static void create combined trace ( final trace list new trace , final list < trace list > traces , final set < breakpoint address > addresses ) { final set < breakpoint address > visited addresses = new linked hash set < breakpoint address > ( ) ; for ( final trace list trace : traces ) { for ( final i event : trace ) { final breakpoint address address = event . get offset ( ) ; if ( ! addresses . contains ( address ) ) { continue ; } if ( visited addresses . contains ( address ) ) { continue ; } visited addresses . add ( address ) ; new trace . add event ( event ) ; } } }	fills a combined trace from the events of multiple input traces .
public void interrupt all ( ) { synchronized ( known actor tasks ) { for ( future < void > ft : known actor tasks ) { ft . cancel ( bool ) ; } thread guard . interrupt all ( ) ; } }	ensure that any guarded regions are interrupted .
@ suppress warnings ( str ) public void register default device types ( ) { final hash map < string , string > devices list = default platform . get device service map ( ) ; for ( hash map . entry < string , string > entry : devices list . entry set ( ) ) { string key = entry . get key ( ) ; string value = entry . get value ( ) ; try { register device service ( ( class < device service > ) class . for name ( key ) , ( class < discovery provider > ) class . for name ( value ) ) ; } catch ( class not found exception e ) { e . print stack trace ( ) ; } } }	registers a commonly - used set of deviceservices with discoverymanager.
private static void remove dependency subsets ( string swc location , map < string , set < string > > dependency map , swc dependency info impl dep info ) { set < string > remove set = new hash set < string > ( ) ; swc external script info external info = dep info . get swc external script info ( swc location ) ; map < string , set < string > > externals by swc = new hash map < string , set < string > > ( ) ; for ( string swc depend location : dependency map . get ( swc location ) ) { for ( string swc depend location2 : dependency map . get ( swc location ) ) { if ( swc depend location . equals ( swc depend location2 ) ) continue ; set < string > external scripts = externals by swc . get ( swc depend location ) ; set < string > external scripts2 = externals by swc . get ( swc depend location2 ) ; if ( external scripts == null ) { external scripts = external info . get external scripts ( swc depend location ) ; externals by swc . put ( swc depend location , external scripts ) ; } if ( external scripts2 == null ) { external scripts2 = external info . get external scripts ( swc depend location2 ) ; externals by swc . put ( swc depend location2 , external scripts2 ) ; } if ( external scripts2 . size ( ) > external scripts . size ( ) && external scripts2 . contains all ( external scripts ) ) { remove set . add ( swc depend location ) ; break ; } } } set < string > dependency set = dependency map . get ( swc location ) ; dependency set . remove all ( remove set ) ; }	look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .
private void draw ticks ( canvas canvas , double min , double max , double min angle , double max angle , int center x , int center y , double long radius , double short radius , double ticks , paint paint , boolean labels ) { for ( double i = min ; i <= max ; i += ticks ) { double angle = get angle for value ( i , min angle , max angle , min , max ) ; double sin value = math . sin ( angle ) ; double cos value = math . cos ( angle ) ; int x1 = math . round ( center x + ( float ) ( short radius * sin value ) ) ; int y1 = math . round ( center y + ( float ) ( short radius * cos value ) ) ; int x2 = math . round ( center x + ( float ) ( long radius * sin value ) ) ; int y2 = math . round ( center y + ( float ) ( long radius * cos value ) ) ; canvas . draw line ( x1 , y1 , x2 , y2 , paint ) ; if ( labels ) { paint . set text align ( align . left ) ; if ( x1 <= x2 ) { paint . set text align ( align . right ) ; } string text = i + str ; if ( math . round ( i ) == ( long ) i ) { text = ( long ) i + str ; } canvas . draw text ( text , x1 , y1 , paint ) ; } } }	draws the chart tick lines .
public static < t , k , l extends list < t > > bi function < partition < t , k , l > , t , boolean > always insert ( ) { return null ; }	returns an insertion policy that indicates the tuple is to be inserted into the partition .
public void test find spring open ldap ( ) { ldap proxy proxy = get ldap open ldap ( ) ; list result = null ; try { result = proxy . find ( get ldap search vo ( str , ldap constants . no search limit , null , null , null , ldap scope constants . scope subtree ) ) ; } catch ( exception e ) { } assert not null ( result ) ; assert equals ( num , result . size ( ) ) ; }	test de busqueda open ldap.
public void test constructor string radix8 ( ) { string value = str ; int radix = num ; byte r bytes [ ] = { num , - num , - num , - num , - num , num , num } ; big integer a number = new big integer ( value , radix ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a string value and radix 8 .
private static boolean in encoding ( char ch , string encoding ) { boolean is in encoding ; try { char c array [ ] = new char [ num ] ; c array [ num ] = ch ; string s = new string ( c array ) ; byte [ ] b array = s . get bytes ( encoding ) ; is in encoding = in encoding ( ch , b array ) ; } catch ( exception e ) { is in encoding = bool ; if ( encoding == null ) is in encoding = bool ; } return is in encoding ; }	this is heart of the code that determines if a given character is in the given encoding.
public void delete ( sso token , string dn ) throws sms , sso { for ( string entry : sub entries ( token , dn , str , num , bool , bool ) ) { debug . message ( str , entry ) ; delete ( token , get naming attribute ( ) + str + entry + str + dn ) ; } for ( string sub org : search sub org names ( token , dn , str , num , bool , bool , bool ) ) { debug . message ( str , sub org ) ; delete ( token , sub org ) ; } delete ( token . get principal ( ) , dn ) ; object changed ( dn , delete ) ; }	delete the entry in the directory . this will delete sub - entries also !.
private void remove highlights ( ) { if ( text area != null ) { r h = ( r ) text area . get highlighter ( ) ; for ( int i = num ; i < tags . size ( ) ; i ++ ) { h . remove mark occurrences highlight ( tags . get ( i ) ) ; } } tags . clear ( ) ; }	removes all highlights added to the text area by this listener .
private static < t extends abstract block base < t > > void enqueue successors ( t block , priority queue < t > worklist , bit set visited blocks ) { for ( t successor : block . get successors ( ) ) { if ( ! visited blocks . get ( successor . get id ( ) ) ) { visited blocks . set ( successor . get id ( ) ) ; worklist . add ( successor ) ; } } }	add successor blocks into the given work list if they are not already marked as visited .
public void add role ( string role ) { if ( role != null ) { roles . add ( role ) ; } }	add a role to this user .
public c ( final c modules table model ) { super ( new border layout ( ) ) ; final j check box = new j ( str ) ; check box . add item listener ( new internal checkbox listener ( ) ) ; add ( check box ) ; m modules table model = modules table model ; }	creates the checkbox panel to control if full paths should be shown in the modules table .
public q ( ) { this ( gmt time zone ) ; }	creates the date for gmt .
protected void response sent ( stream response message response message ) { if ( sync protocol != null ) sync protocol . response sent ( response message ) ; }	must be called by a subclass after the response has been successfully sent to the client .
protected tuple < blob store index shard snapshots , integer > build blob store index shard snapshots ( map < string , blob meta data > blobs ) { int latest = - num ; for ( string name : blobs . key set ( ) ) { if ( name . starts with ( snapshot index prefix ) ) { try { int gen = integer . parse int ( name . substring ( snapshot index prefix . length ( ) ) ) ; if ( gen > latest ) { latest = gen ; } } catch ( number format exception ex ) { logger . warn ( str , name ) ; } } } if ( latest >= num ) { try { return new tuple < > ( index shard snapshots format . read ( blob container , integer . to string ( latest ) ) , latest ) ; } catch ( io e ) { logger . warn ( str , e , snapshot index prefix + latest ) ; } } list < snapshot files > snapshots = new array list < > ( ) ; for ( string name : blobs . key set ( ) ) { try { blob store index shard snapshot snapshot = null ; if ( name . starts with ( snapshot prefix ) ) { snapshot = index shard snapshot format . read blob ( blob container , name ) ; } else if ( name . starts with ( legacy snapshot prefix ) ) { snapshot = index shard snapshot legacy format . read blob ( blob container , name ) ; } if ( snapshot != null ) { snapshots . add ( new snapshot files ( snapshot . snapshot ( ) , snapshot . index files ( ) ) ) ; } } catch ( io e ) { logger . warn ( str , e , name ) ; } } return new tuple < > ( new blob store index shard snapshots ( snapshots ) , - num ) ; }	loads all available snapshots in the repository.
public forum post config create reply ( forum post config config ) { config . add credentials ( this ) ; string xml = post ( this . url + str , config . to xml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { forum post config reply = new forum post config ( ) ; reply . parse xml ( root ) ; return reply ; } catch ( exception exception ) { this . exception = sdk . parse failure ( exception ) ; throw this . exception ; } }	create a reply to a forum post.
public boolean is armed ( ) { return other . is armed ( ) ; }	all these methods simply delegate to the " other " model that is being decorated .
public static attrib key for html attrib ( el key el , string local name ) { return new attrib key ( el , html ns , local name ) ; }	looks up an attribute key by element and local name .
sparse array ( class < l > linear array type , int [ ] row indices , int [ ] col indices , l real values , l imag values , int num rows , int num cols ) { validate user supplied parameters ( linear array type , row indices , col indices , real values , imag values ) ; base component type = linear array type . get component type ( ) ; output array type = ( class < l [ ] > ) array utils . get array class ( base component type , num ) ; map < sparse key , sparse value > sparse map = create sparse map ( linear array type , row indices , col indices , real values , imag values , num rows , num cols ) ; num rows = num rows ; num cols = num cols ; array list < sparse key > keys = new array list < sparse key > ( sparse map . key set ( ) ) ; collections . sort ( keys ) ; row indices = new int [ keys . size ( ) ] ; col indices = new int [ keys . size ( ) ] ; linear indices = new int [ keys . size ( ) ] ; real values = linear array type . cast ( array . new instance ( base component type , keys . size ( ) ) ) ; imag values = imag values == null ? null : linear array type . cast ( array . new instance ( base component type , keys . size ( ) ) ) ; for ( int i = num ; i < keys . size ( ) ; i ++ ) { sparse key key = keys . get ( i ) ; row indices [ i ] = key . row ; col indices [ i ] = key . col ; linear indices [ i ] = key . linear index ; sparse value value = sparse map . get ( key ) ; set sparse value ( value , real values , imag values , i ) ; } }	data provided by a user ; this data needs to be validated and processed .
public static tuple max ( tuple set tuples , string field , comparator cmp ) { if ( tuples instanceof table ) { table table = ( table ) tuples ; column metadata md = table . get metadata ( field ) ; return table . get tuple ( md . get maximum row ( ) ) ; } else { return max ( tuples . tuples ( ) , field , cmp ) ; } }	get the tuple with the maximum data field value .
protected void update radio links ( ) { m cv . set enabled ( bool ) ; m cv . set enabled ( m cv . is selected ( ) ) ; m cv . set enabled ( m cv . is selected ( ) ) ; m . set enabled ( m cv . is selected ( ) ) ; m . set enabled ( m cv . is selected ( ) ) ; if ( m . get value ( ) instanceof attribute transformer ) { m cv . set selected ( bool ) ; m cv . set enabled ( bool ) ; m cv . set enabled ( bool ) ; m cv . set enabled ( bool ) ; m . set enabled ( bool ) ; m . set enabled ( bool ) ; m . set selected ( bool ) ; } }	updates the enabled status of the input fields and labels .
private string id string ( int id1 , int id2 ) { return str + integer . to hex string ( id2 & num ) + str + integer . to hex string ( id1 & num ) + str + ( ( id2 & num ) * num + ( id1 & num ) ) + str ; }	convert throttle id to a human friendly format .
public etag cache reset stats ( ) { hits . set ( num ) ; misses . set ( num ) ; return this ; }	reset stats tracked for cache hits and misses.
public void test other to string default ( ) { number converter converter = make converter ( ) ; assert equals ( str , str , converter . convert ( string . class , new string buffer ( str ) ) ) ; }	convert other - - > string ( default conversion ).
private void remove item at int ( int index , boolean update children on menu views ) { if ( ( index < num ) || ( index >= m items . size ( ) ) ) return ; m items . remove ( index ) ; if ( update children on menu views ) on items changed ( bool ) ; }	remove the item at the given index and optionally forces menu views to update .
public void test shift right3 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , num , num , - num , - num , - num , num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift right ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	shiftright ( int n ) , 0 < n < 32.
private void show filter dialog ( filter filter ) { int sort order = m adapter . get count ( ) - num ; if ( filter == null ) { edit filter activity . create new filter ( get activity ( ) , sort order ) ; } else { edit filter activity . edit filter ( get activity ( ) , filter , sort order ) ; } }	shows the filter dialog.
public static int num pixels between ( int x1 , int y1 , int x2 , int y2 ) { return ( int ) math . sqrt ( math . pow ( ( double ) ( x1 - x2 ) , num ) + math . pow ( ( double ) ( y1 - y2 ) , num ) ) ; }	little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .
static boolean allows popup ( form object form object ) { switch ( form object . get parameter constant ( pdf dictionary . subtype ) ) { case pdf dictionary . text : case pdf dictionary . square : case pdf dictionary . highlight : case pdf dictionary . underline : case pdf dictionary . strick out : case pdf dictionary . stamp : return bool ; default : return bool ; } }	utility method to check if formobject should have a popup.
public static local git repo from current dir ( string remote url ) throws validation exception { git git ; file git dir = new file ( str ) ; try { git = git . open ( git dir ) ; } catch ( repository not found exception rnfe ) { string full path of current dir = path of ( git dir ) ; file git root = get git root if it exists in one of the parent directories ( new file ( full path of current dir ) ) ; string summary ; list < string > messages = new array list < string > ( ) ; if ( git root == null ) { summary = str ; messages . add ( summary ) ; messages . add ( full path of current dir + str ) ; } else { summary = str ; messages . add ( summary ) ; messages . add ( full path of current dir + str ) ; messages . add ( str + path of ( git root ) ) ; } throw new validation exception ( summary , messages ) ; } catch ( exception e ) { throw new validation exception ( str + path of ( git dir ) + str , arrays . as list ( str , e . to string ( ) ) ) ; } return new local git repo ( git , remote url ) ; }	uses the current working dir to open the git repository .
public static vector2 min ( vector2 o1 , vector2 o2 ) { return new vector2 ( math . min ( o1 . x , o2 . x ) , math . min ( o1 . z , o2 . z ) ) ; }	returns a vector2 containing the smallest x and y values .
public void add test call ( generic accessible object < ? > call ) throws illegal argument exception { inputs . check null ( call ) ; test methods . add ( call ) ; }	add a test call.
public void serialize ( k serializer ) throws io { m device info . serialize ( serializer ) ; serialize host info ( serializer ) ; serialize test summary ( serializer ) ; monkey tag . serialize ( serializer ) ; list < test package result > pkgs = new array list < test package result > ( m package map . values ( ) ) ; collections . sort ( pkgs , new pkg comparator ( ) ) ; for ( test package result r : pkgs ) { r . serialize ( serializer ) ; } }	serialize the test results to xml .
private void verify block mirror migration ( ) throws exception { log . info ( str ) ; iterator < block mirror > block mirror itr = db client . query iterative objects ( block mirror . class , block mirror ur ) ; list < block object > block objects = new array list < block object > ( ) ; while ( block mirror itr . has next ( ) ) { block objects . add ( block mirror itr . next ( ) ) ; } verify block objects ( block objects ) ; }	verify the blockmirror objects have been migrated correctly .
public log formatter ( logger log ) { if ( log == null ) log = logger . get logger ( logger . global logger name ) ; level lvl = null ; while ( log != null ) { lvl = log . get level ( ) ; if ( lvl != null ) break ; log = log . get parent ( ) ; } ; if ( lvl == null ) lvl = level . warning ; this . level = lvl ; }	create a log formatter around a given logger.
public synchronized void remove text listener ( text listener cl ) { m text listeners . remove ( cl ) ; }	remove a text listener.
private element create idp ( boolean export private data ) throws exception { element ent ele = doc . create element ns ( null , saml . entdescriptor ) ; string id = idm client . get entity id ( tenant name ) ; string alias = idm client . get local idp ( tenant name ) ; if ( id == null ) { id = tenant name ; } ent ele . set attribute ( saml . entid , id ) ; element idp sso = create idpsso ( export private data ) ; ent ele . append child ( idp sso ) ; if ( export private data ) { if ( alias == null || alias . is empty ( ) ) { alias = id ; } element org ele = create organization ( tenant name , tenant name , alias , saml . english ) ; ent ele . append child ( org ele ) ; } return ent ele ; }	create extension element of entitydescriptor in dom .
public void clear ( ) { info queue . clear ( ) ; while ( ! data queue . is empty ( ) ) { allocator . release ( data queue . remove ( ) ) ; } total bytes dropped = num ; total bytes written = num ; last allocation = null ; last allocation offset = allocation length ; }	clears the buffer , returning all allocations to the allocator .
public void apply camera ( g gl ) { gl . gl matrix mode ( g . gl projection ) ; gl . gl load identity ( ) ; glu . glu perspective ( num , width / ( float ) height , num , num ) ; eye [ num ] = ( float ) math . sin ( theta ) * num ; eye [ num ] = num ; eye [ num ] = ( float ) math . cos ( theta ) * num ; glu . glu look at ( eye [ num ] , eye [ num ] , eye [ num ] , num , num , num , num , num , num ) ; gl . gl matrix mode ( g . gl modelview ) ; gl . gl load identity ( ) ; gl . gl viewport ( num , num , width , height ) ; }	apply the camera settings .
public static result set point table ( double x , double y ) { geometry factory factory = new geometry factory ( ) ; simple result set rs = new simple result set ( ) ; rs . add column ( str , types . java object , str , num , num ) ; rs . add row ( factory . create point ( new coordinate ( x , y ) ) ) ; return rs ; }	this method is called via reflection from the database .
public void add to existing volumes if absent ( map < string , integer > volume ww ) { if ( existing volumes == null ) { existing volumes = new string map ( ) ; } for ( string wwn : volume ww . key set ( ) ) { string normalized wwn = block object . normalize wwn ( wwn ) ; if ( ! existing volumes . contains key ( normalized wwn ) && ( user added volumes == null || ! user added volumes . contains key ( normalized wwn ) ) ) { string hlu str = export group . lun unassigned str ; integer hlu = volume ww . get ( normalized wwn ) ; if ( hlu != null ) { hlu str = hlu . to string ( ) ; } existing volumes . put ( normalized wwn , hlu str ) ; } } }	this method will add to the existing volumes list only those members that don ' t already exist in either the existing or user - created volume list .
public path impl create temp file ( string prefix , string suffix ) throws io { if ( prefix == null || prefix . length ( ) == num ) prefix = str ; if ( suffix == null ) suffix = str ; synchronized ( lock ) { for ( int i = num ; i < num ; i ++ ) { int r = math . abs ( ( int ) random util . get random long ( ) ) ; path impl file = lookup ( prefix + r + suffix ) ; if ( file . create new file ( ) ) return file ; } } throw new io ( str ) ; }	creates a unique temporary file as a child of this directory .
static map < target type , list < type compound > > partition by target type ( collection < type compound > annos , list < type compound > unmatched , target type ... target types ) { final map < target type , list < type compound > > target type to annos = new hash map < > ( ) ; for ( target type target type : target types ) { target type to annos . put ( target type , new array list < type compound > ( num ) ) ; } for ( final type compound anno : annos ) { final list < type compound > anno set = target type to annos . get ( anno . get position ( ) . type ) ; if ( anno set != null ) { anno set . add ( anno ) ; } else if ( unmatched != null ) { unmatched . add ( anno ) ; } } return target type to annos ; }	use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map . any annotation that does not have one of these target types will be added to unmatched.
public void load ( ) { try { if ( file channel == null ) { file channel = file channel . open ( path , standard open option . read ) ; } file channel . position ( num ) ; buffer . clear ( ) ; tmp . clear ( ) ; while ( file channel . read ( tmp ) > num ) { tmp . flip ( ) ; if ( tmp . remaining ( ) > buffer . capacity ( ) - buffer . position ( ) ) { final byte buffer next = byte buffer . allocate direct ( math . max ( buffer . capacity ( ) * num , tmp . remaining ( ) ) ) ; buffer . flip ( ) ; next . put ( buffer ) ; buffer = next ; } buffer . put ( tmp ) ; tmp . clear ( ) ; } buffer . flip ( ) ; } catch ( final io e ) { throw new io ( e ) ; } }	opens a channel to the specified path if it does not already exist.
private void on hp ( final int amount ) { if ( user . squared distance to ( x , y ) < hearing distance sq ) { if ( amount > num ) { add text indicator ( str + amount , notification type . positive ) ; } else { add text indicator ( string . value of ( amount ) , notification type . negative ) ; } } }	called when entity adjusts hp .
@ not null private file resolve name ( @ not null string name ) throws io { file file ; if ( name . starts with ( root ) ) { file = new file ( my template root folder , name . substring ( root . length ( ) ) ) ; } else if ( my last template folders != null ) { file = new file ( my last template folders . peek ( ) , name ) ; } else { file = new file ( my template root folder , name ) ; } return file . get canonical file ( ) ; }	resolve a freemarker name reference .
public void init tool tip ( ) { if ( ttmanager == null ) { ttmanager = tool tip manager . shared instance ( ) ; ttmanager . register component ( map ) ; ttmanager . set enabled ( bool ) ; return ; } if ( map != null ) { map . set tool tip text ( null ) ; } }	this method should be called to initialize the tooltip status so that an old tooltip doesn ' t remain when a layer starts listening to mouse events .
public static string [ ] decode array ( string encoded array ) { string [ ] items = encoded array . split ( str ) ; array list < string > list = new array list < string > ( ) ; for ( int i = num ; i < items . length ; i ++ ) { string item = items [ i ] ; item = gsub ( str , str , item ) ; if ( ! item . equals ( str ) ) { list . add ( item ) ; } } return list . to array ( new string [ list . size ( ) ] ) ; }	decodes a string generated by encodearray .
public boolean compute angle offset ( ) { if ( m finished ) { return bool ; } long system clock = animation utils . current animation time millis ( ) ; long time passed = system clock - m start time ; if ( time passed < m duration ) { switch ( m mode ) { case scroll mode : float sc = ( float ) time passed / m duration ; m curr angle = m start angle + math . round ( m delta angle * sc ) ; break ; case fling mode : float time passed seconds = time passed / num ; float distance ; if ( m velocity < num ) { distance = m coeff velocity * m velocity * time passed seconds - ( m deceleration * time passed seconds * time passed seconds / num ) ; } else { distance = - m coeff velocity * m velocity * time passed seconds - ( m deceleration * time passed seconds * time passed seconds / num ) ; } m curr angle = m start angle - math . signum ( m velocity ) * math . round ( distance ) ; break ; } return bool ; } else { m finished = bool ; return bool ; } }	call this when you want to know the new location.
public long sigignore ( ) { return long . parse long ( fields [ num ] ) ; }	the bitmap of ignored signals , displayed as a decimal number.
private static byte [ ] generate seed ( ) { try { final byte array output stream seed buffer = new byte array output stream ( ) ; final data output stream seed buffer out = new data output stream ( seed buffer ) ; seed buffer out . write long ( system . current time millis ( ) ) ; seed buffer out . write long ( system . nano time ( ) ) ; seed buffer out . write int ( process . my pid ( ) ) ; seed buffer out . write int ( process . my uid ( ) ) ; seed buffer out . write ( build fingerprint and device serial ) ; seed buffer out . close ( ) ; return seed buffer . to byte array ( ) ; } catch ( final io e ) { throw new security exception ( str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
public string render ( value expr the expr ) throws exception { the expr . visit ( this ) ; return m buffer . to string ( ) ; }	return the rendering of the valueexpr object.
public void stop sampling ( ) { if ( m sampling counter . decrement and get ( ) == num ) { m handler . stop sampling thread ( ) ; add final sample ( ) ; } }	finish sampling and prevent further changes to the connectionclass until another timer is started .
public static final void reverse winding ( list < vector2 > points ) { if ( points == null ) throw new null pointer exception ( messages . get string ( str ) ) ; int size = points . size ( ) ; if ( size == num || size == num ) return ; collections . reverse ( points ) ; }	reverses the order of the polygon points within the given list.
public d ( j parent , pkc pkcs10 csr , file csr file , private key sign private key , key pair type sign key pair type , x509 certificate verification certificate , provider provider ) throws crypto exception { super ( parent , dialog . modality type . document modal ) ; this . pkcs10 csr = pkcs10 csr ; this . csr file = csr file ; this . sign private key = sign private key ; this . sign key pair type = sign key pair type ; this . verification certificate = verification certificate ; this . provider = provider ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dsigncsr dialog for a pkcs # 10 formatted csr .
protected static void init ( ) { string notificationfactory class name = null ; try { notificationfactory class name = system . get property ( notification factory name ) ; } catch ( security exception e ) { throw new runtime exception ( e ) ; } if ( notificationfactory class name != null ) { class < ? > nfc ; try { nfc = class . for name ( notificationfactory class name ) ; factory = ( i ) nfc . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { throw new runtime exception ( e ) ; } } else { factory = new syslog notification factory ( ) ; } }	a simple mechanism to initialize factory with dynamic binding.
private int await done ( boolean timed , long nanos ) throws interrupted exception { final long deadline = timed ? system . nano time ( ) + nanos : num ; wait node q = null ; boolean queued = bool ; for ( ; ; ) { if ( thread . interrupted ( ) ) { remove waiter ( q ) ; throw new interrupted exception ( ) ; } int s = state ; if ( s > completing ) { if ( q != null ) q . thread = null ; return s ; } else if ( s == completing ) thread . yield ( ) ; else if ( q == null ) q = new wait node ( ) ; else if ( ! queued ) queued = unsafe . compare and swap object ( this , waiters offset , q . next = waiters , q ) ; else if ( timed ) { nanos = deadline - system . nano time ( ) ; if ( nanos <= num ) { remove waiter ( q ) ; return state ; } lock support . park nanos ( this , nanos ) ; } else lock support . park ( this ) ; } }	awaits completion or aborts on interrupt or timeout .
public static double clamp ( double value , double low , double high ) { return math . min ( math . max ( value , low ) , high ) ; }	clamp a value to be within the provided range .
public static string parse volume host directory ( string volume ) { if ( string utils . is empty ( volume ) ) { return volume ; } if ( ! volume . contains ( host container dir delimiter ) ) { return volume ; } string [ ] host container dir = volume . split ( host container dir delimiter ) ; if ( host container dir . length != num ) { throw new illegal argument exception ( str ) ; } string host dir = host container dir [ num ] ; return host dir ; }	parses volume host directory only .
private string fmt time ( double time ) { return utilities . pad ( time formatter . format ( time ) + str , num ) ; }	formats times into a standard format .
@ override public synchronized object [ ] to array ( ) { object [ ] result = new object [ element count ] ; system . arraycopy ( element data , num , result , num , element count ) ; return result ; }	returns a new array containing all elements contained in this vector .
public static string right ( string s , int width , char fill char ) { if ( s . length ( ) >= width ) { return s ; } string buffer sb = new string buffer ( width ) ; for ( int i = width - s . length ( ) ; -- i >= num ; ) { sb . append ( fill char ) ; } sb . append ( s ) ; return sb . to string ( ) ; }	right justify a string .
public synchronized boolean add all ( collection < ? extends e > c ) { mod count ++ ; object [ ] a = c . to array ( ) ; int num new = a . length ; ensure capacity helper ( element count + num new ) ; system . arraycopy ( a , num , element data , element count , num new ) ; element count += num new ; return num new != num ; }	appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection ' s iterator.
@ override public void update ( default application state trans state ) { new checkpoint ( trans state . get state ( ) , trans state . get state hash ( ) , trans state . get last checkpoint cid ( ) ) ; set last checkpoint cid ( trans state . get last checkpoint cid ( ) ) ; }	updates this log , according to the information contained in the transferablestate object.
public static byte [ ] string to utf8 bytes ( string string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * num ] ; int out at = num ; for ( int i = num ; i < len ; i ++ ) { char c = string . char at ( i ) ; if ( ( c != num ) && ( c < num ) ) { bytes [ out at ] = ( byte ) c ; out at ++ ; } else if ( c < num ) { bytes [ out at ] = ( byte ) ( ( ( c > > num ) & num ) | num ) ; bytes [ out at + num ] = ( byte ) ( ( c & num ) | num ) ; out at += num ; } else { bytes [ out at ] = ( byte ) ( ( ( c > > num ) & num ) | num ) ; bytes [ out at + num ] = ( byte ) ( ( ( c > > num ) & num ) | num ) ; bytes [ out at + num ] = ( byte ) ( ( c & num ) | num ) ; out at += num ; } } byte [ ] result = new byte [ out at ] ; system . arraycopy ( bytes , num , result , num , out at ) ; return result ; }	converts a string into its java - style utf - 8 form.
private list < pair < string , object > > to pair list ( final map < string , object > bindings ) { final list < pair < string , object > > blist = new array list < pair < string , object > > ( ) ; for ( final map . entry < string , object > pair : bindings . entry set ( ) ) { blist . add ( new pair < string , object > ( pair . get key ( ) , pair . get value ( ) ) ) ; } return blist ; }	converts a hash map of bindings to a list of binding pairs .
@ override public boolean validate label ( string label ) { objects . require non null ( label , str ) ; return ! labels . contains ( label ) ; }	checks the given label can be added / removed to / from a vertex .
public void add message observer ( final message observer observer ) { if ( observer == null ) { throw new null pointer exception ( ) ; } else if ( message observers == null ) { init message observer list ( ) ; } message observers . add ( observer ) ; }	adds the specified message observer .
public void show ( char initial char ) { initial string = initial string . append ( initial char ) ; show ( ) ; if ( swt . get platform ( ) != str ) { set edit text ( initial string . to string ( ) ) ; } }	performs show and sets the edit string to be the initial character or string.
private static void byte2hex ( byte b , string buffer buf ) { int high = ( ( b & num ) > > num ) ; int low = ( b & num ) ; buf . append ( hex digits [ high ] ) ; buf . append ( hex digits [ low ] ) ; }	description of the method.
public e remove ( int index ) { hash code up to date = bool ; mod count ++ ; e old value = element data ( index ) ; int num moved = size - index - num ; if ( num moved > num ) system . arraycopy ( element data , index + num , element data , index , num moved ) ; element data [ -- size ] = null ; return old value ; }	removes the element at the specified position in this list.
public static double vector rnorm ( int n , double mean , double sd , random random ) { if ( sd < num ) throw new illegal argument exception ( str ) ; if ( sd == num ) return new double vector ( n , mean ) ; double vector v = new double vector ( n ) ; for ( int i = num ; i < n ; i ++ ) v . set ( i , ( random . next gaussian ( ) + mean ) / sd ) ; return v ; }	generates a sample of a normal distribution .
protected void warning occurred ( int code ) { cb lock . lock ( ) ; try { if ( ( code < num ) || ( code > max warning ) ) { throw new internal error ( str ) ; } process warning occurred ( str , integer . to string ( code ) ) ; } finally { cb lock . unlock ( ) ; } }	called by the native code or other classes to signal a warning.
public boolean is known sub ( string sub name ) { return known subs . contains ( sub name ) ; }	checks if sub is indexed .
public string diff text1 ( linked list < diff > diffs ) { string builder text = new string builder ( ) ; for ( diff a diff : diffs ) { if ( a diff . operation != operation . insert ) { text . append ( a diff . text ) ; } } return text . to string ( ) ; }	compute and return the source text ( all equalities and deletions ) .
public boolean is stored ( ) { return integer . signum ( id ) != - num ; }	determines whether the view was previously stored to the database .
public static big integer size of directory as big integer ( file directory ) { check directory ( directory ) ; final file [ ] files = directory . list files ( ) ; if ( files == null ) { return big integer . zero ; } big integer size = big integer . zero ; for ( final file file : files ) { try { if ( ! is symlink ( file ) ) { size = size . add ( big integer . value of ( size of ( file ) ) ) ; } } catch ( io ioe ) { } } return size ; }	counts the size of a directory recursively ( sum of the length of all files ) .
public boolean is search light bit ( int bit ) { if ( node type != smini ) { log . error ( str ) ; return ( bool ) ; } if ( ( bit < num ) || ( bit > num ) ) { log . error ( str + integer . to string ( bit ) ) ; return ( bool ) ; } if ( loc search light bits [ bit ] == num ) { return ( bool ) ; } return ( bool ) ; }	query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns ' true ' if bit is an oscillating searchlightbit , otherwise ' false ' is returned.
public age file filter ( date cutoff date , boolean accept older ) { this ( cutoff date . get time ( ) , accept older ) ; }	constructs a new age file filter for files on any one side of a certain cutoff date .
public void calc major tick ( ) { major tick = num ; major tick count = ( int ) math . round ( log10 ( max tick / min tick ) ) + num ; }	calculate the optimum major tick distance .
public boolean next ( ) throws generic data source exception { try { return rs . next ( ) ; } catch ( sql sqle ) { throw new generic data source exception ( str + sql , sqle ) ; } }	test if there more records available.
public void put ( string sample , hidden attribute attribute , object value ) { put ( sample , attribute . to string ( ) , value ) ; }	put a value in the table.
public boolean unset ordering ( object first , object second ) { digraph node first po = ( digraph node ) po nodes . get ( first ) ; digraph node second po = ( digraph node ) po nodes . get ( second ) ; return first po . remove edge ( second po ) || second po . remove edge ( first po ) ; }	removes any ordering between two nodes .
public string convert swf html ( input stream in ) throws exception { string writer out1 = new string writer ( ) ; output = new print writer ( out1 ) ; tag parser parser = new tag parser ( this ) ; swf reader = new swf ( parser , in ) ; reader . read file ( ) ; in . close ( ) ; size count = reader . size ; final string ret = str + ( headerstr . is empty ( ) ? str : str + headerstr + str ) + out1 . to string ( ) + str ; return ret ; }	parses swf input and extracts text and wrap it as html.
public void write ( class file class file , file f ) throws io { file output stream f out = new file output stream ( f ) ; try { write ( class file , f out ) ; } finally { f out . close ( ) ; } }	write a classfile data structure to a file .
public connection ( final inet socket address peer address ) { this ( peer address , ( handshaker ) null ) ; }	creates a new connection to a given peer .
protected static vector convert to vector ( final object [ ] an array ) { if ( an array == null ) { return null ; } final vector v = new vector ( an array . length ) ; for ( final object element : an array ) { v . add element ( element ) ; } return v ; }	returns a vector that contains the same objects as the array .
protected synchronized void notify version ( sprog version v ) { ver = v ; for ( sprog version listener listener : get copy of listeners ( ) ) { try { listener . notify version ( ver ) ; version listeners . remove ( listener ) ; } catch ( exception e ) { log . warn ( str + listener + str + e ) ; } } }	notify all registered listeners of the sprog version.
protected void accept drop ( int drop operation ) { drop target context peer peer = get drop target context peer ( ) ; if ( peer != null ) { peer . accept drop ( drop operation ) ; } }	called to signal that the drop is acceptable using the specified operation.
public void clear ( ) { ored criteria . clear ( ) ; order by clause = null ; distinct = bool ; }	this method was generated by mybatis generator . this method corresponds to the database table help_tip.
@ override public string to string ( ) { string result ; result = super . to string ( ) ; if ( m != null ) { init capabilities ( ) ; if ( m != null ) { if ( m . supports maybe ( m ) && ! m . supports ( m ) ) { result = str + maybe support + str + result + str ; } else if ( ! m . supports ( m ) ) { result = str + no support + str + result + str ; } } } return result ; }	returns a string representation of this treenode .
public date modified date ( string path ) throws illegal state exception , io , ftp , ftp { synchronized ( lock ) { if ( ! connected ) { throw new illegal state exception ( str ) ; } if ( ! authenticated ) { throw new illegal state exception ( str ) ; } communication . send ftp ( str + path ) ; ftp r = communication . read ftp ( ) ; touch auto noop timer ( ) ; if ( ! r . is success code ( ) ) { throw new ftp ( r ) ; } string [ ] messages = r . get messages ( ) ; if ( messages . length != num ) { throw new ftp ( ) ; } else { try { return mdtm date format . parse ( messages [ num ] ) ; } catch ( parse exception e ) { throw new ftp ( ) ; } } } }	this method asks and returns the last modification date of a file or directory .
public boolean import pkcs8 ( ) { return jrb pkcs8 . is selected ( ) ; }	has the user chosen to import from pkcs # 8 private key and certificate file combination ?.
public control flow graph run ( compilation unit tree root , processing environment env , method tree tree , class tree class tree ) { ast underlying ast = new cfg ( tree , class tree ) ; return run ( root , env , underlying ast ) ; }	build the control flow graph of a method .
private boolean is valid engine ( ) { if ( has flag ( ~ ( clan engine | tank engine | large engine | superheavy engine | support vee engine ) ) ) { problem . append ( str + engine flags ) ; return bool ; } if ( has flag ( support vee engine ) && ( engine type != steam ) && ( engine type != combustion engine ) && ( engine type != battery ) && ( engine type != fuel cell ) && ( engine type != solar ) && ( engine type != fission ) && ( engine type != normal engine ) && ( engine type != none ) ) { problem . append ( str ) ; return bool ; } if ( ( ( ( int ) math . ceil ( engine rating / num ) > engine ratings . length ) || ( engine rating < num ) ) && ! has flag ( support vee engine ) ) { problem . append ( str + engine rating ) ; return bool ; } if ( ( engine rating > num ) && ! has flag ( support vee engine ) ) { engine flags |= large engine ; } switch ( engine type ) { case combustion engine : case normal engine : case xl engine : case xxl engine : case fuel cell : case none : case maglev : case battery : case solar : break ; case compact engine : if ( has flag ( large engine ) ) { problem . append ( messages . get string ( str ) ) ; return bool ; } break ; case light engine : case fission : if ( has flag ( clan engine ) ) { problem . append ( messages . get string ( str ) ) ; return bool ; } break ; default : problem . append ( str + engine type ) ; return bool ; } return bool ; }	sanity checks the engine , no negative ratings , and similar checks .
static public void assert equals ( string message , float expected , float actual , float delta ) { if ( float . is infinite ( expected ) ) { if ( ! ( expected == actual ) ) fail not equals ( message , new float ( expected ) , new float ( actual ) ) ; } else if ( ! ( math . abs ( expected - actual ) <= delta ) ) fail not equals ( message , new float ( expected ) , new float ( actual ) ) ; }	asserts that two floats are equal concerning a delta.
private void calculate d ( double [ ] b ) { int length = m extremal indices . size ( ) - num ; m d = new double [ length ] ; for ( int k = num ; k < length ; k ++ ) { m d [ k ] = b [ k ] * ( m grid . get cosine frequency grid ( ) [ m extremal indices . get ( k ) ] - m grid . get cosine frequency grid ( ) [ m extremal indices . get ( length ) ] ) ; } }	calculates the set of d values for the current extremal index set . implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 116c.
private static properties load properties ( string properties file ) { properties properties = new properties ( ) ; try ( input stream is = new file input stream ( properties file ) ) { properties . load ( is ) ; } catch ( io e ) { throw new runtime exception ( str , e ) ; } return properties ; }	loads properties from a properties file on the local filesystem .
public text editor replace all ( pattern pattern , replacement replacement ) { matcher m = pattern . matcher ( text ) ; int last index = num ; string builder sb = new string builder ( ) ; while ( m . find ( ) ) { sb . append ( text . sub sequence ( last index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last index = m . end ( ) ; } sb . append ( text . sub sequence ( last index , text . length ( ) ) ) ; text = sb ; return this ; }	replace all occurrences of the pattern.
public map < string , map < string , string > > list ( string service name ) { map < string , map < string , string > > results = new hash map < string , map < string , string > > ( ) ; service info [ ] infos = jmdns . list ( str + service name + str ) ; for ( service info info : infos ) { log . info ( str , info ) ; final string [ ] host addrs = info . get host addresses ( ) ; final string buffer buf = new string buffer ( ) ; for ( string host addr : host addrs ) { buf . append ( host addr ) ; buf . append ( str ) ; } final string key = buf . to string ( ) ; log . info ( str , key ) ; final map < string , string > values = new hash map < string , string > ( ) ; for ( enumeration < string > e = info . get property names ( ) ; e . has more elements ( ) ; ) { final string prop = e . next element ( ) ; final string value = new string ( info . get property bytes ( prop ) ) ; log . info ( str , prop , value ) ; values . put ( prop , value ) ; } if ( values . is empty ( ) ) { log . warn ( str , key ) ; } results . put ( key , values . is empty ( ) ? null : values ) ; } return results ; }	list published node ( s ) configuration in the network via multicast.
@ suppress warnings ( { str } ) @ override default lazy future stream < u > concat ( final stream < ? extends u > other ) { return from stream ( stream . concat ( stream support . stream ( spliterators . spliterator unknown size ( iterator ( ) , spliterator . ordered ) , bool ) , stream support . stream ( spliterators . spliterator unknown size ( other . iterator ( ) , spliterator . ordered ) , bool ) ) ) ; }	concatenate two streams . / / ( 1 , 2 , 3 , 4 , 5 , 6 ) lazyfuturestream . of ( 1 , 2 , 3 ) . concat ( lazyfuturestream . of ( 4 , 5 , 6 ) ).
@ override public void read external ( object input in ) throws io { path = igfs utils . read path ( in ) ; block size = in . read int ( ) ; grp block size = in . read long ( ) ; len = in . read long ( ) ; props = u . read string map ( in ) ; access time = in . read long ( ) ; modification time = in . read long ( ) ; flags = in . read byte ( ) ; }	reads object from data input .
public xy ( ) { this ( default item label format , number format . get number instance ( ) , number format . get number instance ( ) ) ; }	creates an item label generator using default number formatters .
public vector2 ( double direction ) { this . x = math . cos ( direction ) ; this . y = math . sin ( direction ) ; }	creates a unit length vector in the given direction .
public double adjusted pow10 ( double val ) { boolean neg flag = ( val < num ) ; if ( neg flag ) { val = - val ; } double res ; if ( val < num ) { res = ( math . pow ( num , val + num ) - num ) / num ; } else { res = math . pow ( num , val ) ; } return neg flag ? ( - res ) : res ; }	returns an adjusted power of 10 value for graphing purposes.
@ override public void clear ( ) { column list . for each ( null ) ; }	clears all the data from this table.
public boolean is last invoice ( ) { string cm = get costing method ( ) ; return cm != null && cm . equals ( costingmethod ) ; }	is last invoice costing method.
public static void proxy port ( final int port ) { final string port value = integer . to string ( port ) ; set property ( str , port value ) ; set property ( str , port value ) ; }	set the ' http.
public static string fetch cluster name ( string cluster cg name ) { string cluster name = null ; if ( cluster cg name != null && ! cluster cg name . is empty ( ) ) { string [ ] tmp = cluster cg name . split ( splitter ) ; cluster name = tmp [ num ] ; } return cluster name ; }	parses out the cluster name from the combined cluster / cg name .
private void fetch my service cards from server ( ) { retro callback retro callback ; retro callback = new retro callback ( this ) ; retro callback . set request id ( http constants . api response codes . get my services ) ; retro callback list . add ( retro callback ) ; m yelo api . get my service cards ( retro callback ) ; }	helper http function to get list of my service cards .
public d ( j parent , string title , rsa rsa public key ) { super ( parent , title , dialog . modality type . document modal ) ; key = rsa public key ; init fields ( ) ; }	creates new dviewasymmetrickeyfields dialog .
public list < colour change > sample conditional migration events2 ( int parent colour , double parent height , int child colour , double child height , double [ ] m ) { list < colour change > colour changes = new array list < colour change > ( ) ; if ( parent height < child height ) { throw new illegal argument exception ( str + parent height + str + child height + str ) ; } try { int current colour = parent colour ; double current height = parent height ; while ( bool ) { colour change next event = random conditional migration event ( current colour , current height , child colour , child height , m ) ; current height = next event . get time ( ) ; current colour = next event . get colour above ( ) ; colour changes . add ( next event ) ; } } catch ( no event exception nee ) { } reverse colour change list ( colour changes , parent colour ) ; return colour changes ; }	samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree.
public static boolean is attribute ( object obj value ) { if ( obj value instanceof string ) { string string value = ( string ) obj value ; if ( string value . starts with ( attribute start ) && string value . ends with ( attribute end ) ) { return bool ; } } return bool ; }	checks if string is actually an attribute .
public static string decode ascii ( final byte [ ] key , final int off , final int len ) { final byte [ ] b = new byte [ len ] ; system . arraycopy ( key , off , b , num , len ) ; for ( int i = num ; i < len ; i ++ ) { b [ i ] = decode byte ( b [ i ] ) ; } try { return new string ( b , str ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } }	decodes an ascii string from a key .
@ override public void value changed ( tree selection event e ) { if ( prevent event ) { return ; } if ( main frame != null ) { list < operator > selected operators = get selected operators ( ) ; if ( selected operators != null && ! selected operators . is empty ( ) ) { main frame . select operators ( selected operators ) ; } } }	this method will be invoked after a user selection of an operator in the tree.
public synchronized void remove property change listener ( property change listener listener ) { listeners . remove ( listener ) ; }	removes a property change listener .
final boolean transfer after cancelled wait ( node node ) { if ( compare and set wait status ( node , node . condition , num ) ) { enq ( node ) ; return bool ; } while ( ! is on sync queue ( node ) ) thread . yield ( ) ; return bool ; }	transfers node , if necessary , to sync queue after a cancelled wait.
private static intent create share intent ( context context , final string share text ) { final intent share intent = new intent ( intent . action send ) ; share intent . put extra ( android . content . intent . extra subject , context . get string ( r . string . share subject ) ) ; share intent . put extra ( android . content . intent . extra text , share text ) ; share intent . set type ( str ) ; return share intent ; }	creates a share intent.
public static < u > atomic integer field updater < u > new updater ( class < u > tclass , string field name ) { if ( unsafe holder . is available ( ) ) { return new atomic integer field updater impl < u > ( tclass , field name ) ; } return atomic integer field updater . new updater ( tclass , field name ) ; }	creates an updater for objects with the given field.
public map < string , object > convert data to objects ( map < string , string > data ) { map < string , object > results = new hash map < > ( ) ; if ( data != null ) { for ( string key : data . key set ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }	internal conversion . this is needed to support the current springboot actuator auditeventrepository interface.
private static pair < string , string > offset lsr ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value1 , final string register node value2 , final string immediate node value ) { final string address = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string index = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , dw , str + immediate node value , qw , tmp var1 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , qw , tmp var1 , dw , d word bit mask , dw , index ) ) ; instructions . add ( reil helpers . create add ( base offset ++ , dw , register node value1 , dw , index , dw , tmp var2 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var2 , dw , d word bit mask , dw , address ) ) ; return new pair < string , string > ( address , register node value1 ) ; }	operation : [ < rn > , + / - < rm > , lsr # < shift_imm > ] 0b01 / lsr / if shift_imm = = 0 then / lsr # 32 / index = 0 else index = rm logical_shift_right shift_imm if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public static row limit spec build row limit spec ( ep . row limit context ctx ) { object num rows ; object offset ; if ( ctx . o != null ) { num rows = parse num or variable ident ( ctx . n1 , ctx . i1 ) ; offset = parse num or variable ident ( ctx . n2 , ctx . i2 ) ; } else if ( ctx . c != null ) { offset = parse num or variable ident ( ctx . n1 , ctx . i1 ) ; num rows = parse num or variable ident ( ctx . n2 , ctx . i2 ) ; } else { num rows = parse num or variable ident ( ctx . n1 , ctx . i1 ) ; offset = null ; } integer num rows int = null ; string num rows variable = null ; if ( num rows instanceof string ) { num rows variable = ( string ) num rows ; } else { num rows int = ( integer ) num rows ; } integer offset int = null ; string offset variable = null ; if ( offset instanceof string ) { offset variable = ( string ) offset ; } else { offset int = ( integer ) offset ; } return new row limit spec ( num rows int , offset int , num rows variable , offset variable ) ; }	builds a row limit specification .
public final int first common layer ( brd item p other ) { int max first layer = math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = math . min ( last layer ( ) , p other . last layer ( ) ) ; if ( max first layer > min last layer ) { return - num ; } return max first layer ; }	returns the first layer , where both this item and p_other have a shape.
public item stack remove items ( item stack drive , item stack stack , int amount wanted ) { if ( get max kilobits ( drive ) == - num ) return null ; int stored = get amount stored ( drive , stack ) ; int amount given = math . min ( amount wanted , stored ) ; if ( amount given > num ) { set amount stored ( drive , stack , stored - amount given ) ; stack . stack size += amount given ; mark dirty ( drive ) ; } return stack ; }	take as many items as possible , up to the passed limit , from a drive into the given stack.
public void save indexes ( ) { array list to save = new array list ( ) ; synchronized ( this ) { object [ ] value table = this . indexes . value table ; for ( int i = num , l = value table . length ; i < l ; i ++ ) { index index = ( index ) value table [ i ] ; if ( index != null ) to save . add ( index ) ; } } boolean all saved = bool ; for ( int i = num , length = to save . size ( ) ; i < length ; i ++ ) { index index = ( index ) to save . get ( i ) ; read write monitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enter read ( ) ; if ( index . has changed ( ) ) { if ( monitor . exit read enter write ( ) ) { try { save index ( index ) ; } catch ( io e ) { if ( job manager . verbose ) { util . verbose ( str , system . err ) ; e . print stack trace ( ) ; } all saved = bool ; } finally { monitor . exit write enter read ( ) ; } } else { all saved = bool ; } } } finally { monitor . exit read ( ) ; } } if ( this . participants containers != null && this . participant updated ) { write participants index names file ( ) ; this . participant updated = bool ; } this . need to save = ! all saved ; }	commit all index memory changes to disk.
public void add item ( artist artist , int position ) { if ( artist == null ) throw new null pointer exception ( str ) ; if ( position < get item count ( ) || position > get item count ( ) ) throw new illegal argument exception ( str ) ; artists . add ( position , artist ) ; notify item inserted ( position ) ; }	add item in determined index.
public process execute async ( final command line command , map < string , string > environment ) throws io { if ( working directory != null && ! working directory . exists ( ) ) { throw new io ( working directory + str ) ; } return execute internal ( command , environment , working directory , stream handler , null ) ; }	methods for starting asynchronous execution .
public void expand and select if exists ( repository location location ) { if ( location . parent ( ) != null ) { expand if exists ( location . parent ( ) , location . get name ( ) ) ; } else { expand if exists ( location , null ) ; } scroll path to visible ( get selection path ( ) ) ; }	expands the tree to select the given entry if it exists .
public void next token ( ) { previous line = line ; previous column = column ; while ( pos < matcher . region start ( ) ) { if ( text . char at ( pos ) == str ) { ++ line ; column = num ; } else { ++ column ; } ++ pos ; } if ( matcher . region start ( ) == matcher . region end ( ) ) { current token = str ; } else { matcher . use pattern ( token ) ; if ( matcher . looking at ( ) ) { current token = matcher . group ( ) ; matcher . region ( matcher . end ( ) , matcher . region end ( ) ) ; } else { current token = string . value of ( text . char at ( pos ) ) ; matcher . region ( pos + num , matcher . region end ( ) ) ; } skip whitespace ( ) ; } }	advance to the next token .
public static void save provisioning validity ( context context , long validity ) { if ( validity <= num ) { return ; } long next = system . current time millis ( ) + validity ; shared preferences preferences = context . get shared preferences ( android registry factory . rcs prefs name , activity . mode private ) ; shared preferences . editor editor = preferences . edit ( ) ; editor . put long ( registry provisioning validity , validity ) ; editor . put long ( registry provisioning expiration , next ) ; editor . commit ( ) ; }	save the provisioning validity in shared preferences.
public void encode ( output stream out ) throws io { der output stream tmp = new der output stream ( ) ; if ( this . extension value == null ) { this . extension id = pkix . reason code id ; this . critical = bool ; encode this ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to byte array ( ) ) ; }	write the extension to the deroutputstream .
public void create cluster async ( final string project id , final cluster create spec cluster create spec , final future callback < task > response callback ) throws io { string path = string . format ( str , get base path ( ) , project id ) ; create object async ( path , serialize object as json ( cluster create spec ) , response callback ) ; }	create a cluster in the specified project .
public static dereference aliases policy value of ( final int int value ) { if ( int value < num || int value >= elements . length ) { return null ; } return elements [ int value ] ; }	returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4.
public void test get named item n ( ) throws throwable { document doc ; named node map attributes ; node element ; attr attribute ; node list element list ; string attr name ; doc = ( document ) load ( str , builder ) ; element list = doc . get elements by tag name ns ( str , str ) ; element = element list . item ( num ) ; attributes = element . get attributes ( ) ; attribute = ( attr ) attributes . get named item ns ( str , str ) ; attr name = attribute . get node name ( ) ; assert equals ( str , str , attr name ) ; }	runs the test case .
public static void write unsafe ( packet output stream out , string value , boolean no backslash escapes ) throws io { byte [ ] bytes = value . get bytes ( str ) ; out . write unsafe ( quote ) ; write bytes escaped unsafe ( out , bytes , bytes . length , no backslash escapes ) ; out . write unsafe ( quote ) ; }	write string in text format without checking buffer size .
public void add ( final sam read , final int position ) { record and offsets . add ( new record and offset ( read , position ) ) ; }	accumulate info for one read at the locus .
private sha256 hash calculate hash ( ) { try { byte array output stream bos = new unsafe byte array output stream ( header size ) ; write header ( bos ) ; return new sha256 hash ( utils . reverse bytes ( double digest ( bos . to byte array ( ) ) ) ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	calculates the block hash by serializing the block and hashing the resulting bytes .
private void add property type ( uri p , resource t ) { owl property prop = get property ( p ) ; if ( t . equals ( owl . transitiveproperty ) ) { prop . set transitive ( ) ; } else if ( t . equals ( owl . symmetricproperty ) ) { prop . set symmetric ( ) ; } else if ( t . equals ( ow . asymmetricproperty ) ) { prop . set asymmetric ( ) ; } else if ( t . equals ( owl . functionalproperty ) ) { prop . set functional ( ) ; } else if ( t . equals ( owl . inversefunctionalproperty ) ) { prop . set inverse functional ( ) ; } else if ( t . equals ( ow . irreflexiveproperty ) ) { prop . set irreflexive ( ) ; } }	add a particular characteristic to a property .
public static void equals ( object object1 , object object2 ) { check assertion ( object1 . equals ( object2 ) , null ) ; }	asserts that given object1 equals object2 .
public static string write actions to string ( of inst , logger log ) throws exception { return action utils . actions to string ( inst . get actions ( ) , log ) ; }	convert an ofinstructionwriteactions to string form.
protected void pre add interruptibly ( object o ) throws interrupted exception { }	called before the specified object is added to this queue .
public static string encode lines ( byte [ ] in , int i off , int i len , int line len , string line separator ) { int block len = ( line len * num ) / num ; if ( block len <= num ) throw new illegal argument exception ( ) ; int lines = ( i len + block len - num ) / block len ; int buf len = ( ( i len + num ) / num ) * num + lines * line separator . length ( ) ; string builder buf = new string builder ( buf len ) ; int ip = num ; while ( ip < i len ) { int l = math . min ( i len - ip , block len ) ; buf . append ( encode ( in , i off + ip , l ) ) ; buf . append ( line separator ) ; ip += l ; } return buf . to string ( ) ; }	encodes a byte array into base 64 format and breaks the output into lines .
private o read feed log perf ( string query , map < string , string > params ) throws io , o { long delta time = system . current time millis ( ) ; o feed = client . read feed ( query , params ) ; log ( level . debug , str + query + str + delta time + str ) ; return feed ; }	logs how much time an odata command consumed .
final int rllong ( data input stream dis ) throws io { int b1 , b2 , b3 , b4 ; int i = num ; i = dis . read int ( ) ; b1 = ( i & num ) << num ; b2 = ( i & num ) << num ; b3 = ( i & num ) > > num ; b4 = ( i & num ) > > > num ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }	rllong protected helper method to read 64 bits and changing the order of each bytes .
public void test shift right4 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , num , - num , num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift right ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	shiftright ( int n ) , n > 32.
public dependencies resolve from file ( file file , string class name , soot class sc ) { dexlib wrapper wrapper = cache . get ( file ) ; if ( wrapper == null ) { wrapper = new dexlib wrapper ( file ) ; cache . put ( file , wrapper ) ; wrapper . initialize ( ) ; } dependencies deps = wrapper . make soot class ( sc , class name ) ; add source file tag ( sc , str + file . get name ( ) ) ; return deps ; }	resolve the class contained in file into the passed soot class .
public static string build response url ( string tenant , logout state logout state ) { string retval = null ; logout response saml response = logout state . generate response for tenant ( tenant , logout state . get message source ( ) , logout state . get locale ( ) ) ; if ( saml response != null ) { log . info ( str + saml response . to string ( ) ) ; retval = logout state . generate response url for tenant ( saml response , tenant ) ; } return retval ; }	helper method to generate logoutresponse redirect url.
public static void assert label ( int [ ] path , string text ) { if ( verbose ) { log ( str + to string ( path ) + str + text + str ) ; } label l = ( label ) get component by path ( path ) ; assert bool ( l != null , str + text ) ; assert bool ( text == l . get text ( ) || text . equals ( l . get text ( ) ) , ( str + l . get text ( ) ) + str + text ) ; }	asserts that we have a label with the given text baring the given name.
private void interpolate result list ( array list < path parser . path data node > list ) { if ( list == null || list . size ( ) <= num ) return ; float [ ] [ ] list pen pos = path node utils . calculate pen position ( list ) ; array list < path parser . path data node > sub list = new array list < > ( ) ; int size = list . size ( ) ; path parser . path data node current node = null ; int i = num ; while ( i < size - num ) { current node = list . get ( i ) ; if ( ! is interpolatable command ( current node . m type ) ) { i ++ ; continue ; } boolean valid sequence = bool ; int k = i ; for ( int j = i ; j < size && valid sequence ; j ++ ) { if ( current node . m type == list . get ( j ) . m type ) { k = j ; if ( ! arrays . equals ( current node . m params , list . get ( j ) . m params ) ) break ; } else valid sequence = bool ; } if ( k - i > num ) { interpolate sub list ( list . sub list ( i , k + num ) ) ; } i ++ ; } }	apply interpolation on the result list ( where possible ).
private void init tokenizer ( stream tokenizer tokenizer ) { tokenizer . reset syntax ( ) ; tokenizer . whitespace chars ( num , ( str - num ) ) ; tokenizer . word chars ( str , str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . comment char ( str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . quote char ( str ) ; tokenizer . quote char ( str ) ; tokenizer . eol is significant ( bool ) ; }	initializes the stream tokenizer.
protected void illegal message received ( of m ) { string msg = get switch state message ( m , str ) ; throw new switch state exception ( msg ) ; }	we have an ofmessage we didn ' t expect given the current state and we want to treat this as an error . we currently throw an exception that will terminate the connection however , we could be more forgiving.
protected void run ( ) throws exception { for ( int i = num ; i <= num ; i += num ) { set num workers ( i ) ; try { thread . sleep ( num * num ) ; } catch ( interrupted exception e ) { } } }	a simple method to do nothing very much.
protected boolean read ( ) { if ( ! n reuse header ) { debug . message ( str , str ) ; return read header ( ) ; } byte [ ] temp data = new byte [ n data size - n field offset ] ; int n read bytes = po module . read ( temp data , num , temp data . length ) ; system . arraycopy ( pach data , n field offset , temp data , num , temp data . length ) ; if ( n read bytes != ( int ) ( n data size - n field offset ) && n read bytes == - num ) { return bool ; } else if ( n read bytes != ( int ) ( n data size - n field offset ) ) { debug . error ( str ) ; return bool ; } return bool ; }	read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ).
@ override public boolean lock ( ) { try { if ( ! file factory . is file exist ( location , file factory . get file type ( tmp path ) ) ) { file factory . mkdirs ( location , file factory . get file type ( tmp path ) ) ; } string lock file path = location + carbon common constants . file separator + lock file ; if ( ! file factory . is file exist ( lock file path , file factory . get file type ( location ) ) ) { file factory . create new lock file ( lock file path , file factory . get file type ( location ) ) ; } file output stream = new file output stream ( lock file path ) ; channel = file output stream . get channel ( ) ; try { file lock = channel . try lock ( ) ; } catch ( overlapping file lock exception e ) { return bool ; } if ( null != file lock ) { return bool ; } else { return bool ; } } catch ( io e ) { return bool ; } }	lock api for locking of the file channel of the lock file .
public void open ( int port ) throws io { connection = new datagram socket ( port ) ; connection . set so timeout ( timeout ) ; }	open the datagram connection.
public string global info ( ) { return str + str ; }	returns a string describing this split evaluator.
public ml execute ( script script ) { script executor script executor = new script executor ( spark monitoring util ) ; script executor . set explain ( explain ) ; script executor . set explain level ( explain level ) ; script executor . set statistics ( statistics ) ; script executor . set init ( script history strings . is empty ( ) ) ; return execute ( script , script executor ) ; }	execute a dml or pydml script .
public void disable ( rich formatter feature feature ) { features . remove ( feature ) ; }	disable a specific feature on this rich formatter .
public void remove event listener ( z event listener ) { synchronized ( zwave event listeners ) { zwave event listeners . remove ( event listener ) ; } }	remove a listener for zwave events to this controller .
private static double python time ( ) { return system . current time millis ( ) / num ; }	returns the current millis the same way as python does since this is what ' s stored in the replay files * yay * .
@ safe varargs public final void add ( t ... new items ) { add ( arrays . as list ( new items ) ) ; }	add new items to the table .
public static string quote if java keyword ( string name ) { return jvm . quote if java keyword ( name ) ; }	prefixes the given name with a dollar ( $ ) if it is a java keyword.
public static recipe from cursor ( cursor cursor ) { recipe recipe = new recipe ( null ) ; for ( int c = num ; c < cursor . get column count ( ) ; c ++ ) { string column name = cursor . get column name ( c ) ; if ( column name . equals ( recipe table . id column ) ) { recipe . id = cursor . get string ( c ) ; } else if ( column name . equals ( recipe table . title column ) ) { recipe . set title ( cursor . get string ( c ) ) ; } else if ( column name . equals ( recipe table . description column ) ) { recipe . set description ( cursor . get string ( c ) ) ; } else if ( column name . equals ( recipe table . photo column ) ) { recipe . set photo ( cursor . get string ( c ) ) ; } else if ( column name . equals ( recipe table . prep time column ) ) { recipe . set prep time ( cursor . get string ( c ) ) ; } } return recipe ; }	static helper method for populating attributes from a database cursor .
public static void check state ( boolean expression , @ nullable object error message ) { if ( ! expression ) { throw new illegal state exception ( string . value of ( error message ) ) ; } }	ensures the truth of an expression involving the state of the calling instance , but not involving any parameters to the calling method .
private static < t , id > void add drop table statements ( database type database type , table info < t , id > table info , list < string > statements ) { list < string > statements before = new array list < string > ( ) ; list < string > statements after = new array list < string > ( ) ; for ( field type field type : table info . get field types ( ) ) { database type . drop column arg ( field type , statements before , statements after ) ; } string builder sb = new string builder ( num ) ; sb . append ( str ) ; database type . append escaped entity name ( sb , table info . get table name ( ) ) ; sb . append ( str ) ; statements . add all ( statements before ) ; statements . add ( sb . to string ( ) ) ; statements . add all ( statements after ) ; }	generate and return the list of statements to drop a database table .
public boolean is locked ( ) { return ! queue . is empty ( ) ; }	true iff a lock is granted .
public long cguest time ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 2.
private static class info find or create class ( string t ) { if ( ! t . ends with ( str ) ) { return class info . find or create class ( t ) ; } else { string base type = t . substring ( num , t . index of ( str ) ) ; int level = ( t . length ( ) - t . index of ( str ) ) / num ; string s = str ; for ( int i = num ; i < level ; ++ i ) s += str ; if ( base type . equals ( str ) ) s += str ; else if ( base type . equals ( str ) ) s += str ; else s += str + base type + str ; return class info . find or create class ( s ) ; } }	convert pscout - style type name to canonical form.
private void reset notes ( ) { if ( error in status1 ) { if ( edit mode ) { status text1 . set text ( edit status1 ) ; } else { status text1 . set text ( std status1 ) ; } error in status1 = bool ; } reset notes2 ( ) ; }	method to reset the notes error after error display.
@ hle ( nid = num , version = num ) public int sce rtc set tick ( t time addr , t ticks addr ) { long ticks = ticks addr . get value ( ) - rtc magic offset ; sce psp date time time = sce psp date time . from micros ( ticks ) ; time . write ( time addr ) ; return num ; }	set a psptime struct based on ticks .
public static void write ( file file , char sequence data , charset encoding , boolean append ) throws io { string str = data == null ? null : data . to string ( ) ; write string to file ( file , str , encoding , append ) ; }	writes a charsequence to a file creating the file if it does not exist .
private void populate nav drawer ( ) { m nav drawer items . clear ( ) ; m nav drawer items . add ( navdrawer item home ) ; m nav drawer items . add ( navdrawer item separator ) ; m nav drawer items . add ( navdrawer item my following ) ; m nav drawer items . add ( navdrawer item my shots ) ; m nav drawer items . add ( navdrawer item my buckets ) ; m nav drawer items . add ( navdrawer item my projects ) ; m nav drawer items . add ( navdrawer item my teams ) ; m nav drawer items . add ( navdrawer item my likes ) ; m nav drawer items . add ( navdrawer item separator special ) ; m nav drawer items . add ( navdrawer item settings ) ; create nav drawer items ( ) ; }	populates the navigation drawer with the appropriate items .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child value ; int child length ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child value = child . get data ( ) ; child length = child value . length ( ) ; assert equals ( str , num , child length ) ; }	runs the test case .
public static byte [ ] values of ( byte [ ] array ) { byte [ ] dest = new byte [ array . length ] ; for ( int i = num ; i < array . length ; i ++ ) { dest [ i ] = byte . value of ( array [ i ] ) ; } return dest ; }	converts to object array .
public void audit callhome ( operation type enum audit type , string operational status , string description , object ... descparams ) { audit mgr . record audit log ( null , null , event service type , audit type , system . current time millis ( ) , operational status , description , descparams ) ; }	record audit log for callhome service.
public static float mean ( float [ ] data , int start index , int end index ) { float mean = num ; int total = num ; start index = math . max ( start index , num ) ; start index = math . min ( start index , data . length - num ) ; end index = math . max ( end index , num ) ; end index = math . min ( end index , data . length - num ) ; if ( start index > end index ) start index = end index ; for ( int i = start index ; i <= end index ; i ++ ) { if ( float . is na n ( data [ i ] ) ) throw new illegal argument exception ( str ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }	compute the mean of all elements in the array.
public static string construct nt ( long date ) { long ntp time = num ; long start time = ( date / seconds to milliseconds conversion rate ) + ntp time ; return string . value of ( start time ) ; }	construct an ntp time from a date in milliseconds.
protected media type select media type ( server web exchange exchange , list < media type > producible types ) { list < media type > acceptable types = get acceptable types ( exchange ) ; producible types = get producible types ( exchange , producible types ) ; set < media type > compatible media types = new linked hash set < > ( ) ; for ( media type acceptable : acceptable types ) { for ( media type producible : producible types ) { if ( acceptable . is compatible with ( producible ) ) { compatible media types . add ( select more specific media type ( acceptable , producible ) ) ; } } } list < media type > result = new array list < > ( compatible media types ) ; media type . sort by specificity and quality ( result ) ; for ( media type media type : compatible media types ) { if ( media type . is concrete ( ) ) { return media type ; } else if ( media type . equals ( media type . all ) || media type . equals ( media type application all ) ) { return media type . application octet stream ; } } return null ; }	select the best media type for the current request through a content negotiation algorithm .
public void paint border ( component c , graphics g , int x , int y , int width , int height ) { if ( ! ( c instanceof j ) ) { return ; } font orig font = g . get font ( ) ; color orig color = g . get color ( ) ; j popup = ( j ) c ; string title = popup . get label ( ) ; if ( title == null ) { return ; } g . set font ( font ) ; font metrics fm = swing utilities2 . get font metrics ( popup , g , font ) ; int font height = fm . get height ( ) ; int descent = fm . get descent ( ) ; int ascent = fm . get ascent ( ) ; point text loc = new point ( ) ; int string width = swing utilities2 . string width ( popup , fm , title ) ; text loc . y = y + ascent + text spacing ; text loc . x = x + ( ( width - string width ) / num ) ; g . set color ( background ) ; g . fill rect ( text loc . x - text spacing , text loc . y - ( font height - descent ) , string width + ( num * text spacing ) , font height - descent ) ; g . set color ( foreground ) ; swing utilities2 . draw string ( popup , g , title , text loc . x , text loc . y ) ; motif graphics utils . draw groove ( g , x , text loc . y + text spacing , width , groove height , shadow color , highlight color ) ; g . set font ( orig font ) ; g . set color ( orig color ) ; }	paints the border for the specified component with the specified position and size .
public void ensure capacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length * num ) > > num ) + num ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ; system . arraycopy ( olddata , num , array , num , size ) ; } }	increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .
public void invalidate and unmap ( byte buffer ... bufs ) throws io { if ( cleaner != null ) { invalidated = bool ; barrier . lazy set ( num ) ; thread . yield ( ) ; for ( byte buffer b : bufs ) { cleaner . free buffer ( resource description , b ) ; } } }	invalidates this guard and unmaps ( if supported ) .
public int add dir ( file file ) { if ( ! file . exists ( ) ) { return num ; } string [ ] names = get names ( get files ( file , str ) ) ; load class ( file , names ) ; return num ; }	adds new locations for command classes.
private boolean is mineshafter present ( ) { try { class . for name ( str ) ; return bool ; } catch ( exception e ) { return bool ; } }	check if mineshafter is present . if it is , we need to bypass it to send post requests.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof xy ) ) { return bool ; } if ( ! super . equals ( obj ) ) { return bool ; } xy that = ( xy ) obj ; if ( ! object utilities . equal ( this . z format , that . z format ) ) { return bool ; } if ( ! object utilities . equal ( this . z date format , that . z date format ) ) { return bool ; } return bool ; }	tests this object for equality with an arbitrary object .
public static boolean has element child ( node node ) { node list nl = node . get child nodes ( ) ; node child = null ; int length = nl . get length ( ) ; for ( int i = num ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . get node type ( ) == node . element node ) { return bool ; } } return bool ; }	checks if a node has a child of element type .
public void del item ( int index ) { synchronized ( get menu tree lock ( ) ) { if ( selected index == index ) { select item ( null , bool ) ; } else if ( selected index > index ) { selected index -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . is loggable ( platform logger . level . fine ) ) { log . fine ( str + index + str + items . size ( ) ) ; } } } update size ( ) ; }	removes item at the specified index from items vector .
public static int count css ( ) { return all primitive property names . size ( ) ; }	returns a count of all css primitive ( non - shorthand ) properties known to this class .
public void print string ( string v ) throws io { print string ( v , num , v . length ( ) ) ; }	prints a string to the stream , encoded as utf - 8.
private void check permission ( object object , namespace permission enum [ ] permissions , list < access denied exception > access denied exceptions ) { if ( object != null ) { if ( object instanceof collection ) { collection < ? > collection = ( collection < ? > ) object ; for ( object element : collection ) { check permission ( element , permissions , access denied exceptions ) ; } } else if ( object instanceof string ) { try { check permission ( ( string ) object , permissions ) ; } catch ( access denied exception access denied exception ) { access denied exceptions . add ( access denied exception ) ; } } else { throw new illegal state exception ( string . format ( str , string . class , collection . class , object . get class ( ) ) ) ; } } }	checks the current user ' s permissions against the given object which may represent a single or multiple namespaces.
private void display all string defined in string xml ( ) { simple icon font text view text view = ( simple icon font text view ) find view by id ( r . id . text view 2 ) ; list < string > list = new array list < > ( ) ; list . add ( get string ( r . string . cubeicon gems logo ) ) ; list . add ( get string ( r . string . cubeicon android ) ) ; list . add ( get string ( r . string . cubeicon heart ) ) ; string text = text utils . join ( str , list ) ; text view . set text ( text ) ; }	display the string defined in the string xml file : iconfont_string . xml.
private static intent create map activity intent ( context context , url [ ] url spans ) { for ( int span i = num ; span i < url spans . length ; span i ++ ) { url url span = url spans [ span i ] ; string url string = url span . get url ( ) ; if ( url string . starts with ( geo prefix ) ) { intent geo intent = new intent ( intent . action view , uri . parse ( url string ) ) ; geo intent . add flags ( intent . flag activity new task ) ; return geo intent ; } } return null ; }	create an intent to take the user to maps , using the first map link available.
private string builder generate parameters ( ) { string builder parameters = new string builder ( ) ; if ( filter map == null && expand parameters == null ) { return parameters ; } parameters . append ( str ) ; int filter parameter counter = num ; if ( filter map != null && ! filter map . is empty ( ) ) { parameters . append ( filter prefix ) ; for ( map . entry < string , string > filter entry : filter map . entry set ( ) ) { parameters . append ( string . format ( str , filter entry . get key ( ) , filter entry . get value ( ) ) ) ; if ( ++ filter parameter counter < filter map . size ( ) ) { parameters . append ( str ) ; } } if ( expand parameters != null ) { parameters . append ( str ) ; } } if ( expand parameters != null ) { parameters . append ( expand prefix ) ; iterator iterator = expand parameters . iterator ( ) ; parameters . append ( string . format ( str , iterator . next ( ) ) ) ; while ( iterator . has next ( ) ) { parameters . append ( string . format ( str , iterator . next ( ) ) ) ; } } return parameters ; }	returns a stringbuilder that is consisted of filtering and expanding parameters that in turn are appended to the query string used for odata client.
public void write exif ( bitmap bmap , output stream exif out stream ) throws io { if ( bmap == null || exif out stream == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = get exif writer stream ( exif out stream ) ; bmap . compress ( bitmap . compress format . jpeg , num , s ) ; s . flush ( ) ; }	writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .
public void remove attribute ( int index ) { if ( index >= num && index < length ) { if ( index < length - num ) { system . arraycopy ( data , ( index + num ) * num , data , index * num , ( length - index - num ) * num ) ; } index = ( length - num ) * num ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ] = null ; length -- ; } else { bad index ( index ) ; } }	remove an attribute from the list .
public static @ check for null @ slashed class name string from field signature ( string signature ) { if ( signature . char at ( num ) != str ) { return null ; } return signature . substring ( num , signature . length ( ) - num ) ; }	converts from signature to slashed class name ( e.
private void paint preview ( int dx , int dy , float zoomfactor ) { if ( image != null ) { d g2 = ( d ) get graphics ( ) ; u bg = renderer . get background color ( ) ; g2 . set background ( new color ( bg . get red ( ) , bg . get green ( ) , bg . get blue ( ) , bg . get alpha ( ) ) ) ; int new width = math . round ( image . get width ( null ) * zoomfactor ) ; int new height = ( int ) math . round ( image . get height ( null ) * zoomfactor ) ; g2 . draw image ( image , dx , dy , new width , new height , null ) ; if ( dx > num ) g2 . clear rect ( num , num , dx , get height ( ) ) ; else g2 . clear rect ( get width ( ) + dx , num , get width ( ) , get height ( ) ) ; if ( dy > num ) g2 . clear rect ( num , num , get width ( ) , dy ) ; else g2 . clear rect ( num , get height ( ) + dy , get width ( ) , get height ( ) ) ; } }	draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .
@ requires permission ( manifest . permission . camera ) public camera source start ( ) throws io { synchronized ( m camera lock ) { if ( m camera != null ) { return this ; } m camera = create camera ( ) ; if ( build . version . sdk int >= build . version codes . honeycomb ) { m dummy surface texture = new surface texture ( dummy texture name ) ; m camera . set preview texture ( m dummy surface texture ) ; } else { m dummy surface view = new surface view ( m context ) ; m camera . set preview display ( m dummy surface view . get holder ( ) ) ; } m camera . start preview ( ) ; m processing thread = new thread ( m frame processor ) ; m frame processor . set active ( bool ) ; m processing thread . start ( ) ; } return this ; }	opens the camera and starts sending preview frames to the underlying detector.
public synchronized void clear ( ) { m categories . clear ( ) ; m values . clear ( ) ; }	removes all the existing values from the series .
public static list < list < double > > partition variable ( list < double > arr , int chunk ) { int count = num ; list < list < double > > ret = new array list < list < double > > ( ) ; while ( count < arr . size ( ) ) { list < double > sublist = arr . sub list ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; } for ( list < double > lists : ret ) { if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; } return ret ; }	this will partition the given whole variable data applytransformtodestination in to the specified chunk number .
private static void update window ui ( window window ) { swing utilities . update component tree ui ( window ) ; window owned wins [ ] = window . get owned windows ( ) ; for ( window owned win : owned wins ) { update window ui ( owned win ) ; } }	updates the ui of the passed in window and all its children .
public void clear results ( ) { if ( result list != null ) { result list . clear ( ) ; m adapter . notify data set changed ( ) ; } listener . on search cleared ( ) ; }	clear all the results.
public array list < constraint widget > find widgets ( widget container container , int x , int y , int width , int height ) { array list < constraint widget > found = new array list < > ( ) ; rectangle area = new rectangle ( x , y , width , height ) ; for ( constraint widget widget : container . get children ( ) ) { widget companion companion = ( widget companion ) widget . get companion widget ( ) ; widget decorator decorator = companion . get widget decorator ( widget decorator . blueprint style ) ; if ( ! decorator . is visible ( ) ) { continue ; } rectangle bounds = new rectangle ( widget . get draw x ( ) , widget . get draw y ( ) , widget . get width ( ) , widget . get height ( ) ) ; if ( area . intersects ( bounds ) ) { found . add ( widget ) ; } } return found ; }	gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account.
public final void print symbol ( char sequence text ) throws io { if ( text == null ) { append ascii ( str ) ; } else if ( text . length ( ) == num ) { throw new empty symbol exception ( ) ; } else if ( symbol needs quoting ( text , bool ) ) { append ascii ( str ) ; print code points ( text , symbol escape codes ) ; append ascii ( str ) ; } else { append ascii ( text ) ; } }	print an ion symbol type . this method will check if symbol needs quoting.
public static shopping cart item make item ( integer cart location , generic value product , big decimal selected amount , big decimal quantity , big decimal unit price , timestamp reserv start , big decimal reserv length , big decimal reserv persons , timestamp ship before date , timestamp ship after date , map < string , generic value > additional product feature and appls , map < string , object > attributes , string prod catalog id , product config wrapper config wrapper , string item type , shopping cart . shopping cart item group item group , local dispatcher dispatcher , shopping cart cart , boolean trigger external ops bool , boolean trigger price rules bool , generic value parent product , boolean skip inventory checks , boolean skip product checks ) throws cart item modify exception { return make item ( cart location , product , selected amount , quantity , unit price , reserv start , reserv length , reserv persons , null , null , ship before date , ship after date , additional product feature and appls , attributes , prod catalog id , config wrapper , item type , item group , dispatcher , cart , trigger external ops bool , trigger price rules bool , parent product , skip inventory checks , skip product checks ) ; }	makes a shoppingcartitem and adds it to the cart.
@ override public string to string ( ) { map < assignment , double > sorted table = inference utils . get n ( table , math . max ( table . size ( ) , num ) ) ; string str = str ; for ( entry < assignment , double > entry : sorted table . entry set ( ) ) { string prob = string utils . get short form ( entry . get value ( ) ) ; str += str + entry . get key ( ) + str + prob + str ; } return ( str . length ( ) > num ) ? str . substring ( num , str . length ( ) - num ) : str ; }	returns a string representation of the probability table.
protected final void update border text ( final string text ) { preconditions . check not null ( text , str ) ; m titled border . set title ( text ) ; update ui ( ) ; }	updates the border text of the component .
private void add classes ( class < ? > [ ] classes , hash set < class < ? > > result , string field name ) { if ( classes == null || classes . length == num ) error . classes absent ( field name , configured class ) ; for ( class < ? > classe : classes ) result . add ( classe ) ; }	adds to the result parameter all classes that aren ' t present in it.
public void reset references ( ) { if ( refs != null ) refs . clear ( ) ; }	resets the references for streaming .
public static big integer decode mpi ( byte [ ] mpi , boolean has length ) { byte [ ] buf ; if ( has length ) { int length = ( int ) read uint32 be ( mpi , num ) ; buf = new byte [ length ] ; system . arraycopy ( mpi , num , buf , num , length ) ; } else buf = mpi ; if ( buf . length == num ) return big integer . zero ; boolean is negative = ( buf [ num ] & num ) == num ; if ( is negative ) buf [ num ] &= num ; big integer result = new big integer ( buf ) ; return is negative ? result . negate ( ) : result ; }	mpi encoded numbers are produced by the openssl bn_bn2mpi function.
public void schema changed ( string service name , string version ) { synchronized ( map realm to format ) { map realm to format . remove ( root ) ; } }	this method will be invoked when a service ' s schema has been changed .
public void sort ( dtm v , vector keys , x support ) throws javax . xml . transform . transformer exception { m keys = keys ; int n = v . get length ( ) ; vector nodes = new vector ( ) ; for ( int i = num ; i < n ; i ++ ) { node compare elem elem = new node compare elem ( v . item ( i ) ) ; nodes . add element ( elem ) ; } vector scratch vector = new vector ( ) ; mergesort ( nodes , scratch vector , num , n - num , support ) ; for ( int i = num ; i < n ; i ++ ) { v . set item ( ( ( node compare elem ) nodes . element at ( i ) ) . m node , i ) ; } v . set current pos ( num ) ; }	given a vector of nodes , sort each node according to the criteria in the keys .
protected date time data parse ( string str ) throws schema date time exception { date time data date = new date time data ( str , this ) ; int len = str . length ( ) ; date . year = year ; date . day = day ; if ( str . char at ( num ) != str || str . char at ( num ) != str ) { throw new schema date time exception ( str + str ) ; } int stop = num ; date . month = parse int ( str , num , stop ) ; if ( str . length ( ) >= stop + num && str . char at ( stop ) == str && str . char at ( stop + num ) == str ) { stop += num ; } if ( stop < len ) { if ( ! is next char utc ( str , stop , len ) ) { throw new schema date time exception ( str + str ) ; } else { get time zone ( str , date , stop , len ) ; } } validate date time ( date ) ; save unnormalized ( date ) ; if ( date . utc != num && date . utc != str ) { normalize ( date ) ; } date . position = num ; return date ; }	parses , validates and computes normalized version of gmonth object.
private void add to queue ( serial message serial message ) { if ( serial message == null ) { return ; } if ( ! msg queue . contains ( serial message ) && msg queue . remaining capacity ( ) > num ) { msg queue . add ( serial message ) ; } send message ( ) ; }	move the messages to the queue.
private dbid string to dbid ( string query ) { return dbid . import integer ( integer . value of ( query ) ) ; }	parse a string into a dbid .
@ override public final void write short ( int v ) throws io { work [ num ] = ( byte ) v ; work [ num ] = ( byte ) ( v > > num ) ; dis . write ( work , num , num ) ; }	write short , 16 - bits.
final public void println ( long v ) { writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( newline , num , newline . length ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a long followed by a newline .
public thrift service metadata ( class < ? > service type ) { require non null ( service type , str ) ; interfaces = init ( null , collections . singleton ( service type ) ) ; }	creates a new instance from a single thrift service interface .
public writable raster create compatible writable raster ( int w , int h ) { if ( w <= num || h <= num ) { throw new raster format exception ( str + ( ( w <= num ) ? str : str ) ) ; } sample model sm = sample model . create compatible sample model ( w , h ) ; return new byte packed raster ( sm , new point ( num , num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
public static response invalid entity ( constraint violation exception e ) { string builder error message = new string builder ( ) ; boolean first pass = bool ; for ( constraint violation error : e . get constraint violations ( ) ) { if ( ! first pass ) { error message . append ( str ) ; } error message . append ( string . format ( str , error . get property path ( ) , error . get message ( ) , error . get invalid value ( ) ) ) ; first pass = bool ; } external exception external exception = new external exception ( error code . invalid entity , error message . to string ( ) , null ) ; return external exception ( external exception ) ; }	return an error response generated by a validation failure , invalid json , etc .
public string check start block ( int mode ) { if ( log . is debug enabled ( ) ) log . debug ( str + get display name ( ) + str ) ; block order bo = orders . get ( num ) ; o block = bo . get block ( ) ; string msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } msg = bo . set path ( this ) ; if ( msg != null ) { return msg ; } int state = block . get state ( ) ; if ( ( state & o . dark ) != num || temp run blind ) { msg = bundle . get message ( str , block . get display name ( ) ) ; } else if ( ( state & o . occupied ) == num ) { if ( mode == mode learn ) { msg = str ; } else { msg = str ; } msg = bundle . get message ( msg , get train name ( ) , block . get display name ( ) ) ; } else { tracker table action . stop tracker in ( block ) ; } return msg ; }	check start block for occupied for start of run.
public void init ( string prefix , java . net . url url ) { try { java . io . input stream in = url . open stream ( ) ; properties props = new properties ( ) ; props . load ( in ) ; init ( get layers ( prefix , props ) ) ; } catch ( java . net . url murle ) { logger . warning ( str + url + str ) ; } catch ( java . io . io e ) { logger . warning ( str ) ; } }	initialize the layerhandler by having it construct it ' s layers from a url containing an openmap.
boolean suppressed by ( dns msg ) { try { for ( dns answer : msg . get all answers ( ) ) { if ( suppressed by ( answer ) ) { return bool ; } } return bool ; } catch ( array index out of bounds exception e ) { logger . log ( level . warning , str + msg + str , e ) ; return bool ; } }	true if this record is suppressed by the answers in a message .
public static properties create properties ( final map < string , string > map ) { properties properties = new properties ( ) ; if ( ! ( map == null || map . is empty ( ) ) ) { for ( entry < string , string > entry : map . entry set ( ) ) { properties . set property ( entry . get key ( ) , entry . get value ( ) ) ; } } return properties ; }	creates an properties object initialized with the value from the given map . < p >.
public node select first ( string query ) { list < node > selected nodes = select ( query ) ; if ( selected nodes . is empty ( ) ) { return null ; } return selected nodes . get ( num ) ; }	selects nodes using css3 selector query and returns the very first one .
public static string [ ] string array from properties ( properties p , string prop name , string tok ) { string [ ] ret = null ; string raw = p . get property ( prop name ) ; if ( raw != null && raw . length ( ) > num ) { try { string tokenizer token = new string tokenizer ( raw , tok ) ; int num paths = token . count tokens ( ) ; ret = new string [ num paths ] ; for ( int i = num ; i < num paths ; i ++ ) { ret [ i ] = token . next token ( ) ; } return ret ; } catch ( java . util . no such element exception e ) { e . print stack trace ( ) ; } } return ret ; }	takes a string of representing token separated properties and returns an array of parsed strings.
private static int compare locales ( locale primary , locale other ) { final string lang = primary . get language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get language ( ) ) ) { return num ; } final string country = primary . get country ( ) ; if ( ( country == null ) || ! country . equals ( other . get country ( ) ) ) { return num ; } final string variant = primary . get variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get variant ( ) ) ) { return num ; } return num ; }	compares a locale against a primary locale.
void query read result ( prepared statement prep ) throws sql { result set rs = prep . execute query ( ) ; result set meta data meta = rs . get meta data ( ) ; int column count = meta . get column count ( ) ; while ( rs . next ( ) ) { for ( int i = num ; i < column count ; i ++ ) { rs . get string ( i + num ) ; } } }	execute a query and read all rows .
public static < v > boolean add distinct entry ( list < v > source list , v entry ) { return ( source list != null && ! source list . contains ( entry ) ) ? source list . add ( entry ) : bool ; }	add distinct entry to list.
public boolean equals ( object obj ) { if ( obj instanceof m ) { m ms = ( m ) obj ; if ( data == ms . data ) return bool ; } return bool ; }	equal ( based on data , ignores index ).
public static void end transaction ( final c connection ) throws sql { end transaction ( connection . get connection ( ) ) ; }	commits and finishes a formerly started transaction .
public c ( ) { super ( new border layout ( ) ) ; m table . set selection mode ( list selection model . single selection ) ; add ( new j ( m table ) ) ; m table . add mouse listener ( new internal mouse listener ( ) ) ; }	creates a new panel object .
private void double capacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int new capacity = n << num ; if ( new capacity < num ) throw new illegal state exception ( str ) ; object [ ] a = new object [ new capacity ] ; system . arraycopy ( elements , p , a , num , r ) ; system . arraycopy ( elements , num , a , r , p ) ; elements = a ; head = num ; tail = n ; }	double the capacity of this deque.
private void change open am ( string new open am ) { system properties manager . initialize properties ( debug constants . config debug directory , new open am ) ; }	change the debug logs folder.
protected string compute full url ( url base url , string link ) { if ( link == null || link . length ( ) == num ) { return null ; } if ( ! link . starts with ( str ) ) { if ( link . starts with ( str ) ) { link = base url . get protocol ( ) + str + base url . get authority ( ) + link ; } else { if ( link . contains ( str ) ) { return null ; } string path = base url . get path ( ) ; if ( ! path . ends with ( str ) ) { int sep = path . last index of ( str ) ; string file = path . substring ( sep + num ) ; if ( file . contains ( str ) || file . contains ( str ) ) path = path . substring ( num , sep ) ; } link = base url . get protocol ( ) + str + base url . get authority ( ) + path + str + link ; } } link = normalize url ending ( link ) ; string l = link . to lower case ( locale . root ) ; if ( l . ends with ( str ) || l . ends with ( str ) || l . ends with ( str ) || l . ends with ( str ) ) { return null ; } return link ; }	computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .
private void load manifest ( ) { if ( is manifest read ) return ; synchronized ( this ) { if ( is manifest read ) return ; try { manifest = jar path . get manifest ( ) ; if ( manifest == null ) return ; attributes attr = manifest . get main attributes ( ) ; if ( attr != null ) add manifest package ( str , attr ) ; map < string , attributes > entries = manifest . get entries ( ) ; for ( map . entry < string , attributes > entry : entries . entry set ( ) ) { string pkg = entry . get key ( ) ; attr = entry . get value ( ) ; if ( attr == null ) continue ; add manifest package ( pkg , attr ) ; } } catch ( io e ) { log . log ( level . warning , e . to string ( ) , e ) ; } finally { is manifest read = bool ; } } }	reads the jar ' s manifest .
public reference binding [ ] convert to raw types ( reference binding [ ] original types , boolean force erasure , boolean force raw enclosing type ) { if ( original types == null ) return null ; reference binding [ ] converted types = original types ; for ( int i = num , length = original types . length ; i < length ; i ++ ) { reference binding original type = original types [ i ] ; reference binding converted type = ( reference binding ) convert to raw type ( force erasure ? original type . erasure ( ) : original type , force raw enclosing type ) ; if ( converted type != original type ) { if ( converted types == original types ) { system . arraycopy ( original types , num , converted types = new reference binding [ length ] , num , i ) ; } converted types [ i ] = converted type ; } else if ( converted types != original types ) { converted types [ i ] = original type ; } } return converted types ; }	convert an array of types in raw forms.
public void add column ( int idx , column column ) { if ( column != null ) { columns . add ( idx , column ) ; } }	adds the given column at the specified position .
public void read data ( data input din ) throws io { reference = din . read unsigned short ( ) ; and mask = din . read unsigned short ( ) ; or mask = din . read unsigned short ( ) ; }	readdata - - dummy function.
boolean remove display ( display display ) { return m displays . remove ( display ) ; }	remove a display from this visualization .
public double next gaussian ( ) { if ( m have next next gaussian ) { m have next next gaussian = bool ; return m next next gaussian ; } else { double v1 , v2 , s ; do { v1 = num * next double ( ) - num ; v2 = num * next double ( ) - num ; s = v1 * v1 + v2 * v2 ; } while ( s >= num || s == num ) ; final double multiplier = strict math . sqrt ( - num * strict math . log ( s ) / s ) ; m next next gaussian = v2 * multiplier ; m have next next gaussian = bool ; return v1 * multiplier ; } }	return the next gaussian see knuth , acp , section 3.
private void fire event ( final i q ) { if ( q == null ) throw new illegal argument exception ( ) ; if ( listeners . is empty ( ) ) { return ; } final i [ ] a = listeners . to array ( new i [ num ] ) ; for ( i l : a ) { final i listener = l ; try { listener . notify ( q ) ; } catch ( throwable t ) { if ( inner cause . is inner cause ( t , interrupted exception . class ) ) { throw new runtime exception ( t ) ; } log . error ( t , t ) ; } } }	send an event to all registered listeners .
private void update contact header port ( int local port , sip message ) { if ( message != null && message . get contact header ( ) != null ) { contact header contact header = message . get contact header ( ) ; address contact address = contact header . get address ( ) ; contact address . set port ( local port ) ; } }	update port of contact header to reflect local port.
public static android http client new instance ( string user agent ) { return new instance ( user agent , null ) ; }	create a new httpclient with reasonable defaults ( which you can update ) .
@ nullable grid cache mvcc candidate add entry ( grid local cache entry entry ) throws grid cache entry removed exception { grid cache mvcc candidate c = entry . add local ( thread id , lock ver , null , null , timeout , ! in tx ( ) , in tx ( ) , implicit single ( ) , bool ) ; entries . add ( entry ) ; if ( c == null && timeout < num ) { if ( log . is debug enabled ( ) ) log . debug ( str + entry ) ; on failed ( ) ; return null ; } if ( c != null ) { entry . ready local ( c ) ; } return c ; }	adds entry to future .
@ override public void visit vertex ( street router . state state ) { integer edge idx = state . back edge ; if ( ! ( edge idx == null || edge idx == - num ) ) { edge store . edge edge = edge store . get cursor ( edge idx ) ; geo json feature feature = new geo json feature ( edge . get geometry ( ) ) ; feature . add property ( str , state . weight ) ; feature . add property ( str , state . street mode ) ; feature . add property ( str , state . back edge ) ; features . add ( feature ) ; } }	saves current state geometry mode and weight as geojson feature properties in list of features . it is used in full state graph when debugging.
public void test bsbm no solutions ( ) throws exception { final test helper helper = new test helper ( str , str , new string [ ] { } , str ) ; assert same join order ( new int [ ] { num , num , num , num , num } , helper ) ; }	test of bsbm q1 against an empty data set.
public static void delete file or log ( file file ) { if ( ! file . delete ( ) ) { logger . warn ( failed deleting file + file . get path ( ) ) ; } }	delete a file from the file system or log the failure if unable to delete it .
public synchronized void remove ( int index ) { super . remove ( index ) ; m max values . remove ( index ) ; }	removes existing values from the series .
public gitlab group member add group member ( gitlab group group , gitlab user user , gitlab access level access level ) throws io { return add group member ( group . get id ( ) , user . get id ( ) , access level ) ; }	add a group member .
protected logger ( string name , string resource bundle name ) { super ( name , resource bundle name ) ; }	protected method to construct a logger for a named subsystem.
@ override public void increment ( double coord , short val ) { int bin = get bin nr ( coord ) ; if ( bin < num ) { if ( size - bin > data . length ) { short [ ] tmpdata = new short [ grow size ( data . length , size - bin ) ] ; system . arraycopy ( data , num , tmpdata , - bin , size ) ; data = tmpdata ; } else { system . arraycopy ( data , num , data , - bin , size ) ; arrays . fill ( data , num , - bin , ( short ) num ) ; } data [ num ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { short [ ] tmpdata = new short [ grow size ( data . length , bin + num ) ] ; system . arraycopy ( data , num , tmpdata , num , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + num ; max = double . max value ; } else { if ( bin >= size ) { size = bin + num ; } data [ bin ] += val ; } }	increment the value of a bin .
public static void check argument ( boolean expression , object error message ) { if ( ! expression ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
default document put all ( map < ? extends char sequence , object > fields ) { if ( fields != null ) { for ( map . entry < ? extends char sequence , object > entry : fields . entry set ( ) ) { set ( entry . get key ( ) , entry . get value ( ) ) ; } } return this ; }	sets on this object all key / value pairs from the supplied map.
private boolean contains ignore case ( list < string > stringlist , string match ) { for ( string s : stringlist ) { if ( s . equals ignore case ( match ) ) { return bool ; } } return bool ; }	checks if a list of string contains a string while ignoring case.
public static double compute mad ( double [ ] x , double median ) { for ( int i = num ; i < x . length ; i ++ ) { x [ i ] = math . abs ( x [ i ] - median ) ; } double mad = quick select . median ( x ) ; if ( ! ( mad > num ) ) { double min = double . positive infinity ; for ( double xi : x ) { if ( xi > num && xi < min ) { min = xi ; } } if ( min < double . positive infinity ) { mad = min ; } else { mad = num ; } } return mad ; }	compute the median absolute deviation from median .
private static < t > void initialize known plugins ( final t plugin interface , final i < i < t > > registry , final list < plugin config item > xml plugin order , final list < pair < i < t > , plugin status > > validated plugins , final list < pair < i < t > , exception > > initialized plugins , final set < long > processed plugins ) { for ( final plugin config item pt : xml plugin order ) { processed plugins . add ( pt . get guid ( ) ) ; final i < t > plugin = find plugin ( validated plugins , pt . get guid ( ) ) ; if ( plugin != null ) { if ( pt . is load ( ) ) { initialize plugin ( plugin , plugin interface , registry , initialized plugins ) ; } else { registry . add disabled plugin ( plugin , disabled plugin reason . not loaded ) ; } } } }	loads the plugins that are configured in the configuration file .
public static void session stop ( ) { if ( m process == null ) return ; m process . destroy ( ) ; m process = null ; }	stops the superuser session.
public static void keep alive ( final boolean keep alive ) { set property ( str , boolean . to string ( keep alive ) ) ; }	set the ' http.
public static request new upload video request ( session session , file file , callback callback ) throws file not found exception { parcel file descriptor descriptor = parcel file descriptor . open ( file , parcel file descriptor . mode read only ) ; bundle parameters = new bundle ( num ) ; parameters . put parcelable ( file . get name ( ) , descriptor ) ; return new request ( session , my videos , parameters , http method . post , callback ) ; }	creates a new request configured to upload a photo to the user ' s default photo album.
private static byte [ ] read checked bytes ( byte [ ] buffer , int data size ) throws invalid protocol buffer nano exception { checked message wrapper = new checked message ( ) ; message nano . merge from ( wrapper , buffer , num , data size ) ; cr checksum = new cr ( ) ; checksum . update ( wrapper . payload ) ; if ( wrapper . checksum != checksum . get value ( ) ) { throw new invalid protocol buffer nano exception ( str ) ; } return wrapper . payload ; }	unwrap a proto message from a checkedmessage , verifying the checksum .
private multicast socket create socket ( ) throws io { multicast socket sock = new multicast socket ( mcast port ) ; sock . set loopback mode ( bool ) ; if ( sock itf != null ) sock . set interface ( sock itf ) ; if ( sock . get loopback mode ( ) ) u . warn ( log , str + str ) ; sock . join group ( mcast grp ) ; if ( ttl != - num ) sock . set time to live ( ttl ) ; return sock ; }	creates multicast socket and joins multicast group .
protected void check selected subset meta data ( example set meta data subset meta data ) { }	can be overridden to check the selected attributes for compatibility .
private void validate will ( string dest , object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new illegal argument exception ( ) ; } mqtt topic . validate ( dest , bool ) ; }	validates the will fields .
public ber input stream ( input stream in , int initial size ) throws io { this . in = in ; buffer = new byte [ initial size ] ; next ( ) ; if ( length != indefinit length ) { if ( buffer . length < ( length + offset ) ) { byte [ ] new buffer = new byte [ length + offset ] ; system . arraycopy ( buffer , num , new buffer , num , offset ) ; buffer = new buffer ; } } else { is indefined length = bool ; throw new as ( str ) ; } }	creates stream for decoding .
private member next member ( member . type type ) { return new test member ( type , new address ( str , ++ port ) , new address ( str , port + num ) ) ; }	returns the next server address .
protected void encode line suffix ( output stream a stream ) throws io { p stream . println ( ) ; }	encode the suffix that ends every output line.
boolean is system font ( ) { return system font ; }	checks if this is a system font.
public void add to be loaded ( final string url ) { if ( to be loaded == null ) { to be loaded = new array list < string > ( ) ; } if ( string utils . is not blank ( url ) ) { to be loaded . add ( url ) ; } }	this methods allows to indicate if the resource must be obtained.
default document put all ( iterator < field > fields ) { while ( fields . has next ( ) ) { field field = fields . next ( ) ; set value ( field . get name ( ) , field . get value ( ) ) ; } return this ; }	sets on this object all name / value pairs from the supplied object.
public appraise git review client ( repository repo ) { this . repo = repo ; this . author = new person ident ( repo ) ; }	creates a new client for the given git repository .
public root block view ( final boolean root block0 , final byte buffer buf , final checksum utility checker ) throws root block exception { if ( buf == null ) throw new illegal argument exception ( ) ; if ( buf . remaining ( ) != sizeof root block ) { throw new illegal argument exception ( str + sizeof root block + str + buf . remaining ( ) ) ; } this . buf = buf . as read only buffer ( ) ; this . root block0 = root block0 ; switch ( get store type ( ) ) { case rw : { am = new rw ( null ) ; break ; } case worm : { final int offset bits = get offset bits ( ) ; am = new worm address manager ( offset bits ) ; break ; } default : throw new root block exception ( str + get store type ( ) ) ; } if ( checker == null ) { log . warn ( str ) ; } this . checker = checker ; valid ( ) ; }	create a new read - only view from the supplied buffer .
protected soap create soap ( final string method name , final soap request writer ) { final post method method = new post method ( endpoint . to string ( ) ) ; method . set content chunked ( bool ) ; set request headers ( method , method name ) ; final soap request entity = build request entity ( method name , request writer ) ; request entity . set soap ( soap header provider ) ; final soap buffered entity = new soap ( request entity ) ; method . set request entity ( buffered entity ) ; return new soap ( method , request entity ) ; }	create a soap request for the given method name.
@ suppress warnings ( str ) @ test public void inner enum ( ) { class < ? > pc = playing card . class ; list < enum < ? > > include = new array list < > ( ) ; list < enum < ? > > exclude = new array list < > ( ) ; for ( class < ? > c : pc . get declared classes ( ) ) { int mods = c . get modifiers ( ) ; if ( c . is enum ( ) ) { if ( modifier . is public ( mods ) ) { include . add all ( as list ( c . get enum constants ( ) ) ) ; } else { exclude . add all ( as list ( c . get enum constants ( ) ) ) ; } } } set < typed operation > actual = get concrete operations ( pc ) ; assert equals ( str , include . size ( ) + num , actual . size ( ) ) ; for ( enum < ? > e : include ) { assert true ( str + e . name ( ) + str , actual . contains ( create enum operation ( e ) ) ) ; } for ( enum < ? > e : exclude ) { assert false ( str + e . name ( ) + str , actual . contains ( create enum operation ( e ) ) ) ; } }	innerenum tests that reflection.
public string to uri ( ) { char array buffer buffer = new char array buffer ( num ) ; buffer . append ( this . scheme name ) ; buffer . append ( str ) ; buffer . append ( this . hostname ) ; if ( this . port != - num ) { buffer . append ( str ) ; buffer . append ( integer . to string ( this . port ) ) ; } return buffer . to string ( ) ; }	return the host uri , as a string .
public void test wildcards does not need two dots ( ) throws exception { string cert = str + str + str + str + str + str + str + str + str + str + str ; certificate factory cf = certificate factory . get instance ( str ) ; input stream in = new byte array input stream ( cert . get bytes ( str ) ) ; x509 certificate x509 = ( x509 certificate ) cf . generate certificate ( in ) ; my ssl session = new my ssl ( new x509 certificate [ ] { x509 } ) ; hostname verifier verifier = url . get default hostname verifier ( ) ; assert true ( verifier . verify ( str , session ) ) ; }	earlier implementations of android ' s hostname verifier required that wildcard names wouldn ' t match " *.
public static boolean in target dir ( file file ) { return in target dir ( file . to path ( ) ) ; }	verify that the supplied file or directory is within the target directory .
public final boolean skip any ( char c , char sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && ( csq . char at ( i ) == c ) ; i ++ ) { } if ( i == index ) return bool ; index = i ; return bool ; }	moves this cursor forward until it points to a character different from the specified character .
public synchronized boolean remove all ( collection c ) { object [ ] elements = get array ( ) ; int len = elements . length ; if ( len != num ) { int newlen = num ; object [ ] temp = new object [ len ] ; for ( int i = num ; i < len ; ++ i ) { object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set array ( copy of range ( temp , num , newlen , object [ ] . class ) ) ; return bool ; } } return bool ; }	removes from this list all of its elements that are contained in the specified collection.
private final boolean compare and set tail ( node expect , node update ) { return unsafe . compare and swap object ( this , tail offset , expect , update ) ; }	cas tail field . used only by enq .
public phone create phone ( string value ) { phone field phone impl = new phone field ( ) ; try { phone impl . set value ( value ) ; } catch ( sdp exception s ) { s . print stack trace ( ) ; } return phone impl ; }	returns phone object with the specified value .
private list resource bundle load resource bundle ( string resource bundle ) throws missing resource exception { m resource bundle name = resource bundle ; locale locale = get locale ( ) ; list resource bundle lrb ; try { resource bundle rb = resource bundle . get bundle ( m resource bundle name , locale ) ; lrb = ( list resource bundle ) rb ; } catch ( missing resource exception e ) { try { lrb = ( list resource bundle ) resource bundle . get bundle ( m resource bundle name , new locale ( str , str ) ) ; } catch ( missing resource exception e2 ) { throw new missing resource exception ( str + m resource bundle name , m resource bundle name , str ) ; } } m resource bundle = lrb ; return lrb ; }	return a named resourcebundle for a particular locale.
private set < string > return remote pools associated with remote copy settings ( map < string , list < string > > remote copy settings , set < string > pool uris ) { set < string > remote pool uris = new hash set < string > ( ) ; for ( entry < string , list < string > > entry : remote copy settings . entry set ( ) ) { virtual pool v pool = object cache . query object ( virtual pool . class , uri . create ( entry . get key ( ) ) ) ; if ( null == v pool ) { remote pool uris . add all ( pool uris ) ; } else if ( null != v pool . get use matched pools ( ) && v pool . get use matched pools ( ) ) { if ( null != v pool . get matched storage pools ( ) ) { remote pool uris . add all ( v pool . get matched storage pools ( ) ) ; } } else if ( null != v pool . get assigned storage pools ( ) ) { remote pool uris . add all ( v pool . get assigned storage pools ( ) ) ; } } return remote pool uris ; }	choose pools based on remote vpool ' s matched or assigned pools.
private string convert to html ( final string string ) { return str + string . replace all ( str , str ) + str ; }	converts text to html , by transforming \ n to < br / >.
private synchronized void add lock ( file lock lock ) throws overlapping file lock exception { long lock end = lock . position ( ) + lock . size ( ) ; for ( file lock existing lock : locks ) { if ( existing lock . position ( ) > lock end ) { break ; } if ( existing lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new overlapping file lock exception ( ) ; } } locks . add ( lock ) ; }	add a new pending lock to the manager.
public static void u ( double [ ] x , double [ ] f , int nx ) { int count1 = num ; int count2 = num ; double sum1 = num ; double sum2 = num ; double yj ; for ( int j = num ; j <= nx ; j ++ ) { yj = x [ j - num ] - math . sin ( num * pi * x [ num ] + j * pi / nx ) ; if ( j % num == num ) { sum2 += yj * yj ; count2 ++ ; } else { sum1 += yj * yj ; count1 ++ ; } } yj = math . pow ( x [ num ] , num ) ; f [ num ] = yj + num * sum1 / ( double ) count1 ; f [ num ] = num - yj + num * sum2 / ( double ) count2 ; }	evaluates the uf7 problem .
private void reload model with new value ( final long new value ) { final long new value as primitive = new value == null ? get model update period ( ) : new value ; for ( final property change listener listener : model update period listeners ) { final property change event event = new property change event ( this , str , get model update period ( ) , new value as primitive ) ; listener . property change ( event ) ; } }	notify all listeners about cacheperiod property changed.
public static final string move to uci ( move m ) { string ret = square to string ( m . from ) ; ret += square to string ( m . to ) ; switch ( m . promote to ) { case piece . wqueen : case piece . bqueen : ret += str ; break ; case piece . wrook : case piece . brook : ret += str ; break ; case piece . wbishop : case piece . bbishop : ret += str ; break ; case piece . wknight : case piece . bknight : ret += str ; break ; default : break ; } return ret ; }	convert a move object to uci string format .
public image create accelerated image ( component target , int width , int height ) { color model model = get color model ( transparency . opaque ) ; writable raster wr = model . create compatible writable raster ( width , height ) ; return new off screen image ( target , model , wr , model . is alpha premultiplied ( ) ) ; }	creates a new managed image of the given width and height that is associated with the target component .
public void display state ( ) { print writer xout = context . get ( log . out key ) ; xout . println ( str + file object history ) ; xout . println ( str + open type names ) ; xout . println ( str + generated source names ) ; xout . println ( str + generated classes . key set ( ) ) ; xout . println ( str + aggregate generated source names ) ; xout . println ( str + aggregate generated class names ) ; }	debugging function to display internal state .
public static void write string to writer ( string string , writer writer ) throws io { buffered writer bw = new buffered writer ( writer ) ; try { bw . write ( string ) ; } finally { bw . close ( ) ; } }	writes given string to given writer.
private void ensure capacity ( int n ) { if ( n <= num ) { return ; } int max ; if ( data == null || data . length == num ) { max = num ; } else if ( data . length >= n * num ) { return ; } else { max = data . length ; } while ( max < n * num ) { max *= num ; } string new data [ ] = new string [ max ] ; if ( length > num ) { system . arraycopy ( data , num , new data , num , length * num ) ; } data = new data ; }	ensure the internal array ' s capacity .
public final void dec ref ( ) throws io { ensure open ( ) ; final int rc = ref count . decrement and get ( ) ; if ( rc == num ) { boolean success = bool ; try { do close ( ) ; closed = bool ; success = bool ; } finally { if ( ! success ) { ref count . increment and get ( ) ; } } } else if ( rc < num ) { throw new illegal state exception ( str + rc + str ) ; } }	expert : decreases the refcount of this taxonomyreader instance.
public static x500 name x500 principal to x500 name ( x500 principal principal ) { return x500 name . get instance ( kse x500 name style . instance , principal . get encoded ( ) ) ; }	convert an x . 500 principal to an x . 500 name .
private void assert described resource ( final bigdata value described resource , final i describe cache , final test helper h ) { final graph actual graph = describe cache . lookup ( described resource . get iv ( ) ) ; assert not null ( actual graph ) ; final set < statement > expected graph = get expected description ( described resource , h ) ; h . compare graphs ( new hash set < statement > ( actual graph ) , expected graph ) ; for ( statement stmt : actual graph ) { assert true ( stmt instanceof bigdata statement ) ; final bigdata statement st = ( bigdata statement ) stmt ; assert not null ( st . s ( ) ) ; assert not null ( st . p ( ) ) ; assert not null ( st . o ( ) ) ; if ( st . get context ( ) != null ) { assert not null ( st . c ( ) ) ; } } }	assert that a resource is described by the cache .
public boolean is flat ( ) { return type flat . equals ( get type ( ) ) ; }	flat background type ( default ).
@ deprecated private list < char sequence > build limited networks list ( ) { final context context = get activity ( ) ; final array list < char sequence > limited = lists . new array list ( ) ; if ( has subscription ( context ) ) { final string subscriber id = get active subscriber id ( context ) ; if ( m policy editor . has limited policy ( build template mobile all ( subscriber id ) ) ) { limited . add ( get text ( r . string . data usage list mobile ) ) ; } if ( m policy editor . has limited policy ( build template mobile3g lower ( subscriber id ) ) ) { limited . add ( get text ( r . string . data usage tab 3g ) ) ; } if ( m policy editor . has limited policy ( build template mobile4g ( subscriber id ) ) ) { limited . add ( get text ( r . string . data usage tab 4g ) ) ; } } if ( m policy editor . has limited policy ( build template wifi wildcard ( ) ) ) { limited . add ( get text ( r . string . data usage tab wifi ) ) ; } if ( m policy editor . has limited policy ( build template ethernet ( ) ) ) { limited . add ( get text ( r . string . data usage tab ethernet ) ) ; } return limited ; }	build list of currently limited networks , which defines when background data is restricted .
public int eval rpn ( string [ ] tokens ) { if ( tokens == null || tokens . length == num ) return num ; stack < string > s = new stack < string > ( ) ; int len = tokens . length ; for ( int i = num ; i < len ; i ++ ) { string cur = tokens [ i ] ; if ( is operator ( cur ) ) { int t2 = integer . parse int ( s . pop ( ) ) ; int t1 = integer . parse int ( s . pop ( ) ) ; int res = calculate ( t1 , t2 , cur ) ; s . push ( integer . to string ( res ) ) ; } else s . push ( cur ) ; } return integer . value of ( s . peek ( ) ) ; }	assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack.
public synchronized void add all series ( list < xy > series ) { m series . add all ( series ) ; }	adds all the provided xy series to the list .
private static void exit ( string err msg , options options , int exit code ) { if ( err msg != null ) echo ( str + err msg ) ; string runner = system . get property ( ignite prog name , str ) ; int space = runner . index of ( str ) ; runner = runner . substring ( num , space == - num ? runner . length ( ) : space ) ; if ( options != null ) { help formatter formatter = new help formatter ( ) ; formatter . print help ( runner , options ) ; } system . exit ( exit code ) ; }	exists with optional error message , usage show and exit code .
@ override public int compare ( new split emitted term term1 , new split emitted term term2 ) { return term1 . compare to ( term2 ) ; }	compares term key 1 to term key 2.
public aabb merge ( aabb other ) { min x = math . min ( min x , other . min x ) ; max x = math . max ( max x , other . max x ) ; min y = math . min ( min y , other . min y ) ; max y = math . max ( max y , other . max y ) ; min z = math . min ( min z , other . min z ) ; max z = math . max ( max z , other . max z ) ; return this ; }	computes an aabb that contains both this and other and stores it in this .
public static string generate auto tag ( int stack offset ) { stack trace element [ ] current stack = get current stack ( ) ; stack trace element element = current stack [ stack offset ] ; string class name = element . get class name ( ) ; string pkg path [ ] = class name . split ( str ) ; if ( pkg path . length > num ) { class name = pkg path [ pkg path . length - num ] ; } string builder sb inner class = new string builder ( ) ; int index ; string str loop = class name ; while ( ( index = str loop . last index of ( str ) ) != - num ) { string piece = str loop . substring ( index + num ) ; sb inner class . insert ( num , piece ) ; if ( ! piece . matches ( str ) ) { break ; } sb inner class . insert ( num , str ) ; str loop = str loop . substring ( num , index ) ; } if ( sb inner class . length ( ) > num && sb inner class . char at ( num ) == str ) { sb inner class . delete char at ( num ) ; } string inner class name = sb inner class . to string ( ) ; if ( text utils . is digits only ( inner class name ) ) { inner class name = null ; } return text utils . is empty ( inner class name ) ? class name : inner class name ; }	generate auto tag for logs .
public void flush pending ( ) throws sax { if ( m need to call start document ) { start document internal ( ) ; m need to call start document = bool ; } if ( m elem context . m start tag open ) { close start tag ( ) ; m elem context . m start tag open = bool ; } if ( m cdata tag open ) { close cdata ( ) ; m cdata tag open = bool ; } if ( m writer != null ) { try { m writer . flush ( ) ; } catch ( io e ) { } } }	this method flushes any pending events , which can be startdocument ( ) closing the opening tag of an element , or closing an open cdata section .
@ post construct public void init ( ) { configuration views . add ( default distribution set type layout ) ; configuration views . add ( authentication configuration view ) ; configuration views . add ( polling configuration view ) ; }	init method adds all configuration views to the list of views .
public extended type ( int nodetype , string namespace , string local name ) { this . nodetype = nodetype ; this . namespace = namespace ; this . local name = local name ; this . hash = nodetype + namespace . hash code ( ) + local name . hash code ( ) ; }	create an extendedtype object from node type , namespace and local name.
private static void validate new addition ( vector paths , expression owner owner , loc path iterator path ) throws runtime exception { assertion ( owner . get expression ( ) == path , str ) ; int n = paths . size ( ) ; for ( int i = num ; i < n ; i ++ ) { expression owner ew = ( expression owner ) paths . element at ( i ) ; assertion ( ew != owner , str ) ; assertion ( ew . get expression ( ) != path , str ) ; } }	validate some assumptions about the new locpathiterator and it ' s owner and the state of the list .
@ override public void start ( ) { for ( int i = num ; i < thread count ; ++ i ) { set < system stream partition > thread ssps = new hash set < system stream partition > ( ) ; for ( system stream partition ssp : ssps ) { if ( math . abs ( ssp . hash code ( ) ) % thread count == i ) { thread ssps . add ( ssp ) ; } } thread thread = new thread ( new mock system consumer runnable ( thread ssps ) , str + i ) ; thread . set daemon ( bool ) ; threads . add ( thread ) ; thread . start ( ) ; } }	assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .
public void undo ( ) { try { if ( undo manager != null ) undo manager . undo or redo ( ) ; } catch ( cannot undo exception ignored ) { } catch ( cannot redo exception ignored ) { } }	undoes the last action .
public void remove column ( column column ) { if ( column != null ) { columns . remove ( column ) ; } }	removes the given column .
public string info ( ) { string builder sb = new string builder ( str + table size + str + elements + str + load factor + str + threshold ) ; sb . append ( str + num empty ) ; int size = num ; int min = elements ; int max = - num ; for ( int i = num ; i < table size ; i ++ ) { linked list < string > list = bins [ i ] ; if ( list != null ) { int sz = list . size ( ) ; size += sz ; if ( sz < min ) { min = sz ; } if ( sz > max ) { max = sz ; } } } float avg = size ; int base = ( table size - num empty ) ; if ( base == num ) { sb . append ( str ) ; sb . append ( str ) ; sb . append ( str ) ; } else { avg /= base ; sb . append ( str + avg ) ; sb . append ( str + min ) ; sb . append ( str + max ) ; } return sb . to string ( ) ; }	return single line of output .
public boolean peek sample ( media codec . buffer info out buffer info ) { update ( ) ; boolean result = bool ; if ( ! m available output buffers . is empty ( ) ) { int index = m available output buffers . peek ( ) ; media codec . buffer info info = m output buffer info [ index ] ; out buffer info . set ( info . offset , info . size , info . presentation time us , info . flags ) ; result = bool ; } return result ; }	performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i.
@ override public abstract scanned result scan blocklet ( blocks chunk holder blocks chunk holder ) throws query execution exception { try { fill scanned result ( blocks chunk holder ) ; } catch ( filter unsupported exception e ) { throw new query execution exception ( e . get message ( ) ) ; } return scanned result ; }	below method will be used to process the block.
@ override public int hash code ( ) { return subconditions . hash code ( ) - operator . hash code ( ) ; }	returns the hashcode for the condition.
public void balance segments ( ) { m [ ] elements = m acct schema . get acct schema elements ( ) ; for ( int i = num ; i < elements . length ; i ++ ) { m ase = elements [ i ] ; if ( ase . is balanced ( ) ) balance segment ( ase . get element type ( ) ) ; } }	balance all segments . - for all balancing segments - for all segment values - if balance < > 0 create dueto / duefrom line overwriting the segment value.
public annotation drawer ( final annotations model model , final process renderer model renderer model ) { this . model = model ; this . renderer model = renderer model ; this . display cache = new hash map < > ( ) ; this . cached id = new hash map < > ( ) ; pane = new j ( str , str ) ; pane . set border ( null ) ; pane . set opaque ( bool ) ; }	creates a new drawer for the specified model and decorator .
public boolean has user partitions ( ) { return ! user output . is empty ( ) ; }	retrieves if user partitions are present.
@ override public void insert string ( final int offs , final string str , final attribute set attr ) { if ( offs < num ) { return ; } if ( str . length ( ) > num ) { int i ; for ( i = num ; i < str . length ( ) ; i ++ ) { if ( str . char at ( i ) == str ) { remaining text string = str . substring ( i + num ) ; remaining text attr = attr ; input key listener . key pressed ( new key event ( new container ( ) , key event . key pressed , num , num , key event . vk enter , str ) ) ; break ; } else { insert char ( offs + i , str + str . char at ( i ) ) ; } } } else if ( str . length ( ) == num ) { insert char ( offs , str ) ; } }	insert a string of source code to be highlighted to the document.
protected int read code point ( ) throws io { int next = reader . read ( ) ; if ( character . is high surrogate ( ( char ) next ) ) { next = character . to code point ( ( char ) next , ( char ) reader . read ( ) ) ; } return next ; }	reads the next unicode code point .
public static int put int ( byte [ ] bytes , int offset , int val ) { if ( little endian ) { val = integer . reverse bytes ( val ) ; } the unsafe . put int ( bytes , offset + byte array base offset , val ) ; return offset + bytes . sizeof int ; }	put an int value out to the specified byte array position in big - endian format .
public item ( drawable symbol , string label text , font font ) { double font size = font . get size2 d ( ) ; set layout ( new edge layout ( font size , num ) ) ; this . symbol = symbol ; add ( symbol , location . west ) ; label = new label ( label text ) ; label . set font ( font ) ; label . set alignment x ( num ) ; label . set alignment y ( num ) ; add ( label , location . center ) ; }	creates a new item object with the specified data source and text .
void tag ( string tag ) ;	set a one - time tag for use on the next logging call .
public int consume ( ) { int consumed amount ; if ( math . abs ( left ) < math . abs ( get regen ( ) ) ) { consumed amount = left ; left = num ; } else { consumed amount = get regen ( ) ; left -= get regen ( ) ; } return consumed amount ; }	consumes a part of this item .
public from clause add ( outer join qualifier outer join qualifier ) { outer join qualifiers . add ( outer join qualifier ) ; return this ; }	adds an outer join descriptor that defines how the streams are related via outer joins.
private static final file [ ] encode ( string src ) { if ( src == null || src . length ( ) == num ) { return ( new file [ num ] ) ; } string tokenizer tokenizer = new string tokenizer ( src , str ) ; file [ ] dirs = new file [ tokenizer . count tokens ( ) ] ; for ( int i = num ; i < dirs . length ; i ++ ) { dirs [ i ] = new file ( tokenizer . next token ( ) ) ; } return dirs ; }	splits the string into an array.
public e poll ( long timeout , time unit unit ) throws interrupted exception { long nanos = unit . to nanos ( timeout ) ; final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; long t = now ( ) ; tenant queue . item item = null ; try { for ( ; ; ) { tenant queue q = next queue ( t ) ; if ( q == null ) { if ( nanos <= num ) return null ; else nanos = available . await nanos ( nanos ) ; } else { long delay = q . next - t ; if ( delay <= num ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } if ( nanos <= num ) return null ; if ( nanos < delay || leader != null ) nanos = available . await nanos ( nanos ) ; else { thread this thread = thread . current thread ( ) ; leader = this thread ; try { long time left = available . await nanos ( delay ) ; nanos -= delay - time left ; } finally { if ( leader == this thread ) leader = null ; } } } t = system . nano time ( ) ; } } finally { if ( leader == null && has next ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .
public void add swipe listener ( swipe listener listener ) { if ( m listeners == null ) { m listeners = new array list < swipe listener > ( ) ; } m listeners . add ( listener ) ; }	add a callback to be invoked when a swipe event is sent to this view .
public int size ( ) { return patterns . size ( ) ; }	size of the cluster .
public static void write uint8 ( output stream the os , int the value ) throws io { the os . write ( the value ) ; }	writes a " uint8 " in wsp format to the given output stream .
public void test case11 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , num , num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add two numbers of different length and sign.
@ override public void add header ( final string header , final string value ) { m headers options . add ( new header option ( header , value ) ) ; }	adds a header to this request .
public void store ( ) throws saml { try { key provider . store ( ) ; } catch ( key store exception e ) { throw new saml ( e . get message ( ) ) ; } catch ( certificate exception e ) { throw new saml ( e . get message ( ) ) ; } catch ( no such algorithm exception e ) { throw new saml ( e . get message ( ) ) ; } catch ( io e ) { throw new saml ( e . get message ( ) ) ; } }	store the keystore changes.
static void append to pointer hierarchy ( final base type type , final base type pointer ) { preconditions . check not null ( type , str ) ; preconditions . check not null ( pointer , str ) ; preconditions . check argument ( type != pointer , str ) ; preconditions . check argument ( pointer . pointed to by != type , str ) ; preconditions . check argument ( type . points to != pointer , str ) ; pointer . points to = type ; type . pointed to by = pointer ; }	appends a base type to the pointer hierarchy just below parent , e.
public static void sort ( long [ ] a ) { do sort ( a , num , a . length - num ) ; }	sorts the specified array into ascending numerical order .
public string to string ( ) { return str + string . format ( str , value similarity * num ) + str + string . format ( str , containment similarity * num ) + str + string . format ( str , size similarity * num ) ; }	return a string representation of this object , describing all aspects of similarity .
public optional < t > last ( ) { iterator < t > iterator = iterator ( ) ; t value = null ; while ( iterator . has next ( ) ) value = iterator . next ( ) ; return optional . of ( value ) ; }	convert an iterable stream into one last item of the stream .
public static void thread sleep ( long millis ) { try { thread . sleep ( millis ) ; } catch ( interrupted exception ex ) { log . e ( str , string utils . exception stack trace to string ( ex ) ) ; } }	makes the thread sleep for some time.
public int index of ( node elem , int index ) { run to ( - num ) ; if ( null == m map ) return - num ; for ( int i = index ; i < m first free ; i ++ ) { node node = m map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - num ; }	searches for the first occurence of the given argument , beginning the search at index , and testing for equality using the equals method .
static boolean is package access ( final int modifiers ) { return ( modifiers & access test ) == num ; }	returns whether a given set of modifiers implies package access .
public void write ( final string filename ) { print stream stream ; try { stream = new print stream ( new file ( filename ) ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; return ; } write ( stream ) ; stream . close ( ) ; }	writes the gathered data tab - separated into a text file .
managed window decorator ( window window , string window id ) { this . window = window ; name = str + window id ; }	create a managed window decorator with an identity for a window .
@ override public void write ( byte [ ] b , int off , int len ) throws io { while ( len > num ) { int c = math . min ( len , decoder in . remaining ( ) ) ; decoder in . put ( b , off , c ) ; process input ( bool ) ; len -= c ; off += c ; } if ( write immediately ) { flush output ( ) ; } }	write bytes from the specified byte array to the stream .
public static void log ( string message , object ... args ) { if ( logging enabled ) { log . d ( tag , args . length == num ? message : string . format ( message , args ) ) ; } }	send a log message if logging is enabled .
protected void process updates ( queue < device update > updates ) { if ( updates == null ) return ; device update update = null ; while ( null != ( update = updates . poll ( ) ) ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str , update ) ; } if ( update . change == device update . change . delete ) { device sync manager . remove device ( update . device ) ; } else { device sync manager . store device ( update . device ) ; } list < i > listeners = device listeners . get ordered listeners ( ) ; notify listeners ( listeners , update ) ; } }	send update notifications to listeners.
boolean handle remote can rebalance ( long size ) { return bool ; }	checks if this partitionedregiondatastore has the capacity to handle the rebalancing size .
public static file to sld ( final file file ) { final string path = file . get absolute path ( ) ; final string base = path . substring ( num , path . length ( ) - num ) ; string new path = base + str ; file sld = new file ( new path ) ; if ( sld . exists ( ) ) { return sld ; } new path = base + str ; sld = new file ( new path ) ; if ( sld . exists ( ) ) { return sld ; } return null ; }	figure out if a valid sld file is available .
private string insert properties ( string template , map < string , string > properties ) { for ( entry < string , string > entry : properties . entry set ( ) ) { template = template . replace ( entry . get key ( ) , entry . get value ( ) ) ; } return template ; }	inserts properties to the template .
public static void change font ( j comp , int style ) { font font = comp . get font ( ) ; comp . set font ( font . derive font ( style ) ) ; }	change the font style of a component.
public void draw contours ( mat img , color color ) { drawing . draw contours ( img , contours , color ) ; }	draw contours matched by the blob detector.
public static void save x509 cert ( string cert str , file cert file ) throws io { buffered writer writer = new buffered writer ( new file writer ( cert file ) ) ; writer . write ( begin cert ) ; writer . new line ( ) ; writer . write ( cert str ) ; writer . new line ( ) ; writer . write ( end cert ) ; writer . new line ( ) ; writer . close ( ) ; }	save a certificate to a file in base 64 binary format with begin and end strings.
public void clear on central position changed listener ( ) { m on central position changed listeners . clear ( ) ; }	clear all listeners that listening the central item of the list changes event .
public static object invoke static ( class clazz , string method name ) throws no such method exception { try { method method = clazz . get method ( method name , new class [ num ] ) ; object result = method . invoke ( null , new object [ num ] ) ; return result ; } catch ( illegal access exception e ) { throw new no such method exception ( method name + str ) ; } catch ( invocation target exception e ) { throw new internal error ( e . get message ( ) ) ; } }	invokes the specified accessible parameterless method if it exists .
@ deprecated public boolean is fill below line ( ) { return m fill below line . size ( ) > num ; }	returns if the chart should be filled below the line .
public void on patch service result ( boolean is upgrade patch ) { if ( ! is retry enable ) { tinker log . w ( tag , str ) ; return ; } if ( ! is upgrade patch ) { tinker log . w ( tag , str ) ; return ; } if ( retry info file . exists ( ) ) { share patch file util . safe delete file ( retry info file ) ; } if ( temp patch file . exists ( ) ) { share patch file util . safe delete file ( temp patch file ) ; } }	if we receive any result , we can delete the temp retry info file.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return note id ; case num : return class name ; case num : return interpreter context ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static boolean is stanza ( packet packet ) { if ( packet instanceof message ) return bool ; if ( packet instanceof iq ) return bool ; if ( packet instanceof presence ) return bool ; return bool ; }	returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .
@ override public int execute ( final form object form , final int type , final string code , final int event type , final char key pressed ) { int message code = action handler . nomessage ; if ( code instanceof string ) { final string js = code ; final string [ ] args = js . convert to array ( js ) ; final string command = args [ num ] ; if ( command . starts with ( str ) ) { message code = handle af ( form , command , js , args , event type , key pressed ) ; } } return message code ; }	execute javascript and reset forms values.
private boolean needs update ( long bundle version , string bean version ) { if ( bean version . contains ( str ) ) { log . i ( tag , str + bundle version ) ; log . i ( tag , str + bean version ) ; return bool ; } else { try { long parsed version = long . parse long ( bean version . split ( str ) [ num ] ) ; log . i ( tag , str + bundle version ) ; log . i ( tag , str + parsed version ) ; if ( bundle version > parsed version ) { return bool ; } else { log . i ( tag , str ) ; } } catch ( number format exception e ) { log . e ( tag , str + bean version ) ; fail ( bean error . unparsable fw version ) ; } } return bool ; }	helper function to determine whether a bean needs a fw update given a specific bundle version.
public void clear ( faces context faces context , map < string , object > view map ) { if ( logger . is loggable ( level . finest ) ) { logger . log ( level . finest , str ) ; } map < string , view scope context object > context map = get context map ( faces context , view map ) ; if ( context map != null ) { destroy beans ( view map , context map ) ; } }	clear the given view map .
public void load logical tables with granularities ( map < string , table group > name group map , set < ? extends granularity > valid grains , resource dictionaries dictionaries ) { for ( map . entry < string , table group > entry : name group map . entry set ( ) ) { string logical table name = entry . get key ( ) ; table group group = entry . get value ( ) ; load logical table with granularities ( logical table name , group , valid grains , dictionaries ) ; } }	load several logical tables into the logicaldictionary.
protected int read block ( ) { block size = read ( ) ; int n = num ; if ( block size > num ) { try { int count = num ; while ( n < block size ) { count = in . read ( block , n , block size - n ) ; if ( count == - num ) break ; n += count ; } } catch ( io e ) { } if ( n < block size ) { status = status format error ; } } return n ; }	reads next variable length block from input .
@ override public void add new subscription ( final subscription new subscription ) { final string client id = new subscription . get client id ( ) ; list < client topic couple > client subscriptions = subscriptions . get ( client id ) ; if ( client subscriptions == null ) { client subscriptions = new array list < > ( ) ; subscriptions . put ( client id , client subscriptions ) ; } client subscriptions . add ( new subscription . as client topic couple ( ) ) ; }	add a new subscription to the session .
public x509 cert path impl ( list < ? extends java . security . cert . certificate > certs ) throws certificate exception { super ( str ) ; final int size = certs . size ( ) ; certificates = new array list < x509 certificate > ( size ) ; for ( int i = num ; i < size ; i ++ ) { final java . security . cert . certificate cert = certs . get ( i ) ; if ( ! ( cert instanceof x509 certificate ) ) { throw new certificate exception ( str + i + str ) ; } certificates . add ( ( x509 certificate ) cert ) ; } }	creates an instance of x.
public process ( final string xml string ) throws io , xml { init context ( ) ; string reader in = new string reader ( xml string ) ; read process ( in ) ; in . close ( ) ; }	reads an process configuration from an xml string .
public consul topology fraction ( ) { this . url = default url ; }	construct a default fraction using the default agent url of http : / / localhost : 8500 / .
protected string build qualifier regex ( string qualifier value ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( qualifier value ) ; sb . append ( str ) ; return sb . to string ( ) ; }	just used for like and not_like.
public string shorten name ( string name , int desired length ) { int original length = name . length ( ) ; if ( ( desired length <= num ) || ( original length <= desired length ) ) { return name ; } int delta = original length - desired length ; int start cut = desired length / num ; string buffer result = new string buffer ( ) ; result . append ( name . substring ( num , start cut ) ) ; if ( ( ( start cut == num ) || ( name . char at ( start cut - num ) != str ) ) && ( ( start cut + delta + num == original length ) || ( name . char at ( start cut + delta + num ) != str ) ) ) { result . append ( str ) ; } result . append ( name . substring ( start cut + delta + num , original length ) ) ; return result . to string ( ) ; }	generates a version of the name that has at most the specified length .
public static color blend ( color color1 , color color2 , double weight ) { double w2 = math utils . limit ( weight , num , num ) ; double w1 = num - w2 ; int r = ( int ) math . round ( w1 * color1 . get red ( ) + w2 * color2 . get red ( ) ) ; int g = ( int ) math . round ( w1 * color1 . get green ( ) + w2 * color2 . get green ( ) ) ; int b = ( int ) math . round ( w1 * color1 . get blue ( ) + w2 * color2 . get blue ( ) ) ; int a = ( int ) math . round ( w1 * color1 . get alpha ( ) + w2 * color2 . get alpha ( ) ) ; return new color ( r , g , b , a ) ; }	linearly blends two colors with a defined weight .
public long kstkeip ( ) { return long . parse long ( fields [ num ] ) ; }	the current eip ( instruction pointer ) .
private void decide ui ( main options options ) { try { boolean system plaf = bool ; system plaf = options . system plaf ; string system plaf req = system . getenv ( str ) ; if ( system plaf req != null && system plaf req . equals ignore case ( str ) ) system plaf = bool ; if ( system plaf ) ui . set look and feel ( ui . get system look and feel class name ( ) ) ; } catch ( exception exc ) { exc . print stack trace ( ) ; } }	normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel.
public static buffered image to buffered image ( image img , int type ) { if ( img instanceof buffered image ) { return ( buffered image ) img ; } buffered image bimage = new buffered image ( img . get width ( null ) , img . get height ( null ) , type ) ; d b gr = bimage . create graphics ( ) ; b gr . draw image ( img , num , num , null ) ; b gr . dispose ( ) ; return bimage ; }	converts a given image into a bufferedimage.
private json read array ( ) throws json { json result = new json ( ) ; boolean has trailing separator = bool ; while ( bool ) { switch ( next clean internal ( ) ) { case - num : throw syntax error ( str ) ; case str : if ( has trailing separator ) { result . put ( null ) ; } return result ; case str : case str : result . put ( null ) ; has trailing separator = bool ; continue ; default : pos -- ; } result . put ( next value ( ) ) ; switch ( next clean internal ( ) ) { case str : return result ; case str : case str : has trailing separator = bool ; continue ; default : throw syntax error ( str ) ; } } }	reads a sequence of values and the trailing closing brace ' ] ' of an array.
public list < node > list available terminals ( class < ? > type ) { list < node > result = new array list < node > ( ) ; for ( node node : available nodes ) { if ( ( node . get number of arguments ( ) == num ) && type . is assignable from ( node . get return type ( ) ) ) { result . add ( node ) ; } } return result ; }	returns the list of all available terminal nodes with the given return type .
public void remove sensor selection listener ( sensor selection listener listener ) { listener list . remove ( sensor selection listener . class , listener ) ; }	remove the specified sensor selection listener .
public void write ( int c ) throws io { if ( output == null ) throw new io ( str ) ; output . append ( ( char ) c ) ; }	writes the 16 low - order bits of the given integer value ; the 16 high - order bits are ignored .
private static void test dex class loader ( ) { class loader dex class loader = get dex class loader ( ) ; class another class ; try { another class = dex class loader . load class ( str ) ; } catch ( class not found exception cnfe ) { throw new runtime exception ( str ) ; } object another ; try { another = another class . new instance ( ) ; } catch ( illegal access exception ie ) { throw new runtime exception ( str , ie ) ; } catch ( instantiation exception ie ) { throw new runtime exception ( str , ie ) ; } dex class loader . get resource ( str ) ; }	create a class loader , explicitly specifying the source dex and the location for the optimized dex .
public void register ( grid cache ttl manager mgr ) { synchronized ( mux ) { if ( cleanup worker == null ) start cleanup worker ( ) ; mgrs . add ( mgr ) ; } }	register ttl manager of cache for periodical check on expired entries .
public static java . sql . time to sql time ( int hour , int minute , int second ) { java . util . date new date = to date ( num , num , num , hour , minute , second ) ; if ( new date != null ) { return new java . sql . time ( new date . get time ( ) ) ; } else { return null ; } }	makes a java . sql . time from separate ints for hour , minute , and second .
public void initialize key store ( ) { try { logger logger = ( com . sun . identity . log . logger ) logger . get logger ( log name ) ; reset current file list ( log name ) ; add to current file list ( log name , log name , log name ) ; string log path = lmanager . get property ( log constants . log location ) ; if ( ! log path . ends with ( str ) ) log path += str ; string file name = log name ; string logger file name = log path + prefix + str + file name ; string verifier file name = log path + prefix + str + file name ; debug . message ( log name + str + logger file name ) ; debug . message ( log name + str + verifier file name ) ; helper . initialize secure log helper ( logger file name , log password , verifier file name , log password ) ; debug . message ( log name + str ) ; helper . initialize verifier ( verifier file name , log password , ver password ) ; debug . message ( log name + str ) ; } catch ( exception e ) { debug . error ( log name + str , e ) ; } }	initialize logger key store.
private native byte [ ] image data to platform image bytes ( byte [ ] image data , int width , int height , long format ) ;	returns a byte array which contains data special for the given format and for the given image data .
public static string clean folder stacking markers ( string filename ) { if ( ! string utils . is empty ( filename ) ) { matcher m = folder stacking pattern . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( num ) + m . group ( num ) ; } } return filename ; }	clean stacking markers . < br > same logic as detection , but just returning string w / o.
public void discard ( service registrar reg ) { synchronized ( registrars ) { if ( terminated ) { throw new illegal state exception ( str ) ; } if ( reg == null ) return ; send discarded ( reg , null ) ; } }	discard a registrar from the set of registrars already discovered.
public boolean is final state ( int state ) { return ( state < num ) ? bool : f final state flags [ state ] ; }	check whether the given state is one of the final states.
public static string generate scale markers ( int protein length , int max num scale markers ) { if ( max num scale markers < num ) { max num scale markers = num ; } int scale = calc scale ( protein length , max num scale markers ) ; string builder sb = new string builder ( str ) ; int index = num ; int num remaining = protein length ; while ( index <= protein length ) { index += scale ; num remaining -= scale ; sb . append ( str ) ; if ( ( num remaining > num ) && ( num remaining < scale ) ) { if ( num remaining < ( scale / num ) ) { sb . append ( protein length ) ; break ; } } if ( index >= protein length ) { sb . append ( protein length ) ; } else { sb . append ( index ) ; } } return sb . to string ( ) ; }	generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .
public void write fig tree block ( map < string , object > settings ) throws io { writer . println ( str ) ; for ( string key : settings . key set ( ) ) { object value = settings . get ( key ) ; writer . println ( str + key + str + create string ( value ) + str ) ; } writer . println ( str ) ; }	writes a ' figtree ' block .
public int hash code ( ) { return font . hash code ( ) ^ glyphs . length ; }	as a concrete subclass of object that implements equality , this must implement hashcode .
public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( obj instanceof map == bool ) { return bool ; } map map = ( map ) obj ; if ( map . size ( ) != size ( ) ) { return bool ; } map iterator it = map iterator ( ) ; try { while ( it . has next ( ) ) { object key = it . next ( ) ; object value = it . get value ( ) ; if ( value == null ) { if ( map . get ( key ) != null || map . contains key ( key ) == bool ) { return bool ; } } else { if ( value . equals ( map . get ( key ) ) == bool ) { return bool ; } } } } catch ( class cast exception ignored ) { return bool ; } catch ( null pointer exception ignored ) { return bool ; } return bool ; }	compares this map with another .
@ override public void doctype decl ( string root element , string public id , string system id , augmentations augs ) throws xni { f in dtd = bool ; try { if ( f lexical handler != null ) { f lexical handler . start dtd ( root element , public id , system id ) ; } } catch ( sax e ) { throw new xni ( e ) ; } if ( f decl handler != null ) { f declared attrs = new symbol hash ( ) ; } }	notifies of the presence of the doctype line in the document .
public void write exif ( byte [ ] jpeg , string exif out file name ) throws file not found exception , io { if ( jpeg == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = null ; try { s = get exif writer stream ( exif out file name ) ; s . write ( jpeg , num , jpeg . length ) ; s . flush ( ) ; } catch ( io e ) { close silently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .
public void clean start ( ) { connection conn = get connection ( bool , bool ) ; if ( conn == null ) throw new illegal state exception ( str ) ; drop database ( conn ) ; create user ( conn ) ; create database ( conn ) ; try { if ( conn != null ) conn . close ( ) ; } catch ( sql e2 ) { log . log ( level . severe , str , e2 ) ; } conn = null ; }	clean start - drop & re - create db.
static template model exception new method arg invalid value exception ( string method name , int arg idx , object ... details ) { return new template model exception ( method name , str , integer . value of ( arg idx + num ) , str , details ) ; }	the type of the argument was good , but it ' s value wasn ' t .
public static byte [ ] compress for zlib ( string string to compress ) { byte [ ] return values = null ; try { return values = compress for zlib ( string to compress . get bytes ( str ) ) ; } catch ( unsupported encoding exception uee ) { uee . print stack trace ( ) ; } return return values ; }	zlib compress 2 byte.
private void load map ( string extension , string mime type ) { if ( ! mime type to extension map . contains key ( mime type ) ) { mime type to extension map . put ( mime type , extension ) ; } extension to mime type map . put ( extension , mime type ) ; if ( is image type ( mime type ) ) { image mime type set . add ( mime type ) ; } }	load an entry into the map .
public void start dtd ( string name , string public id , string system id ) throws org . xml . sax . sax { }	report the start of dtd declarations , if any.
private string convert timestamp ( ) { string result = timestamp format . replace all ( valid dateformat char pattern + str , str ) ; result = result . replace all ( pattern . quote ( str ) , str ) ; return result ; }	helper method that will convert timestamp format to a pattern.
public static string encode ( byte [ ] bytes ) { int len = bytes . length ; final string buffer encoded = new string buffer ( ( len + num ) / num * num ) ; int i = num ; int j = len ; while ( j >= num ) { encoded . append ( to64 ( ( ( ( bytes [ i ] & num ) << num ) | ( int ) ( ( bytes [ i + num ] & num ) << num ) | ( int ) ( bytes [ i + num ] & num ) ) , num ) ) ; i += num ; j -= num ; } if ( j == num ) { encoded . append ( to64 ( ( ( bytes [ i ] & num ) << num ) | ( ( bytes [ i + num ] & num ) ) , num ) ) ; } if ( j == num ) { encoded . append ( to64 ( ( ( bytes [ i ] & num ) ) , num ) ) ; } return encoded . to string ( ) ; }	encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .
final public void print ( double v ) { writer out = this . out ; if ( out == null ) return ; try { string s = string . value of ( v ) ; out . write ( s , num , s . length ( ) ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a double followed by a newline .
public string to string ( ) { string buffer result = new string buffer ( ip address . to string ( ) ) ; result . append ( str ) ; result . append ( extended network prefix ) ; return result . to string ( ) ; }	convert the ip range into a string representation .
private static boolean contains chroot ( string zk host ) { return zk host . contains ( str ) ; }	validates if zkhost contains a chroot.
public static void on database ( mongo client client , string db name , consumer < mongo database > db operation ) { if ( contains ( client . list database names ( ) , db name ) ) { db operation . accept ( client . get database ( db name ) ) ; } }	perform the given operation on the database with the given name , only if that database exists .
protected int create hash code ( ) { int result = uri . hash code ( ) ^ prefix . hash code ( ) ; if ( result == num ) { result = num ; } return result ; }	factory method to create the hashcode allowing derived classes to change the behaviour.
public static placeholder fragment new instance ( int section number ) { placeholder fragment fragment = new placeholder fragment ( ) ; bundle args = new bundle ( ) ; args . put int ( arg section number , section number ) ; fragment . set arguments ( args ) ; return fragment ; }	returns a new instance of this fragment for the given section number .
public string import trl ( string directory , int ad id , string ad , string trl table ) { string file name = directory + file . separator + trl table + str + ad + str ; log . info ( file name ) ; file in = new file ( file name ) ; if ( ! in . exists ( ) ) { string msg = str + file name ; log . log ( level . severe , msg ) ; return msg ; } try { translation handler handler = new translation handler ( ad id ) ; sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; parser . parse ( in , handler ) ; log . info ( str + handler . get update count ( ) ) ; return msg . get msg ( m ctx , str ) + str + handler . get update count ( ) ; } catch ( exception e ) { log . log ( level . severe , str , e ) ; return e . to string ( ) ; } }	import translation . uses translationhandler to update translation.
public result file reader ( problem problem , file file ) throws io { super ( ) ; this . problem = problem ; reader = new buffered reader ( new file reader ( file ) ) ; line = reader . read line ( ) ; }	constructs a result file reader for reading the approximation sets from the specified result file .
@ override public void on failure ( i async action token , throwable exception ) { exception . print stack trace ( ) ; log . e ( str , str + exception . get message ( ) ) ; on disconnect ( bool ) ; }	called when there was an error connecting.
@ override public boolean exclude ( string identifier ) { return blacklist . contains ( identifier ) ; }	checks if the given identifier should be excluded .
public static boolean check communication error ( exception exc ) { throwable root cause = solr exception . get root cause ( exc ) ; boolean was comm error = ( root cause instanceof connect exception || root cause instanceof connect timeout exception || root cause instanceof no http response exception || root cause instanceof socket exception ) ; return was comm error ; }	determine if a request to solr failed due to a communication error , which is generally retry - able .
public boolean is reliable ( ) { return bool ; }	returns " true " as this is a reliable transport .
private void push ( final int type ) { if ( output stack == null ) { output stack = new int [ num ] ; } int n = output stack . length ; if ( output stack top >= n ) { int [ ] t = new int [ math . max ( output stack top + num , num * n ) ] ; system . arraycopy ( output stack , num , t , num , n ) ; output stack = t ; } output stack [ output stack top ++ ] = type ; int top = owner . input stack top + output stack top ; if ( top > owner . output stack max ) { owner . output stack max = top ; } }	pushes a new type onto the output frame stack .
static private string short ( ) { long temp value = short . max value + num ; return string . value of ( temp value ) ; }	get the max value plus one for a short.
public void fire property change ( string name , object old value , object new value ) { bean context child support . fire property change ( name , old value , new value ) ; }	method for beancontextchild interface.
public static string encode ( string value ) { value = value . replace ( str , str ) ; value = value . replace ( str , str ) ; value = value . replace ( str , str ) ; value = value . replace ( str , str ) ; value = value . replace ( str , str ) ; value = value . replace ( str , str ) ; return value ; }	html encodes value to avoid xss attacks . & = & amp ; < = & lt ; > = & gt ; " = & quot ; ' = & # x27 ; / = & # x2f ;.
public void create database entities for storage policy testing ( ) { create database entities for storage policy testing ( abstract service test . storage policy namespace cd , arrays . as list ( abstract service test . storage policy rule type ) , abstract service test . bdef namespace , abstract service test . bdef name , arrays . as list ( abstract service test . format file type code ) , arrays . as list ( abstract service test . storage name ) , arrays . as list ( abstract service test . storage name 2 ) ) ; }	create and persist database entities required for storage policy service testing .
private pdf create page ( int pagenum , pdf page obj ) throws io { int rotation = num ; f mediabox = null ; f cropbox = null ; pdf mediabox obj = get inherited value ( page obj , str ) ; if ( mediabox obj != null ) { mediabox = parse rect ( mediabox obj ) ; } pdf cropbox obj = get inherited value ( page obj , str ) ; if ( cropbox obj != null ) { cropbox = parse rect ( cropbox obj ) ; } pdf rotate obj = get inherited value ( page obj , str ) ; if ( rotate obj != null ) { rotation = rotate obj . get int value ( ) ; } f bbox = ( ( cropbox == null ) ? mediabox : cropbox ) ; return new pdf ( pagenum , bbox , rotation , cache ) ; }	create a pdf page object by finding the relevant inherited properties.
static map add element to map ( string key , set values , map to map ) { if ( ( key != null ) && ( to map != null ) ) { to map . put ( key , values ) ; } return to map ; }	adds a key / value pair to a map.
public void save boot prop ( ) throws io { if ( ! boot prop . equals ( boot prop org ) ) { final string prop file = jar folder + str ; final output stream os = new file output stream ( prop file ) ; try { boot prop . store ( os , str ) ; } finally { os . close ( ) ; } } }	saves modified boot properties to disk .
private int append ( file system fs , configuration conf , path src , print writer writer , int current record number ) throws io { buffered reader reader = new buffered reader ( new input stream reader ( fs . open ( src ) ) ) ; try { string line = reader . read line ( ) ; while ( line != null ) { if ( line . starts with ( str ) ) { line = str + current record number ++ ; } writer . println ( line ) ; line = reader . read line ( ) ; } return current record number ; } finally { reader . close ( ) ; } }	appends two files and updates the recno counter.
public packet output stream write timestamp length ( final calendar calendar , timestamp ts , boolean fractional seconds ) { assure buffer capacity ( fractional seconds ? num : num ) ; buffer . put ( ( byte ) ( fractional seconds ? num : num ) ) ; buffer . put short ( ( short ) calendar . get ( calendar . year ) ) ; buffer . put ( ( byte ) ( ( calendar . get ( calendar . month ) + num ) & num ) ) ; buffer . put ( ( byte ) ( calendar . get ( calendar . day of month ) & num ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . hour of day ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . minute ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . second ) ) ; if ( fractional seconds ) { buffer . put int ( ts . get nanos ( ) / num ) ; } return this ; }	write timestamp in binary format .
public int difference ( string s1 , string s2 ) throws encoder exception { return soundex utils . difference ( this , s1 , s2 ) ; }	encodes the strings and returns the number of characters in the two encoded strings that are the same.
public static string morpha ( string text , boolean tags ) { if ( text . is empty ( ) ) { return str ; } string [ ] text parts = whitespace . split ( text ) ; string builder result = new string builder ( ) ; try { for ( string text part : text parts ) { morpha morpha = new morpha ( new string reader ( text part ) , tags ) ; if ( result . length ( ) != num ) { result . append ( str ) ; } result . append ( morpha . next ( ) ) ; } } catch ( error e ) { return text ; } catch ( java . io . io e ) { return text ; } return result . to string ( ) ; }	run the morpha algorithm on the specified string .
public static void delete file ( file file ) throws ade usage exception { if ( ! file . delete ( ) ) { throw new ade usage exception ( failed deleting file + file . get path ( ) ) ; } }	delete a file from file system .
public shape create check mark ( final int x , final int y , final int w , final int h ) { double xf = w / num ; double hf = h / num ; path . reset ( ) ; path . move to ( x , y + num * hf ) ; path . line to ( x + num * xf , y + num * hf ) ; path . line to ( x + num * xf , y + num * hf ) ; path . line to ( x + num * xf , y ) ; path . line to ( x + num * xf , y ) ; path . line to ( x + num * xf , y + num * hf ) ; path . close path ( ) ; return path ; }	return a path for a check mark .
@ override public synchronized void initialize ( ) { if ( ! m root directory . exists ( ) ) { if ( ! m root directory . mkdirs ( ) ) { volley log . e ( str , m root directory . get absolute path ( ) ) ; } return ; } file [ ] files = m root directory . list files ( ) ; if ( files == null ) { return ; } for ( file file : files ) { file input stream fis = null ; try { fis = new file input stream ( file ) ; cache header entry = cache header . read header ( fis ) ; entry . size = file . length ( ) ; put entry ( entry . key , entry ) ; } catch ( io e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( io ignored ) { } } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public tcp ( executor service executor , tcp event listener , string ip , int port ) { this . executor = executor ; executor thread check = new thread utils . thread checker ( ) ; executor thread check . detach thread ( ) ; this . event listener = event listener ; inet address address ; try { address = inet address . get by name ( ip ) ; } catch ( unknown host exception e ) { report error ( str ) ; return ; } if ( address . is any local address ( ) ) { socket = new tcp ( address , port ) ; } else { socket = new tcp ( address , port ) ; } socket . start ( ) ; }	initializes the tcpchannelclient . if ip is a local ip address , starts a listening server on that ip . if not , instead connects to the ip .
protected void cut selected bean ( ) { if ( debug . debugging ( str ) ) debug . output ( str ) ; if ( selected bean == null || selected bean location == null ) { if ( debug . debugging ( str ) ) debug . output ( str + selected bean ) ; if ( debug . debugging ( str ) ) debug . output ( str + selected bean location ) ; clear selection ( ) ; return ; } try { ser bean = new byte array output stream ( ) ; object output stream oos = new object output stream ( ser bean ) ; oos . write object ( selected bean ) ; } catch ( exception e ) { e . print stack trace ( ) ; clear selection ( ) ; if ( debug . debugging ( str ) ) debug . output ( str ) ; return ; } cut bean = selected bean ; selected bean box . show cut ( selected bean ) ; if ( debug . debugging ( str ) ) debug . output ( str ) ; }	this method is called when the user chooses to cut a bean by some means such by by pressing ctrl - x.
public remover manager track ( remover remover ) { if ( handlers == null ) { handlers = new array list < > ( ) ; } handlers . add ( remover ) ; return this ; }	tracks a new handler so that it can be removed in bulk .
public void action performed ( java . awt . event . action event e ) { object source = e . get source ( ) ; if ( ! ( source instanceof j ) ) return ; j mi = ( j ) source ; string name = mi . get text ( ) ; om target layer = ( om ) layers . get ( name ) ; if ( target layer == null ) { debug . message ( str , str + str + name ) ; return ; } target layer . do action ( ( om ) transfer data , new om ( om . update graphic mask ) ) ; }	invoked when an action from the popup menu occurs .
private void add entry ( ) { model . add new entry ( ) ; remove button . set enabled ( bool ) ; }	adds a new colour map entry .
private void ensure size ( ) { if ( children == empty children ) { children = new fp [ num ] ; return ; } int newsize = children . length == num ? initial size : ( children . length << num ) ; children = arrays . copy of ( children , newsize ) ; }	ensure we have enough storage .
public uuid ( long most sig bits , long least sig bits ) { this . most sig bits = most sig bits ; this . least sig bits = least sig bits ; init ( ) ; }	< p > constructs an instance with the specified bits .
public static pretty print indent with spaces ( int number ) { if ( number < num ) { throw new illegal argument exception ( str ) ; } char [ ] chars = new char [ number ] ; arrays . fill ( chars , str ) ; return new pretty print ( chars ) ; }	print every value on a separate line.
private static void render handler ( faces context context , ui component , collection < client behavior context . parameter > params , string handler name , object handler value , string behavior event name , string submit target , boolean needs submit , boolean include exec ) throws io { response writer writer = context . get response writer ( ) ; string user handler = get non empty user handler ( handler value ) ; list < client behavior > behaviors = get client behaviors ( component , behavior event name ) ; if ( ( null != behaviors ) && ( behaviors . size ( ) > num ) && util . component is disabled ( component ) ) { behaviors = null ; } if ( params == null ) { params = collections . empty list ( ) ; } string handler = null ; switch ( get handler type ( behaviors , params , user handler , needs submit , include exec ) ) { case user handler only : handler = user handler ; break ; case single behavior only : handler = get single behavior handler ( context , component , behaviors . get ( num ) , params , behavior event name , submit target , needs submit ) ; break ; case submit only : handler = get submit handler ( context , component , params , submit target , bool ) ; break ; case chain : handler = get chained handler ( context , component , behaviors , params , behavior event name , user handler , submit target , needs submit ) ; break ; default : assert ( bool ) ; } writer . write attribute ( handler name , handler , null ) ; }	renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra.
public string construct tsdb ( ) { string builder sb = new string builder ( get scope ( ) ) ; if ( namespace != null && ! namespace . is empty ( ) ) { sb . append ( get namespace ( ) ) ; } return sb . to string ( ) ; }	constructs a native tsdb metric name for this metric .
@ override protected void register new selector ( ) throws io { synchronized ( selector ) { set < selection key > keys = selector . keys ( ) ; selector new selector = null ; if ( selector provider == null ) { new selector = selector . open ( ) ; } else { new selector = selector provider . open selector ( ) ; } for ( selection key key : keys ) { selectable channel ch = key . channel ( ) ; nio session session = ( nio session ) key . attachment ( ) ; selection key new key = ch . register ( new selector , key . interest ops ( ) , session ) ; session . set selection key ( new key ) ; } selector . close ( ) ; selector = new selector ; } }	in the case we are using the java select ( ) method , this method is used to trash the buggy selector and create a new one , registering all the sockets on it .
public void test case4 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , - num , num , num , num , num , - num , num , num , num , - num , num , - num , - num , - num , num , num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	multiply two positive numbers of different length.
protected synchronized void received ( int response code , string stream , string json ) { follower info result = parse followers ( stream , json ) ; if ( result != null ) { no error ( stream ) ; cached . put ( stream , result ) ; if ( type == follower . type . follower ) { listener . received followers ( result ) ; if ( has new followers ( result . followers ) ) { listener . new followers ( result ) ; } } else if ( type == follower . type . subscriber ) { listener . received subscribers ( result ) ; } requested . add ( stream ) ; } else { string error message = str ; if ( response code == num ) { error message = str ; error ( stream , num ) ; } else if ( response code == num ) { error message = str ; error ( stream , num ) ; } else if ( response code == num || response code == num ) { error message = str ; error ( stream , num ) ; } else if ( response code == num ) { error message = str ; error ( stream , num ) ; } else { error message = str ; error ( stream , num ) ; } follower info error result = new follower info ( type , stream , error message ) ; cached . put ( stream , error result ) ; if ( type == follower . type . follower ) { listener . received followers ( error result ) ; } else if ( type == follower . type . subscriber ) { listener . received subscribers ( error result ) ; } } }	received data from the api , so parse it or handle a possible error , then give it to the listener .
public static < t > list < t > select ( connection connection , string raw sql query , row processor < t > row processor , object ... parameters ) throws io , sql { prepared statement stmt = null ; result set rs = null ; try { stmt = connection . prepare statement ( raw sql query ) ; for ( int index = num ; index < parameters . length ; index ++ ) { jdbc utils . bind parameter ( stmt , index + num , parameters [ index ] ) ; } rs = stmt . execute query ( ) ; list < t > result = lists . new linked list ( ) ; while ( rs . next ( ) ) { result . add ( row processor . process ( rs ) ) ; } return result ; } finally { jdbc utils . close result set ( rs ) ; jdbc utils . close statement ( stmt ) ; } }	retrieve all the rows satisfying the given sql query .
public static long now in nanos ( ) { return system . nano time ( ) ; }	current time from some arbitrary time base in the past , counting in nanoseconds , and not affected by settimeofday or similar system clock changes.
public void test clone ( ) { format fm = new mock format ( ) ; format fmc = ( format ) fm . clone ( ) ; assert equals ( fm . get class ( ) , fmc . get class ( ) ) ; }	java . text . format # clone ( ) test of method java . text . format # clone ( ) . compare of internal variables of cloned objects .
public future < sync reply > send request ( int xid , sync message request ) throws remote store exception { ensure connected ( ) ; remote sync future future = new remote sync future ( xid , connection generation ) ; future map . put ( integer . value of ( xid ) , future ) ; if ( future map . size ( ) > max pending requests ) { synchronized ( future notify ) { while ( future map . size ( ) > max pending requests ) { try { future notify . wait ( ) ; } catch ( interrupted exception e ) { throw new remote store exception ( str , e ) ; } } } } channel . write and flush ( request ) ; return future ; }	send a request to the server and generate a future for the eventual reply . note that this call can block if there is no active connection while a new connection is re - established or if the maximum number of requests is already pending.
public static boolean is empty ( string str ) { return ( null == str || num == str . length ( ) ) ; }	is null or its length is 0.
public void enable dependency ( capability c ) { if ( do not check capabilities ( ) ) { return ; } if ( c == capability . nominal attributes ) { enable dependency ( capability . binary attributes ) ; } else if ( c == capability . binary attributes ) { enable dependency ( capability . unary attributes ) ; } else if ( c == capability . unary attributes ) { enable dependency ( capability . empty nominal attributes ) ; } else if ( c == capability . nominal class ) { enable dependency ( capability . binary class ) ; } m . add ( c ) ; }	enables the dependency flag for the given capability enabling nominal_attributes also enables binary_attributes , unary_attributes and empty_nominal_attributes.
public i [ ] extract robot debug variables ( final int stack trace id , final map < string , object > new variables ) { final robot debug variables context current variables context = find current variables context ( stack trace id ) ; map < string , i > previous variables map = init previous variables state ( current variables context ) ; final map < string , i > non global variables map = new linked hash map < > ( ) ; if ( previous variables map == null ) { init new non global variables ( new variables , non global variables map ) ; } else { init variables comparing with previous state ( new variables , previous variables map , non global variables map ) ; } final linked list < i > current variables list = create current variables list ( non global variables map ) ; save current variables state ( stack trace id , current variables context , non global variables map ) ; return current variables list . to array ( new i [ current variables list . size ( ) ] ) ; }	extract and sort variables for given stacktrace level.
public resources poet add integer ( string name , string value ) { element bool = document . create element ( str ) ; bool . set attribute ( str , name ) ; bool . append child ( document . create text node ( string . value of ( value ) ) ) ; resource element . append child ( bool ) ; return this ; }	add an integer to the config.
public static string map full width letter to half width ( string text ) { }	convert full - width letters in chinese fonts to normal half - width letters in ansi charset.
private static < t > void assert collection equals no order ( collection < t > expected , collection < t > actual ) { string msg = string . format ( str , expected . to string ( ) , actual . to string ( ) ) ; assert equals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( t e : expected ) { if ( ! actual . contains ( e ) ) { msg = string . format ( str + str , e , expected , actual ) ; fail ( msg ) ; } } }	test whether two collections contains the same elements , regardless of the order in which the elements appear in the collections.
private static boolean has response body ( int request method , int response code ) { return request method != request . method . head && ! ( http status . sc continue <= response code && response code < http status . sc ok ) && response code != http status . sc no content && response code != http status . sc not modified ; }	checks if a response message contains a body .
public int available in process ( ) { return math . max ( num , max in process - pending . size ( ) ) ; }	a connection can only have so many things in process happening on it at once , where " in process " refers to the maximum number of in - process requests less the number of pending responses .
public void add ( double x ) { cell [ ] as ; long b , v ; int m ; cell a ; if ( ( as = cells ) != null || ! cas base ( b = base , double . double to raw long bits ( double . long bits to double ( b ) + x ) ) ) { boolean uncontended = bool ; if ( as == null || ( m = as . length - num ) < num || ( a = as [ get probe ( ) & m ] ) == null || ! ( uncontended = a . cas ( v = a . value , double . double to raw long bits ( double . long bits to double ( v ) + x ) ) ) ) double accumulate ( x , null , uncontended ) ; } }	adds the given value .
public boolean should execute action ( ) { if ( delay <= num ) { return bool ; } long time passed = system . current time millis ( ) - last action executed ; if ( time passed > delay * num ) { last action executed = system . current time millis ( ) ; return bool ; } return bool ; }	checks whether an action should currently be executed , based on the required delay.
public static int move by word ( string text , int column , boolean forward , boolean return cursor at end ) { int cur column = column ; int length = text . length ( ) ; int direction = forward ? num : - num ; boolean far word end = ( ( direction == num && return cursor at end ) || ( direction == - num && ! return cursor at end ) ) ; boolean found early match = bool ; if ( ! unicode utils . is whitespace ( text . char at ( cur column ) ) ) { cur column = skip nonwhitespace similar ( text , cur column , forward ) ; if ( far word end && cur column - direction != column ) { cur column -= direction ; found early match = bool ; } } if ( ! found early match && cur column >= num && cur column < length ) { cur column = skip whitespace ( text , cur column , forward ) ; if ( far word end && cur column >= num && cur column < length ) { cur column = skip nonwhitespace similar ( text , cur column , forward ) - direction ; } } if ( cur column < num || cur column >= length ) { return - num ; } return cur column ; }	jumps to the previous or next best match given the parameters below.
protected void handle or defer message ( distribution message msg ) { synchronized ( startup lock ) { if ( being sick || playing dead ) { if ( msg . contains region content change ( ) || msg instanceof partition message with direct reply ) { startup messages . add ( new startup event ( msg ) ) ; return ; } } if ( ! processing events ) { startup messages . add ( new startup event ( msg ) ) ; return ; } } dispatch message ( msg ) ; }	dispatch the distribution message , or place it on the startup queue .
public boolean zone export remove volumes ( list < network zoning param > zoning params , collection < uri > volume ur , string step id ) { network zoning param zoning param = zoning params . get ( num ) ; log . info ( string . format ( str , zoning param . get export group display ( ) , volume ur . to string ( ) ) ) ; return do zone export masks delete ( zoning params , volume ur , step id ) ; }	removes the indicated volumes from the zones given by the zoning parameters.
private void shutdown ( ) { if ( nbest list writer != null ) { logger . info ( str ) ; nbest list writer . close ( ) ; } if ( alignment writer != null ) { logger . info ( str ) ; alignment writer . close ( ) ; } }	free resources and cleanup .
@ override public void paint icon ( component c , graphics g , int x , int y ) { painter painter = ( painter ) ui . get ( prefix + str + key ) ; if ( painter != null ) { j jc = ( c instanceof j ) ? ( j ) c : null ; d gfx = ( d ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }	implements the standard icon interface ' s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available.
protected void zoom image to position ( float scale , float center x , float center y , long duration ms ) { if ( scale > get max scale ( ) ) { scale = get max scale ( ) ; } final float old scale = get current scale ( ) ; final float delta scale = scale - old scale ; post ( m zoom image to position runnable = new zoom image to position ( crop image view . this , duration ms , old scale , delta scale , center x , center y ) ) ; }	this method changes image scale ( animating zoom for given duration ) , related to given center ( x , y ) .
public list < map < string , string > > list ( database conn ) throws sql { result set rs = null ; statement statement = conn . create statement ( ) ; list < map < string , string > > shard to channels = new array list < map < string , string > > ( ) ; try { rs = statement . execute query ( select ) ; while ( rs . next ( ) ) { map < string , string > shard = new hash map < string , string > ( ) ; shard . put ( shard channel table . shard id col , rs . get string ( shard channel table . shard id col ) ) ; shard . put ( shard channel table . channel col , rs . get string ( shard channel table . channel col ) ) ; shard to channels . add ( shard ) ; } } finally { close ( rs ) ; close ( statement ) ; } return shard to channels ; }	return a list of currently known shard / channel assignments .
public boolean is hidden ( file f ) { string name = f . get name ( ) ; if ( ( name != null ) && ! name . equals ( str ) && ( name . char at ( num ) == str ) ) { return boolean . true ; } else { return boolean . false ; } }	whether the file is hidden or not.
private boolean scroll view can scroll vertically ( scroll view scroll view , int direction ) { final int offset = math . max ( num , scroll view . get scroll y ( ) ) ; final int range = compute vertical scroll range ( scroll view ) - scroll view . get height ( ) ; if ( range == num ) return bool ; if ( direction < num ) { return offset > num ; } else { return offset < range - num ; } }	copy from scrollview ( api level > = 14 ).
public jar info load jar ( ) throws io { zip input stream zis = null ; manifest mf = null ; boolean empty = bool ; try { zis = new zip input stream ( jar stream ) ; zip entry ent = null ; while ( ( ent = zis . get next entry ( ) ) != null ) { empty = bool ; string name = ent . get name ( ) ; if ( manifest . is manifest name ( name ) ) { byte array output stream baos = new byte array output stream ( ) ; byte buffer [ ] = new byte [ num ] ; for ( ; ; ) { int len = zis . read ( buffer ) ; if ( len < num ) { break ; } baos . write ( buffer , num , len ) ; } byte [ ] buf = baos . to byte array ( ) ; mf = new manifest ( buf ) ; } } } catch ( io ex ) { throw ex ; } catch ( throwable th ) { th . print stack trace ( ) ; throw new io ( str + th ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( exception ex ) { } } } if ( empty ) { throw new io ( str ) ; } jar info ji = create jar info ( mf ) ; return ji ; }	load the classes , resources , etc .
public void invalidate title sortable ( ) { for ( movie movie : new array list < > ( movie list ) ) { movie . clear title sortable ( ) ; } }	invalidate the title sortable upon changes to the sortable prefixes.
public void add row ( assignment head , double prob ) { if ( prob < num || prob > num ) { return ; } head vars . add all ( head . get variables ( ) ) ; table . put ( head , prob ) ; }	adds a new row to the probability table , assuming no conditional assignment.
public byte [ ] create jar from file content ( final string file name , final string content ) throws io { byte array output stream byte array output stream = new byte array output stream ( ) ; jar output stream jar output stream = new jar output stream ( byte array output stream ) ; jar entry entry = new jar entry ( file name ) ; entry . set time ( system . current time millis ( ) ) ; jar output stream . put next entry ( entry ) ; jar output stream . write ( content . get bytes ( ) ) ; jar output stream . close entry ( ) ; jar output stream . close ( ) ; return byte array output stream . to byte array ( ) ; }	create a jar using the given file contents and with the given file name .
private boolean go to ( long day , boolean animate , boolean set selected , boolean force scroll ) { if ( set selected ) { m selected day . set time in millis ( day ) ; } m temp day . set time in millis ( day ) ; final int position = get position from day ( day ) ; view child ; int i = num ; int top = num ; do { child = get child at ( i ++ ) ; if ( child == null ) { break ; } top = child . get top ( ) ; } while ( top < num ) ; int selected position ; if ( child != null ) { selected position = get position for view ( child ) ; } else { selected position = num ; } if ( set selected ) { m adapter . set selected day ( m selected day ) ; } if ( position != selected position || force scroll ) { set month displayed ( m temp day ) ; m previous scroll state = on scroll listener . scroll state fling ; if ( animate ) { smooth scroll to position from top ( position , list top offset , goto scroll duration ) ; return bool ; } else { post set selection ( position ) ; } } else if ( set selected ) { set month displayed ( m selected day ) ; } return bool ; }	this moves to the specified time in the view.
public boolean search ( v v ) { int h = hash method . hash ( v ) ; linked list < v > list = ( linked list < v > ) table [ h ] ; if ( list == null ) { return bool ; } return list . contains ( v ) ; }	search for the desired value in the hashtable . < p > only succeeds if v overrides the equals ( object o ) method.
public void close jdbc ( connection conn ) { try { if ( conn != null ) { conn . close ( ) ; } } catch ( sql sqle ) { subclass log wrapper ( str ) ; } }	closes database connection and logs if an error is encountered.
@ override public void message item details ( string str class , string item , string description , string [ ] msg option , int [ ] msg number , int default option ) { hash map < integer , string > options = new hash map < > ( msg option . length ) ; for ( int i = num ; i < msg option . length ; i ++ ) { options . put ( msg number [ i ] , msg option [ i ] ) ; } message item details ( str class , description , item , options , default option ) ; }	add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable.
public void add listener ( color map listener listener ) { listeners . add ( listener ) ; }	add a color map listener.
protected void compute p ( relation < o > relation , knn < o > knn , writable double data store pdists ) { finite progress prds progress = log . is verbose ( ) ? new finite progress ( str , relation . size ( ) , log ) : null ; for ( dbid iditer = relation . iter dbi ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final knn neighbors = knn . get knn dbid ( iditer , kreach + num ) ; int ks = num ; double ssum = num ; for ( dbid neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if ( dbid . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . double value ( ) ; ssum += d * d ; ks ++ ; } double pdist = ks > num ? math . sqrt ( ssum / ks ) : num ; pdists . put double ( iditer , pdist ) ; log . increment processed ( prds progress ) ; } log . ensure completed ( prds progress ) ; }	compute the probabilistic distances used by loop .
private static string append if missing ( final string str , final char sequence suffix , final boolean ignore case , final char sequence ... suffixes ) { if ( str == null || is empty ( suffix ) || ends with ( str , suffix , ignore case ) ) { return str ; } if ( suffixes != null && suffixes . length > num ) { for ( final char sequence s : suffixes ) { if ( ends with ( str , s , ignore case ) ) { return str ; } } } return str + suffix . to string ( ) ; }	appends the suffix to the end of the string if the string does not already end in the suffix .
private json request all file systems ( ) throws io , json { json ret = new json ( ) ; for ( filesystem fs : filesystems ) { ret . put ( fs . get root entry ( ) ) ; } return ret ; }	requests a filesystem in which to store application data .
external problem ( process process ) { this ( process . get input stream ( ) , process . get output stream ( ) ) ; redirect stream . redirect ( process . get error stream ( ) , system . err ) ; }	constructs an external problem using the specified process .
protected static boolean network monitor exist ( string nw mon name ) { string class method = str ; if ( debug . message enabled ( ) ) { debug . message ( class method + str + nw mon name ) ; } if ( ( nw mon name == null ) || ( nw mon name . length ( ) == num ) ) { if ( debug . warning enabled ( ) ) { debug . warning ( class method + str ) ; } return bool ; } set < string > ntw stats = network monitor . get instance names ( ) ; string ss = nw mon name . to lower case ( ) ; if ( ntw stats . contains ( ss ) ) { return bool ; } else { return bool ; } }	return whether the specified network monitor has been instantiated in the entitlements service yet.
public void and with ( list < query predicate > predicates ) { children . add all ( predicates ) ; }	adds multiple predicates that much be met by the vertices .
public void add roll ( mm rng ) { int result = rng . random int ( this . faces ) + this . min ; all . add element ( new integer ( result ) ) ; this . total += result ; if ( keep != - num && all . size ( ) >= keep ) { this . total = num ; collections . sort ( all , collections . reverse order ( ) ) ; for ( int i = num ; i < keep ; i ++ ) { this . total += all . get ( i ) ; } } }	add the result from the given rng source .
public boolean check canonical user options ( ) { boolean result ; option handler handler ; string [ ] user options ; string [ ] user options check ; print ( str ) ; try { handler = get default handler ( ) ; handler . set options ( get user options ( ) ) ; if ( get debug ( ) ) { print ( str ) ; } user options = handler . get options ( ) ; if ( get debug ( ) ) { println ( print options ( user options ) ) ; } if ( get debug ( ) ) { println ( str ) ; } handler . set options ( user options . clone ( ) ) ; if ( get debug ( ) ) { println ( str ) ; } user options check = handler . get options ( ) ; compare options ( user options , user options check ) ; println ( str ) ; result = bool ; } catch ( exception e ) { println ( str ) ; result = bool ; if ( get debug ( ) ) { println ( e ) ; } } return result ; }	checks whether the user - supplied options stay the same after settting , getting and re - setting again.
public static void close quietly ( final closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( final runtime exception rethrown ) { throw rethrown ; } catch ( final exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
public static void push encrypted message ( final text secure envelope envelope ) { while ( bool ) { try { queue . put ( envelope ) ; return ; } catch ( final interrupted exception e ) { } } }	adds an encrypted message to the queue.
public static int random range int ( int min , int max ) { return ( int ) ( math . random ( ) < num ? ( ( num - math . random ( ) ) * ( max - min ) + min ) : ( math . random ( ) * ( max - min ) + min ) ) ; }	returns a random integer between the value min and the value max .
public void test simple premature close ( ) { striterator iter = new striterator ( m data . iterator ( ) ) ; int i = num ; while ( iter . has next ( ) ) { iter . next ( ) ; if ( ++ i == num ) { iter . close ( ) ; assert true ( ! iter . has next ( ) ) ; } } assert true ( ! iter . is open ( ) ) ; assert true ( i == num ) ; }	test that striterator returns false for hasnext ( ) after close ( ).
public void push draw list ( psp ge list list ) { synchronized ( draw list queue ) { draw list queue . add ( list ) ; } }	called from pspge module.
private void populate task list ( volume source , map < block mirror , volume > group mirror source map , task list task list , string task id , resource operation type enum operation type ) { set < uri > group set = new hash set < uri > ( ) ; add task ( task list , source , task id , operation type ) ; for ( entry < block mirror , volume > entry : group mirror source map . entry set ( ) ) { block mirror mirror = entry . get key ( ) ; volume mirror source = entry . get value ( ) ; if ( source . is in cg ( ) && null != task list . get task list ( ) ) { group set . add ( mirror source . get consistency group ( ) ) ; } } list < block consistency group > groups = db client . query object ( block consistency group . class , group set ) ; for ( block consistency group group : groups ) { add task ( task list , group , task id , operation type ) ; } }	populate the given tasklist with tasks .
public static tuple max ( iterator tuples , string field , comparator cmp ) { tuple t = null , tmp ; object min = null ; if ( tuples . has next ( ) ) { t = ( tuple ) tuples . next ( ) ; min = t . get ( field ) ; } while ( tuples . has next ( ) ) { tmp = ( tuple ) tuples . next ( ) ; object obj = tmp . get ( field ) ; if ( cmp . compare ( obj , min ) > num ) { t = tmp ; min = obj ; } } return t ; }	get the tuple with the maximum data field value .
public string cluster definitions tip text ( ) { return str ; }	returns the tip text for this property.
public void test constructor sign bytes positive1 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; int a sign = num ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void fling ( int start x , int start y , int velocity x , int velocity y , int min x , int max x , int min y , int max y , int over x , int over y ) { if ( m flywheel && ! is finished ( ) ) { float old velocity x = m scroller x . m curr velocity ; float old velocity y = m scroller y . m curr velocity ; if ( math . signum ( velocity x ) == math . signum ( old velocity x ) && math . signum ( velocity y ) == math . signum ( old velocity y ) ) { velocity x += old velocity x ; velocity y += old velocity y ; } } m mode = fling mode ; m scroller x . fling ( start x , velocity x , min x , max x , over x ) ; m scroller y . fling ( start y , velocity y , min y , max y , over y ) ; }	start scrolling based on a fling gesture.
public void add listener ( navigator listener listener ) { listeners . add ( listener ) ; }	add listener to listener list.
public void close stream ( ) { carbon util . close streams ( stream ) ; executor service . shutdown ( ) ; }	below method will be used to close streams.
public double patience ( int k , f f , int n ) { double pf = p ( f ) ; binomial distribution dist = new binomial distribution ( null , n , pf ) ; double p0 = math . pow ( num - pf , n ) ; return num - ( dist . cumulative probability ( k - num ) - p0 ) / ( num - p0 ) ; }	return the patience , i.
public static list series name list from data array ( object [ ] [ ] data ) { int series count = data . length ; list series name list = new java . util . array list ( series count ) ; for ( int i = num ; i < series count ; i ++ ) { series name list . add ( str + ( i + num ) ) ; } return series name list ; }	utility method for automatically generating series names .
@ override public int read ( char b [ ] , int off , int len ) throws io { ensure open ( ) ; if ( ( off < num ) || ( off > b . length ) || ( len < num ) || ( ( off + len ) > b . length ) || ( ( off + len ) < num ) ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return num ; } if ( pos >= count ) { return - num ; } if ( pos + len > count ) { len = count - pos ; } if ( len <= num ) { return num ; } system . arraycopy ( buf , pos , b , off , len ) ; pos += len ; return len ; }	reads characters into a portion of an array .
public static void f ( string tag , string msg , object ... args ) { if ( s level > level fatal ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . wtf ( tag , msg ) ; }	send a fatal error log message.
private static void expand number at ( string number string , int start index , word relation word relation ) { expand number ( number string . substring ( start index , number string . length ( ) ) , word relation ) ; }	returns the number string list of the given string starting at the given index.
public static boolean null equals ( string s1 , string s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }	equals ( ) with two strings where either could be null.
@ override public void run ( ) { multiple objects bundle data = generator . load data ( ) ; if ( log . is verbose ( ) ) { log . verbose ( str ) ; } try { if ( output file . exists ( ) && log . is verbose ( ) ) { log . verbose ( str + output file + str + str ) ; } try ( output stream writer out stream = new file writer ( output file , bool ) ) { write clusters ( out stream , data ) ; } } catch ( io e ) { throw new abort exception ( str , e ) ; } if ( log . is verbose ( ) ) { log . verbose ( str ) ; } }	runs the wrapper with the specified arguments .
private boolean used all rule17 directors ( set < string > allocated directors , port allocation context context ) { set < string > rule17 directors = get rule17 directors ( context ) ; for ( string director : allocated directors ) { rule17 directors . remove ( director ) ; } return rule17 directors . is empty ( ) ; }	returns true if already used all the rule17 directors .
public void stop ( ) { synchronized ( private instance lock ) { if ( connection accept thread == null ) { return ; } } is stopped . set ( bool ) ; try { connection accept thread . interrupt ( ) ; connection accept thread . join ( ) ; } catch ( interrupted exception e ) { } try { server socket . close ( ) ; } catch ( io e ) { } }	stops the communicator . all open connections to the remote server will be terminated . once this method has been called , the communicator cannot be restarted .
private static string expand system id strict on ( string system id , string base system id ) throws uri . uri { uri system uri = new uri ( system id , bool ) ; if ( system uri . is absolute uri ( ) ) { return system id ; } uri base uri = null ; if ( base system id == null || base system id . length ( ) == num ) { base uri = get user dir ( ) ; } else { base uri = new uri ( base system id , bool ) ; if ( ! base uri . is absolute uri ( ) ) { base uri . absolutize ( get user dir ( ) ) ; } } system uri . absolutize ( base uri ) ; return system uri . to string ( ) ; }	helper method for expandsystemid ( string , string , boolean ) : string.
public static void free ( d msg ) { int index = size2 index ( msg . get size ( ) ) ; msg . clear ( ) ; if ( index < num ) ; else if ( m cache [ index ] != null ) ; else m cache [ index ] = msg ; }	put a dmessage into the cache for reuse.
public boolean equals ignore case ( final str builder other ) { if ( this == other ) { return bool ; } if ( this . size != other . size ) { return bool ; } final char this buf [ ] = this . buffer ; final char other buf [ ] = other . buffer ; for ( int i = size - num ; i >= num ; i -- ) { final char c1 = this buf [ i ] ; final char c2 = other buf [ i ] ; if ( c1 != c2 && character . to upper case ( c1 ) != character . to upper case ( c2 ) ) { return bool ; } } return bool ; }	checks the contents of this builder against another to see if they contain the same character content ignoring case .
protected static long convert uuid to long ( uuid uuid ) { if ( uuid == null ) { return null ; } long converted uuid ; if ( uuid . version ( ) == num ) { converted uuid = uuid . timestamp ( ) ; } else { converted uuid = uuid . get most significant bits ( ) ; } return converted uuid ; }	converts a uuid to a long for bucketing purposes.
public void add vm ( string vm argument name , string vm argument value ) { vm argument data vm arg = new vm argument data ( vm argument name , vm argument value ) ; vm set . add ( vm arg ) ; }	adds the given vm argument .
private void apply to ( class visitor v , field f ) { if ( log . is logging on ( ) ) { log . log line ( string . format ( str , f . to generic string ( ) ) ) ; } v . visit ( f ) ; }	apply a visitor to a field .
public void test compare to equal neg ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
public void test screenshot ( ) throws exception { log . d ( log tag , str ) ; screenshot stub activity activity = get activity ( ) ; assert not null ( activity ) ; file screenshot dir = get screenshot dir ( ) ; new screenshot observer observer = new new screenshot observer ( screenshot dir . get absolute path ( ) ) ; observer . start watching ( ) ; take screenshot ( ) ; if ( observer . get created path ( ) == null ) { synchronized ( observer ) { observer . wait ( screen wait time sec * num ) ; } } assert not null ( string . format ( str , screen wait time sec ) , observer . get created path ( ) ) ; file screenshot file = new file ( screenshot dir , observer . get created path ( ) ) ; try { assert true ( string . format ( str , screenshot file . get name ( ) ) , screenshot file . is file ( ) ) ; assert true ( string . format ( str , screenshot file . get name ( ) ) , is valid image ( screenshot file ) ) ; } finally { screenshot file . delete ( ) ; } }	a simple test for screenshots that launches an activity , injects the key event combo to trigger the screenshot , and verifies the screenshot was taken successfully .
public task resource rep unlink target volumes from snapshot session ( uri snap session uri , snapshot session unlink targets param param ) { return unlink target volumes from snapshot session ( snap session uri , param , operation type enum . unlink snapshot session target ) ; }	implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .
private list reverse ( list seq ) { linked list new seq = new linked list ( ) ; for ( iterator i = seq . iterator ( ) ; i . has next ( ) ; ) { directed edge de = ( directed edge ) i . next ( ) ; new seq . add first ( de . get sym ( ) ) ; } return new seq ; }	reverse the sequence . this requires reversing the order of the diredges , and flipping each diredge as well.
protected loc path iterator change part to ref ( final q unique pseudo var name , walking iterator wi , final int num steps , final boolean is global ) { variable var = new variable ( ) ; var . set q ( unique pseudo var name ) ; var . set is global ( is global ) ; if ( is global ) { elem template element elem = get elem from expression ( wi ) ; stylesheet root root = elem . get stylesheet root ( ) ; vector vars = root . get variables and params composed ( ) ; var . set index ( vars . size ( ) - num ) ; } axes walker walker = wi . get first walker ( ) ; for ( int i = num ; i < num steps ; i ++ ) { assertion ( null != walker , str ) ; walker = walker . get next walker ( ) ; } if ( null != walker ) { filter expr walker few = new filter expr walker ( wi ) ; few . set inner expression ( var ) ; few . expr set parent ( wi ) ; few . set next walker ( walker ) ; walker . set prev walker ( few ) ; wi . set first walker ( few ) ; return wi ; } else { filter expr iterator simple feis = new filter expr iterator simple ( var ) ; feis . expr set parent ( wi . expr get parent ( ) ) ; return feis ; } }	change a given number of steps to a single variable reference .
@ deprecated @ override public string read line ( ) throws io { string builder b = new string builder ( num ) ; int chr ; while ( ( chr = read ( ) ) >= num ) { if ( chr != str ) { b . append ( ( char ) chr ) ; } else { return b . to string ( ) ; } } return b . to string ( ) ; }	emulate the deprecated datainputstream.
private void add to scene ( final node items ) { collection . add ( items ) ; }	adds items to scene , ensuring we are on the fx thread.
public string documentation home page url ( ) { return properties . get property ( str ) ; }	returns the url of the product home page .
public static boolean has taxonomy info ( sequences reader reader ) { final file taxon file = new file ( reader . path ( ) , taxonomy file ) ; final file mapping file = new file ( reader . path ( ) , taxonomy to sequence file ) ; if ( taxon file . exists ( ) && mapping file . exists ( ) ) { return bool ; } else if ( taxon file . exists ( ) || mapping file . exists ( ) ) { throw new no talkback slim exception ( str ) ; } else { return bool ; } }	returns true if the supplied reader contains taxonomy information.
public void remove selection listener ( final selection listener listener ) { check widget ( ) ; if ( listener == null ) { swt . error ( swt . error null argument ) ; } list of selection listeners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the control is selected by the user .
public void replace ( class node type , int n ) { remove ( n ) ; push ( type ) ; }	replace n top level elements with new element of given type.
public void handle button1 request ( request invocation event event ) throws model control exception { submit cycle = bool ; entities model model = ( entities model ) get model ( ) ; am prop = ( am ) get child ( property attribute ) ; string universal id = ( string ) get page session attribute ( universal id ) ; try { map old values = model . get attribute values ( universal id , bool ) ; map values = prop . get attribute values ( old values , bool , model ) ; string cur realm = ( string ) get page session attribute ( am . current realm ) ; model . modify entity ( cur realm , universal id , values ) ; set inline alert message ( cc . type info , str , str ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } forward to ( ) ; }	handles create realm request .
private node delete max ( node x ) { if ( x . right == null ) return x . left ; x . right = delete max ( x . right ) ; x . size = num + size ( x . left ) + size ( x . right ) ; x . height = num + math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }	removes the largest key and associated value from the given subtree .
public void clear ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { for ( node < e > f = first ; f != null ; ) { f . item = null ; node < e > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = num ; not full . signal all ( ) ; } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this deque.
protected void on progress ( int itemcount , int size ) { }	called every time when command makes some little progress . can be mapped to async progress - bar.
private tree node ( long node value , snmp mib agent agent , tree node sup ) { this . node value = node value ; this . parent = sup ; agents . add element ( agent ) ; }	only the treenode class can create an instance of treenode.
public week ( date time ) { this ( time , time zone . get default ( ) , locale . get default ( ) ) ; }	creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .
public code attribute create code ( ) { code attribute code = new code attribute ( ) ; for ( int i = num ; i < attributes . size ( ) ; i ++ ) { attribute attr = attributes . get ( i ) ; if ( attr instanceof code attribute ) return ( code attribute ) attr ; } return null ; }	create the code attribute .
public binary out ( string filename ) { try { output stream os = new file output stream ( filename ) ; out = new buffered output stream ( os ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	initializes a binary output stream from a file .
protected object stream class read class descriptor ( ) throws io , class not found exception { object stream class new class desc = new object stream class ( ) ; string name = input . read utf ( ) ; if ( name . length ( ) == num ) { throw new io ( str ) ; } new class desc . set name ( name ) ; new class desc . set serial version uid ( input . read long ( ) ) ; new class desc . set flags ( input . read byte ( ) ) ; if ( descriptor handle == - num ) { descriptor handle = next handle ( ) ; } register object read ( new class desc , descriptor handle , bool ) ; read field descriptors ( new class desc ) ; return new class desc ; }	reads a class descriptor from the source stream .
public static boolean create new file ( file target file ) { if ( target file . exists ( ) ) target file . delete ( ) ; try { return target file . create new file ( ) ; } catch ( io e ) { return bool ; } }	create a new file , if the file exists , delete and create again .
public void test zero one ( ) { byte a bytes [ ] = { num } ; byte b bytes [ ] = { num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	or for zero and one.
protected int execute prepare statement ( list < column > columns , prepared statement statement ) throws sql { int bind no = num ; for ( column c : columns ) { set column value ( statement , bind no , c ) ; bind no ++ ; } return statement . execute update ( ) ; }	executes a prepared statement using values supplied as arguments .
public config ( saml authority configuration saml authority config , token restrictions token restrictions , collection < list < certificate > > valid certs , long clock tolerance , collection < idp > in external idps ) { validate . not null ( saml authority config ) ; validate . not null ( token restrictions ) ; validate . not empty ( valid certs ) ; list < certificate > authority cert = saml authority config . get signing certificate chain ( ) ; boolean authority cert in valid certs = bool ; for ( list < certificate > current chain : valid certs ) { validate . not empty ( current chain ) ; validate . no null elements ( current chain ) ; if ( ! authority cert in valid certs && current chain . equals ( authority cert ) ) { authority cert in valid certs = bool ; } } validate . is true ( authority cert in valid certs , str ) ; validate . is true ( clock tolerance >= num ) ; this . saml authority config = saml authority config ; this . valid certs = valid certs ; this . clock tolerance = clock tolerance ; this . token restrictions = token restrictions ; hash map < string , idp > idps set = new hash map < string , idp > ( ) ; if ( in external idps != null ) { for ( idp conf : in external idps ) { if ( conf != null ) { idps set . put ( conf . get entity id ( ) , conf ) ; } } } this . external idps = collections . unmodifiable map ( idps set ) ; }	creates a new configuration.
public static void check not empty ( string string ) { if ( string . is empty ( ) ) { throw new null pointer exception ( ) ; } }	ensures that an string reference passed as a parameter to the calling method is not empty .
public void cancel unnamed tasks ( ) { if ( unnamed task executor != null ) { unnamed task executor . shutdown now ( ) ; } }	cancel all open and running unnamed tasks.
public static double [ ] minmax ( list < double > values ) { if ( values . size ( ) == num ) { return new double [ num ] ; } double min = values . get ( num ) ; double max = min ; int length = values . size ( ) ; for ( int i = num ; i < length ; i ++ ) { double value = values . get ( i ) ; min = math . min ( min , value ) ; max = math . max ( max , value ) ; } return new double [ ] { min , max } ; }	calculate the minimum and maximum values out of a list of doubles .
public criteria create criteria ( ) { criteria criteria = create criteria internal ( ) ; if ( ored criteria . size ( ) == num ) { ored criteria . add ( criteria ) ; } return criteria ; }	this method was generated by mybatis generator . this method corresponds to the database table trash.
private char read escape character ( ) throws io { if ( pos == limit && ! fill buffer ( num ) ) { throw syntax error ( str ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case str : if ( pos + num > limit && ! fill buffer ( num ) ) { throw syntax error ( str ) ; } char result = num ; for ( int i = pos , end = i + num ; i < end ; i ++ ) { char c = buffer [ i ] ; result <<= num ; if ( c >= str && c <= str ) { result += ( c - str ) ; } else if ( c >= str && c <= str ) { result += ( c - str + num ) ; } else if ( c >= str && c <= str ) { result += ( c - str + num ) ; } else { throw new number format exception ( str + new string ( buffer , pos , num ) ) ; } } pos += num ; return result ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : line number ++ ; line start = pos ; case str : case str : case str : case str : return escaped ; default : throw syntax error ( str ) ; } }	unescapes the character identified by the character or characters that immediately follow a backslash.
private void update params for auth ( string [ ] auth names , list < pair > query params , map < string , string > header params ) { for ( string auth name : auth names ) { authentication auth = authentications . get ( auth name ) ; if ( auth == null ) throw new runtime exception ( str + auth name ) ; auth . apply to params ( query params , header params ) ; } }	update query and header parameters based on authentication settings .
private void fix spanned with spaces ( spannable string builder builder , int width measure spec , int height measure spec ) { long start fix = system . current time millis ( ) ; fixing result result = add spaces around spans until fixed ( builder , width measure spec , height measure spec ) ; if ( result . fixed ) { remove unneeded spaces ( width measure spec , height measure spec , builder , result ) ; } else { fallback to string ( width measure spec , height measure spec ) ; } long fix duration = system . current time millis ( ) - start fix ; logger . d ( tag , str + fix duration ) ; }	add spaces around spans until the text is fixed , and then removes the unneeded spaces.
private void remove bookmark tracking icons ( ) { if ( tracking icons != null ) { for ( iterator i = tracking icons . iterator ( ) ; i . has next ( ) ; ) { gutter icon impl ti = ( gutter icon impl ) i . next ( ) ; if ( ti . get icon ( ) == bookmark icon ) { i . remove ( ) ; } } } }	removes all bookmark tracking icons .
public simple metric group ( group name name , stream < ? extends metric > i ) { this ( name , i . collect ( collectors . < metric > to list ( ) ) ) ; }	create a metric group with the given metrics .
public boolean is inside ( point point ) { return bounds . contains ( point ) ; }	returns true if the point is inside this sprite.
private void resolve protocols ( class loader loader ) { service loader < protocol manager factory > service loader = service loader . load ( protocol manager factory . class , loader ) ; load protocol manager factories ( service loader ) ; }	finds protocol support from a given classloader .
public static list < inet address > host addresses ( ) { list < inet address > addr list = new array list < > ( ) ; enumeration < network interface > if = null ; try { if = network interface . get network interfaces ( ) ; } catch ( socket exception ex ) { log . error ( str , ex ) ; } if ( if != null ) { while ( if . has more elements ( ) ) { network interface ifc = if . next element ( ) ; try { if ( ifc . is up ( ) ) { enumeration < inet address > addresses = ifc . get inet addresses ( ) ; while ( addresses . has more elements ( ) ) { inet address address = addresses . next element ( ) ; if ( ! address . is loopback address ( ) && ! address . is link local address ( ) ) { addr list . add ( address ) ; } } } } catch ( socket exception ex ) { log . error ( str , ifc . to string ( ) , ex ) ; } } } return addr list ; }	a list of the non - loopback , non - link - local ip addresses of the host , or null if none found .
public final static int caculate in sample size ( bitmap factory . options options , int rqs w , int rqs h ) { final int height = options . out height ; final int width = options . out width ; int in sample size = num ; if ( rqs w == num || rqs h == num ) return num ; if ( height > rqs h || width > rqs w ) { final int height ratio = math . round ( ( float ) height / ( float ) rqs h ) ; final int width ratio = math . round ( ( float ) width / ( float ) rqs w ) ; in sample size = height ratio < width ratio ? height ratio : width ratio ; } return in sample size ; }	caculate the bitmap samplesize.
public boolean has status ( final id status ) { return statuses . contains ( status ) ; }	check if the entity has a certain status .
@ override public string to string ( ) { return str + str + instance list + str + outcome list + str + weight list + str + sequence ids + str + sequence positions + str + adding another instances allowed + str + total non null features count + str ; }	primarily for debug purposes.
static synchronized void compute prf ss ( byte [ ] out , byte [ ] secret , byte [ ] seed ) { if ( sha == null ) { init ( ) ; } int pos = num ; int iteration = num ; byte [ ] digest ; while ( pos < out . length ) { byte [ ] pref = new byte [ iteration ] ; arrays . fill ( pref , ( byte ) ( num + iteration ++ ) ) ; sha . update ( pref ) ; sha . update ( secret ) ; sha . update ( seed ) ; md5 . update ( secret ) ; md5 . update ( sha . digest ( ) ) ; digest = md5 . digest ( ) ; if ( pos + num > out . length ) { system . arraycopy ( digest , num , out , pos , out . length - pos ) ; pos = out . length ; } else { system . arraycopy ( digest , num , out , pos , num ) ; pos += num ; } } }	computes the value of sslv3 pseudo random function .
public void add channel map ( channel map channel map ) { if ( ! m channel maps . contains ( channel map ) ) { m channel maps . add ( channel map ) ; int index = m channel maps . index of ( channel map ) ; fire interval added ( this , index , index ) ; broadcast ( new channel map event ( channel map , event . add ) ) ; } }	adds the channel map to this model.
@ override public boolean add ( e o ) { if ( null == o ) { throw new null pointer exception ( ) ; } if ( offer ( o ) ) { return bool ; } throw new illegal state exception ( ) ; }	adds an element to the queue .
public object put resource ( object key , object value ) { return ( object cache . put ( key , value ) ) ; }	return the resource for the specified key.
public uid range [ ] parse uid range ( ) throws decoding exception { character validator validator = new message set char validator ( ) ; string next word = consume word ( validator , bool ) ; int comma pos = next word . index of ( str ) ; if ( comma pos == - num ) { return new uid range [ ] { parse uid range ( next word ) } ; } array list < uid range > range list = new array list < uid range > ( ) ; int pos = num ; while ( comma pos != - num ) { string range = next word . substring ( pos , comma pos ) ; uid range set = parse uid range ( range ) ; range list . add ( set ) ; pos = comma pos + num ; comma pos = next word . index of ( str , pos ) ; } string range = next word . substring ( pos ) ; range list . add ( parse uid range ( range ) ) ; list < uid range > merged = uid range . merge ranges ( range list ) ; return merged . to array ( new uid range [ merged . size ( ) ] ) ; }	reads a " message set " argument , and parses into an idset . this also support the use of $ as sequence - set as stated in searchres rfc5182.
private string replace suffix ( string value , string to replace , string change to ) { string vvalue ; if ( ( value == null ) || ( to replace == null ) || ( change to == null ) ) { return value ; } vvalue = remove suffix ( value , to replace ) ; if ( value . equals ( vvalue ) ) { return value ; } else { return vvalue + change to ; } }	replace a string suffix by another.
private void execute claimed task ( claimed task claimed task ) { if ( ! claimed task . set start time ( new date ( ) ) ) { log . info ( str , claimed task . get task ( ) ) ; return ; } scan range task task = claimed task . get task ( ) ; boolean release task = bool ; try { scan workflow . renew scan range tasks ( immutable list . of ( task ) , queue renew ttl ) ; release task = async range scan ( task ) ; } finally { unclaim task ( claimed task , release task ) ; background service . submit ( start scans if available runnable ) ; } }	executes a previously claimed scan range task .
private static boolean create navi directory ( ) { final file dir = new file ( config helper . get configuration directory ( constants . company name , constants . project name ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }	creates the configuration directory if it does not already exist .
public void update button action performed ( ) { if ( ! read receive delay ( ) ) { return ; } if ( ! read pulse width ( ) ) { return ; } if ( ! check consistency ( ) ) { return ; } if ( cur node . get node type ( ) != node type ) { cur node . set node type ( node type ) ; } set node parameters ( ) ; changed node = bool ; edit mode = bool ; cur node = null ; add button . set visible ( bool ) ; edit button . set visible ( bool ) ; delete button . set visible ( bool ) ; done button . set visible ( bool ) ; update button . set visible ( bool ) ; cancel button . set visible ( bool ) ; node addr field . set visible ( bool ) ; node addr static . set visible ( bool ) ; status text2 . set text ( std status2 ) ; status text3 . set text ( std status3 ) ; status text1 . set text ( rb . get string ( str ) + str + integer . to string ( node address ) ) ; error in status1 = bool ; }	method to handle update button.
public static class to class ( class file cf , class loader loader , protection domain domain ) throws cannot compile exception { try { byte [ ] b = to bytecode ( cf ) ; method method ; object [ ] args ; if ( domain == null ) { method = define class1 ; args = new object [ ] { cf . get name ( ) , b , new integer ( num ) , new integer ( b . length ) } ; } else { method = define class2 ; args = new object [ ] { cf . get name ( ) , b , new integer ( num ) , new integer ( b . length ) , domain } ; } return to class2 ( method , loader , args ) ; } catch ( runtime exception e ) { throw e ; } catch ( java . lang . reflect . invocation target exception e ) { throw new cannot compile exception ( e . get target exception ( ) ) ; } catch ( exception e ) { throw new cannot compile exception ( e ) ; } }	loads a class file by a given class loader .
public iterator < target > target iterator ( ) { return target list . iterator ( ) ; }	iterate over target objects representing control flow targets and their edge types .
private void fit size of scrolled content ( ) { point p = scroll composite . get size ( ) ; main . set size ( main . compute size ( p . x , swt . default ) ) ; }	fits the width of the main composite to the same width scrolled composite was given .
public int hash code ( ) { return name . hash code ( ) ; }	returns the hash code value for this entry .
private static map < string , snmp oid > build pool index map ( snmp cached data cached ) { if ( cached == null ) return collections . empty map ( ) ; final snmp oid [ ] indexes = cached . indexes ; final object [ ] datas = cached . datas ; final int len = indexes . length ; final map < string , snmp oid > m = new hash map < > ( len ) ; for ( int i = num ; i < len ; i ++ ) { final snmp oid index = indexes [ i ] ; if ( index == null ) continue ; final mx mpm = ( mx ) datas [ i ] ; if ( mpm == null ) continue ; final string name = mpm . get name ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }	builds a map pool - name = > pool - index from the snmptablehandler of the jvmmempooltable.
public d ( j parent ) throws crypto exception { super ( parent , res . get string ( str ) , modality type . document modal ) ; init components ( ) ; }	creates a new dcryptostrength dialog where the parent is a frame .
private component create separator ( ) { j sep = new j ( swing constants . vertical ) ; sep . set preferred size ( new dimension ( num , num ) ) ; sep . set minimum size ( new dimension ( num , num ) ) ; return sep ; }	creates a vertical separator for visually separating status bar elements.
public void add ( final t object ) { synchronized ( m lock ) { m list . add ( object ) ; } notify data set changed ( ) ; }	adds the specified object at the end of the array .
public void build ( realm results < t > results ) { int x index = num ; for ( t object : results ) { m values . add ( build entry from result object ( object , x index ++ ) ) ; } }	rebuilds the dataset based on the given realmresults .
public byte [ ] generate signature ( ) throws crypto exception , data length exception { content digest . do final ( m dash , m dash . length - h len - s len ) ; if ( s len != num ) { random . next bytes ( salt ) ; system . arraycopy ( salt , num , m dash , m dash . length - s len , s len ) ; } byte [ ] h = new byte [ h len ] ; content digest . update ( m dash , num , m dash . length ) ; content digest . do final ( h , num ) ; block [ block . length - s len - num - h len - num ] = num ; system . arraycopy ( salt , num , block , block . length - s len - h len - num , s len ) ; byte [ ] db mask = mask generator function1 ( h , num , h . length , block . length - h len - num ) ; for ( int i = num ; i != db mask . length ; i ++ ) { block [ i ] ^= db mask [ i ] ; } block [ num ] &= ( num > > ( ( block . length * num ) - em bits ) ) ; system . arraycopy ( h , num , block , block . length - h len - num , h len ) ; block [ block . length - num ] = trailer ; byte [ ] b = cipher . process block ( block , num , block . length ) ; clear block ( block ) ; return b ; }	generate a signature for the message we ' ve been loaded with using the key we were initialised with .
public void test neg pos first longer ( ) { byte a bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = num ; byte r bytes [ ] = { num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	and for a negative and a positive numbers ; the first is longer.
@ override public void write ( byte [ ] b , int off , int len ) { if ( ( off < num ) || ( off > b . length ) || ( len < num ) || ( ( off + len ) > b . length ) || ( ( off + len ) < num ) ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int in buffer pos = count - filled buffer sum ; while ( remaining > num ) { int part = math . min ( remaining , current buffer . length - in buffer pos ) ; system . arraycopy ( b , off + len - remaining , current buffer , in buffer pos , part ) ; remaining -= part ; if ( remaining > num ) { need new buffer ( newcount ) ; in buffer pos = num ; } } count = newcount ; } }	write the bytes to byte array .
public static void open file intent ( context context , file open file ) { if ( context != null && open file . exists ( ) ) { try { intent intent = get file intent ( context , open file ) ; context . start activity ( intent ) ; } catch ( exception e ) { global utils . log this ( tag , str , e ) ; } } }	open file using intent.
public static java . sql . date to sql date ( string date ) { java . util . date new date = to date ( date , str ) ; if ( new date != null ) { return new java . sql . date ( new date . get time ( ) ) ; } else { return null ; } }	converts a date string into a java.
public static int round ( final float value ) { final int bits = float . float to raw int bits ( value ) ; final int biased exp = bits > > num & num ; final int shift = num - num + max float exponent - biased exp ; if ( ( shift & - num ) == num ) { int extended mantissa = num | bits & num ; if ( bits < num ) { extended mantissa = - extended mantissa ; } return ( extended mantissa > > shift ) + num > > num ; } else { return ( int ) value ; } }	might have different semantics than math.
public static plain text plain ( short text ) { return plain ( integer . to string ( text ) ) ; }	creates a new plaintext component with the given short.
public attribute info copy ( const pool new cp , map classnames ) { copier copier = new copier ( info , const pool , new cp , classnames ) ; try { copier . parameters ( ) ; return new parameter annotations attribute ( new cp , get name ( ) , copier . close ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e . to string ( ) ) ; } }	copies this attribute and returns a new copy .
private string create component changes ( ) { string builder builder = new string builder ( ) ; for ( service catalog diff service catalog diff : diff list ) { builder . append ( create api changes ( service catalog diff ) ) ; } return builder . to string ( ) ; }	construct details of api changes by service and component name.
public static synchronized void it ( string description , unsafe block block ) { it ( description , identity ( ) , block ) ; }	defines a new example .
public static boolean is writable ( final file file , final boolean make dirs ) { if ( file == null ) { log . e ( file utils . class , str ) ; return bool ; } final string file parent dir = file . get parent ( ) ; if ( ! text utils . is empty ( file parent dir ) ) { final file file dir = new file ( file parent dir ) ; if ( ! file dir . exists ( ) ) { if ( make dirs ) return make dirs for file ( file ) ; else return bool ; } } boolean is writable = bool ; if ( file . exists ( ) ) is writable = file . can write ( ) ; else { try { is writable = file . create new file ( ) ; } catch ( io e ) { } if ( is writable ) is writable = file . delete ( ) ; } return is writable ; }	method checks if file could be written / deleted or created.
public string to string ( ) { return oid . to string ( ) ; }	returns a string representation of the oid ' s integer components in dot separated notation .
public void read ( byte code parser in ) throws io { int length = in . read int ( ) ; max stack = in . read short ( ) ; max locals = in . read short ( ) ; int code length = in . read int ( ) ; code = new byte [ code length ] ; in . read ( code , num , code length ) ; int exn count = in . read short ( ) ; for ( int i = num ; i < exn count ; i ++ ) { exception item exn = new exception item ( ) ; exn . set start ( in . read short ( ) & num ) ; exn . set end ( in . read short ( ) & num ) ; exn . set handler ( in . read short ( ) & num ) ; exn . set type ( in . read short ( ) & num ) ; exceptions . add ( exn ) ; } int attr count = in . read short ( ) ; for ( int i = num ; i < attr count ; i ++ ) { attribute attr = in . parse attribute ( ) ; attributes . add ( attr ) ; } }	writes the field to the output .
public void test skip ( ) throws exception { byte [ ] data = new byte [ ] { - num , - num , - num , - num , - num , num , num , num , num , num } ; test input stream tis = new test input stream ( data ) ; cipher input stream cis = new cipher input stream ( tis , new null cipher ( ) ) ; int expected = data . length ; byte [ ] result = new byte [ expected ] ; int skipped = ( int ) cis . skip ( num ) ; int ind = skipped ; int got = skipped + cis . read ( result , num , num ) ; while ( bool ) { for ( int j = num ; j < got - ind ; j ++ ) { if ( result [ j ] != data [ ind + j ] ) { fail ( str + str + data [ ind + j ] + str + result [ j ] ) ; } } if ( got == expected ) { break ; } else if ( got > expected ) { fail ( str + str + str ) ; } else { ind = got ; got += cis . read ( result , num , num ) ; } } if ( ( got = cis . read ( result , num , num ) ) != - num ) { fail ( str + str + got + str ) ; } }	skip ( long n ) method testing.
void add string ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length + num ] ; system . arraycopy ( str , num , newstr , num , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }	add a char to the string buffer .
@ override public int hash code ( ) { return oid . hash code ( ) ; }	returns the hash code for this name form.
public cholesky decomposition ( matrix arg ) { double [ ] [ ] a = arg . get array ( ) ; n = arg . get row dimension ( ) ; l = new double [ n ] [ n ] ; isspd = ( arg . get column dimension ( ) == n ) ; for ( int j = num ; j < n ; j ++ ) { double [ ] lrowj = l [ j ] ; double d = num ; for ( int k = num ; k < j ; k ++ ) { double [ ] lrowk = l [ k ] ; double s = num ; for ( int i = num ; i < k ; i ++ ) { s += lrowk [ i ] * lrowj [ i ] ; } lrowj [ k ] = s = ( a [ j ] [ k ] - s ) / l [ k ] [ k ] ; d = d + s * s ; isspd = isspd & ( a [ k ] [ j ] == a [ j ] [ k ] ) ; } d = a [ j ] [ j ] - d ; isspd = isspd & ( d > num ) ; l [ j ] [ j ] = math . sqrt ( math . max ( d , num ) ) ; for ( int k = j + num ; k < n ; k ++ ) { l [ j ] [ k ] = num ; } } }	cholesky algorithm for symmetric and positive definite matrix .
protected void find candidate crossings ( s2 point a , s2 point b , list < integer > candidate crossings ) { preconditions . check state ( index computed ) ; array list < s2 cell id > cover = lists . new array list ( ) ; get covering ( a , b , bool , cover ) ; set < integer > unique set = new hash set < integer > ( ) ; get edges in parent cells ( cover , unique set ) ; get edges in children cells ( a , b , cover , unique set ) ; candidate crossings . clear ( ) ; candidate crossings . add all ( unique set ) ; }	appends to " candidatecrossings " all edge references which may cross the given edge.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return true as of secs ; case num : return source ; case num : return system ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public repository location ( string repository name , string [ ] path components ) throws malformed repository location exception { if ( repository name == null || repository name . is empty ( ) ) { throw new malformed repository location exception ( str ) ; } if ( path components == null ) { throw new malformed repository location exception ( str ) ; } for ( string path comp : path components ) { if ( path comp == null || path comp . is empty ( ) ) { throw new malformed repository location exception ( str ) ; } } this . repository name = repository name ; this . path = path components ; }	creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .
public void add property ( string key , string value ) { carbon properties . set property ( key , value ) ; }	this method will be used to add a new property.
protected java element delta create delta tree ( i element , java element delta delta ) { java element delta child delta = delta ; array list ancestors = get ancestors ( element ) ; if ( ancestors == null ) { if ( equals and same parent ( delta . get element ( ) , get element ( ) ) ) { this . kind = delta . kind ; this . change flags = delta . change flags ; this . moved to handle = delta . moved to handle ; this . moved from handle = delta . moved from handle ; } } else { for ( int i = num , size = ancestors . size ( ) ; i < size ; i ++ ) { i ancestor = ( i ) ancestors . get ( i ) ; java element delta ancestor delta = new java element delta ( ancestor ) ; ancestor delta . add affected child ( child delta ) ; child delta = ancestor delta ; } } return child delta ; }	creates the nested delta deltas based on the affected element its delta , and the root of this delta tree.
@ override public string to string ( ) { return get title ( ) ; }	tostring . used for jcombobox in movie editor.
public int size ( ) { if ( hmap == null ) { return num ; } return hmap . size ( ) ; }	return the size of the embedded map.
public static string replace ( string in string , string old pattern , string new pattern ) { if ( ! has length ( in string ) || ! has length ( old pattern ) || new pattern == null ) { return in string ; } string builder sb = new string builder ( ) ; int pos = num ; int index = in string . index of ( old pattern ) ; int pat len = old pattern . length ( ) ; while ( index >= num ) { sb . append ( in string . substring ( pos , index ) ) ; sb . append ( new pattern ) ; pos = index + pat len ; index = in string . index of ( old pattern , pos ) ; } sb . append ( in string . substring ( pos ) ) ; return sb . to string ( ) ; }	replace all occurrences of a substring within a string with another string .
public boolean coordinate in zone ( id < activity facility > zone id , coord coordinate ) { point point = mgc . xy2 point ( coordinate . get x ( ) , coordinate . get y ( ) ) ; return point in zone ( zone id , point ) ; }	determines if a given coordinate lies within a selected zone . the shape of the zone is defined by the respective zone geometry in the shape file.
public string associator tip text ( ) { return str ; }	returns the tip text for this property.
public xwaves labelfile reader ( reader reader ) throws io { this . reader = new buffered reader ( reader ) ; parse labels ( ) ; reader . close ( ) ; }	read data from a label file .
public static double parse double default ( string s , double def ) { if ( s == null ) { return def ; } try { return double . parse double ( s ) ; } catch ( number format exception e ) { return def ; } }	parses a double safely , returning a default if nothing can be sanely parsed from it .
public static void register app ( int application , string app name ) throws id { if ( ( application & app id mask ) != application ) { throw new id ( application ) ; } string old app = app id map . put if absent ( application , app name ) ; if ( old app != null && ! old app . equals ( app name ) ) { throw new id ( application , old app , app name ) ; } }	a lame attempt to prevent duplicate application id.
public boolean put profile ( profile profile ) { return put profile ( profile , bool ) ; }	create or update a profile for a remote counterpart .
public void print ( char c ) { writer . print ( c ) ; }	prints the given char.
public void init block views ( ) { if ( m workspace view != null ) { list < block > root blocks = m workspace . get root blocks ( ) ; connection manager conn manager = m workspace . get connection manager ( ) ; for ( int i = num ; i < root blocks . size ( ) ; i ++ ) { block group bg = m view factory . build block group tree ( root blocks . get ( i ) , conn manager , m touch handler ) ; m workspace view . add view ( bg ) ; } } }	recursively initialize views for all the blocks in the model and add them to the view .
protected void clear all trails ( sso id token id ) { boolean removed = bool ; string key = token id . to string ( ) ; synchronized ( map token i ) { removed = ( map token i . remove ( key ) != null ) ; } }	clears all registered page trails of a given single sign on token id.
public d ( j parent , byte [ ] value ) throws io { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; prepopulate with value ( value ) ; }	creates a new dnetscapecarevocationurl dialog .
public static int [ ] parse number list ( string list str , int min val , int max val , boolean allow zero ) { int [ ] values ; if ( list str . index of ( str ) < num ) { values = new int [ num ] ; values [ num ] = parse int range ( list str , min val , max val , allow zero ) ; } else { string [ ] value strs = list str . split ( str ) ; int len = value strs . length ; values = new int [ len ] ; for ( int i = num ; i < len ; i ++ ) { values [ i ] = parse int range ( value strs [ i ] , min val , max val , allow zero ) ; } } return values ; }	parses a comma - separated list of integers , with range - checking .
public directory or file not found exception ( string entity , string name ) { super ( string . format ( error message , entity , name ) ) ; }	constructs a new exception with detailed error message .
void scramble ( ) { initial size = get size ( ) ; int a [ ] = new int [ initial size . height / num ] ; double f = initial size . width / ( double ) a . length ; for ( int i = a . length ; -- i >= num ; ) { a [ i ] = ( int ) ( i * f ) ; } for ( int i = a . length ; -- i >= num ; ) { int j = ( int ) ( i * math . random ( ) ) ; int t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; } arr = a ; }	fill the array with random numbers from 0.
public static sip parse sip ( string header ) throws parse exception { int start = num ; int end = header . length ( ) - num ; try { while ( header . char at ( start ) <= num ) start ++ ; while ( header . char at ( end ) <= num ) end -- ; } catch ( array index out of bounds exception e ) { throw new parse exception ( str , num ) ; } string builder buffer = new string builder ( end + num ) ; int i = start ; int line start = start ; boolean end of line = bool ; while ( i <= end ) { char c = header . char at ( i ) ; if ( c == str || c == str ) { if ( ! end of line ) { buffer . append ( header . substring ( line start , i ) ) ; end of line = bool ; } } else { if ( end of line ) { end of line = bool ; if ( c == str || c == str ) { buffer . append ( str ) ; line start = i + num ; } else { line start = i ; } } } i ++ ; } buffer . append ( header . substring ( line start , i ) ) ; buffer . append ( str ) ; header parser hp = parser factory . create parser ( buffer . to string ( ) ) ; if ( hp == null ) throw new parse exception ( str , num ) ; return hp . parse ( ) ; }	parse an individual sip message header from a string .
private static int convert srg rgb ( int color ) { float input , output ; input = color / num ; if ( input <= num ) { output = input / num ; } else { output = ( float ) math . pow ( ( input + num ) / num , num ) ; } return math . round ( output * num ) ; }	helper function to convert a color component in srgb space to linear rgb space.
public void record beginning ( ) { final string msg = str + m module name + str + m run id ; m usage messages . add ( msg ) ; diagnostic . developer log ( msg ) ; m client . record beginning ( m module name , m run id ) ; }	records a start usage logging message to whichever logging endpoint is configured.
static float rotate y ( float p x , float p y , float c x , float c y , float angle in degrees ) { double angle = math . to radians ( angle in degrees ) ; return ( float ) ( math . sin ( angle ) * ( p x - c x ) + math . cos ( angle ) * ( p y - c y ) + c y ) ; }	rotate point p around center point c .
public boolean is pronounceable ( string word ) { string lower case word = word . to lower case ( ) ; return ( prefix fsm . accept ( lower case word ) && suffix fsm . accept ( lower case word ) ) ; }	returns true if the given word is pronounceable.
public void add split edges ( list edge list ) { add endpoints ( ) ; iterator it = iterator ( ) ; edge intersection ei prev = ( edge intersection ) it . next ( ) ; while ( it . has next ( ) ) { edge intersection ei = ( edge intersection ) it . next ( ) ; edge new edge = create split edge ( ei prev , ei ) ; edge list . add ( new edge ) ; ei prev = ei ; } }	creates new edges for all the edges that the intersections in this list split the parent edge into.
public io ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public mem based cache ( int max cache size in bytes ) { m max cache size in bytes = max cache size in bytes ; m data entries = new linked hash map < string , cache header > ( num , num , bool ) ; }	constructs an instance of the membasedcache .
public void update max text widths ( float required width , float match contents width ) { m max required width = math . max ( m max required width , required width ) ; m max match contents width = math . max ( m max match contents width , match contents width ) ; }	updates the max text width values for the suggestions .
public void enable overview ( boolean b ) { if ( overview item != null ) { overview item . set enabled ( b ) ; } }	enable / disable the overview menu .
public void mouse entered ( mouse event e ) { if ( debug . debugging ( str ) ) { debug . output ( get id ( ) + str ) ; } super . mouse entered ( e ) ; auto zoom = bool ; }	handle a mouseentered mouselistener event.
public page of collections fetch page ( page of collections page , solr zk client zk client ) throws keeper exception , interrupted exception { list < string > children = get collections ( zk client ) ; page . selected = children ; if ( page . start == num && page . rows == - num && page . filter == null && children . size ( ) > num ) { page . rows = num ; page . start = num ; } if ( page . filter type == filter type . name && page . filter != null ) children = page . apply name filter ( children ) ; if ( page . filter type != filter type . status ) page . select page ( children ) ; return page ; }	gets the requested page of collections after applying filters and offsets .
public void accept ( final annotation visitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = num ; i < values . size ( ) ; i += num ) { string name = ( string ) values . get ( i ) ; object value = values . get ( i + num ) ; accept ( av , name , value ) ; } } av . visit end ( ) ; } }	makes the given visitor visit this annotation .
public ids query builder add ids ( string ... ids ) { values . add all ( arrays . as list ( ids ) ) ; return this ; }	adds ids to the filter .
private void stop ( http servlet request request , http servlet response response ) throws io { print writer out = response . get writer ( ) ; string label = request . get parameter ( str ) ; monitor mon = remove mon ( label , null , default units ) ; if ( mon == null ) { out . println ( error + str ) ; } else { mon . stop ( ) ; out . println ( ok + str + mon ) ; } }	stop a previously started monitor if it exists .
public static string normalize url ( string request url ) throws o { if ( ( request url == null ) || ( request url . length ( ) == num ) ) { throw new o ( str ) ; } uri uri ; try { uri = new uri ( request url ) ; } catch ( uri e ) { throw new o ( e ) ; } string authority = uri . get authority ( ) ; string scheme = uri . get scheme ( ) ; if ( authority == null || scheme == null ) { throw new o ( str ) ; } authority = authority . to lower case ( ) ; scheme = scheme . to lower case ( ) ; if ( ( scheme . equals ( str ) && uri . get port ( ) == num ) || ( scheme . equals ( str ) && uri . get port ( ) == num ) ) { int index = authority . last index of ( str ) ; if ( index >= num ) { authority = authority . substring ( num , index ) ; } } return scheme + str + authority + uri . get raw path ( ) ; }	calculates the normalized request url , as per section 9.
public void invoke ( input stream is , output stream os , serializer factory serializer factory ) throws exception { boolean is debug = bool ; if ( is debug invoke ( ) ) { is debug = bool ; print writer dbg = create debug print writer ( ) ; hessian debug input stream d is = new hessian debug input stream ( is , dbg ) ; d is . start top2 ( ) ; is = d is ; hessian debug output stream d os = new hessian debug output stream ( os , dbg ) ; d os . start top2 ( ) ; os = d os ; } hessian input factory . header type header = input factory . read header ( is ) ; abstract hessian input in ; abstract hessian output out ; switch ( header ) { case call 1 reply 1 : in = hessian factory . create hessian input ( is ) ; out = hessian factory . create hessian output ( os ) ; break ; case call 1 reply 2 : in = hessian factory . create hessian input ( is ) ; out = hessian factory . create hessian2 output ( os ) ; break ; case hessian 2 : in = hessian factory . create hessian2 input ( is ) ; in . read call ( ) ; out = hessian factory . create hessian2 output ( os ) ; break ; default : throw new illegal state exception ( header + str ) ; } if ( serializer factory != null ) { in . set serializer factory ( serializer factory ) ; out . set serializer factory ( serializer factory ) ; } try { invoke ( service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( is debug ) os . close ( ) ; } }	invoke the object with the request from the input stream .
private void commit local transaction ( ) throws commit failed exception { if ( tx == null ) { return ; } if ( logger . is loggable ( level . finest ) ) { logger . log ( level . finest , str + tx ) ; } try { tx . commit ( ) ; } catch ( exception e ) { if ( logger . is loggable ( level . severe ) ) { logger . log ( level . severe , str + tx , e ) ; } throw new commit failed exception ( e ) ; } }	commits the local transaction .
public static entry add object class ( entry entry ) { attribute attribute = entry . get attribute ( core token constants . object class ) ; if ( attribute == null ) { entry . add attribute ( core token constants . object class , core token constants . fr core token ) ; } return entry ; }	only adds the objectclass if it hasn ' t already been added .
@ suppress warnings ( str ) public list < boundary > populate area ( final long ward id ) { hierarchy type h type = heirarchy type service . get hierarchy type by name ( hierarchy type name ) ; ; list < boundary > area list = new linked list < boundary > ( ) ; final boundary type child boundary type = boundary type service . get boundary type by name and hierarchy type ( str , h type ) ; final boundary parent boundary = boundary service . get boundary by id ( ward id ) ; area list = new linked list ( cross heirarchy service . get cross hierarchy childrens ( parent boundary , child boundary type ) ) ; logger . info ( str + area list . to string ( ) ) ; return area list ; }	populate the area list by ward.
private static string read name ( data input stream dis , byte data [ ] ) throws io { int c = dis . read unsigned byte ( ) ; if ( ( c & num ) == num ) { c = ( ( c & num ) << num ) + dis . read unsigned byte ( ) ; hash set < integer > jumps = new hash set < integer > ( ) ; jumps . add ( c ) ; return read name ( data , c , jumps ) ; } if ( c == num ) { return str ; } byte b [ ] = new byte [ c ] ; dis . read fully ( b ) ; string s = idn . to unicode ( new string ( b ) ) ; string t = read name ( dis , data ) ; if ( t . length ( ) > num ) { s = s + str + t ; } return s ; }	parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .
public simple string concat ( final char c ) { byte [ ] bytes = new byte [ data . length + num ] ; system . arraycopy ( data , num , bytes , num , data . length ) ; bytes [ data . length ] = ( byte ) ( c & num ) ; bytes [ data . length + num ] = ( byte ) ( c > > num & num ) ; return new simple string ( bytes ) ; }	concatenates a simplestring and a char.
public static double prob to log odds ( double prob ) { if ( gr ( prob , num ) || ( sm ( prob , num ) ) ) { throw new illegal argument exception ( str + str + prob ) ; } double p = small + ( num - num * small ) * prob ; return math . log ( p / ( num - p ) ) ; }	returns the log - odds for a given probabilitiy .
private void signal not empty ( ) { final reentrant lock take lock = this . take lock ; take lock . lock ( ) ; try { not empty . signal ( ) ; } finally { take lock . unlock ( ) ; } }	signals a waiting take.
public void deep fill ( mary node spec tree ) { tree = spec tree ; number of leaves = num ; sort node ( num , tree ) ; }	fill a tree which specifies a feature hierarchy but no corresponding units .
public int node count ( ) { return nodes == null ? num : nodes . size ( ) ; }	return the number of nodes in the is way.
public void add to global blacklist ( string host ) { add to global blacklist ( host , system . current time millis ( ) + this . global blacklist timeout ) ; }	adds a host to the blacklist .
public boolean add node ( lop node ) { if ( nodes . contains ( node ) ) return bool ; nodes . add ( node ) ; return bool ; }	method to add a node to the dag .
private void write object ( java . io . object output stream s ) throws java . io . io { s . default write object ( ) ; for ( node < k , v > n = find first ( ) ; n != null ; n = n . next ) { v v = n . get valid value ( ) ; if ( v != null ) { s . write object ( n . key ) ; s . write object ( v ) ; } } s . write object ( null ) ; }	saves this map to a stream ( that is , serializes it ) .
public static final double sigma ( double a ) { return num / ( num + math . exp ( - a ) ) ; }	sigmoid / logistic function.
public void insert or refresh ( final k new entry ) { if ( new entry == null ) return ; list < k > entries ref = entries ; for ( k existing : entries ref ) { if ( existing . equals ( new entry ) ) { existing . merge in timestamps ( new entry ) ; return ; } if ( existing . match i id ( new entry ) ) { dht . log info ( str + new entry + str + existing + str ) ; return ; } } if ( new entry . verified reachable ( ) ) { if ( entries ref . size ( ) < dht . max entries per bucket ) { modify main bucket ( null , new entry ) ; return ; } if ( replace bad entry ( new entry ) ) return ; k youngest = entries ref . get ( entries ref . size ( ) - num ) ; if ( youngest . get creation time ( ) > new entry . get creation time ( ) || new entry . get rtt ( ) * num < youngest . get rtt ( ) ) { modify main bucket ( youngest , new entry ) ; insert in replacement bucket ( youngest ) ; return ; } } insert in replacement bucket ( new entry ) ; }	notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate.
public void translate ( double x , double y ) { current transform . translate ( x , y ) ; try { write transform ( new affine transform ( num , num , num , num , x , y ) ) ; } catch ( io e ) { handle exception ( e ) ; } }	translates the current transform . calls writetransform ( transform ).
private void write object ( object output stream oos ) throws io { oos . default write object ( ) ; boolean write font = ( f != om . default font ) ; oos . write boolean ( write font ) ; if ( write font ) { oos . write object ( f . get name ( ) ) ; oos . write int ( f . get size ( ) ) ; oos . write int ( f . get style ( ) ) ; } write stroke ( oos , stroke , om . basic stroke ) ; write stroke ( oos , text matte stroke , default text matte stroke ) ; }	write this object to a stream .
private static void write spaces ( writer out , int amt ) throws io { while ( amt > num ) { out . write ( str ) ; amt -- ; } }	writes the given number of spaces to the given writer .
public static double relative overlap ( spatial comparable box1 , spatial comparable box2 ) { final int dim = assert same dimensionality ( box1 , box2 ) ; double overlap = num ; double vol1 = num ; double vol2 = num ; for ( int i = num ; i < dim ; i ++ ) { final double box1min = box1 . get min ( i ) ; final double box1max = box1 . get max ( i ) ; final double box2min = box2 . get min ( i ) ; final double box2max = box2 . get max ( i ) ; final double omax = math . min ( box1max , box2max ) ; final double omin = math . max ( box1min , box2min ) ; if ( omax <= omin ) { return num ; } overlap *= omax - omin ; vol1 *= box1max - box1min ; vol2 *= box2max - box2min ; } return overlap / ( vol1 + vol2 ) ; }	computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .
protected void handle auto draw ( ) { if ( is tool item selected ( tool bar item key . auto draw ) ) { on auto draw ( ) ; } }	if auto draw is enabled , a draw request is sent.
protected final void load to have at least ( int min available ) throws io { if ( input stream == null ) { throw construct error ( str + min available + str ) ; } int amount = input end - input ptr ; curr input processed += input ptr ; if ( amount > num && input ptr > num ) { system . arraycopy ( input buffer , input ptr , input buffer , num , amount ) ; input end = amount ; } else { input end = num ; } input ptr = num ; while ( input end < min available ) { int count = input stream . read ( input buffer , input end , input buffer . length - input end ) ; if ( count < num ) { close input ( ) ; if ( count == num ) { throw new io ( str + amount + str ) ; } throw construct error ( str + min available + str + min available + str ) ; } input end += count ; } }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public z21 message ( byte [ ] a , int l ) { super ( string . value of ( a ) ) ; set binary ( bool ) ; }	this ctor interprets the byte array as a sequence of characters to send .
private method descriptor [ ] sort method descriptors ( method descriptor [ ] method descriptors ) { return method sorter != null ? method sorter . sort method descriptors ( method descriptors ) : method descriptors ; }	as of this writing , this is only used for testing if method order really doesn ' t mater .
public static properties parse property list ( string list ) throws property string format exception { return parse property list ( list , property separators , key value separators ) ; }	take a property list , defined in a single string , and return a properties object.
public boolean package has annotation ( annotation annotation ) { try { package pkg = type . get package ( ) ; if ( pkg == null ) { return bool ; } string class name = pkg . get name ( ) + str ; class < ? > package type = class . for name ( class name ) ; annotation accessor accessor = new annotation accessor ( supported annotations , package type , ignore annotation failure ) ; return accessor . type has ( annotation ) ; } catch ( class not found exception e ) { return bool ; } }	determines whether the package in which t resides has a particular annotation .
private string build tool tip ( final c node ) { final string builder tooltip = new string builder ( str ) ; boolean first = bool ; for ( final navi node graphnode : node . get graph nodes ( ) ) { if ( ! first ) { tooltip . append ( str ) ; } tooltip . append ( c . get display string ( graphnode ) ) ; first = bool ; } return tooltip + str ; }	generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes .
public boolean remove on item click listener ( on item click listener item click listener ) { return click listeners . remove ( item click listener ) ; }	remove item click listener from this view.
@ override protected int look for selectable position ( int position , boolean look down ) { final list adapter adapter = m adapter ; if ( adapter == null || is in touch mode ( ) ) { return invalid position ; } final int count = adapter . get count ( ) ; if ( ! m are all items selectable ) { if ( look down ) { position = math . max ( num , position ) ; while ( position < count && ! adapter . is enabled ( position ) ) { position ++ ; } } else { position = math . min ( position , count - num ) ; while ( position >= num && ! adapter . is enabled ( position ) ) { position -- ; } } if ( position < num || position >= count ) { return invalid position ; } return position ; } else { if ( position < num || position >= count ) { return invalid position ; } return position ; } }	find a position that can be selected ( i.
public static string pad right ( final string s , final int length ) { final int pad = length - s . length ( ) ; return pad > num ? s + get space string ( pad ) : s ; }	pad a string on the right with spaces till it is at least the specified length .
private static string [ ] collation matching rule names ( final list < string > locale names , final int num suffix , final string symbolic suffix ) { final list < string > names = new array list < > ( ) ; for ( string locale name : locale names ) { if ( symbolic suffix . is empty ( ) ) { names . add ( locale name ) ; } else { names . add ( locale name + str + num suffix ) ; names . add ( locale name + str + symbolic suffix ) ; } } return names . to array ( new string [ names . size ( ) ] ) ; }	build the complete list of names for a collation matching rule .
public static boolean is cache safe ( class < ? > clazz , class loader class loader ) { assert . not null ( clazz , str ) ; class loader target = clazz . get class loader ( ) ; if ( target == null ) { return bool ; } class loader cur = class loader ; if ( cur == target ) { return bool ; } while ( cur != null ) { cur = cur . get parent ( ) ; if ( cur == target ) { return bool ; } } return bool ; }	check whether the given class is cache - safe in the given context , i.
public void write ( print stream out ) { write ( out , table ) ; }	writes the algorithm ' s internal representation as text .
static part from ( string encoded , string decoded ) { if ( encoded == null ) { return null ; } if ( encoded . length ( ) == num ) { return empty ; } if ( decoded == null ) { return null ; } if ( decoded . length ( ) == num ) { return empty ; } return new part ( encoded , decoded ) ; }	creates a part from the encoded and decoded strings .
private int [ ] create epoch months ( int epoch day , int min year , int max year , map < integer , int [ ] > years ) { int num months = ( max year - min year + num ) * num + num ; int epoch month = num ; int [ ] epoch months = new int [ num months ] ; min month length = integer . max value ; max month length = integer . min value ; for ( int year = min year ; year <= max year ; year ++ ) { int [ ] months = years . get ( year ) ; for ( int month = num ; month < num ; month ++ ) { int length = months [ month ] ; epoch months [ epoch month ++ ] = epoch day ; if ( length < num || length > num ) { throw new illegal argument exception ( str + min year ) ; } epoch day += length ; min month length = math . min ( min month length , length ) ; max month length = math . max ( max month length , length ) ; } } epoch months [ epoch month ++ ] = epoch day ; if ( epoch month != epoch months . length ) { throw new illegal state exception ( str + epoch month + str + epoch months . length ) ; } return epoch months ; }	converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays.
private static string descriptor to internal name ( string descriptor ) { switch ( descriptor . char at ( num ) ) { case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : return descriptor ; case str : return class descriptor to internal name ( descriptor ) ; default : throw new illegal argument exception ( str + descriptor ) ; } }	convert a non - method type descriptor into an internal type .
public subscription register ( object m bean , m description ) { return register ( m bean , description . get m ( get next id ( ) ) ) ; }	register the given mbean based on the given description.
void check after unmarshalled ( ) { assert equals ( short val . short value ( ) , num ) ; assert equals ( long val , num ) ; assert null ( a arr ) ; assert null ( str val ) ; assert equals ( double val , num ) ; }	checks correctness of the state after unmarshalling .
public void put ( int key , e value ) { int i = container helpers . binary search ( m keys , m size , key ) ; if ( i >= num ) { m values [ i ] = value ; } else { i = ~ i ; if ( i < m size && m values [ i ] == deleted ) { m keys [ i ] = key ; m values [ i ] = value ; return ; } if ( m garbage && m size >= m keys . length ) { gc ( ) ; i = ~ container helpers . binary search ( m keys , m size , key ) ; } if ( m size >= m keys . length ) { int n = container helpers . ideal int array size ( m size + num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } if ( m size - i != num ) { system . arraycopy ( m keys , i , m keys , i + num , m size - i ) ; system . arraycopy ( m values , i , m values , i + num , m size - i ) ; } m keys [ i ] = key ; m values [ i ] = value ; m size ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
@ override public < r > completable future < r > collect ( final supplier < r > supplier , final bi consumer < r , ? super t > accumulator , final bi consumer < r , r > combiner ) { return completable future . supply async ( null , exec ) ; }	asynchronously perform a stream collection.
@ suppress warnings ( str ) protected object from reflection type ( final object value ) { field descriptor descriptor = get descriptor ( ) ; if ( descriptor . is repeated ( ) ) { if ( descriptor . get java type ( ) == field descriptor . java type . message || descriptor . get java type ( ) == field descriptor . java type . enum ) { final list result = new array list ( ) ; for ( final object element : ( list ) value ) { result . add ( singular from reflection type ( element ) ) ; } return result ; } else { return value ; } } else { return singular from reflection type ( value ) ; } }	convert from the type used by the reflection accessors to the type used by native accessors.
public void register manufacturer specific builder ( int company id , ad builder ) { if ( company id < num || num < company id ) { string message = string . format ( str , company id ) ; throw new illegal argument exception ( message ) ; } if ( builder == null ) { return ; } integer key = integer . value of ( company id ) ; list < ad > builders = m ms . get ( key ) ; if ( builders == null ) { builders = new array list < ad > ( ) ; m ms . put ( key , builders ) ; } builders . add ( num , builder ) ; }	register a builder for the company id.
public static reil graph copy reil code ( final window parent , final i node ) { final reil translator < i > translator = new reil translator < i > ( ) ; try { return translator . translate ( new standard environment ( ) , node ) ; } catch ( final internal translation exception e ) { c . log exception ( e ) ; final string message = str + str ; final string description = c . create description ( string . format ( str , node . get address ( ) ) , new string [ ] { str } , new string [ ] { str + str } ) ; navi error dialog . show ( parent , message , description , e ) ; } return null ; }	copy reil code for node.
private static void apply overrides ( ) { input stream stream = get content types properties stream ( ) ; if ( stream == null ) { return ; } try { try { properties overrides = new properties ( ) ; overrides . load ( stream ) ; for ( map . entry < object , object > entry : overrides . entry set ( ) ) { string extension = ( string ) entry . get key ( ) ; string mime type = ( string ) entry . get value ( ) ; add ( mime type , extension ) ; } } finally { stream . close ( ) ; } } catch ( io ignored ) { } }	this isn ' t what the ri does.
public static string to string ( reader reader , long timeout ) throws io { string writer sw = new string writer ( num ) ; copy ( to buffered reader ( reader ) , sw , timeout ) ; sw . close ( ) ; return sw . to string ( ) ; }	reads string data from a reader.
private static float compute similarity ( lane a , lane b ) { int same = num ; int diff = num ; int first coordinate = math . max ( a . get first non gap position ( ) , b . get first non gap position ( ) ) ; int last coordinate = math . min ( a . get last non gap position ( ) , b . get last non gap position ( ) ) ; for ( int i = first coordinate ; i <= last coordinate ; i ++ ) { char cha = a . char at ( i ) ; char chb = b . char at ( i ) ; if ( character . is letter ( cha ) && character . is letter ( chb ) ) { if ( character . to lower case ( cha ) == character . to lower case ( ( chb ) ) ) same ++ ; else diff ++ ; } } return math . max ( same > num ? num : num , same - num * diff ) ; }	computes the similarity of two sequences.
private void force overflow ( ) { force overflow ( ) ; }	gratuitous and stupid recursion.
public int find ( string string ) { if ( string == null ) { return - num ; } for ( int i = num ; i != m string offsets . length ; ++ i ) { int offset = m string offsets [ i ] ; int length = get short ( m strings , offset ) ; if ( length != string . length ( ) ) { continue ; } int j = num ; for ( ; j != length ; ++ j ) { offset += num ; if ( string . char at ( j ) != get short ( m strings , offset ) ) { break ; } } if ( j == length ) { return i ; } } return - num ; }	finds index of the string.
public string prep operand ( string label , data type dt , value type vt , boolean literal ) { string builder sb = new string builder ( ) ; sb . append ( label ) ; sb . append ( lop . datatype prefix ) ; sb . append ( dt ) ; sb . append ( lop . valuetype prefix ) ; sb . append ( vt ) ; sb . append ( lop . literal prefix ) ; sb . append ( literal ) ; return sb . to string ( ) ; }	method to prepare instruction operand with given parameters .
public static list < space time > divide conquer brownian bridge ( multivariate normal distribution normal , space time start , space time end , int depth , int max tries , space time rejector rejector ) { list < space time > points = new linked list < space time > ( ) ; points . add ( start ) ; points . add ( end ) ; stop = bool ; if ( divide conquer brownian bridge ( normal , num , points , depth , max tries , rejector ) == ( num << ( depth - num ) ) ) { return points ; } stop = bool ; return null ; }	divide and conquer brownian bridge ; not thread - safe ! ! ! ! !.
public static ejb jar xml version value of ( document type doc type ) throws null pointer exception { return value of ( doc type . get public id ( ) ) ; }	returns the version corresponding to the given document type .
public static list < double > merge coords ( list < double > x , list < double > y ) { if ( x . size ( ) != y . size ( ) ) throw new illegal argument exception ( str ) ; list < double > ret = new array list < > ( ) ; for ( int i = num ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }	this will merge the coordinates of the given coordinate system .
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }	prints an integer to standard output and flushes standard output .
public void copy text ( ) { int end , start ; end = selected char field . get selection end ( ) ; start = selected char field . get selection start ( ) ; selected char field . select all ( ) ; selected char field . copy ( ) ; selected char field . select ( start , end ) ; }	copy text . copy all sample text to the system clipboard . remember the current caret position ( selection ) and restore that afterwards .
public void handle button1 request ( request invocation event event ) throws model control exception { try { auth properties model model = ( auth properties model ) get model ( ) ; map original = model . get values ( ) ; am ps = ( am ) get child ( property attribute ) ; model . set values ( ps . get attribute values ( original , bool , model ) ) ; set inline alert message ( cc . type info , str , str ) ; } catch ( am a ) { set inline alert message ( cc . type error , str , a . get message ( ) ) ; } forward to ( ) ; }	handles save button request .
private void build description panel ( final composite parent ) { description label = new styled text ( parent , swt . read only ) ; description label . set text ( str ) ; description label . set layout data ( new grid data ( grid data . fill , grid data . fill , bool , bool , num , num ) ) ; }	build the description panel.
public http method client ( ) { this ( num , num , num * num ) ; }	creates a new http method client with default timeouts .
public is pss ( asymmetric block cipher cipher , digest digest , int salt length , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; this . h len = digest . get digest size ( ) ; this . salt length = salt length ; if ( implicit ) { trailer = trailer implicit ; } else { integer trailer obj = ( integer ) trailer map . get ( digest . get algorithm name ( ) ) ; if ( trailer obj != null ) { trailer = trailer obj . int value ( ) ; } else { throw new illegal argument exception ( str ) ; } } }	generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .
string decode text value ( byte [ ] data ) throws io { boolean is compressed = ( ( data . length > num ) && ( data [ num ] == text compression header [ num ] ) && ( data [ num ] == text compression header [ num ] ) ) ; if ( is compressed ) { string builder text buf = new string builder ( data . length ) ; int data start = text compression header . length ; int data end = data start ; boolean in compressed mode = bool ; while ( data end < data . length ) { if ( data [ data end ] == ( byte ) num ) { decode text segment ( data , data start , data end , in compressed mode , text buf ) ; in compressed mode = ! in compressed mode ; ++ data end ; data start = data end ; } else { ++ data end ; } } decode text segment ( data , data start , data end , in compressed mode , text buf ) ; return text buf . to string ( ) ; } return decode uncompressed text ( data , get charset ( ) ) ; }	decodes a compressed or uncompressed text value .
private < s , t > set < t > extract ( final collection < s > collection , final extractor < s , t > extractor ) { final set < t > values = new hash set < t > ( collection . size ( ) ) ; for ( final s instance : collection ) { values . add ( extractor . get value ( instance ) ) ; } return values ; }	extract a set of a defined type from the passed collection using the given extractor .
public static boolean is zte ( ) { return s build model . starts with ( str ) ; }	whether the stack is running on a zte device.
static public string normalize to encoding ( string orig string , charset encoding ) { string norm string = orig string ; charset encoder encoder = encoding . new encoder ( ) ; if ( ! encoder . can encode ( orig string ) ) { final int length = orig string . length ( ) ; char [ ] norm seq = new char [ ( orig string . length ( ) ) ] ; int char num = num ; for ( int offset = num ; offset < length ; ) { pair < character , integer > replacement = normalize codepoint ( orig string , encoding , offset ) ; character replaced char = replacement . get first ( ) ; int codepoint = replacement . get second ( ) ; if ( null != replaced char ) { norm seq [ char num ] = replaced char ; char num ++ ; } offset += character . char count ( codepoint ) ; } norm string = new string ( norm seq ) ; } return norm string ; }	tries to normalize string to specified encoding.
private fast concurrent skip list map . node < k , v > lo node ( ) { if ( lo == null ) return m . find first ( ) ; else if ( lo inclusive ) return m . find near ( lo , m . gt | m . eq ) ; else return m . find near ( lo , m . gt ) ; }	returns lowest node . this node might not be in range , so most usages need to check bounds.
public int size ( ) { return m sets . size ( ) ; }	get the number of item sets .
public d ( stack < vector3 > points , float thickness , int [ ] colors , boolean create vb ) { super ( ) ; m points = points ; m line thickness = thickness ; m colors = colors ; if ( colors != null && colors . length != points . size ( ) ) throw new runtime exception ( str ) ; init ( create vb ) ; }	creates a line primitive with a specified color for each point .
public static byte [ ] as unsigned byte array ( big integer value ) { byte [ ] bytes = value . to byte array ( ) ; if ( bytes [ num ] == num ) { byte [ ] tmp = new byte [ bytes . length - num ] ; system . arraycopy ( bytes , num , tmp , num , tmp . length ) ; return tmp ; } return bytes ; }	return the passed in value as an unsigned byte array .
public static float approximate length ( float control points [ ] [ ] ) { float length = num ; for ( int i = num ; i < control points . length - num ; i ++ ) { float x dif = control points [ i + num ] [ num ] - control points [ i ] [ num ] ; float y dif = control points [ i + num ] [ num ] - control points [ i ] [ num ] ; float z dif = control points [ i + num ] [ num ] - control points [ i ] [ num ] ; length += math . sqrt ( x dif * x dif + y dif * y dif + z dif * z dif ) ; } return length ; }	compute an approximate length of a bezier curve given the control points .
protected int map drag operation from modifiers ( mouse event e ) { int mods = e . get modifiers ex ( ) ; int btns = mods & button mask ; if ( ! ( btns == input event . butto down mask || btns == input event . butto down mask ) ) { return d . action none ; } return sun drag source context peer . convert modifiers to drop action ( mods , get source actions ( ) ) ; }	determine the drop action from the event.
public update clause add assignment ( expression expression ) { assignments . add ( new assignment ( expression ) ) ; return this ; }	adds a property to set to the clause .
private boolean step value ( ) { while ( bool ) { if ( iter != null && iter . has next ( ) ) { svcs = ( array list ) iter . next ( ) ; svcidx = svcs . size ( ) ; return bool ; } if ( ! step class ( ) ) return bool ; if ( iter == null ) return bool ; } }	step to the next hashmap value , if any , reset svcs and svcidx , and return false if everything exhausted .
private array list < icon marker > create icon markers ( ) { final array list < icon marker > icon markers = new array list < > ( locations . length ) ; icon markers . add ( new icon marker ( locations [ num ] , r . drawable . bread , r . drawable . bread c ) ) ; icon markers . add ( new icon marker ( locations [ num ] , r . drawable . butcher , r . drawable . butcher c ) ) ; icon markers . add ( new icon marker ( locations [ num ] , r . drawable . fruits , r . drawable . fruits c ) ) ; icon markers . add ( new icon marker ( locations [ num ] , r . drawable . grocery , r . drawable . grocery c ) ) ; icon markers . add ( new icon marker ( locations [ num ] , r . drawable . patisserie , r . drawable . patisserie c ) ) ; return icon markers ; }	icons courtesy of https : / / mapicons.
public void has network connection ( network request check listener listener ) { if ( has network connection ( ) ) { test network request ( listener ) ; } else { listener . on no response ( ) ; } }	utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .
public void assign thread for subscriber ( @ non null object subscriber ) { looper looper = looper . my looper ( ) ; if ( looper != null ) { m subscribers default threads . put ( new identity weak reference key < > ( subscriber ) , looper != looper . get main looper ( ) ? new handler ( looper ) : m ui thread handler ) ; } else { m subscribers default threads . remove ( new identity weak reference key < > ( subscriber ) ) ; } }	assign current thread to the subscriber object.
private void validate dynamic attribute ( set dynamic set ) throws policy exception { if ( debug . message enabled ( ) ) { debug . message ( str + str + dynamic set ) ; } response attr names = new hash set ( ) ; repo attr names = new hash set ( ) ; response attr to repo attr = new hash map ( ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + valid dynamic attr names ) ; } set dynamic attrs = ( ( set ) properties . get ( dynamic attribute ) ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + dynamic attrs ) ; } iterator dynamic attrs iter = dynamic attrs . iterator ( ) ; while ( dynamic attrs iter . has next ( ) ) { string attr = ( string ) dynamic attrs iter . next ( ) ; if ( ! valid dynamic attr names . contains ( attr ) ) { if ( debug . warning enabled ( ) ) { debug . warning ( str + str + str + attr ) ; } continue ; } string [ ] attr names = parse dynamic attr name ( attr ) ; string response attr name = attr names [ num ] ; string repo attr name = attr names [ num ] ; response attr names . add ( response attr name ) ; repo attr names . add ( repo attr name ) ; add to response attr to repo attr map ( response attr name , repo attr name ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + str + response attr name + str + repo attr name ) ; } } if ( debug . message enabled ( ) ) { debug . message ( str + str + response attr to repo attr ) ; debug . message ( str + str ) ; } }	this method validates the dynamic_attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in " responseattr = repoattr " format else , throws policyexception.
public static boolean type check ( class type , object instance ) { return type . is assignable from ( instance . get class ( ) ) || is wrapper instance ( type , instance ) ; }	check if an object is an instance of a given class , or , if the class is a primitive type , if the object is an instance of the wrapper class for that primitive ( e.
public synchronized void init ( ) { array list < warrant > temp list = new array list < warrant > ( ) ; list < string > system name list = manager . get system name list ( ) ; iterator < string > iter = system name list . iterator ( ) ; while ( iter . has next ( ) ) { warrant w = manager . get by system name ( iter . next ( ) ) ; if ( ! war list . contains ( w ) ) { w . add property change listener ( this ) ; } else { war list . remove ( w ) ; } temp list . add ( w ) ; } for ( int i = num ; i < war list . size ( ) ; i ++ ) { warrant w = war list . get ( i ) ; if ( ! war nx . contains ( w ) ) { w . remove property change listener ( this ) ; } } for ( int i = num ; i < war nx . size ( ) ; i ++ ) { temp list . add ( war nx . get ( i ) ) ; } war list = temp list ; }	preserve current listeners so that there is no gap to miss a propertychange.
public void add command ( command cmd , int offset ) { menu bar . add command ( cmd , offset ) ; }	adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location.
public boolean connect ( final string address ) { if ( m bluetooth adapter == null || address == null ) { log . w ( tag , str ) ; return bool ; } if ( m bluetooth device address != null && address . equals ( m bluetooth device address ) && m bluetooth gatt != null ) { log . d ( tag , str ) ; if ( m bluetooth gatt . connect ( ) ) { m connection state = state connecting ; return bool ; } else { return bool ; } } final bluetooth device device = m bluetooth adapter . get remote device ( address ) ; if ( device == null ) { log . w ( tag , str ) ; return bool ; } m bluetooth gatt = device . connect gatt ( this , bool , m gatt callback ) ; log . d ( tag , str ) ; m bluetooth device address = address ; m connection state = state connecting ; return bool ; }	connects to the gatt server hosted on the bluetooth le device .
private double normal dens ( double x , double mean , double std dev ) { double diff = x - mean ; return ( num / ( m norm const * std dev ) ) * math . exp ( - ( diff * diff / ( num * std dev * std dev ) ) ) ; }	density function of normal distribution .
private static void draw shape ( g gl , shape s ) { path iterator it = s . get path iterator ( new affine transform ( ) , shape flatness ) ; float [ ] last move to = new float [ num ] ; float [ ] f = new float [ num ] ; while ( ! it . is done ( ) ) { int res = it . current segment ( f ) ; switch ( res ) { case path iterator . seg close : gl . v ( gl , last move to [ num ] , last move to [ num ] ) ; break ; case path iterator . seg moveto : gl . v ( gl , f [ num ] , f [ num ] ) ; system . arraycopy ( f , num , last move to , num , num ) ; break ; case path iterator . seg lineto : gl . v ( gl , f [ num ] , f [ num ] ) ; break ; case path iterator . seg cubicto : d c = new d . float ( last move to [ num ] , last move to [ num ] , f [ num ] , f [ num ] , f [ num ] , f [ num ] , f [ num ] , f [ num ] ) ; draw shape ( gl , c ) ; break ; default : throw new error ( str + str + res ) ; } it . next ( ) ; } }	draw the given shape on the given opengl object .
@ override protected void tear down ( ) throws naming exception , jms { naming enumeration < binding > iter = context . list bindings ( str ) ; while ( iter . has more ( ) ) { binding binding = iter . next ( ) ; object conn factory = binding . get object ( ) ; if ( conn factory instanceof mq ) { } } }	stops all existing activemqconnectionfactory in context .
protected list < uri > load ( final input stream in ) throws sax , io { sax sax parser ; final sax factory = sax . new instance ( ) ; try { sax parser = factory . new sax ( ) ; } catch ( final parser configuration exception ex ) { throw new sax ( ex ) ; } groups = new linked list < uri > ( ) ; sax parser . parse ( in , this ) ; return groups ; }	load and returns the list of files .
public final void lazy set ( long new value ) { unsafe . put ordered long ( this , value offset , new value ) ; }	eventually sets to the given value .
private static list < object > create equality key ( node node ) { list < object > values = new array list < object > ( ) ; values . add ( node . get node type ( ) ) ; values . add ( node . get node name ( ) ) ; values . add ( node . get local name ( ) ) ; values . add ( node . get namespace uri ( ) ) ; values . add ( node . get prefix ( ) ) ; values . add ( node . get node value ( ) ) ; for ( node child = node . get first child ( ) ; child != null ; child = child . get next sibling ( ) ) { values . add ( child ) ; } switch ( node . get node type ( ) ) { case document type node : document type impl doctype = ( document type impl ) node ; values . add ( doctype . get public id ( ) ) ; values . add ( doctype . get system id ( ) ) ; values . add ( doctype . get internal subset ( ) ) ; values . add ( doctype . get entities ( ) ) ; values . add ( doctype . get notations ( ) ) ; break ; case element node : element element = ( element ) node ; values . add ( element . get attributes ( ) ) ; break ; } return values ; }	returns a list of objects such that two nodes are equal if their lists are equal.
@ deprecated public static string collection2 string ( collection < ? > in , string separator ) { if ( in == null ) { return null ; } return iterator2 string ( in . iterator ( ) , separator ) ; }	this concatenates the elements of a collection in a string.
public static byte [ ] decode base64 ( string base64 str ) { return datatype converter . parse base64 binary ( base64 str ) ; }	decodes a base 64 encoded string into byte array .
protected void remove all premove drops ( ) { for ( premove info info : premoves . to array ( new premove info [ num ] ) ) { if ( info . is premove drop ) { premoves . remove ( info ) ; } } }	removes all of the premove drops from premoves .
public void test clear bit zero ( ) { byte a bytes [ ] = { num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . clear bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	clearbit ( int n ) outside zero.
public void stop ( ) { throttle . set speed setting ( - num ) ; throttle . set speed setting ( num ) ; stop label . set icon ( stop icon ) ; stop label . set icon text gap ( gap ) ; pack ( ) ; }	perform an emergency stop.
public void encode ( output stream out ) throws io { der output stream tmp = new der output stream ( ) ; dn name . encode ( tmp ) ; out . write ( tmp . to byte array ( ) ) ; }	encode the name in der form to the stream .
public void make dirty ( ) { beta changed = bool ; new mode = bool ; precision changed = bool ; regression interface . make dirty ( instance ) ; }	forces a complete recalculation of the likelihood next time getlikelihood is called.
private array list < e > to array list ( ) { array list < e > list = new array list < e > ( ) ; for ( node < e > p = first ( ) ; p != null ; p = succ ( p ) ) { e item = p . item ; if ( item != null ) list . add ( item ) ; } return list ; }	creates an array list and fills it with elements of this list.
public boolean remove ( http connection connection ) { time values times = connection to times . remove ( connection ) ; if ( times == null ) { log . warn ( str ) ; return bool ; } else { return system . current time millis ( ) <= times . time expires ; } }	removes the given connection from the list of connections to be closed when idle.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
private list < string > split ( string prefix ) { list < string > parts = new array list < string > ( ) ; int bracket count = num ; boolean inquotes = bool ; int last index = num ; for ( int i = num ; i < prefix . length ( ) ; i ++ ) { char c = prefix . char at ( i ) ; if ( c == str ) { bracket count ++ ; continue ; } else if ( c == str ) { inquotes = ! inquotes ; continue ; } else if ( c == str ) { bracket count -- ; if ( bracket count < num ) { throw new runtime exception ( str + prefix ) ; } continue ; } if ( c == str && ! inquotes && bracket count == num ) { parts . add ( prefix . substring ( last index , i ) ) ; last index = i + num ; } } if ( last index < prefix . length ( ) - num && ! inquotes && bracket count == num ) { parts . add ( prefix . substring ( last index ) ) ; } return parts ; }	given some dot separated prefix , split on the colons that are not within quotes , and not within brackets .
public static long lower hex to unsigned long ( string lower hex ) { int length = lower hex . length ( ) ; if ( length < num || length > num ) throw isnt lower hex long ( lower hex ) ; int i = length > num ? length - num : num ; long result = num ; for ( ; i < length ; i ++ ) { char c = lower hex . char at ( i ) ; result <<= num ; if ( c >= str && c <= str ) { result |= c - str ; } else if ( c >= str && c <= str ) { result |= c - str + num ; } else { throw isnt lower hex long ( lower hex ) ; } } return result ; }	parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .
public static double sample skew standard error ( int size ) { int n = size ; return math . sqrt ( num * n * ( n - num ) / ( ( n - num ) * ( n + num ) * ( n + num ) ) ) ; }	return the standard error of the sample skew.
public void load ( list < policy qualifier info > policy qualifier info ) { policy qualifier info [ ] policy qualifier info array = policy qualifier info . to array ( new policy qualifier info [ policy qualifier info . size ( ) ] ) ; arrays . sort ( policy qualifier info array , new policy qualifier info comparator ( ) ) ; data = new object [ policy qualifier info array . length ] [ num ] ; int i = num ; for ( policy qualifier info policy qual info : policy qualifier info array ) { data [ i ] [ num ] = policy qual info ; i ++ ; } fire table data changed ( ) ; }	load the policyqualifierinfotablemodel with policy qualifier info .
public void run script ( reader reader ) throws io , sql { try { boolean original auto commit = connection . get auto commit ( ) ; try { if ( original auto commit != this . auto commit ) { connection . set auto commit ( this . auto commit ) ; } run script ( connection , reader ) ; } finally { connection . set auto commit ( original auto commit ) ; } } catch ( io | sql e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( str + e , e ) ; } }	runs an sql script ( read in using the reader parameter ).
marker segment find marker segment ( class cls , boolean first ) { if ( first ) { iterator iter = marker sequence . iterator ( ) ; while ( iter . has next ( ) ) { marker segment seg = ( marker segment ) iter . next ( ) ; if ( cls . is instance ( seg ) ) { return seg ; } } } else { list iterator iter = marker sequence . list iterator ( marker sequence . size ( ) ) ; while ( iter . has previous ( ) ) { marker segment seg = ( marker segment ) iter . previous ( ) ; if ( cls . is instance ( seg ) ) { return seg ; } } } return null ; }	returns the first or last markersegment object in the list of the given class , or null if none is found .
default filterable < t > remove all ( final t ... values ) { return remove all ( stream . of ( values ) ) ; }	remove all supplied elements from this filterable.
public void reset ( boolean clear ) { got version = bool ; got header length = bool ; got header = bool ; got body = bool ; got body boundary = bool ; header length = num ; body length = num ; body bytes received = num ; if ( clear ) { buffer offset = num ; buffer . clear ( ) ; body file = null ; if ( body stream != null ) { try { body stream . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } body stream = null ; } } }	reset the state of the receiver in preparation for a new sessionmessage .
void remove at ( final int remove index ) { final object [ ] items = this . items ; if ( remove index == take index ) { items [ take index ] = null ; take index = inc ( take index ) ; count -- ; if ( itrs != null ) itrs . element dequeued ( ) ; } else { final int put index = this . put index ; for ( int i = remove index ; ; ) { int next = inc ( i ) ; if ( next != put index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed at ( remove index ) ; } not full . signal ( ) ; }	deletes item at array index removeindex.
private void save and close ( boolean save ) { content . set enabled ( bool ) ; if ( timer != null ) { timer . cancel ( ) ; timer = null ; } if ( timer next sync != null ) { timer next sync . cancel ( ) ; timer next sync = null ; } if ( save ) { log . d ( log tag , str ) ; save data ( null ) ; } else { log . d ( log tag , str ) ; } intent data = new intent ( ) ; data . set action ( intent . action view ) ; data . put extra ( param note , note ) ; data . put extra ( param note position , note position ) ; set result ( result ok , data ) ; finish ( ) ; }	saves all changes and closes the activity.
public static uri add message ( content resolver resolver , string address , string body , string subject , long date , boolean delivery report , long thread id ) { final uri content uri = uri . parse ( str ) ; return add message to uri ( resolver , content uri , address , body , subject , date , bool , delivery report , thread id ) ; }	add an sms to the out box .
public static < t > void blocking subscribe print ( observable < t > observable , string name ) { count down latch latch = new count down latch ( num ) ; subscribe print ( observable . finally do ( null ) , name ) ; try { latch . await ( ) ; } catch ( interrupted exception e ) { } }	subscribes to an observable , printing all its emissions.
public static final double calc nice number ( final double range , final boolean round ) { double nice fraction ; double exponent = math . floor ( math . log10 ( range ) ) ; double fraction = range / math . pow ( num , exponent ) ; if ( round ) { if ( double . compare ( fraction , num ) < num ) { nice fraction = num ; } else if ( double . compare ( fraction , num ) < num ) { nice fraction = num ; } else if ( double . compare ( fraction , num ) < num ) { nice fraction = num ; } else { nice fraction = num ; } } else { if ( double . compare ( fraction , num ) <= num ) { nice fraction = num ; } else if ( double . compare ( fraction , num ) <= num ) { nice fraction = num ; } else if ( double . compare ( fraction , num ) <= num ) { nice fraction = num ; } else { nice fraction = num ; } } return nice fraction * math . pow ( num , exponent ) ; }	returns a " nicescaling " number approximately equal to the range.
private static final boolean copy header ( string name , string from req , string buffer buf ) { int start = from req . index of ( name ) ; if ( start != - num ) { int end = from req . index of ( str , start ) ; if ( end != - num ) { buf . append ( from req . sub sequence ( start - num , end ) ) ; return bool ; } } return bool ; }	copies a header from a request.
public void send metric ( final string name , final double value ) { logger . debug ( string . format ( str , name , value ) ) ; if ( telemetry client != null ) { telemetry client . track metric ( name , value ) ; } }	call sendmetric to track the new value of the named metric .
default document put all ( iterable < field > fields , predicate < char sequence > acceptable field names ) { for ( field field : fields ) { if ( acceptable field names . test ( field . get name ( ) ) ) { set value ( field . get name ( ) , field . get value ( ) ) ; } } return this ; }	attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .
public static url find resource base ( string base resource , class loader loader ) { url url = loader . get resource ( base resource ) ; return find resource base ( url , base resource ) ; }	find the classpath url for a specific classpath resource.
public string to epl ( ep formatter ) { string writer writer = new string writer ( ) ; to epl ( formatter , writer ) ; return writer . to string ( ) ; }	rendering using the provided formatter .
public boolean is specified ( int index ) { if ( ( index < num ) || ( index >= m length ) ) { throw new array index out of bounds exception ( str ) ; } string str = m items [ ( index << num ) + num ] ; return ( ( str != null ) ? ( str . char at ( num ) == str ) : bool ) ; }	returns true unless the attribute value was provided by dtd defaulting .
public stat archive reader ( string archive name ) throws io { this ( new file [ ] { new file ( archive name ) } , null , bool ) ; }	creates a statarchivereader that will read the named archive file .
private static void init adb socket addr ( ) { try { s adb server port = get adb server port ( ) ; inet address host addr = inet address . get by name ( default adb host ) ; s socket addr = new inet socket address ( host addr , s adb server port ) ; } catch ( unknown host exception e ) { } }	instantiates ssocketaddr with the address of the host ' s adb process .
public int read ( long file offset , byte [ ] buffer , int offset , int length ) throws io { file . seek ( file offset ) ; return file . read ( buffer , offset , length ) ; }	reads a block from a given location .
private boolean matches any tag ( string tag name ) { return tag names . contains ( tag name ) ; }	tries to match tagname to known tag names .
default void shutdown ( ) { platform . exit ( ) ; }	shuts down the application by delegating service cleanups to the application thread .
public boolean is expanded ( int row ) { ui tree = get ui ( ) ; if ( tree != null ) { tree path path = tree . get path for row ( this , row ) ; if ( path != null ) { boolean value = expanded state . get ( path ) ; return ( value != null && value . boolean value ( ) ) ; } } return bool ; }	returns true if the node at the specified display row is currently expanded .
private static int label end ( string s ) { int colon index = s . index of ( str ) ; int semicolon index = s . index of ( str ) ; if ( ( semicolon index == - num ) || ( colon index < semicolon index ) ) { return colon index ; } else { return - num ; } }	determines the position in the string where a label that might be contained ends.
public void add listener ( animator listener listener ) { if ( m listeners == null ) { m listeners = new array list < animator listener > ( ) ; } m listeners . add ( listener ) ; }	adds a listener to the set of listeners that are sent events through the life of an animation , such as start , repeat , and end .
public http method info ( method method , object handler , object [ ] args , multivalued map < string , object > form parameters , response responder ) { this . method = method ; this . handler = handler ; this . args = arrays . copy of ( args , args . length ) ; this . form parameters = form parameters ; this . responder = responder ; }	construct httpmethodinfo object for a handler method that does not support streaming .
public static boolean equals ( byte [ ] [ ] field1 , byte [ ] [ ] field2 ) { int index1 = num ; int length1 = field1 == null ? num : field1 . length ; int index2 = num ; int length2 = field2 == null ? num : field2 . length ; while ( bool ) { while ( index1 < length1 && field1 [ index1 ] == null ) { index1 ++ ; } while ( index2 < length2 && field2 [ index2 ] == null ) { index2 ++ ; } boolean at end of1 = index1 >= length1 ; boolean at end of2 = index2 >= length2 ; if ( at end of1 && at end of2 ) { return bool ; } else if ( at end of1 != at end of2 ) { return bool ; } else if ( ! arrays . equals ( field1 [ index1 ] , field2 [ index2 ] ) ) { return bool ; } index1 ++ ; index2 ++ ; } }	checks repeated bytes field equality.
private void draw text ( int x1 , int y1 , int s , boolean e or n , graphics g ) { color old color = g . get color ( ) ; g . set paint mode ( ) ; if ( m == null ) { g . set color ( color . black ) ; } else { g . set color ( m ) ; } string st ; if ( e or n ) { edge e = m edges [ s ] . m edge ; for ( int noa = num ; ( st = e . get line ( noa ) ) != null ; noa ++ ) { g . draw string ( st , ( m edges [ s ] . m width - m font size . string width ( st ) ) / num + x1 , y1 + ( noa + num ) * m font size . get height ( ) ) ; } } else { node e = m nodes [ s ] . m node ; for ( int noa = num ; ( st = e . get line ( noa ) ) != null ; noa ++ ) { g . draw string ( st , ( m nodes [ s ] . m width - m font size . string width ( st ) ) / num + x1 , y1 + ( noa + num ) * m font size . get height ( ) ) ; } } g . set color ( old color ) ; }	draws the text for either an edge or a node .
public void update ( list < race > races ) { if ( current race == null ) { return ; } if ( races . contains ( current race ) ) { set race ( races . get ( races . index of ( current race ) ) ) ; } }	give this list of races , whereas the dialog picks out the one it currently has open ( if present ) .
public boolean required ( ) { return parameter metadata . contains ( metadata . required ) ; }	indicates whether the parameter is required.
protected void send data to receiver ( result receiver receiver , intent original intent , serializable data ) { if ( receiver != null && data != null ) { bundle bundle = new bundle ( ) ; bundle . put parcelable ( service receiver . extra original intent , original intent ) ; bundle . put serializable ( service receiver . extra data , data ) ; receiver . send ( service receiver . status data , bundle ) ; } }	sends data to the receiver , usually the creator of the service intent .
public void print ( print writer output , int w , int d ) { decimal format format = new decimal format ( ) ; format . set decimal format symbols ( new decimal format symbols ( locale . us ) ) ; format . set minimum integer digits ( num ) ; format . set maximum fraction digits ( d ) ; format . set minimum fraction digits ( d ) ; format . set grouping used ( bool ) ; print ( output , format , w + num ) ; }	print the matrix to the output stream.
public static < e > set < e > new set from map ( map < e , boolean > map ) { if ( map . is empty ( ) ) { return new set from map < e > ( map ) ; } throw new illegal argument exception ( ) ; }	answers a set backed by a map.
public void remove biome type ( biome dictionary . type type ) { array list < biome gen base > entry list = new array list < biome gen base > ( ) ; entry list . add all ( arrays . as list ( biome dictionary . get biomes for type ( type ) ) ) ; for ( biome gen base biome : entry list ) { iterator < biome entry > iterator = allowed biomes . iterator ( ) ; while ( iterator . has next ( ) ) { if ( biome dictionary . are biomes equivalent ( iterator . next ( ) . biome , biome ) ) iterator . remove ( ) ; } } }	removes all biomes of this type from the list of biomes allowed to generate.
static size requirements calculate tiled requirements ( layout iterator iter , size requirements r ) { long minimum = num ; long maximum = num ; long preferred = num ; int last margin = num ; int total spacing = num ; int n = iter . get count ( ) ; for ( int i = num ; i < n ; i ++ ) { iter . set index ( i ) ; int margin0 = last margin ; int margin1 = ( int ) iter . get leading collapse span ( ) ; total spacing += math . max ( margin0 , margin1 ) ; preferred += ( int ) iter . get preferred span ( num ) ; minimum += iter . get minimum span ( num ) ; maximum += iter . get maximum span ( num ) ; last margin = ( int ) iter . get trailing collapse span ( ) ; } total spacing += last margin ; total spacing += num * iter . get border width ( ) ; minimum += total spacing ; preferred += total spacing ; maximum += total spacing ; if ( r == null ) { r = new size requirements ( ) ; } r . minimum = ( minimum > integer . max value ) ? integer . max value : ( int ) minimum ; r . preferred = ( preferred > integer . max value ) ? integer . max value : ( int ) preferred ; r . maximum = ( maximum > integer . max value ) ? integer . max value : ( int ) maximum ; return r ; }	calculate the requirements needed to tile the requirements given by the iterator that would be tiled.
public static void write padded integer ( writer out , long value , int size ) throws io { int int value = ( int ) value ; if ( int value == value ) { write padded integer ( out , int value , size ) ; } else if ( size <= num ) { out . write ( long . to string ( value ) ) ; } else { if ( value < num ) { out . write ( str ) ; if ( value != long . min value ) { value = - value ; } else { for ( ; size > num ; size -- ) { out . write ( str ) ; } out . write ( str ) ; return ; } } int digits = ( int ) ( math . log ( value ) / log 10 ) + num ; for ( ; size > digits ; size -- ) { out . write ( str ) ; } out . write ( long . to string ( value ) ) ; } }	converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and writes it to the given writer.
private static ldap create or ( filter set filter set ) throws ldap , io { list < jaxb < ? > > list = filter set . get filter group ( ) ; array list < raw filter > filters = new array list < > ( list . size ( ) ) ; for ( jaxb < ? > filter : list ) { filters . add ( create filter ( filter ) ) ; } return ldap . create or ( filters ) ; }	returns a new or search filter with the provided filter components .
private void send blob ( string index , byte [ ] blob ) { send instruction ( new guacamole instruction ( str , index , datatype converter . print base64 binary ( blob ) ) ) ; }	injects a " blob " instruction into the outbound guacamole protocol stream , as if sent by the connected client.
protected void define labels ( ) { labels values = calc labels ( ) ; if ( handle values ) labels = get labels from values ( ) ; else labels = get labels from data ( ) ; n labels = labels . size ( ) ; }	defines what will be the axis labels.
public static set < interval > merge interval to set ( set < interval > intervals , interval interval to merge ) { linked hash set < interval > copy of original set = new linked hash set < > ( intervals ) ; copy of original set . add ( interval to merge ) ; return merge interval set ( copy of original set ) ; }	merge an interval into the given interval set .
public static string drop while ( g self , @ closure params ( value = from string . class , conflict resolution strategy = pick first resolver . class , options = { str , str } ) closure condition ) { return drop while ( self . to string ( ) , condition ) ; }	a gstring variant of the equivalent charsequence method .
public void add node ( topological node node ) { node list . add ( node ) ; }	adds an topological node to this graph .
public void print text ( string text ) { view . print ( text , text . ends with ( str ) ) ; for ( action delegate action delegate : action delegates ) { action delegate . on console output ( this ) ; } }	print text in the console .
@ override public void trim ( ) { if ( counter < x . length ) { int [ ] y = new int [ counter ] ; system . arraycopy ( x , num , y , num , counter ) ; x = y ; resize values ( counter ) ; } }	trims the data row to the number of actually used elements .
private void divide ( int [ ] idx , double [ ] data , array list < int [ ] > ret , int start , int end , int depth ) { if ( depth == num ) { int [ ] a = arrays . copy of range ( idx , start , end ) ; arrays . sort ( a ) ; ret . add ( a ) ; return ; } final int count = end - start ; if ( count == num ) { for ( int j = num << depth ; j > num ; -- j ) { ret . add ( new int [ num ] ) ; } return ; } double m = num ; for ( int i = start ; i < end ; i ++ ) { m += data [ i ] ; } m /= count ; int pos = arrays . binary search ( data , start , end , m ) ; if ( pos >= num ) { final int opt = ( start + end ) > > num ; while ( data [ pos ] == m ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - num ) ; } divide ( idx , data , ret , start , pos , depth - num ) ; divide ( idx , data , ret , pos , end , depth - num ) ; }	recursive call to further subdivide the array .
void assert threads stay alive ( long millis , thread ... threads ) { try { delay ( millis ) ; for ( thread thread : threads ) assert true ( thread . is alive ( ) ) ; } catch ( interrupted exception fail ) { thread fail ( str ) ; } }	checks that the threads do not terminate within the given millisecond delay .
public abstract worker manager ( string id ) { id = id ; status = new worker manager status ( ) ; set execution mode ( execution mode . non serial ) ; setup executor ( ) ; }	set the identifier of the process.
@ on message public void on message ( string message , session session ) { call internal ( str , session , message ) ; }	on message received handler.
public final boolean insert via ( brd via info p via info , pla point int p location , net nos list p net no arr , int p trace clearance class no , int [ ] p trace pen halfwidth arr , int p max recursion depth , int p max via recursion depth , int p pull tight accuracy , int p pull tight time limit ) { shove fail clear ( ) ; changed area clear ( ) ; boolean r ok = shove via algo . shove via insert ( p via info , p location , p net no arr , p trace clearance class no , p trace pen halfwidth arr , p max recursion depth , p max via recursion depth ) ; if ( ! r ok ) return bool ; net nos list opt net no arr = p max recursion depth <= num ? p net no arr : net nos list . empty ; time limit stoppable t limit = new time limit stoppable ( s prevent endless loop ) ; changed area optimize ( opt net no arr , p pull tight accuracy , null , t limit , null ) ; return bool ; }	shoves aside traces , so that a via with the input parameters can be inserted without clearance violations.
boolean threshold exceeded ( final set < i > distinct projection buffer , final int distinct projection buffer threshold , final list < i > incoming bindings buffer , final int incoming bindings buffer threshold ) { return distinct projection buffer . size ( ) >= distinct projection buffer threshold || incoming bindings buffer . size ( ) >= incoming bindings buffer threshold ; }	returns true if , for one of the buffers , the threshold has been exceeded .
public static byte [ ] to byte array ( string str ) { int len = str . length ( ) ; string tokenizer st = new string tokenizer ( str , str ) ; string [ ] new str array = new string [ st . count tokens ( ) ] ; int j = num ; while ( st . has more tokens ( ) ) { new str array [ j ] = st . next token ( ) ; j ++ ; } byte [ ] ret = new byte [ new str array . length ] ; int tmp ; for ( int i = num ; i < new str array . length ; i ++ ) { tmp = integer . parse int ( new str array [ i ] , num ) ; ret [ i ] = ( byte ) ( tmp - num ) ; } return ret ; }	converts a given hex string separated by colons to a byte array .
int max length ( ) { font metrics fm = get font metrics ( get font ( ) ) ; int m = num ; int end = items . size ( ) ; for ( int i = num ; i < end ; i ++ ) { int l = fm . string width ( ( ( string ) items . element at ( i ) ) ) ; m = math . max ( m , l ) ; } return m ; }	return the length of the largest item in the list.
public void write ( final char chars [ ] , final int start , final int length ) throws java . io . io { if ( m writer != null ) m writer . write ( chars , start , length ) ; int lengthx3 = ( length << num ) + length ; if ( lengthx3 >= buf length ) { flush buffer ( ) ; set buffer size ( num * lengthx3 ) ; } if ( lengthx3 > buf length - count ) { flush buffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < num ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < num ) { buf [ count ++ ] = ( byte ) ( num + ( c > > num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( c & num ) ) ; } else { buf [ count ++ ] = ( byte ) ( num + ( c > > num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( ( c > > num ) & num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( c & num ) ) ; } } }	write a portion of an array of characters .
public pla point int round to the left ( pla direction p dir ) { pla point float dir = p dir . to float ( ) ; double rounded x ; if ( dir . v y > num ) { rounded x = math . floor ( v x ) ; } else if ( dir . v y < num ) { rounded x = math . ceil ( v x ) ; } else { rounded x = math . round ( v x ) ; } double rounded y ; if ( dir . v x > num ) { rounded y = math . ceil ( v y ) ; } else if ( dir . v x < num ) { rounded y = math . floor ( v y ) ; } else { rounded y = math . round ( v y ) ; } return new pla point int ( rounded x , rounded y ) ; }	rounds this point , so that if this point is on the left side of any directed line with direction p_dir , the result point will also be on the left side .
protected http host determine proxy ( http host target , http request request , http context context ) throws http exception { proxy selector psel = this . proxy selector ; if ( psel == null ) psel = proxy selector . get default ( ) ; if ( psel == null ) return null ; uri target uri = null ; try { target uri = new uri ( target . to uri ( ) ) ; } catch ( uri usx ) { throw new http exception ( str + target , usx ) ; } list < proxy > proxies = psel . select ( target uri ) ; proxy p = choose proxy ( proxies , target , request , context ) ; http host result = null ; if ( p . type ( ) == proxy . type . http ) { if ( ! ( p . address ( ) instanceof inet socket address ) ) { throw new http exception ( str + p . address ( ) ) ; } final inet socket address isa = ( inet socket address ) p . address ( ) ; result = new http host ( get host ( isa ) , isa . get port ( ) ) ; } return result ; }	determines a proxy for the given target .
private void add reference ( final int source position , final int reference position ) { if ( src and ref positions == null ) { src and ref positions = new int [ num ] ; } if ( reference count >= src and ref positions . length ) { int [ ] a = new int [ src and ref positions . length + num ] ; system . arraycopy ( src and ref positions , num , a , num , src and ref positions . length ) ; src and ref positions = a ; } src and ref positions [ reference count ++ ] = source position ; src and ref positions [ reference count ++ ] = reference position ; }	adds a forward reference to this label.
public object [ ] to array ( ) { return arrays . copy of ( element data , size ) ; }	returns an array containing all of the elements in this list in proper sequence ( from first to last element ).
public boolean is running ( ) { return m thread != null && m thread . is alive ( ) ; }	indicates whether the server is currently running .
public static byte [ ] unwrap vcf ( file source file , file tmp file ) throws file not found exception , io { zip archive input stream in = null ; file output stream fos = null ; string hmac string = null ; try { in = new zip archive input stream ( new file input stream ( source file ) ) ; archive entry entry ; in . get next entry ( ) ; fos = new file output stream ( tmp file ) ; io . copy ( in , fos ) ; entry = in . get next entry ( ) ; hmac string = entry . get name ( ) ; return utils . hex to bytes ( hmac string ) ; } catch ( string index out of bounds exception e ) { logger . error ( str + hmac string + str , e ) ; throw e ; } catch ( exception e ) { logger . error ( str , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }	method extracts the vcf file stored within the zipped import file to the given destination file.
public boolean register user ( string username , string password , string uri ) throws data access exception { if ( check username exists ( username ) ) { return bool ; } store user ( username , password , uri ) ; return bool ; }	attempts to register the username , password combination.
public select ( @ non null string ... columns ) { if ( columns == null ) { throw new null pointer exception ( str ) ; } if ( columns . length == num ) throw new illegal argument exception ( str ) ; string builder builder = new string builder ( str ) ; for ( int i = num ; i < columns . length ; i ++ ) { builder . append ( columns [ i ] ) ; if ( i != ( columns . length - num ) ) builder . append ( str ) ; } sql = builder . to string ( ) ; }	create a < code > select column1 , column2 ,.
public static synchronized m test compliance ( final class < ? > base class , class < ? > mbean interface ) throws m { if ( mbean interface == null ) mbean interface = get standard m ( base class ) ; reflect util . check package access ( mbean interface ) ; m < ? > introspector = m . get instance ( ) ; return get class m ( introspector , base class , mbean interface ) ; }	basic method for testing if a given class is a jmx compliant standard mbean.
public static set < string > to string set ( template sequence model seq model ) throws template model exception { set < string > set = new hash set < string > ( ) ; for ( int i = num ; i < seq model . size ( ) ; i ++ ) { set . add ( get as string non escaping ( ( template scalar model ) seq model . get ( i ) ) ) ; } return set ; }	to string set . < p > warn : bypasses auto - escaping , caller handles . ( e . g . the object wrapper used to rewrap the result ) .
public jks ( input stream ks stream , string ks password ) { try { key store = key store . get instance ( key store . get default type ( ) ) ; password = ( ks password == null ) ? null : ks password . to char array ( ) ; key store . load ( ks stream , password ) ; } catch ( exception e ) { throw new dss ( e ) ; } finally { if ( ks stream != null ) { try { ks stream . close ( ) ; } catch ( io e ) { logger . error ( e . get message ( ) , e ) ; } } } }	creates a signaturetokenconnection with the provided inputstream to java keystore file and password .
protected void write location ( string loc ) throws io { had annotations |= ( loc != null ) ; loc out . write object ( loc ) ; }	overrides marshaloutputstream . writelocation implementation to write annotations to the location stream .
protected int offset ( int vtable offset ) { int vtable = bb pos - bb . get int ( bb pos ) ; return vtable offset < bb . get short ( vtable ) ? bb . get short ( vtable + vtable offset ) : num ; }	look up a field in the vtable .
public static string select text ( x expr , node context ) { try { return ( string ) expr . evaluate ( context , x . string ) ; } catch ( x e ) { throw new xml exception ( e ) ; } }	evaluates the xpath expression as text .
public static http headers to armeria ( io . netty . handler . codec . http . http headers in headers ) { if ( in headers . is empty ( ) ) { return http headers . empty headers ; } final http headers out = new default http headers ( bool , in headers . size ( ) ) ; to armeria ( in headers , out ) ; return out ; }	converts the specified netty http / 1 headers into armeria http / 2 headers .
public static int calculate rms ( short [ ] audio data , int numframes ) { long l sum = num ; int numread = num ; for ( short s : audio data ) { l sum = l sum + s ; numread ++ ; if ( numread == numframes ) break ; } double d avg = l sum / numframes ; double sum mean square = num ; numread = num ; for ( short an audio data : audio data ) { sum mean square = sum mean square + math . pow ( an audio data - d avg , num ) ; numread ++ ; if ( numread == numframes ) break ; } double average mean square = sum mean square / numframes ; return ( int ) ( math . pow ( average mean square , num ) + num ) ; }	calculates the rms audio level from the provided short sample extract.
private void init program ( ) { gl use program ( this . program ) ; vec3 array uniform = gl get uniform location ( this . program , str ) ; chosen uniform = gl get uniform location ( this . program , str ) ; gl use program ( num ) ; }	initialize the shader program .
public boolean engine contains alias ( string alias ) { return entries . contains key ( alias . to lower case ( locale . english ) ) ; }	checks if the given alias exists in this keystore .
public void invert selected relations ( ) { i selection = viewer . get selection ( ) ; if ( ! ( selection instanceof i ) ) { return ; } i structured selection = ( i ) selection ; collection < relation > inverse = compute inverse relations ( get table relations ( ) , structured selection ) ; structured selection next selection = new structured selection ( inverse . to array ( ) ) ; viewer . set selection ( next selection , bool ) ; }	invert the set of relations selected in the table.
public void test float value neg ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; float result = - num ; assert true ( str , a number . float value ( ) == result ) ; }	float value of a negative bigdecimal.
public void bind key store ( final key store service key store service ) { this . key store = key store service ; }	binds the keystore to the truststore service.
protected void draw connector centers ( canvas c ) { list < connection > connections = m block . get all connections ( ) ; paint paint = new paint ( ) ; paint . set style ( paint . style . fill ) ; for ( int i = num ; i < connections . size ( ) ; i ++ ) { connection conn = connections . get ( i ) ; if ( conn . in drag mode ( ) ) { if ( conn . is connected ( ) ) { paint . set color ( color . red ) ; } else { paint . set color ( color . magenta ) ; } } else { if ( conn . is connected ( ) ) { paint . set color ( color . green ) ; } else { paint . set color ( color . cyan ) ; } } m temp workspace point . set ( conn . get position ( ) . x - m block . get position ( ) . x , conn . get position ( ) . y - m block . get position ( ) . y ) ; m helper . workspace to virtual view delta ( m temp workspace point , m temp connection position ) ; if ( m helper . use rtl ( ) ) { m temp connection position . x += m block view size . x ; } c . draw circle ( m temp connection position . x , m temp connection position . y , num , paint ) ; } }	this is a developer testing function subclasses can call to draw dots at the model ' s location of all connections on this block.
private static boolean is merge ( instruction handle handle ) { if ( handle . has targeters ( ) ) { instruction targeter [ ] targeter list = handle . get targeters ( ) ; for ( instruction targeter targeter : targeter list ) { if ( targeter instanceof branch instruction ) { return bool ; } } } return bool ; }	determine whether or not the given instruction is a control flow merge .
private synchronized void load trust manager ( ) { try { trust manager factory tmf = trust manager factory . get instance ( algorithm ) ; tmf . init ( keystore ) ; for ( trust manager trust manager : tmf . get trust managers ( ) ) { if ( trust manager instanceof x509 trust manager ) { default vi pr = ( x509 trust manager ) trust manager ; log . debug ( str ) ; break ; } } log . info ( str , default vi pr . get accepted issuers ( ) . length ) ; } catch ( general security exception e ) { log . error ( e . get message ( ) , e ) ; } }	loads the trust manager using the vipr keystore .
private boolean is outside doc elem ( ) { return ( null == m doc frag ) && m elem stack . size ( ) == num && ( null == m current node || m current node . get node type ( ) == node . document node ) ; }	tell if the current node is outside the document element .
public thread pool ( string name , int pool size ) { this . pool size = pool size ; this . pool name = name ; task list = new linked list < runnable > ( ) ; threads = new worker thread [ pool size ] ; create threads ( ) ; }	constructs a thread pool with given parameters .
private static object invoke or die ( final method method , final object object , final object ... params ) { try { return method . invoke ( object , params ) ; } catch ( illegal access exception e ) { throw new runtime exception ( str + str , e ) ; } catch ( invocation target exception e ) { final throwable cause = e . get cause ( ) ; if ( cause instanceof runtime exception ) { throw ( runtime exception ) cause ; } else if ( cause instanceof error ) { throw ( error ) cause ; } else { throw new runtime exception ( str , cause ) ; } } }	calls invoke and throws a runtimeexception if it fails .
public void clear ( ) { this . normal = null ; this . depth = num ; }	clears the penetration information .
public final void add helper text color ( @ color int final int color ) { if ( ! helper text colors . contains ( color ) ) { helper text colors . add ( color ) ; verify password strength ( ) ; } }	adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .
public void advance to next minute ( ) { }	hook function overridden in instrumentedraptorworker b / efore advancing to the next minute.
list based token stream ( attribute source attribute source , list < attribute source > tokens ) { super ( attribute source . get attribute factory ( ) ) ; this . tokens = tokens ; add attributes ( attribute source ) ; }	creates a new listbasedtokenstream which uses the given tokens as its token source .
@ suppress warnings ( str ) protected class resolve class ( object stream class class desc ) throws io , class not found exception { string cname = class desc . get name ( ) ; return class finder . resolve class ( cname , this . loader ) ; }	use the given classloader rather than using the system class.
public map < string , object > make valid ( map < string , ? extends object > source , string mode ) { return make valid ( source , mode , bool , null ) ; }	creates a new map based from an existing map with just valid parameters.
public static int find ( byte [ ] a , int from index , int to index , byte [ ] key ) { int result = - num ; int sublen = key . length ; int maxpos , first , sp = num ; maxpos = math . min ( to index , a . length ) - sublen ; for ( first = from index ; sp != sublen && first <= maxpos ; first ++ ) { first = find ( a , first , maxpos , key [ num ] ) ; if ( ( first < num ) || ( first > maxpos ) ) { break ; } for ( sp = num ; sp < sublen ; sp ++ ) { if ( a [ first + sp ] != key [ sp ] ) { sp = sublen ; } } } if ( sublen == num ) { result = num ; } else if ( sp == sublen ) { result = ( first - num ) ; } return result ; }	look for a sequence of bytes in a byte array .
private void add synthetic edge ( collection < graph edge > result , graph edge original , graph node head , graph node tail ) { result . add ( new graph edge ( head , tail , original . get relation ( ) ) ) ; }	synthesize a new edge , and add it to the result.
public void add states ( state [ ] s ) { for ( int i = num ; i < s . length ; i ++ ) states . add element ( s [ i ] ) ; }	append states to the state vector .
private synchronized void read object ( java . io . object input stream s ) throws io , class not found exception { s . default read object ( ) ; init ( get mask ( actions ) ) ; }	readobject is called to restore the state of the servicepermission from a stream .
private static byte [ ] windows reg enum key ex1 ( int h key , int sub key index , int max key length ) { byte [ ] result = windows reg enum key ex ( h key , sub key index , max key length ) ; if ( result != null ) { return result ; } else { long sleep time = init sleep time ; for ( int i = num ; i < max attempts ; i ++ ) { try { thread . sleep ( sleep time ) ; } catch ( interrupted exception e ) { return result ; } sleep time *= num ; result = windows reg enum key ex ( h key , sub key index , max key length ) ; if ( result != null ) { return result ; } } } return result ; }	retries regenumkeyex ( ) max_attempts times before giving up .
public tasker add task ( task task ) { tasks . add ( task ) ; last added task = task ; return this ; }	add a new task.
private void init compute program ( ) { gl use program ( compute program ) ; int buffer work group size = buffer utils . create int buffer ( num ) ; gl get programiv ( compute program , gl compute work group size , work group size ) ; work group size x = work group size . get ( num ) ; work group size y = work group size . get ( num ) ; time uniform = gl get uniform location ( compute program , str ) ; blend factor uniform = gl get uniform location ( compute program , str ) ; bounce count uniform = gl get uniform location ( compute program , str ) ; int buffer params = buffer utils . create int buffer ( num ) ; int loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; framebuffer image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world position image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world normal image binding = params . get ( num ) ; gl use program ( num ) ; }	initialize the compute shader .
public void sort ( ) { throw if immutable ( ) ; if ( ! sorted ) { arrays . sort ( values , num , size ) ; sorted = bool ; } }	sorts the elements in the list in - place .
public static object object from byte buffer ( byte [ ] buffer ) throws exception { if ( buffer == null ) return null ; byte array input stream in stream = new byte array input stream ( buffer ) ; object input stream in = new object input stream ext ( in stream ) ; object retval = in . read object ( ) ; in . close ( ) ; return retval ; }	creates an object from a byte buffer .
public string generate group name ( string policy name , set < string > existing group names , string parent group name ) { int count = num ; string format = null ; while ( count <= existing group names . size ( ) ) { if ( num == count ) { format = string . format ( str , policy name ) ; } else { format = string . format ( str , policy name , count ) ; } string generated group name = generate ( parent group name , format , smis constants . mask name delimiter , smis constants . max storage group name length ) ; if ( ! existing group names . contains ( generated group name ) ) { return generated group name ; } count ++ ; } return generate ( parent group name , string . format ( str , policy name ) , smis constants . mask name delimiter , smis constants . max storage group name length ) ; }	todo : vmax3 customized names generate group names which doesn ' t exist in array already .
public static void assert column types ( result set rs , int [ ] expected types ) throws sql { result set meta data rsmd = rs . get meta data ( ) ; int actual cols = rsmd . get column count ( ) ; assert equals ( str , expected types . length , rsmd . get column count ( ) ) ; for ( int i = num ; i < actual cols ; i ++ ) { assert equals ( str + ( i + num ) , expected types [ i ] , rsmd . get column type ( i + num ) ) ; } }	test method from apache derby project class org.
public default action group ( @ not null an action ... actions ) { this ( arrays . as list ( actions ) ) ; }	creates an action group containing the specified actions .
public int add ( t dl , int row ) { list . add ( row , dl ) ; fire table rows inserted ( row , row ) ; return row ; }	adds a dataline to the list at a row.
private void push term ( bytes ref text ) throws io { int limit = math . min ( last term . length ( ) , text . length ) ; int pos = num ; while ( pos < limit && last term . byte at ( pos ) == text . bytes [ text . offset + pos ] ) { pos ++ ; } for ( int i = last term . length ( ) - num ; i >= pos ; i -- ) { int prefix top size = pending . size ( ) - prefix starts [ i ] ; if ( prefix top size >= min items in block ) { write blocks ( i + num , prefix top size ) ; prefix starts [ i ] -= prefix top size - num ; } } if ( prefix starts . length < text . length ) { prefix starts = array util . grow ( prefix starts , text . length ) ; } for ( int i = pos ; i < text . length ; i ++ ) { prefix starts [ i ] = pending . size ( ) ; } last term . copy bytes ( text ) ; }	pushes the new term to the top of the stack , and writes new blocks .
public numeric literal ( object x ) { if ( x instanceof number ) { m number = ( number ) x ; m type = type lib . get primitive type ( m number . get class ( ) ) ; } else { throw new illegal argument exception ( str ) ; } }	create a new numericliteral .
private final boolean compare and set head ( node update ) { return unsafe . compare and swap object ( this , head offset , null , update ) ; }	cas head field . used only by enq .
protected set < dependency kind > remove dependency ( node n ) { set < dependency kind > removed kinds = new hash set < > ( ) ; for ( dependency kind dk : dependency kind . values ( ) ) { set < node > deps by kind = deps . get ( dk ) ; if ( deps by kind == null ) continue ; if ( deps by kind . remove ( n ) ) { removed kinds . add ( dk ) ; } } return removed kinds ; }	remove a dependency , regardless of its kind .
public static < k , v > concurrent map < k , v > new concurrent map with aggressive concurrency ( ) { return new concurrent hash map < > ( num , num , aggressive concurrency level ) ; }	creates a new chm with an aggressive concurrency level , aimed at high concurrent update rate long living maps .
@ override public boolean connection allowed ( string event name ) { if ( m listenee != null || ! event name . equals ( str ) ) { return bool ; } return bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
protected char skip all whitespace ( reader r ) throws io { char c ; do { c = ( char ) r . read ( ) ; } while ( character . is whitespace ( c ) && c != ( char ) - num ) ; return c ; }	skips all consecutive whitespace characters from reader.
public iterator enumerate literal result attributes ( ) { return ( null == m avts ) ? null : m avts . iterator ( ) ; }	compiling templates requires that we be able to list the avts added 9 / 5 / 2000 to support compilation experiment.
public map < string , string > parse ( final string str , char separator ) { if ( str == null ) { return new hash map < > ( ) ; } return parse ( str . to char array ( ) , separator ) ; }	extracts a map of name / value pairs from the given string.
public priority queue ( collection < ? extends e > c ) { if ( c instanceof priority queue ) { get from priority queue ( ( priority queue < ? extends e > ) c ) ; } else if ( c instanceof sorted set ) { get from sorted set ( ( sorted set < ? extends e > ) c ) ; } else { init size ( c ) ; add all ( c ) ; } }	constructs a priority queue that contains the elements of a collection.
private string resource id ( ) { return sub schema path . is empty ( ) ? null : last schema node name ( ) ; }	gets the resource id.
@ override public boolean is initial ( ) { return init ; }	returns a boolean flag indicating if the state is initial ( just starting ).
public static string denormalize ( final char sequence self ) { if ( line separator == null ) { final string writer sw = new string writer ( num ) ; try { final buffered writer bw = new buffered writer ( sw ) ; bw . new line ( ) ; bw . flush ( ) ; line separator = sw . to string ( ) ; } catch ( io ioe ) { line separator = str ; } } final int len = self . length ( ) ; if ( len < num ) { return self . to string ( ) ; } final string builder sb = new string builder ( ( num * len ) / num ) ; int i = num ; char sequence cs = ( self instanceof g ) ? self . to string ( ) : self ; while ( i < len ) { final char ch = cs . char at ( i ++ ) ; switch ( ch ) { case str : sb . append ( line separator ) ; if ( ( i < len ) && ( cs . char at ( i ) == str ) ) { ++ i ; } break ; case str : sb . append ( line separator ) ; break ; default : sb . append ( ch ) ; break ; } } return sb . to string ( ) ; }	return a charsequence with lines ( separated by lf , cr / lf , or cr ) terminated by the platform specific line separator .
public static void perform save as ( string schema prefix file name , string sel file path , container config container config ) { try { file file with default configuration = create container schema file ( schema prefix file name , sel file path ) ; update file ( container config , file with default configuration . get path ( ) , schema prefix file name ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	save content of containerconfig instance into xml file ( schema or configuration ) .
public boolean is aborted ( ) { return is aborted . get ( ) ; }	returns whether the printng was aborted using this printingstatus.
public void append ( int key , e value ) { if ( m size != num && key <= m keys [ m size - num ] ) { put ( key , value ) ; return ; } if ( m garbage && m size >= m keys . length ) { gc ( ) ; } int pos = m size ; if ( pos >= m keys . length ) { int n = ideal int array size ( pos + num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } m keys [ pos ] = key ; m values [ pos ] = value ; m size = pos + num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public void test skip ( ) throws io { byte [ ] data = new byte [ num * num ] ; byte [ ] gzipped = gzip . gzip ( data ) ; gzip in = new gzip ( new byte array input stream ( gzipped ) ) ; long total skipped = num ; long count ; do { count = in . skip ( long . max value ) ; total skipped += count ; } while ( count > num ) ; assert equals ( data . length , total skipped ) ; in . close ( ) ; }	http : / / b / 3042574 gzipinputstream . skip ( ) causing crc failures.
private support test web data ( string path , string type ) { file file = new file ( path ) ; test length = file . length ( ) ; test last modified = file . last modified ( ) ; test name = file . get name ( ) ; test type = type ; test dir = file . is directory ( ) ; byte array output stream out = new byte array output stream ( ) ; file input stream in = null ; try { in = new file input stream ( file ) ; while ( in . available ( ) > num ) { out . write ( in . read ( ) ) ; } in . close ( ) ; out . flush ( ) ; test0 data = out . to byte array ( ) ; out . close ( ) ; test0 data available = bool ; return ; } catch ( exception e ) { e . print stack trace ( ) ; } finally { try { if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } catch ( io e ) { } } }	creates a data package with information used by the server when responding to requests.
public static void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }	prints a boolean to standard output and flushes standard output .
public ipc shared memory space ( string tok file name , int writer pid , int reader pid , int size , boolean reader , ignite logger parent ) throws ignite checked exception { assert size > num : str ; log = parent . get logger ( ipc shared memory space . class ) ; op size = size ; shmem ptr = ipc shared memory utils . allocate system resources ( tok file name , size , debug && log . is debug enabled ( ) ) ; shmem id = ipc shared memory utils . shared memory id ( shmem ptr ) ; sem id = ipc shared memory utils . semaphore id ( shmem ptr ) ; is reader = reader ; this . tok file name = tok file name ; this . reader pid = reader pid ; this . writer pid = writer pid ; if ( debug && log . is debug enabled ( ) ) log . debug ( str + this ) ; }	this will allocate system resources for the space .
@ override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch ( sql e ) { e . print stack trace ( ) ; } }	close the jdbc connection.
public version add qualifier ( string qualifier ) { list < string > new qualifiers = new array list < > ( this . qualifiers ) ; new qualifiers . add ( qualifier ) ; return new version ( major , minor , patch , new qualifiers . to array ( new string [ new qualifiers . size ( ) ] ) ) ; }	creates a new version object from the current one , but append a new qualifier to it .
public int load signed16 ( int addr ) { return load signed16 ( addr , access source . code ) ; }	perform a 16bit load where the sign extended result fills the return value.
public static string array to hex string ( byte [ ] array ) { return array to hex string ( array , num , array . length ) ; }	helper method to convert a byte [ ] array ( such as a msgid ) to a hex string.
public static void unregister baggage handler ( baggage handler handler ) { handlers . remove ( handler ) ; }	remove an existing baggage handler that was previously registered.
public default heat map dataset ( int x samples , int y samples , double min x , double max x , double min y , double max y ) { if ( x samples < num ) { throw new illegal argument exception ( str ) ; } if ( y samples < num ) { throw new illegal argument exception ( str ) ; } if ( double . is infinite ( min x ) || double . is na n ( min x ) ) { throw new illegal argument exception ( str ) ; } if ( double . is infinite ( max x ) || double . is na n ( max x ) ) { throw new illegal argument exception ( str ) ; } if ( double . is infinite ( min y ) || double . is na n ( min y ) ) { throw new illegal argument exception ( str ) ; } if ( double . is infinite ( max y ) || double . is na n ( max y ) ) { throw new illegal argument exception ( str ) ; } this . x samples = x samples ; this . y samples = y samples ; this . min x = min x ; this . max x = max x ; this . min y = min y ; this . max y = max y ; this . z values = new double [ x samples ] [ ] ; for ( int x = num ; x < x samples ; x ++ ) { this . z values [ x ] = new double [ y samples ] ; } }	creates a new dataset where all the z - values are initially 0.
public static void assert equals any order ( event bean [ ] [ ] expected , event bean [ ] [ ] actual ) { if ( compare array size ( expected , actual ) ) { return ; } int num matches = num ; boolean [ ] found received = new boolean [ actual . length ] ; for ( event bean [ ] expected object : expected ) { boolean found = bool ; for ( int i = num ; i < actual . length ; i ++ ) { if ( found received [ i ] ) { continue ; } boolean match = compare equals exact order ( actual [ i ] , expected object ) ; if ( match ) { found = bool ; num matches ++ ; found received [ i ] = bool ; break ; } } if ( ! found ) { log . error ( str + arrays . to string ( expected object ) ) ; log . error ( str + arrays . to string ( actual ) ) ; } scope test helper . assert true ( found ) ; } scope test helper . assert equals ( num matches , expected . length ) ; }	compare two 2 - dimensional event arrays .
private void collect text ( ) { if ( text node count > num ) { first text node . set text ( text buffer . to string ( ) ) ; } text node count = num ; }	this method breaks concatenation mode . as a side effect it copies the concatenated string to the first text node.
@ suppress warnings ( { str , str } ) public static < t extends annotation > t unproxy ( t annotation ) { function unproxy function = get unproxy function ( annotation . annotation type ( ) ) ; return ( t ) unproxy function . apply ( annotation ) ; }	convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .
public static list < node > parse expression ( context context , hash set < string > config namespaces , string text ) { return parse expression ( context , config namespaces , text , num , bool ) ; }	this method should be used to parse an expression , like " a = b ".
public void add tick mark section ( final section section ) { if ( null == section ) return ; tick mark sections . add ( section ) ; collections . sort ( tick mark sections , new section comparator ( ) ) ; fire update event ( redraw event ) ; }	adds the given section to the list of tickmark sections .
protected static double calc q i ( double f , double lambda ) { return lambda * math . exp ( - lambda * f ) ; }	compute q_i ( exponential distribution , inliers ).
void flush ( ) { print stream . flush ( ) ; }	flush any io to disk.
public char buffer delete ( int start , int end ) { int length = length ( ) ; if ( start < num || end < start || length < start ) throw new string index out of bounds exception ( ) ; end = math . min ( length , end ) ; int tail = length - end ; char [ ] buffer = buffer ( ) ; for ( int i = num ; i < tail ; i ++ ) { buffer [ start + i ] = buffer [ end + i ] ; } length ( length - ( end - start ) ) ; return this ; }	deletes characters from the buffer .
public void add plotter ( final plotter plotter ) { plotters . add ( plotter ) ; }	add a plotter to the graph , which will be used to plot entries.
node < k , v > find near ( k kkey , int rel ) { comparable < ? super k > key = comparable ( kkey ) ; for ( ; ; ) { node < k , v > b = find predecessor ( key ) ; node < k , v > n = b . next ; for ( ; ; ) { if ( n == null ) return ( ( rel & lt ) == num || b . is base header ( ) ) ? null : b ; node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . help delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare to ( n . key ) ; if ( ( c == num && ( rel & eq ) != num ) || ( c < num && ( rel & lt ) == num ) ) return n ; if ( c <= num && ( rel & lt ) != num ) return b . is base header ( ) ? null : b ; b = n ; n = f ; } } }	utility for ceiling , floor , lower , higher methods .
public void add listener ( speedruns live listener listener ) { listeners . add ( listener ) ; }	adds a listener that receives the data and error messages .
public boolean find ( int start ) { if ( start < num || start > input . length ( ) ) { throw new index out of bounds exception ( str + start + str + input . length ( ) ) ; } synchronized ( this ) { match found = find impl ( address , input , start , match offsets ) ; } return match found ; }	returns true if there is another match in the input , starting from the given position.
public int action ( string fault , string action ) { integer current = get ( fault ) ; if ( current == null ) throw new illegal argument exception ( fault ) ; boolean no = action . starts with ( str ) ; if ( no ) action = action . substring ( num ) ; integer bit = get action ( action ) ; if ( bit == null ) throw new illegal argument exception ( action ) ; int old = current . int value ( ) ; int mask = bit . int value ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new integer ( n ) ) ; return n ; }	sets the action bits as appropriate for the given fault and action.
public static boolean contains whitespace ( char sequence str ) { if ( ! has length ( str ) ) { return bool ; } int str len = str . length ( ) ; for ( int i = num ; i < str len ; i ++ ) { if ( character . is whitespace ( str . char at ( i ) ) ) { return bool ; } } return bool ; }	check whether the given charsequence contains any whitespace characters .
public static < t > t decode from base64 ( coder < t > coder , string encoded value ) throws coder exception { return decode from safe stream ( coder , new byte array input stream ( base64 . decode base64 ( encoded value ) ) , coder . context . outer ) ; }	parses a value from a base64 - encoded string using the given coder .
public void validate ( set set data ) throws validation exception { for ( iterator iter = set data . iterator ( ) ; iter . has next ( ) ; ) { perform validation ( ( string ) iter . next ( ) ) ; } }	performs validation on a set of string .
public string add ( object ... values ) { double result = num ; for ( int i = num ; i < values . length ; i ++ ) { result += function handler . get double ( values [ i ] ) ; } return double . to string ( result ) ; }	adds all values together.
public list < string > list my d ( string owner , boolean restricted ) { connection conn = null ; try { conn = get connection ( ) ; return list my d ( conn , owner , restricted ) ; } catch ( exception ex ) { logger . log ( level . severe , str , ex ) ; } finally { db . close ( conn ) ; } return null ; }	list database groups the specific user has provided passwords.
protected void do function ( float [ ] inputs , int input offset , float [ ] outputs , int output offset ) { float input = inputs [ input offset ] ; for ( int i = num ; i < get num outputs ( ) ; i ++ ) { outputs [ i + output offset ] = get c0 ( i ) + ( float ) ( math . pow ( input , get n ( ) ) * ( get c1 ( i ) - get c0 ( i ) ) ) ; } }	calculate the function value for the input . for each output ( j ) , the function value is : c0 ( j ) + x ^ n * ( c1 ( j ) - c0 ( j ) ).
public void put ( string key , long value ) { if ( key != null ) { url params . put ( key , string . value of ( value ) ) ; } }	adds a long value to the request .
public int compare ( object o1 , object o2 ) { return comparator . compare ( o1 , o2 ) ; }	call the comparator on the column.
public void add check box action listener ( action listener al ) { m enable distributed experiment . add action listener ( al ) ; }	enable objects to listen for changes to the check box.
private rect calc bounds ( int index , paint paint ) { rect bounds = new rect ( ) ; char sequence title = get title ( index ) ; bounds . right = ( int ) paint . measure text ( title , num , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }	calculate the bounds for a view ' s title.
g add or subtract ( g other ) { if ( ! field . equals ( other . field ) ) { throw new illegal argument exception ( str ) ; } if ( is zero ( ) ) { return other ; } if ( other . is zero ( ) ) { return this ; } int [ ] smaller coefficients = this . coefficients ; int [ ] larger coefficients = other . coefficients ; if ( smaller coefficients . length > larger coefficients . length ) { int [ ] temp = smaller coefficients ; smaller coefficients = larger coefficients ; larger coefficients = temp ; } int [ ] sum diff = new int [ larger coefficients . length ] ; int length diff = larger coefficients . length - smaller coefficients . length ; system . arraycopy ( larger coefficients , num , sum diff , num , length diff ) ; for ( int i = length diff ; i < larger coefficients . length ; i ++ ) { sum diff [ i ] = g . add or subtract ( smaller coefficients [ i - length diff ] , larger coefficients [ i ] ) ; } return new g ( field , sum diff ) ; }	gf addition or subtraction ( they are identical for a gf ( 2 ^ n ).
@ override public string to string ( ) { string buffer sb = new string buffer ( ) ; sb . append ( type ) ; sb . append ( str ) ; sb . append ( sub type ) ; for ( string name : attributes . key set ( ) ) { if ( inferred charset && attr charset . equals ( name ) ) { continue ; } sb . append ( str ) ; sb . append ( name ) ; sb . append ( str ) ; string value = attributes . get ( name ) ; matcher token matcher = token pattern . matcher ( value ) ; if ( token matcher . matches ( ) ) { sb . append ( value ) ; } else { sb . append ( str + value + str ) ; } } return sb . to string ( ) ; }	generates the content - type value.
public static long first field offset ( class clazz ) { long min size = round up to8 ( header size ( clazz ) ) ; while ( clazz != object . class ) { for ( field f : clazz . get declared fields ( ) ) { if ( ( f . get modifiers ( ) & modifier . static ) == num ) { long offset = unsafe . object field offset ( f ) ; if ( offset < min size ) { min size = offset ; } } } clazz = clazz . get superclass ( ) ; } return min size ; }	returns the offset of the first field in the range [ headersize , sizeof ] .
public static void w ( string tag , string msg , object ... args ) { if ( s level > level warning ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . w ( tag , msg ) ; }	send a warning log message.
public final v extract first ( ) { if ( size ( ) > num ) { if ( gwt . is script ( ) ) { v ret = js array . get ( num ) ; js array . remove ( num ) ; return ret ; } else { return java array . remove ( num ) ; } } return null ; }	retrieve the first element and remove it from the list.
@ override public void action performed ( action event event ) { string command = event . get action command ( ) ; if ( command . equals ( str ) ) { attempt label font selection ( ) ; } else if ( command . equals ( str ) ) { attempt modify label paint ( ) ; } else if ( command . equals ( str ) ) { attempt tick label font selection ( ) ; } }	handles user interaction with the property panel .
@ android only ( str ) public void test unwrap 04 ( ) { string host = str ; int port = num ; byte buffer bbs = byte buffer . allocate ( num ) ; byte buffer [ ] bbd = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; ssl sse = get engine ( host , port ) ; try { sse . unwrap ( bbs , bbd ) ; fail ( str ) ; } catch ( illegal state exception iobe ) { } catch ( exception e ) { fail ( e + str ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts ) illegalstateexception should be thrown .
public static void upgrade server instance ( sso sso token , string instance name , string instance id , map < string , string > upgraded values ) throws sms , sso , configuration exception , io { service config sc = get server config ( sso token , instance name ) ; if ( sc != null ) { map map = sc . get attributes ( ) ; map . remove ( attr parent site id ) ; set new set = get properties set ( upgraded values ) ; map . put ( attr server config , new set ) ; sc . set attributes ( map ) ; } else { throw new configuration exception ( str + str ) ; } }	upgrades a server instance .
public static < t > t instance ( class < t > clazz ) { try { return clazz . new instance ( ) ; } catch ( instantiation exception | illegal access exception e ) { throw new illegal state exception ( e ) ; } }	creates a new instance of the class represented by the given class object.
private void pop ( final string desc ) { char c = desc . char at ( num ) ; if ( c == str ) { pop ( ( type . get arguments and return sizes ( desc ) > > num ) - num ) ; } else if ( c == str || c == str ) { pop ( num ) ; } else { pop ( num ) ; } }	pops a type from the output frame stack .
public generic sip msrp session create msrp session ( contact id contact , string feature tag , string [ ] accept types , string [ ] accept wrapped types ) { if ( s logger . is activated ( ) ) { s logger . info ( str + contact ) ; } return new originating sip msrp session ( this , contact , feature tag , m rcs settings , system . current time millis ( ) , m contact manager , accept types , accept wrapped types ) ; }	initiate a msrp session.
public forum post config create ( forum post config config ) { config . add credentials ( this ) ; string xml = post ( this . url + str , config . to xml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { forum post config post = new forum post config ( ) ; post . parse xml ( root ) ; return post ; } catch ( exception exception ) { this . exception = sdk . parse failure ( exception ) ; throw this . exception ; } }	create a new forum post.
protected void draw mark ( d g2 , float x , float y , color color ) { d bounds = mark . get bounds2 d ( ) ; float w = ( float ) bounds . get width ( ) ; float h = ( float ) bounds . get height ( ) ; x = x - ( w / num ) ; y = y - ( h / num ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( mark fill paint != null ) { g2 . set paint ( mark fill paint ) ; g2 . fill ( mark ) ; } } else { g2 . set paint ( color ) ; g2 . fill ( mark ) ; } g2 . set paint ( mark paint ) ; g2 . set stroke ( mark stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; d rect = new d . float ( x , y , w , h ) ; mark bounds . add ( rect ) ; }	draw a mark transforming co - ordinates to each axis.
public void component resized ( component event e ) { if ( logger . is loggable ( level . fine ) ) { logger . fine ( str + get width ( ) + str + get height ( ) ) ; } projection . set width ( get width ( ) ) ; projection . set height ( get height ( ) ) ; fire projection changed ( ) ; }	componentlistener interface method . should not be called directly . invoked when component has been resized , and kicks off a projection change .
public static string byte array to hex string ( byte [ ] block , int offset , int length ) { string buffer buf = new string buffer ( ) ; int len = block . length ; length = length + offset ; if ( ( len < length ) ) { length = len ; } for ( int i = num + offset ; i < length ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < length - num ) { buf . append ( str ) ; } } return buf . to string ( ) ; }	description of the method.
private void change value ( abstract storage label < object > label , object new value ) { if ( ! objects . equals ( label . get value ( ) , new value ) ) { synchronized ( label edit listeners ) { for ( label edit listener listener : label edit listeners ) { listener . pre label value change ( label ) ; } } label . set value ( new value ) ; synchronized ( label edit listeners ) { for ( label edit listener listener : label edit listeners ) { listener . post label value change ( label ) ; } } } }	reforms the value change and informs the listeners .
public void write ( byte [ ] b , int offset , int length ) throws io { if ( entry . get method ( ) == deflated ) { if ( length > num ) { if ( ! def . finished ( ) ) { def . set input ( b , offset , length ) ; while ( ! def . needs input ( ) ) { deflate ( ) ; } } } } else { write out ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; }	writes bytes to zip entry .
public void update point ( float x , float y ) { if ( math . sqrt ( x * x + y * y ) > num ) if ( listener != null ) { listener . on angle changed listener ( get angle ( x , - y ) ) ; } }	update the gravity point only if a the gravity vector is longer than the threshold.
public final void quietly join ( ) { do join ( ) ; }	joins this task , without returning its result or throwing its exception.
@ override public int clamp view position horizontal ( view child , int left , int dx ) { if ( m dragged view == null ) { return num ; } final int left bound = num - max overflow - ( m column size side / num ) ; final int right bound = get width ( ) + max overflow + ( m column size side / num ) ; return math . min ( math . max ( left , left bound ) , right bound ) ; }	override method used to configure the horizontal drag.
http request wrapper ( http servlet request request ) { super ( request ) ; }	constructs a request object wrapping the given request .
private int convert to panel x ( double xval ) { double temp = ( xval - m min x ) / m range x ; temp = temp * m panel width ; return ( int ) temp ; }	convert an x coordinate from the instance space to the panel space .
public void forward ( http server request request ) { forward ( request , null ) ; }	handles the request and forwards it to the hook specific destination .
private set < string > primary keys ( prepared statement stmt , string owner , string tbl ) throws sql { set < string > pk cols = new hash set < > ( ) ; stmt . set string ( num , owner ) ; stmt . set string ( num , tbl ) ; try ( result set pk rs = stmt . execute query ( ) ) { while ( pk rs . next ( ) ) pk cols . add ( pk rs . get string ( num ) ) ; } return pk cols ; }	retrieve primary key columns .
public static long read uin ( input stream stream ) throws io { long result = num ; for ( int i = num ; i <= num ; i += num ) { result |= ( long ) stream . read ( ) << i ; } return result ; }	reads 4 bytes from stream and interprets them as uint32 . < br >.
private token to prefix token ( i leaf ) { lexer lexer = new js ( ) ; string text = leaf . get text ( ) ; string prefix = text . substring ( num , end offset - leaf . get total offset ( ) ) ; antlr stream = new antlr ( prefix ) ; lexer . set char stream ( stream ) ; token next token = lexer . next token ( ) ; return new common token ( next token . get type ( ) , next token . get text ( ) ) ; }	produce an antlr token for the prefix of the given leaf that overlaps the requested region.
protected void add ( csv record ) { records . add ( objects . require non null ( record ) ) ; }	adds the given record to this data .
private void scheduled enqueue send ( ) { scheduler queue size . decrement and get ( ) ; scheduled . set ( bool ) ; enqueue send with error logging ( ) ; }	decrements the scheduled queue counter and enqueues the request .
private e await match ( node s , node pred , e e , boolean timed , long nanos ) { final long deadline = timed ? system . nano time ( ) + nanos : num ; thread w = thread . current thread ( ) ; int spins = - num ; thread local random random yields = null ; for ( ; ; ) { object item = s . item ; if ( item != e ) { s . forget contents ( ) ; return linked transfer queue . < e > cast ( item ) ; } if ( ( w . is interrupted ( ) || ( timed && nanos <= num ) ) && s . cas item ( e , s ) ) { unsplice ( pred , s ) ; return e ; } if ( spins < num ) { if ( ( spins = spins for ( pred , s . is data ) ) > num ) random yields = thread local random . current ( ) ; } else if ( spins > num ) { -- spins ; if ( random yields . next int ( chained spins ) == num ) thread . yield ( ) ; } else if ( s . waiter == null ) { s . waiter = w ; } else if ( timed ) { nanos = deadline - system . nano time ( ) ; if ( nanos > num ) lock support . park nanos ( this , nanos ) ; } else { lock support . park ( this ) ; } } }	spins / yields / blocks until node s is matched or caller gives up .
public static string join ( char [ ] self , string separator ) { string builder buffer = new string builder ( ) ; boolean first = bool ; if ( separator == null ) separator = str ; for ( char next : self ) { if ( first ) { first = bool ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to string ( ) ; }	concatenates the string representation of each items in this array , with the given string as a separator between each item .
private < t > binding amp < t > find object binding ( key < t > key ) { objects . require non null ( key ) ; if ( key . qualifiers ( ) . length != num ) { throw new illegal argument exception ( ) ; } return ( binding amp ) find binding ( key . of ( object . class , key . qualifiers ( ) [ num ] ) ) ; }	returns an object producer .
private void init compute program ( ) { gl use program ( compute program ) ; int buffer work group size = buffer utils . create int buffer ( num ) ; gl get programiv ( compute program , gl compute work group size , work group size ) ; work group size x = work group size . get ( num ) ; work group size y = work group size . get ( num ) ; time uniform = gl get uniform location ( compute program , str ) ; blend factor uniform = gl get uniform location ( compute program , str ) ; light radius uniform = gl get uniform location ( compute program , str ) ; int buffer props = buffer utils . create int buffer ( num ) ; int buffer params = buffer utils . create int buffer ( num ) ; props . put ( num , gl buffer binding ) ; int objects resource index = gl get program resource index ( compute program , gl shader storage block , str ) ; gl get program resourceiv ( compute program , gl shader storage block , objects resource index , props , null , params ) ; objects ssbo binding = params . get ( num ) ; int triangles resource index = gl get program resource index ( compute program , gl shader storage block , str ) ; gl get program resourceiv ( compute program , gl shader storage block , triangles resource index , props , null , params ) ; triangles ssbo binding = params . get ( num ) ; int loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; framebuffer image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world position image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world normal image binding = params . get ( num ) ; gl use program ( num ) ; }	initialize the compute shader .
public boolean if task completed success or failure from response ( response on singe request my response ) { boolean is completed = bool ; try { if ( my response == null || my response . is fail obtain response ( ) ) { return is completed ; } string response body = my response . get response body ( ) ; if ( response body . matches ( success regex ) || response body . matches ( failure regex ) ) { is completed = bool ; } } catch ( exception t ) { logger . error ( str + t ) ; } return is completed ; }	if task completed success or failure from response .
public void center horizontal ( array list < integer > nodes ) { if ( m b needs undo action ) { add undo action ( new center horizontal action ( nodes ) ) ; } int n min y = - num ; int n max y = - num ; for ( int i node = num ; i node < nodes . size ( ) ; i node ++ ) { int n y = get position y ( nodes . get ( i node ) ) ; if ( n y < n min y || i node == num ) { n min y = n y ; } if ( n y > n max y || i node == num ) { n max y = n y ; } } for ( int i node = num ; i node < nodes . size ( ) ; i node ++ ) { int n node = nodes . get ( i node ) ; m n position y . set ( n node , ( n min y + n max y ) / num ) ; } }	center set of nodes half way between left and right most node in the list.
protected void append text ( final string text ) { if ( text != null ) { text body . append ( text ) ; } }	append text to the outgoing email body .
public void on restore instance state ( bundle saved instance state ) { m selected positions . add all ( saved instance state . get integer array list ( tag ) ) ; log . d ( tag , str + m selected positions ) ; }	restores the previous state of the selection on the items .
public hour ( int hour , day day ) { param checks . null not permitted ( day , str ) ; this . hour = ( byte ) hour ; this . day = day ; peg ( calendar . get instance ( ) ) ; }	constructs a new hour .
public void undo ( ) { if ( -- m temp undo index < num ) { m temp undo index = m temp undo files . length - num ; } if ( m temp undo files [ m temp undo index ] != null ) { abstract file loader loader = converter utils . get loader for file ( m temp undo files [ m temp undo index ] ) ; try { loader . set file ( m temp undo files [ m temp undo index ] ) ; set instances from file ( loader ) ; } catch ( exception e ) { e . print stack trace ( ) ; m . log message ( e . to string ( ) ) ; j . show message dialog ( preprocess panel . this , str + e . to string ( ) , str , j . error message ) ; } m temp undo files [ m temp undo index ] = null ; } int temp = m temp undo index - num ; if ( temp < num ) { temp = m temp undo files . length - num ; } m . set enabled ( m temp undo files [ temp ] != null ) ; }	reverts to the last backed up version of the dataset .
public static boolean is connected using wifi ( ) { context context = fe app . get app context ( ) ; connectivity manager cm = ( connectivity manager ) context . get system service ( context . connectivity service ) ; network info ni = cm . get active network info ( ) ; return ni != null && ni . is connected ( ) == bool && ni . get type ( ) == connectivity manager . type wifi ; }	checks to see if we are connected using wifi.
public void close ( ) throws io { if ( writer != null ) writer . flush buffer ( ) ; }	done with this responsewriter.
public boolean is empty ( ) { return ext ordering . is empty ( ) ; }	return true if there are no extension present in this generator .
public process ( final file file , final progress listener progress listener ) throws io , xml { this . process location = new file process location ( file ) ; init context ( ) ; reader in = null ; try { in = new input stream reader ( new file input stream ( file ) , str ) ; read process ( in , progress listener ) ; } catch ( io e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }	creates a new process from the given process file.
public static string extract music id id ( @ non null string media id ) { int pos = media id . index of ( leaf separator ) ; if ( pos >= num ) { return media id . substring ( pos + num ) ; } return null ; }	extracts unique musicid from the mediaid.
public void test get scope ( ) throws exception { identity i = new identity stub ( str ) ; assert null ( i . get scope ( ) ) ; identity scope s = identity scope . get system scope ( ) ; identity i2 = new identity stub ( str , s ) ; assert same ( s , i2 . get scope ( ) ) ; }	verify identity . getscope ( ) returns identity ' s scope.
public object [ ] build parameters ( object [ ] first parameters , method method , class < ? extends annotation > annotation type ) { int parameters length = method . get parameter types ( ) . length ; if ( first parameters . length > num && parameters length < num ) { throw new repository method exception ( string . format ( str , annotation type ) ) ; } int parameters to resolve = parameters length - first parameters . length ; object [ ] additional parameters = new object [ parameters to resolve ] ; for ( int i = first parameters . length ; i < parameters length ; i ++ ) { additional parameters [ i - first parameters . length ] = parameter provider . provide ( method , i ) ; } return concatenate ( first parameters , additional parameters ) ; }	build a list of parameters that can be provided to a method .
@ override public boolean contains ( s2 cell cell ) { return contains ( cell . id ( ) ) ; }	this is a fast operation ( logarithmic in the size of the cell union ) .
public simplex noise generator ( random rand ) { super ( rand ) ; offset w = rand . next double ( ) * num ; }	creates a seeded simplex noise generator with the given random.
public static long [ ] values ( long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = num ; i < array . length ; i ++ ) { long v = array [ i ] ; if ( v != null ) { dest [ i ] = v . long value ( ) ; } } return dest ; }	converts to primitive array .
@ override public void process new lines ( string [ ] lines ) { for ( string line : lines ) { if ( line . starts with ( str ) ) { continue ; } if ( line . contains ( str ) ) { my is file missing = bool ; return ; } string [ ] values = line . split ( line split regex ) ; if ( values . length < index of tx bytes ) { continue ; } try { int line uid = integer . parse int ( values [ index of uid ] ) ; if ( my uid == line uid ) { int temp rx bytes = integer . parse int ( values [ index of rx bytes ] ) ; int temp tx bytes = integer . parse int ( values [ index of tx bytes ] ) ; if ( temp rx bytes < num || temp tx bytes < num ) { log . warning ( string . format ( str , temp rx bytes , temp tx bytes , line ) ) ; continue ; } my rx bytes += temp rx bytes ; my tx bytes += temp tx bytes ; } } catch ( number format exception e ) { log . warning ( string . format ( str , values [ index of uid ] , values [ index of rx bytes ] , values [ index of tx bytes ] , line ) ) ; } } }	processes the stats line to sum up all network stats belonging to the uid .
protected void init lookup ( ) { m lookup = new hash map ( ) ; for ( int i = num ; i < m names . length ; ++ i ) { m lookup . put ( m names [ i ] , new integer ( i ) ) ; } }	lazily construct the lookup table for this schema.
public string to string ( ) { string str = str ; string followed by = str ; int last type = - num ; string last string = str ; int singles count = num ; for ( enumeration e = format constraints . elements ( ) ; e . has more elements ( ) ; ) { format constraint constraint = ( format constraint ) e . next element ( ) ; if ( constraint . count == format constraint . count exactly one ) { if ( last type != - num ) { if ( last type != constraint . type ) { str += followed by + singles count + last string ; followed by = str ; singles count = num ; last type = constraint . type ; last string = constraint . to string ( ) ; } else { singles count ++ ; } } else { last type = constraint . type ; last string = constraint . to string ( ) ; singles count = num ; } } else { if ( last type != - num ) { str += followed by + singles count + last string ; followed by = str ; last type = - num ; singles count = num ; last string = str ; } str += followed by + constraint . to string ( ) ; followed by = str ; } } if ( last type != - num ) { str += followed by + singles count + last string ; } return str ; }	a printout of a user - friendly string describing the format.
public void read data ( data input din ) throws io { din . read short ( ) ; count = din . read unsigned short ( ) ; registers = new input register [ count ] ; for ( int i = num ; i < count ; i ++ ) { registers [ i ] = new simple input register ( din . read short ( ) ) ; } }	readdata - - input the modbus message from din.
public void adjust indentation ( int delta ) { if ( delta < num ) { indentation level = math . max ( num , indentation level + delta ) ; } else { indentation level += delta ; } }	adjusts the current indentation level of this log stream .
public int capacity ( ) { return capacity . get ( ) ; }	retrieves the maximum capacity of the map .
protected static token do code string ( ) throws java . io . io { string buffer result = new string buffer ( ) ; advance ( ) ; advance ( ) ; while ( ! ( next char == str && next char2 == str ) ) { if ( next char == eof char ) { emit error ( str ) ; break ; } result . append ( new character ( ( char ) next char ) ) ; advance ( ) ; } advance ( ) ; advance ( ) ; return new str token ( sym . code string , result . to string ( ) ) ; }	swallow up a code string.
public string random ( object omin , object omax ) { int min = function handler . get int ( omin ) ; int max = function handler . get int ( omax ) ; if ( max > min ) { return integer . to string ( rnd . next int ( max - min ) + min ) ; } return str ; }	returns a random number between min ( inclusive ) and max ( exclusive ).
public void test reopen01 ( ) { final i store = new simple memory raw store ( ) ; final b btree ; { index metadata md = new index metadata ( uuid . random uuid ( ) ) ; md . set branching factor ( num ) ; btree = b . create ( store , md ) ; } assert true ( btree . is open ( ) ) ; btree . close ( ) ; assert false ( btree . is open ( ) ) ; try { btree . close ( ) ; fail ( str + illegal state exception . class ) ; } catch ( illegal state exception ex ) { if ( log . is info enabled ( ) ) log . info ( str + ex ) ; } assert not null ( btree . get root ( ) ) ; assert true ( btree . is open ( ) ) ; }	test close on a new tree - should force the root to the store since a new root is dirty ( if empty ).
public static file search paths ( iterable < ? extends file > paths , string rel file ) { for ( file path : paths ) { file f = new file ( path , rel file ) ; if ( f . exists ( ) ) { return path ; } } return null ; }	given a relative file path and a list of " search paths " returns the search path where the file was located.
public boolean has unsupported critical extension ( ) { set extns = get critical extension oi ( ) ; return extns != null && ! extns . is empty ( ) ; }	will return true if any extensions are present and marked as critical as we currently don ' t handle any extensions !.
@ override public string buffer format ( double value , string buffer buffer , field position field ) { for ( int i = choice limits . length - num ; i >= num ; i -- ) { if ( choice limits [ i ] <= value ) { return buffer . append ( choice formats [ i ] ) ; } } return choice formats . length == num ? buffer : buffer . append ( choice formats [ num ] ) ; }	appends the string associated with the range in which the specified double value fits to the specified string buffer .
private void load configuration from jvm parameters ( ) { string repository property = system . get property ( repository property ) ; if ( null != repository property ) { string [ ] repository ip host = repository property . split ( str ) ; if ( repository ip host . length == num ) { string repository ip = repository ip host [ num ] ; string repository port = repository ip host [ num ] ; if ( string utils . is not blank ( repository ip ) && string utils . is not blank ( repository port ) ) { log . info ( str + repository ip + str + repository port ) ; try { int port = integer . parse int ( repository port ) ; set repository ( repository ip , port ) ; } catch ( exception e ) { log . warn ( str , e ) ; } } } } string agent name = system . get property ( agent name property ) ; if ( string utils . is not blank ( agent name ) ) { try { log . info ( str + agent name ) ; set agent name ( agent name ) ; } catch ( exception e ) { log . warn ( str , e ) ; } } else { try { set agent name ( default agent name ) ; } catch ( storage exception e ) { log . warn ( str , e ) ; } } }	checks if the jvm parameters have the repository and agent information .
public boolean soft signin ( ) throws io { if ( url == null ) { throw new illegal state exception ( str ) ; } check resolve host ( ) ; if ( session id != null ) { if ( check authorized ( get auth check url ( session id ) ) ) { logger . fine ( str + session id ) ; return bool ; } else { session id = null ; } } long id = load session id ( ) ; if ( id == num ) { return bool ; } boolean authorized = check authorized ( get auth check url ( id ) ) ; if ( authorized ) { logger . info ( str + id ) ; this . session id = id ; } return authorized ; }	if the user can be authenticated due to an existing session id , do so.
private void test view alter and command cache ( ) throws sql { delete db ( str ) ; connection conn = get connection ( str ) ; statement stat = conn . create statement ( ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; result set rs = stat . execute query ( str ) ; assert true ( rs . next ( ) ) ; assert equals ( num , rs . get int ( num ) ) ; stat . execute ( str ) ; rs = stat . execute query ( str ) ; assert true ( rs . next ( ) ) ; assert equals ( num , rs . get int ( num ) ) ; conn . close ( ) ; delete db ( str ) ; }	make sure that when we change a view , that change in reflected in other sessions command cache .
protected static boolean approx unit ( final string builder sbuf , final int amount , final int size , final string name ) { int count = amount / size ; int remainder ; if ( count == num ) { return bool ; } remainder = amount - ( count * size ) ; if ( remainder >= ( size * num / num ) ) { count ++ ; sbuf . append ( count ) ; } else if ( remainder >= ( size * num / num ) ) { count ++ ; sbuf . append ( str ) ; sbuf . append ( count ) ; } else if ( remainder >= ( size * num / num ) ) { sbuf . append ( str ) ; sbuf . append ( count ) ; sbuf . append ( str ) ; count = num ; } else if ( remainder >= ( size * num / num ) ) { sbuf . append ( str ) ; sbuf . append ( count ) ; } else { sbuf . append ( count ) ; } sbuf . append ( str ) ; sbuf . append ( grammar . plnoun ( count , name ) ) ; return bool ; }	for a given amount and unit size , generate the approximate value .
public static element create element ( document doc , string tag , string ns uri , string prefix ) { string q name = ( prefix == null || prefix . length ( ) == num ) ? tag : prefix + str + tag ; return doc . create element ns ( ns uri , q name ) ; }	creates an element in the specified namespace , with the specified tag and namespace prefix .
public static void modify file ( file file , function < string , string > modifier ) throws io { string content = new string ( files . to byte array ( file ) , standard charsets . utf 8 ) ; string result = modifier . apply ( content ) ; files . write ( result . get bytes ( standard charsets . utf 8 ) , file ) ; }	modifies the given file in place .
private void state2 ( ) throws io { int [ ] selection ids = read list ( new file ( file prefix + str ) ) ; int [ ] archived ids = read list ( new file ( file prefix + str ) ) ; int [ ] variation ids = new int [ lambda ] ; if ( selection ids . length != mu ) { throw new io ( str ) ; } update population ( archived ids ) ; clear file ( new file ( file prefix + str ) ) ; clear file ( new file ( file prefix + str ) ) ; list < solution > offspring = new array list < solution > ( ) ; for ( int i = num ; i < mu ; i += variation . get arity ( ) ) { solution [ ] parents = new solution [ variation . get arity ( ) ] ; for ( int j = num ; j < variation . get arity ( ) ; j ++ ) { parents [ j ] = solutions . get ( selection ids [ i + j ] ) ; } offspring . add all ( arrays . as list ( variation . evolve ( parents ) ) ) ; } if ( offspring . size ( ) != lambda ) { throw new io ( str ) ; } evaluate all ( offspring ) ; for ( int i = num ; i < lambda ; i ++ ) { variation ids [ i ] = add to population ( offspring . get ( i ) ) ; } write population ( new file ( file prefix + str ) , variation ids ) ; }	the commands to execute when in state 2 .
public void test list options ( ) { if ( m . get option handler ( ) != null ) { if ( ! m . check list options ( ) ) fail ( str ) ; } }	tests the listing of the options.
protected double ll ( double lat , double lon , d lp ) { double phi deg = lat ; double phi = proj math . deg to rad ( phi deg ) ; double lamba deg = lon ; double lamba = proj math . deg to rad ( lamba deg ) ; double dlamda = lamba - lamdaf ; if ( dlamda > math . pi ) { dlamda -= more math . two pi d ; } else if ( dlamda < - math . pi ) { dlamda += more math . two pi d ; } double e = ellps . ecc ; double r = num ; if ( ! more math . approximately equal ( math . abs ( phi ) , more math . half pi , ep ) ) { double t = lamb tsfn ( phi , math . sin ( phi ) , e ) ; r = ellps . radius * f * math . pow ( t , n ) ; } double theta = n * dlamda ; double easting = false easting + r * math . sin ( theta - alpha ) ; double northing = false northing + rf - r * math . cos ( theta - alpha ) ; lp . set location ( easting , northing ) ; return dlamda ; }	lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods.
protected void notify size changed ( float width , float height , int orientation ) { }	notifies when the size or the orientation of the view has actually changed .
protected boolean remove turntable ( layout turntable o ) { if ( ! no warn turntable ) { int selected value = j . show option dialog ( this , rb . get string ( str ) , bundle . get message ( str ) , j . yes no cancel option , j . question message , null , new object [ ] { bundle . get message ( str ) , bundle . get message ( str ) , rb . get string ( str ) } , bundle . get message ( str ) ) ; if ( selected value == num ) { return ( bool ) ; } if ( selected value == num ) { no warn turntable = bool ; } } if ( selected object == o ) { selected object = null ; } if ( prev selected object == o ) { prev selected object = null ; } for ( int j = num ; j < o . get number rays ( ) ; j ++ ) { track segment t = o . get ray connect ordered ( j ) ; if ( t != null ) { substitute anchor ( o . get ray coords indexed ( j ) , o , t ) ; } } for ( int i = num ; i < turntable list . size ( ) ; i ++ ) { layout turntable lx = turntable list . get ( i ) ; if ( lx == o ) { turntable list . remove ( i ) ; o . remove ( ) ; set dirty ( bool ) ; repaint ( ) ; return ( bool ) ; } } return ( bool ) ; }	remove a layout turntable.
@ override public final void end element ( final string ns , final string l name , final string q name ) throws sax { string name = l name == null || l name . length ( ) == num ? q name : l name ; rule r = ( rule ) rules . match ( match ) ; if ( r != null ) { r . end ( name ) ; } int slash = match . last index of ( str ) ; if ( slash >= num ) { match = match . substring ( num , slash ) ; } else { match = str ; } }	process notification of the end of an xml element being reached .
public ind as matrix ( buffered image image ) { if ( channels == num ) { return to bgr ( image ) ; } else { image = scaling if need ( image , bool ) ; int w = image . get width ( ) ; int h = image . get height ( ) ; ind ret = nd4j . create ( h , w ) ; for ( int i = num ; i < h ; i ++ ) { for ( int j = num ; j < w ; j ++ ) { ret . put scalar ( new int [ ] { i , j } , image . get rgb ( i , j ) ) ; } } return ret ; } }	convert an bufferedimage to a matrix.
public file system utils ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public int scheduled queue size ( ) { return scheduler queue size . get ( ) ; }	get the total number of scheduled requests .
public d ( j parent , string title , general name general name ) { super ( parent , title , modality type . document modal ) ; init components ( general name ) ; }	constructs a new dgeneralnamechooser dialog .
public void destroy scene ( ) { clear animations ( ) ; clear cameras ( ) ; clear lights ( ) ; clear plugins ( ) ; clear children ( ) ; clear frame callbacks ( ) ; }	clears any references the scene is holding for its contents.
private void add limited mitre join ( line segment offset0 , line segment offset1 , double distance , double mitre limit ) { coordinate base pt = seg0 . p1 ; double ang0 = angle . angle ( base pt , seg0 . p0 ) ; double ang1 = angle . angle ( base pt , seg1 . p1 ) ; double ang diff = angle . angle between oriented ( seg0 . p0 , base pt , seg1 . p1 ) ; double ang diff half = ang diff / num ; double mid ang = angle . normalize ( ang0 + ang diff half ) ; double mitre mid ang = angle . normalize ( mid ang + math . pi ) ; double mitre dist = mitre limit * distance ; double bevel delta = mitre dist * math . abs ( math . sin ( ang diff half ) ) ; double bevel half len = distance - bevel delta ; double bevel mid x = base pt . x + mitre dist * math . cos ( mitre mid ang ) ; double bevel mid y = base pt . y + mitre dist * math . sin ( mitre mid ang ) ; coordinate bevel mid pt = new coordinate ( bevel mid x , bevel mid y ) ; line segment mitre mid line = new line segment ( base pt , bevel mid pt ) ; coordinate bevel end left = mitre mid line . point along offset ( num , bevel half len ) ; coordinate bevel end right = mitre mid line . point along offset ( num , - bevel half len ) ; if ( side == position . left ) { seg list . add pt ( bevel end left ) ; seg list . add pt ( bevel end right ) ; } else { seg list . add pt ( bevel end right ) ; seg list . add pt ( bevel end left ) ; } }	adds a limited mitre join connecting the two reflex offset segments.
static byte [ ] discard non base64 ( byte [ ] data ) { byte groomed data [ ] = new byte [ data . length ] ; int bytes copied = num ; for ( int i = num ; i < data . length ; i ++ ) { if ( is base64 ( data [ i ] ) ) { groomed data [ bytes copied ++ ] = data [ i ] ; } } byte packed data [ ] = new byte [ bytes copied ] ; system . arraycopy ( groomed data , num , packed data , num , bytes copied ) ; return packed data ; }	discards any characters outside of the base64 alphabet , per the requirements on page 25 of rfc 2045 - " any characters outside of the base64 alphabet are to be ignored in base64 encoded data . ".
public void test multiply diff scale pos neg ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = - num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . multiply ( b number ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	multiply two numbers of different scales.
private static long limit duration ( long lease duration , long limit ) { if ( lease duration == lease . any || lease duration > limit ) lease duration = limit ; else if ( lease duration < num ) throw new illegal argument exception ( str ) ; return lease duration ; }	limit leaseduration by limit , and check for negative value .
static string path to cookie path ( string path ) { if ( path == null ) { return str ; } int last slash = path . last index of ( str ) ; return path . substring ( num , last slash + num ) ; }	returns a cookie - safe path by truncating everything after the last " / ".
public static string format simple decimal ( double d ) { return simple format . format ( d ) ; }	returns string from double formatted to decimalformat ( " # # # . # # " ).
protected abstract category item label generator ( string label format , date format formatter ) { param checks . null not permitted ( label format , str ) ; param checks . null not permitted ( formatter , str ) ; this . label format = label format ; this . number format = null ; this . percent format = number format . get percent instance ( ) ; this . date format = formatter ; this . null value string = str ; }	creates a label generator with the specified date formatter .
static long make id ( snmp oid oid ) { long id = num ; long [ ] arcs = oid . long value ( bool ) ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] << num ; id |= arcs [ num ] ; return id ; }	translate an oid to a thread id.
private void cache attribute ( string attr id , byte [ ] [ ] values ) { string cache key = name + str + attr id ; value cache . put ( cache key , values ) ; }	add the values to the cache .
void read ( reader policy ) throws parsing exception , io { if ( ! ( policy instanceof buffered reader ) ) { policy = new buffered reader ( policy ) ; } st = new stream tokenizer ( policy ) ; st . reset syntax ( ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( num + num , num ) ; st . whitespace chars ( num , str ) ; st . comment char ( str ) ; st . quote char ( str ) ; st . quote char ( str ) ; st . lower case mode ( bool ) ; st . ordinary char ( str ) ; st . slash slash comments ( bool ) ; st . slash star comments ( bool ) ; st . parse numbers ( ) ; hashtable < string , vector < string > > processed permissions = null ; lookahead = st . next token ( ) ; while ( lookahead != stream tokenizer . tt eof ) { if ( peek ( str ) ) { grant entry ge = parse grant entry ( processed permissions ) ; if ( ge != null ) grant entries . add element ( ge ) ; } else { throw new parsing exception ( st . lineno ( ) , str + str ) ; } match ( str ) ; } }	reads a policy configuration using a reader object . < p >.
protected void inject into volume information container ( map < string , string set > volume information , string info key , string alt key , cim volume instance ) { object value = get cim ( volume instance , info key ) ; if ( null == value ) { value = get cim ( volume instance , alt key ) ; } string characterstic name = supported volume information . get volume information ( info key ) ; if ( null != value && null != characterstic name ) { string set value set = new string set ( ) ; if ( value instanceof string ) { value set . add ( value . to string ( ) ) ; } else if ( value instanceof string [ ] ) { value set . add all ( arrays . as list ( ( string [ ] ) value ) ) ; } volume information . put ( characterstic name , value set ) ; } }	extract value from provider for given volume info key , and then get its name and use that to inject to map .
@ override public void on detached from recycler view ( recycler view recycler view ) { super . on detached from recycler view ( recycler view ) ; m attached recycler view pool . remove ( recycler view ) ; }	implementation of adapter . ondetachedfromrecyclerview ( recyclerview ) < p > called when this expandablerecycleradapter is detached from a recyclerview .
private void load file ( string filename , abstract file loader ... loaders ) { arff sorted table model model ; this . m = filename ; create title ( ) ; if ( filename . equals ( str ) ) { model = null ; } else { model = new arff sorted table model ( filename , loaders ) ; model . set show attribute index ( get show attribute index ( ) ) ; } m . set model ( model ) ; set changed ( bool ) ; create name ( ) ; }	loads the specified file into the table.
public static input stream try gzip input ( input stream in ) throws io { if ( ! in . mark supported ( ) ) { pushback input stream pb = new pushback input stream ( in , num ) ; in = pb ; byte [ ] magic = { num , num } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ num ] == num && magic [ num ] == - num ) { return new gzip ( pb ) ; } return in ; } in . mark ( num ) ; boolean isgzip = ( in . read ( ) == num && in . read ( ) == - num ) ; in . reset ( ) ; if ( isgzip ) { in = new gzip ( in ) ; } return in ; }	try to open a stream as gzip , if it starts with the gzip magic.
@ override public int hash code ( ) { if ( location != null ) return location . hash code ( ) ; else return num ; }	returns the hash code value for this object .
public static query new prefix query ( string field , inet address value , int prefix length ) { if ( value == null ) { throw new illegal argument exception ( str ) ; } if ( prefix length < num || prefix length > num * value . get address ( ) . length ) { throw new illegal argument exception ( str + prefix length + str ) ; } byte lower [ ] = value . get address ( ) ; byte upper [ ] = value . get address ( ) ; for ( int i = prefix length ; i < num * lower . length ; i ++ ) { int m = num << ( num - ( i & num ) ) ; lower [ i > > num ] &= ~ m ; upper [ i > > num ] |= m ; } try { return new range query ( field , inet address . get by address ( lower ) , inet address . get by address ( upper ) ) ; } catch ( unknown host exception e ) { throw new assertion error ( e ) ; } }	create a prefix query for matching a cidr network range .
public static subject create am ( policy manager pm , am user ) throws policy exception { subject type manager mgr = pm . get subject type manager ( ) ; subject subject = mgr . get subject ( str ) ; set < string > set = new hash set < string > ( ) ; set . add ( user . get universal id ( ) ) ; subject . set values ( set ) ; return subject ; }	returns a subject for the given amidentity .
protected void expand for ( int index , double d ) { if ( index < size ) return ; int old size = size , capacity = vector . length ; size = index + num ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= num ; double [ ] t = new double [ capacity ] ; system . arraycopy ( vector , num , t , num , old size ) ; if ( d != num ) arrays . fill ( t , old size , size , d ) ; vector = t ; }	makes sure the capacity and size of the vector can accomodate the given index.
private void do normal command line list ( list < string > command line list , list < string > joint options , path classpath ) { command line list . add ( str ) ; command line list . add ( classpath . to string ( ) ) ; if ( joint compilation ) { command line list . add ( str ) ; command line list . add all ( joint options ) ; } if ( dest dir != null ) { command line list . add ( str ) ; command line list . add ( dest dir . get path ( ) ) ; } if ( encoding != null ) { command line list . add ( str ) ; command line list . add ( encoding ) ; } if ( stacktrace ) { command line list . add ( str ) ; } if ( parameters ) { command line list . add ( str ) ; } if ( use indy ) { command line list . add ( str ) ; } if ( script base class != null ) { command line list . add ( str ) ; command line list . add ( script base class ) ; } if ( configscript != null ) { command line list . add ( str ) ; command line list . add ( configscript ) ; } }	add " groovyc " parameters to the commandlinelist , based on the ant configuration .
private synchronized void load hex image ( i hex ) { hex tileset . assign match ( hex , boardview ) ; hex tileset . track hex images ( hex , tracker ) ; }	loads the image ( s ) for this hex into the tracker .
public void triangulate ( point set ps ) { triangulations . clear ( ) ; triangulations . add ( ps ) ; start ( ) ; }	triangulate a pointset with eventual constraints.
public string base64 url encode ( byte [ ] data ) { string encoded data = new string ( base64 . encode ( data , base64 . url safe ) ) ; encoded data = encoded data . replace ( str , str ) ; encoded data = encoded data . replace ( str , str ) ; return encoded data ; }	encodes a string with base64url encoding it also removes characters which must be removed according to the jose spec : http : / / tools.
private void write java field spec ( java field spec spec , document document , element parent element ) { element parameter = document . create element ( str ) ; parameter . append child ( parent element ) ; parameter . set attribute ( str , spec . get package name ( ) ) ; parameter . set attribute ( str , spec . get class name ( ) ) ; parameter . set attribute ( str , spec . get field name ( ) ) ; }	writes out a source / sink specification object for java static fields.
private void read object ( object input stream s ) throws io , class not found exception { s . default read object ( ) ; init ( get mask ( actions ) ) ; }	readobject is called to restore the state of the filepermission from a stream .
@ override public synchronized void parse ( reader reader , string base uri ) throws io , rdf , rdf { if ( reader == null ) { throw new illegal argument exception ( str ) ; } if ( base uri == null ) { throw new illegal argument exception ( str ) ; } input source input source = new input source ( reader ) ; input source . set system id ( base uri ) ; parse ( input source ) ; }	parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .
private string exclude destination statement ( string text ) { int idx = - num ; if ( ( idx = text . index of ( str ) ) != - num ) { text = text . substring ( num , idx ) ; } return text ; }	parses the specified string to return the portion not containing the destination statement.
protected static final string add escapes ( string str ) { string builder retval = new string builder ( ) ; char ch ; for ( int i = num ; i < str . length ( ) ; i ++ ) { switch ( str . char at ( i ) ) { case num : continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; default : if ( ( ch = str . char at ( i ) ) < num || ch > num ) { string s = str + integer . to string ( ch , num ) ; retval . append ( str + s . substring ( s . length ( ) - num , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to string ( ) ; }	replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string.
public static void add file ( string s ) throws io { file f = new file ( s ) ; add file ( f ) ; }	adds a file to the classpath .
@ safe varargs public final void insert ( int row index , t ... new items ) { insert ( row index , arrays . as list ( new items ) ) ; }	insert new records at a specified index .
@ deprecated public void put ( collection < integer > data ) { for ( integer value : data ) { final int val = value . int value ( ) ; min = val < min ? val : min ; max = val > max ? val : max ; } }	process a whole collection of integer values.
public int buffer major version buffer ( ) { int [ ] holder = new int [ num ] ; holder [ num ] = get major version ( ) ; int buffer ib = int buffer . wrap ( holder ) ; ib . limit ( num ) ; return ib ; }	return an intbuffer that accesses the major version number.
public create index request source ( x source ) { return source ( source . bytes ( ) ) ; }	sets the settings and mappings as a single source .
public static byte [ ] create data to sign ( byte [ ] digest ) { byte [ ] prefix = get digest info prefix ( digest ) ; byte [ ] digest info = new byte [ prefix . length + digest . length ] ; system . arraycopy ( prefix , num , digest info , num , prefix . length ) ; system . arraycopy ( digest , num , digest info , prefix . length , digest . length ) ; return digest info ; }	creates data to be signed from the digest .
public http request if modified since ( final long value ) { connection . set if modified since ( value ) ; return this ; }	set the ' if - modified - since ' request header to the given value.
public static string tmp journal ( ) { final file file = code . wrap throw ( null ) ; file . delete on exit ( ) ; return file . get absolute path ( ) ; }	create a tmp journal file for test cases .
public static object new instance ( class < ? > cl , int [ ] dims ) { if ( dims . length == num ) { dims = new int [ ] { num } ; } return array . new instance ( cl , dims ) ; }	allocate an array dynamically.
public void play together ( collection < animator > items ) { if ( items != null && items . size ( ) > num ) { m needs sort = bool ; builder builder = null ; for ( animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }	sets up this animatorset to play all of the supplied animations at the same time .
protected static void print error message ( exception e ) { if ( e instanceof abort exception ) { logging configuration . set verbose ( level . verbose ) ; log . verbose ( e . get message ( ) ) ; } else if ( e instanceof unspecified parameter exception ) { log . error ( e . get message ( ) ) ; } else if ( e instanceof parameter exception ) { log . error ( e . get message ( ) ) ; } else { log . exception ( e ) ; } }	print an error message for the given error .
public string request statistics ( ) { sb . set length ( num ) ; make string buffer ( sb ) ; return sb . to string ( ) ; }	a method for other parts of the application to get stats the command processor uses this to report stats on request.
private void apply l1 reg ( final double eta t , vec x ) { if ( lambda1 > num ) { l1 u += eta t * lambda1 ; for ( int k = num ; k < ws . length ; k ++ ) { final vec w k = ws [ k ] ; final double [ ] l1 q k = l1 q [ k ] ; for ( index value iv : x ) { final int i = iv . get index ( ) ; final double z = w k . get ( i ) ; double new w i = num ; if ( z > num ) new w i = math . max ( num , z - ( l1 u + l1 q k [ i ] ) ) ; else if ( z < num ) new w i = math . min ( num , z + ( l1 u - l1 q k [ i ] ) ) ; l1 q k [ i ] += ( new w i - z ) ; w k . set ( i , new w i ) ; } } } }	applies l1 regularization to the model.
@ override public void key pressed ( key event e ) { synchronized ( key lock ) { keys down . add ( e . get key code ( ) ) ; } }	this method cannot be called directly .
public static string slurp url ( url u , string encoding ) { try { return slurp url ( u , encoding ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }	returns all the text at the given url .
public static move participant [ ] load move participants ( refactoring status status , refactoring processor processor , object element , move arguments arguments , i filter , string [ ] affected natures , sharable participants shared ) { refactoring participant [ ] participants = fg move extensions . get participants ( status , processor , element , arguments , filter , affected natures , shared ) ; move participant [ ] result = new move participant [ participants . length ] ; system . arraycopy ( participants , num , result , num , participants . length ) ; return result ; }	loads the move participants for the given element .
private long [ ] determine preference vector ( relation < v > relation , dbi [ ] neighbor i , string builder msg ) { if ( strategy . equals ( strategy . apriori ) ) { return determine preference vector by apriori ( relation , neighbor i , msg ) ; } else if ( strategy . equals ( strategy . max intersection ) ) { return determine preference vector by max intersection ( neighbor i , msg ) ; } else { throw new illegal state exception ( str ) ; } }	determines the preference vector according to the specified neighbor ids .
private void paint foreground disabled ( d g , int width , int height ) { shape s = decode arrow path ( width , height ) ; g . set paint ( disabled color ) ; g . fill ( s ) ; }	paint the arrow in disabled state .
public void test flip bit negative inside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; int number = num ; byte r bytes [ ] = { - num , num , - num , - num , num , num , - num , - num , - num , - num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	flipbit ( int n ) inside a negative number.
private void on user ( @ not null tl abs user ) { user current user = null ; user user = null ; if ( abs user instanceof tl ) { final tl tl user = ( tl ) abs user ; if ( tl user . is mutual contact ( ) ) { current user = ( user ) database manager . get user by id ( tl user . get id ( ) ) ; user = on user contact ( current user , tl user ) ; } else if ( tl user . is deleted ( ) ) { current user = ( user ) database manager . get user by id ( tl user . get id ( ) ) ; user = on user delete ( current user , tl user ) ; } else if ( tl user . is contact ( ) ) { current user = ( user ) database manager . get user by id ( tl user . get id ( ) ) ; user = on user request ( current user , tl user ) ; } else if ( tl user . is self ( ) || ! tl user . is bot ( ) ) { current user = ( user ) database manager . get user by id ( tl user . get id ( ) ) ; user = on user foreign ( current user , tl user ) ; } else { bot logger . info ( logtag , str ) ; } } if ( ( current user == null ) && ( user != null ) ) { database manager . add user ( user ) ; } else if ( user != null ) { database manager . update user ( user ) ; } }	add a user to database.
@ override public boolean has next ( ) { log . log ( level . fine , str ) ; boolean result = ( next event != null ) ; log . log ( level . fine , str , result ) ; return result ; }	check if there are more events.
public static xmp extract xmp ( input stream is ) { list < section > sections = parse ( is , bool ) ; if ( sections == null ) { return null ; } for ( section section : sections ) { if ( has xmp ( section . data ) ) { int end = get xmp ( section . data ) ; byte [ ] buffer = new byte [ end - xmp header size ] ; system . arraycopy ( section . data , xmp header size , buffer , num , buffer . length ) ; try { xmp result = xmp . parse from buffer ( buffer ) ; return result ; } catch ( xmp e ) { log . d ( tag , str , e ) ; return null ; } } } return null ; }	extracts xmpmeta from a jpeg image file stream .
private void initialize ( model validator validator , m client ) { if ( client == null ) m global validators . add ( validator ) ; m validators . add ( validator ) ; validator . initialize ( this , client ) ; }	initialize and add validator.
void cross over ( bayes net representation other ) { boolean [ ] bits = new boolean [ m bits . length ] ; for ( int i = num ; i < m bits . length ; i ++ ) { bits [ i ] = m bits [ i ] ; } int i cross over point = m bits . length ; do { for ( int i = i cross over point ; i < m bits . length ; i ++ ) { m bits [ i ] = bits [ i ] ; } i cross over point = m random . next int ( m bits . length ) ; for ( int i = i cross over point ; i < m bits . length ; i ++ ) { m bits [ i ] = other . m bits [ i ] ; } } while ( has cycles ( ) ) ; calc global score ( ) ; }	apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .
public void reset ( ) { engine reset ( ) ; state = initial ; }	resets the digest for further use .
public perspective create user perspective ( final string name , final boolean show ) { perspective perspective = model . add perspective ( name , bool ) ; perspective . store ( context ) ; if ( show ) { show perspective ( name ) ; } return perspective ; }	creates a user - defined perspectives , and possibly switches to this new perspective immediately.
public static double phred ( double error ) { return - num * math . log10 ( error ) ; }	get a phred - scaled quality value corresponding to the supplied error rate .
public static string of ( ct class type ) { string buffer sbuf = new string buffer ( ) ; to descriptor ( sbuf , type ) ; return sbuf . to string ( ) ; }	returns the descriptor representing the given type .
public abstract string encode ( ) ;	get the string encoded version of this object.
@ safe varargs public final token < token type > expect ( token type ... expected ) throws simple parser exception { if ( has type ( expected ) ) return this ; throw new simple parser exception ( line , column , str + arrays . to string ( expected ) + str + to string ( ) ) ; }	ensures that this token has one of the given expected types .
public void test update3 ( ) { int new value1 = - num ; int new value2 = - num ; string update query = str + database creator . test tabl + str + new value1 + str + new value2 ; try { int num = statement . execute update ( update query ) ; assert equals ( str , number of records , num ) ; string select query = str + database creator . test tabl ; result set result = statement . execute query ( select query ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } }	updatefunctionalitytest # testupdate3 ( ) . updates values in a several columns in the table.
public void test set null ( ) throws exception { prepared statement stmt = connection . prepare statement ( str ) ; try { stmt . set int ( num , num ) ; stmt . set bytes ( num , null ) ; stmt . execute update ( ) ; stmt . set int ( num , num ) ; stmt . set binary stream ( num , null , num ) ; stmt . execute update ( ) ; stmt . set int ( num , num ) ; stmt . set string ( num , null ) ; stmt . execute update ( ) ; } finally { stmt . close ( ) ; } }	this method checks if we correctly handle assigning null values to blobs .
@ deprecated public boolean is assignable from ( type from ) { if ( from == null ) { return bool ; } if ( type . equals ( from ) ) { return bool ; } if ( type instanceof class < ? > ) { return raw type . is assignable from ( gson types . get raw type ( from ) ) ; } else if ( type instanceof parameterized type ) { return is assignable from ( from , ( parameterized type ) type , new hash map < string , type > ( ) ) ; } else if ( type instanceof generic array type ) { return raw type . is assignable from ( gson types . get raw type ( from ) ) && is assignable from ( from , ( generic array type ) type ) ; } else { throw build unexpected type error ( type , class . class , parameterized type . class , generic array type . class ) ; } }	check if this type is assignable from the given type .
eg demand details insert penalty ( final big decimal chq bounce penalty , final module module ) { eg demand details demand detail = null ; if ( chq bounce penalty != null && chq bounce penalty . compare to ( big decimal . zero ) > num ) { final installment curr installment = get current installment ( module ) ; final eg demand reason master eg demand reason master = demand generic dao . get demand reason master by code ( demandrsn code chq bounce penalty , module ) ; if ( eg demand reason master == null ) throw new application runtime exception ( str ) ; final eg demand reason eg demand reason = demand generic dao . get dmd reason by dmd reason mster install and mod ( eg demand reason master , curr installment , module ) ; if ( eg demand reason == null ) throw new application runtime exception ( str ) ; demand detail = eg demand details . from reason and amounts ( chq bounce penalty , eg demand reason , big decimal . zero ) ; } return demand detail ; }	method used to insert penalty in egdemanddetail table.
public sample info ( byte buffer bb ) throws io { number of channels = bb . get int ( ) ; sample rate = bb . get int ( ) ; coeff min = bb . get float ( ) ; coeff range = bb . get float ( ) ; post emphasis = bb . get float ( ) ; residual fold = bb . get int ( ) ; }	constructs a sample info from the given byte buffer .
public void handle maintenance ( operation maint op ) { perform pending request maintenance ( ) ; check and schedule synchronization ( this . cached group state . membership update time micros ) ; maint op . complete ( ) ; }	invoked by parent during its maintenance interval.
public < t > t time ( callable < t > event ) throws exception { final long start time = clock . tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . tick ( ) - start time ) ; } }	times and records the duration of event .
public static boolean is post jd ( string bytecode version ) { return jd . equals ( bytecode version ) || jd . equals ( bytecode version ) ; }	checks if the specified bytecode version string represents a jdk 1.
public put index template request mapping ( string type , object ... source ) { mapping ( type , put mapping request . build from simplified def ( type , source ) ) ; return this ; }	a specialized simplified mapping source method , takes the form of simple properties definition : ( " field1 " , " type = string , store = true " ) .
private input stream find template ( string path , string template ) { try { file file = new file ( path , template ) ; if ( file . can read ( ) ) { return new buffered input stream ( new file input stream ( file . get absolute path ( ) ) ) ; } else { return null ; } } catch ( file not found exception fnfe ) { return null ; } }	try to find a template given a normalized path .
@ override public synchronized void initialize ( ) { if ( ! m root directory . exists ( ) ) { if ( ! m root directory . mkdirs ( ) ) { volley log . e ( str , m root directory . get absolute path ( ) ) ; } return ; } file [ ] files = m root directory . list files ( ) ; if ( files == null ) { return ; } for ( file file : files ) { buffered input stream fis = null ; try { fis = new buffered input stream ( new file input stream ( file ) ) ; cache header entry = cache header . read header ( fis ) ; entry . size = file . length ( ) ; put entry ( entry . key , entry ) ; } catch ( io e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( io ignored ) { } } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public void add listener ( circular progress view listener listener ) { if ( listener != null ) listeners . add ( listener ) ; }	register a circularprogressviewlistener with this view.
public site status check thread impl ( ) { super ( ) ; url checkers = new hash map ( ) ; }	constructs a sitestatuscheckthreadimpl object based on the configured parameter com.
@ override public void render ( final int type , final d g2 , final float scaling , final boolean is form glyph ) { glyph display . set scaling values ( num , num , scaling ) ; final float ol = glyph scale ; if ( is form glyph ) { glyph scale = scaling * glyph scale ; } affine transform aff = null ; if ( glyph scale != num ) { aff = g2 . get transform ( ) ; g2 . scale ( glyph scale , glyph scale ) ; } glyph display . set g2 ( g2 ) ; glyph display . paint ( null , null , null ) ; if ( aff != null ) { g2 . set transform ( aff ) ; } glyph scale = ol ; }	draw the t3 glyph.
public list < string > reset ( list < string > replace ) { array list < string > copy = new array list < string > ( retained vars . size ( ) ) ; copy . add all ( retained vars ) ; retained vars . clear ( ) ; if ( replace != null ) { retained vars . add all ( replace ) ; } return copy ; }	replaces the list of retained vars with the specified list , returning the old list.
protected void release ( ) { app context temp app context = null ; synchronized ( grab release synchronizer ) { if ( usage count > num ) { -- usage count ; } else { synchronized ( thread group synchronizer ) { temp app context = reset app context ( ) ; } } } if ( temp app context != null ) { try { temp app context . dispose ( ) ; } catch ( illegal thread state exception e ) { } } }	release this appletclassloader and its threadgroup / appcontext.
public synchronized void delete all tables ( ) { list < string > table names = new array list < string > ( table lookup . key set ( ) ) ; for ( string s : table names ) { delete table ( s ) ; } }	delete all tables from this database .
public pet category find one ( string id ) { log . debug ( str , id ) ; pet category pet category = pet category repository . find one ( uuid . from string ( id ) ) ; return pet category ; }	get one petcategory by id .
private void mark removed default session token ( string site , string token ) { if ( removed default tokens == null ) removed default tokens = new hash map < > ( num ) ; hash set < string > removed set = removed default tokens . get ( site ) ; if ( removed set == null ) { removed set = new hash set < > ( num ) ; removed default tokens . put ( site , removed set ) ; } removed set . add ( token ) ; }	marks a default session token as removed for a particular site .
public exchange ( final request request , final origin origin ) { this . current request = request ; this . origin = origin ; this . timestamp = system . current time millis ( ) ; }	creates a new exchange with the specified request and origin .
public static float compute discard alpha ( float amount , float range ) { if ( math . abs ( amount ) < num ) return num ; float t = amount / range ; t = math utils . clamp ( t , - num , num ) ; return num - math . abs ( t ) ; }	computes the alpha value of the tab based on its discard status .
public static final file time unix time to file time ( long utime ) { return file time . from ( utime , time unit . seconds ) ; }	converts " standard unix time " ( in seconds , utc / gmt ) to filetime.
public static cipher text iv mac encrypt ( string plaintext , secret keys secret keys , string encoding ) throws unsupported encoding exception , general security exception { return encrypt ( plaintext . get bytes ( encoding ) , secret keys ) ; }	generates a random iv and encrypts this plain text with the given key.
public void remove address ( address entity address ) { addresses . remove ( address ) ; }	removes the given address from this user.
@ override protected void on measure ( int width measure spec , int height measure spec ) { int width spec mode = measure spec . get mode ( width measure spec ) ; int height spec mode = measure spec . get mode ( height measure spec ) ; int parent width = measure spec . get size ( width measure spec ) ; int parent height = measure spec . get size ( height measure spec ) ; boolean resize width = width spec mode != measure spec . exactly ; boolean resize height = height spec mode != measure spec . exactly ; int width = parent width ; int height = parent height ; if ( s width > num && s height > num ) { if ( resize width && resize height ) { width = s width ( ) ; height = s height ( ) ; } else if ( resize height ) { height = ( int ) ( ( ( ( double ) s height ( ) / ( double ) s width ( ) ) * width ) ) ; } else if ( resize width ) { width = ( int ) ( ( ( ( double ) s width ( ) / ( double ) s height ( ) ) * height ) ) ; } } width = math . max ( width , get suggested minimum width ( ) ) ; height = math . max ( height , get suggested minimum height ( ) ) ; set measured dimension ( width , height ) ; }	measures the width and height of the view , preserving the aspect ratio of the image displayed if wrap_content is used.
protected void fire end elem ( string name ) throws org . xml . sax . sax { if ( m tracer != null ) { flush my writer ( ) ; m tracer . fire generate event ( serializer trace . eventtype endelement , name , ( attributes ) null ) ; } }	to fire off the end element trace event.
private boolean verify migrate from product home ( string migrate from product home ) throws install exception { if ( migrate from product home == null || migrate from product home . length ( ) == num ) { debug . log ( str + str ) ; console . println ( localized message . get ( loc hr msg migrate none found ) ) ; return bool ; } if ( ! migrate from product home . equals ( config util . get home path ( ) ) ) { debug . log ( str + str + migrate from product home + str + config util . get home path ( ) ) ; string translate file = migrate from product home + migrate from inst finder store . get relative translate file ( ) ; if ( ! file utils . is file valid ( translate file ) ) { console . println ( localized message . get ( loc hr msg migrate none found ) ) ; return bool ; } } else { debug . log ( str + str ) ; throw new install exception ( localized message . get ( loc dr err product already migrated ) ) ; } return bool ; }	check if the product home input by the user has the locator file of the product to be migrated from .
public spanned [ ] history ( ) { int i = num ; spanned [ ] array = new spanned [ history . size ( ) ] ; for ( string s : history ) { if ( s != null ) { array [ i ] = html . from html ( s ) ; i ++ ; } } return array ; }	generate an array of spanned items representing the history of this connection .
public static string format ( string message , object [ ] arguments ) { return message format . format ( message , arguments ) ; }	formats the given string with the given argument .
private void insert prosody settings ( utterance utterance , element element ) { element prosody = ( element ) dom utils . get ancestor ( element , xml . prosody ) ; if ( prosody == null ) { return ; } element voice = ( element ) dom utils . get ancestor ( element , xml . voice ) ; if ( voice != null && dom utils . is ancestor ( prosody , voice ) ) { return ; } element paragraph = ( element ) dom utils . get ancestor ( element , xml . paragraph ) ; if ( paragraph != null && dom utils . is ancestor ( prosody , paragraph ) ) { return ; } for ( string att : prosody attributes ) { string val = prosody . get attribute ( att ) ; if ( ! val . equals ( str ) ) { utterance . set string ( att , val ) ; } } }	for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance.
public static boolean create folder ( @ suppress warnings ( str ) context m context , string path , string folder name ) { file sd = new file ( path , folder name ) ; if ( ! sd . exists ( ) ) { return sd . mkdir ( ) ; } return bool ; }	use to create folder in your directory.
private void translate matrix after rotate ( int axis , float trans , float prev image size , float image size , int prev view size , int view size , int drawable size ) { if ( image size < view size ) { m [ axis ] = ( view size - ( drawable size * m [ matrix . mscale x ] ) ) * num ; } else if ( trans > num ) { m [ axis ] = - ( ( image size - view size ) * num ) ; } else { float percentage = ( math . abs ( trans ) + ( num * prev view size ) ) / prev image size ; m [ axis ] = - ( ( percentage * image size ) - ( view size * num ) ) ; } }	after rotating , the matrix needs to be translated.
private char sequence create ticker text ( string title , string body ) { spannable string builder spannable string builder = new spannable string builder ( ) ; spannable string builder . append ( title ) ; spannable string builder . append ( str ) ; spannable string builder . append ( body ) ; spannable string builder . set span ( new style span ( android . graphics . typeface . bold ) , num , title . length ( ) , spannable . span inclusive inclusive ) ; return spannable string builder ; }	creates the ticker text for a notification having | title | and | body |.
private void add protocol if not exists ( set < string > protocols , string protocol type ) { if ( ! protocols . contains ( protocol type ) ) { protocols . add ( protocol type ) ; } }	verify whether protocoltype already exists or not.
public string to string ( ) { string builder result = new string builder ( ) ; result . append ( str ) ; result . append ( klazz . get name ( ) ) ; result . append ( str ) ; for ( int i = num ; i < elements . length ; ++ i ) { if ( i != num ) { result . append ( str ) ; } result . append ( elements [ i ] ) ; } result . append ( str ) ; return result . to string ( ) ; }	provides detailed description of this annotation instance , including all member name - values pairs .
void add ( object key ) { table . put ( key , key ) ; }	adds an object to this set .
public configuration load config from resource ( resource resource ) { properties configuration result = new properties configuration ( ) ; try { result . load ( resource . get input stream ( ) ) ; return result ; } catch ( configuration exception | io e ) { log . error ( configuration load error . format ( resource . get filename ( ) ) , e ) ; throw new system config exception ( configuration load error . format ( resource . get filename ( ) ) , e ) ; } }	build a configuration object from a resource , processing it as a properties file .
public final void log ( string filename , int line number , string method , string tag , int level , string message ) { final log message lm = new log message ( log message . logmsg type log , next sequence number . get and increment ( ) ) ; lm . add int16 ( level , log message . part key level ) ; if ( filename != null ) { lm . add string ( filename , log message . part key filename ) ; if ( line number != num ) lm . add int32 ( line number , log message . part key linenumber ) ; } if ( method != null ) lm . add string ( method , log message . part key functionname ) ; if ( tag != null && ! tag . is empty ( ) ) lm . add string ( tag , log message . part key tag ) ; lm . add string ( message , log message . part key message ) ; log ( lm ) ; }	log a message with full information ( if provided ).
protected d draw vertical ( d g2 , d chart area ) { double start x ; double top space = num ; double bottom space = num ; double left space = num ; double right space = num ; double w = get width ( ) ; double h = get height ( ) ; rectangle insets padding = get padding ( ) ; if ( padding != null ) { top space = padding . calculate top outset ( h ) ; bottom space = padding . calculate bottom outset ( h ) ; left space = padding . calculate left outset ( w ) ; right space = padding . calculate right outset ( w ) ; } if ( get position ( ) == rectangle edge . left ) { start x = chart area . get x ( ) + left space ; } else { start x = chart area . get max x ( ) - right space - w ; } vertical alignment alignment = get vertical alignment ( ) ; double start y = num ; if ( alignment == vertical alignment . center ) { start y = chart area . get min y ( ) + top space + chart area . get height ( ) / num - h / num ; } else if ( alignment == vertical alignment . top ) { start y = chart area . get min y ( ) + top space ; } else if ( alignment == vertical alignment . bottom ) { start y = chart area . get max y ( ) - bottom space - h ; } g2 . draw image ( this . image , ( int ) start x , ( int ) start y , ( int ) w , ( int ) h , null ) ; return new d ( chart area . get width ( ) + left space + right space , h + top space + bottom space ) ; }	draws the title on a java 2d graphics device ( such as the screen or a printer ) .
private static final public key construct public key ( byte [ ] encoded key , string encoded key algorithm ) throws invalid key exception , no such algorithm exception { public key key = null ; try { key factory key factory = key factory . get instance ( encoded key algorithm , jce . get instance ( ) ) ; x509 encoded key spec key spec = new x509 encoded key spec ( encoded key ) ; key = key factory . generate public ( key spec ) ; } catch ( no such algorithm exception nsae ) { try { key factory key factory = key factory . get instance ( encoded key algorithm ) ; x509 encoded key spec key spec = new x509 encoded key spec ( encoded key ) ; key = key factory . generate public ( key spec ) ; } catch ( no such algorithm exception nsae2 ) { throw new no such algorithm exception ( str + str + encoded key algorithm + str ) ; } catch ( invalid key spec exception ikse2 ) { invalid key exception ike = new invalid key exception ( str ) ; ike . init cause ( ikse2 ) ; throw ike ; } } catch ( invalid key spec exception ikse ) { invalid key exception ike = new invalid key exception ( str ) ; ike . init cause ( ikse ) ; throw ike ; } return key ; }	construct a public key from its encoding .
public int num hits ( string query ) throws parse exception , io { integer count ; if ( ( count = ( integer ) m hit count cache . get ( query ) ) == null ) { hits hits = search ( query ) ; count = new integer ( hits . length ( ) ) ; m hit count cache . put ( query , count ) ; } return count . int value ( ) ; }	return the result count for the given search query.
public static boolean expression is true ( double left side , operator operator , double right side ) { final string expression = left side + operator . get mathematical operator ( ) + right side ; return expression is true ( expression ) ; }	evaluates whether an expression is true or false .
public mock response add header ( string name , object value ) { return add header ( name + str + string . value of ( value ) ) ; }	adds a new header with the name and value.
@ override public completable future < optional < t > > max ( final comparator < ? super t > comparator ) { return completable future . supply async ( null , exec ) ; }	perform an asyncrhonous min operation.
final public void println ( char v ) { writer out = this . out ; if ( out == null ) return ; try { out . write ( v ) ; out . write ( newline , num , newline . length ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a character followed by a newline .
public void test write correct rejection empty record ( ) { final i store = get store ( ) ; try { try { store . write ( byte buffer . wrap ( new byte [ ] { } ) ) ; fail ( str + illegal argument exception . class ) ; } catch ( illegal argument exception ex ) { if ( log . is info enabled ( ) ) log . info ( str + ex ) ; } try { final byte buffer buf = byte buffer . wrap ( new byte [ num ] ) ; buf . position ( buf . limit ( ) ) ; store . write ( buf ) ; fail ( str + illegal argument exception . class ) ; } catch ( illegal argument exception ex ) { if ( log . is info enabled ( ) ) log . info ( str + ex ) ; } } finally { store . destroy ( ) ; } }	test verifies correct rejection of a write operation when the caller supplies an empty buffer ( no bytes remaining ) .
public synchronized void commit ( ) { synchronized ( mutex ) { map < column , set < interval > > temp = working intervals ; working intervals = collections . synchronized map ( new linked hash map < > ( ) ) ; available intervals ref . set ( collections . unmodifiable map ( new linked hash map < > ( temp ) ) ) ; super . columns = new linked hash set < > ( temp . key set ( ) ) ; } }	swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .
public void test update7 ( ) { string update query = str + database creator . test tabl + str + database creator . test tabl + str ; try { int num = statement . execute update ( update query ) ; int expected updated = num ; assert equals ( str , expected updated , num ) ; string select query = str + database creator . test tabl ; result set result = statement . execute query ( select query ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } }	updatefunctionalitytest # testupdate7 ( ) . updates records in the table using subquery in update command.
public static string extract indent string ( string line , int tab width , int indent width ) { if ( tab width < num || indent width < num || line == null ) { throw new illegal argument exception ( ) ; } int size = line . length ( ) ; int end = num ; int space equivs = num ; int characters = num ; for ( int i = num ; i < size ; i ++ ) { char c = line . char at ( i ) ; if ( c == str ) { space equivs = calculate space equivalents ( tab width , space equivs ) ; characters ++ ; } else if ( is indent char ( c ) ) { space equivs ++ ; characters ++ ; } else { break ; } if ( space equivs >= indent width ) { end += characters ; characters = num ; if ( indent width == num ) { space equivs = num ; } else { space equivs = space equivs % indent width ; } } } if ( end == num ) { return util . empty string ; } else if ( end == size ) { return line ; } else { return line . substring ( num , end ) ; } }	returns the leading indentation string of the given line.
private static string do get full path ( string filename , boolean include separator ) { if ( filename == null ) { return null ; } int prefix = get prefix length ( filename ) ; if ( prefix < num ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( include separator ) { return get prefix ( filename ) ; } else { return filename ; } } int index = index of last separator ( filename ) ; if ( index < num ) { return filename . substring ( num , prefix ) ; } int end = index + ( include separator ? num : num ) ; if ( end == num ) { end ++ ; } return filename . substring ( num , end ) ; }	does the work of getting the path .
private static boolean add if matches ( list < string > container , string status line , char x , char y ) { if ( matches ( status line , x , y ) ) { final string filename = status line . substring ( num ) ; if ( ! container . contains ( filename ) ) { container . add ( filename ) ; } return bool ; } return bool ; }	adds files to container if they matched to template .
public void test divide round half down neg2 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round half down ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is negative ; equidistant.
public static string encode from string ( string plain , string charset ) throws coder exception , unsupported encoding exception { return encode ( plain . get bytes ( charset ) ) ; }	encodes a string to base64 string.
public void slide ( slide slide ) { if ( slide == slide . up ) { if ( ! is panel shown ( ) ) { int position = num ; if ( items != null ) { position = items . size ( ) / num ; } slide up ( position ) ; } } else { hide panel picker ui ( ) ; } }	slide the panel to the desired direction .
public drawer builder add sticky drawer items ( @ non null i ... sticky drawer items ) { if ( this . m sticky drawer items == null ) { this . m sticky drawer items = new array list < > ( ) ; } collections . add all ( this . m sticky drawer items , id distributor . check ids ( sticky drawer items ) ) ; return this ; }	add a initial draweritem or a draweritem array for the stickydrawerfooter.
public boolean is debugging finest ( ) { return logger . is loggable ( level . finest ) ; }	test whether to log ' debug ' at ' finest ' level.
public void reset ( ) { ns . remove all elements ( ) ; ks . set length ( num ) ; cur = tt . root ; run ( ) ; }	resets the iterator to its initial state .
@ layoutlib delegate static float sin ( float angle ) { return ( float ) math . sin ( angle ) ; }	returns the closest float approximation of the sine of the argument .
public byte [ ] extract data ( byte [ ] stego data , string stego file name , byte [ ] orig sig data ) throws open stego exception { return null ; }	method to extract the message from the stego data.
public static string make related session id ( string encrypted id , id prototype ) throws session exception { prototype . parse session string ( ) ; return make session id ( encrypted id , prototype . get extension ( ) , prototype . tail ) ; }	generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id.
public static general path cardinal spline ( float pts [ ] , int start , int npoints , float slack , boolean closed ) { general path path = new general path ( ) ; path . move to ( pts [ start ] , pts [ start + num ] ) ; return cardinal spline ( path , pts , start , npoints , slack , closed , num , num ) ; }	compute a cardinal spline , a series of cubic bezier splines smoothly connecting a set of points.
public boolean matches ( string seq ) { return queue . region matches ( bool , pos , seq , num , seq . length ( ) ) ; }	tests if the next characters on the queue match the sequence.
public static int compare ( comparable c1 , comparable c2 , boolean null greater ) { if ( c1 == c2 ) { return num ; } else if ( c1 == null ) { return ( null greater ? num : - num ) ; } else if ( c2 == null ) { return ( null greater ? - num : num ) ; } return c1 . compare to ( c2 ) ; }	null safe comparison of comparables .
public boolean check root by super user apk ( ) { file su apk = new file ( su apk ) ; if ( su apk != null && su apk . exists ( ) ) { return bool ; } return bool ; }	returns true if the device contains superuser.
int add expression ( expression expression ) ;	adds a new expression to the database .
public static < e > e sync rest ( final iterator < ? extends object > iterator , final callable < e > task ) throws exception { if ( iterator . has next ( ) ) { synchronized ( iterator . next ( ) ) { return sync rest ( iterator , task ) ; } } else { return task . call ( ) ; } }	recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .
private static component find by name ( container root , string component name ) { if ( verbose ) { log ( str + root + str + component name + str ) ; } int count = root . get component count ( ) ; for ( int iter = num ; iter < count ; iter ++ ) { component c = root . get component at ( iter ) ; string n = c . get name ( ) ; if ( n != null && n . equals ( component name ) ) { return c ; } if ( c instanceof container ) { c = find by name ( ( container ) c , component name ) ; if ( c != null ) { return c ; } } } return null ; }	finds a component with the given name , works even with ui ' s that weren ' t created with the gui builder.
public boolean is fingerprint ( class template class template ) { return fingerprint class . equals ( class template . get implementing class ( ) ) ; }	tests if a template contains methods with signatures that are required by the filter object.
public void write field ( final string name , final float value ) throws java . io . io { write field ( name , float . to string ( value ) ) ; }	writes an float field value .
private list extract column keys ( string line ) { list keys = new java . util . array list ( ) ; int field index = num ; int start = num ; for ( int i = num ; i < line . length ( ) ; i ++ ) { if ( line . char at ( i ) == this . field delimiter ) { if ( field index > num ) { string key = line . substring ( start , i ) ; keys . add ( remove string delimiters ( key ) ) ; } start = i + num ; field index ++ ; } } string key = line . substring ( start , line . length ( ) ) ; keys . add ( remove string delimiters ( key ) ) ; return keys ; }	extracts the column keys from a string .
protected void draw rhombus ( int x , int y , int w , int h , color fill color , paint fill paint , color pen color , boolean shadow ) { int half width = w / num ; int half height = h / num ; polygon rhombus = new polygon ( ) ; rhombus . add point ( x + half width , y ) ; rhombus . add point ( x + w , y + half height ) ; rhombus . add point ( x + half width , y + h ) ; rhombus . add point ( x , y + half height ) ; draw polygon ( rhombus , fill color , fill paint , pen color , shadow ) ; }	draws a rhombus ( aka.
private void convert and fill byte buffer list to byte array list ( list < byte [ ] > dictionary values , list < byte buffer > dictionary value buffer list ) { for ( byte buffer buffer : dictionary value buffer list ) { int length = buffer . limit ( ) ; byte [ ] value = new byte [ length ] ; buffer . get ( value , num , value . length ) ; dictionary values . add ( value ) ; } }	this method will convert and fill list of byte buffer to list of byte array.
static object instantiate ( class < ? > sibling , string class name ) throws instantiation exception , illegal access exception , class not found exception { class loader cl = sibling . get class loader ( ) ; class < ? > cls = class finder . find class ( class name , cl ) ; return cls . new instance ( ) ; }	try to create an instance of a named class.
private byte [ ] generate derived key ( int bytes needed ) { byte [ ] buf = new byte [ digest . get digest size ( ) ] ; byte [ ] key = new byte [ bytes needed ] ; int offset = num ; for ( ; ; ) { digest . update ( password , num , password . length ) ; digest . update ( salt , num , salt . length ) ; digest . do final ( buf , num ) ; int len = ( bytes needed > buf . length ) ? buf . length : bytes needed ; system . arraycopy ( buf , num , key , offset , len ) ; offset += len ; bytes needed -= len ; if ( bytes needed == num ) { break ; } digest . reset ( ) ; digest . update ( buf , num , buf . length ) ; } return key ; }	the derived key function , the ith hash of the password and the salt .
public void test system run finalization returns even if queue is non empty ( ) throws exception { atomic integer count = new atomic integer ( ) ; atomic boolean keep going = new atomic boolean ( bool ) ; create chained finalizer ( count , keep going ) ; while ( count . get ( ) == num ) { thread . sleep ( num ) ; finalization tester . induce finalization ( ) ; } keep going . set ( bool ) ; assert true ( count . get ( ) > num ) ; }	make sure that system.
public synchronized void show ( bundle options ) { if ( debug ) log . d ( tag , str + m keyguard view ) ; boolean enable screen rotation = should enable screen rotation ( ) ; maybe create keyguard locked ( enable screen rotation , bool , options ) ; maybe enable screen rotation ( enable screen rotation ) ; final int vis flags = view . status bar disable home ; if ( debug ) log . v ( tag , str + integer . to hex string ( vis flags ) + str ) ; m keyguard host . set system ui visibility ( vis flags ) ; m view manager . update view layout ( m keyguard host , m window layout params ) ; m keyguard host . set visibility ( view . visible ) ; m keyguard view . show ( ) ; m keyguard view . request focus ( ) ; }	show the keyguard . will handle creating and attaching to the view manager lazily .
public static int compute string width ( font metrics fm , string str ) { return swing utilities2 . string width ( null , fm , str ) ; }	compute the width of the string using a font with the specified " metrics " ( sizes ) .
private boolean passes sanity check ( accessibility event event ) { final char sequence after text = get event text ( event ) ; final char sequence before text = event . get before text ( ) ; if ( ( event . get added count ( ) == num ) && ( event . get removed count ( ) == before text . length ( ) ) ) { return bool ; } if ( after text == null || before text == null ) { return bool ; } final int diff = ( event . get added count ( ) - event . get removed count ( ) ) ; return ( ( before text . length ( ) + diff ) == after text . length ( ) ) ; }	checks whether the event ' s reported properties match its actual properties , e.
public void action performed ( action event ae ) { string command = ae . get action command ( ) ; if ( command == display palette cmd ) { if ( debug . debugging ( str ) ) { debug . output ( get name ( ) + str ) ; } show palette ( ) ; } else if ( command == hide palette cmd ) { if ( debug . debugging ( str ) ) { debug . output ( get name ( ) + str ) ; } hide palette ( ) ; } else if ( command == display properties cmd ) { inspector inspector = new inspector ( ) ; inspector . inspect property consumer ( this ) ; } }	the default actionperformed method for layer.
public static string to string ( local date data ) { return data == null ? str : data . format ( formatter ( str ) ) ; }	converte localdatetime para string no formato dd / mm / yyyy.
@ json creator public data source metadata ( @ json property ( str ) string name , @ json property ( str ) map < string , string > properties , @ json property ( str ) list < data segment > segments ) { this . name = name ; this . properties = collections . unmodifiable map ( properties ) ; this . segments = collections . unmodifiable list ( segments ) ; }	store the full metadata for a druid data source , mainly as a list of segments .
public e create e ( string value ) { email field email impl = new email field ( ) ; try { email impl . set value ( value ) ; } catch ( sdp exception s ) { s . print stack trace ( ) ; } return email impl ; }	returns email object with the specified value .
public address lookup ( string server url , string serial no , string password ) { this . server url = server url . trim ( ) ; this . client id = serial no . trim ( ) ; this . access code = password . trim ( ) ; }	creates a new instance of addresslookup .
public void add change listener ( change listener l ) { m . add ( l ) ; }	adds a changelistener to the panel.
public node ( string permission , boolean value , boolean override , long expire at , string server , string world , context set contexts ) { if ( permission == null || permission . equals ( str ) ) { throw new illegal argument exception ( str ) ; } if ( server != null && ( server . equals ignore case ( str ) || server . equals ( str ) ) ) { server = null ; } if ( world != null && world . equals ( str ) ) { world = null ; } if ( world != null && server == null ) { server = str ; } this . permission = permission ; this . value = value ; this . override = override ; this . expire at = expire at ; this . server = server ; this . world = world ; this . contexts = contexts == null ? context set . empty ( ) : contexts . make immutable ( ) ; }	make an immutable node instance.
public cell ( int rowspan , int colspan ) { this . rowspan = math . max ( rowspan , num ) ; this . colspan = math . max ( colspan , num ) ; }	creates a cell which takes a custom amount of cell spaces in the table .
@ override public void open element ( string tag name ) { xml new element = new xml ( ) ; new element . set name ( tag name ) ; current . add child ( new element ) ; stack . push ( current ) ; current = new element ; }	puts a new element into the dom document.
public format ( string p format string ) { string format vars [ ] = p format string . split ( str ) ; m id = integer . parse int ( format vars [ num ] ) ; }	construct this object from one of the strings in the " fmt_list " parameter.
public boolean equals ( object interval ) { if ( intervals == null ) { return bool ; } return intervals . contains ( interval ) ; }	determine the matching test.
public static string relative to absolute ( string base url , string relative url ) { if ( relative url . starts with ( str ) ) { return get url ( base url ) + str + get url ( base url ) + relative url ; } else { return get url ( base url ) + str + get url ( base url ) + get url ( base url ) + relative url ; } }	converts a relative url e.
public void start ( ) { if ( set state ( enum set . of ( task state . initial , task state . queued ) , task state . running ) ) { dht . log debug ( str + to string ( ) ) ; start time = system . current time millis ( ) ; try { serialized update . run ( ) ; } catch ( exception e ) { dht . log ( e , log level . error ) ; } } }	start the task , to be used when a task is queued .
public journal index ( final i store , final checkpoint checkpoint , final index metadata metadata , final boolean read only ) { super ( store , checkpoint , metadata , read only ) ; }	load from the store .
private void close file ( ) { if ( plog stream != null ) { try { plog stream . close ( ) ; logger . info ( str + plog filename + str ) ; } catch ( io e ) { logger . warn ( str + plog filename ) ; } finally { plog stream = null ; } } }	close plog file . this operation is idempotent to allow convenient cleanup at thread exit .
private void parse first consonant ( ) { iterator iter = al first consonants . iterator ( ) ; while ( iter . has next ( ) ) { string str first con = ( string ) iter . next ( ) ; if ( str syllable . starts with ( str first con , i cur pos ) ) { str first consonant = str first con ; i cur pos += str first con . length ( ) ; return ; } } str first consonant = zero ; }	parses the first consonant .
private buddy panel controller ( ) { buddy panel = new j ( ) ; buddy panel . set layout ( new s ( s . vertical ) ) ; model = new buddy list model ( ) ; j < buddy > list = new buddy panel ( model ) ; buddy panel . add ( list , s . expand x ) ; }	creates a new buddypanelcontroller .
public static test result exec javac ( string to compile , file dir , string jflex test version ) { project p = new project ( ) ; javac javac = new javac ( ) ; path path = new path ( p , dir . to string ( ) ) ; javac . set project ( p ) ; javac . set srcdir ( path ) ; javac . set destdir ( dir ) ; javac . set target ( java version ) ; javac . set source ( java version ) ; javac . set sourcepath ( new path ( p , str ) ) ; javac . set includes ( to compile ) ; path class path = javac . create classpath ( ) ; class path . set path ( system . get property ( str ) + str + jflex test version + str + jflex test version + str ) ; byte array output stream out = new byte array output stream ( ) ; print stream out safe = system . err ; system . set err ( new print stream ( out ) ) ; try { javac . execute ( ) ; return new test result ( out . to string ( ) , bool ) ; } catch ( build exception e ) { return new test result ( e + system . get property ( str ) + out . to string ( ) , bool ) ; } finally { system . set err ( out safe ) ; } }	call javac on tocompile in input dir.
private final boolean park and check interrupt ( ) { lock support . park ( this ) ; return thread . interrupted ( ) ; }	convenience method to park and then check if interrupted.
public static cl [ ] list gpu ( ) { cl [ ] platforms = list platforms ( ) ; list < cl > out = new array list < cl > ( platforms . length ) ; for ( cl platform : platforms ) { if ( platform . list gpu ( bool ) . length > num ) out . add ( platform ) ; } return out . to array ( new cl [ out . size ( ) ] ) ; }	list the opencl implementations that contain at least one gpu device .
public action request helper depends on ( action request helper dependency ) { m dependencies . add ( dependency ) ; return this ; }	this request will execute after the dependency completes .
static boolean is date ( object obj ) { return obj instanceof date && obj . get class ( ) == date . class ; }	check whether this object is a date .
public static string to xml ( final config to convert , boolean pretty xml ) throws jaxb , io { string ret val = str ; try ( string writer writer = new string writer ( ) ) { to xml ( to convert , writer , pretty xml ) ; ret val = writer . to string ( ) ; return ret val ; } }	converts config to xml ,.
private static list < d > build quadrilateral ( final d ... points ) { list < d > quadrilateral = new array list < d > ( ) ; for ( d p : points ) { if ( ! quadrilateral . contains ( p ) ) { quadrilateral . add ( p ) ; } } return quadrilateral ; }	build the convex quadrilateral with the found corner points ( with min / max x / y coordinates ) .
private void heapify up ( int twopos , comparable < object > cur ) { while ( twopos > num ) { final int parent = ( twopos - num ) > > > num ; comparable < object > par = twoheap [ parent ] ; if ( cur . compare to ( par ) <= num ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }	heapify - up method for 2 - ary heap .
public void insert ( string key , char val ) { int len = key . length ( ) + num ; if ( freenode + len > eq . length ) { redim node arrays ( eq . length + block size ) ; } char strkey [ ] = new char [ len -- ] ; key . get chars ( num , len , strkey , num ) ; strkey [ len ] = num ; root = insert ( root , strkey , num , val ) ; }	branches are initially compressed , needing one node per key plus the size of the string key.
void fully unlock ( ) { take lock . unlock ( ) ; put lock . unlock ( ) ; }	unlock to allow both puts and takes .
private static boolean is sub format ( string filename ) { for ( string ext : sub extensions ) { if ( filename . contains ( str + ext ) ) { return bool ; } } return bool ; }	test if file is subtitle format.
void write ( environment env , data output stream out , constant pool tab ) throws io { out . write byte ( constant nameandtype ) ; out . write short ( tab . index ( name ) ) ; out . write short ( tab . index ( type ) ) ; }	write the constant to the output stream.
public static void initialize properties ( properties properties , boolean reset , boolean with defaults ) { properties default prop = null ; if ( with defaults ) { sso app token = access controller . do privileged ( admin token action . get instance ( ) ) ; default prop = server configuration . get defaults ( app token ) ; } properties holder old props ; properties holder new props ; do { old props = properties holder ref . get ( ) ; final properties combined = new properties ( ) ; if ( default prop != null ) { combined . put all ( default prop ) ; } if ( ! reset ) { combined . put all ( old props . properties ) ; } combined . put all ( properties ) ; new props = new properties holder ( maps . from properties ( combined ) ) ; } while ( ! properties holder ref . compare and set ( old props , new props ) ) ; }	initializes the properties to be used by openam.
public void add network listener ( final network listener listener ) { network listeners . add ( listener ) ; }	register a network listener .
public static void append content prefix ( http servlet request request , appendable url buffer ) throws io { append content prefix ( request , url buffer , null ) ; }	appends content prefix to buffer.
public void add error listener ( final error listener error listener ) { if ( error listeners == null ) { error listeners = new array list < error listener > ( ) ; } error listeners . add ( error listener ) ; }	add an error listener .
private void validate class name ( string class name ) { string nvalue = class name . trim ( ) ; if ( ! nvalue . matches ( class re ) ) { throw property exception . illegal property value exception ( this , class name ) ; } }	do some basic checks to make sure the string representation is valid .
public static void import base types ( final c connection , final int raw module id , final int module id ) throws sql { final string query = str + c . base types table + str + module id + str + str + string . format ( c . raw base types , raw module id ) ; connection . execute update ( query , bool ) ; final string update sequence = string . format ( str + str , c . base types table , c . base types table ) ; connection . execute query ( update sequence , bool ) ; }	imports the base types .
@ suppress warnings ( str ) public object read matrix old ( element node ) throws exception { weka . core . matrix matrix ; weka . core . matrix . matrix matrix new ; if ( debug ) { trace ( new throwable ( ) , node . get attribute ( att name ) ) ; } m = node ; matrix new = ( weka . core . matrix . matrix ) read matrix ( node ) ; matrix = new weka . core . matrix ( matrix new . get array copy ( ) ) ; return matrix ; }	builds the matrix ( old ) from the given dom node .
public void record file system operation ( db client db client , operation type enum op type , operation . status status , object ... ext param ) { try { boolean op status = ( operation . status . ready == status ) ? bool : bool ; string ev type ; ev type = op type . get ev type ( op status ) ; string ev desc = op type . get description ( ) ; string op stage = audit log manager . auditop end ; logger . info ( str , op type . to string ( ) , ev type . to string ( ) + str + ev desc ) ; uri uri = ( uri ) ext param [ num ] ; record bourne file system event ( db client , ev type , status , ev desc , uri ) ; audit file ( db client , op type , op status , op stage , uri . to string ( ) ) ; } catch ( exception e ) { logger . error ( str , op type . to string ( ) , e ) ; } }	record filesystem related event and audit.
public core token exception ( int error code ) { this . error code = error code ; this . message = get localized message ( locale . get default ( ) ) ; }	creates a core token service exception .
public d ( j parent , kse frame kse frame ) { super ( parent , res . get string ( str ) , dialog . modality type . document modal ) ; this . kse frame = kse frame ; init components ( ) ; }	creates new dexaminessl dialog .
private static list < string > compute dynamic vm ( i java project ) { array list < string > out = new array list < string > ( ) ; string dev jar path = maybe get dev jar path ( java project ) ; if ( dev jar path . length ( ) > num ) { out . add ( str + dev jar path + str ) ; } return out ; }	dynamic vm args common to both computejunitdynamicvmargsaslist and computecompiledynamicvmargsaslist .
static void normalize ( string builder number ) { string normalized number = normalize ( number . to string ( ) ) ; number . replace ( num , number . length ( ) , normalized number ) ; }	normalizes a string of characters representing a phone number.
public double [ ] skip to ( final int index ) throws math illegal argument exception { if ( index == num ) { arrays . fill ( x , num ) ; } else { final int i = index - num ; final long gray code = i ^ ( i > > num ) ; for ( int j = num ; j < dimension ; j ++ ) { long result = num ; for ( int k = num ; k <= bits ; k ++ ) { final long shift = gray code > > ( k - num ) ; if ( shift == num ) { break ; } final long ik = shift & num ; result ^= ik * direction [ j ] [ k ] ; } x [ j ] = result ; } } count = index ; return next vector ( ) ; }	skip to the i - th point in the sobol sequence.
public void remove organization configuration ( string org name , string group name , boolean check legacy mode ) throws sms , sso { if ( ( group name == null ) || group name . length ( ) == num ) { group name = sms . default ; } string orgdn = dn . org name to dn ( org name ) ; validate scm ( ) ; string odn = scm . construct service config dn ( group name , create service config . org config node , orgdn ) ; sms c entry = sms . get instance ( token , odn ) ; if ( c entry . is new entry ( ) ) { return ; } if ( check legacy mode && service manager . is coexistence mode ( ) && group name . equals ignore case ( sms . default ) ) { amsdk amsdk = new amsdk ( token , dn . realm name to amsdk ( orgdn ) , orgdn ) ; amsdk . unassign service ( service name ) ; } if ( ! c entry . is new entry ( ) ) { sms entry = c entry . get cloned sms ( ) ; entry . delete ( token ) ; c entry . refresh ( entry ) ; } }	deletes the organization ' s group configuration data .
public void remove group listener ( final group listener listener ) { group listeners . remove ( listener ) ; }	remove a group listener .
public set changelog mapping ( string source , string task name , int changelog partition number ) { super ( source ) ; set type ( type ) ; set key ( task name ) ; put message value ( changelog value key , string . value of ( changelog partition number ) ) ; }	the change log mapping message is used to store changelog partition information for a given task name .
@ override protected string extract key ( final string name ) { final string key = unescape ( name . substring ( num , name . length ( ) - num ) ) ; return key . equals ( str ) ? null : key ; }	given a filename , the unescape method returns the key which originated it .
private static float spacing ( motion event event ) { float x = event . get x ( num ) - event . get x ( num ) ; float y = event . get y ( num ) - event . get y ( num ) ; return ( float ) math . sqrt ( x * x + y * y ) ; }	returns the distance between two pointer touch points.
@ suppress warnings ( str ) public static < k , v > void transform string map ( map < string , string > original , map < k , v > map , class < k > key class , class < v > value class ) throws preference exception { method parse key method = find parse method ( key class ) ; method parse value method = find parse method ( value class ) ; if ( ( null != parse key method ) && ( null != parse value method ) ) { for ( map . entry < string , string > to transform entry : original . entry set ( ) ) { try { object transformed key = parse key method . invoke ( null , to transform entry . get key ( ) ) ; object transformed value = parse value method . invoke ( null , to transform entry . get value ( ) ) ; if ( key class . is assignable from ( transformed key . get class ( ) ) && value class . is assignable from ( transformed value . get class ( ) ) ) { map . put ( ( k ) transformed key , ( v ) transformed value ) ; } } catch ( exception e ) { throw new preference exception ( str + key class . get name ( ) + str + value class . get name ( ) + str , e ) ; } } } else if ( null == parse key method ) { throw new preference exception ( str + key class . get name ( ) + str + value class . get name ( ) + str + str + key class . get name ( ) + str ) ; } else { throw new preference exception ( str + key class . get name ( ) + str + value class . get name ( ) + str + str + value class . get name ( ) + str ) ; } }	transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .
public component manager ( collection < sequence > general seeds ) { set < sequence > seed set = new linked hash set < > ( general seeds . size ( ) ) ; seed set . add all ( general seeds ) ; this . gral seeds = collections . unmodifiable set ( seed set ) ; gral components = new sequence collection ( seed set ) ; }	create a component manager , initially populated with the given sequences , which are considered seed sequences .
public synchronized void delete observers ( ) { observers . clear ( ) ; }	removes all observers from the list of observers .
public static byte [ ] unsynchronize ( byte [ ] aby source ) { byte array input stream input = new byte array input stream ( aby source ) ; byte array output stream output = new byte array output stream ( aby source . length ) ; int count = num ; while ( input . available ( ) > num ) { int first byte = input . read ( ) ; count ++ ; output . write ( first byte ) ; if ( ( first byte & mpeg . sync byt ) == mpeg . sync byt ) { if ( input . available ( ) > num ) { input . mark ( num ) ; int second byte = input . read ( ) ; if ( ( second byte & mpeg . sync byt ) == mpeg . sync byt ) { if ( logger . is loggable ( level . finest ) ) { logger . finest ( str + count ) ; } output . write ( num ) ; } else if ( second byte == num ) { if ( logger . is loggable ( level . finest ) ) { logger . finest ( str + count ) ; } output . write ( num ) ; } input . reset ( ) ; } } } if ( ( aby source [ aby source . length - num ] & mpeg . sync byt ) == mpeg . sync byt ) { logger . finest ( str ) ; output . write ( num ) ; } return output . to byte array ( ) ; }	unsynchronize an array of bytes , this should only be called if the decision has already been made to unsynchronize the byte array in order to prevent a media player from incorrectly interpreting the contents of a tag , all $ ff bytes followed by a byte with value > = 224 must be followed by a $ 00 byte ( thus , $ ff $ f0 sequences become $ ff $ 00 $ f0 ) . additionally because unsynchronisation is being applied any existing $ ff $ 00 have to be converted to $ ff $ 00 $ 00.
private byte [ ] calculate general encryption key ( byte [ ] user password , byte [ ] first doc id value , int key bit length , int revision , byte [ ] o value , int p value , boolean encrypt metadata ) throws general security exception { final byte [ ] padded password = pad password ( user password ) ; message digest md5 = create m ( ) ; md5 . reset ( ) ; md5 . update ( padded password ) ; md5 . update ( o value ) ; md5 . update ( ( byte ) ( p value & num ) ) ; md5 . update ( ( byte ) ( ( p value > > num ) & num ) ) ; md5 . update ( ( byte ) ( ( p value > > num ) & num ) ) ; md5 . update ( ( byte ) ( p value > > num ) ) ; if ( first doc id value != null ) { md5 . update ( first doc id value ) ; } if ( revision >= num && ! encrypt metadata ) { for ( int i = num ; i < num ; ++ i ) { md5 . update ( ( byte ) num ) ; } } byte [ ] hash = md5 . digest ( ) ; final int key len = revision == num ? num : ( key bit length / num ) ; final byte [ ] key = new byte [ key len ] ; if ( revision >= num ) { for ( int i = num ; i < num ; ++ i ) { md5 . update ( hash , num , key . length ) ; digest to ( md5 , hash ) ; } } system . arraycopy ( hash , num , key , num , key . length ) ; return key ; }	determine what the general encryption key is , given a configuration.
public message capture ( final logger logger , final boolean capture entity ) { this ( logger , capture entity , bool ) ; }	builds a new messagecapture .
public static final byte [ ] unzip ( byte [ ] in ) throws io { byte array output stream out stream = new byte array output stream ( expected compression ratio * in . length ) ; gzip in stream = new gzip ( new byte array input stream ( in ) ) ; byte [ ] buf = new byte [ buf size ] ; while ( bool ) { int size = in stream . read ( buf ) ; if ( size <= num ) break ; out stream . write ( buf , num , size ) ; } out stream . close ( ) ; return out stream . to byte array ( ) ; }	returns an gunzipped copy of the input array .
public static void insert into combo ( j combo , object item ) { mutable combo box model model = ( mutable combo box model ) combo . get model ( ) ; if ( model . get size ( ) == num ) { model . insert element at ( item , num ) ; return ; } object o = model . get element at ( num ) ; if ( o . equals ( item ) ) { return ; } model . remove element ( item ) ; model . insert element at ( item , num ) ; combo . set selected index ( num ) ; }	insert the given item into the combo box , and set it as first selected item.
public synchronized object co entry pause ( int this coroutine ) throws java . lang . no such method exception { if ( ! m active i . get ( this coroutine ) ) throw new java . lang . no such method exception ( ) ; while ( m next coroutine != this coroutine ) { try { wait ( ) ; } catch ( java . lang . interrupted exception e ) { } } return m yield ; }	in the standard coroutine architecture , coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them ; its ' s presumed that this recognizes the not - already - running case and does the right thing.
private boolean python error in ( string output ) { boolean is error = bool ; string [ ] output multiline = output . split ( str ) ; matcher error matcher ; for ( string row : output multiline ) { error matcher = error in last line . matcher ( row ) ; if ( error matcher . find ( ) == bool ) { is error = bool ; break ; } } return is error ; }	checks if there is a syntax error or an exception.
public static string number to string ( number number ) throws json { if ( number == null ) { throw new json ( str ) ; } double double value = number . double value ( ) ; json . check double ( double value ) ; if ( number . equals ( negative zero ) ) { return str ; } long long value = number . long value ( ) ; if ( double value == ( double ) long value ) { return long . to string ( long value ) ; } return number . to string ( ) ; }	encodes the number as a json string .
public static map < string , string > str to map ( string str , string delim , boolean trim , string pairs separator ) { if ( str == null ) return null ; map < string , string > decoded map = new hash map < string , string > ( ) ; list < string > elements = split ( str , delim ) ; pairs separator = pairs separator == null ? str : pairs separator ; for ( string s : elements ) { list < string > e = split ( s , pairs separator ) ; if ( e . size ( ) != num ) { continue ; } string name = e . get ( num ) ; string value = e . get ( num ) ; if ( trim ) { if ( name != null ) { name = name . trim ( ) ; } if ( value != null ) { value = value . trim ( ) ; } } try { decoded map . put ( url . decode ( name , str ) , url . decode ( value , str ) ) ; } catch ( unsupported encoding exception e1 ) { debug . log error ( e1 , module ) ; } } return decoded map ; }	creates a map from a name / value pair string.
public set < t > key set ( ) { return collections . unmodifiable set ( map . key set ( ) ) ; }	the item keys contained in the map .
public void on start ( ) { if ( m audio mirror buffer == null ) { m audio mirror buffer = new byte [ num ] ; } if ( m streamer != null ) { m streamer . start ( ) ; } if ( m insecure streamer != null ) { m insecure streamer . start ( ) ; } }	called when the playback service starts.
@ suppress warnings ( str ) public propagation imp ( stack < composite transaction > lineage , boolean serial , long timeout ) { serial = serial ; lineage = ( stack < composite transaction > ) lineage . clone ( ) ; timeout = timeout ; }	construct a new instance .
public native runner ( file eclipsec ) { this . eclipsec = objects . require non null ( eclipsec ) ; }	pass it the location of the launcher file .
private static string indent ( final int height ) { return b . indent ( height ) ; }	returns a string that may be used to indent a dump of the nodes in the tree .
public static calendar reduce calendar ( calendar calendar ) { calendar . set ( calendar . millisecond , num ) ; calendar . set ( calendar . second , num ) ; calendar . set ( calendar . minute , num ) ; calendar . set ( calendar . hour , num ) ; calendar . set ( calendar . hour of day , num ) ; return calendar ; }	sets the supplied calendar object with 0 values for fields lower than days.
public static string surround ( string string , string prefix , string suffix ) { if ( string . starts with ( prefix ) == bool ) { string = prefix + string ; } if ( string . ends with ( suffix ) == bool ) { string += suffix ; } return string ; }	surrounds the string with provided prefix and suffix if such missing from string .
public static coordinate pt not in list ( coordinate [ ] test pts , coordinate [ ] pts ) { for ( int i = num ; i < test pts . length ; i ++ ) { coordinate test pt = test pts [ i ] ; if ( ! is in list ( test pt , pts ) ) return test pt ; } return null ; }	finds a point in a list of points which is not contained in another list of points.
public static string trim or pad ( string str , int length , char pad char ) { string result ; if ( str == null ) { result = str ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( num , length ) ; } while ( result . length ( ) < length ) { result += pad char ; } return result ; }	trims or pads this string , so it has this exact length .
void schedule to timer pool ( ) { if ( session poller pool . is polling enabled ( ) ) { long timeout time = ( session . get latest refresh time ( ) + ( session . get max idle time ( ) * num ) ) * num ; if ( session poller pool . get cache based polling ( ) ) { timeout time = math . min ( ( session . get latest refresh time ( ) + ( session . get max caching time ( ) * num ) ) * num , timeout time ) ; } reschedule if will time out before execution ( timeout time ) ; } else { if ( ( session poller pool . is session cleanup enabled ( ) ) && will expire ( session . get max session time ( ) ) ) { long timeout time = ( session . get latest refresh time ( ) + ( session . get max session time ( ) * num ) ) * num ; reschedule if will time out before execution ( timeout time ) ; } } }	schedule this culler to be run , based on the state of the session .
public cipher parameters decrypt ( byte [ ] in , int key len ) { return decrypt ( in , num , in . length , key len ) ; }	decrypt an encapsulated session key .
private static void log os info ( ) { logger . append log ( str + cfg . get os ( ) ) ; logger . append log ( str + os . get os name ( ) ) ; logger . append log ( str + os . platform ( ) ) ; logger . append log ( str + system . get property ( str ) ) ; logger . append log ( str + host info . available cpus ( ) ) ; logger . append log ( str + host info . get max memory ( ) + str ) ; }	log system informations to the log file this have no effect on the software it ' s here for logging purpose.
private void before value ( ) throws json { if ( stack . is empty ( ) ) { return ; } scope context = peek ( ) ; if ( context == scope . empty array ) { replace top ( scope . nonempty array ) ; newline ( ) ; } else if ( context == scope . nonempty array ) { out . append ( str ) ; newline ( ) ; } else if ( context == scope . dangling key ) { out . append ( indent == null ? str : str ) ; replace top ( scope . nonempty object ) ; } else if ( context != scope . null ) { throw new json ( str ) ; } }	inserts any necessary separators and whitespace before a literal value , inline array , or inline object.
public static byte [ ] hash ( string input ) { if ( ! text utils . is empty ( input ) ) { try { byte [ ] input bytes = input . get bytes ( str ) ; return hash ( input bytes ) ; } catch ( unsupported encoding exception e ) { log . e ( tag , str + input + str + e . get message ( ) , e ) ; } } return null ; }	created sha256 of input.
public static string generate transport zone native guid ( string transport type , string device type , string fabric id ) { return string . format ( str , transport type , device type map . get ( device type ) , fabric id ) ; }	the format of this native guid is transporttype + devicetype + fabricwwn.
public void test add servlet with name and jsp file ( ) throws exception { string xml = webapp test header + str + str ; web xml web xml = web xml io . parse web xml ( new byte array input stream ( xml . get bytes ( str ) ) , get entity resolver ( ) ) ; web xml utils . add jsp file ( web xml , str , str ) ; assert true ( web xml utils . has servlet ( web xml , str ) ) ; }	tests whether a single servlet can be added using the method that takes a string for the servlet name and a string for the jsp file .
@ override public boolean equals value ( final object other ) { return objects . equals ( this . value , other ) ; }	indicates whether some other object is " equal to " the value.
public static void error ( string msg , throwable t ) { debug inst . debug ( i . error , msg , t ) ; }	error level debug message.
public void remove event listener ( sip old listener ) { event listeners . remove ( old listener ) ; }	removed an event listener from this transaction .
public static execution system new execution system ( uri uri , map < string , ? > env ) throws io { return new execution system ( uri , env , null ) ; }	creates a new execution system for the specified uri.
public static boolean is command ( i type ) { return type == sqf . command token || type == sqf . command || type == sqf . case || type == sqf . case command ; }	return true if the given type refers to a command , false otherwise.
public void send ( x report ) { outgoing . offer ( report ) ; }	enqueues the provided report to be sent by the reporting thread.
@ contract ( pure = bool ) public static boolean starts with concatenation ( @ not null string string , @ not null string ... prefixes ) { int offset = num ; for ( string prefix : prefixes ) { int prefix len = prefix . length ( ) ; if ( ! string . region matches ( offset , prefix , num , prefix len ) ) { return bool ; } offset += prefix len ; } return bool ; }	equivalent to string . startswith ( prefixes [ 0 ] + prefixes [ 1 ] + . . . ) but avoids creating an object for concatenation .
public void test ordered by datatype ( ) throws exception { int last type = integer . min value ; while ( type info rs . next ( ) ) { string name = type info rs . get string ( str ) ; int type = type info rs . get int ( str ) ; assert true ( str + type + str + name + str + last type , type >= last type ) ; last type = type ; } }	check types ordered by data type .
public boolean fire map mouse clicked ( mouse event evt ) { if ( debug ) { logger . fine ( str ) ; } click happened = bool ; boolean consumed = bool ; evt = new map mouse event ( get parent mode ( ) , evt ) ; if ( priority listener != null && evt . get click count ( ) > num ) { priority listener . mouse clicked ( evt ) ; consumed = bool ; } priority listener = null ; if ( proxy == null || evt . is shift down ( ) || ( proxy distribution mask & proxy distrib mouse clicked ) > num ) { iterator < map mouse listener > it = iterator ( ) ; while ( it . has next ( ) && ! consumed ) { map mouse listener target = it . next ( ) ; consumed = target . mouse clicked ( evt ) && consume events ; if ( consumed ) { priority listener = target ; } } } boolean ignore consumed = ! consumed || ( consumed && ( ( proxy distribution mask & proxy ack consumed mouse clicked ) == num ) ) ; if ( proxy != null && ignore consumed && ! evt . is shift down ( ) ) { proxy . mouse clicked ( evt ) ; consumed = bool ; } return consumed ; }	handle a mouseclicked mouselistener event.
public static string format sql values ( string ... values ) { string builder builder = new string builder ( str ) ; for ( int i = num ; i < values . length ; i ++ ) { if ( i > num ) { builder . append ( str ) ; } builder . append ( str ) ; builder . append ( escape sql string ( values [ i ] ) ) ; builder . append ( str ) ; } builder . append ( str ) ; return builder . to string ( ) ; }	formats an array of values as a sql values like ( ' value1 ' , ' value2 ' ,.
protected void paint content border top edge ( graphics g , int x , int y , int w , int h , boolean draw broken , rectangle sel rect , boolean is content border painted ) { if ( is content border painted ) { g . set color ( select highlight ) ; g . fill rect ( x , y , w - num , num ) ; } }	draws the top edge of the border around the content area.
public void analyze all it and write results ( ) { run results loader run dir = new run results loader ( run directory , null ) ; print stream stream ; try { stream = new print stream ( new file ( output dir + str ) ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; return ; } string header = str ; stream . println ( header ) ; double total tt ; double [ ] avg route t ; int [ ] route users it ; for ( int i = num ; i <= last iteration ; i ++ ) { log . info ( str + i + str + last iteration + str ) ; string events filename = run dir . get events filename ( i ) ; events manager events manager = new events manager impl ( ) ; tt analyze braess handler = new tt analyze braess ( ) ; events manager . add handler ( handler ) ; matsim events reader reader = new matsim events reader ( events manager ) ; reader . read file ( events filename ) ; total tt = handler . get total tt ( ) ; avg route t = handler . calculate avg route t ( ) ; route users it = handler . get route users ( ) ; string buffer line = new string buffer ( ) ; line . append ( i + str + total tt ) ; for ( int j = num ; j < num ; j ++ ) { line . append ( str + route users it [ j ] ) ; } for ( int j = num ; j < num ; j ++ ) { line . append ( str + avg route t [ j ] ) ; } stream . println ( line . to string ( ) ) ; } stream . close ( ) ; log . info ( last iteration + str ) ; }	analyzes all iterations in terms of route choice and travel time.
public int execute update ( string sql ) throws sql { return util . truncate and convert to int ( execute large update ( sql ) ) ; }	execute a sql insert , update or delete statement.
@ layoutlib delegate static long current thread time millis ( ) { return system . current time millis ( ) ; }	returns milliseconds running in the current thread .
public static entry make entry ( list < string > ldif lines ) { return make entry ( ldif lines . to array ( new string [ ldif lines . size ( ) ] ) ) ; }	builds an entry from the provided lines of ldif .
void clear parser highlights ( ) { for ( int i = num ; i < parser highlights . size ( ) ; i ++ ) { object tag = parser highlights . get ( i ) ; if ( tag instanceof layered highlight info ) { layered highlight info lhi = ( layered highlight info ) tag ; if ( lhi . width > num && lhi . height > num ) { text area . repaint ( lhi . x , lhi . y , lhi . width , lhi . height ) ; } } else { highlight info info = ( highlight info ) tag ; ui ui = text area . get ui ( ) ; ui . damage range ( text area , info . get start offset ( ) , info . get end offset ( ) ) ; } } parser highlights . clear ( ) ; }	removes all parser highlights .
@ override public final short read short ( ) throws io { dis . read fully ( work , num , num ) ; return ( short ) ( ( work [ num ] & num ) << num | ( work [ num ] & num ) ) ; }	read short , 16 - bits.
public int format ( int val , byte [ ] buf , int off , int len ) { if ( val == integer . min value ) { if ( len > byte formatter . number base ) { return format ( str , buf , off , len ) ; } else { truncation filler ( buf , off , len ) ; return off + len ; } } int pos = math . abs ( val ) ; int ndig = num ; int dmax = byte formatter . number base ; while ( ndig < byte formatter . number base && pos >= dmax ) { ndig ++ ; dmax *= byte formatter . number base ; } if ( val < num ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncation filler ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - num ; do { buf [ xoff ] = byte formatter . digits [ pos % byte formatter . number base ] ; xoff -- ; pos /= byte formatter . number base ; } while ( pos > num ) ; if ( val < num ) { buf [ xoff ] = ( byte ) str ; } return off ; }	format an int into an existing array .
public void append ( char c [ ] ) { int maxlength = buffer . length - pos ; if ( c . length < maxlength ) { system . arraycopy ( c , num , buffer , pos , c . length ) ; pos += c . length ; } else { system . arraycopy ( c , num , buffer , pos , maxlength ) ; curr . next = new entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > c . length - maxlength ) ? buffer . length : c . length - maxlength ] ; if ( c . length > maxlength ) { system . arraycopy ( c , maxlength , buffer , num , c . length - maxlength ) ; pos = c . length - maxlength ; } else { pos = num ; } } }	method to appennd a charr array to the buffer.
public static boolean has permission ( security security , generic value user login , generic value order header ) { if ( user login == null || order header == null ) return bool ; if ( security . has entity permission ( str , str , user login ) ) { return bool ; } else if ( security . has entity permission ( str , str , user login ) ) { list < generic value > order roles = null ; try { order roles = order header . get related ( str , util misc . to map ( str , user login . get string ( str ) ) , null , bool ) ; } catch ( generic entity exception e ) { debug . log error ( e , str , module ) ; } if ( util validate . is not empty ( order roles ) ) { return bool ; } } return bool ; }	checks to see if this user has read permission on the specified order.
private boolean is annotation ( ) { return impl interfaces . contains ( str ) ; }	sees if the class under test is actually an annotation .
public final boolean is exception handler equivalent ( basic block other ) { if ( exception handlers != other . exception handlers ) { enumeration < basic block > e1 = get exception handlers ( ) ; enumeration < basic block > e2 = other . get exception handlers ( ) ; while ( e1 . has more elements ( ) ) { if ( ! e2 . has more elements ( ) ) return bool ; if ( e1 . next element ( ) != e2 . next element ( ) ) return bool ; } if ( e2 . has more elements ( ) ) return bool ; } return bool ; }	compare the in scope exception handlers of two blocks .
public int checksum ( ) { return calculate checksum ( compile checksum . to string ( ) ) ; }	this value is good for naming the cache file .
public boolean long label ( ) { return f state . long label ; }	returns true if long labels are uses in the indicator display .
public secret block ( mario player , group parent , int stage zone , float x pos , float y pos , float yolo width , image ... hit state ) { super ( block collision data , x pos , y pos , num , num , ( image ) null ) ; this . hit state = hit state [ num ] ; yolo view = new image view ( hit state [ num ] ) ; yolo view . set fit width ( yolo width ) ; this . parent = parent ; zone = stage zone ; }	constructs a single secretblock ( tile which generates one - ups in original game , but " yolo " image in this game ) .
public static boolean install normal ( context context , string file path ) { intent i = new intent ( intent . action view ) ; file file = new file ( file path ) ; if ( ! file . exists ( ) || ! file . is file ( ) || file . length ( ) <= num ) { return bool ; } i . set data and type ( uri . parse ( str + file path ) , str ) ; i . add flags ( intent . flag activity new task ) ; context . start activity ( i ) ; return bool ; }	install package normal by system intent.
private void create insert list ( final i item , list < i > temp list , list < i > insert list , int depth , int removed ) { if ( ! temp list . contains ( item ) ) { temp list . add ( item ) ; if ( depth == num ) { insert list . add ( item ) ; } if ( item . get items ( ) != null ) { depth ++ ; for ( i child : item . get items ( ) ) { create insert list ( child , temp list , insert list , depth , removed ) ; } } } else { insert list . remove ( item ) ; removed ++ ; } }	recursive helper method for createinsertlist.
@ suppress warnings ( str ) public int read outline file metadata ( final pdf object outlines obj , final pdf object reader current pdf file ) { final int count = outlines obj . get int ( pdf dictionary . count ) ; final pdf object first obj = outlines obj . get dictionary ( pdf dictionary . first ) ; current pdf file . check resolved ( first obj ) ; if ( first obj != null ) { final element root = xml . create element ( str ) ; xml . append child ( root ) ; final int level = num ; read outline level ( root , current pdf file , first obj , level , bool ) ; } return count ; }	read the outline data.
private int decode run length ( int k ) { if ( ( k & num ) == num ) { return ( ( k > > > num ) & num ) ^ num ; } else { return integer . number of leading zeros ( k << p + ( num - sp ) ) + num ; } }	more of less the opposite of the encoding function but just for getting out run lengths .
private static byte [ ] stream to bytes ( input stream in , int length ) throws io { byte [ ] bytes = new byte [ length ] ; int count ; int pos = num ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - num ) ) { pos += count ; } if ( pos != length ) { throw new io ( str + length + str + pos + str ) ; } return bytes ; }	reads the contents of an inputstream into a byte [ ] .
public no duplicate value global constraint ( abstract parameter < ? , ? > ... parameters ) { this . parameters = arrays . as list ( parameters ) ; }	constructs a not - equal - value global parameter constraint.
@ suppress warnings ( str ) public rhythm overlay inflate overlay ( string config string ) { list < string > config strings = arrays . as list ( config string . split ( str ) ) ; return inflate overlay internal ( config strings , collections . empty map , num ) ; }	inflate a single overlay from overlay configuration string according to the syntax spec .
public static revocation hash brute force hash ( byte [ ] seed , byte [ ] target , int max child tries , int max sibling tries ) { for ( int i = num ; i < max child tries ; i ++ ) { for ( int j = num ; j < max sibling tries ; j ++ ) { revocation hash test = hash derivation . calculate revocation hash ( seed , num , j ) ; if ( arrays . equals ( test . get secret hash ( ) , target ) ) { return new revocation hash ( i , j , test . get secret ( ) , test . get secret hash ( ) ) ; } } seed = tools . hash secret ( seed ) ; } return null ; }	the other party has breached the contract and submitted an old channel transaction .
public fancy loader ( class loader parent ) { super ( parent ) ; try { m dex class = parent . load class ( str ) ; } catch ( class not found exception cnfe ) { } }	construct fancyloader , grabbing a reference to the dexfile class if we ' re running under dalvik .
public boolean is source modified ( resource resource ) { boolean modified = bool ; string file name = resource . get name ( ) ; string path = ( string ) template paths . get ( file name ) ; file current file = null ; for ( int i = num ; current file == null && i < paths . size ( ) ; i ++ ) { string test path = ( string ) paths . get ( i ) ; file test file = new file ( test path , file name ) ; if ( test file . can read ( ) ) { current file = test file ; } } file file = new file ( path , file name ) ; if ( current file == null || ! file . exists ( ) ) { } else if ( current file . equals ( file ) && file . can read ( ) ) { modified = ( file . last modified ( ) != resource . get last modified ( ) ) ; } return modified ; }	how to keep track of all the modified times across the paths.
protected void flip ( buffer capabilities . flip contents flip action ) { if ( peer != null ) { image back buffer = get back buffer ( ) ; if ( back buffer != null ) { peer . flip ( num , num , back buffer . get width ( null ) , back buffer . get height ( null ) , flip action ) ; } } else { throw new illegal state exception ( str ) ; } }	flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .
protected void load value ( string s value ) { try { value = byte . parse byte ( s value . trim ( ) ) ; } catch ( number format exception nfe ) { revert to default ( ) ; } }	load value from property string value.
public static map < string , string > all namespaces ( soap ele ) { map < string , string > ns list = new tree map < string , string > ( ) ; log . trace ( str + ele . get node name ( ) ) ; all namespaces ( ele , ns list ) ; log . trace ( str + ns list ) ; return ns list ; }	returns a list of all namespaces below an element ( recursive ).
private void draw hook ( canvas canvas ) { path hook path = new path ( ) ; double sweep angle = math . pi / num * num ; float y = ( float ) math . sin ( sweep angle ) * ( get big circle radius ( ) ) + rect f . height ( ) / num ; float x = ( float ) math . cos ( sweep angle ) * ( get big circle radius ( ) ) + rect f . width ( ) / num ; float i = get big circle radius ( ) / num ; hook path . add round rect ( new f ( i + i / num , i + i / num , i + i / num + num , i + i + i / num ) , num , num , path . direction . ccw ) ; hook path . add round rect ( new f ( i + i / num , ( i + i + i / num ) - num , i + i / num + i + i , i + i + i / num + num ) , num , num , path . direction . ccw ) ; matrix matrix = new matrix ( ) ; matrix . reset ( ) ; int restore count = canvas . get save count ( ) ; hook path . close ( ) ; canvas . rotate ( - num , rect f . center x ( ) , rect f . center y ( ) ) ; canvas . draw path ( hook path , m hook paint ) ; canvas . restore to count ( restore count ) ; }	there is some bug and it ' s not perfect . so we should improve this path for our projection.
public static byte [ ] to byte array ( bitmap bitmap , bitmap . compress format format , int quality ) { byte array output stream out = null ; try { out = new byte array output stream ( ) ; bitmap . compress ( format , quality , out ) ; return out . to byte array ( ) ; } finally { closeable utils . close ( out ) ; } }	compress the bitmap to the byte array as the specified format and quality .
public void continue button action performed ( java . awt . event . action event e ) { if ( test running && test suspended ) { test suspended = bool ; if ( wrap test ) { status text1 . set text ( str ) ; status text1 . set visible ( bool ) ; } } }	method to handle continue button in diagnostic frame.
@ hle ( nid = num , version = num ) public int sce net adhoc ptp flush ( @ check argument ( str ) int id , int timeout , int nonblock ) { return num ; }	wait for data in the buffer to be sent.
public void reset ( ) { display cache . clear ( ) ; cached id . clear ( ) ; }	resets the drawer and its caches .
private void copy directory ( file source , file dest ) throws io { for ( file f : source . list files ( ) ) { file source file = new file ( source , f . get name ( ) ) ; file dest file = new file ( dest , f . get name ( ) ) ; if ( f . is directory ( ) ) { dest file . mkdirs ( ) ; copy directory ( source file , dest file ) ; } else copy file ( source file , dest file ) ; } }	copy an entire directory from one location to another.
private synchronized void rebuild journal ( ) throws io { if ( m journal writer != null ) { m journal writer . close ( ) ; } writer writer = new buffered writer ( new file writer ( m journal file tmp ) , io buffer size ) ; writer . write ( magic ) ; writer . write ( str ) ; writer . write ( version 1 ) ; writer . write ( str ) ; writer . write ( integer . to string ( m app version ) ) ; writer . write ( str ) ; writer . write ( str ) ; for ( cache entry cache entry : m lru entries . values ( ) ) { if ( cache entry . is under edit ( ) ) { writer . write ( s action list [ action dirty ] + str + cache entry . get key ( ) + str + cache entry . get size ( ) + str ) ; } else { writer . write ( s action list [ action clean ] + str + cache entry . get key ( ) + str + cache entry . get size ( ) + str ) ; } } writer . close ( ) ; m journal file tmp . rename to ( m journal file ) ; m journal writer = new buffered writer ( new file writer ( m journal file , bool ) , io buffer size ) ; }	creates a new journal that omits redundant information.
private void record log data ( ) { try { int size = m recording data . size ( ) ; if ( size == num ) { return ; } vector < string > recording data = new vector < > ( m recording data ) ; file log dir = constants . get record dir ( this ) ; log dir . mkdirs ( ) ; file log file = new file ( log dir , m recording filename ) ; file writer log file writer = new file writer ( log file , bool ) ; for ( int i = num ; i < size ; i ++ ) { log file writer . append ( recording data . element at ( i ) + str ) ; m recording data . remove element at ( num ) ; } recording data . remove all elements ( ) ; log file writer . close ( ) ; } catch ( exception e ) { log . e ( log tag , str + e . to string ( ) ) ; } }	save log data to file.
private static list < command > load rewrites ( string str ) { assert str != null ; list < command > commands = new array list < > ( ) ; for ( string line : str . split ( str ) ) { add line ( commands , line ) ; } return commands ; }	loads the rewrites from tab - separated values .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public state connection on close read ( ) { connection protocol request = request ( ) ; if ( request != null ) { request . on close read ( ) ; } sequence close . set ( sequence read . get ( ) ) ; if ( sequence flush . get ( ) < sequence close . get ( ) ) { is close pending . set ( bool ) ; if ( sequence flush . get ( ) < sequence close . get ( ) ) { return state connection . close read s ; } else { is close pending . set ( bool ) ; return state connection . close ; } } else { return state connection . close ; } }	called by reader thread on reader end of file .
public void http request ( http request event e ) throws java . io . io { string request = e . get request ( ) ; if ( debug . debugging ( str ) ) { debug . output ( str + request + str ) ; } if ( request . char at ( num ) == str ) { request = request . substring ( num , request . length ( ) ) ; } int index = num ; index = request . index of ( str ) ; if ( index != - num ) { request = request . substring ( index + num , request . length ( ) ) ; debug . message ( str , str ) ; } else { debug . message ( str , str ) ; } try { i server . handle request ( request , e . get output stream ( ) ) ; } catch ( io ioe ) { debug . error ( str + ioe . get message ( ) ) ; } catch ( map request format exception exception ) { string message = str + exception . get message ( ) + str + error message ; http connection . write http response ( e . get output stream ( ) , http connection . content plain , message ) ; } }	invoked when an http request is received .
public void test constructor bytes negative2 ( ) { byte a bytes [ ] = { - num , num , num } ; byte r bytes [ ] = { - num , num , num } ; big integer a number = new big integer ( a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	create a negative number from an array of bytes.
public string format ( double val ) { decimal format df = get double format ( ) ; if ( df != null ) { return df . format ( val ) ; } return double . to string ( val ) ; }	formats the given double values .
public void remove positions ( collection < integer > positions ) { array list < integer > positions list = new array list < integer > ( positions ) ; collections . sort ( positions list ) ; collections . reverse ( positions list ) ; for ( int position : positions list ) { m items . remove ( position ) ; } notify data set changed ( ) ; }	removes all elements at the specified positions in the list.
private void reset shape bounds ( ) { d . double rrect = ( d . double ) shape ; rrect . set round rect ( num , num , get bounds ( ) . width - num , get bounds ( ) . height - num , num , num ) ; }	rests the boundaries of the shape which is drawn as the rubberband.
public static colour attempt to get as colour ( string part ) { colour col = null ; try { col = colour . value of ( part . to upper case ( ) ) ; } catch ( exception e ) { } return col ; }	attempt to parse string as a colour.
public int rank ( ) { double eps = math . pow ( num , - num ) ; double tol = math . max ( m , n ) * s [ num ] * eps ; int r = num ; for ( int i = num ; i < s . length ; i ++ ) { if ( s [ i ] > tol ) { r ++ ; } } return r ; }	effective numerical matrix rank.
public static void execute random modifiable variable modification ( modifiable variable holder object ) { field field = object . get random modifiable variable field ( ) ; execute modifiable variable modification ( object , field ) ; }	picks a random modifiable variable and executes a random modification on this variable .
public static boolean save ( file file , string content ) { boolean result ; buffered writer writer ; writer = null ; try { writer = new buffered writer ( new file writer ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = bool ; } catch ( exception e ) { e . print stack trace ( ) ; result = bool ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( exception e ) { } } } return result ; }	saves the content to a file .
private void delete old temp ( file file cfg ) { buffered reader reader = null ; try { int count = num ; reader = new buffered reader ( new file reader ( file cfg ) ) ; string s line ; while ( ( s line = reader . read line ( ) ) != null ) { file file = new file ( s line ) ; if ( ! file . exists ( ) ) { continue ; } if ( file . delete ( ) ) { count ++ ; } else { hs delete on exit . add ( file ) ; } } log debug ( log area . config , str , count , file cfg . get absolute path ( ) ) ; } catch ( io e ) { } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( io e ) { } } } }	deletes temporary files listed in the file.
public void flush ( ) { final bigdata sail repository connection cxn = tl tx . get ( ) ; if ( cxn != null ) { code . wrap throw ( null ) ; } }	flush the statement buffers to the indices without committing .
@ override public buffered image jpeg rgb ( final byte [ ] data , final int ww , final int hh , final int p x , final int p y ) { buffered image image = null ; raster ras = jpeg . get raster from jpeg ( data , str ) ; if ( ras != null ) { ras = cleanup raster ( ras , p x , p y , component count ) ; final int w = ras . get width ( ) ; final int h = ras . get height ( ) ; final data buffer byte rgb = ( data buffer byte ) ras . get data buffer ( ) ; image = create image ( w , h , rgb . get data ( ) ) ; } return image ; }	convert data stream to srgb image.
public void despawn ( visible object object ) { despawn ( object , bool ) ; }	despawn visibleobject , object will become invisible and object position will become invalid.
public string event topic ( string event id ) { if ( event id == null ) { event id = str ; } return evt topic . replace ( str , event id ) ; }	get the mqtt topic for an device event .
public match result match ( ) { if ( ! match successful ) { throw new illegal state exception ( ) ; } return matcher . to match result ( ) ; }	returns the result of the last matching operation.
@ suppress warnings ( str ) public static void create project constraint ( zip file zip , project a project , repository service a repository ) throws io { for ( enumeration zip enumerate = zip . entries ( ) ; zip enumerate . has more elements ( ) ; ) { zip entry entry = ( zip entry ) zip enumerate . next element ( ) ; string entry name = normalize entry name ( entry ) ; if ( entry name . starts with ( constraints ) ) { string filename = filename utils . get name ( entry . get name ( ) ) ; constraint set constraint set = new constraint set ( ) ; constraint set . set project ( a project ) ; constraint set . set name ( filename ) ; a repository . create constraint set ( constraint set ) ; a repository . write constraint set ( constraint set , zip . get input stream ( entry ) ) ; log . info ( str + filename + str + a project . get name ( ) + str + a project . get id ( ) + str ) ; } } }	copy constraints from the exported project.
public string decode ( string p string ) throws decoder exception { if ( p string == null ) { return null ; } try { return decode ( p string , get default charset ( ) ) ; } catch ( unsupported encoding exception e ) { throw new decoder exception ( e . get message ( ) ) ; } }	decodes a url safe string into its original form using the default string charset.
public operation copy to ( extent target ) { block transform extent extent = new block transform extent ( original , transform , world data . get block registry ( ) ) ; forward extent copy copy = new forward extent copy ( extent , original . get region ( ) , original . get origin ( ) , target , original . get origin ( ) ) ; copy . set transform ( transform ) ; return copy ; }	create an operation to copy from the original clipboard to the given extent .
@ caller sensitive public class < ? > for class ( ) { if ( cl == null ) { return null ; } require initialized ( ) ; if ( system . get security manager ( ) != null ) { class < ? > caller = reflection . get caller class ( ) ; if ( reflect util . needs package access check ( caller . get class loader ( ) , cl . get class loader ( ) ) ) { reflect util . check package access ( cl ) ; } } return cl ; }	return the class in the local vm that this version is mapped to.
private void path style helper ( string style , string offset ) { if ( style == null ) { return ; } if ( style . equals ( str ) ) { stroke paint . set path effect ( null ) ; return ; } string tokenizer st = new string tokenizer ( style , str ) ; int count = st . count tokens ( ) ; float [ ] intervals = new float [ ( count & num ) == num ? count * num : count ] ; float max = num ; float current = num ; int i = num ; while ( st . has more tokens ( ) ) { intervals [ i ++ ] = current = to float ( st . next token ( ) , current ) ; max += current ; } for ( int start = num ; i < intervals . length ; i ++ , start ++ ) { max += intervals [ i ] = intervals [ start ] ; } float off = num ; if ( offset != null ) { try { off = float . parse float ( offset ) % max ; } catch ( number format exception e ) { } } stroke paint . set path effect ( new dash path effect ( intervals , off ) ) ; }	set the path style ( if any ) stroke - dasharray = " n1 , n2 ,.
private float color to angle ( int color ) { float [ ] colors = new float [ num ] ; color . color to hsv ( color , colors ) ; return ( float ) math . to radians ( - colors [ num ] ) ; }	convert a color to an angle .
private size parse old bounded size ( string token , boolean set max ) { int semicolon index = token . index of ( str ) ; string size token1 = token . substring ( num , semicolon index ) ; string size token2 = token . substring ( semicolon index + num , token . length ( ) - num ) ; size size1 = parse atomic size ( size token1 ) ; size size2 = parse atomic size ( size token2 ) ; if ( is constant ( size1 ) ) { if ( size2 instanceof sizes . component size ) { return new bounded size ( size2 , set max ? null : size1 , set max ? size1 : null ) ; } throw new illegal argument exception ( str ) ; } if ( is constant ( size2 ) ) { return new bounded size ( size1 , set max ? null : size2 , set max ? size2 : null ) ; } throw new illegal argument exception ( str ) ; }	parses an encoded compound size and sets the size fields.
builder add encoded query parameter ( string encoded name , string encoded value ) { if ( encoded name == null ) throw new illegal argument exception ( str ) ; if ( encoded query names and values == null ) encoded query names and values = new array list < > ( ) ; encoded query names and values . add ( canonicalize ( encoded name , query component encode set , bool , bool ) ) ; encoded query names and values . add ( encoded value != null ? canonicalize ( encoded value , query component encode set , bool , bool ) : null ) ; return this ; }	adds the pre - encoded query parameter to this url ' s query string .
private static a create image link ( string ad , string name , string js command , boolean enabled , boolean pressed ) { a img = new a ( str , create image ( ad , name ) ) ; if ( ! pressed || ! enabled ) img . set id ( str ) ; else img . set id ( str ) ; if ( js command == null ) js command = str ; if ( js command . length ( ) > num && enabled ) { if ( js command . starts with ( str ) ) img . set on click ( js command ) ; else img . set on click ( str + name + str + js command + str ) ; } img . set class ( str ) ; img . set on mouse over ( str + name + str ) ; img . set on mouse out ( str ) ; img . set on blur ( str ) ; return img ; }	create image with name , id of button_name and set p_command onclick.
public namespace ( principal user creator , string qualifier , principal user owner , set < principal user > users ) { super ( creator ) ; set qualifier ( qualifier ) ; set owner ( owner ) ; if ( users != null && ! users . is empty ( ) ) { set users ( users ) ; } add user ( owner ) ; }	creates a new namespace object .
public final int decrement and get ( ) { return unsafe . get and add int ( this , value offset , - num ) - num ; }	atomically decrements by one the current value .
public void update ( long dt , float ratio y ) { double step = num * math . pi / points per circle ; angle += dt * bubble d angle ; float from x = start x + ( float ) ( num * math . sin ( angle ) ) ; float to x = from x + size ; float from y = this . from y + dt * speed ; float to y = from y + size ; center y += dt * virtual speed ; get color ( ) [ num ] = ( top y - center y / top y ) ; vertex buffer . put ( num , utils . normalize gl ( num , from x , to x ) ) ; vertex buffer . put ( num , utils . normalize gl ( center y * ratio y , from y , to y ) ) ; for ( int i = num ; i <= points per circle ; i ++ ) { vertex buffer . put ( coords per vertex * i , utils . normalize gl ( ( float ) math . sin ( - math . pi + step * i ) , from x , to x ) ) ; vertex buffer . put ( coords per vertex * i + num , utils . normalize gl ( ( float ) math . cos ( - math . pi + step * i ) * ratio y , from y , to y ) ) ; } this . from y = from y ; }	update position of bubble .
public final void clear ( ) { if ( gwt . is script ( ) ) { js array . clear ( ) ; } else { java array . clear ( ) ; } }	remove all elements on this list.
void fully lock ( ) { put lock . lock ( ) ; take lock . lock ( ) ; }	locks to prevent both puts and takes .
@ override public synchronized void clear ( ) { file [ ] files = m root directory . list files ( ) ; if ( files != null ) { for ( file file : files ) { file . delete ( ) ; } } m entries . clear ( ) ; volley log . d ( str ) ; }	clears the cache . deletes all cached files from disk .
private void update podcast publication date and last media url ( episode episode , podcast podcast ) { date podcast publication date = podcast . get publication date ( ) ; boolean episode pub date is more recent = episode . get publication date ( ) != null && ( podcast publication date == null || podcast publication date . before ( episode . get publication date ( ) ) ) ; if ( episode pub date is more recent ) { podcast . set publication date ( episode . get publication date ( ) ) ; podcast . set last episode media url ( episode . get media url ( ) ) ; } }	set the podcast ' s publication date to the episode ' s if it is more recent.
private void remove our u ( ) { for ( string ui name : ui list ) { ui defaults . remove ( ui name + str ) ; } }	use our ui delegate for the specified ui control type .
public void make immutable ( ) { }	makes the object immutable.
public static < o > knn < o > precomputed knn ( database database , relation < o > relation , distance query < o > dq , int k ) { knn < o > knnq = database . get knn ( dq , k , database query . hint heavy use , database query . hint optimized only , database query . hint no cache ) ; if ( knnq instanceof knn ) { return knnq ; } knn < o > preproc = new knn < > ( relation , dq . get distance function ( ) , k ) ; preproc . initialize ( ) ; return preproc . get knn ( dq , k ) ; }	get ( or create ) a precomputed knn query for the database .
public static sorted set < integer > adjust position ( set < integer > positions , int start position , int end position , int adjust by ) { sorted set < integer > new positions = new tree set < > ( ) ; for ( integer entry : positions ) { int position = entry ; if ( position < start position || position > end position ) { new positions . add ( position ) ; } else if ( adjust by > num ) { new positions . add ( position + adjust by ) ; } else if ( adjust by < num ) { if ( position > start position + adjust by && position <= start position ) { ; } else { new positions . add ( position + adjust by ) ; } } } return new positions ; }	internal method to handle the selections if items are added / removed.
private static void add id ( final string builder buf , final byte [ ] id ) { buf . append ( str ) ; boolean backslash = bool ; for ( final byte b : id ) { buf . append ( ( char ) ( b & num ) ) ; if ( b == str && backslash ) { buf . append ( str ) ; } else { backslash = b == str ; } } buf . append ( str ) ; }	appends the given id to the given buffer , followed by " \ \ e ".
private resolved migration create available migration ( int version ) { resolved migration migration = new resolved migration ( ) ; migration . set version ( migration version . from version ( integer . to string ( version ) ) ) ; migration . set description ( str ) ; migration . set script ( str ) ; migration . set type ( migration type . cql ) ; return migration ; }	creates a new available migration with this version .
public void comment ( string data ) throws sax { m doc is empty = bool ; final int length = data . length ( ) ; if ( length > m chars buff . length ) { m chars buff = new char [ length * num + num ] ; } data . get chars ( num , length , m chars buff , num ) ; comment ( m chars buff , num , length ) ; }	receive notification of a comment .
public boolean draw image ( image img , affine transform xform , image observer observer ) { if ( img == null ) { return bool ; } if ( xform == null || xform . is identity ( ) ) { return draw image ( img , num , num , null , observer ) ; } if ( is hi dpi ( img ) ) { final int w = img . get width ( null ) ; final int h = img . get height ( null ) ; final affine transform tx = new affine transform ( transform ) ; transform ( xform ) ; boolean result = draw hi dpi ( img , num , num , w , h , num , num , w , h , null , observer ) ; transform . set transform ( tx ) ; invalidate transform ( ) ; return result ; } try { return imagepipe . transform image ( this , img , xform , observer ) ; } catch ( invalid pipe exception e ) { try { revalidate all ( ) ; return imagepipe . transform image ( this , img , xform , observer ) ; } catch ( invalid pipe exception e2 ) { return bool ; } } finally { surface data . mark dirty ( ) ; } }	draw an image , applying a transform from image space into user space before drawing.
public void begin display ( display event event ) throws model control exception { super . begin display ( event , bool ) ; reset button state ( tbl button delete ) ; agents model model = ( agents model ) get model ( ) ; string agent type = get display id ( ) ; object [ ] param = { agent type } ; pt model . set page title text ( model . get localized string ( str + agent type ) ) ; pt model . set page title help message ( model . get localized string ( str + agent type + str ) ) ; tbl model . set title ( message format . format ( model . get localized string ( str ) , param ) ) ; tbl model . set title label ( message format . format ( model . get localized string ( str ) , param ) ) ; tbl model . set summary ( message format . format ( model . get localized string ( str ) , param ) ) ; tbl group model . set title ( message format . format ( model . get localized string ( str ) , param ) ) ; tbl group model . set title label ( message format . format ( model . get localized string ( str ) , param ) ) ; tbl group model . set summary ( message format . format ( model . get localized string ( str ) , param ) ) ; get agent names ( ) ; cc b = ( cc ) get child ( tbl button delete ) ; b . set disabled ( bool ) ; b = ( cc ) get child ( tbl button delete group ) ; b . set disabled ( bool ) ; }	sets the agent title and populates the agent and agent group action table .
public void select all ( ) { arrays . fill ( sel array , bool ) ; }	selects all item types .
public nvp builder add raw ( final string name , final string value ) { npv . put ( name , value ) ; return this ; }	add raw name value pair .
@ override public int length ( ) { return set . size ( ) ; }	returns the set length.
public final long read unsigned int ( ) throws io { m position += num ; d . read fully ( w , num , num ) ; return ( ( long ) ( w [ num ] ) << num | ( w [ num ] & num ) << num | ( w [ num ] & num ) << num | ( w [ num ] & num ) ) & num ; }	like datainputstream . readint except little endian and for unsigned integers .
public list < ro > view address country options ( final shopping cart cart , final shop shop , final string address type ) { final list < country > countries = address book facade . get all countries ( shop . get code ( ) , address type ) ; return map ( countries , ro . class , country . class ) ; }	common address book function .
public void add pause listener ( animator pause listener listener ) { if ( m pause listeners == null ) { m pause listeners = new array list < animator pause listener > ( ) ; } m pause listeners . add ( listener ) ; }	adds a pause listener to this animator .
@ override public void make immutable ( ) { if ( mutable ) { if ( attrs != null ) { iterator iter = attrs . iterator ( ) ; while ( iter . has next ( ) ) { attribute attr = ( attribute ) iter . next ( ) ; attr . make immutable ( ) ; } attrs = collections . unmodifiable list ( attrs ) ; } if ( enc attrs != null ) { enc attrs = collections . unmodifiable list ( enc attrs ) ; } mutable = bool ; } }	makes the object immutable .
public void add component ( t component ) { components . add ( component ) ; }	adds a component to the composite .
public static ui result open url ( uri uri ) { return open url ( uri . to string ( ) ) ; }	launch url in a new window .
public final void invalidate line ( int line ) { repaint ( num , text area . line to y ( line ) + fm . get max descent ( ) + fm . get leading ( ) , get width ( ) , fm . get height ( ) ) ; }	marks a line as needing a repaint .
public byte banded raster ( sample model sample model , point origin ) { this ( sample model , sample model . create data buffer ( ) , new rectangle ( origin . x , origin . y , sample model . get width ( ) , sample model . get height ( ) ) , origin , null ) ; }	constructs a bytebandedraster with the given samplemodel.
private void initialize ( uri p other ) { m scheme = p other . get scheme ( ) ; m userinfo = p other . get userinfo ( ) ; m host = p other . get host ( ) ; m port = p other . get port ( ) ; m path = p other . get path ( ) ; m query string = p other . get query string ( ) ; m fragment = p other . get fragment ( ) ; }	initialize all fields of this uri from another uri .
private e unlink last ( ) { node < e > l = last ; if ( l == null ) return null ; node < e > p = l . prev ; e item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; not full . signal ( ) ; return item ; }	removes and returns last element , or null if empty .
static boolean is refresh notification registered ( notification listener client , refresh notification type type ) { boolean is registered = bool ; map < refresh notification type , integer > notifications = null ; synchronized ( refresh clients ) { notifications = ( map < refresh notification type , integer > ) refresh clients . get ( client ) ; } if ( notifications != null ) { integer timer notification id = notifications . get ( type ) ; if ( timer notification id != null ) { is registered = bool ; } } return is registered ; }	verifies a refresh notification for the specified client mbean . if notification is not registered , then returns a false.
private collection < string > read process output ( process proc ) throws io { buffered reader rdr = new buffered reader ( new input stream reader ( proc . get input stream ( ) ) ) ; collection < string > res = new array list < > ( ) ; string s ; while ( ( s = rdr . read line ( ) ) != null ) res . add ( s ) ; return res ; }	reads process output line - by - line .
public void fill header and footer ( final http servlet request request , final http servlet response response , final map < string , object > data model ) throws exception { fill header ( request , response , data model ) ; fill footer ( data model ) ; }	fills header and footer .
public void add operand ( i operand ) { if ( operands list == null ) operands list = new array list < i > ( ) ; operands list . add ( operand ) ; }	adds an operand at the end of the current operands list .
public big decimal calculate total collected amt ( final bill receipt info bri , final list < eg bill details > bill det list ) throws invalid account head exception { return bri . get total amount ( ) ; }	called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated.
public void skip ( int count ) throws io { int skip count = math . min ( limit - position , count ) ; while ( bool ) { position += skip count ; count -= skip count ; if ( count == num ) break ; skip count = math . min ( count , capacity ) ; require ( skip count ) ; } }	discards the specified number of bytes .
public void remove all ims ( ) { ims . clear ( ) ; }	removes all im ' s from this user.
static string escape string for ascii ( string s ) { string out = str ; char [ ] c array = s . to char array ( ) ; for ( int i = num ; i < c array . length ; i ++ ) { char c = c array [ i ] ; if ( c > num ) { out += str ; string hex = integer . to hex string ( c ) ; while ( hex . length ( ) < num ) hex = str + hex ; out += hex ; } else if ( c == str ) { out += str ; } else if ( c == str ) { out += str ; } else if ( c == str ) { out += str ; } else if ( c == str ) { out += str ; } else if ( c == str ) { out += str ; } else if ( c == str ) { out += str ; } else { out += c ; } } return out ; }	escapes a string for use in ascii property lists .
public void copy reader ( string encoding , reader r ) throws io { super . set content encoding ( encoding ) ; string s = read string ( r ) ; content = s . get bytes ( encoding ) ; }	set the content by copying characters from the given reader and converting them into bytes using the specified encoding .
private void clear dictionary cache ( ) { map < string , dictionary > dictionary caches = surrogate key gen . get dictionary caches ( ) ; list < dictionary > reverse dictionaries = new array list < > ( dictionary caches . values ( ) ) ; for ( int i = num ; i < reverse dictionaries . size ( ) ; i ++ ) { dictionary dictionary = reverse dictionaries . get ( i ) ; dictionary . clear ( ) ; } }	this method will clear the dictionary access count so that any unused column can be removed from the cache.
public static string to type string ( object [ ] arguments , int max size ) { if ( arguments == null ) { return str ; } string builder arg buf = new string builder ( ) ; for ( int i = num ; i < arguments . length ; i ++ ) { if ( max size != - num && arg buf . length ( ) > max size ) { arg buf . append ( str ) ; break ; } else { if ( i > num ) { arg buf . append ( str ) ; } arg buf . append ( arguments [ i ] != null ? type name ( arguments [ i ] ) : str ) ; } } return arg buf . to string ( ) ; }	a helper method to format the arguments types as a comma - separated list .
public boolean rename file ( file old file , file new file ) { synchronized ( file cache ) { if ( old file . rename to ( new file ) ) { validate file cache ( ) ; return bool ; } return bool ; } }	renames a file in the underlying file system .
public future < ? > execute ( camera command command ) { if ( m closed ) { return futures . immediate future ( null ) ; } synchronized ( m lock ) { if ( m executor == null ) { m executor = m executor provider . get ( ) ; } check not null ( m executor ) ; return m executor . submit ( new command runnable ( command ) ) ; } }	executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .
public static enum set < kind name > kind names ( int kind ) { enum set < kind name > kinds = enum set . none of ( kind name . class ) ; if ( ( kind & val ) != num ) kinds . add ( ( ( kind & val ) == var ) ? kind name . var : kind name . val ) ; if ( ( kind & mth ) != num ) kinds . add ( kind name . method ) ; if ( ( kind & typ ) != num ) kinds . add ( kind name . class ) ; if ( ( kind & pck ) != num ) kinds . add ( kind name . package ) ; return kinds ; }	a set of kindname ( s ) representing a set of symbol ' s kinds .
public int length ( ) { return text . length ( ) ; }	retruns the length of the text.
public static string serialize digest response ( map < string , string > param map ) { string builder sb = new string builder ( str ) ; boolean prefix comma = bool ; for ( map . entry < string , string > entry : param map . entry set ( ) ) { if ( ! prefix comma ) { prefix comma = bool ; } else { sb . append ( str ) ; } sb . append ( entry . get key ( ) ) ; sb . append ( str ) ; sb . append ( entry . get value ( ) ) ; } return sb . to string ( ) ; }	serialize a parameter map into a digest response.
public void populate combos ( activity activity , final listener listener ) { list < string > services = get services ( activity . get package manager ( ) ) ; populate combos ( activity , services , listener ) ; }	collect together the languages supported by the given services and call back once done .
protected json encoding find encoding ( media type media type , multivalued map < string , object > http headers ) { return json encoding . ut ; }	helper method to use for determining desired output encoding.
static buffered image convert image ( buffered image image ) { switch ( image . get type ( ) ) { case buffered image . type int argb pre : return image ; case buffered image . type 4 byte abgr : image . coerce data ( bool ) ; return image ; } buffered image converted image = new buffered image ( image . get width ( ) , image . get height ( ) , buffered image . type int argb pre ) ; d g = converted image . create graphics ( ) ; g . set color ( new java . awt . color ( num , num , num , num ) ) ; g . fill rect ( num , num , image . get width ( ) , image . get height ( ) ) ; g . draw image ( image , num , num , null ) ; g . dispose ( ) ; return converted image ; }	converts the given image into a format for quick upload to the gpu .
public long start ( ) { start time = system . current time millis ( ) ; return start time ; }	start the stop watch .
public void next ( ) { if ( iterator . has next ( ) ) { view current view = iterator . next ( ) ; if ( is using default listener ( ) ) current view . set on click listener ( null ) ; if ( iterator . next index ( ) < m views . size ( ) ) { view next view = m views . get ( iterator . next index ( ) ) ; if ( is using default listener ( ) ) next view . set on click listener ( listener ) ; controller animator animator = get default forward animation ( ) ; animator . set old view ( current view ) ; animator . set new view ( next view ) ; current view . start animation ( animator ) ; if ( iterator . next index ( ) == m views . size ( ) - num ) if ( has controller listener ( ) ) m listener . on end reached ( ) ; } else { if ( m loop ) { iterator = m views . list iterator ( ) ; view next view = m views . get ( num ) ; if ( m use default listener ) next view . set on click listener ( listener ) ; controller animator animator = get default forward animation ( ) ; animator . set old view ( current view ) ; animator . set new view ( next view ) ; current view . start animation ( animator ) ; } } } }	go to the next view.
private boolean is hh ( string str ) { boolean sign = bool ; try { char r = ( char ) integer . parse int ( str , num ) ; } catch ( number format exception e ) { sign = bool ; } return sign ; }	dmitri ilyin : makes sure if the string is hh encoded sign .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { sun misc allocate instance ( method , this var , return var , params ) ; return ; } { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public void cache resolved method ( class clas , class [ ] types , method method ) { if ( interpreter . debug ) interpreter . debug ( str + clas + str + method ) ; signature key sk = new signature key ( clas , method . get name ( ) , types ) ; if ( modifier . is static ( method . get modifiers ( ) ) ) resolved static methods . put ( sk , method ) ; else resolved object methods . put ( sk , method ) ; }	cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change.
public void test set bit top positive ( ) { byte a bytes [ ] = { num , - num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , - num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	setbit ( int n ) the leftmost bit in a positive number.
private void destroy beans ( map < string , object > view map , map < string , view scope context object > context map ) { array list < string > removal name list = new array list < > ( ) ; if ( context map != null ) { for ( map . entry < string , view scope context object > entry : context map . entry set ( ) ) { string passivation capable id = entry . get key ( ) ; contextual contextual = bean manager . get passivation capable bean ( passivation capable id ) ; view scope context object context object = entry . get value ( ) ; creational context creational context = bean manager . create creational context ( contextual ) ; contextual . destroy ( view map . get ( context object . get name ( ) ) , creational context ) ; removal name list . add ( context object . get name ( ) ) ; } iterator < string > removal names = removal name list . iterator ( ) ; while ( removal names . has next ( ) ) { string name = removal names . next ( ) ; view map . remove ( name ) ; } context map . clear ( ) ; } }	destroy the view scoped beans for the given view and context map .
public static void close ( @ check for null output stream output stream ) { if ( output stream == null ) { return ; } try { output stream . close ( ) ; } catch ( io e ) { } }	close given outputstream , ignoring any resulting exception .
@ override public node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( node ) ( nodes . get ( index ) ) : null ; }	retrieve an item from the map by 0 - based index .
private int char to visible width ( char c , @ jdk constants . font style int font type , int current x ) { if ( c == str ) { return num ; } if ( c == str ) { return editor util . next tab stop ( current x , this ) - current x ; } return editor util . char width ( c , font type , this ) ; }	allows to answer how much width requires given char to be represented on a screen .
public static void create dir ( file target ) throws ade usage exception { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new ade usage exception ( str + target . get path ( ) ) ; } }	create directory if not already exists . throw an exception upon failure.
public gts ( long base timestamp ) { this . base timestamp = base timestamp ; this . stream = new byte array output stream ( ) ; this . wrapping key = null ; }	create an encoder using the given timestamp as its base.
public static string encode ( final coordinate [ ] coords ) { long last lat = num ; long last lng = num ; final string buffer result = new string buffer ( ) ; for ( final coordinate point : coords ) { long lat = math . round ( point . y * num ) ; long lng = math . round ( point . x * num ) ; long d lat = lat - last lat ; long d lng = lng - last lng ; encode ( d lat , result ) ; encode ( d lng , result ) ; last lat = lat ; last lng = lng ; } return result . to string ( ) ; }	encodes a sequence of latlngs into an encoded path string .
private void extract weight values ( list < synapse > synapses ) { int ex weights = num ; int in weights = num ; for ( synapse s : synapses ) { double w = s . get strength ( ) ; if ( w > num ) { ex weights ++ ; } else { in weights ++ ; } } weights [ num ] = new double [ ex weights ] ; weights [ num ] = new double [ in weights ] ; ex weights = num ; in weights = num ; if ( weights [ num ] . length != num ) { for ( synapse s : synapses ) { double w = s . get strength ( ) ; if ( w > num ) { weights [ num ] [ ex weights ++ ] = w ; } else { weights [ num ] [ in weights ++ ] = w ; } } } }	extracts weight values and organizes them by synapse type ( inhibitory or excitatory ).
@ override public void close ( ) { try { flush ( ) ; } catch ( am ale ) { debug . error ( table name + str + ale . get message ( ) ) ; } if ( conn != null ) { try { conn . close ( ) ; } catch ( sql ce ) { debug . error ( table name + str , ce ) ; } } stop buffer timer ( ) ; }	flush any buffered messages and close the current output stream .
public boolean contains ( list < integer > hashes ) { iterator < integer > ni = hashes . iterator ( ) ; for ( int i = num ; i < hash functions ; ++ i ) { if ( ! test bit ( ( int ) ( ( ni . next ( ) & num ) % ( filter . length * num ) ) ) ) { return bool ; } } return bool ; }	check if the filter contains data with precomputed hashes .
private void ensure capacity ( int additional data ) { if ( ( this . position + additional data ) > this . byte buffer . length ) { int new length = ( int ) ( this . byte buffer . length * num ) ; if ( new length < ( this . byte buffer . length + additional data ) ) { new length = this . byte buffer . length + ( int ) ( additional data * num ) ; } if ( new length < this . byte buffer . length ) { new length = this . byte buffer . length + additional data ; } byte [ ] new bytes = new byte [ new length ] ; system . arraycopy ( this . byte buffer , num , new bytes , num , this . byte buffer . length ) ; this . byte buffer = new bytes ; } }	ensure that there are additionaldata bytes available in the buffer.
public boolean is valid number ( phone number number ) { string region code = get region code for number ( number ) ; return is valid number for region ( number , region code ) ; }	tests whether a phone number matches a valid pattern.
private string trim url ( string uri ) { if ( uri == null ) return str ; if ( uri . ends with ( str ) ) uri = uri . substring ( num , uri . length ( ) - num ) ; return uri ; }	trim the url , by removing an extra ' / ' at the end of the url and also make it lowercase < p >.
public pair < integer , list < long > > next ( ) { try { classes processed ++ ; integer key = iterator . next ( ) ; long pos = classification block rm . get pos ( key ) ; int count = classification block rm . get sum ( key ) ; class dump reader . seek ( pos ) ; list < long > list = new linked list < > ( ) ; for ( int i = num ; i < count ; i ++ ) list . add ( class dump reader . read long ( ) ) ; return new pair < > ( key , list ) ; } catch ( exception e ) { basic . caught ( e ) ; error = bool ; return null ; } }	returns the next element in the iteration .
public static string add alpha ( string original color , double alpha ) { long alpha fixed = math . round ( alpha * num ) ; string alpha hex = long . to hex string ( alpha fixed ) ; if ( alpha hex . length ( ) == num ) { alpha hex = str + alpha hex ; } original color = original color . replace ( str , str + alpha hex ) ; return original color ; }	adds alpha to a hex color.
public void stop ( ) { server . stop ( num ) ; }	stop the web server .
final void copy into local state ( operand [ ] local state ) { local state = new operand [ local state . length ] ; system . arraycopy ( local state , num , local state , num , local state . length ) ; set local known ( ) ; }	save a shallow copy of the given local variable state into this .
protected object attempt read response ( connection cnx ) throws exception { message msg = create response message ( ) ; if ( msg != null ) { msg . set comms ( cnx . get socket ( ) , cnx . get input stream ( ) , cnx . get output stream ( ) , cnx . get comm buffer ( ) , cnx . get stats ( ) ) ; if ( msg instanceof chunked message ) { try { return process response ( msg , cnx ) ; } finally { msg . unset comms ( ) ; process secure bytes ( cnx , msg ) ; } } else { try { msg . recv ( ) ; } finally { msg . unset comms ( ) ; process secure bytes ( cnx , msg ) ; } return process response ( msg , cnx ) ; } } else { return null ; } }	attempts to read a response to this operation by reading it from the given connection , and returning it .
public synchronized boolean add ( e e , boolean has next ) { while ( m internal queue . size ( ) >= m max size && ! m closed ) { notify all ( ) ; try { wait ( timeout ) ; } catch ( interrupted exception e1 ) { m closed = bool ; program state . check abort ( ) ; throw new illegal state exception ( str , e1 ) ; } program state . check abort ( ) ; } if ( m closed ) { return bool ; } final boolean was empty = m internal queue . is empty ( ) ; m has next = has next ; m internal queue . add ( e ) ; if ( was empty ) { notify all ( ) ; } return bool ; }	add method which also set whether there is a next value.
public translatable component ( ) { }	construct new empty translatablecomponent .
public void add part ( int index , pdu part part ) { if ( null == part ) { throw new null pointer exception ( ) ; } put part to maps ( part ) ; m parts . add ( index , part ) ; }	inserts the specified part at the specified position .
public str builder insert ( int index , boolean value ) { validate index ( index ) ; if ( value ) { ensure capacity ( size + num ) ; system . arraycopy ( buffer , index , buffer , index + num , size - index ) ; buffer [ index ++ ] = str ; buffer [ index ++ ] = str ; buffer [ index ++ ] = str ; buffer [ index ] = str ; size += num ; } else { ensure capacity ( size + num ) ; system . arraycopy ( buffer , index , buffer , index + num , size - index ) ; buffer [ index ++ ] = str ; buffer [ index ++ ] = str ; buffer [ index ++ ] = str ; buffer [ index ++ ] = str ; buffer [ index ] = str ; size += num ; } return this ; }	inserts the value into this builder .
public boolean has nature and weapon ( nature nature , string weapon ) { return this . nature == nature && ( ( weapon == null && this . weapon == null ) || ( weapon != null && weapon . equals ( this . weapon ) ) ) ; }	check if this painter has the given nature an weapon .
public void dump ( string info msg ) { storage . get online members ( ) ; storage . get offline members ( ) ; storage . get offline and equal members ( ) ; storage . get my initializing id ( ) ; storage . get my persistent id ( ) ; final string builder buf = new string builder ( num ) ; if ( info msg != null ) { buf . append ( info msg ) ; buf . append ( str ) ; } buf . append ( str ) ; buf . append ( storage . get my persistent id ( ) ) ; buf . append ( str ) ; buf . append ( storage . get my initializing id ( ) ) ; buf . append ( str ) ; for ( id id : storage . get online members ( ) ) { buf . append ( str ) ; buf . append ( id ) ; buf . append ( str ) ; } buf . append ( str ) ; for ( id id : storage . get offline members ( ) ) { buf . append ( str ) ; buf . append ( id ) ; buf . append ( str ) ; } buf . append ( str ) ; for ( id id : storage . get offline and equal members ( ) ) { buf . append ( str ) ; buf . append ( id ) ; buf . append ( str ) ; } logger . debug ( buf . to string ( ) ) ; }	callers should have already verified that debug output is enabled .
public synchronized void open ( ) { }	open the device ( done automatically ).
@ not null private optional < type conversion > find conversion from db value ( @ not null type source , @ not null type target ) { if ( is assignable ( target , source ) ) return optional . of ( type conversion . identity ( ) ) ; optional < type conversion > direct conversion = type conversion registry . find conversion from db value ( source , target ) ; if ( direct conversion . is present ( ) ) return direct conversion ; optional < type conversion > array conversion = find array conversion ( source , target ) ; if ( array conversion . is present ( ) ) return array conversion ; optional < type conversion > optional conversion = find optional conversion ( source , target ) ; if ( optional conversion . is present ( ) ) return optional conversion ; optional < type conversion > enum conversion = find enum conversion ( target ) ; if ( enum conversion . is present ( ) ) return enum conversion ; return optional . empty ( ) ; }	returns conversion for converting value of source to target , or returns null if there ' s no such conversion .
private boolean advance api up to ( tree set < area panel info > sorted api tree , area panel info api , int time ) { area panel ap = api . ap ( ) ; time tree root tt = ap . get time tree ( ) ; time tree tt = root tt . get encompassig time tree or max time tree before time ( time , bool ) ; if ( tt == null || tt . id == api . curr tt id ) return bool ; sorted api tree . remove ( api ) ; if ( api . set tt ( tt , integer . max value ) ) sorted api tree . add ( api ) ; return bool ; }	moves api to the latest value before time .
@ request mapping ( value = { str , str } , method = request method . post ) @ response body public rest wrapper update ( @ model attribute ( str ) @ valid user roles user roles , binding result binding result , principal principal ) { rest wrapper rest wrapper = null ; if ( binding result . has errors ( ) ) { binding result error binding result error = new binding result error ( ) ; return binding result error . error message ( binding result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . user roles jpa user roles = new com . wipro . ats . bdre . md . dao . jpa . user roles ( ) ; jpa user roles . set user role id ( user roles . get user role id ( ) ) ; jpa user roles . set role ( user roles . get role ( ) ) ; users users = new users ( ) ; users . set username ( user roles . get username ( ) ) ; jpa user roles . set users ( users ) ; user roles dao . update ( jpa user roles ) ; rest wrapper = new rest wrapper ( user roles , rest wrapper . ok ) ; logger . info ( str + user roles . get user role id ( ) + str + principal . get name ( ) + user roles ) ; } catch ( exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls proc updateuserroles and updates the values.
private void send request option ( ) throws io { string request = str + m parameters . host + str + m parameters . port + m parameters . path + str + add headers ( ) ; log . i ( tag , request . substring ( num , request . index of ( str ) ) ) ; m output stream . write ( request . get bytes ( str ) ) ; response . parse response ( m buffered reader ) ; }	forges and sends the options request.
@ override public result do comparison test ( final properties properties ) throws exception { final long timeout = long . parse long ( properties . get property ( test options . timeout ) ) ; final int nresources = integer . parse int ( properties . get property ( test options . nresources ) ) ; final int min locks = integer . parse int ( properties . get property ( test options . min locks ) ) ; final int max locks = integer . parse int ( properties . get property ( test options . max locks ) ) ; final int ntrials = integer . parse int ( properties . get property ( test options . ntrials ) ) ; final int key len = integer . parse int ( properties . get property ( test options . keylen ) ) ; final int nops = integer . parse int ( properties . get property ( test options . nops ) ) ; final double failure rate = double . parse double ( properties . get property ( test options . failure rate ) ) ; result result = do concurrent client test ( journal , timeout , nresources , min locks , max locks , ntrials , key len , nops , failure rate ) ; return result ; }	setup and run a test .
public void add delete ( i delete ) { if ( f delete == null ) f delete = new array list < i > ( num ) ; f delete . add ( delete ) ; if ( f ignore count == num ) { internal add ( new delete description ( delete ) ) ; } }	adds the given resource to the list of resources to be deleted .
public static double max ( final double a , final double b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return double . n ; } long bits = double . double to raw long bits ( a ) ; if ( bits == num ) { return b ; } return a ; }	compute the maximum of two values.
public void add container ( image container container ) { m containers . add ( container ) ; }	adds another imagecontainer to the list of those interested in the results of the request .
@ override public void write external ( object output out ) throws io { super . write external ( out ) ; out . write object ( approximation ) ; }	calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .
public void add ( string method name , list < expression > parameters ) { chain . add ( new dot expression item ( method name , parameters , bool ) ) ; }	add a method to the chain of methods after the dot .
public static request request ( ) { return thread local . get ( ) ; }	get the current request , which is specific to the current thread .
public static string create hash ( string password ) throws no such algorithm exception , invalid key spec exception { return create hash ( password . to char array ( ) ) ; }	returns a salted pbkdf2 hash of the password .
private void schedule commercial ( int length ) { long delay = commercial delay . get setting value ( ) ; if ( delay == null ) { set commercial result ( str ) ; clear commercial buttons selection ( ) ; } else { scheduled commercial time = system . current time millis ( ) + delay * num ; scheduled commercial length = length ; update ( ) ; } }	schedules a commercial of the given length to be run after the delay currently set in the delay input field .
public int hash code ( ) { long bits = double . double to long bits ( m00 ) ; bits = bits * num + double . double to long bits ( m01 ) ; bits = bits * num + double . double to long bits ( m02 ) ; bits = bits * num + double . double to long bits ( m10 ) ; bits = bits * num + double . double to long bits ( m11 ) ; bits = bits * num + double . double to long bits ( m12 ) ; return ( ( ( int ) bits ) ^ ( ( int ) ( bits > > num ) ) ) ; }	returns the hashcode for this transform .
public void unsubscribe ( aws message ) throws aws { try { unsubscribe topic ( message ) ; } catch ( aws iot retryable exception e ) { if ( client . get max offline queue size ( ) > num && unsubscribe queue . size ( ) < client . get max offline queue size ( ) ) { unsubscribe queue . add ( message ) ; } else { logger . info ( str + message . get topic ( ) ) ; throw new aws ( e ) ; } } }	the actual unsubscribe method exposed by this class .
public static boolean is digital unix ( ) { return os name . index of ( str ) > - num ; }	is operating system digital unix ?.
public void client disconnect ( ) { try { out http app response stream = response stream ; if ( response stream != null ) { response stream . close ( ) ; } } catch ( exception e ) { log . log ( level . finer , e . to string ( ) , e ) ; } connection tcp conn = conn tcp ( ) ; if ( conn != null ) { conn . client disconnect ( ) ; } kill keepalive ( str ) ; }	called when the client has disconnected.
public boolean ends with ( name n ) { if ( n instanceof compound name ) { return ( impl . ends with ( n . size ( ) , n . get all ( ) ) ) ; } else { return bool ; } }	determines whether a compound name is a suffix of this compound name.
private int calculate total height ( float star size , int number of stars , float stars separation , boolean padding ) { return math . round ( star size ) + ( padding ? get padding top ( ) + get padding bottom ( ) : num ) ; }	calculates total height to occupy based on several parameters.
@ suppress warnings ( str ) private static boolean is regex ( string s ) { try { pattern . compile ( s ) ; } catch ( pattern syntax exception e ) { return bool ; } return bool ; }	this method is a copy of regexutil.
private static boolean has specialized handler intents ( context context , intent intent ) { try { package manager pm = context . get package manager ( ) ; list < resolve info > handlers = pm . query intent activities ( intent , package manager . get resolved filter ) ; if ( handlers == null || handlers . size ( ) == num ) { return bool ; } for ( resolve info resolve info : handlers ) { intent filter filter = resolve info . filter ; if ( filter == null ) continue ; if ( filter . count data authorities ( ) == num || filter . count data paths ( ) == num ) continue ; if ( resolve info . activity info == null ) continue ; return bool ; } } catch ( runtime exception e ) { log . e ( tag , str ) ; } return bool ; }	used to check whether there is a specialized handler for a given intent .
public static void flush ( ) { clear buffer ( ) ; try { out . flush ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .
private string attach footer to text ( string content ) throws messaging exception , io { string builder builder = new string builder ( content ) ; ensure trailing carriage return ( content , builder ) ; builder . append ( get footer text ( ) ) ; return builder . to string ( ) ; }	prepends the content of the mimepart as text to the existing footer.
public static sentence make ( final connective connective , final sentence ... children2 ) { return make ( connective , arrays . as list ( children2 ) ) ; }	conjoin a list of sentences.
public final void test is state preserved1 ( ) { byte [ ] encoded key = new byte [ ] { ( byte ) num , ( byte ) num , ( byte ) num , ( byte ) num } ; encoded key spec meks = new my encoded key spec ( encoded key ) ; encoded key [ num ] = ( byte ) num ; byte [ ] ek = meks . get encoded ( ) ; assert true ( ek [ num ] == ( byte ) num ) ; }	tests that internal state of the object can not be modified by modifying initial array value.
public synchronized void init ( ) { init = bool ; for ( string map name : store . get map names ( ) ) { if ( map name . starts with ( str ) ) { mv < object , integer > temp = open temp map ( map name ) ; store . remove map ( temp ) ; } } synchronized ( undo log ) { if ( undo log . size ( ) > num ) { for ( long key : undo log . key set ( ) ) { int transaction id = get transaction id ( key ) ; open transactions . set ( transaction id ) ; } } } }	initialize the store . this is needed before a transaction can be opened . if the transaction store is corrupt , this method can throw an exception , in which case the store can only be used for reading .
public static t create cumulative histogram ( t histogram ) { double [ ] keys = histogram . keys ( ) ; arrays . sort ( keys ) ; double sum = num ; for ( double key : keys ) { double val = histogram . get ( key ) ; sum += val ; histogram . put ( key , sum ) ; } return histogram ; }	creates a cumulative histogram where each bin height is the sum of the previous bin ' s height and the current bin ' s height .
public synchronized void update icons for pkg ( string package name , user handle compat user ) { remove icons for pkg ( package name , user ) ; try { package info info = m package manager . get package info ( package name , package manager . get uninstalled packages ) ; long user serial = m user manager . get serial number for user ( user ) ; for ( launcher activity info compat app : m launcher apps . get activity list ( package name , user ) ) { add icon to db ( app , info , user serial ) ; } } catch ( name not found exception e ) { log . d ( tag , str , e ) ; return ; } }	updates the entries related to the given package in memory and persistent db .
protected date time data parse ( string str ) throws schema date time exception { date time data date = new date time data ( str , this ) ; int len = str . length ( ) ; int end = index of ( str , num , len , str ) ; int date end = get date ( str , num , end , date ) ; get time ( str , end + num , len , date ) ; if ( date end != end ) { throw new runtime exception ( str + str + str ) ; } validate date time ( date ) ; save unnormalized ( date ) ; if ( date . utc != num && date . utc != str ) { normalize ( date ) ; } return date ; }	parses , validates and computes normalized version of datetime object.
void add attribute values ( string attr name , set values ) throws sms { if ( attr name != null && values != null && ! values . is empty ( ) ) { map attrs = get attributes ( ) ; set orig values = ( set ) attrs . get ( attr name ) ; set new values = new hash set ( values ) ; if ( orig values != null && ! orig values . is empty ( ) ) { new values . add all ( orig values ) ; } map new attrs = new hash map ( ) ; new attrs . put ( attr name , new values ) ; set attributes ( new attrs ) ; } }	adds attributes to amsdk organization.
public void test park until 3 ( ) throws exception { cyclic barrier barrier = new cyclic barrier ( num ) ; parker parker = new parker ( barrier , bool , num ) ; thread parker thread = new thread ( parker ) ; unsafe . unpark ( parker thread ) ; parker thread . start ( ) ; parker . assert duration is in range ( num ) ; parker thread . join ( ) ; }	test the case where the thread is preemptively unparked .
segment manager commit index ( long commit index ) { this . commit index = math . max ( this . commit index , commit index ) ; return this ; }	sets the log commit index .
public void finish fragments ( ) { for ( fragment comment : closing fragments ) { finish fragment ( comment ) ; } closing fragments . clear ( ) ; }	sets all the closing fragments into finished state .
private final void write ut ( byte [ ] utf8 , int offset , int total len ) throws io , json generation exception { do { int len = math . min ( output max contiguous , total len ) ; write ut ( utf8 , offset , len ) ; offset += len ; total len -= len ; } while ( total len > num ) ; }	method called when utf - 8 encoded ( but not yet escaped ! ) content is not guaranteed to fit in the output buffer after escaping ; as such , we just need to chunk writes .
public static string hex to string no exception ( final string data ) { try { return conversion utils . array to string ( hex . decode hex ( data . to char array ( ) ) ) ; } catch ( decoder exception e ) { return str ; } }	converts the given hex string into a plain string .
public collection < node > matching scenarios and examples ( final feature feature ) { final list < scenario definition > all scenarios = feature . get scenario definitions ( ) ; final list < node > matching scenarios and examples = new linked list < node > ( ) ; for ( final scenario definition scenario : all scenarios ) { final set < tag > all tags for scenario = new hash set < tag > ( scenario . get tags ( ) ) ; all tags for scenario . add all ( feature . get tags ( ) ) ; if ( scenario instanceof scenario outline ) { matching scenarios and examples . add all ( matching examples ( ( scenario outline ) scenario , all tags for scenario ) ) ; } else { if ( matches ( all tags for scenario ) ) { matching scenarios and examples . add ( scenario ) ; } } } return matching scenarios and examples ; }	find the scenarios that match the required tags in the feature .
public static string rate2speed ( double rate ) { return number forma . format ( rate ) + str + general unit kbpsec ; }	converts an rate into a human readable and localized kb / s speed .
public long next ( ) { long result = - num ; if ( cache < num && buffer elements > num ) { result = get next from buffer ( ) ; buffer elements -- ; } else { result = cache ; cache = - num ; } if ( ! cs . is empty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - num ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - num ) { throw new no such element exception ( ) ; } assert . check ( previous < result , ec . general ) ; previous = result ; read elements ++ ; return result ; }	returns the next element in the iteration .
public boolean is set queue size ( ) { return isset bit vector . get ( queuesize isset id ) ; }	returns true if field queuesize is set ( has been assigned a value ) and false otherwise.
private static string to string ( double coeff ) { final string c = double . to string ( coeff ) ; if ( c . ends with ( str ) ) { return c . substring ( num , c . length ( ) - num ) ; } else { return c ; } }	creates a string representing a coefficient , removing ".
public static final index created event create test index creation status with bulk data hit ( ) { index created event to return = new index created event ( uuid . random uuid ( ) , new date ( ) , new date ( ) , create test index with bulk data hit ( ) , num , num ) ; to return . calculate values ( ) ; return to return ; }	creates at test indexcreatedevent .
public boolean validate ( string value , string rule ) { return ( value . equals ignore case ( rule ) ) ; }	determines whether the specified string is a valid boolean value.
public string find uri ( int owner ) { int n = m source tree . size ( ) ; for ( int i = num ; i < n ; i ++ ) { source tree s tree = ( source tree ) m source tree . element at ( i ) ; if ( owner == s tree . m root ) return s tree . m url ; } return null ; }	given a document , find the url associated with that document .
static public final int random ( int start , int end ) { return start + random . next int ( end - start + num ) ; }	returns a random number between start ( inclusive ) and end ( inclusive ) .
public boolean offer ( e event , int task id ) throws interrupted exception { assert not done ( ) ; if ( predicate . match ( event ) ) { this . matched [ task id ] = bool ; for ( boolean match : matched ) { if ( ! match ) return bool ; } response queue . put ( new event holder ( event ) ) ; done = bool ; return bool ; } else return bool ; }	offer an event to this watch instance.
private static algorithm parameter spec algorithm parameter spec ( ) { final secure random random = new secure random ( ) ; final byte [ ] bytes = new byte [ cc aes . block ] ; random . next bytes ( bytes ) ; return new iv parameter spec ( bytes ) ; }	create algorithmparameterspec with the block size .
protected boolean is token char ( char ch ) { if ( character . is letter or digit ( ch ) ) return bool ; if ( character . is iso ( ch ) ) return bool ; if ( is http separator ( ch ) ) return bool ; return bool ; }	checks whether a character is a valid token character.
public void draw lines and points ( d g2d , array list < comparable label > ordered date set , hash map < comparable label , integer > data points , long y max mark ) { int section width = this . graph width / ordered date set . size ( ) ; int x offset = section width / num ; int y prev value ; int y current value ; float prev offset perc ; float current offset perc ; g2d . set color ( this . line color ) ; for ( int i = num ; i < ordered date set . size ( ) ; i ++ ) { if ( i != num ) { y prev value = data points . get ( ordered date set . get ( i - num ) ) ; y current value = data points . get ( ordered date set . get ( i ) ) ; prev offset perc = y prev value / ( float ) y max mark ; current offset perc = y current value / ( float ) y max mark ; g2d . draw line ( this . graph left + ( i - num ) * section width + x offset , this . graph bottom - math . round ( prev offset perc * this . graph height ) , this . graph left + i * section width + x offset , math . round ( this . graph bottom - current offset perc * this . graph height ) ) ; } else { y current value = data points . get ( ordered date set . get ( i ) ) ; current offset perc = y current value / ( float ) y max mark ; g2d . fill oval ( this . graph left + ( i ) * section width + x offset - this . point radius , this . graph bottom - math . round ( current offset perc * this . graph height ) - this . point radius , this . point radius * num , this . point radius * num ) ; } } }	draws the datapoints and the lines connecting the datapoints on the line graph.
@ suppress lint ( str ) public void element type ( string name , int model , int member of , int flags ) { element type e = new element type ( name , model , member of , flags , this ) ; the element types . put ( name . to lower case ( ) , e ) ; if ( member of == m root ) the root = e ; }	add or replace an element type for this schema .
public static string make log tag ( class cls ) { return make log tag ( cls . get simple name ( ) ) ; }	don ' t use this when obfuscating class names !.
final public void println ( string s ) { writer out = this . out ; if ( out == null ) return ; try { if ( s == null ) out . write ( null chars , num , null chars . length ) ; else out . write ( s , num , s . length ( ) ) ; out . write ( newline , num , newline . length ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	writes a string followed by a newline .
private static uri refrag uri ( uri uri , string frag ) throws uri { return new uri ( uri . get scheme ( ) , uri . get scheme specific part ( ) , frag ) ; }	return a new uri with a different fragment .
@ override public void paint ( final p ppc ) { final paint paint = get paint ( ) ; if ( paint != null ) { final d g2 = ppc . get graphics ( ) ; final p bounds = get union of children bounds ( null ) ; if ( fill background ) { g2 . set paint ( background color ) ; g2 . fill rect ( ( int ) bounds . get x ( ) - outline padding , ( int ) bounds . get y ( ) - outline padding , ( int ) bounds . get width ( ) + num * outline padding , ( int ) bounds . get height ( ) + num * outline padding ) ; } if ( draw outline ) { g2 . set paint ( line color ) ; g2 . draw round rect ( ( int ) bounds . get x ( ) - outline padding , ( int ) bounds . get y ( ) - outline padding , ( int ) bounds . get width ( ) + num * outline padding , ( int ) bounds . get height ( ) + num * outline padding , rounding width height , rounding width height ) ; } } }	change the default paint to fill an expanded bounding box based on its children ' s bounds .
public final synchronized byte [ ] to byte array ( ) { byte array output stream baos = null ; data output stream dos = null ; try { baos = new byte array output stream ( num ) ; dos = new data output stream ( baos ) ; game . write to stream ( dos ) ; dos . flush ( ) ; return baos . to byte array ( ) ; } catch ( io e ) { return null ; } finally { if ( dos != null ) try { dos . close ( ) ; } catch ( io ex ) { } if ( baos != null ) try { baos . close ( ) ; } catch ( io ex ) { } } }	serialize to byte array .
public void add import ( @ not null psi element importable , @ not null psi file file , @ nullable py import element import element ) { my imports . add ( new import candidate holder ( importable , file , import element , null ) ) ; }	adds another import source .
protected final void draw arrow head ( d g , int x , int y , int sgn ) { g . set stroke ( strokes . get stroke ( stroke type . solid , num ) ) ; int size = diagram ( ) . arrow size ; switch ( head type ) { case closed : polygon p = new polygon ( new int [ ] { x , x + sgn * size , x + sgn * size , x } , new int [ ] { y , y - size , y + size , y } , num ) ; g . fill polygon ( p ) ; break ; case open : g . draw line ( x , y , x + sgn * size , y - size ) ; g . draw line ( x , y , x + sgn * size , y + size ) ; break ; case rounded : int left = sgn == - num ? x - num * size : x ; int top = y - size ; g . fill arc ( left , top , size * num , size * num , num , sgn * num ) ; } }	draws the head of a message arrow onto the diagram display .
public void class loader init ( dynamic class loader loader ) { env loader listener listener = listener ref . get ( ) ; if ( listener != null ) listener . class loader init ( loader ) ; }	handles the case where a class loader is activated .
private object [ ] unmarshal parameters checked ( deserialization checker checker , method method , marshal input stream in ) throws io , class not found exception { int call id = method call id . get and increment ( ) ; my checker my checker = new my checker ( checker , method , call id ) ; in . set stream checker ( my checker ) ; try { class < ? > [ ] types = method . get parameter types ( ) ; object [ ] values = new object [ types . length ] ; for ( int i = num ; i < types . length ; i ++ ) { my checker . set index ( i ) ; values [ i ] = unmarshal value ( types [ i ] , in ) ; } my checker . end ( call id ) ; return values ; } finally { in . set stream checker ( null ) ; } }	unmarshal parameters for the given method of the given instance over the given marshalinputstream.
private void load data from service ( ) { list < exception sensor data > ex data = null ; if ( ( null != from date ) && ( null != to date ) ) { ex data = data access service . get ungrouped exception overview ( template , limit , from date , to date , result comparator ) ; } else { ex data = data access service . get ungrouped exception overview ( template , limit , result comparator ) ; } exception sensor data . clear ( ) ; if ( null != ex data ) { exception sensor data . add all ( ex data ) ; } }	reloads the data from the service .
public static string create resource name ( string resource , locale locale , boolean remove extension ) { string resource name = resource ; if ( remove extension ) { if ( resource name . ends with ( str ) ) { resource name = resource name . replace ( str , str ) ; } else if ( resource name . ends with ( str ) ) { resource name = resource name . replace ( str , str ) ; } } if ( locale != null ) { if ( util validate . is not empty ( locale . to string ( ) ) ) { resource name = resource name + str + locale ; } } return resource name ; }	create a localized resource name based on a resource name and a locale .
public static string to string ( object [ ] objects , displayable renderer ) { if ( objects == null ) return str ; string buffer buffer = new string buffer ( num ) ; for ( int i = num ; i < objects . length ; i ++ ) { if ( i > num ) buffer . append ( str ) ; buffer . append ( renderer . display string ( objects [ i ] ) ) ; } return buffer . to string ( ) ; }	converts an array of objects into string .
void draw icon ( graphics g , int ax , int ay , int aw , int ah , float align , component c ) { int gap = is left to right ? - ( img . get icon width ( ) + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = math . max ( ay , ay + ( int ) ( align * ah ) - img . get icon height ( ) ) ; img . paint icon ( c , g , x , y ) ; }	draws the bullet icon specified by the list - style - image argument .
public int sync query ( string query ) { long start = system . current time millis ( ) ; int modified = execute ( str , update count response , query ) ; log . debug ( str , system . current time millis ( ) - start , modified ) ; return modified ; }	synchronizes the rdf repository ' s representation of an entity to be exactly the provided statements .
public static void full reset ( ) { reset runtime ( ) ; synchronized ( read properties ) { read properties . clear ( ) ; } }	fully reset the state , not only the one related to latest test case execution.
private buffered image to buffered image ( final image image ) { if ( image instanceof buffered image ) { return ( buffered image ) image ; } if ( image instanceof volatile image ) { volatile image volatile image = ( volatile image ) image ; return volatile image . get snapshot ( ) ; } graphics environment graphics environment = graphics environment . get local graphics environment ( ) ; graphics device graphics device = graphics environment . get default screen device ( ) ; graphics configuration graphics configuration = graphics device . get default configuration ( ) ; buffered image buffered image = graphics configuration . create compatible image ( image . get width ( null ) , image . get height ( null ) ) ; d g = buffered image . create graphics ( ) ; g . draw image ( image , num , num , null ) ; g . dispose ( ) ; return buffered image ; }	convert the specified image to a bufferedimage , if necessary .
public final boolean is cancelled ( ) { if ( cancelled ) { pass ( str , cancelled ) ; } else { fail ( str ) ; } return cancelled ; }	returns true if this testsubscriber has been cancelled .
public void remove ( directed edge de ) { out edges . remove ( de ) ; }	drops a member of this directededgestar .
@ override public boolean event generatable ( string event name ) { if ( m listenee == null ) { return bool ; } if ( ! event name . equals ( str ) && ! event name . equals ( str ) ) { return bool ; } if ( m listenee instanceof data source ) { if ( m listenee instanceof event constraints ) { event constraints ec = ( event constraints ) m listenee ; return ec . event generatable ( event name ) ; } } if ( m listenee instanceof training set producer ) { if ( m listenee instanceof event constraints ) { event constraints ec = ( event constraints ) m listenee ; if ( ! event name . equals ( str ) ) { return bool ; } if ( ! ec . event generatable ( str ) ) { return bool ; } } } if ( m listenee instanceof test set producer ) { if ( m listenee instanceof event constraints ) { event constraints ec = ( event constraints ) m listenee ; if ( ! event name . equals ( str ) ) { return bool ; } if ( ! ec . event generatable ( str ) ) { return bool ; } } } return bool ; }	returns true if , at the current time , the named event could be generated .
@ override protected void on message on producer thread ( t msg ) { lock . lock ( ) ; try { if ( pending . is empty ( ) ) { queue . schedule ( flush runnable , interval , time unit ) ; } pending . add ( msg ) ; } finally { lock . unlock ( ) ; } }	receives message and batches as needed .
public builder until date ( date date ) { until date = query date . format ( date ) ; return this ; }	returns tweets generated before the given date.
private boolean is in thumb range ( float touch x , double normalized thumb value ) { return math . abs ( touch x - normalized to screen ( normalized thumb value ) ) <= m thumb half width ; }	decides if given x - coordinate in screen space needs to be interpreted as " within " the normalized thumb x - coordinate .
public static void cleanup all files ( file system file system , string base uri ) throws io { try { if ( file system != null ) { path root dir = new path ( base uri ) ; file status [ ] files = file system . list status ( root dir ) ; for ( file status file : files ) { file system . delete ( file . get path ( ) , bool ) ; } } } catch ( exception e ) { log . error ( str ) ; } }	deletes all files in a container.
@ override public boolean can be collided with ( ) { return bool ; }	returns true if other entities should be prevented from moving through this entity .
public void update ( long duration , time unit unit ) { update ( unit . to nanos ( duration ) ) ; }	adds a recorded duration .
public void submit ( string queue name , dispatcher task dispatcher task ) { synchronized ( sync root ) { dispatcher task runner current task runner = current tasks map . get ( queue name ) ; if ( current task runner == null ) { current task runner = new dispatcher task runner ( queue name , dispatcher task ) ; current tasks map . put ( queue name , current task runner ) ; executor service . execute ( current task runner ) ; } else { enqueue next task ( queue name , dispatcher task ) ; } } }	submits task to the specific queue.
public static executor create task distributor ( ) { return executors . new cached thread pool ( create thread factory ( thread . norm priority , str ) ) ; }	creates default implementation of task distributor.
public void dump ( writer writer ) { print writer pw = new print writer ( new buffered writer ( writer ) ) ; pw . println ( str ) ; pw . println ( str ) ; pw . println ( str + ( int ) audio format . get sample rate ( ) ) ; pw . println ( str + samples . length / num ) ; pw . println ( str + audio format . get channels ( ) ) ; if ( samples != null ) { for ( int i = num ; i < samples . length ; i += num ) { pw . println ( wave utils . bytes to short ( samples [ i ] , samples [ i + num ] ) ) ; } } pw . flush ( ) ; }	dumps the wave out to the given stream.
public void add field buffered ( v editor , grid field m field ) { wrap = m field != null ? ! m field . is same line ( ) : bool ; if ( prev editor != null && prev field != null ) add field ( prev editor , prev field ) ; prev editor = editor ; prev field = m field ; }	add field and label to buffer and push buffered field to panel.
public expand room freespace incomplete add incomplete expansion room ( shape tile p shape , int p layer , shape tile p contained shape ) { expand room freespace incomplete new room = new expand room freespace incomplete ( p shape , p layer , p contained shape ) ; incomplete expansion rooms . add ( new room ) ; return new room ; }	creates a new freespaceexpansionroom and adds it to the room list.
static double compute desired ellipsoid magnitude ( final planet model planet model , final double x , final double y , final double z ) { return num / math . sqrt ( x * x * planet model . inverse ab squared + y * y * planet model . inverse ab squared + z * z * planet model . inverse c ) ; }	compute the desired magnitude of a unit vector projected to a given planet model .
public static string trim ( char sequence s ) { if ( s == null ) { return null ; } matcher m = s trim pattern . matcher ( s ) ; return m . replace all ( str ) ; }	trims the string , removing all whitespace at the beginning and end of the string.
private void validate vnx smis ( storage system request param param ) { arg validator . check field valid ip ( param . get smis provider ip ( ) , str ) ; arg validator . check field not null ( param . get smis port number ( ) , str ) ; arg validator . check field range ( param . get smis port number ( ) , num , num , str ) ; arg validator . check field not empty ( param . get smis user name ( ) , str ) ; arg validator . check field not empty ( param . get smis password ( ) , str ) ; }	validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications.
private art locate result calculate next trace ( boolean p layer changed , boolean p at fanout end ) { collection < pla point float > corner list = new linked list < pla point float > ( ) ; corner list . add ( current from point ) ; if ( ! p at fanout end ) { pla point float adjusted start corner = adjust start corner ( ) ; if ( adjusted start corner != current from point ) { pla point float add corner = calculate additional corner ( current from point , adjusted start corner , bool , angle restriction ) ; corner list . add ( add corner ) ; corner list . add ( adjusted start corner ) ; previous from point = current from point ; current from point = adjusted start corner ; } } pla point float prev corner = current from point ; for ( int c limit = num ; c limit < num ; c limit ++ ) { collection < pla point float > next corners = calculate next trace corners ( ) ; if ( next corners . is empty ( ) ) break ; for ( pla point float curr next corner : next corners ) { if ( curr next corner == prev corner ) continue ; corner list . add ( curr next corner ) ; previous from point = current from point ; current from point = curr next corner ; prev corner = curr next corner ; } } int next layer = current trace layer ; if ( p layer changed ) { current from door index = current target door index + num ; expand room complete next room = backtrack array [ current from door index ] . next room ; if ( next room != null ) { next layer = next room . get layer ( ) ; } } pla point int alist rounded corner list = new pla point int alist ( corner list . size ( ) ) ; pla point int prev point = null ; for ( pla point float a float : corner list ) { pla point int curr point = a float . round ( ) ; if ( curr point . equals ( prev point ) ) continue ; rounded corner list . add ( curr point ) ; prev point = curr point ; } art locate result result = new art locate result ( rounded corner list , current trace layer ) ; current trace layer = next layer ; return result ; }	calculates the next trace trace of the connection under construction .
public static < t > byte buffer to byte buffer ( t obj ) throws io { byte [ ] bytes = null ; byte array output stream bos = null ; object output stream oos = null ; try { bos = new byte array output stream ( ) ; oos = new object output stream ( bos ) ; oos . write object ( obj ) ; oos . flush ( ) ; bytes = bos . to byte array ( ) ; } finally { if ( oos != null ) { oos . close ( ) ; } if ( bos != null ) { bos . close ( ) ; } } return byte buffer . wrap ( bytes ) ; }	serialize object to a bytebuffer object .
void write bytes ( channel handler context ctx , byte buf bytes ) ;	executed upon sending a packet away.
@ override protected sensor create new sensor ( string system name , string user name ) { if ( log . is debug enabled ( ) ) { log . debug ( str + system name + str + user name ) ; } sensor s ; string s name = serial address . normalize system name ( system name ) ; if ( s name . equals ( str ) ) { log . error ( str + system name ) ; return null ; } s = get by system name ( s name ) ; if ( s != null ) { log . error ( str + system name ) ; return null ; } string alt name = serial address . convert system name to alternate ( s name ) ; s = get by system name ( alt name ) ; if ( s != null ) { log . error ( str + system name + str + alt name + str ) ; return null ; } int bit = serial address . get bit from system name ( s name ) ; if ( ( bit <= num ) || ( bit >= sensorspernode ) ) { log . error ( str + integer . to string ( bit ) + str + integer . to string ( sensorspernode - num ) ) ; return null ; } if ( user name == null ) { s = new serial sensor ( s name ) ; } else { s = new serial sensor ( s name , user name ) ; } serial node node = serial address . get node from system name ( s name ) ; if ( node == null ) { log . warn ( str + s name + str ) ; return s ; } node . register sensor ( s , bit ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + s . get system name ( ) + str + node ) ; } return s ; }	create a new sensor if all checks are passed system name is normalized to ensure uniqueness .
private double [ ] max ( double [ ] distances1 , double [ ] distances2 ) { if ( distances1 . length != distances2 . length ) { throw new runtime exception ( str ) ; } double [ ] result = new double [ distances1 . length ] ; for ( int i = num ; i < distances1 . length ; i ++ ) { result [ i ] = math . max ( distances1 [ i ] , distances2 [ i ] ) ; } return result ; }	returns an array that holds the maximum values of the both specified arrays in each index .
public void fill shape ( pla point float [ ] p points , graphics p g , color p color , double p translucency factor ) { if ( p color == null ) return ; d g2 = ( d ) p g ; polygon draw polygon = new polygon ( ) ; for ( int index = num ; index < p points . length ; index ++ ) { d curr corner = coordinate transform . board to screen ( p points [ index ] ) ; draw polygon . add point ( ( int ) math . round ( curr corner . get x ( ) ) , ( int ) math . round ( curr corner . get y ( ) ) ) ; } g2 . set color ( p color ) ; set translucency ( g2 , p translucency factor ) ; g2 . set rendering hint ( rendering hints . key antialiasing , rendering hints . value antialias on ) ; g2 . fill ( draw polygon ) ; }	fill the interior of the polygon shape represented by p_points .
public void write exif ( input stream jpeg stream , output stream exif out stream ) throws io { if ( jpeg stream == null || exif out stream == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = get exif writer stream ( exif out stream ) ; do exif stream io ( jpeg stream , s ) ; s . flush ( ) ; }	writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .
private static void decode base256 segment ( bit source bits , string builder result , collection < byte [ ] > byte segments ) throws format exception { int codeword position = num + bits . get byte offset ( ) ; int d1 = unrandomize255 state ( bits . read bits ( num ) , codeword position ++ ) ; int count ; if ( d1 == num ) { count = bits . available ( ) / num ; } else if ( d1 < num ) { count = d1 ; } else { count = num * ( d1 - num ) + unrandomize255 state ( bits . read bits ( num ) , codeword position ++ ) ; } if ( count < num ) { throw format exception . get format instance ( ) ; } byte [ ] bytes = new byte [ count ] ; for ( int i = num ; i < count ; i ++ ) { if ( bits . available ( ) < num ) { throw format exception . get format instance ( ) ; } bytes [ i ] = ( byte ) unrandomize255 state ( bits . read bits ( num ) , codeword position ++ ) ; } byte segments . add ( bytes ) ; try { result . append ( new string ( bytes , str ) ) ; } catch ( unsupported encoding exception uee ) { throw new illegal state exception ( str + uee ) ; } }	see iso 16022 : 2006 , 5.
public void go to current day ( ) { int month difference = flexible calendar helper . get month difference ( display year , display month ) ; calendar cal = calendar . get instance ( ) ; selected date item . set day ( cal . get ( calendar . day of month ) ) ; selected date item . set month ( cal . get ( calendar . month ) ) ; selected date item . set year ( cal . get ( calendar . year ) ) ; if ( disable auto date selection ) { this . user selected item = selected date item . clone ( ) ; } if ( month difference != num ) { reset adapters = bool ; if ( month difference < num ) { month inf pager adapter . set fake count ( last position ) ; month inf pager adapter . notify data set changed ( ) ; } should override computed date = bool ; move to position ( month difference ) ; } else { flexible calendar grid adapter currently visible adapter = month view pager adapter . get month adapter at position ( last position % month view pager adapter . views in pager ) ; currently visible adapter . notify data set changed ( ) ; } }	move the position to today ' s date.
public static byte [ ] to i ( int ip address ) { return new byte [ ] { ( byte ) ( ip address > > > num ) , ( byte ) ( ip address > > > num ) , ( byte ) ( ip address > > > num ) , ( byte ) ip address } ; }	accepts an ipv4 address in the form of an integer and returns the corresponding byte array .
public boolean is valid template ( ) { return is valid template ( template ) ; }	validates this template to see if its valid for plugin v3.
public object take ( ) throws interrupted exception , force reattempt exception { throw new unsupported operation exception ( ) ; }	it removes the first key from the queue .
@ suppress warnings ( { str } ) public static double normal cdf ( double y ) { double f , h ; int j ; double dcphi , x , z , f1 , f2 , f3 , f4 , f5 ; x = y ; if ( math . abs ( x ) > num ) { dcphi = num ; } else { j = ( int ) math . floor ( math . abs ( x ) * num + num ) ; z = j * num ; h = math . abs ( x ) - z ; f = r [ j ] ; f1 = f * z - num ; f2 = f + z * f1 ; f3 = f1 * num + z * f2 ; f4 = f2 * num + z * f3 ; f5 = f3 * num + z * f4 ; dcphi = f + h * ( f1 * num + h * ( f2 * num + h * ( f3 * num + h * ( f4 * num + h * f5 ) ) ) ) / num ; dcphi = dcphi * num * math . exp ( x * - num * x ) ; } if ( x < num ) { return dcphi ; } else { return ( num - dcphi ) ; } }	normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .
private void destroy ( ) { if ( log . is loggable ( level . finest ) ) { log . finest ( this + str ) ; } try { socket . force shutdown ( ) ; } catch ( throwable e ) { } try { close connection ( ) ; } catch ( throwable e ) { log . log ( level . finer , e . to string ( ) , e ) ; } port . remove connection ( this ) ; }	destroy kills the connection and drops it from the connection pool . destroy should only occur if the connection state machine has failed or.
int atom ( ) throws re { int ret = node ( re . op atom , num ) ; int len atom = num ; atom loop : while ( idx < len ) { if ( ( idx + num ) < len ) { char c = pattern . char at ( idx + num ) ; if ( pattern . char at ( idx ) == str ) { int idx escape = idx ; escape ( ) ; if ( idx < len ) { c = pattern . char at ( idx ) ; } idx = idx escape ; } switch ( c ) { case str : case str : case str : case str : if ( len atom != num ) { break atom loop ; } } } switch ( pattern . char at ( idx ) ) { case str : case str : case str : case str : case str : case str : case str : case str : break atom loop ; case str : case str : case str : case str : if ( len atom == num ) { syntax error ( str ) ; } break atom loop ; case str : { int idx before escape = idx ; int c = escape ( ) ; if ( ( c & esc mask ) == esc mask ) { idx = idx before escape ; break atom loop ; } emit ( ( char ) c ) ; len atom ++ ; } break ; default : emit ( pattern . char at ( idx ++ ) ) ; len atom ++ ; break ; } } if ( len atom == num ) { internal error ( ) ; } instruction [ ret + re . offset opdata ] = ( char ) len atom ; return ret ; }	absorb an atomic character string.
public static < t > unary operator < list < t > > from ( collection < string > command line udids , function < t , i . mbs > mbs backup , function < i . mbs , string > formatter , printer out , input stream in ) { return command line udids . is empty ( ) ? new user ( mbs backup , out , in , formatter ) : new udid ( mbs backup , out , in , new array list < > ( command line udids ) ) ; }	returns a new instance.
public boolean is network connected ( ) { connectivity manager connectivity manager = ( connectivity manager ) get system service ( connectivity service ) ; network info network info = connectivity manager . get active network info ( ) ; return network info != null && network info . is connected or connecting ( ) ; }	check the current active network is available .
@ override public void on tab closing ( long time , int id ) { reset ( ) ; force animation to finish ( ) ; tab model model = m tab model selector . get model for tab id ( id ) ; if ( model != null ) { m closed tab = create layout tab ( id , model . is incognito ( ) , no close button , no title ) ; m closed tab . set border alpha ( num ) ; m layout tabs = new layout tab [ ] { m closed tab } ; update cache visible ids ( new linked list < integer > ( arrays . as list ( id ) ) ) ; } else { m layout tabs = null ; m closed tab = null ; } super . on tab closing ( time , id ) ; }	set up for the tab closing animation.
public void put ( string name , string supported , string auth scheme , string level , boolean is default ) { sam c = new sam ( ) ; c . name = name ; c . supported = supported ; if ( auth scheme . length ( ) != num && auth scheme != null ) { int index = auth scheme . last index of ( str ) ; c . value = auth scheme . substring ( index + num ) ; c . key = auth scheme . substring ( num , index ) ; } else { c . value = str ; c . key = str ; } c . level = level ; c . is default = is default ; collections . put ( name , c ) ; }	adds samlv2authcontext to the collection .
public final void close ( ls server packet close packet , boolean forced ) { synchronized ( guard ) { if ( is write disabled ( ) ) { return ; } log . debug ( str + close packet + str ) ; pending close = bool ; is forced closing = forced ; send msg queue . clear ( ) ; send msg queue . add last ( close packet ) ; enable write interest ( ) ; } }	its guaranted that closepacket will be sent before closing connection , but all past and future packets wont.
private void replace collapsed edges ( ) { list new edges = new array list ( ) ; for ( iterator it = edge list . iterator ( ) ; it . has next ( ) ; ) { edge e = ( edge ) it . next ( ) ; if ( e . is collapsed ( ) ) { it . remove ( ) ; new edges . add ( e . get collapsed edge ( ) ) ; } } edge list . add all ( new edges ) ; }	if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge.
public void timing event ( float fraction ) { current . x = ( int ) ( start . x + ( end . x - start . x ) * fraction ) ; current . y = ( int ) ( start . y + ( end . y - start . y ) * fraction ) ; track . set car position ( current ) ; }	timingtarget implementation : calculate and set the current car position based on the animation fraction.
public sea glass title pane ( j root pane , ui ui ) { this . root pane = root pane ; this . root pane ui = ui ; root parent = ( root pane container ) root pane . get parent ( ) ; install title pane ( ) ; }	creates a new seaglasstitlepane object .
public string to string ( ) { string builder s = new string builder ( ) ; for ( item item : this ) s . append ( item + str ) ; return s . to string ( ) ; }	returns a string representation of this queue .
public void write long ( long value ) throws io { check write primitive types ( ) ; primitive types . write long ( value ) ; }	writes a long ( 64 bit ) to the target stream .
public static list < string > expand wildcards ( iterable < file > dirs , list < string > names , backend for backend ) { list < string > result = new array list < string > ( names . size ( ) ) ; for ( string name : names ) { expand wildcard ( result , dirs , name , for backend ) ; } return result ; }	given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories.
public static charset for name ( string charset name ) { return for name ( charset name , null ) ; }	safely gets charset for the specified name.
public ns ( int i ) { double value = long value = i ; type = integer ; }	creates an integer number .
public static void dump ( string message , stack trace element [ ] stack trace ) { dump ( message , arrays . as list ( stack trace ) ) ; }	dumps the given message and stack to the system error console .
public void exec query ( string sql , if a listener ) throws generic entity exception { if ( connection == null ) { get connection ( ) ; } try { if ( debug . verbose on ( ) ) debug . log verbose ( str + sql , module ) ; execute query ( sql ) ; boolean keep going = bool ; while ( keep going && rs . next ( ) ) { keep going = a listener . process next row ( rs ) ; } if ( manual tx ) { connection . commit ( ) ; } } catch ( sql sqle ) { debug . log warning ( str + sql + str , module ) ; debug . log warning ( sqle . get message ( ) , module ) ; throw new generic entity exception ( str + sql , sqle ) ; } finally { close ( ) ; } }	execute a query based on the sql string given . for each record of the resultset return , execute a callback function.
private name cache name ( string sig ) { string builder buf = new string builder ( ) ; if ( sig . starts with ( str ) ) { buf = buf . append ( str ) ; while ( sig . starts with ( str ) ) { buf = buf . append ( target . synthetic name char ( ) ) ; sig = sig . substring ( num ) ; } if ( sig . starts with ( str ) ) { sig = sig . substring ( num , sig . length ( ) - num ) ; } } else { buf = buf . append ( str + target . synthetic name char ( ) ) ; } buf = buf . append ( sig . replace ( str , target . synthetic name char ( ) ) ) ; return names . from string ( buf . to string ( ) ) ; }	the name of the variable to cache t.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case eip package . conditional route condition : return condition edefault == null ? condition != null : ! condition edefault . equals ( condition ) ; case eip package . conditional route channel : return channel != null ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public static native string map library name ( string libname ) ;	maps a library name into a platform - specific string representing a native library .
public matcher next ( ) throws io { readahead ( ) ; if ( matches == null ) { throw new no such element exception ( ) ; } matcher matcher = matches . next ( ) ; if ( discard ) { pattern pattern = matcher . pattern ( ) ; for ( int n = num ; n < patterns . length ; n ++ ) { if ( patterns [ n ] == pattern ) { patterns [ n ] = null ; break ; } } } return matcher ; }	returns the next match from the character stream.
@ called only by ( amidst thread . fragment loader ) public void process queues ( ) { dimension dimension = dimension setting . get ( ) ; update layer manager ( dimension ) ; process recycle queue ( ) ; fragment fragment ; while ( ( fragment = loading queue . poll ( ) ) != null ) { load fragment ( dimension , fragment ) ; dimension = dimension setting . get ( ) ; update layer manager ( dimension ) ; process recycle queue ( ) ; } layer manager . clear invalidated layers ( ) ; }	it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders.
default field declaration add private field ( class < ? > type class , string name ) { return add field ( type class , name , modifier . private ) ; }	add a private field to this.
void reconstruct private subrs ( int font , index base item [ ] fd private base , offset item [ ] fd subrs ) { for ( int i = num ; i < fonts [ font ] . fdprivate lengths . length ; i ++ ) { if ( fd subrs [ i ] != null && fonts [ font ] . private subrs offset [ i ] >= num ) { output list . add last ( new subr marker item ( fd subrs [ i ] , fd private base [ i ] ) ) ; if ( l [ i ] != null ) output list . add last ( new range item ( new random access file or array ( ras factory . create source ( l [ i ] ) ) , num , l [ i ] . length ) ) ; } } }	function adds the new lsubrs dicts ( only for the fds used ) to the list.
public boolean match chomp ( string seq ) { if ( matches ( seq ) ) { pos += seq . length ( ) ; return bool ; } else { return bool ; } }	tests if the queue matches the sequence ( as with match ) , and if they do , removes the matched string from the queue .
public void init gl ( ) { m egl core = new egl core ( null , egl core . flag recordable | egl core . flag try gle ) ; m window surface = new window surface ( m egl core , m surface texture ) ; m window surface . make current ( ) ; m record surface = new window surface ( m egl core , m media recorder . get surface ( ) , bool ) ; init gl ( ) ; }	initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording.
void clear ( ) { if ( m view type count == num ) { final array list < view > scrap = m current scrap ; final int scrap count = scrap . size ( ) ; for ( int i = num ; i < scrap count ; i ++ ) { remove detached view ( scrap . remove ( scrap count - num - i ) , bool ) ; } } else { final int type count = m view type count ; for ( int i = num ; i < type count ; i ++ ) { final array list < view > scrap = m scrap views [ i ] ; final int scrap count = scrap . size ( ) ; for ( int j = num ; j < scrap count ; j ++ ) { remove detached view ( scrap . remove ( scrap count - num - j ) , bool ) ; } } } if ( m transient state views != null ) { m transient state views . clear ( ) ; } }	clears the scrap heap .
protected void contribute token request parameters ( final query string body parameters ) { }	allows subclasses to augment the request to the token endpoint with additional parameters .
public int read ( char cbuf [ ] , int off , int len ) { int k ; if ( position >= document . get length ( ) ) { return - num ; } k = len ; if ( ( position + k ) >= document . get length ( ) ) k = document . get length ( ) - ( int ) position ; if ( off + k >= cbuf . length ) k = cbuf . length - off ; try { document . get text ( ( int ) position , k , segment ) ; position += k ; system . arraycopy ( segment . array , segment . offset , cbuf , off , k ) ; return k ; } catch ( bad location exception ble ) { return - num ; } }	reads characters into a portion of an array .
builder add lenient ( string line ) { int index = line . index of ( str , num ) ; if ( index != - num ) { return add lenient ( line . substring ( num , index ) , line . substring ( index + num ) ) ; } else if ( line . starts with ( str ) ) { return add lenient ( str , line . substring ( num ) ) ; } else { return add lenient ( str , line ) ; } }	add a header line without any validation.
public static void merge node children ( tree node node ) { default mutable tree node master node = ( default mutable tree node ) node ; for ( int i = num ; i < master node . get child count ( ) ; i ++ ) { default mutable tree node child = ( default mutable tree node ) master node . get child at ( i ) ; if ( ! child . is leaf ( ) ) { merge help utilities . merge node children ( default merge type , child ) ; } } }	merge node children . merge the children of a node according to the merging rules of the parent . each subclass must implement this method.
public void test negate negative ( ) { string a = str ; int a scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal c number = new big decimal ( new big integer ( c ) , c scale ) ; assert equals ( str , c number , a number . negate ( ) ) ; }	negate ( ) for a negative bigdecimal.
private static object create and bind item ( parameter access parameters , class < ? > item type ) { try { object value = item type . new instance ( ) ; bind ( value , parameters ) ; return value ; } catch ( instantiation exception | illegal access exception e ) { throw new binding exception ( str + item type , e ) ; } }	creates and binds the parameters to a new item .
public simple setup panel ( experiment exp ) { this ( ) ; set experiment ( exp ) ; }	creates the setup panel with the supplied initial experiment .
public static void add listener ( listener listener ) { listeners . add last ( listener ) ; }	adds a listener of memory copying events .
private static void process args ( string [ ] args ) { for ( int i = num ; i < args . length ; i ++ ) { string arg = args [ i ] ; if ( arg . equals ( str ) ) { output dir = args [ ++ i ] ; } else if ( arg . equals ( str ) ) { unicode data = args [ ++ i ] ; } else if ( arg . equals ( str ) ) { language = args [ ++ i ] ; } else if ( arg . equals ( str ) ) { country = args [ ++ i ] ; } else if ( arg . equals ( str ) ) { valiant = args [ ++ i ] ; } else { usage ( ) ; } } locale name = get locale name ( ) ; }	parses the specified arguments and sets up the variables .
public static boolean is zoning required ( db client db client , virtual array nh ) { if ( nh . get auto san zoning ( ) == bool ) { log . info ( str + nh . get label ( ) ) ; return bool ; } return network util . are network system discovered ( db client ) ; }	looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .
private void init xml ( ) throws exception { update filtered tokens ( ) ; array list elements = get elements ( get filtered tokens ( ) ) ; if ( elements . size ( ) > num ) { throw new exception ( str ) ; } set root element ( ( xml ) elements . get ( num ) ) ; }	creats an in - memory xml tree based on the parsed tokens in this document .
public boolean has name value ( string name ) { return name value map . contains key ( name . to lower case ( ) ) ; }	returns a boolean telling if this namevaluelist has a record with this name.
public boolean starts with ( char seq prefix ) { return str . starts with ( prefix . str ) ; }	tests whether this charseq starts with the specified prefix.
public boolean contains window ( class < ? > window class ) { return ( get window ( window class ) != null ) ; }	checks , whether an instance of the given window class is already in the window list .
protected final void fire property change ( string property name , long old value , long new value ) { fire property change ( property name , long . value of ( old value ) , long . value of ( new value ) ) ; }	support for reporting bound property changes for integer properties.
public void fade to layer ( int index ) { m transition state = transition starting ; arrays . fill ( m is layer on , bool ) ; m is layer on [ index ] = bool ; invalidate self ( ) ; }	starts fading to the specified layer .
public static int hash code ( boolean [ ] field ) { return field == null || field . length == num ? num : arrays . hash code ( field ) ; }	computes the hash code of a repeated boolean field.
public abstract surface object ( abstract surface object source ) { super ( source ) ; this . visible = source . visible ; this . unique id = next unique id ( ) ; this . last modified time = system . current time millis ( ) ; this . enable batch picking = source . enable batch picking ; }	creates a shallow copy of the specified source shape .
public soot method and class parse soot method string ( string parse string ) { if ( ! parse string . starts with ( str ) || ! parse string . ends with ( str ) ) { throw new illegal argument exception ( str + parse string + str ) ; } string name = str ; string class name = str ; string return type = str ; pattern pattern = pattern . compile ( str ) ; matcher matcher = pattern . matcher ( parse string ) ; if ( matcher . find ( ) ) { class name = matcher . group ( num ) ; } pattern = pattern . compile ( str ) ; matcher = pattern . matcher ( parse string ) ; if ( matcher . find ( ) ) { return type = matcher . group ( num ) ; parse string = parse string . substring ( matcher . end ( num ) ) ; } pattern = pattern . compile ( str ) ; matcher = pattern . matcher ( parse string ) ; if ( matcher . find ( ) ) { name = matcher . group ( num ) ; } list < string > param list = new array list < string > ( ) ; pattern = pattern . compile ( str ) ; matcher = pattern . matcher ( parse string ) ; if ( matcher . find ( ) ) { string params = matcher . group ( num ) ; for ( string param : params . split ( str ) ) param list . add ( param . trim ( ) ) ; } return new soot method and class ( name , class name , return type , param list ) ; }	parses a string in soot representation , for example : < soot.
@ override public void startup ( ) throws exception { log . d ( mary . log , str ) ; list < string > voice names = mary properties . get list ( str ) ; for ( string voice name : voice names ) { long time = system . current time millis ( ) ; voice unit sel voice = new unit selection voice ( voice name , this ) ; log . d ( mary . log , str + unit sel voice + str ) ; voice . register voice ( unit sel voice ) ; long newtime = system . current time millis ( ) - time ; log . i ( mary . log , str + voice name + str + newtime + str ) ; } log . i ( mary . log , str ) ; }	start up the waveform synthesizer.
public int find start of column ( int column ) { if ( column == m columns ) return get space used ( ) ; int current column = num ; int current char index = num ; while ( bool ) { int new char index = current char index ; char c = m text [ new char index ++ ] ; boolean is high = character . is high surrogate ( c ) ; int code point = is high ? character . to code point ( c , m text [ new char index ++ ] ) : c ; int wcwidth = wc width . width ( code point ) ; if ( wcwidth > num ) { current column += wcwidth ; if ( current column == column ) { while ( new char index < m space used ) { if ( character . is high surrogate ( m text [ new char index ] ) ) { if ( wc width . width ( character . to code point ( m text [ new char index ] , m text [ new char index + num ] ) ) <= num ) { new char index += num ; } else { break ; } } else if ( wc width . width ( m text [ new char index ] ) <= num ) { new char index ++ ; } else { break ; } } return new char index ; } else if ( current column > column ) { return current char index ; } } current char index = new char index ; } }	note that the column may end of second half of wide character .
public static color decode ( string color , color default color ) { if ( color == null ) { return default color ; } color c = get named color ( color ) ; if ( c == null ) { try { c = color . decode ( color ) ; } catch ( number format exception ex ) { return default color ; } } return c ; }	decodes an html color and turns it into a color object.
public static linked list < mary module > modules required for processing ( mary data type source type , mary data type target type , locale locale , voice voice ) { if ( ! registration complete ) throw new illegal state exception ( str ) ; if ( source type == null ) throw new null pointer exception ( str ) ; if ( target type == null ) throw new null pointer exception ( str ) ; linked list < mary data type > seen types = new linked list < mary data type > ( ) ; seen types . add ( source type ) ; return modules required for processing ( source type , target type , locale , voice , seen types ) ; }	a method for determining the list of modules required to transform the given source data type into the requested target data type.
public double distance ( vector o ) { return math . sqrt ( number conversions . square ( x - o . x ) + number conversions . square ( y - o . y ) + number conversions . square ( z - o . z ) ) ; }	get the distance between this vector and another.
public static long calculate elapsed gc ( ) { long time millis = num ; for ( mx gcbean : gcbeans ) { time millis += gcbean . get collection time ( ) ; } return time millis ; }	ask each gc bean for its elapsed collection time.
public void close ( ) { }	flush and close the underlying java.
public static < v > int add distinct list ( list < v > source list , list < v > entry list ) { if ( source list == null || is empty ( entry list ) ) { return num ; } int source count = source list . size ( ) ; for ( v entry : entry list ) { if ( ! source list . contains ( entry ) ) { source list . add ( entry ) ; } } return source list . size ( ) - source count ; }	add all distinct entry to list1 from list2.
public void start object ( int numfields ) { not nested ( ) ; if ( vtable == null || vtable . length < numfields ) vtable = new int [ numfields ] ; vtable in use = numfields ; arrays . fill ( vtable , num , vtable in use , num ) ; nested = bool ; object start = offset ( ) ; }	start encoding a new object in the buffer.
private map < string , string > produce stream ( string topic ) { list < producer record < string , string > > messages = new array list < > ( event cnt ) ; map < string , string > key val map = new hash map < > ( ) ; for ( int evt = num ; evt < event cnt ; evt ++ ) { long runtime = system . current time millis ( ) ; string key = topic + str + string . value of ( evt ) ; string msg = runtime + string . value of ( evt ) ; messages . add ( new producer record < > ( topic , key , msg ) ) ; key val map . put ( key , msg ) ; } kafka broker . send messages ( messages ) ; return key val map ; }	sends messages to kafka .
public static string string of char ( char ch , int count ) { string buffer buf = new string buffer ( ) ; for ( int i = num ; i < count ; i ++ ) { buf . append ( ch ) ; } return buf . to string ( ) ; }	returns a string of the given length consisting entirely of the given character.
private void add connection view ( connection connection ) { platform impl . run and wait ( null ) ; }	add a view for the given connection to the pipeline view.
public static void trim ( char sequence a text , int [ ] a span ) { int begin = a span [ num ] ; int end = a span [ num ] - num ; char sequence data = a text ; while ( ( begin < ( data . length ( ) - num ) ) && trim char ( data . char at ( begin ) ) ) { begin ++ ; } while ( ( end > num ) && trim char ( data . char at ( end ) ) ) { end -- ; } end ++ ; a span [ num ] = begin ; a span [ num ] = end ; }	remove trailing or leading whitespace from the annotation .
public void add script finished listener ( script execution listener l ) { m . add ( l ) ; }	adds the given listener to its internal list .
public void on consume finished ( purchase purchase , iab result result ) ;	called to notify that a consumption has finished .
public void test get put byte array ( ) { final int size = num ; final i buf = new fixed byte array buffer ( size ) ; assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( size - num ) ) ; final int pos = num ; for ( int i = num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next int ( size - num ) ] ; r . next bytes ( expected ) ; buf . put ( pos , expected ) ; assert equals ( num , bytes util . compare bytes with len and offset ( num , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assert true ( bytes util . bytes equal ( expected , actual ) ) ; } assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( pos + size - num ) ) ; }	test of the simple forms of the bulk get / put methods .
public static double [ ] concat all double ( double [ ] ... arrays ) { int total length = num ; final int sub array count = arrays . length ; for ( int i = num ; i < sub array count ; ++ i ) { total length += arrays [ i ] . length ; } double [ ] result = arrays . copy of ( arrays [ num ] , total length ) ; int offset = arrays [ num ] . length ; for ( int i = num ; i < sub array count ; ++ i ) { system . arraycopy ( arrays [ i ] , num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of double arrays into a single array .
private t [ ] ensure capacity ( int min capacity ) { if ( tmp . length < min capacity ) { int new size = min capacity ; new size |= new size > > num ; new size |= new size > > num ; new size |= new size > > num ; new size |= new size > > num ; new size |= new size > > num ; new size ++ ; if ( new size < num ) new size = min capacity ; else new size = math . min ( new size , a . length > > > num ) ; t [ ] new array = ( t [ ] ) new object [ new size ] ; tmp = new array ; } return tmp ; }	ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary.
public synchronized void add ( string category , double min value , double max value ) { super . add ( category , min value ) ; m max values . add ( max value ) ; }	adds new values to the series .
public void cont ( int session number ) throws exception { this . max session number = math . max ( this . max session number , session number ) ; test elements . add ( new continuation element ( session number ) ) ; }	adds a continuation . to allow one thread to be used for testing .
public static double calc rotation angle in degrees ( f center pt , f target pt ) { double theta = math . atan2 ( target pt . y - center pt . y , target pt . x - center pt . x ) ; double angle = math . to degrees ( theta ) ; if ( angle < num ) { angle += num ; } return angle ; }	calculates the angle from centerpt to targetpt in degrees.
public int count in ( char sequence sequence ) { int count = num ; for ( int i = num ; i < sequence . length ( ) ; i ++ ) { if ( matches ( sequence . char at ( i ) ) ) { count ++ ; } } return count ; }	returns the number of matching characters found in a character sequence .
public crl ( int crl num ) throws io { super ( pkix . crl , bool , big integer . value of ( crl num ) , name , label ) ; }	creates a delta crl indicator extension with the integer value.
public static void v ( string tag , string s , object ... args ) { if ( log . verbose >= loglevel ) log . v ( tag , string . format ( s , args ) ) ; }	verbose log message with printf formatting .
static private double calc log prob ( int num appear , double mu ) { final double sigma = calc sigma from mu ( mu ) ; final double log num appear = math . log ( num appear ) ; final double over mu = math . max ( log num appear - mu , num ) ; final double res = - ( num / num ) * ( over mu * over mu ) / ( sigma * sigma ) - s log sqrt two pi - math . log ( sigma ) ; assert ( res <= num ) ; return res ; }	calculate the log probability given the message ' s logarithm is normally distributed.
@ override public pid with tolerance ( double tolerance ) { target = target . with tolerance ( math . abs ( tolerance ) ) ; return this ; }	sets the absolute tolerance for this controller .
protected final void drag drop finished ( final boolean success , final int operations , final int x , final int y ) { drag source event event = new drag source drop event ( get drag source context ( ) , operations & source actions , success , x , y ) ; event dispatcher dispatcher = new event dispatcher ( dispatch finish , event ) ; sun toolkit . invoke later on app context ( sun toolkit . target to app context ( get component ( ) ) , dispatcher ) ; start secondary event loop ( ) ; set native context ( num ) ; drag image = null ; drag image offset = null ; }	upcall from native code via implemented class ( do ).
@ override public byte [ ] write ( internal log log ) throws io { final byte [ ] rowkey = rowkey builder . build rowkey ( log ) ; final put p = new put ( rowkey ) ; populate column values ( p , log ) ; tbl . put ( p ) ; final list < byte [ ] > index rowkeys = log . get index rowkeys ( ) ; if ( index rowkeys != null ) { write indexes ( rowkey , index rowkeys ) ; } return rowkey ; }	todo need think about if multi - put is necessary , by checking if autoflush works.
private void insert into dynamic table ( int index , header entry ) { header list . add ( entry ) ; int delta = entry . hpack size ; if ( index != - num ) { delta -= dynamic table [ dynamic table index ( index ) ] . hpack size ; } if ( delta > max dynamic table byte count ) { clear dynamic table ( ) ; return ; } int bytes to recover = ( dynamic table byte count + delta ) - max dynamic table byte count ; int entries evicted = evict to recover bytes ( bytes to recover ) ; if ( index == - num ) { if ( header count + num > dynamic table . length ) { header [ ] doubled = new header [ dynamic table . length * num ] ; system . arraycopy ( dynamic table , num , doubled , dynamic table . length , dynamic table . length ) ; next header index = dynamic table . length - num ; dynamic table = doubled ; } index = next header index -- ; dynamic table [ index ] = entry ; header count ++ ; } else { index += dynamic table index ( index ) + entries evicted ; dynamic table [ index ] = entry ; } dynamic table byte count += delta ; }	index = = - 1 when new .
protected static string extract secret access key ( string s3uri ) { return s3uri . substring ( s3uri . index of ( str , s3uri . index of ( str ) + num ) + num , s3uri . index of ( str ) ) ; }	extracts the secretaccesskey from the given uri.
private void dial ( string contact information , boolean make the call , boolean use phone speaker ) { if ( contact information . equals ( str ) ) { string last recipient = recipient cmd . get last recipient number ( ) ; string last recipient name = recipient cmd . get last recipient name ( ) ; if ( last recipient != null ) { do dial ( last recipient name , last recipient , make the call , use phone speaker ) ; } else { send ( str ) ; } } else { resolved contact resolved contact = m contacts resolver . resolve contact ( contact information , contacts resolver . type all ) ; if ( resolved contact == null ) { send ( r . string . chat no match for , contact information ) ; } else if ( resolved contact . is distinct ( ) ) { do dial ( resolved contact . get name ( ) , resolved contact . get number ( ) , make the call , use phone speaker ) ; } else { ask for more details ( resolved contact . get candidates ( ) ) ; } } }	dial the specified contact.
public void add safe class ( soot class clz ) { safe classes . add ( clz . get name ( ) ) ; }	denote that all methods of a class are safe .
private boolean active list has room ( ) { int max downloads = num ; return m active list . size ( ) < max downloads ; }	check if there is room in the active list .
public boolean is running ( ) { return this . running ; }	return whether the stop watch is currently running .
protected static map < string , step > parse ( class < ? extends rslp > clazz , string resource ) { try { input stream is = clazz . get resource as stream ( resource ) ; line number reader r = new line number reader ( new input stream reader ( is , standard charsets . utf 8 ) ) ; map < string , step > steps = new hash map < > ( ) ; string step ; while ( ( step = read line ( r ) ) != null ) { step s = parse step ( r , step ) ; steps . put ( s . name , s ) ; } r . close ( ) ; return steps ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	parse a resource file into an rslp stemmer description .
public string bet to string ( ) { final string builder sb = new string builder ( ) ; sb . append ( amount ) ; sb . append ( str ) ; sb . append ( item name ) ; sb . append ( str ) ; sb . append ( target ) ; return sb . to string ( ) ; }	converts the bet into a string .
public void test non empty journal ( ) throws io , interrupted exception , execution exception { final file out = file . create temp file ( get name ( ) , options . jnl ) ; try { final journal src = get store ( get properties ( ) ) ; try { if ( ! ( src . get buffer strategy ( ) instanceof iha ) ) { return ; } src . write ( get random data ( num ) ) ; src . commit ( ) ; try { final i snapshot factory = new my snapshot factory ( get name ( ) , bool ) ; final future < i > f = src . snapshot ( snapshot factory ) ; final i snapshot result = f . get ( ) ; final file snapshot file = snapshot result . get file ( ) ; try { final journal tmp = open snapshot ( snapshot result ) ; assert equals ( src . get root block view ( ) , tmp . get root block view ( ) ) ; tmp . destroy ( ) ; } finally { if ( snapshot file . exists ( ) ) { snapshot file . delete ( ) ; } } } catch ( illegal argument exception ex ) { log . info ( str + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	verifies exception if there are no commits on the journal ( the lastcommittime will be zero which does not identify a valid commit point ) .
private boolean check match ip ( map < string , object > rows ) { boolean match ether = bool ; string val = ( string ) rows . get ( static flow entry pusher . column dl type ) ; if ( val != null ) { int type = num ; if ( val . starts with ( str ) ) { type = integer . parse int ( val . substring ( num ) , num ) ; } else { try { type = integer . parse int ( val ) ; } catch ( number format exception e ) { } } if ( type == num ) match ether = bool ; } if ( ( rows . contains key ( static flow entry pusher . column nw dst ) || rows . contains key ( static flow entry pusher . column nw src ) || rows . contains key ( static flow entry pusher . column nw proto ) || rows . contains key ( static flow entry pusher . column nw tos ) ) && ( match ether == bool ) ) return bool ; return bool ; }	checks to see if the user matches ip information without checking for the correct ether - type ( 2048 ) .
public static double pow quick ( double value , double power ) { if ( use jdk math ) { return strict math ? strict math . pow ( value , power ) : math . pow ( value , power ) ; } return fast math . exp ( power * fast math . log quick ( value ) ) ; }	quick pow , with a max relative error of about 3.
private string class to entry path ( class < ? > clazz ) { string name = str ; class < ? > parent ; while ( ( parent = clazz . get enclosing class ( ) ) != null ) { name = str + clazz . get simple name ( ) + name ; clazz = parent ; } return class name to entry path ( clazz . get canonical name ( ) + name ) ; }	utility method to get the jar entry path from a class name.
public static string write ( pos counter ) { return pos . write ( counter ) ; }	write an instance of posmikheevcounter class to json format.
private map < string , annotation mirror > annos in package ( package element package element ) { return create imported annotations map ( element filter . types in ( package element . get enclosed elements ( ) ) ) ; }	all annotations defined in the package.
public osm element paste from ( ) { list < way > ways = storage . get ways ( ) ; list < node > nodes = storage . get nodes ( ) ; if ( mode == mode . cut ) { reset ( ) ; if ( ways != null && ways . size ( ) == num ) { way w = ways . get ( num ) ; w . set state ( saved state ) ; for ( node nd : w . get nodes ( ) ) { log . d ( str , str + nd . get osm id ( ) ) ; nd . set state ( saved nd state . get ( nd ) ) ; } return w ; } else if ( nodes != null && nodes . size ( ) == num ) { node n = nodes . get ( num ) ; n . set state ( saved state ) ; return n ; } } else { if ( ways != null && ways . size ( ) == num ) { return ways . get ( num ) ; } else if ( nodes != null && nodes . size ( ) == num ) { return nodes . get ( num ) ; } } return null ; }	returns whatever is in the clipboard.
public final void update cursor ( ) { update pending . set ( bool ) ; update cursor impl ( ) ; }	sets the cursor to correspond the component currently under mouse.
public static boolean is middle mouse button ( mouse event an event ) { return ( ( an event . get modifiers ex ( ) & input event . butto down mask ) != num || an event . get button ( ) == mouse event . butto ) ; }	returns true if the mouse event specifies the middle mouse button .
public void add success message ( final string success message ) { success message list . add ( success message ) ; }	adds a success message into the list .
private void start stopped changed ( ) { clock . set start stopped ( start stopped check box . is selected ( ) ) ; changed = bool ; }	method to handle start stopped check box change.
public void close ( ) throws io { try { debug . message ( str , str ) ; if ( debug . debugging ( str ) ) { thread . sleep ( num ) ; } if ( input stream != null ) input stream . close ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } input stream = null ; }	closes the underlying file.
public static long next log segment sequence number ( list < log segment metadata > segment list desc ) { int last assigned log segment idx = - num ; long last assigned log segment seq no = null ; long next log segment seq no = null ; for ( int i = num ; i < segment list desc . size ( ) ; i ++ ) { log segment metadata metadata = segment list desc . get ( i ) ; if ( log segment metadata . supports log segment sequence no ( metadata . get version ( ) ) ) { last assigned log segment seq no = metadata . get log segment sequence number ( ) ; last assigned log segment idx = i ; break ; } } if ( null != last assigned log segment seq no ) { next log segment seq no = last assigned log segment seq no + last assigned log segment idx + num ; } return next log segment seq no ; }	assign next log segment sequence number based on a decreasing list of log segments .
public static void assert specific lang ( string specific lang ) throws xmp { if ( specific lang == null || specific lang . length ( ) == num ) { throw new xmp ( str , xmp . badparam ) ; } }	asserts that a specific language is set .
public int on block exploded ( ) { return ( int ) ( fuse time / num + math . random ( ) * fuse time / num ) ; }	called when the block for of this explosive is destroy by an explosion.
@ override public boolean has queued reader threads ( ) { return reader lock . has queued threads ( ) ; }	returns whether there are threads waiting for read access to the guacamole instruction stream .
public long inactive time millis ( ) { return system . current time millis ( ) - last time millis ; }	returns the number of milliseconds this session has been inactive .
public static void check ( boolean cond , object value ) { if ( ! cond ) error ( string . value of ( value ) ) ; }	equivalent to assert cond : value ;.
public void add definition ( icos cos def ) throws ums { if ( ! ( cos def instanceof cos ) ) { string msg = i18n . get string ( iums . invalid cosdefinition ) ; throw new ums ( msg ) ; } string [ ] cos attributes = cos def . get cos ( ) ; abstract collection a list = ( abstract collection ) arrays . as list ( icos . qualifiers ) ; for ( int i = num ; i < cos attributes . length ; i ++ ) { string cos attribute = null ; string qualifier = null ; string tokenizer st = new string tokenizer ( cos attributes [ i ] ) ; if ( st . has more tokens ( ) ) { cos attribute = st . next token ( ) ; } if ( cos attribute == null ) { string msg = i18n . get string ( iums . invalid cos attribute qualifier ) ; throw new ums ( msg ) ; } if ( st . has more tokens ( ) ) qualifier = st . next token ( ) ; if ( qualifier == null ) { qualifier = icos . qualifiers [ icos . default ] ; cos def . remove cos ( cos attribute ) ; cos def . add cos ( cos attribute , icos . default ) ; } if ( ! a list . contains ( qualifier ) ) { string msg = i18n . get string ( iums . invalid cos attribute qualifier ) ; throw new ums ( msg ) ; } } persistent object po = ( persistent object ) cos def ; parent object . add child ( po ) ; }	this method adds a cos definition to the persistent store.
public static source data quality from xml ( element dom element ) { node list fields = dom element . get child nodes ( ) ; int fields count = fields . get length ( ) ; string field name ; string field value string ; node field node ; source data quality result = new source data quality ( ) ; for ( int i = num ; i != fields count ; i ++ ) { field node = fields . item ( i ) ; if ( field node . get node type ( ) == node . element node ) { field name = field node . get node name ( ) ; node field value node = field node . get first child ( ) ; if ( field value node != null ) { field value string = field value node . get node value ( ) ; } else { field value string = str ; } if ( field name . equals ( xml element quality code ) ) { result . quality code = short . parse short ( field value string ) ; } else if ( field name . equals ( xml element quality desc ) ) { result . description = field value string ; } } } return result ; }	create a sourcedataquality object from its xml representation.
q to q ( class < ? > output class ) { string local part ; string namespace uri ; if ( output class . is annotation present ( xml root element . class ) ) { xml root element annotation = output class . get annotation ( xml root element . class ) ; local part = annotation . name ( ) ; namespace uri = annotation . namespace ( ) ; } else if ( output class . is annotation present ( xml type . class ) ) { xml type annotation = output class . get annotation ( xml type . class ) ; local part = annotation . name ( ) ; namespace uri = annotation . namespace ( ) ; } else { throw new illegal argument exception ( str + output class + str + str ) ; } if ( jaxb default annotation value . equals ( local part ) ) { local part = class utils . get short name as property ( output class ) ; } if ( jaxb default annotation value . equals ( namespace uri ) ) { package output class package = output class . get package ( ) ; if ( output class package != null && output class package . is annotation present ( xml schema . class ) ) { xml schema annotation = output class package . get annotation ( xml schema . class ) ; namespace uri = annotation . namespace ( ) ; } else { namespace uri = xml . null ns uri ; } } return new q ( namespace uri , local part ) ; }	returns the qualified name for the given class , according to the mapping rules in the jaxb specification .
private static string generate jwt ( string secret , string jwt id , string iss , integer ttl , map < string , string > claims ) throws hmac exception { try { return sign jwt ( secret , jwt id , ttl , iss , claims ) ; } catch ( jose e ) { e . print stack trace ( ) ; throw new hmac exception ( str , e ) ; } }	generate a new signed jwt.
public void export symbols ( string [ ] export names , symbol [ ] symbols ) { if ( exported symbols == null ) { exported symbols = new array list ( ) ; } for ( int i = num ; i < export names . length && i < symbols . length ; i ++ ) { exported symbols . add ( new exported symbol ( symbols [ i ] , export names [ i ] ) ) ; } }	export a number of symbols with the given names so that other movies can import and use them.
static boolean is fulfilling ( int m ) { return ( m & fulfilling ) != num ; }	returns true if m has fulfilling bit set .
@ override public synchronized void add data source listener ( data source listener dsl ) { m data source listeners . add element ( dsl ) ; if ( m format != null ) { data set event e = new data set event ( this , m format ) ; dsl . accept data set ( e ) ; } }	add a datasource listener.
public static annotation mirror find effective annotation in hierarchy ( final qualifier hierarchy qualifier hierarchy , final annotated type mirror to search , final annotation mirror top ) { return find effective annotation in hierarchy ( qualifier hierarchy , to search , top , bool ) ; }	when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds.
public boolean to fail ( ) { lifecycle state state ; synchronized ( this ) { state = state ; if ( state . is after destroying ( ) ) { return bool ; } state = failed ; last change time = current time . current time ( ) ; } if ( log != null && log . is loggable ( level ) ) log . log ( level , str + name ) ; notify listeners ( state , failed ) ; fail count ++ ; return bool ; }	changes to the failed state .
private static void read ( input stream in , byte [ ] buf , int pos , int n ) throws io { int read = num ; int res = num ; while ( read < n ) { res = in . read ( buf , read + pos , n - read ) ; if ( res > num ) { read += res ; } else { throw new io ( str + read + str + n ) ; } } }	read at least the specified amount of bytes , and place them in the input buffer .
public double evaluate ( vector instance x , vector instance y ) throws exception { vector instance diff = x . subtract ( y ) ; double result = - m gamma * diff . dot product ( diff ) ; return math . exp ( result ) ; }	compute the result of the kernel evaluation on the supplied vectors.
void parse finish ( ) { m children = m current group . get children ( ) ; }	ensure there is at least one animation for every path in group ( linking them by names ) build the " current " path based on the first group.
void cancel included only ( ) { if ( ! show all input ) { input all button . do click ( ) ; } if ( ! show all output ) { output all button . do click ( ) ; } if ( ! show all align ) { align all button . do click ( ) ; } }	cancels included only option.
list < entry > kill all ( boolean root included ) { list < entry > killed = new array list < > ( root included ? entries . size ( ) : entries . size ( ) - num ) ; entry entry ; for ( int i = entries . size ( ) - num ; i > ( root included ? - num : num ) ; i -- ) { entry = entries . get ( i ) ; if ( entry . dead ) continue ; entry . dead = bool ; if ( i != num ) { killed . add ( entry ) ; } } return killed ; }	kill all , including root or not the returned entries don ' t include the root entry though.
public static void create error dialog ( final string title , final string message ) { final alert alert = new alert ( alert type . error ) ; alert . set title ( title ) ; alert . set content text ( message ) ; alert . set header text ( null ) ; alert . show and wait ( ) ; }	shows an error dialog .
public static string check index header suffix ( data input in , string expected suffix ) throws io { int suffix length = in . read byte ( ) & num ; byte suffix bytes [ ] = new byte [ suffix length ] ; in . read bytes ( suffix bytes , num , suffix bytes . length ) ; string suffix = new string ( suffix bytes , num , suffix bytes . length , standard charsets . utf 8 ) ; if ( ! suffix . equals ( expected suffix ) ) { throw new corrupt index exception ( str + expected suffix + str + suffix , in ) ; } return suffix ; }	expert : just reads and verifies the suffix of an index header.
protected void tag ( string tag , array list names , array list values , int nattr , boolean close ) { spacing ( ) ; m out . print ( str ) ; m out . print ( tag ) ; for ( int i = num ; i < nattr ; ++ i ) { m out . print ( str ) ; m out . print ( ( string ) names . get ( i ) ) ; m out . print ( str ) ; m out . print ( str ) ; escape string ( ( string ) values . get ( i ) ) ; m out . print ( str ) ; } if ( close ) m out . print ( str ) ; m out . print ( str ) ; println ( ) ; if ( ! close ) { m tag stack . add ( tag ) ; } }	internal method for printing a tag with attributes .
public static string parse disk string ( string input ) { string delims = str ; string [ ] tokens = input . split ( delims ) ; return tokens [ num ] ; }	get the disk name out from the input string .
private static boolean is trusted ( object obj , trust verifier . context ctx ) throws remote exception { object saved = state . get ( ) ; try { state . set ( obj ) ; return ctx . is trusted object ( obj ) ; } finally { state . set ( saved ) ; } }	returns result of calling ctx.
public static persistent search request control new control ( final boolean is critical , final boolean changes only , final boolean return e , final persistent search change type ... change types ) { reject . if null ( ( object ) change types ) ; return new control ( is critical , changes only , return e , arrays . as list ( change types ) ) ; }	creates a new persistent search request control .
private void connect equalized ( synapse group synapse group ) { current ordering indices = new int [ source neurons . length ] ; int num connects per src ; int expected num syns ; if ( synapse group . is recurrent ( ) && ! self connection allowed ) { num connects per src = ( int ) ( connection density * ( source neurons . length - num ) ) ; } else { num connects per src = ( int ) ( connection density * target neurons . length ) ; } expected num syns = num connects per src * source neurons . length ; synapse group . pre allocate synapses ( expected num syns ) ; for ( int i = num , n = source neurons . length ; i < n ; i ++ ) { current ordering indices [ i ] = num connects per src ; neuron src = source neurons [ i ] ; neuron tar ; for ( int j = num ; j < num connects per src ; j ++ ) { tar = target neurons [ sparse ordering [ i ] [ j ] ] ; synapse s = new synapse ( src , tar ) ; synapse group . add new synapse ( s ) ; } } }	populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group ' s source and target groups.
public static number multiply ( character left , character right ) { return multiply ( integer . value of ( left ) , right ) ; }	multiply two characters . the ordinal values of the characters are used in the multiplication ( the ordinal value is the unicode value which for simple character sets is the ascii value ) .
public static string normalize ( final char sequence self ) { final string s = self . to string ( ) ; int nx = s . index of ( str ) ; if ( nx < num ) { return s ; } final int len = s . length ( ) ; final string builder sb = new string builder ( len ) ; int i = num ; do { sb . append ( s , i , nx ) ; sb . append ( str ) ; if ( ( i = nx + num ) >= len ) break ; if ( s . char at ( i ) == str ) { if ( ++ i >= len ) break ; } nx = s . index of ( str , i ) ; } while ( nx > num ) ; sb . append ( s , i , len ) ; return sb . to string ( ) ; }	return a string with linefeeds and carriage returns normalized to linefeeds .
public void add zone change listener ( zone change listener listener ) { zone change listeners . add ( listener ) ; }	add a listener to be called when the player changes zone .
public void write ( final int b ) throws io { if ( m store == null ) { throw new illegal state exception ( err no store ) ; } if ( m is saved ) { throw new illegal state exception ( err already saved ) ; } if ( m count == m blob threshold && ! m writing hdr ) { if ( m blob header == null ) { m blob header = new array list < integer > ( ) ; } final int cur addr = ( int ) m store . alloc ( m buf , m count , m context ) ; m blob header . add ( cur addr ) ; m count = num ; } m buf [ m count ++ ] = ( byte ) b ; m bytes written ++ ; }	write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .
public start listener ( object resource ) { resource = resource ; }	creates the new start listener .
public list < t > as flat list ( ) { list < t > list = new array list < t > ( ) ; for ( int i = num ; i < get row count ( ) ; i ++ ) { for ( int j = num ; j < get column count ( ) ; j ++ ) { list . add ( get logical value at ( i , j ) ) ; } } return list ; }	returns the contents of the table as a flat list .
@ beta public void reset ( ) { schedulers hook . set ( null ) ; }	reset any explicit or default - set hooks.
public static string hash key for disk ( string key ) { string cache key ; try { final message digest m digest = message digest . get instance ( str ) ; m digest . update ( key . get bytes ( ) ) ; cache key = bytes to hex string ( m digest . digest ( ) ) ; } catch ( no such algorithm exception e ) { cache key = string . value of ( key . hash code ( ) ) ; } return cache key ; }	a hashing method that changes a string ( like a url ) into a hash suitable for using as a disk filename .
public void record timestamp ( ) { long cur timestamp = system . current time millis ( ) ; if ( used fields > num ) { long diff = cur timestamp - last value ; if ( used fields == diffs . length ) { long removed value = diffs [ cur position ] ; diffs [ cur position ] = diff ; calculate new average ( removed value , diff , bool ) ; shift end ( ) ; } else { calculate new average ( num , diff , bool ) ; diffs [ cur position ] = diff ; shift end ( ) ; } } else if ( last value != - num ) { long diff = cur timestamp - last value ; current average = num ; diffs [ cur position ] = diff ; calculate new average ( num , diff , bool ) ; shift end ( ) ; } last value = cur timestamp ; }	adds a value and calculates the new average of differences between the values within the window size provided at creation .
@ after method public void tear down ( ) throws exception { throwable t = thread failure . get and set ( null ) ; if ( t != null ) { if ( t instanceof error ) throw ( error ) t ; else if ( t instanceof runtime exception ) throw ( runtime exception ) t ; else if ( t instanceof exception ) throw ( exception ) t ; else { assertion failed error afe = new assertion failed error ( t . to string ( ) ) ; afe . init cause ( t ) ; throw afe ; } } if ( thread . interrupted ( ) ) tear down fail ( str ) ; check fork join pool thread leaks ( ) ; }	extra checks that get done for all test cases.
public void parse ( string string ) { if ( string == null ) { throw new null pointer exception ( str ) ; } int buffer size = math . max ( min buffer size , math . min ( default buffer size , string . length ( ) ) ) ; try { parse ( new string reader ( string ) , buffer size ) ; } catch ( io exception ) { throw new runtime exception ( exception ) ; } }	parses the given input string.
protected double default max radius ( ) { return math . sqrt ( num ) ; }	returns the default max radius.
public char [ ] to char array ( ) { char [ ] new value = new char [ count ] ; system . arraycopy ( buf , num , new value , num , count ) ; return new value ; }	returns a copy of the input data .
@ override protected int size pending workers ( ) { return pending workers . size ( ) ; }	the size of pending workers.
public void insert ( component component , int index ) { if ( index < num ) { throw new illegal argument exception ( str ) ; } int nitems = get component count ( ) ; vector < component > temp items = new vector < component > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { temp items . add element ( get component ( index ) ) ; remove ( index ) ; } add ( component ) ; for ( component temp item : temp items ) { add ( temp item ) ; } }	inserts the specified component into the menu at a given position .
public static list < string > unescape ( string source , char escape char , char [ ] special characters , char split character , int split limit ) { list < string > result = new linked list < > ( ) ; string builder b = new string builder ( ) ; boolean read escape = bool ; int index count = - num ; for ( char c : source . to char array ( ) ) { index count ++ ; if ( read escape ) { boolean found = bool ; if ( c == split character ) { found = bool ; b . append ( c ) ; } else if ( c == escape char ) { found = bool ; b . append ( c ) ; } else { for ( char s : special characters ) { if ( s == c ) { found = bool ; b . append ( c ) ; break ; } } } if ( ! found ) { throw new illegal argument exception ( str + source + str + c + str ) ; } read escape = bool ; } else if ( c == escape char ) { read escape = bool ; } else if ( c == split character ) { read escape = bool ; result . add ( b . to string ( ) ) ; if ( split limit != - num ) { if ( result . size ( ) == split limit - num ) { result . add ( source . substring ( index count + num ) ) ; return result ; } } b = new string builder ( ) ; } else { read escape = bool ; b . append ( c ) ; } } result . add ( b . to string ( ) ) ; return result ; }	splits the string at every split character unless escaped.
@ override public string append ( string path , input stream is ) throws url , io , authentication exception { string resp = null ; ensure valid token ( ) ; string spec = message format . format ( str , url . encode path ( path ) , this . principal ) ; string redirect url = null ; url conn = authenticated url . open connection ( new url ( new url ( httpfs url ) , spec ) , token ) ; conn . set request method ( str ) ; conn . set instance follow redirects ( bool ) ; conn . connect ( ) ; logger . info ( str + conn . get header field ( str ) ) ; resp = result ( conn , bool ) ; if ( conn . get response code ( ) == num ) redirect url = conn . get header field ( str ) ; conn . disconnect ( ) ; if ( redirect url != null ) { conn = authenticated url . open connection ( new url ( redirect url ) , token ) ; conn . set request method ( str ) ; conn . set do output ( bool ) ; conn . set do input ( bool ) ; conn . set use caches ( bool ) ; conn . set request property ( str , str ) ; final int size = is . available ( ) ; conn . set request property ( str , str + size ) ; conn . set fixed length streaming mode ( size ) ; conn . connect ( ) ; output stream os = conn . get output stream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , bool ) ; conn . disconnect ( ) ; } return resp ; }	curl - i - x post " http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ] ".
public economy concurrent hash map ( map < ? extends k , ? extends v > m , i < k , v > handler ) { this ( math . max ( ( int ) ( m . size ( ) / default load factor ) + num , default initial capacity ) , default load factor , default concurrency level , handler ) ; put all ( m ) ; }	creates a new map with the same mappings as the given map.
void add rule ( string [ ] selector , attribute set declaration , boolean is linked ) { int n = selector . length ; string builder sb = new string builder ( ) ; sb . append ( selector [ num ] ) ; for ( int counter = num ; counter < n ; counter ++ ) { sb . append ( str ) ; sb . append ( selector [ counter ] ) ; } string selector name = sb . to string ( ) ; style rule = get style ( selector name ) ; if ( rule == null ) { style alt rule = add style ( selector name , null ) ; synchronized ( this ) { selector mapping mapping = get root selector mapping ( ) ; for ( int i = n - num ; i >= num ; i -- ) { mapping = mapping . get child selector mapping ( selector [ i ] , bool ) ; } rule = mapping . get style ( ) ; if ( rule == null ) { rule = alt rule ; mapping . set style ( rule ) ; refresh resolved rules ( selector name , selector , rule , mapping . get specificity ( ) ) ; } } } if ( is linked ) { rule = get linked style ( rule ) ; } rule . add attributes ( declaration ) ; }	adds a rule into the stylesheet .
public builder append read data ( byte [ ] data ) { assertions . check state ( data != null && data . length > num ) ; segments . add ( new segment ( data , null ) ) ; return this ; }	appends to the underlying data .
private boolean is latest dss keystore ( tsl parse result ) { list < string > english scheme information ur = parse result . get english scheme information ur ( ) ; return english scheme information ur . contains ( oj url ) ; }	this method checks if the oj url is still correct.
private synchronized void init resource bundle ( string resource bundle name ) { string current = this . resource bundle name ; if ( current != null ) { if ( current . equals ( resource bundle name ) ) { return ; } else { throw new illegal argument exception ( str + resource bundle name + str + current + str ) ; } } if ( resource bundle name != null ) { this . resource bundle = load resource bundle ( resource bundle name ) ; this . resource bundle name = resource bundle name ; } }	initializes this logger ' s resource bundle .
public layer graphic warehouse support ( ) { init drawing attributes ( ) ; graphics = new om ( ) ; graphics . set traverse mode ( om . last added on top ) ; }	construct an object , initializes graphiclist.
public boolean matches naming convension ( ) { return package name . matches ( java package convension ) ; }	check whether the package name match standard java package name conventions .
void remember factory ( string host , rmi factory ) { synchronized ( success table ) { while ( host list . size ( ) >= max remembered hosts ) { success table . remove ( host list . element at ( num ) ) ; host list . remove element at ( num ) ; } host list . add element ( host ) ; success table . put ( host , factory ) ; } }	remember a successful factory for connecting to host.
public char next ( ) { return pos < in . length ( ) ? in . char at ( pos ++ ) : str ; }	returns the next available character , or the null character ' \ 0 ' if all input has been exhausted.
private map . entry < k , v > do remove first entry ( ) { for ( node < k , v > b , n ; ; ) { if ( ( n = ( b = head . node ) . next ) == null ) return null ; node < k , v > f = n . next ; if ( n != b . next ) continue ; object v = n . value ; if ( v == null ) { n . help delete ( b , f ) ; continue ; } if ( ! n . cas value ( v , null ) ) continue ; if ( ! n . append marker ( f ) || ! b . cas next ( n , f ) ) find first ( ) ; clear index to first ( ) ; @ suppress warnings ( str ) v vv = ( v ) v ; return new abstract map . simple immutable entry < k , v > ( n . key , vv ) ; } }	removes first entry ; returns its snapshot .
public compute task cancelled exception ( throwable cause ) { this ( cause . get message ( ) , cause ) ; }	creates new task cancellation exception given throwable as a cause and source of error message .
public static int normalize ( char [ ] src , int src start , int src limit , char [ ] dest , int dest start , int dest limit , mode mode , int options ) { int length = mode . normalize ( src , src start , src limit , dest , dest start , dest limit , options ) ; if ( length <= ( dest limit - dest start ) ) { return length ; } else { throw new index out of bounds exception ( integer . to string ( length ) ) ; } }	normalize a string . the string will be normalized according the the specified normalization mode and options .
private void remove obsolete elements ( list < string > names , map < string , view > shared elements , list < string > elements to remove ) { if ( elements to remove . size ( ) > num ) { names . remove all ( elements to remove ) ; for ( string element to remove : elements to remove ) { shared elements . remove ( element to remove ) ; } } }	removes obsolete elements from names and shared elements .
public void remove action ( network update action action ) { action list . remove ( action ) ; for ( update manager listener listener : listeners ) { listener . action removed ( action ) ; } }	completely remove an action .
public static double buffer distance error ( int quad segs ) { double alpha = math . pi / num / quad segs ; return num - math . cos ( alpha / num ) ; }	computes the maximum distance error due to a given level of approximation to a true arc .
public pair < string , string > next ( ) { try { current header position = next header position ; string read header = next line ; next header position += read header . length ( ) + end of line bytes ; read header = str + read header . substring ( num ) ; string read sequence = r . read line ( ) ; next header position += read sequence . length ( ) + end of line bytes ; string comments = r . read line ( ) ; next header position += comments . length ( ) + end of line bytes ; if ( comments . starts with ( str ) ) { string quality values = r . read line ( ) ; next header position += quality values . length ( ) + end of line bytes ; } next line = r . read line ( ) ; return new pair < > ( read header , read sequence ) ; } catch ( io e ) { basic . caught ( e ) ; } return null ; }	gets next fasta record.
public void add ( character character ) { elements . add ( character == null ? json null . instance : new json primitive ( character ) ) ; }	adds the specified character to self .
public static boolean is valid ifd ( int ifd id ) { return ifd id == ifd id . type ifd 0 || ifd id == ifd id . type ifd 1 || ifd id == ifd id . type ifd exif || ifd id == ifd id . type ifd interoperability || ifd id == ifd id . type ifd gps ; }	returns true if the given ifd is a valid ifd .
public void remove child ( group the group ) { m children . remove ( the group ) ; }	remove a child from this group.
protected storage port check port exists in db ( string native guid ) throws io { storage port port = null ; list < storage port > port in db = custom query utility . get active storage port by native guid ( db client , native guid ) ; if ( port in db != null && ! port in db . is empty ( ) ) { port = port in db . get ( num ) ; } return port ; }	check if port exists in db .
public void append split element ( fragment a split ) { splits . add ( a split ) ; }	adds a split element at the end.
public osm handler ( map builder me consumer ) { osm element processor = new osm element processor ( null , me consumer ) ; }	creates a new instance .
public void close ( ) throws io { flush bits ( ) ; out . close ( ) ; }	description of the method.
public respoke direct connection direct connection ( ) { if ( null != direct connection reference ) { return direct connection reference . get ( ) ; } else { return null ; } }	get the active direct connection with this endpoint ( if any ).
private string append national number ( string national number ) { int prefix before national number length = prefix before national number . length ( ) ; if ( should add space after national prefix && prefix before national number length > num && prefix before national number . char at ( prefix before national number length - num ) != separator before national number ) { return new string ( prefix before national number ) + separator before national number + national number ; } else { return prefix before national number + national number ; } }	combines the national number with any prefix ( idd / + and country code or national prefix ) that was collected.
public void cut ( ) { copy ( ) ; delete selected objects ( ) ; }	cut to the clipboard .
public void stop ( ) { set led on ( bool ) ; if ( null != blink future ) { blink future . cancel ( bool ) ; } if ( null != blink service ) { blink service . shutdown now ( ) ; } }	calling this method will stop all threads.
public synchronized void release ( ) { index . clear ( ) ; }	releases resources in the index .
public void configure ( ) { if ( cmd prefix != null ) { prefix = cmd prefix . split ( str ) ; } }	configure the helper . this must called before executing any commands .
protected void write transform ( affine transform t ) throws io { page stream . matrix ( t ) ; }	write the given transformation matrix to the file .
public void test signum positive ( ) { string a = str ; int a scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; assert equals ( str , num , a number . signum ( ) ) ; }	signum ( ) for a positive bigdecimal.
public painter chain prepend painter ( painter p ) { painter [ ] new chain = new painter [ chain . length + num ] ; system . arraycopy ( chain , num , new chain , num , chain . length ) ; new chain [ num ] = p ; return new painter chain ( new chain ) ; }	creates a new chain based on the existing chain with the new element added at the beginning.
@ nullable private operator . kind parse operator ( token stream tokens ) { if ( tokens . has ( str ) ) { tokens . next ( ) ; tokens . expect ( str ) ; return operator . kind . equals ; } if ( tokens . has ( str ) ) { tokens . next ( ) ; tokens . expect ( str ) ; return operator . kind . not equals ; } if ( tokens . has ( str ) ) { tokens . next ( ) ; if ( tokens . has ( str ) ) { tokens . next ( ) ; return operator . kind . less equal ; } return operator . kind . less ; } if ( tokens . has ( str ) ) { tokens . next ( ) ; if ( tokens . has ( str ) ) { tokens . next ( ) ; return operator . kind . greater equal ; } return operator . kind . greater ; } return null ; }	check for and get an operator kind .
@ override public boolean drag to ( selector obj , selector dest obj , int steps ) throws ui object not found exception , not implemented exception { return drag to ( device . find object ( obj . to ui selector ( ) ) , dest obj , steps ) ; }	drags this object to a destination uiobject.
private void queue up syncs ( final cursor contacts cursor ) { contact sync entry sync entry = null ; while ( contacts cursor . move to next ( ) ) { if ( sync entry == null ) { sync entry = new contact sync entry ( upload batch size ) ; } final string number = contacts cursor . get string ( contacts cursor . get column index ( contacts contract . common data kinds . phone . number ) ) ; final string name = contacts cursor . get string ( contacts cursor . get column index ( contacts contract . common data kinds . phone . display name ) ) ; if ( ! text utils . is empty ( number ) ) { sync entry . add number ( number to national ( number ) ) ; sync entry . add name ( name ) ; if ( sync entry . is full ( ) ) { logger . d ( tag , str ) ; m sync queue . add ( sync entry ) ; sync entry = null ; } } } }	method that hashes contacts and syncs them to server.
public synchronized void remove series ( int index ) { m series . remove ( index ) ; }	removes the xy series from the list .
public static void add glue ( j b , int layout ) { b . add ( get axis ( b , layout ) == box layout . x axis ? box . create horizontal glue ( ) : box . create vertical glue ( ) ) ; }	add a glue , or variable spacing , to a ui component.
public static void write result to file ( result result , string fname ) throws exception { print writer outer = new print writer ( new buffered writer ( new file writer ( fname ) ) ) ; outer . write ( result . to string ( ) ) ; outer . close ( ) ; }	writeresulttofile - - write a result ' result ' out in plain text format to file ' fname ' .
private jmx ( ) { }	don ' t let anyone instantiate this class .
protected void write blocklet info to file ( list < blocklet info columnar > info list , file channel channel , string file path ) throws carbon data writer exception { try { long current position = channel . size ( ) ; carbon footer writer writer = new carbon footer writer ( file path ) ; file footer convert file meta = carbon metadata util . convert file footer ( info list , local cardinality . length , local cardinality , thrift column schema list , segment properties ) ; fill block index info details ( info list , convert file meta . get num rows ( ) , file path , current position ) ; writer . write footer ( convert file meta , current position ) ; } catch ( io e ) { throw new carbon data writer exception ( str , e ) ; } }	this method will write metadata at the end of file file format in thrift format.
private static void render tree ( tree tree , int indent , boolean parent label null , boolean first sibling , boolean left sibling pre terminal , boolean top level , string builder sb ) { boolean suppress indent = ( parent label null || ( first sibling && tree . is pre terminal ( ) ) || ( left sibling pre terminal && tree . is pre terminal ( ) ) ) ; if ( suppress indent ) { sb . append ( str ) ; } else { if ( ! top level ) { sb . append ( str ) ; } for ( int i = num ; i < indent ; i ++ ) { sb . append ( str ) ; } } if ( tree . is leaf ( ) || tree . is pre terminal ( ) ) { render flat ( tree , sb ) ; return ; } sb . append ( str ) ; sb . append ( tree . get label ( ) ) ; render children ( tree . get children ( ) , indent + num , bool , sb ) ; sb . append ( str ) ; }	display a node , implementing penn treebank style layout.
public static string buffer replace regex ( string buffer original , string regex , string replace , boolean case insensitive ) { int flags = num ; if ( case insensitive ) flags = pattern . case insensitive ; pattern p = pattern . compile ( regex , flags ) ; matcher m = p . matcher ( original ) ; string buffer new sb = new string buffer ( ) ; boolean result = m . find ( ) ; while ( result ) { m . append replacement ( new sb , replace ) ; result = m . find ( ) ; } m . append tail ( new sb ) ; return new sb ; }	run regex expression against original string.
public boolean equals chars ( string a , int ai , string b , int bi , boolean ignore case ) { char ca = a . char at ( ai ) ; char cb = b . char at ( bi ) ; if ( ignore case ) { ca = character . to upper case ( ca ) ; cb = character . to upper case ( cb ) ; } return ca == cb ; }	compare two characters in a string .
private void adjust backing file length ( byte [ ] buffer , long index ) throws io { if ( buffer == null || buffer . length == num ) { throw new io ( str ) ; } long newsize = f header . header size ( ) + ( index * chunk enc size ) + chunk iv size + buffer . length + chunk tlen ; if ( newsize > real length ( ) ) { backing random access file . set length ( newsize ) ; } }	helper methods which adjusts the actual length of the backing file for caching.
private static collection < collection < dsn net pin > > create ordered subnets ( collection < dsn net pin > p pin list ) { collection < collection < dsn net pin > > result = new linked list < collection < dsn net pin > > ( ) ; if ( p pin list . is empty ( ) ) { return result ; } iterator < dsn net pin > it = p pin list . iterator ( ) ; dsn net pin prev pin = it . next ( ) ; while ( it . has next ( ) ) { dsn net pin next pin = it . next ( ) ; set < dsn net pin > curr subnet pin list = new java . util . tree set < dsn net pin > ( ) ; curr subnet pin list . add ( prev pin ) ; curr subnet pin list . add ( next pin ) ; result . add ( curr subnet pin list ) ; prev pin = next pin ; } return result ; }	creates a sequence of subnets with 2 pins from p_pin_list.
private static string create js method invocation expression ( string method name , boolean is static , string ... param names ) { string builder sb = new string builder ( ) ; sb . append ( is static ? wnd : this ) ; sb . append ( str ) ; sb . append ( method name ) ; sb . append ( str ) ; for ( int i = num ; i < param names . length ; i ++ ) { if ( i != num ) { sb . append ( str ) ; } sb . append ( param names [ i ] ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	creates a jsni method invocation expression .
public void do double click action ( ) { do double click action ( null ) ; }	launches an dialog allowing the user to pick a new name for this variable , where no constraints are placed on the name .
public static node serializable instance ( ) { return new graph node ( str ) ; }	generates a simple exemplar of this class to test serialization .
protected void drop tables ( list < string > drop table names , sq db ) { if ( drop table names != null && ! drop table names . is empty ( ) ) { string [ ] drop table sqls = new string [ drop table names . size ( ) ] ; for ( int i = num ; i < drop table sqls . length ; i ++ ) { drop table sqls [ i ] = generate drop table sql ( drop table names . get ( i ) ) ; } execute ( drop table sqls , db ) ; } }	drop the tables by the passing table name .
private segment create disk segment ( segment descriptor descriptor ) { file segment file = segment file . create segment file ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = file buffer . allocate ( segment file , math . min ( default buffer size , descriptor . max segment size ( ) ) , integer . max value ) ; descriptor . copy to ( buffer ) ; segment segment = new segment ( new segment file ( segment file ) , buffer . slice ( ) , descriptor , create index ( descriptor ) , new offset predicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( str , segment ) ; return segment ; }	creates a new segment .
public boolean exists ( string email ) { for ( person person : people ) { if ( email . equals ( person . get email ( ) ) ) { return bool ; } } return bool ; }	given an email checks if the person exists in the manager .
private double max ignore na n ( double a , double b ) { if ( double . is na n ( a ) ) { return b ; } if ( double . is na n ( b ) ) { return a ; } else { return math . max ( a , b ) ; } }	a function to find the maximum of two values , but ignoring any double.
public void crab down dir block for modification ( block id blk ) { lock tbl . x lock ( blk , tx num ) ; writen index blks . add ( blk ) ; }	sets exclusive lock on the directory block when crabbing down for modification .
private static void remove reference to connection ( final http connection with reference connection ) { synchronized ( reference to connection source ) { reference to connection source . remove ( connection . reference ) ; } }	removes the reference being stored for the given connection.
public boolean matches word ( ) { return ! is empty ( ) && character . is letter or digit ( queue . char at ( pos ) ) ; }	test if the queue matches a word character ( letter or digit ) .
public vacuum environment ( ) { random r = new random ( ) ; env state = new vacuum environment state ( num == r . next int ( num ) ? location state . clean : location state . dirty , num == r . next int ( num ) ? location state . clean : location state . dirty ) ; }	constructs a vacuum environment with two locations , in which dirt is placed at random .
public void generate ( batch environment env , class definition cdef , file dest dir ) { remote class remote class = remote class . for class ( env , cdef ) ; if ( remote class == null ) return ; rmi gen ; try { gen = new rmi ( env , cdef , dest dir , remote class , version ) ; } catch ( class not found e ) { env . error ( num , str , e . name ) ; return ; } gen . generate ( ) ; }	generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .
public base view holder add on long click listener ( int view id ) { item child long click view ids . add ( view id ) ; return this ; }	add long click view id.
public void remove ( final creature respawn point point ) { respawn points . remove ( point ) ; }	remove a creature respawn point from the zone .
public photo ( file d , file f ) throws io , number format exception { extended exif interface exif = new extended exif interface ( f . to string ( ) ) ; string lon str = exif . get attribute ( exif interface . tag gps longitude ) ; if ( lon str == null ) { throw new io ( str ) ; } float lonf = convert to degree ( lon str ) ; string lon ref = exif . get attribute ( exif interface . tag gps longitude ref ) ; if ( lon ref != null && ! lon ref . equals ( str ) ) { lonf = - lonf ; } float latf = convert to degree ( exif . get attribute ( exif interface . tag gps latitude ) ) ; string lat ref = exif . get attribute ( exif interface . tag gps latitude ref ) ; if ( lat ref != null && ! lat ref . equals ( str ) ) { latf = - latf ; } lat = ( int ) ( latf * num ) ; lon = ( int ) ( lonf * num ) ; log . d ( str , str + lat + str + lon ) ; ref = d . get absolute path ( ) + str + f . get name ( ) ; string dir = exif . get attribute ( extended exif interface . tag gps img direction ) ; if ( dir != null ) { direction = ( int ) double . parse double ( dir ) ; direction ref = exif . get attribute ( extended exif interface . tag gps img direction ref ) ; log . d ( str , str + dir + str + direction + str + direction ref ) ; } }	create a bug from an osb gpx xml wpt element .
public static long bytes to long ( final byte [ ] bytes ) { final byte buffer buffer = byte buffer . allocate ( num ) ; buffer . put ( bytes , num , num ) ; buffer . flip ( ) ; return buffer . get long ( ) ; }	converts an array of 8 bytes into a long .
protected int unicode escape lexer ( int c ) throws io { int ret = num ; c = in . read ( ) ; code . clear ( ) ; try { for ( int i = num ; i < num ; i ++ ) { c = in . read ( ) ; if ( is end of file ( c ) || is end of line ( c ) ) { throw new number format exception ( str ) ; } code . append ( ( char ) c ) ; } ret = integer . parse int ( code . to string ( ) , num ) ; } catch ( number format exception e ) { throw new io ( str + get line number ( ) + str + code . to string ( ) + str + e . to string ( ) ) ; } return ret ; }	decodes unicode escapes . interpretation of " \ \ uxxxx " escape sequences where xxxx is a hex - number .
@ override public void mouse entered ( mouse event evt ) { delegate . mouse moved ( evt ) ; }	pass mouseevent straight through to delegate.
public static string remove formatting ( string line ) { int length = line . length ( ) ; string builder buffer = new string builder ( ) ; for ( int i = num ; i < length ; i ++ ) { char ch = line . char at ( i ) ; if ( ch != str && ch != str && ch != str && ch != str ) buffer . append ( ch ) ; } return buffer . to string ( ) ; }	remove formatting from a line of irc text .
public void test neg pos first shorter ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for two negative numbers ; the first is shorter.
public void print ( ) { object [ ] iter charging times = charging times . to array ( ) ; arrays . sort ( iter charging times ) ; for ( int i = num ; i < iter charging times . length ; i ++ ) { charge log cur item = ( charge log ) iter charging times [ i ] ; cur item . print ( ) ; } }	just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .
public boolean is empty ( ) { return rdns . is empty ( ) ; }	determines whether this ldap name is empty.
private void write local csv ( medtronic sensor record most recent data , context context ) { try { if ( most recent data == null || most recent data . b g == null ) log . debug ( str ) ; else log . debug ( str + most recent data . b g ) ; object output stream oos = new object output stream ( new file output stream ( new file ( context . get files dir ( ) , str ) ) ) ; oos . write object ( most recent data ) ; oos . flush ( ) ; oos . close ( ) ; } catch ( exception e ) { log . e ( tag , str , e ) ; log . error ( str , e ) ; } }	this method saves a file with the last record read from the device.
public service config create organization config ( string org name , map attrs ) throws sms , sso { validate ssm ( ) ; service schema impl ss = ssm . get schema ( schema type . organization ) ; if ( ss == null ) { string [ ] args = { service name } ; throw ( new sms ( iums . ums bundle name , str , args ) ) ; } string orgdn = dn . org name to dn ( org name ) ; create service config . check base nodes for org ( token , orgdn , service name , version ) ; string org dn = scm . construct service config dn ( sms . default , create service config . org config node , orgdn ) ; try { sms c entry = sms . get instance ( token , org dn ) ; if ( c entry . is dirty ( ) ) { c entry . refresh ( ) ; } if ( c entry . is new entry ( ) ) { create service config . create sub config entry ( token , org dn , ss , null , null , attrs , org name ) ; if ( service manager . is coexistence mode ( ) ) { string sms dn = dn . org name to dn ( org name ) ; amsdk amsdk = new amsdk ( token , dn . realm name to amsdk ( sms dn ) , sms dn ) ; amsdk . assign service ( service name ) ; } } else if ( attrs != null && ! attrs . is empty ( ) ) { service config sc = get organization config ( org name , null ) ; sc . set attributes ( attrs ) ; } } catch ( service already exists exception slee ) { } return ( get organization config ( org name , null ) ) ; }	creates organization configuration for the default instance of the service given configuration attributes .
public void delete authentication domain ( string realm , string cot name ) throws am { string [ ] param = { realm , cot name } ; log event ( str , param ) ; try { circle of trust manager manager = get circle of trust manager ( ) ; manager . delete circle of trust ( realm , cot name ) ; log event ( str , param ) ; } catch ( cot e ) { string str error = get error string ( e ) ; string [ ] params ex = { realm , cot name , str error } ; log event ( str , params ex ) ; throw new am ( str error ) ; } }	deletes an authentication domain ( circle of trust ) within a given realm .
protected void add source code remark ( test solution test solution , element element , string message code , evidence element evidence element ) { if ( evidence element != null ) { collection < evidence element > evidence element list = new array list < > ( ) ; evidence element list . add ( evidence element ) ; process remark service . add source code remark on element ( test solution , element , message code , evidence element list ) ; } else { process remark service . add source code remark on element ( test solution , element , message code ) ; } }	add a sourcecoderemark on the given element with a preset evidence element collection.
void event pre modify ( action type type , long position , boolean is single ) { if ( type != current action type || ! is single || system . current time millis ( ) - previous time > merge time || ( type == action type . insert || type == action type . overwrite ) && action exclusive end ( ) != position || type == action type . delete && action position ( ) != position && action position ( ) - num != position ) { start action ( type , is single ) ; } else { is backspace = action position ( ) > position ; } if ( is single && type == action type . insert ) { update new range ( position ) ; previous time = system . current time millis ( ) ; } }	user event : single / block delete / insert / overwrite . called before any change has been done.
void save async ( document entity entity , consumer < document entity > call back ) throws execute async query exception , unsupported operation exception ;	saves an entity asynchronously.
public boolean mark supported ( ) { return f input stream . mark supported ( ) ; }	tell whether this stream supports the mark ( ) operation .
public string resolve parent relation name ( string parent name , object parent , string child name , object child ) { return parent name ; }	follow the most conventional pattern , returns the parentname unchanged .
public byte column ( int nrows , int capacity , byte default value ) { super ( byte . class , new byte ( default value ) ) ; if ( capacity < nrows ) { throw new illegal argument exception ( str ) ; } m values = new byte [ capacity ] ; arrays . fill ( m values , default value ) ; m size = nrows ; }	create a new intcolumn .
public rel node convert select ( sql select select , boolean top ) { final sql validator scope select scope = validator . get where scope ( select ) ; final blackboard bb = create blackboard ( select scope , null , top ) ; convert select impl ( bb , select ) ; return bb . root ; }	converts a select statement ' s parse tree into a relational expression .
public static object execute script ( string file path , string function name , map < string , object > context ) { return execute script ( file path , function name , context , new object [ ] { context } ) ; }	executes the script at the specified location and returns the result .
public htm ( document builder setting [ ] settings ) throws dom { super ( settings ) ; try { class loader class loader = class loader . get system class loader ( ) ; class html builder class = class loader . load class ( str ) ; html builder constructor = html builder class . get constructor ( no classes ) ; get html = html builder class . get method ( str , no classes ) ; class html dom = class loader . load class ( str ) ; method method = html dom . get method ( str , no classes ) ; dom impl = ( dom ) method . invoke ( null , no objects ) ; class sax factory class = class loader . load class ( str ) ; factory = ( sax ) sax factory class . new instance ( ) ; } catch ( invocation target exception ex ) { throw new dom ( ex . get target exception ( ) , null ) ; } catch ( exception ex ) { throw new dom ( ex , null ) ; } if ( settings != null ) { for ( int i = num ; i < settings . length ; i ++ ) { } } try { factory . new sax ( ) ; } catch ( parser configuration exception ex ) { throw new dom ( ex , null ) ; } catch ( sax ex ) { throw new dom ( ex , null ) ; } }	creates a implementation of domtestdocumentbuilderfactory using org.
private static string format sample rate ( int rate ) { return mhz formatter . format ( ( double ) rate / num ) ; }	formats the rate in hertz for display as megahertz.
public final boolean is closed ( ) { return closed . get ( ) ; }	checks whether this closeableiteration has been closed .
void start ( ) { this . running = bool ; thread thread = new thread ( this , str + hash code ( ) ) ; thread . set daemon ( bool ) ; thread . start ( ) ; }	start the network listening thread .
type simplifier ( types type utils , string package name , set < type mirror > types , type mirror base ) { this . type utils = type utils ; set < type mirror > types plus base = new type mirror set ( types ) ; if ( base != null ) { types plus base . add ( base ) ; } set < type mirror > referenced = referenced class types ( type utils , types plus base ) ; set < type mirror > defined = non private declared types ( type utils , base ) ; this . imports = find imports ( type utils , package name , referenced , defined ) ; }	makes a new simplifier for the given package and set of types .
public static byte [ ] escape ( final byte [ ] bytes ) { final byte [ ] temp = new byte [ num * bytes . length ] ; int current position = num ; for ( final byte b : bytes ) { if ( b == escape char ) { temp [ current position ++ ] = escape char ; temp [ current position ++ ] = replacement char ; } else if ( b == delimiter ) { temp [ current position ++ ] = escape char ; temp [ current position ++ ] = escape char ; } else { temp [ current position ++ ] = b ; } } final byte [ ] escaped = new byte [ current position ] ; system . arraycopy ( temp , num , escaped , num , current position ) ; return escaped ; }	escapes the provided string so that it no longer contains the constants.
public final native string name ( ) ;	human readable name of the mode , such as " c + + " .
public static string to string ( document host doc ) throws io { try { string writer out = new string writer ( ) ; dom dom source = new dom ( host doc ) ; stream result stream result = new stream result ( out ) ; transformer factory tf = transformer factory . new instance ( ) ; transformer serializer = tf . new transformer ( ) ; serializer . set output property ( output keys . encoding , enc . name ( ) ) ; serializer . set output property ( output keys . method , str ) ; serializer . set output property ( output keys . indent , str ) ; serializer . set output property ( output keys . doctype public , html dom util . html strict ) ; serializer . transform ( dom source , stream result ) ; return out . to string ( ) ; } catch ( transformer exception e ) { io r = new io ( str ) ; r . init cause ( e ) ; throw r ; } }	convert a document to a string , assuming later encoding to utf - 8 .
public mongo client client for members ( server address ... seeds ) { list < server address > addresses = new array list < > ( ) ; for ( server address seed address : seeds ) { if ( seed address != null ) addresses . add ( seed address ) ; } return client for members ( addresses ) ; }	obtain a client connection to the replica set or cluster.
public static boolean string to boolean value ( string str ) throws expression exception { str = string util . to lower case ( str . trim ( ) ) ; if ( str . equals ( str ) || str . equals ( str ) ) return bool ; else if ( str . equals ( str ) || str . equals ( str ) ) return bool ; throw new caster exception ( str + str + str ) ; }	cast a string to a boolean value ( primitive value type ).
public boolean has more work ( ) { return ! work list . is empty ( ) ; }	are there more work list items ?.
protected synchronized void engine set seed ( byte [ ] seed ) { if ( seed == null ) { throw new null pointer exception ( str ) ; } if ( state == next bytes ) { system . arraycopy ( copies , hashcopy offset , this . seed , hash offset , extraframe offset ) ; } state = set seed ; if ( seed . length != num ) { update seed ( seed ) ; } }	changes current seed by supplementing a seed argument to the current seed , if this already set ; the argument is used as first seed otherwise.
public void generate class file ( output stream os ) { class writer cw = new asm ( class writer . compute frames ) ; cv = cw ; generate byte code ( ) ; try { os . write ( cw . to byte array ( ) ) ; } catch ( io e ) { throw new runtime exception ( str , e ) ; } }	outputs the bytecode generated as a class file.
private static boolean use compact font format ( map < string , object > args , int compatibility version ) { string value = ( string ) args . get ( embedascff ) ; boolean use cff = bool ; if ( compatibility version < mxml configuration . version 4 0 ) use cff = bool ; if ( value != null ) { use cff = boolean . parse boolean ( value . trim ( ) ) ; } return use cff ; }	the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .
public static void main ( string [ ] args ) { new generator tester ( args ) ; }	test the image generator .
private string mosesize ( string feature ) { if ( joshua configuration . moses ) { if ( feature . starts with ( str ) || feature . starts with ( str ) ) return feature . replace ( str , str ) ; } return feature ; }	moses requires the pattern.
public static int calc text height ( paint paint , string demo text ) { rect r = new rect ( ) ; paint . get text bounds ( demo text , num , demo text . length ( ) , r ) ; return r . height ( ) ; }	calculates the approximate height of a text , depending on a demo text avoid repeated calls ( e.
private void check shutdown ( ) { synchronized ( mux ) { if ( is being shutdown ) throw new rejected execution exception ( str ) ; } }	checks if service is being shutdown .
private static final void check queue for dependencies and execute unblocked tasks ( ) { list < progress thread > to remove = new linked list < > ( ) ; synchronized ( lock ) { for ( progress thread pg : queued threads ) { if ( ! pg . is blocked by dependencies ( ) ) { if ( ! pg . is waiting ( ) ) { to remove . add ( pg ) ; executor . execute ( pg . make wrapper ( ) ) ; } } } } for ( progress thread pg : to remove ) { synchronized ( lock ) { queued threads . remove ( pg ) ; } } }	checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .
private static short v ( jni env , int obj jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , type reference . short , bool ) ; return reflection . unwrap short ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callshortmethodv : invoke a virtual method that returns a short value.
public void fire indexed property change ( string property name , int index , boolean old value , boolean new value ) { if ( old value != new value ) { fire indexed property change ( property name , index , boolean . value of ( old value ) , boolean . value of ( new value ) ) ; } }	fires a property change of a boolean property with the given name.
protected void remove markers ( ) { for ( int i = marker image . size ( ) ; i > num ; i -- ) { loco icon il = marker image . get ( i - num ) ; if ( ( il != null ) && ( il . is active ( ) ) ) { marker image . remove ( i - num ) ; il . remove ( ) ; il . dispose ( ) ; set dirty ( bool ) ; } } super . remove markers ( ) ; repaint ( ) ; }	remove marker icons from panel.
public i capture string ( ) { char sequence buffer = get buffer ( ) ; int current position = get token end ( ) ; set token start ( current position ) ; int buffer end = get buffer end ( ) ; char open quote = buffer . char at ( current position ) ; char close quote = regex block . get quote close char ( open quote ) ; boolean quotes differ = open quote != close quote ; boolean is escaped = bool ; int quotes depth = num ; current position ++ ; while ( current position < buffer end ) { char current char = buffer . char at ( current position ) ; if ( ! is escaped && quotes depth == num && current char == close quote ) { break ; } if ( ! is escaped && quotes differ ) { if ( current char == open quote ) { quotes depth ++ ; } else if ( current char == close quote ) { quotes depth -- ; } } is escaped = ! is escaped && current char == str ; current position ++ ; } if ( current position < buffer end ) { current position ++ ; } set token end ( current position ) ; perl string lexer string lexer = get string lexer ( ) ; pop state ( ) ; preparsed tokens list . add all ( lex current token ( string lexer ) ) ; return get pre parsed token ( ) ; }	captures string token from current position according to the current lexical state.
public static string to localized integer ( long value ) { return number forma . format ( value ) ; }	this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .
public void test parse client handshake ( ) throws exception { for ( int split pos = num ; split pos < num ; split pos ++ ) { log . info ( str + split pos ) ; byte buffer tmp = client handshake packet ( ) ; byte buffer [ ] split = split ( tmp , split pos ) ; grid nio session ses = new mock nio session ( ) ; ses . add meta ( marshaller . ordinal ( ) , new grid client optimized marshaller ( ) ) ; grid tcp rest parser parser = new grid tcp rest parser ( bool ) ; collection < grid client message > lst = new array list < > ( num ) ; for ( byte buffer buf : split ) { grid client message r ; while ( buf . has remaining ( ) && ( r = parser . decode ( ses , buf ) ) != null ) lst . add ( r ) ; assert true ( str , buf . remaining ( ) == num ) ; } assert equals ( num , lst . size ( ) ) ; grid client handshake request req = ( grid client handshake request ) f . first ( lst ) ; assert not null ( req ) ; assert equals ( u . bytes to short ( new byte [ ] { num , num } , num ) , req . version ( ) ) ; } }	tests correct parsing of client handshake packets .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . delete data ( num , num ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; }	runs the test case .
void check frame value ( final object value ) { if ( value == opcodes . top || value == opcodes . integer || value == opcodes . float || value == opcodes . long || value == opcodes . double || value == opcodes . null || value == opcodes . uninitialized this ) { return ; } if ( value instanceof string ) { check internal name ( ( string ) value , str ) ; return ; } if ( ! ( value instanceof label ) ) { throw new illegal argument exception ( str + value ) ; } else { used labels . add ( ( label ) value ) ; } }	checks a stack frame value .
public static template create ( string value ) { if ( settings . is function ( value ) ) { return new functional template ( value ) ; } if ( graph . is relational ( value ) ) { try { return new relational template ( value ) ; } catch ( exception e ) { log . warning ( str + value + str ) ; return new string template ( value ) ; } } else if ( regex template . is possible regex ( value ) ) { try { if ( arithmetic template . is arithmetic expression ( value ) ) { return new arithmetic template ( value ) ; } return new regex template ( value ) ; } catch ( pattern syntax exception e ) { log . warning ( str + value + str ) ; return new string template ( value ) ; } } else { return new string template ( value ) ; } }	creates a new template based on the string value.
protected boolean custom should take focus ( ) { if ( custom area instanceof label ) { return bool ; } if ( custom area instanceof c ) { return ( custom area . get style ( ) & swt . no focus ) > num ; } return bool ; }	return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog.
public void init ( private key key ) { try { if ( signature != null ) { signature . init sign ( key ) ; } else if ( cipher != null ) { cipher . init ( cipher . encrypt mode , key ) ; } } catch ( invalid key exception e ) { throw new alert exception ( alert protocol . bad certificate , new ssl ( str , e ) ) ; } }	initiate signature type by private key.
private map < string , list < zone > > select zones for initiators and ports ( network lite network , map < string , list < zone > > wwn to zones , map < string , storage port > initiator ports map ) { map < string , list < zone > > filtered map = new hash map < string , list < zone > > ( ) ; zone zone = null ; list < zone > zones = null ; for ( string initiator wwn : wwn to zones . key set ( ) ) { for ( string port wwn : initiator ports map . key set ( ) ) { zone = network scheduler . select existing zone for initiator port ( network , initiator wwn , port wwn , wwn to zones . get ( initiator wwn ) ) ; if ( zone != null ) { zones = filtered map . get ( initiator wwn ) ; if ( zones == null ) { zones = new array list < > ( ) ; filtered map . put ( initiator wwn , zones ) ; } zones . add ( zone ) ; } } } return filtered map ; }	given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .
public static boolean is extension ( string filename , collection < string > extensions ) { if ( filename == null ) return bool ; if ( extensions == null || extensions . is empty ( ) ) return index of extension ( filename ) == - num ; string file ext = get extension ( filename ) ; for ( string extension : extensions ) { if ( file ext . equals ( extension ) ) return bool ; } return bool ; }	checks whether the extension of the filename is one of those specified.
private void write jar post resource ( element post resource el , string path ) { post resource el . set attribute ( str , jar resource set ) ; post resource el . set attribute ( str , path . replace ( str , str ) ) ; }	write jar post resource.
public void close file ( ) throws io { file . close ( ) ; file = null ; }	close the file . the file may later be re - opened using openfile .
public typed event listener ( event listener < e > wrapped listener , class < e > event class ) { this . event class = event class ; this . wrapped listener = wrapped listener ; }	constructs a new single typed event listener .
public static list < ? extends node > child node list ( node node ) { if ( node == null ) return null ; list < node > nodes = new linked list < node > ( ) ; do { if ( node . get node type ( ) == node . element node || node . get node type ( ) == node . comment node ) { nodes . add ( node ) ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; return nodes ; }	return a list of node objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
public static corleone context ( string job context ) { if ( job context == null || job context . equals ( str ) ) { throw new illegal argument exception ( str ) ; } contexts . clear ( ) ; contexts . add ( job context ) ; return get instance ( ) ; }	provides a corleone instance to work on the given context .
public static double info ( int counts [ ] ) { int total = num ; double x = num ; for ( int count : counts ) { x -= xlogx ( count ) ; total += count ; } return x + xlogx ( total ) ; }	computes entropy for an array of integers .
public void add method ( soot method m ) { check level ( signatures ) ; if ( m . is declared ( ) ) throw new runtime exception ( str + m . get name ( ) ) ; if ( sub sig to methods . get ( m . get numbered sub signature ( ) ) != null ) { throw new runtime exception ( str + m . get sub signature ( ) + str + this + str ) ; } sub sig to methods . put ( m . get numbered sub signature ( ) , m ) ; method list . add ( m ) ; m . set declared ( bool ) ; m . set declaring class ( this ) ; }	adds the given method to this class .
private void add replication factor ( operation op ) { op . add request header ( operation . replication quorum header , operation . replication quorum header value all ) ; }	authorization related operations should take effect on all replicas , before they complete . this method adds a special header that sets the quorum level to all available nodes , avoiding a race where a client can reach a node that has not yet received latest authorization changes , even if it received success from this auth helper class.
private static frame show initial splash ( ) { frame splash frame = null ; image image = null ; url image url = get chosen splash url ( ) ; if ( image url != null ) { try { image = io . read ( image url ) ; } catch ( io e ) { e . print stack trace ( ) ; } if ( image != null ) { splash frame = awt . splash ( image ) ; } } return splash frame ; }	shows the initial splash window .
protected void decode line suffix ( pushback input stream in stream , output stream out stream ) throws io { int c ; while ( bool ) { c = in stream . read ( ) ; if ( c == - num ) { throw new ce ( ) ; } if ( c == str ) { break ; } if ( c == str ) { c = in stream . read ( ) ; if ( ( c != str ) && ( c != - num ) ) { in stream . unread ( c ) ; } break ; } } }	find the end of the line for the next operation . the following sequences are recognized as end - of - line cr , cr lf , or lf.
public void add transaction ( sip server transaction ) throws io { if ( is logging enabled ( ) ) stack logger . log debug ( str + server transaction ) ; server transaction . map ( ) ; add transaction hash ( server transaction ) ; }	add a new server transaction to the set of existing transactions.
private float spacing ( motion event event ) { float x = event . get x ( num ) - event . get x ( num ) ; float y = event . get y ( num ) - event . get y ( num ) ; return ( float ) math . sqrt ( x * x + y * y ) ; }	determine the space between the first two fingers.
public boolean contains poly ( soot method method ) { return get method ( method ) != null ; }	search for polymorphic containment based on inheritance of receiver and arguments .
public jk ( final string source q , final string target q , final jk namespace ) { logger . info ( string . format ( str , source q , target q ) ) ; this . source q = source q ; this . target q = target q ; this . namespace = namespace ; this . auto = bool ; }	instantiates a new jk tag mapping .
private void select attribute set instance ( ) { int m warehouse id = get m id ( ) ; int m product id = get m id ( ) ; if ( m product id <= num ) return ; m product = m . get ( get ctx ( ) , m product id ) ; m wh = m . get ( get ctx ( ) , m warehouse id ) ; string title = product . get ( m . columnname ) + str + wh . get ( m . columnname ) ; p pai = new p ( m frame , title , m warehouse id , num , m product id , num ) ; if ( pai . get m id ( ) != - num ) { f attr set instance id . set text ( pai . get m ( ) ) ; f attr set instance id . set value ( new integer ( pai . get m id ( ) ) ) ; } else { f attr set instance id . set value ( integer . value of ( num ) ) ; } }	filter by attribute set instance.
private void ensure file open ( ) { if ( saving disabled ) { log . e ( tag , str ) ; return ; } if ( save file stream != null ) return ; file save file = new file ( ctx . get files dir ( ) , savefile ) ; try { file output stream file output = null ; data output stream out = null ; if ( save file . exists ( ) ) { file output = ctx . open file output ( savefile , context . mode append ) ; out = new data output stream ( new buffered output stream ( file output ) ) ; } else { file output = ctx . open file output ( savefile , context . mode private ) ; out = new data output stream ( new buffered output stream ( file output ) ) ; out . write int ( track point . format version ) ; saved track points = num ; } save file stream = out ; } catch ( exception e ) { mark saving broken ( str , e ) ; } }	opens the savefilestream if necessary.
public void test canonicalizing cache ( ) { final properties properties = get properties ( ) ; properties . set property ( abstract transaction service . options . min release age , str ) ; final journal journal = new journal ( properties ) ; try { final long commit time0 = journal . commit ( ) ; assert true ( commit time0 != num ) ; final i commit record0 = journal . get commit record ( commit time0 ) ; assert equals ( commit record0 , journal . get commit record ( ) ) ; journal . write ( byte buffer . wrap ( new byte [ ] { num , num , num } ) ) ; final long commit time1 = journal . commit ( ) ; assert true ( commit time1 != num ) ; final i commit record1 = journal . get commit record ( commit time1 ) ; assert equals ( commit record1 , journal . get commit record ( ) ) ; assert true ( commit record0 == journal . get commit record ( commit time1 - num ) ) ; assert true ( commit record1 == journal . get commit record ( commit time1 + num ) ) ; assert true ( commit record1 == journal . get commit record ( commit time1 + num ) ) ; } finally { journal . destroy ( ) ; } }	test verifies that exact match and find always return the same reference for the same commit record ( at least as long as the test holds a hard reference to the commit record of interest ) .
public static void print ( object x ) { out . print ( x ) ; out . flush ( ) ; }	prints an object to standard output and flushes standard output .
@ override public void stop ( runnable arg0 ) { stop ( ) ; arg0 . run ( ) ; }	smart lifecycle stop implementation.
protected int read ( input stream input stream , byte [ ] buffer , char divider ) throws io { int index = num ; do { byte read byte = ( byte ) ( num & input stream . read ( ) ) ; if ( read byte == - num || read byte == ( byte ) divider ) { return index ; } buffer [ index ] = read byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }	reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .
private static void generate graph file ( trans meta trans meta , string graph file ) throws graph generator exception { data output stream dos = null ; try { string xml = trans meta . get xml ( ) ; dos = new data output stream ( new file output stream ( new file ( graph file ) ) ) ; dos . write ( xml . get bytes ( carbon common constants . default charset ) ) ; } catch ( kettle exception kettel exception ) { throw new graph generator exception ( str , kettel exception ) ; } catch ( file not found exception e ) { throw new graph generator exception ( str , e ) ; } catch ( unsupported encoding exception ue ) { throw new graph generator exception ( str , ue ) ; } catch ( io ioe ) { throw new graph generator exception ( str , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( io e ) { e . get message ( ) ; } } } }	generate the graph file.
public static void close output stream ( output stream stream , string tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( io e ) { log . e ( tag , str + e ) ; } } }	close a bytearrayoutputstream passed in .
public void add property change listener ( string property name , property change listener in pcl ) { bean context child support . add property change listener ( property name , in pcl ) ; }	method for beancontextchild interface.
public boolean is expired ( ) { return this . ttl < system . current time millis ( ) ; }	true if the entry is expired .
private void load user info into action bar ( ) { if ( ! text utils . is empty ( m with user image ) ) { utils . load circular image ( get activity ( ) , m with image view , m with user image , avatar bitmap transformation . avatar size . normal ) ; } }	loads the user image into the action bar profile pic.
public static direction direction for arrow key ( key event e ) { int index = math . max ( num , math . min ( e . get key code ( ) , key event . vk down ) - key event . vk left ) ; return direction . values ( ) [ index ] ; }	returns a direction corresponding to the specified arrow key.
public trace graph ( collection < span > spans ) { this . spans by parent = new spans by parent ( spans ) ; this . spans by tracer id = new spans by tracer id ( spans ) ; }	create a new tracegraph.
public boolean is persistent ( ) { return m persist ; }	indicates if the tooltip will stay persistent on the screen to support interaction within the tooltip component .
public static java . util . date to date ( string month str , string day str , string year str , string hour str , string minute str , string second str ) { int month , day , year , hour , minute , second ; try { month = integer . parse int ( month str ) ; day = integer . parse int ( day str ) ; year = integer . parse int ( year str ) ; hour = integer . parse int ( hour str ) ; minute = integer . parse int ( minute str ) ; second = integer . parse int ( second str ) ; } catch ( exception e ) { return null ; } return to date ( month , day , year , hour , minute , second ) ; }	makes a date from separate strings for month , day , year , hour , minute , and second .
protected void handle mesos failure ( string task id ) { int attempt = task utils . get attempt for task id ( task id ) ; base container container = containers info . get ( task utils . get container index for task id ( task id ) ) ; boolean has attempts left = attempt < container . retries ; if ( has attempts left ) { log . warning ( string . format ( str , container . name , attempt + num ) ) ; string new task id = task utils . get task id ( container . name , attempt + num ) ; schedule new task ( new task id ) ; } else { log . severe ( str + attempt ) ; } }	restart a failed task unless exceeding the retires limitation.
public static file find config in working directory ( ) { for ( final string suffix : suffixes ) { final file config file = new file ( system . get property ( str ) , prefix + suffix ) ; if ( config file . is file ( ) ) { return config file ; } } return null ; }	finds a log4j configuration file in the current working directory.
protected boolean attempt to add word ( word word ) { double additional length = word . get word width ( ) ; additional length += ! words . is empty ( ) ? space size : num ; if ( current line length + additional length <= max length || max length == - num ) { words . add ( word ) ; current line length += additional length ; return bool ; } else { return bool ; } }	attempt to add a word to the line.
@ override public boolean on preference click ( preference preference ) { if ( preference == m play example ) { get sample text ( ) ; return bool ; } return bool ; }	called when mplayexample is clicked.
public void read www authenticate header ( string header ) { if ( header != null ) { m is digest authentication = header . starts with ( http digest md5 authentication . http digest schema ) ; if ( ! m is digest authentication ) { return ; } string value = get value ( header , str ) ; m digest . set realm ( value ) ; value = get value ( header , str ) ; m digest . set opaque ( value ) ; value = get value ( header , str ) ; m digest . set qop ( value ) ; value = get value ( header , str ) ; m digest . set nextnonce ( value ) ; } }	read the www - authenticate header.
public static string value of ( boolean value ) { return value != null ? string . value of ( value ) : null ; }	returns the string value of the given boolean.
public void test send receive ( ) throws exception { messages . clear ( ) ; for ( int i = num ; i < data . length ; i ++ ) { message message = session . create text message ( data [ i ] ) ; message . set string property ( str , data [ i ] ) ; message . set int property ( str , i ) ; if ( verbose ) { if ( log . is debug enabled ( ) ) { log . debug ( str + message + str + data [ i ] ) ; } } send to producer ( producer , producer destination , message ) ; message sent ( ) ; } assert messages are received ( ) ; log . info ( str + data . length + str ) ; }	sends and consumes the messages .
public void add live ( boolean live ) { query . append ( str + live ) ; }	adds + live to the query.
public static string to string ( uri uri , charset encoding ) throws io { return to string ( uri . to url ( ) , charsets . to charset ( encoding ) ) ; }	gets the contents at the given uri .
public boolean exists ( string key ) { return exists ( key , bool ) ; }	check existence of config section element.
public allocation site ( int line , int column ) { synchronized ( sites ) { this . id = sites . size ( ) ; sites . add ( this ) ; } this . line = line ; this . column = column ; }	create an allocation site for a given source code line / column .
public boolean draw image ( image img , affine transform xform , image observer obs ) { return m graphics . draw image ( img , xform , obs ) ; }	draws an image , applying a transform from image space into user space before drawing.
public final static int parse int ( char [ ] digit chars , int offset , int len ) { int num = digit chars [ offset ] - str ; len += offset ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; if ( ++ offset < len ) { num = ( num * num ) + ( digit chars [ offset ] - str ) ; } } } } } } } } return num ; }	fast method for parsing integers that are known to fit into regular 32 - bit signed int type . this means that length is between 1 and 9 digits ( inclusive ) < p > note : public to let unit tests call it.
public activity monitor sample ( ) { init components ( ) ; owner a . set action command ( str ) ; owner b . set action command ( str ) ; owner c . set action command ( str ) ; indicator a . set activity owner ( str ) ; indicator b . set activity owner ( str ) ; indicator c . set activity owner ( str ) ; j . get instance ( ) ; }	creates new form activitymonitorsample.
public static lat lon [ ] great circle extreme locations ( lat lon location , angle azimuth ) { if ( location == null ) { throw new illegal argument exception ( str ) ; } if ( azimuth == null ) { throw new illegal argument exception ( str ) ; } double lat0 = location . get latitude ( ) . radians ; double az = azimuth . radians ; double tan distance = - math . tan ( lat0 ) / math . cos ( az ) ; double distance = math . atan ( tan distance ) ; angle extreme distance1 = angle . from radians ( distance + ( math . pi / num ) ) ; angle extreme distance2 = angle . from radians ( distance - ( math . pi / num ) ) ; return new lat lon [ ] { great circle end position ( location , azimuth , extreme distance1 ) , great circle end position ( location , azimuth , extreme distance2 ) } ; }	returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .
private void init checkbox ( check box preference checkbox , boolean checked , boolean enabled ) { checkbox . set checked ( checked ) ; checkbox . set enabled ( enabled ) ; }	initialize the service activation checkbox.
private void paint check icon enabled and selected ( d g , int width , int height ) { shape s = shape generator . create check mark ( num , num , width , height ) ; g . set paint ( icon enabled selected ) ; g . fill ( s ) ; }	paint the check mark in enabled state .
public static int find uri ( string uri ) { int uri length = uri . length ( ) ; int idx = uri length - num ; for ( ; idx >= num ; idx -- ) { if ( ! turtle util . is name char ( uri . char at ( idx ) ) ) { break ; } } idx ++ ; for ( ; idx < uri length ; idx ++ ) { if ( turtle util . is name start char ( uri . char at ( idx ) ) ) { break ; } } if ( ! turtle util . is name end char ( uri . char at ( uri length - num ) ) ) { return - num ; } if ( idx > num && idx < uri length ) { return idx ; } return - num ; }	tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .
private void write log ( string cmd ) { try { if ( m writer == null ) { file file = file . create temp file ( str , str ) ; m writer = new print writer ( new file writer ( file ) ) ; log . info ( file . to string ( ) ) ; } m writer . println ( cmd ) ; m writer . flush ( ) ; } catch ( exception e ) { log . severe ( e . to string ( ) ) ; } }	write to file log.
public void reload ( string why ) { m full photo paths = m root dir . list ( media scanner . jpg filename filter ) ; if ( ( m full photo paths != null ) && ( m full photo paths . length == num ) ) { m full photo paths = null ; log . i ( global . log context , m debug prefix + why + str + m root dir + str + num ) ; } else if ( m full photo paths != null ) { if ( global . debug enabled ) { log . i ( global . log context , m debug prefix + why + str + m root dir + str + m full photo paths . length ) ; } string parent dir string = m root dir . get absolute path ( ) ; for ( int i = num ; i < m full photo paths . length ; i ++ ) { m full photo paths [ i ] = parent dir string + str + m full photo paths [ i ] ; } } }	refreshlocal files from inital path.
dns ( string name , dns type , dns record class , boolean unique , int ttl ) { super ( name , type , record class , unique ) ; this . ttl = ttl ; this . created = system . current time millis ( ) ; }	create a dnsrecord with a name , type , class , and ttl .
public static string block ( stream < string > rows ) { return block ( rows . collect ( joining ( nl ( ) ) ) ) ; }	indents the specified text , surrounds it with brackets and put the content on a separate line .
protected void add content spec to element ( xml element decl ) { if ( ( f depth == num || ( f depth == num && element decl . type == xml . type mixed ) ) && f node index stack != null ) { if ( element decl . type == xml . type mixed ) { int pcdata = add unique leaf node ( null ) ; if ( f node index stack [ num ] == - num ) { f node index stack [ num ] = pcdata ; } else { f node index stack [ num ] = add content spec node ( xml . contentspecnode choice , pcdata , f node index stack [ num ] ) ; } } set content spec index ( f current element index , f node index stack [ f depth ] ) ; } }	adds the content spec to the given element declaration .
private void grow spine ( ) { spine = new int [ ( spine . length << num ) + num ] ; threshold = ( int ) ( spine . length * load factor ) ; arrays . fill ( spine , - num ) ; for ( int i = num ; i < size ; i ++ ) { insert ( objs [ i ] , i ) ; } }	expands the hash " spine " - - equivalent to increasing the number of buckets in a conventional hash table .
public void reconnect ( ) { if ( opened && ! allow connection recovery ) { return ; } reconnectwait thread = new reconnectwait ( ) ; thread . start ( ) ; try { thread . join ( ) ; } catch ( interrupted exception e ) { log . error ( str + e . get message ( ) ) ; } if ( ! opened ) { log . error ( str ) ; } else { log . info ( str + get current port name ( ) ) ; resetup connection ( ) ; } }	attempts to reconnect to a failed server.
public collection < grid port record > records ( ) { synchronized ( recs ) { return collections . unmodifiable collection ( new array list < > ( recs ) ) ; } }	returns unmodifiable collections of records .
@ override public string to string ( ) { return buf . to string ( ) ; }	returns the signature that was built by this signature writer .
public boolean has change event ( string name ) { if ( var != null ) { list < meta data > md list = var . get meta data ( standard defs . md changeevent ) ; if ( md list != null ) { for ( int i = num , size = md list . size ( ) ; i < size ; i ++ ) { meta data md = md list . get ( i ) ; if ( name . equals ( md . get value ( num ) ) ) { return bool ; } } } } return bool ; }	[ changeevent ] todo why just on var ? should it be returned for getter / setter props ?.
protected void reset xm ( ) throws xni { int count = f xm . size ( ) ; for ( int i = num ; i < count ; i ++ ) { xml c = ( xml ) f xm . get ( i ) ; c . reset ( this ) ; } }	reset all components before parsing and namespace context.
public float distance to other circle ( circle circle ) { return ( float ) math . abs ( math . sqrt ( math . pow ( circle . center . x - center . x , num ) + math . pow ( circle . center . y - center . y , num ) ) ) ; }	distance between circle center.
public simple command ( string command name , string ... args ) { this ( command name , ( argument ) null ) ; array list < argument > arg list = new array list < argument > ( ) ; for ( string arg : args ) arg list . add ( new argument ( arg ) ) ; arguments = arg list . to array ( new argument [ num ] ) ; }	constructs a simplecommand from the given command name and the list of arguments .
private void grow ( ) { m allocated size *= num ; boolean new vector [ ] = new boolean [ m allocated size ] ; system . arraycopy ( m values , num , new vector , num , m index + num ) ; m values = new vector ; }	grows the size of the stack.
public string convert to lower case ( string table ) { return table . to lower case ( ) ; }	returns the given string in lowercase.
public picking graph mouse plugin ( int selection modifiers , int add to selection modifiers ) { super ( selection modifiers ) ; this . add to selection modifiers = add to selection modifiers ; this . lens paintable = new lens paintable ( ) ; this . cursor = cursor . get predefined cursor ( cursor . hand cursor ) ; }	create an instance with overides.
public int [ ] breadth first search ( int intial value , ibfs < n > traversable , int first value , i < n > next value iterator , list < integer > sources index ) { int [ ] results = new int [ nodes . length ] ; arrays . fill ( results , intial value ) ; boolean [ ] already scanned = new boolean [ nodes . length ] ; arrays . fill ( already scanned , bool ) ; set < integer > current nodes index = new hash set < > ( sources index ) ; iterative integer breadth first search ( results , already scanned , current nodes index , first value , num , traversable , next value iterator ) ; return results ; }	breadth - first search implementation for integers.
public view ref render ( view render < t > view , class < t > type , int priority ) { objects . require non null ( view ) ; view = view ; type = type ; priority = priority ; }	creates the view and analyzes the type.
public void check number args ( int arg num ) throws wrong number args exception { if ( arg num < num ) report wrong number args ( ) ; }	check that the number of arguments passed to this function is correct .
private boolean announce ( string [ ] groups ) { if ( data packets == null || ! last locator . equals ( my locator ) || ! arrays . equals ( last groups , groups ) ) { list < datagram packet > packets = new array list < datagram packet > ( ) ; discovery disco ; try { disco = get discovery ( multicast announcement constraints . choose protocol version ( ) ) ; } catch ( discovery protocol exception e ) { throw new assertion error ( e ) ; } encode iterator ei = disco . encode multicast announcement ( new multicast announcement ( announcement seq no ++ , my locator . get host ( ) , my locator . get port ( ) , groups , my service id ) , multicast announcement constraints . get multicast max packet size ( default max packet size ) , multicast announcement constraints . get unfulfilled constraints ( ) ) ; while ( ei . has next ( ) ) { try { packets . add all ( arrays . as list ( ei . next ( ) ) ) ; } catch ( exception e ) { logger . log ( ( e instanceof unsupported constraint exception ) ? levels . handled : level . info , str + str , e ) ; } } last locator = my locator ; last groups = groups ; data packets = packets . to array ( new datagram packet [ packets . size ( ) ] ) ; } try { send ( data packets ) ; } catch ( io e ) { return bool ; } return bool ; }	announce membership in the specified groups , and return false if interrupted , otherwise return true.
public drawing attributes ( ) { property change support = new property change support ( this ) ; }	create a drawingattributes with the default settings - clear fill paint and pattern , sold black edge line of width 1 .
public void close ( ) { scanner . close ( ) ; }	closes this input stream .
static void create policy tree ( string config name , string config id , service config manager scm , string org ) throws no permission exception , policy exception , sso { try { service config p config = scm . get organization config ( org , null ) ; if ( p config == null ) { scm . create organization config ( org , null ) ; p config = scm . get organization config ( org , null ) ; } p config . add sub config ( config name , config id , num , null ) ; } catch ( service already exists exception se ) { if ( debug . message enabled ( ) ) { debug . message ( str + config name + str + config id + str + org ) ; } } catch ( sms e ) { string [ ] objs = { org } ; if ( e . get exception code ( ) == sms . status no permission ) { throw ( new no permission exception ( res bundle utils . rb name , str , null ) ) ; } else { throw ( new policy exception ( res bundle utils . rb name , str , objs , e ) ) ; } } }	creates the policy tree , ou = policy , ou = services ,.
private void rollback method for create snapshot ( boolean is snapshot created , boolean is dummy lun path added , hds hds api client , storage system storage , uri snapshot ) throws exception { if ( is dummy lun path added ) { log . info ( str ) ; hds protection operations . remove dummy lun path ( storage , snapshot ) ; } if ( is snapshot created ) { log . info ( str ) ; block snapshot snapshot obj = db client . query object ( block snapshot . class , snapshot ) ; string system object id = hds . get system object id ( storage ) ; string logical unit obj id = hds . get logical unit object id ( snapshot obj . get native id ( ) , storage ) ; hds api client . delete snapshot volume ( system object id , logical unit obj id , storage . get model ( ) ) ; } }	roll back method to clean up stale snapshot volume on storage system.
public static int convert string to time seconds ( string time ) { int result = num ; if ( time . ends with ( str ) ) { int hours to add = integer . value of ( string utils . remove ( time , str ) ) ; result = ( num * num ) * hours to add ; } else if ( time . ends with ( str ) ) { int mins to add = integer . value of ( string utils . remove ( time , str ) ) ; result = num * mins to add ; } else if ( time . ends with ( str ) ) { int secs to add = integer . value of ( string utils . remove ( time , str ) ) ; result = secs to add ; } return result ; }	converts a string denoting an amount of time into seconds . strings are expected to follow this form where # equals a digit : # m the following are permitted for denoting time : h = hours , m = minutes , s = seconds.
public void detach ( app compat activity activity ) { attr view maps . remove ( activity . hash code ( ) ) ; }	this method should be called in activity ondestroy method.
public void read prefs ( shared preferences settings , action factory factory ) { boolean visible = bool ; string action id = settings . get string ( str + name + str , str ) ; main action = factory . get action ( action id ) ; if ( main action != null ) visible = bool ; menu actions . clear ( ) ; for ( int i = num ; i < max menu actions ; i ++ ) { action id = settings . get string ( str + name + str + ( i + num ) , str ) ; ui a = factory . get action ( action id ) ; if ( a != null ) visible = bool ; menu actions . add ( a ) ; } if ( button != null ) button . set visibility ( visible ? view . visible : view . gone ) ; }	update button actions from preferences settings .
public boolean add to active list ( download info runnable download info runnable ) { return active list has room ( ) && m active list . add ( download info runnable ) ; }	tries to add a download object to the active list.
private void add expr to tla ( tla expr ) { vector sv = expr . to string vector ( ) ; vector expr mapping = expr . to mapping vector ( ) ; int indent = tlacode next line . length ( ) ; int next line = num ; if ( indent != num ) { mapping object . shift mapping vector ( expr mapping , indent ) ; tlacode next line = tlacode next line + ( ( string ) sv . element at ( num ) ) ; mapping vector next line . add all ( ( vector ) expr mapping . element at ( num ) ) ; next line = num ; if ( sv . size ( ) > num ) { end current line of tla ( ) ; } } if ( sv . size ( ) > num ) { string spaces = n ( indent ) ; while ( next line < sv . size ( ) - num ) { tlacode . add element ( spaces + ( ( string ) sv . element at ( next line ) ) ) ; mapping vector . add element ( ( vector ) expr mapping . element at ( next line ) ) ; next line ++ ; } tlacode next line = spaces + ( ( string ) sv . element at ( next line ) ) ; mapping vector next line = ( vector ) expr mapping . element at ( next line ) ; } else if ( indent == num ) { tlacode next line = tlacode next line + ( ( string ) sv . element at ( num ) ) ; mapping vector next line . add all ( ( vector ) expr mapping . element at ( num ) ) ; } }	adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline.
private boolean is upper case camel case hunk ( string hunk ) { if ( hunk . length ( ) < num ) return bool ; for ( int i = num ; i < hunk . length ( ) ; i ++ ) { if ( ! is legal char ( hunk . char at ( i ) ) ) return bool ; } return bool ; }	true if hunk is longer than 1 character and all letters in the hunk are uppercase.
public void type ( string string ) { for ( int i = num ; i < string . length ( ) ; i ++ ) { char c = string . char at ( i ) ; type ( c ) ; } }	simulate keyboard type to type out a string.
public boolean provides identifier ( ) { return bool ; }	simple registration doesn ' t implement authentication services .
static void remove redundant affix ( translator utils . i i contain , list < string > str list ) { if ( str list . size ( ) <= num ) { return ; } int w = num ; for ( string str : str list ) { if ( w == num || ! i contain . contain func ( str , str list . get ( w - num ) ) ) { str list . set ( w , str ) ; w ++ ; } } str list = str list . sub list ( num , w ) ; }	this function ensures that prefix / suffix sets aren ' t redundant.
public static int next int ( int n ) { random random = get random ( ) ; int value = random . next int ( n ) ; if ( ! is test ) free random list . free ( random ) ; return value ; }	returns the next random int .
protected void do resume updates ( ) { calendar cal = calendar . get instance ( locale . get default ( ) ) ; m first day of week = cal . get first day of week ( ) - num ; m show week number = bool ; update header ( ) ; go to ( m selected day . to millis ( bool ) , bool , bool , bool ) ; m adapter . set selected day ( m selected day ) ; m today updater . run ( ) ; }	updates the user preference fields.
private void store last used ( ) { put ( last use , ( int ) ( system . current time millis ( ) / num ) ) ; }	store current system time as the last used.
private boolean can contain ( element containment info child , element containment info top , int top index ) { int child types = child . types ; int contents = top . contents ; int transparency allowed = child types & ( top . transparent to contents & ~ contents ) ; for ( int container index = top index - num ; transparency allowed != num ; -- container index ) { if ( container index < num ) { contents |= transparency allowed ; break ; } element containment info container = open elements . get ( container index ) ; contents |= transparency allowed & container . contents ; transparency allowed = transparency allowed & container . transparent to contents & ~ contents ; } return ( contents & child types ) != num ; }	takes into account transparency when figuring out what can be contained .
public static int [ ] extract arcs ( as oid ) throws invalid object id exception { string oid str = oid . get id ( ) ; string tokenizer str tok cnt = new string tokenizer ( oid str , str , bool ) ; int arc count = str tok cnt . count tokens ( ) ; string tokenizer str tok = new string tokenizer ( oid str , str , bool ) ; boolean expect delimiter = bool ; int [ ] arcs = new int [ arc count ] ; int i = num ; while ( str tok . has more tokens ( ) ) { string token = str tok . next token ( ) ; if ( expect delimiter && ( ! token . equals ( str ) || ! str tok . has more tokens ( ) ) ) { throw new invalid object id exception ( res . get string ( str ) ) ; } else if ( ! expect delimiter ) { try { arcs [ i ] = integer . parse int ( token ) ; if ( arcs [ i ] < num ) { throw new invalid object id exception ( res . get string ( str ) ) ; } i ++ ; } catch ( number format exception ex ) { throw new invalid object id exception ( res . get string ( str ) ) ; } } expect delimiter = ! expect delimiter ; } return arcs ; }	extract the arcs from an object identifier .
public void test is duplicate string ( ) { int count = num ; mq audit = new mq ( ) ; id generator id gen = new id generator ( ) ; list < string > list = new array list < > ( ) ; for ( int i = num ; i < count ; i ++ ) { string id = id gen . generate id ( ) ; list . add ( id ) ; assert false ( audit . is duplicate ( id ) ) ; } list < string > window list = list . sub list ( list . size ( ) - num - audit . get audit depth ( ) , list . size ( ) - num ) ; for ( string id : window list ) { assert true ( str + id , audit . is duplicate ( id ) ) ; } }	test case for isduplicate.
protected void update stats for conditional density estimator ( conditional density estimator classifier , instance class missing , double class value ) throws exception { if ( m == null ) { set numeric priors from buffer ( ) ; } m -= classifier . log density ( class missing , class value ) * class missing . weight ( ) / utils . log2 ; m -= m . log density ( class value ) * class missing . weight ( ) / utils . log2 ; }	updates stats for conditional density estimator based on current test instance .
@ override public boolean accept ( file f ) { if ( f != null ) { if ( f . is directory ( ) ) { return bool ; } string extension = get extension ( f ) ; if ( extension != null && filters . get ( get extension ( f ) ) != null ) { return bool ; } ; } return bool ; }	return true if this file should be shown in the directory pane , false if it shouldn ' t.
public void test case3 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add two numbers of the same length.
@ override public poll result start poll ( poll controller conn ) { if ( ! lifecycle . is active ( ) ) { log . warning ( this + str ) ; return poll result . closed ; } socket bar socket = conn . get socket ( ) ; if ( socket == null ) { log . warning ( this + str + conn ) ; return poll result . closed ; } selectable channel sel channel = socket . selectable channel ( ) ; if ( sel channel == null ) { log . warning ( this + str + socket ) ; return poll result . closed ; } connection count . increment and get ( ) ; active count . increment and get ( ) ; register queue . offer ( conn ) ; return poll result . start ; }	adds a keepalive connection .
@ override public void increment access count ( ) { access count . increment and get ( ) ; }	this method will increment the access count for a column by 1 whenever a column is getting used in query or incremental data load.
public static boolean compare doubles ( double a , double b ) { if ( double . is na n ( a ) && double . is na n ( b ) ) return bool ; if ( ! double . is infinite ( a ) && ! double . is infinite ( b ) ) return math . abs ( a - b ) <= epsilon ; return a == b ; }	compares two doubles for equality .
public static byte [ ] bitmap to byte ( bitmap b ) { byte array output stream o = new byte array output stream ( ) ; b . compress ( bitmap . compress format . png , num , o ) ; return o . to byte array ( ) ; }	convert bitmap to byte array.
public nb ( coercive parsing coercive parsing ) { this . coercive parsing = coercive parsing ; init components ( ) ; final iterate model number of tags iterator = coercive parsing . get number of tags iterator ( ) ; configure iterate model n . set start at ( string . value of ( number of tags iterator . get start at ( ) ) ) ; configure iterate model n . set stop at ( string . value of ( number of tags iterator . get stop at ( ) ) ) ; configure iterate model n . set increment ( string . value of ( number of tags iterator . get increment ( ) ) ) ; configure iterate model n . set iterate strategie ( number of tags iterator . get iterate strategie ( ) ) ; list < string > tag names = arrays . as list ( coercive parsing . get tag names ( ) ) ; configure string list n . set string list ( tag names ) ; }	creates new form configurecoerceiveparsingdialog_nb.
public static double log of base ( double number , int base ) { return math . log ( number ) / math . log ( base ) ; }	gets the log at a certain base of a number .
public static void u ( double [ ] x , double [ ] f , int nx ) { int count1 = num ; int count2 = num ; double sum1 = num ; double sum2 = num ; double prod1 = num ; double prod2 = num ; double yj ; double hj ; double pj ; double n = num ; double e = num ; for ( int j = num ; j <= nx ; j ++ ) { yj = x [ j - num ] - math . sin ( num * pi * x [ num ] + j * pi / nx ) ; pj = math . cos ( num * yj * pi / math . sqrt ( j + num ) ) ; if ( j % num == num ) { sum2 += yj * yj ; prod2 *= pj ; count2 ++ ; } else { sum1 += yj * yj ; prod1 *= pj ; count1 ++ ; } } hj = num * ( num / n + e ) * math . sin ( num * n * pi * x [ num ] ) ; if ( hj < num ) { hj = num ; } f [ num ] = x [ num ] + hj + num * ( num * sum1 - num * prod1 + num ) / ( double ) count1 ; f [ num ] = num - x [ num ] + hj + num * ( num * sum2 - num * prod2 + num ) / ( double ) count2 ; }	evaluates the uf6 problem .
public file saver descriptor ( @ not null string title , @ not null string description , string ... extensions ) { super ( bool , bool , bool , bool , bool , bool ) ; set title ( title ) ; set description ( description ) ; this . extensions = arrays . as list ( extensions ) ; }	constructs save dialog properties.
protected int read block ( ) { block size = read ( ) ; int n = num ; if ( block size > num ) { try { int count ; while ( n < block size ) { count = block size - n ; raw data . get ( block , n , count ) ; n += count ; } } catch ( final exception e ) { log . w ( tag , str , e ) ; status = status format error ; } } return n ; }	reads next variable length block from input .
public void add run ( final run run ) { runs . add ( run ) ; run . set id ( run id counter ++ ) ; }	will add the run to the list .
void copy into ( converter [ ] converters ) { system . arraycopy ( i converters , num , converters , num , i converters . length ) ; }	copies all the converters in the set to the given array .
@ override public boolean add output sensor ( string sensor name , int state ) { output sensor output sensor = new output sensor ( sensor name ) ; if ( ! output sensor . set state ( state ) ) { return bool ; } output sensor list . add ( output sensor ) ; return bool ; }	add an output sensor to this route.
public void init ( socket channel channel ) { channel = channel ; read buffer . clear ( ) ; read buffer . flip ( ) ; needs flush = bool ; }	initialize the socketstream with a new socket .
public void reset ( ) { timber . i ( str ) ; m current player . reset ( ) ; m next player . reset ( ) ; m queue = collections . empty list ( ) ; m queue index = num ; m requested seek position = num ; m play when prepared = bool ; }	resets both mediaplayers , and clears the queue.
@ override public expected < t > if present ( final consumer < ? super t > consumer ) { if ( this . value != null ) consumer . accept ( this . value ) ; return this ; }	if a value is present , invoke the consumer with the value .
protected void send intensity ( double intensity ) { if ( log . is debug enabled ( ) ) { log . debug ( str + intensity + str + str + last output step + str + max dim step ) ; } int new step = ( int ) math . round ( intensity * max dim step ) ; if ( ( new step < num ) || ( new step > max dim step ) ) { log . error ( str + new step + str + intensity ) ; } if ( new step == num ) { if ( log . is debug enabled ( ) ) { log . debug ( str + intensity + str ) ; } return ; } x10 sequence out = new x10 sequence ( ) ; out . add ext data ( housecode , devicecode , x10 sequence . extcmd dim , new step ) ; tc . send x10 sequence ( out , null ) ; last output step = new step ; if ( log . is debug enabled ( ) ) { log . debug ( str + intensity + str + x10 sequence . house value to text ( housecode ) + str + devicecode + str + new step ) ; } }	send a dim / bright commands to the x10 hardware to reach a specific intensity.
public static float read float ( ) { return scanner . next float ( ) ; }	reads the next token from standard input , parses it as a float , and returns the float .
public glow scheduler ( glow server server , world scheduler worlds ) { this . server = server ; this . worlds = worlds ; in tick task condition = worlds . get advance condition ( ) ; tick end run = null ; primary thread = thread . current thread ( ) ; }	creates a new task scheduler .
public void test fill iiii ( ) { int val = integer . max value ; int d [ ] = new int [ num ] ; arrays . fill ( d , num , d . length , val ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == val ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == val ) ; try { arrays . fill ( d , num , num , val ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } try { arrays . fill ( d , - num , num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } try { arrays . fill ( d , num , d . length + num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } }	java . util . arrays # fill ( int [ ] , int , int , int ).
private int calculate layout width ( int width size , int mode ) { init resources if necessary ( ) ; items layout . set layout params ( new layout params ( layout params . wrap content , layout params . wrap content ) ) ; items layout . measure ( measure spec . make measure spec ( width size , measure spec . unspecified ) , measure spec . make measure spec ( num , measure spec . unspecified ) ) ; int width = items layout . get measured width ( ) ; if ( mode == measure spec . exactly ) { width = width size ; } else { width += num * padding ; width = math . max ( width , get suggested minimum width ( ) ) ; if ( mode == measure spec . at most && width size < width ) { width = width size ; } } items layout . measure ( measure spec . make measure spec ( width - num * padding , measure spec . exactly ) , measure spec . make measure spec ( num , measure spec . unspecified ) ) ; return width ; }	calculates control width and creates text layouts.
public void delete ( ) throws io { close ( ) ; utils . delete contents ( directory ) ; }	closes the cache and deletes all of its stored values.
@ override public boolean execute ( @ not null psi element pe , @ not null resolve state state ) { if ( pe instanceof psi variable ) { final psi variable pvar = ( psi variable ) pe ; if ( ! my static sensitive flag || ! my static scope flag || pvar . has modifier property ( psi modifier . static ) ) { if ( check ( pvar , state ) ) { my result list . add ( pvar ) ; } } } return bool ; }	always return true since we wanna get all vars in scope.
public void characters ( char [ ] ch , int start , int length ) throws sax { try { stop terminator ( ) ; if ( w == null ) return ; int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; switch ( c ) { case str : w . write ( str ) ; break ; case str : w . write ( str ) ; break ; case str : w . write ( str ) ; break ; case str : case str : case str : w . write ( c ) ; break ; default : if ( can encode ( c ) ) { w . write ( c ) ; } else { w . write ( str ) ; w . write ( integer . to string ( c ) ) ; w . write ( str ) ; } break ; } } } catch ( io e ) { throw new sax ( e ) ; } }	inserts a string of characters into the document .
public static string to human readable string ( final string iso8601 duration ) { string str = str ; if ( iso8601 duration . matches ( str ) ) { str = str ; } else { string hours = get hours ( iso8601 duration ) , minutes = get minutes ( iso8601 duration ) , seconds = get seconds ( iso8601 duration ) ; if ( hours != null ) { str = hours ; if ( minutes != null && minutes . length ( ) == num ) { minutes = str + minutes ; } } if ( str . is empty ( ) ) str = minutes ; else str += str + minutes ; if ( str . is empty ( ) ) str = seconds ; else str += str + seconds ; } return str ; }	converts the supplies iso 8601 duration into a human readable string.
@ override public i send message ( final string text ) throws remote exception { if ( text utils . is empty ( text ) ) { throw new server api illegal argument exception ( str ) ; } int message length = text . length ( ) ; int max message length = m rcs settings . get max group chat message length ( ) ; if ( message length > max message length ) { throw new server api illegal argument exception ( str + message length + str + max message length + str ) ; } if ( ! is allowed to send message ( ) ) { throw new server api permission denied exception ( str ) ; } try { m im service . remove group chat composing status ( m chat id ) ; long timestamp = system . current time millis ( ) ; final chat message msg = chat utils . create text message ( null , text , timestamp , timestamp ) ; chat message persisted storage accessor persisted storage = new chat message persisted storage accessor ( m messaging log , msg . get message id ( ) , msg . get remote contact ( ) , text , msg . get mime type ( ) , m chat id , direction . outgoing ) ; add outgoing group chat message ( msg , content . status . queued , content . reason code . unspecified ) ; if ( ! m chat service . is group chat active ( m chat id ) ) { m chat service . set group chat state and reason code ( m chat id , group chat . state . started , group chat . reason code . unspecified ) ; } m im service . try to dequeue group chat messages and group file transfers ( m chat id ) ; return new chat message impl ( persisted storage ) ; } catch ( server api base exception e ) { if ( ! e . should not be logged ( ) ) { s logger . error ( exception util . get full stack trace ( e ) ) ; } throw e ; } catch ( exception e ) { s logger . error ( exception util . get full stack trace ( e ) ) ; throw new server api generic exception ( e ) ; } }	sends a text message to the group.
public java . lang . string to string ( ) { return to string ( value ) ; }	returns a string object representing this long ' s value.
void remove ( tcp server thread t ) { running . remove ( t ) ; }	remove a thread from the list .
public dock node event handler ( node node ) { this . node = node ; }	creates a default dock node event handler that will help this dock pane track the current docking area .
private int read source to log ( settings settings ) { string source to log = settings . get ( index indexing slowlog max source chars to log , str ) ; try { return integer . parse int ( source to log , num ) ; } catch ( number format exception e ) { return booleans . parse boolean ( source to log , bool ) ? integer . max value : num ; } }	reads how much of the source to log.
private void delete current license file on disk ( ) { file license file = new file ( license constants . license file path ) ; if ( license file . exists ( ) ) { license file . delete ( ) ; } }	deletes current version of license file in / tmp / . license.
@ deprecated public static network parameters test net ( ) { return test net3 params . get ( ) ; }	alias for testnet3params . get ( ) , use that instead .
@ override public void run ( ) { synchronized ( m sync ) { m request stop = bool ; m request drain = num ; m sync . notify ( ) ; } final boolean is running = bool ; boolean local request stop ; boolean local request drain ; while ( is running ) { synchronized ( m sync ) { local request stop = m request stop ; local request drain = ( m request drain > num ) ; if ( local request drain ) m request drain -- ; } if ( local request stop ) { drain ( ) ; signal end of input stream ( ) ; drain ( ) ; release ( ) ; break ; } if ( local request drain ) { drain ( ) ; } else { synchronized ( m sync ) { try { m sync . wait ( ) ; } catch ( final interrupted exception e ) { break ; } } } } if ( debug ) log . d ( tag , str ) ; synchronized ( m sync ) { m request stop = bool ; m is capturing = bool ; } }	encoding loop on private thread.
public final void read from stream ( data input stream dis , int version ) throws io , chess parse error { event = dis . read utf ( ) ; site = dis . read utf ( ) ; date = dis . read utf ( ) ; round = dis . read utf ( ) ; white = dis . read utf ( ) ; black = dis . read utf ( ) ; start pos = io . read fen ( dis . read utf ( ) ) ; current pos = new position ( start pos ) ; time control = dis . read utf ( ) ; if ( version >= num ) { white time control = dis . read utf ( ) ; black time control = dis . read utf ( ) ; } else { white time control = str ; black time control = str ; } int n tags = dis . read int ( ) ; tag pairs . clear ( ) ; for ( int i = num ; i < n tags ; i ++ ) { tag pair tp = new tag pair ( ) ; tp . tag name = dis . read utf ( ) ; tp . tag value = dis . read utf ( ) ; tag pairs . add ( tp ) ; } root node = new node ( ) ; node . read from stream ( dis , root node ) ; current node = root node ; int path len = dis . read int ( ) ; for ( int i = num ; i < path len ; i ++ ) go forward ( dis . read int ( ) ) ; update listener ( ) ; }	de - serialize from input stream .
public rect update fast scroller bounds ( base recycler view rv , int last touch y ) { m invalidate rect . set ( m bg bounds ) ; if ( is visible ( ) ) { int edge padding = rv . get max scrollbar width ( ) ; int bg padding = ( m bg original size - m text bounds . height ( ) ) / num ; int bg height = m bg original size ; int bg width = math . max ( m bg original size , m text bounds . width ( ) + ( num * bg padding ) ) ; if ( utilities . is rtl ( m res ) ) { m bg bounds . left = rv . get background padding ( ) . left + ( num * rv . get max scrollbar width ( ) ) ; m bg bounds . right = m bg bounds . left + bg width ; } else { m bg bounds . right = rv . get width ( ) - rv . get background padding ( ) . right - ( num * rv . get max scrollbar width ( ) ) ; m bg bounds . left = m bg bounds . right - bg width ; } m bg bounds . top = last touch y - ( int ) ( fast scroll overlay y offset factor * bg height ) ; m bg bounds . top = math . max ( edge padding , math . min ( m bg bounds . top , rv . get height ( ) - edge padding - bg height ) ) ; m bg bounds . bottom = m bg bounds . top + bg height ; } else { m bg bounds . set empty ( ) ; } m invalidate rect . union ( m bg bounds ) ; return m invalidate rect ; }	updates the bounds for the fast scroller .
public d ( j parent ) { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dnetscapecapolicyurl dialog .
public static path create directory ( final path parent , final string folder name ) { final file file = new file ( parent . to file ( ) , folder name ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdir ( ) ) { throw new runtime exception ( str + parent + str + folder name + str ) ; } } file . delete on exit ( ) ; return file . to path ( ) ; }	creates a new directory with the given parent folder and folder name.
public static boolean is windows8 ( ) { return os name . index of ( str ) > - num && ( os version . equals ( str ) || os version . equals ( str ) ) ; }	is operating system windows 8 or 8 . 1 ?.
protected set < function interface > find unused functions ( set < unit interface > units ) { set < function interface > all functions = new hash set < function interface > ( ) ; set < function interface > used functions = new hash set < function interface > ( ) ; for ( unit interface unit : units ) { list < function interface > unit functions = get unit functions ( unit ) ; all functions . add all ( unit functions ) ; for ( function interface unit function : unit functions ) { for ( function interface used function : unit function . get called functions ( ) ) { used functions . add ( used function ) ; } } } all functions . remove all ( used functions ) ; return all functions ; }	find unused functions in a unit.
private static void add items to list ( int start index , int end index ) { for ( int i = start index ; i < end index ; i ++ ) { values . add ( new integer ( i ) ) ; } }	adds the items to the list.
public static synchronized list < proxy > no proxy list ( ) { if ( no proxy list == null ) { array list < proxy > list = new array list < proxy > ( num ) ; list . add ( proxy . no proxy ) ; no proxy list = collections . unmodifiable list ( list ) ; } return no proxy list ; }	gets an unmodifiable proxy list that will have as it ' s only entry an direct proxy .
public void add includes ( string [ ] definitions ) { add strings ( includes , definitions ) ; add strings ( linker more , includes , definitions ) ; new linker options after compile . add ( includes ) ; }	adds a list of definitions to the existing list of definitions .
protected void add ( double value , int group ) { if ( ( group < num ) || ( group >= number of groups ) ) { throw new illegal argument exception ( ) ; } data . add ( new ranked observation ( value , group ) ) ; }	adds a new observation with the specified value and group .
public void tally variant ( vcf header header , vcf record rec ) { tally variant ( rec , header . get sample names ( ) ) ; }	add the given vcf record to the statistics.
public int read ( byte [ ] b , int off , int len ) throws io { if ( closed ) { throw new io ( str ) ; } if ( eof ) { return - num ; } if ( pos >= chunk size ) { next chunk ( ) ; if ( eof ) { return - num ; } } len = math . min ( len , chunk size - pos ) ; int count = in . read ( b , off , len ) ; pos += count ; return count ; }	read some bytes from the stream .
public ldif ( final string ... ldif lines ) { super ( arrays . as list ( ldif lines ) ) ; }	creates a new ldif entry reader which will read lines of ldif from the provided array of ldif lines .
public void update preson info ( ) { this . left person = person2 leaving person info . get ( this . person id ) ; this . entered person = person2 entering person info . get ( this . person id ) ; }	a person may re - appear on the same link .
public my map remove ( int position ) { my map mm = null ; if ( position >= num && position < get item count ( ) ) { mm = my maps . remove ( position ) ; notify item removed ( position ) ; } return mm ; }	remove item at the given position.
public void present licenses ( boolean pre accept ) { license set licenses = license module . get required licenses ( ) ; if ( pre accept ) { licenses . accept all ( ) ; } else { for ( license license : licenses ) { if ( license . is accepted ( ) ) { continue ; } user . show ( str ) ; user . show ( license . get license text ( ) ) ; string input = user . ask ( str ) ; if ( input != null && yes . starts with ( input . to lower case ( ) ) ) { license . accept ( ) ; } else { license . reject ( ) ; } } } }	present the licenses to the user - if the preaccept parameter is set , then simply display them through system.
public void add geo key ( xtiff geo key ) { geo key index . put ( new integer ( geo key . get tag ( ) ) , geo key ) ; has geo keys = bool ; }	add an existing geokey to the directory .
public static geo time serie detect ( geo time serie gts , int alphabet size , int word len , int window len , collection < string > patterns , boolean standardize paa ) throws warp script exception { geo time serie gts patterns = gts . b sax ( gts , alphabet size , word len , window len , standardize paa ) ; gts . sort ( gts patterns ) ; geo time serie detected = new geo time serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , num ) ; detected . set metadata ( gts . get metadata ( ) ) ; int lastidx = - num ; for ( int i = num ; i < gts patterns . values ; i ++ ) { if ( ! patterns . contains ( gts patterns . string values [ i ] ) ) { continue ; } for ( int j = num ; j < window len ; j ++ ) { if ( i + j > lastidx ) { lastidx = i + j ; gts . set value ( detected , gts . tick at index ( gts , lastidx ) , gts . location at index ( gts , lastidx ) , gts . elevation at index ( gts , lastidx ) , gts . value at index ( gts , lastidx ) , bool ) ; } } } return detected ; }	detect patterns in a geo time serie instance.
private string builder debug dump candidates ( string builder msg , list < ? extends itemset > candidates , vector field type information < bit vector > meta ) { msg . append ( str ) ; for ( itemset itemset : candidates ) { msg . append ( str ) ; itemset . append to ( msg , meta ) ; msg . append ( str ) ; } return msg ; }	debug method : output all itemsets .
public static final void write boolean array xml ( boolean [ ] val , string name , xml serializer out ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { out . start tag ( null , str ) ; out . attribute ( null , str , boolean . to string ( val [ i ] ) ) ; out . end tag ( null , str ) ; } out . end tag ( null , str ) ; }	flatten a boolean [ ] into an xmlserializer.
public void add outbound rule ( final outbound rule outbound rule ) { outbound rule . set id ( outbound rule id counter ++ ) ; outbound rules . add ( outbound rule ) ; }	will add the rule to the rules list .
public skype ( string username , string password ) { this . username = username ; this . password = password ; }	builds a new skype connection without connecting to anything .
private void stop drag ( motion event ev ) { m touch mode = touch mode idle ; final boolean commit change = ev . get action ( ) == motion event . action up && is enabled ( ) ; final boolean old state = is checked ( ) ; final boolean new state ; if ( commit change ) { m velocity tracker . compute current velocity ( num ) ; final float xvel = m velocity tracker . get x ( ) ; if ( math . abs ( xvel ) > m min fling velocity ) { new state = view utils . is layout rtl ( this ) ? ( xvel < num ) : ( xvel > num ) ; } else { new state = get target checked state ( ) ; } } else { new state = old state ; } if ( new state != old state ) { play sound effect ( sound effect constants . click ) ; } set checked ( new state ) ; cancel super touch ( ev ) ; }	called from ontouchevent to end a drag operation .
private void add flags ( int newflags ) { flags = get layout flags ( ) | newflags ; }	or newflags with existing flags.
public static string match certificate ( key store key store , x509 certificate cert ) throws crypto exception { try { for ( enumeration aliases = key store . aliases ( ) ; aliases . has more elements ( ) ; ) { string alias = ( string ) aliases . next element ( ) ; if ( key store . is certificate entry ( alias ) ) { x509 certificate comp cert = x509 cert util . convert certificate ( key store . get certificate ( alias ) ) ; if ( cert . equals ( comp cert ) ) { return alias ; } } } return null ; } catch ( key store exception ex ) { throw new crypto exception ( res . get string ( str ) , ex ) ; } }	check whether or not a trusted certificate in the supplied keystore matches the supplied x.
void purge last articles ( int amount to purge ) { if ( ! is db ( ) ) return ; long time = system . current time millis ( ) ; string query = str + table articles + str + ( utils . article limit - amount to purge + str ) ; safely delete articles ( query , null ) ; log . d ( tag , str + ( system . current time millis ( ) - time ) + str ) ; }	delete given amount of last updated articles from db.
public void reclaim views ( list < view > views ) { int child count = get child count ( ) ; recycler listener listener = m recycler . m recycler listener ; for ( int i = num ; i < child count ; i ++ ) { view child = get child at ( i ) ; two way abs list view . layout params lp = ( two way abs list view . layout params ) child . get layout params ( ) ; if ( lp != null && m recycler . should recycle view type ( lp . view type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on moved to scrap heap ( child ) ; } } } m recycler . reclaim scrap views ( views ) ; remove all views in layout ( ) ; }	move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list.
proxy verifier ( txn manager server proxy , uuid proxy id ) { if ( ! ( server proxy instanceof remote method control ) ) { throw new unsupported operation exception ( str ) ; } else if ( ! ( server proxy instanceof trust equivalence ) ) { throw new unsupported operation exception ( str + str ) ; } else if ( proxy id == null ) { throw new illegal argument exception ( str ) ; } this . server proxy = ( remote method control ) server proxy ; this . proxy id = proxy id ; }	returns a verifier for the smart proxies of the specified mahalo server proxy .
public void paint ( graphics g ) { g . translate ( num , translate y ) ; super . paint ( g ) ; }	displays our component in the location ( 0 , translatey ).
private void before key ( ) throws json { scope context = peek ( ) ; if ( context == scope . nonempty object ) { out . append ( str ) ; } else if ( context != scope . empty object ) { throw new json ( str ) ; } newline ( ) ; replace top ( scope . dangling key ) ; }	inserts any necessary separators and whitespace before a name.
public static void transfer ( input stream in , output stream out , int buffer size ) throws io { byte [ ] buffer = new byte [ buffer size ] ; int bytes read ; while ( ( bytes read = in . read ( buffer ) ) != - num ) { out . write ( buffer , num , bytes read ) ; } }	copies data from an input stream to an output stream using a buffer of specified size .
public void test file directory ( ) throws exception { properties properties = load properties ( str ) ; assert equals ( str , properties . get property ( str ) ) ; }	test the configuration files option with copying of subdirectory as - is .
private static long add and check ( long a , long b , localizable pattern ) throws math runtime exception { final long result = a + b ; if ( ! ( ( a ^ b ) < num || ( a ^ result ) >= num ) ) { throw new math runtime exception ( pattern , a , b ) ; } return result ; }	add two long integers , checking for overflow .
private void serialize compact rdf ( int indent , xmp node ) throws io , xmp { write ( str ) ; write newline ( ) ; serialize canonical rdf ( node , bool , bool , indent + num ) ; for ( iterator iq = node . iterate qualifier ( ) ; iq . has next ( ) ; ) { xmp qualifier = ( xmp ) iq . next ( ) ; serialize canonical rdf ( qualifier , bool , bool , indent + num ) ; } }	serializes the general qualifier .
private j add checkbox ( string text , container container ) { j checkbox = new j ( text ) ; checkbox . set alignment x ( component . left alignment ) ; checkbox . set border ( border factory . create empty border ( num , num , num , num ) ) ; container . add ( checkbox ) ; return checkbox ; }	adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .
public void push ( ) { state . cliprgn = g . get clip bounds ( ) ; stack . push ( state ) ; state = ( graphics state ) state . clone ( ) ; }	push the current graphics state onto the stack.
public static void drop index ( connection conn , string schema , string table ) throws sql { init ( conn ) ; prepared statement prep = conn . prepare statement ( str + schema + str ) ; prep . set string ( num , schema ) ; prep . set string ( num , table ) ; result set rs = prep . execute query ( ) ; if ( ! rs . next ( ) ) { return ; } int index id = rs . get int ( num ) ; prep = conn . prepare statement ( str + schema + str ) ; prep . set int ( num , index id ) ; prep . execute ( ) ; create or drop trigger ( conn , schema , table , bool ) ; prep = conn . prepare statement ( str + schema + str ) ; while ( bool ) { prep . set int ( num , index id ) ; int deleted = prep . execute update ( ) ; if ( deleted == num ) { break ; } } prep = conn . prepare statement ( str + schema + str + str + schema + str ) ; while ( bool ) { int deleted = prep . execute update ( ) ; if ( deleted == num ) { break ; } } }	drop an existing full text index for a table.
public e peek ( ) { if ( is empty ( ) ) { return null ; } return elements [ num ] ; }	gets but does not remove the head of the queue .
public synchronized int add ( i processor ) { processors . add ( processor ) ; build final processor ( ) ; return processors . index of ( processor ) ; }	adds a processor to the internal processor queue .
public script builder data ( int index , byte [ ] data ) { byte [ ] copy = arrays . copy of ( data , data . length ) ; int opcode ; if ( data . length == num ) { opcode = op 0 ; } else if ( data . length == num ) { byte b = data [ num ] ; if ( b >= num && b <= num ) opcode = script . encode to op n ( b ) ; else opcode = num ; } else if ( data . length < op pushdat ) { opcode = data . length ; } else if ( data . length < num ) { opcode = op pushdat ; } else if ( data . length < num ) { opcode = op pushdat ; } else { throw new runtime exception ( str ) ; } return add chunk ( index , new script chunk ( opcode , copy ) ) ; }	adds a copy of the given byte array as a data element ( i.
public void initialize ( map config params ) { string delimiter config = ( string ) config params . get ( policy config . resource comparator delimiter ) ; if ( delimiter config != null ) { this . delimiter = delimiter config ; } string case config = ( string ) config params . get ( policy config . resource comparator case sensitive ) ; if ( case config != null ) { if ( case config . equals ( str ) ) { this . case sensitive = bool ; } else if ( case config . equals ( str ) ) { this . case sensitive = bool ; } else { this . case sensitive = bool ; } } string wildcard config = ( string ) config params . get ( policy config . resource comparator wildcard ) ; if ( wildcard config != null ) { this . wildcard = wildcard config ; } string one level wildcard config = ( string ) config params . get ( policy config . resource comparator one level wildcard ) ; if ( one level wildcard config != null ) { this . one level wildcard = one level wildcard config ; } if ( debug . message enabled ( ) ) { debug . message ( str + str + delimiter + str + wildcard + str + one level wildcard + str + case config ) ; } one level wildcard length = one level wildcard . length ( ) ; wildcard length = wildcard . length ( ) ; if ( one level wildcard . index of ( wildcard ) != - num ) { wildcard embedded = bool ; } else { wildcard embedded = bool ; } if ( wildcard . index of ( one level wildcard ) != - num ) { one level wildcard embedded = bool ; } else { one level wildcard embedded = bool ; } if ( debug . message enabled ( ) ) { debug . message ( str + wildcard embedded + str + one level wildcard embedded ) ; } return ; }	initializes the resource name with configuration information , usally set by the administrators.
protected void delete least used entry ( ) { try { pool lock . lock ( ) ; basic pool entry entry = free connections . remove ( ) ; if ( entry != null ) { delete entry ( entry ) ; } else if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } } finally { pool lock . unlock ( ) ; } }	delete an old , free pool entry to make room for a new one.
private string convert less than one thousand ( int number ) { string so far ; if ( number % num < num ) { so far = num names [ number % num ] ; number /= num ; } else { so far = num names [ number % num ] ; number /= num ; string s = integer . to string ( number ) ; if ( s . ends with ( str ) && ! so far . equals ( str ) ) so far = str + so far . trim ( ) ; else if ( so far . equals ( str ) ) so far = tens names [ number % num ] + so far ; else so far = tens names [ number % num ] + str + so far ; number /= num ; } if ( number == num ) return tens names [ number % num ] + so far ; if ( number > num ) so far = str + so far ; if ( number == num && ! so far . equals ( str ) ) number = num ; return num names [ number ] + str + so far ; }	convert less than one thousand.
public static boolean is embedded base64 image ( string uri ) { return ( uri != null && uri . starts with ( str ) ) ; }	detect if an uri represents an embedded base 64 image .
void change state ( int new state ) { int old state ; synchronized ( state lock ) { if ( state == new state ) return ; old state = state ; state = new state ; state lock . notify all ( ) ; } send state change notification ( old state , new state ) ; }	for internal use only .
private int parse link label ( ) { string m = match ( link label ) ; return m == null ? num : m . length ( ) ; }	attempt to parse a link label , returning number of characters parsed .
public static string read file as string ( file file ) throws file not found exception { return read file as string ( file . get absolute path ( ) ) ; }	devuelve el contenido de un file como string.
protected void on exception ( final wro runtime exception e ) { throw e ; }	invoked when an unexpected exception occurred during processing.
public synchronized void check access ( license checker callback callback ) { if ( m policy . allow access ( ) ) { log . i ( tag , str ) ; callback . allow ( policy . licensed ) ; } else { license validator validator = new license validator ( m policy , new null device limiter ( ) , callback , generate nonce ( ) , m package name , m version code ) ; if ( m service == null ) { log . i ( tag , str ) ; try { boolean bind result = m context . bind service ( new intent ( new string ( base64 . decode ( str ) ) ) , this , context . bind auto create ) ; if ( bind result ) { m pending checks . offer ( validator ) ; } else { log . e ( tag , str ) ; handle service connection error ( validator ) ; } } catch ( security exception e ) { callback . application error ( license checker callback . error missing permission ) ; } catch ( base64 decoder exception e ) { e . print stack trace ( ) ; } } else { m pending checks . offer ( validator ) ; run checks ( ) ; } } }	checks if the user should have access to the app.
public void close ( ) { if ( ! is open ) return ; log . d ( tag , str ) ; loading lock . lock ( ) ; try { save ( ) ; if ( save file stream != null ) { saving helper . close ( save file stream ) ; save file stream = null ; } saving disabled = bool ; is open = bool ; log . i ( tag , str ) ; } finally { loading lock . unlock ( ) ; } }	saves and closes the track.
protected int select operator ( ) { last update ++ ; if ( ( last update >= update window ) || ( probabilities == null ) ) { last update = num ; probabilities = get operator probabilities ( ) ; } double rand = prng . next double ( ) ; double sum = num ; for ( int i = num ; i < operators . size ( ) ; i ++ ) { sum += probabilities [ i ] ; if ( sum > rand ) { return i ; } } throw new illegal state exception ( ) ; }	returns the index of one of the available operators randomly selected using the probabilities .
@ override public list chunk string ( string s to chunk ) { integer [ ] i res = split points by delimiter list ( s to chunk , get delimiters ( ) ) ; string [ ] s res = split string by delimiter points ( s to chunk , i res ) ; return arrays . as list ( s res ) ; }	returns a list of string chunks , derived from a given string .
public static string convert boolean arr to string ( boolean [ ] no dictionary dims mapping ) { string builder builder = new string builder ( ) ; int index = num ; for ( ; index < no dictionary dims mapping . length ; index ++ ) { builder . append ( no dictionary dims mapping [ index ] ) ; builder . append ( carbon common constants . coma spc character ) ; } int last index = builder . last index of ( carbon common constants . coma spc character ) ; string str = - num != last index ? builder . substring ( num , last index ) : builder . to string ( ) ; return str ; }	this method will convert boolean [ ] to string with comma separated.
public byte buffer decode buffer to byte buffer ( string input string ) throws io { return byte buffer . wrap ( decode buffer ( input string ) ) ; }	decode the contents of the string into a bytebuffer .
public void clear ( ) { m . clear ( ) ; set buttons ( null ) ; }	clears the content of the panel.
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( num / ( num - scale ) ) ; if ( r == num && g == num && b == num ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > num && r < i ) r = i ; if ( g > num && g < i ) g = i ; if ( b > num && b < i ) b = i ; return rgba ( math . min ( num , ( int ) ( r / scale ) ) , math . min ( num , ( int ) ( g / scale ) ) , math . min ( num , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }	get a brighter shade of an input color .
public void shutdown ( ) { running = bool ; if ( network threads != null ) { for ( network thread n : network threads ) { n . stopped = bool ; } } network threads = null ; synchronized ( lock ) { lock . notify all ( ) ; } }	shuts down the network thread , this will trigger failures if you have network requests.
public serial message ( byte [ ] a ) { super ( string . value of ( a ) ) ; set binary ( bool ) ; }	this ctor interprets the byte array as a sequence of characters to send .
@ override @ suppress warnings ( str ) public void completed ( int bytes transferred , boolean can invoke direct ) { if ( bytes transferred == num ) { bytes transferred = - num ; } else { update buffers ( bytes transferred ) ; } release buffers ( ) ; synchronized ( result ) { if ( result . is done ( ) ) return ; enable reading ( ) ; if ( scattering read ) { result . set result ( ( v ) long . value of ( bytes transferred ) ) ; } else { result . set result ( ( v ) integer . value of ( bytes transferred ) ) ; } } if ( can invoke direct ) { invoker . invoke unchecked ( result ) ; } else { invoker . invoke ( result ) ; } }	executed when the i / o has completed.
public void write golomb ( int divisor , int value ) { int q = value / divisor ; for ( int i = num ; i < q ; i ++ ) { write bit ( num ) ; } write bit ( num ) ; int r = value - q * divisor ; int bit = num - integer . number of leading zeros ( divisor - num ) ; if ( r < ( ( num << bit ) - divisor ) ) { bit -- ; } else { r += ( num << bit ) - divisor ; } for ( ; bit >= num ; bit -- ) { write bit ( ( r > > > bit ) & num ) ; } }	write the golomb code of a value .
public void add force ( force f ) { if ( f . is item force ( ) ) { if ( iforces . length == iflen ) { force [ ] newf = new force [ iflen + num ] ; system . arraycopy ( iforces , num , newf , num , iforces . length ) ; iforces = newf ; } iforces [ iflen ++ ] = f ; } if ( f . is spring force ( ) ) { if ( sforces . length == sflen ) { force [ ] newf = new force [ sflen + num ] ; system . arraycopy ( sforces , num , newf , num , sforces . length ) ; sforces = newf ; } sforces [ sflen ++ ] = f ; } }	add a new force function to the simulator .
private static metric value number to metric value ( number elem ) { if ( elem == null ) return metric value . empty ; final string num = elem . to string ( ) ; try { return metric value . from int value ( long . parse long ( num ) ) ; } catch ( number format exception ex ) { } try { return metric value . from dbl value ( double . parse double ( num ) ) ; } catch ( number format exception ex ) { } return metric value . from str value ( num ) ; }	work around for google gson parser emitting numbers as ' lazily parsed ' numbers .
public boolean overlaps ( string sequence , int start , int end ) { if ( start == missing || end == missing || end < start ) { throw new illegal argument exception ( ) ; } if ( ! m sequence . equals ( sequence ) ) { return bool ; } if ( ( m end != missing && start >= m end ) || ( end <= m start ) ) { return bool ; } return bool ; }	test whether the specified range overlaps the current region.
public b ( double k1 , double b ) { if ( double . is na n ( k1 ) || double . is infinite ( k1 ) || k1 < num ) throw new illegal argument exception ( str + k1 ) ; this . k1 = k1 ; if ( double . is na n ( b ) || b < num || b > num ) throw new illegal argument exception ( str + b ) ; this . b = b ; }	creates a new okapi object.
protected void prepare ( ) { for ( process info parameter para : get parameter ( ) ) { string name = para . get parameter name ( ) ; if ( para . get parameter ( ) == null ) ; else if ( name . equals ( param m id ) ) p m id = para . get parameter as int ( ) ; else log . log ( level . severe , str + name ) ; } p c id = get record id ( ) ; }	prepare - e . g . , get parameters .
public boolean is configured ( ) { log . debug ( str + url ) ; return url != null && ! url . is empty ( ) ; }	method to quickly indicate if the service is not configured .
public static string [ ] comma delimited list to string array ( string str ) { return delimited list to string array ( str , str ) ; }	convert a csv list into an array of strings .
@ override public byte [ ] read byte array ( string file path , long offset , int length ) { file channel file channel = update cache ( file path ) ; byte buffer byte bffer = read ( file channel , length , offset ) ; return byte bffer . array ( ) ; }	this method will be used to read the byte array from file based on offset and length ( number of bytes ) need to read.
private static void fatal error ( jni env , address message address ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { vm . sys write ( jni . create string from c ( message address ) ) ; system . exit ( exit status jni trouble ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; system . exit ( exit status recursively shutting down ) ; } }	fatalerror : print a message and terminate the vm.
public boolean make backup file ( string directory , file file ) { if ( file == null ) { log . info ( str ) ; } else if ( file . can write ( ) ) { string backup full name = directory + file . separator + create file name with date ( file . get name ( ) ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + backup full name ) ; } file backup file = find file ( backup full name ) ; if ( backup file != null ) { if ( backup file . delete ( ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + backup full name ) ; } } } else { backup file = new file ( backup full name ) ; } file parent dir = backup file . get parent file ( ) ; if ( ! parent dir . exists ( ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + parent dir . get name ( ) ) ; } if ( ! parent dir . mkdirs ( ) ) { log . error ( str ) ; return bool ; } } if ( file . rename to ( new file ( backup full name ) ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + backup full name ) ; } } else { if ( log . is debug enabled ( ) ) { log . debug ( str + backup full name ) ; } return bool ; } } return bool ; }	move original file to backup directory .
public final void push pair ( int v1 , int v2 ) { if ( null == m map ) { m map = new int [ m blocksize ] ; m map size = m blocksize ; } else { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free ) ; m map = new map ; } } m map [ m first free ] = v1 ; m map [ m first free + num ] = v2 ; m first free += num ; }	push a pair of nodes into the stack.
public void remove storage ( ) throws backup exception { logger . debug ( str + data dir spec . get absolute path ( ) ) ; process helper . exec ( str , rm cmd ) ; }	clears storage in preparation for restore operation .
private void append container config ( docker slave template slave template , create container cmd container config ) { map < string , string > labels = container config . get labels ( ) ; if ( labels == null ) { labels = new hash map < > ( ) ; } labels . put ( docker cloud label , get display name ( ) ) ; labels . put ( docker template label , slave template . get id ( ) ) ; container config . with labels ( labels ) ; }	cloud specific container config options.
read only game settings ( ) { }	constructs game settings with default parameters.
public void delete users ( set users ) throws am , sso { iterator iter = users . iterator ( ) ; while ( iter . has next ( ) ) { string user dn = ( string ) iter . next ( ) ; am user = new am ( super . token , user dn ) ; user . delete ( ) ; } }	removes users from the organization .
@ override public boolean accept ( file file ) { string name = file . get name ( ) ; for ( string wildcard : wildcards ) { if ( filename utils . wildcard match ( name , wildcard , case sensitivity ) ) { return bool ; } } return bool ; }	checks to see if the filename matches one of the wildcards .
public void remove region ( region r ) { regions . remove ( r ) ; }	include a region in the model.
public static void silent close input stream ( input stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( io e ) { log . w ( log tag , str , e ) ; } }	a utility function to close an input stream without raising an exception .
@ override public void start element ( string uri , string local name , string q name , attributes attributes ) throws sax { if ( request id == null && local name . equals ( str ) ) { request id = attributes . get value ( str ) ; } super . start element ( uri , local name , q name , attributes ) ; }	this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .
public void stop ( int timeout ) throws interrupted exception { if ( ! isclosed . compare and set ( bool , bool ) ) { return ; } list < web socket > sockets to close = null ; synchronized ( connections ) { sockets to close = new array list < web socket > ( connections ) ; } for ( web socket ws : sockets to close ) { ws . close ( close frame . going away ) ; } synchronized ( this ) { if ( selectorthread != null ) { if ( thread . current thread ( ) != selectorthread ) { } if ( selectorthread != thread . current thread ( ) ) { if ( sockets to close . size ( ) > num ) selectorthread . join ( timeout ) ; selectorthread . interrupt ( ) ; selectorthread . join ( ) ; } } } }	closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads.
public storage ( ) { this ( new file ( get temporary storage directory string ( ) ) ) ; }	creates new instance of storage for storing temporary data.
protected void calculate item width ( category plot plot , d data area , int renderer index , category item renderer state state ) { category axis domain axis = get domain axis ( plot , renderer index ) ; category dataset dataset = plot . get dataset ( renderer index ) ; if ( dataset != null ) { int columns = dataset . get column count ( ) ; int rows = state . get visible series count ( ) >= num ? state . get visible series count ( ) : dataset . get row count ( ) ; double space = num ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation == plot orientation . horizontal ) { space = data area . get height ( ) ; } else if ( orientation == plot orientation . vertical ) { space = data area . get width ( ) ; } double max width = space * get maximum item width ( ) ; double category margin = num ; double current item margin = num ; if ( columns > num ) { category margin = domain axis . get category margin ( ) ; } if ( rows > num ) { current item margin = get item margin ( ) ; } double used = space * ( num - domain axis . get lower margin ( ) - domain axis . get upper margin ( ) - category margin - current item margin ) ; if ( ( rows * columns ) > num ) { state . set bar width ( math . min ( used / ( rows * columns ) , max width ) ) ; } else { state . set bar width ( math . min ( used , max width ) ) ; } } }	calculates the bar width and stores it in the renderer state .
@ requires permission ( manifest . permission . camera ) public camera source start ( ) throws io { synchronized ( m camera lock ) { if ( m camera != null ) { return this ; } m camera = create camera ( ) ; if ( build . version . sdk int >= build . version codes . honeycomb ) { m dummy surface texture = new surface texture ( dummy texture name ) ; m camera . set preview texture ( m dummy surface texture ) ; } else { m dummy surface view = new surface view ( m context ) ; m camera . set preview display ( m dummy surface view . get holder ( ) ) ; } m camera . start preview ( ) ; is safe to take picture = bool ; m processing thread = new thread ( m frame processor ) ; m frame processor . set active ( bool ) ; m processing thread . start ( ) ; } return this ; }	opens the camera and starts sending preview frames to the underlying detector.
public void add breakpoint listener ( final breakpoint listener listener ) { breakpoint listeners . add ( listener ) ; }	adds a breakpoint listener .
public void update ( graphics g ) { if ( is showing ( ) ) { if ( ! ( peer instanceof lightweight peer ) ) { g . clear rect ( num , num , width , height ) ; } paint ( g ) ; } }	updates the container . this forwards the update to any lightweight components that are children of this container . if this method is reimplemented , super . update ( g ) should be called so that lightweight components are properly rendered . if a child component is entirely clipped by the current clipping setting in g , update ( ) will not be forwarded to that child .
private void release waiters ( int phase ) { q q ; thread t ; atomic reference < q > head = ( phase & num ) == num ? even q : odd q ; while ( ( q = head . get ( ) ) != null && q . phase != ( int ) ( root . state > > > phase shift ) ) { if ( head . compare and set ( q , q . next ) && ( t = q . thread ) != null ) { q . thread = null ; lock support . unpark ( t ) ; } } }	removes and signals threads from queue for phase .
public static date format to date time format ( string date time format , time zone tz , locale locale ) { date format df = null ; if ( util validate . is empty ( date time format ) ) { df = date format . get date time instance ( date format . short , date format . medium , locale ) ; } else { df = new simple date format ( date time format , locale == null ? locale . get default ( ) : locale ) ; } df . set time zone ( tz ) ; return df ; }	returns an initialized dateformat object .
public static void print stack trace ( throwable e ) { try { debug . print stack trace ( e ) ; } catch ( throwable f ) { e . print stack trace ( ) ; } }	used in environments where full debug may not be available.
@ override public void visit type ( type element e , void p ) { scan ( e . get type parameters ( ) , p ) ; check camel case ( e , bool ) ; super . visit type ( e , p ) ; return null ; }	check the name of a type and its enclosed elements and type parameters .
public block ( boolean multi push ) { this ( multi push , str , null , arrays . as list ( str , str ) ) ; }	create a new block with default style at ( startx , starty ).
private double poisson ( double x ) { return math . exp ( - m + ( x * math . log ( m ) ) - log fac ( x ) ) ; }	returns value for poisson distribution.
protected expression find expression ( string source ) { if ( source != null && source . length ( ) > num ) { source = source . trim ( ) ; if ( source . length ( ) == num ) { return null ; } string left side = source ; string right side = null ; connector op = find op ( left side ) ; if ( op != null ) { right side = op . get right side ( left side ) ; left side = left side . substring ( num , op . source loc ) ; expression left expression = find expression ( left side ) ; expression right expression = find expression ( right side ) ; if ( left expression != null ) { op . add expr ( left expression ) ; } if ( right expression != null ) { op . add expr ( right expression ) ; } return op ; } op = find mini op ( left side ) ; if ( op != null ) { right side = op . get right side ( left side ) ; left side = left side . substring ( num , op . source loc ) ; expression left expression = find expression ( left side ) ; expression right expression = find expression ( right side ) ; if ( left expression != null ) { op . add expr ( left expression ) ; } if ( right expression != null ) { op . add expr ( right expression ) ; } return op ; } if ( logger . is loggable ( level . finer ) ) { logger . finer ( str + source ) ; } return find math op ( source ) ; } return null ; }	recursive parsing statement . keys on connectors ( and , or ) and builds expressions based on those . then looks for mini connectors ( and , or ) and builds on those . of course , there might just be one expression here , one that is separated by an operator .
void put channel ( final stored client channel channel ) { put channel ( channel , bool ) ; }	adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension.
private void delete files in dir ( file dir ) { for ( file child : dir . list files ( ) ) { child . delete ( ) ; } }	deletes all files in a folder.
@ suppress warnings ( str ) public static void pipe input to output stream ( input stream in , file file out , boolean ignore errors ) throws io { if ( file out == null ) { logger . error ( str ) ; if ( ! ignore errors ) { throw new io ( str ) ; } } else { file parent = file out . get parent file ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } output stream file stream = null ; try { file stream = new file output stream ( file out ) ; pipe input to output stream ( in , file stream , bool , ignore errors ) ; } catch ( io e ) { if ( file stream != null ) { try { file stream . close ( ) ; } catch ( io ex ) { logger . error ( str , ex . get message ( ) ) ; } } if ( ! ignore errors ) { throw e ; } } } }	convenient way of sending data from an input stream to an output file in the most efficient way possible.
@ suppress lint ( str ) void release ( ) { assert ( m processing thread . get state ( ) == state . terminated ) ; m detector . release ( ) ; m detector = null ; }	releases the underlying receiver.
public static string trim leading character ( string str , char leading character ) { if ( ! has length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > num && sb . char at ( num ) == leading character ) { sb . delete char at ( num ) ; } return sb . to string ( ) ; }	trim all occurrences of the supplied leading character from the given string .
public e take ( ) throws interrupted exception { final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; long t = now ( ) ; tenant queue . item item = null ; try { for ( ; ; ) { tenant queue q = next queue ( t ) ; if ( q == null ) available . await ( ) ; else { long delay = q . next - t ; if ( delay <= num ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } else if ( leader != null ) available . await ( ) ; else { thread this thread = thread . current thread ( ) ; leader = this thread ; try { available . await nanos ( delay ) ; } finally { if ( leader == this thread ) leader = null ; } } } t = system . nano time ( ) ; } } finally { if ( leader == null && has next ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .
public boolean thread safe timeout ( long delay time , time unit unit , action0 action ) { boolean scheduled = bool ; thread current thread = thread . current thread ( ) ; if ( current thread . equals ( duty thread ) ) { timer wheel . new timeout ( delay time , unit , null ) ; } else { scheduled = actions . offer ( null ) ; } return scheduled ; }	schedules timeout on the timerwheel in a thread - safe manner.
void submit ( process and display image task task ) { init executors if need ( ) ; task executor for cached images . execute ( task ) ; }	submits task to execution pool.
void add attribute selection ( string exp ) { int index = exp . index of ( str ) ; string value = null ; int constraint = att string . equals ; if ( index != - num ) { if ( index == num ) { set tag id ( tag css illegal selector ) ; return ; } int op index = index ; char c = exp . char at ( index - num ) ; if ( c == str ) { constraint = att string . contains word ; op index -- ; } else if ( c == str ) { constraint = att string . begins with ; op index -- ; } value = exp . substring ( index + num ) ; if ( ( ( value . starts with ( str ) ) && ( value . ends with ( str ) ) ) || ( ( value . starts with ( str ) ) && ( value . ends with ( str ) ) ) ) { value = value . substring ( num , value . length ( ) - num ) ; } exp = exp . substring ( num , op index ) ; } if ( attribute selections == null ) { attribute selections = new vector ( ) ; } attribute selections . add element ( new att string ( exp , constraint , value ) ) ; }	adds the given attribute selection.
private void create left over ( ) { int line length bytes = current last byte pos + num ; if ( line length bytes > num ) { left over = new byte [ line length bytes ] ; system . arraycopy ( data , num , left over , num , line length bytes ) ; } else { left over = null ; } current last byte pos = - num ; }	creates the buffer containing any left over bytes .
public value sample ( ) { int index = sampler . next int ( action values . size ( ) ) ; if ( action values as array == null ) { action values as array = action values . to array ( new value [ action values . size ( ) ] ) ; } return action values as array [ index ] ; }	returns a sample point for the action , assuming a uniform distribution over the action values.
@ override public void channel closed ( channel handler context channel handler context , channel state event channel state event ) throws exception { curr conns . decrement and get ( ) ; channel group . remove ( channel handler context . get channel ( ) ) ; }	on close we manage some statistics , and remove this connection from the channel group .
private static void configure head less simulation ( ) { system . set property ( str , str ) ; gama . set head less mode ( ) ; }	load in headless mode a specified model and create an experiment.
public static boolean is next window ( uri id ) { return id == null || next . equals ( id ) ; }	determines if this id corresponds to the ' next ' execution window .
public static boolean is visible ( class < ? > clazz , class loader class loader ) { if ( class loader == null ) { return bool ; } try { class < ? > actual class = class loader . load class ( clazz . get name ( ) ) ; return ( clazz == actual class ) ; } catch ( class not found exception ex ) { return bool ; } }	check whether the given class is visible in the given classloader .
public byte [ ] remove ( queue event event ) throws keeper exception , interrupted exception { timer context time = stats . time ( dir + str ) ; try { string path = event . get id ( ) ; string response path = dir + str + response prefix + path . substring ( path . last index of ( str ) + num ) ; if ( zookeeper . exists ( response path , bool ) ) { zookeeper . set data ( response path , event . get bytes ( ) , bool ) ; } byte [ ] data = zookeeper . get data ( path , null , null , bool ) ; zookeeper . delete ( path , - num , bool ) ; return data ; } finally { time . stop ( ) ; } }	remove the event and save the response into the other path .
public xml ( service schema service schema , am model , set attribute schemas ) throws sms , sso { this . model = model ; this . service name = service schema . get service name ( ) ; get service resource bundle ( service schema ) ; if ( service bundle != null ) { map type to attribute schema = new hash map ( attribute schemas . size ( ) * num ) ; map type to attribute schema . put ( null type , attribute schemas ) ; } }	returns a xml for displaying attribute in property sheet .
public boolean is ( string arg , boolean allow abbr ) { if ( name . equals ignore case ( arg ) ) { return bool ; } if ( allow abbr && arg . length ( ) == num ) { if ( arg . char at ( num ) == c ) { return bool ; } } return bool ; }	returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .
static public void add all ( list < string > list , string [ ] array ) { for ( string item : array ) list . add ( item ) ; }	adds all items in the specific array to the specific list .
void remove ( super card toast super card toast ) { m list . remove ( super card toast ) ; }	removes a supercardtoast from the list .
public void test vmstat header and data parse ( ) { final pattern pattern = vm . pattern ; final string header = str ; final string data = str ; { final string [ ] fields = pattern . split ( header . trim ( ) , num ) ; for ( int i = num ; i < fields . length ; i ++ ) { if ( log . is info enabled ( ) ) log . info ( str + i + str + fields [ i ] + str ) ; } assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; assert field ( header , fields , num , str ) ; } { final string [ ] fields = pattern . split ( data . trim ( ) , num ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; assert field ( data , fields , num , str ) ; } }	test based on some sample data .
public static secret keys generate key from password ( string password , string salt ) throws general security exception { return generate key from password ( password , base64 . decode ( salt , bas flags ) ) ; }	a function that generates password - based aes & hmac keys.
private string partially escape assertion value ( string assertion value ) { string builder sb = new string builder ( assertion value . length ( ) ) ; for ( int j = num ; j < assertion value . length ( ) ; j ++ ) { char c = assertion value . char at ( j ) ; if ( c == str ) { sb . append ( c ) ; } else { sb . append ( filter . escape assertion value ( string . value of ( c ) ) ) ; } } return sb . to string ( ) ; }	escapes the provided assertion value according to the ldap standard.
protected boolean filter leftover view ( view group parent , int child index ) { parent . remove view at ( child index ) ; return bool ; }	filter the child view at index and remove it if appropriate .
protected boolean decl already declared ( string prefix ) { int start decls = m context indexes . peek ( ) ; java . util . vector prefix mappings = m prefix mappings ; int n decls = prefix mappings . size ( ) ; for ( int i = start decls ; i < n decls ; i += num ) { string prefix decl = ( string ) prefix mappings . element at ( i ) ; if ( prefix decl == null ) continue ; if ( prefix decl . equals ( prefix ) ) return bool ; } return bool ; }	check if a declaration has already been made for a given prefix .
@ override public void step ( message logger logger ) { try { add agent ( ) ; env . step ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	executes one simulation step .
public static attack status calculate physical status ( creature attacker , creature attacked , boolean is main hand ) { return calculate physical status ( attacker , attacked , is main hand , num , num , bool , bool ) ; }	manage attack status rate.
public t vertex processor ( final bi consumer < vertex , map < string , object > > vertex processor ) { this . vertex processor = optional . of nullable ( vertex processor ) ; return extending class . cast ( this ) ; }	the function supplied here may be called more than once per vertex depending on the implementation .
synchronized boolean release ( ) { d ( str ) ; if ( state == busy ) { state = idle ; idle since = system . current time millis ( ) ; return bool ; } else { return bool ; } }	changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .
private void validate replica availability ( slice slice , string shard , string collection name , int count ) { if ( slice != null ) { collection < replica > all replicas for shard = slice . get replicas ( ) ; if ( all replicas for shard == null ) { throw new solr exception ( solr exception . error code . bad request , str + shard + str + collection name ) ; } if ( all replicas for shard . size ( ) == num ) { throw new solr exception ( solr exception . error code . bad request , str + shard + str + collection name + str ) ; } if ( all replicas for shard . size ( ) <= count ) { throw new solr exception ( solr exception . error code . bad request , str + shard + str + collection name + str + count + str + all replicas for shard . size ( ) + str ) ; } } }	validate if there is less replicas than requested to remove . also error out if there is only one replica available.
default class declaration as class ( ) { throw new unsupported operation exception ( string . format ( str , this ) ) ; }	return this as a classdeclaration or throw unsupportedoperationexception .
private static string partition spec to name ( map < string , string > spec ) { string builder sb = new string builder ( ) ; for ( map . entry < string , string > entry : spec . entry set ( ) ) { if ( sb . length ( ) != num ) { sb . append ( str ) ; } sb . append ( entry . get key ( ) + str + entry . get value ( ) ) ; } return sb . to string ( ) ; }	converts a map of partition key - value pairs to a name.
public static input stream to input stream ( char sequence input , charset encoding ) { return to input stream ( input . to string ( ) , encoding ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .
public void test hit end after find ( ) { hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; string float regex = get hex float regex ( ) ; hit end test ( bool , str , float regex , double . to hex string ( - num ) , bool ) ; hit end test ( bool , str , float regex , str + double . to hex string ( double . n ) + str , bool ) ; hit end test ( bool , str , float regex , double . to hex string ( - num ) + str , bool ) ; hit end test ( bool , str , float regex , str + double . to hex string ( double . min value ) + str , bool ) ; hit end test ( bool , str , str , str , bool ) ; hit end test ( bool , str , str , str , bool ) ; }	regression test for harmony - 4396.
@ modifying @ transactional public void delete cheque ( @ path variable long cheque id ) { cheque repository . delete ( cheque id ) ; photo repository . delete by cheque id ( cheque id . to string ( ) ) ; }	method deletecheque remove cheque from db by id.
public static synchronized double partial correlation ( tetrad matrix submatrix ) { try { tetrad matrix inverse = submatrix . inverse ( ) ; double a = - num * inverse . get ( num , num ) ; double v0 = inverse . get ( num , num ) ; double v1 = inverse . get ( num , num ) ; double b = math . sqrt ( v0 * v1 ) ; return a / b ; } catch ( exception e ) { e . print stack trace ( ) ; return double . n ; } }	assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 ,.
public void add column ( string name , string expr ) { expression ex = expression parser . parse ( expr ) ; throwable t = expression parser . get error ( ) ; if ( t != null ) { throw new runtime exception ( t ) ; } else { add column ( name , ex ) ; } }	add a derived column to this table , using an expression instance to dynamically calculate the column data values .
public void add put and get time nanos ( long duration ) { put time nanos . add and get ( duration ) ; get time nanos . add and get ( duration ) ; if ( delegate != null ) delegate . add put and get time nanos ( duration ) ; }	increments put and get time accumulators .
private float check saturation valid ( final float val ) { float tempval = val ; if ( val > num ) { tempval = num ; } if ( val < num ) { tempval = num ; } return tempval ; }	check whether the specified saturation is valid or not .
string parse ( string cell str , int layout constant ) { return cell str . split ( layout constants . cell ptrn ) [ layout constant ] ; }	utility method to parse a cell definition for a particular value .
public void pseudo property change ( string prop name , object old , object n ) { if ( log . is debug enabled ( ) ) { log . debug ( str + get system name ( ) + str + prop name + str + n . to string ( ) ) ; } fire property change ( prop name , old , n ) ; }	call for circuit builder to make icon color changes for its gui.
public static string run cmd ( file directory , list < string > cmd , string error message ) throws exception { process builder pb = new process builder ( cmd ) ; pb . directory ( directory ) ; pb . redirect error stream ( bool ) ; process p = pb . start ( ) ; string s ; string builder sb = new string builder ( ) ; buffered reader stdout = new buffered reader ( new input stream reader ( p . get input stream ( ) ) ) ; while ( ( s = stdout . read line ( ) ) != null ) { logger . info ( s ) ; sb . append ( s ) ; sb . append ( str ) ; } string sbs = sb . to string ( ) ; int exit value = p . wait for ( ) ; if ( exit value != num ) throw new exception ( error message + str + exit value + str + sbs ) ; return sbs ; }	run command cmd in separate process in directory.
@ override public selectable channel selectable channel ( ) { return socket channel ; }	returns the socketchannel underlying this socketcommchannel.
public void test iiiiii ( ) { date d1 = new date ( num , num , num , num , num , num ) ; date d2 = new date ( num + d1 . get timezone offset ( ) * num * num + num * num * num + num * num + num ) ; assert true ( str , d1 . equals ( d2 ) ) ; }	java . util . date # date ( int , int , int , int , int , int ).
public static string from tag ( byte array tag tag ) { string builder builder = new string builder ( ) ; builder . append ( array start ) ; boolean start = bool ; for ( byte value : tag . get value ( ) ) { byte tag b = new byte tag ( value ) ; if ( start ) { start = bool ; } else { builder . append ( element seperator ) ; } builder . append ( from tag ( b ) ) ; } builder . append ( array end ) ; return builder . to string ( ) ; }	creates a mojangson string from the given bytearray tag .
@ override protected void add chooser filters ( j chooser ) { javax . swing . filechooser . file name extension filter filter = new javax . swing . filechooser . file name extension filter ( bundle . get message ( str , str ) , str , str ) ; chooser . add choosable file filter ( new javax . swing . filechooser . file name extension filter ( str , str ) ) ; chooser . add choosable file filter ( new javax . swing . filechooser . file name extension filter ( str , str ) ) ; chooser . add choosable file filter ( filter ) ; chooser . set file filter ( filter ) ; }	add filter ( s ) for possible types to the input file chooser .
private static byte [ ] windows reg enum value1 ( int h key , int value index , int max value name length ) { byte [ ] result = windows reg enum value ( h key , value index , max value name length ) ; if ( result != null ) { return result ; } else { long sleep time = init sleep time ; for ( int i = num ; i < max attempts ; i ++ ) { try { thread . sleep ( sleep time ) ; } catch ( interrupted exception e ) { return result ; } sleep time *= num ; result = windows reg enum value ( h key , value index , max value name length ) ; if ( result != null ) { return result ; } } } return result ; }	retries regenumvalueex ( ) max_attempts times before giving up .
public static date time parse rfc822 ( string str ) throws parse exception { date date ; synchronized ( date time format822 ) { try { date = date time format822 . parse ( str ) ; } catch ( java . text . parse exception e ) { throw new parse exception ( e ) ; } } return new date time ( date ) ; }	parses the value as an rfc 822 date / time .
public model validate model ( dataset dataset , uri shapes graph uri , resource min severity , boolean validate shapes , function < rdf , string > label function , progress monitor monitor ) throws interrupted exception { if ( dataset . get default model ( ) == null ) { throw new illegal argument exception ( str ) ; } model shapes model = dataset . get named model ( shapes graph uri . to string ( ) ) ; if ( monitor != null ) { monitor . sub task ( str ) ; } list < property > constraint properties = shacl . get all constraint properties ( validate shapes ) ; map < resource , list < sh > > map = build shape2 constraints map ( shapes model , dataset . get default model ( ) , constraint properties , validate shapes ) ; if ( monitor != null ) { monitor . sub task ( str ) ; } if ( monitor != null ) { monitor . begin task ( str + map . size ( ) + str , map . size ( ) ) ; } model results = jena util . create memory model ( ) ; results . set ns prefixes ( dataset . get default model ( ) ) ; for ( resource shape : map . key set ( ) ) { for ( sh constraint : map . get ( shape ) ) { validate constraint for shape ( dataset , shapes graph uri , min severity , constraint , shape , results , label function , monitor ) ; if ( monitor != null ) { monitor . worked ( num ) ; if ( monitor . is canceled ( ) ) { throw new interrupted exception ( ) ; } } } } return results ; }	validates all resources in a given model , which is expected to be the default graph of a given dataset .
public pdf page add annotation ( pdf annotation annotation ) { return add annotation ( - num , annotation , bool ) ; }	adds specified annotation to the end of annotations array and tagged it.
public static string find preferred idp ( string realm , http servlet request request ) { if ( request == null ) { return null ; } string succinct id = request . get parameter ( ifs . provider id key ) ; if ( ( succinct id == null ) || succinct id . length ( ) == num ) { debug . message ( str ) ; return null ; } succinct id = succinct id . trim ( ) ; string preferred succinct id = null ; string tokenizer st = new string tokenizer ( succinct id , str ) ; while ( st . has more tokens ( ) ) { preferred succinct id = st . next token ( ) ; if ( ( preferred succinct id . length ( ) < num ) && st . has more tokens ( ) ) { preferred succinct id = preferred succinct id + str + st . next token ( ) ; } } preferred succinct id = saml . byte array to string ( base64 . decode ( preferred succinct id ) ) ; return get provider id id ( realm , preferred succinct id ) ; }	finds the preferred idp from the httpservletrequest .
private void check and create directory ( final string directory name ) { try { final file dir = new file ( directory name ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { logger . debug ( str ) ; } } catch ( exception ex ) { logger . error ( str , ex . get message ( ) ) ; } }	verify whether directory already exists or not.
@ safe varargs public final assert subscriber < t > assert values with ( consumer < t > ... expectations ) { if ( ! values storage ) { throw new illegal state exception ( str ) ; } final int expected value count = expectations . length ; if ( expected value count != values . size ( ) ) { throw new assertion error ( str + expected value count + str + value count , null ) ; } for ( int i = num ; i < expected value count ; i ++ ) { consumer < t > consumer = expectations [ i ] ; t actual value = values . get ( i ) ; consumer . accept ( actual value ) ; } return this ; }	assert the specified values have been received in the declared order.
private boolean journal rebuild required ( ) { final int redundant op compact threshold = num ; return redundant op count >= redundant op compact threshold && redundant op count >= lru entries . size ( ) ; }	we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .
final public void println ( float v ) { string s = string . value of ( v ) ; write ( s , num , s . length ( ) ) ; println ( ) ; }	prints a float followed by a newline .
private static translation result extract register ( final i environment , final long offset , final string sub register ) throws internal translation exception { final array list < reil instruction > instructions = new array list < reil instruction > ( ) ; final string parent register = get parent register ( sub register ) ; final operand size arch size = environment . get architecture size ( ) ; if ( is higher8 bit register ( sub register ) ) { final string mask result = environment . get next variable string ( ) ; final string shift result = environment . get next variable string ( ) ; instructions . add ( reil helpers . create and ( offset , arch size , parent register , operand size . word , str , operand size . word , mask result ) ) ; instructions . add ( reil helpers . create bsh ( offset + num , operand size . word , mask result , operand size . word , str , operand size . byte , shift result ) ) ; return new translation result ( shift result , operand size . byte , translation result type . register , null , instructions , offset ) ; } else { final operand size sub register size = get register size ( sub register ) ; final string mask = string . value of ( translation helpers . get all bits mask ( sub register size ) ) ; final string result = environment . get next variable string ( ) ; instructions . add ( reil helpers . create and ( offset , arch size , parent register , sub register size , mask , sub register size , result ) ) ; return new translation result ( result , sub register size , translation result type . register , null , instructions , offset ) ; } }	extracts a subregister ( like ax , al , ah ) from a parent register ( like eax ).
public void on login failure ( map request params map , http servlet request req , http servlet response res ) throws authentication exception { debug . message ( str ) ; }	post processing on failed authentication .
public interceptor [ ] build method interceptors ( method method ) { interceptors before = method . get annotation ( interceptors . class ) ; return before != null ? create interceptors ( before ) : null interceptor array ; }	build interceptors of method.
static void remove all phis ( ir ir ) { for ( instruction s = ir . first instruction in code order ( ) , sentinel = ir . last instruction in code order ( ) , next instr = null ; s != sentinel ; s = next instr ) { next instr = s . next instruction in code order ( ) ; if ( phi . conforms ( s ) ) s . remove ( ) ; } }	remove all phi instructions from the ir .
protected int count token ( string token , string target ) { int token index = num ; int count = num ; while ( token index != - num ) { token index = target . index of ( token , token index ) ; if ( token index > - num ) { token index ++ ; count ++ ; } } return count ; }	returns the number of times the token appears in the target .
private map < test case , set < test fitness function > > initialize coverage map from tests ( list < test case > tests ) { map < test case , set < test fitness function > > test to goals = new linked hash map < > ( ) ; for ( test case test : tests ) { test to goals . put ( test , filter supported goals ( new linked hash set < > ( test . get covered goals ( ) ) ) ) ; } return test to goals ; }	builds the name map based on coverage goal stored as covered in each of the tests.
public interceptor [ ] build route interceptors ( interceptor [ ] default inters , interceptor [ ] resource inters , class < ? extends resource > resource class , interceptor [ ] method inters , method method ) { list < interceptor > all inters = new array list < interceptor > ( ) ; for ( interceptor default inter : default inters ) { all inters . add ( default inter ) ; } for ( interceptor resource inter : resource inters ) { all inters . add ( resource inter ) ; } for ( interceptor method inter : method inters ) { all inters . add ( method inter ) ; } class < ? extends interceptor > [ ] resource clears = get resource clears ( resource class ) ; class < ? extends interceptor > [ ] method clears = get method clears ( method ) ; if ( ( resource clears != null && resource clears . length > num ) || ( method clears != null && method clears . length > num ) ) { for ( int i = num ; i < all inters . size ( ) ; i ++ ) { i = clear interceptor ( all inters , resource clears , i ) ; i = clear interceptor ( all inters , method clears , i ) ; } } return all inters . to array ( new interceptor [ all inters . size ( ) ] ) ; }	build interceptors of action.
public static boolean check gml ( string footprint ) { try { configuration configuration = new gml ( ) ; parser parser = new parser ( configuration ) ; geometry geom = ( geometry ) parser . parse ( new input source ( new string reader ( footprint ) ) ) ; if ( ! geom . is empty ( ) && ! geom . is valid ( ) ) { logger . error ( str ) ; return bool ; } } catch ( exception e ) { logger . error ( str + e . get message ( ) ) ; return bool ; } return bool ; }	check gml footprint validity.
public static void main ( string [ ] args ) { double pre buffer = double . parse double ( args [ num ] ) ; double post buffer = double . parse double ( args [ num ] ) ; run ( args [ num ] , args [ num ] , args [ num ] , args [ num ] , pre buffer , post buffer ) ; }	creates a timetable ( network change events file ).
public static double quantile ( double p , double k , double theta , double shift ) { return math . exp ( gamma distribution . quantile ( p , k , theta ) ) + shift ; }	compute probit ( inverse cdf ) for loggamma distributions .
public static cipher parameters make pbe ( bcpbe pbe key , algorithm parameter spec spec ) { if ( ( spec == null ) || ! ( spec instanceof pbe ) ) { throw new illegal argument exception ( str ) ; } pbe pbe param = ( pbe ) spec ; pbe generator = make pbe ( pbe key . get type ( ) , pbe key . get digest ( ) ) ; byte [ ] key = pbe key . get encoded ( ) ; cipher parameters param ; if ( pbe key . should try wrong pkc ( ) ) { key = new byte [ num ] ; } generator . init ( key , pbe param . get salt ( ) , pbe param . get iteration count ( ) ) ; param = generator . generate derived mac parameters ( pbe key . get key size ( ) ) ; for ( int i = num ; i != key . length ; i ++ ) { key [ i ] = num ; } return param ; }	generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .
public orion editor init ( final text editor configuration configuration , final code assistant factory code assistant factory , final quick assist assistant quick assist , final orion editor presenter text editor ) { this . configuration = configuration ; this . code assistant factory = code assistant factory ; this . quick assist = quick assist ; this . text editor = text editor ; }	the quick assist assistant .
final void put byte ( int offset , byte value ) { unsafe . put byte ( offset + address , value ) ; }	writes a byte at the specified offset from this native object ' s base address .
public final void add validation error ( string error ) { validation errors . add ( error ) ; }	add a new validation error to the accumulating validation errors.
public static void parse option setting to ( string option setting , map < string , string > dst ) { int eq index = option setting . index of ( str ) ; if ( eq index == - num ) { throw new internal error ( str + option setting ) ; } dst . put ( option setting . substring ( num , eq index ) , option setting . substring ( eq index + num ) ) ; }	parses a given option setting string to a map of settings .
public big integer generate client credentials ( byte [ ] salt , byte [ ] identity , byte [ ] password ) { this . x = sr . calculate x ( digest , n , salt , identity , password ) ; this . a = select private value ( ) ; this . a = g . mod pow ( a , n ) ; return a ; }	generates client ' s credentials given the client ' s salt , identity and password.
public void build ( solr core core , solr index searcher searcher ) throws io { log . info ( str + name + str ) ; dictionary = dictionary factory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( store dir != null ) { file target = get store file ( ) ; if ( ! lookup . store ( new file output stream ( target ) ) ) { log . error ( str ) ; } else { log . info ( str + target . get absolute path ( ) ) ; } } }	build the underlying lucene suggester.
public void start ( string json ) { guided tour steps . clear ( ) ; guided tour configuration configuration = dto factory . create dto from json ( json , guided tour configuration . class ) ; log . set debug mode ( configuration . get debug mode ( ) ) ; this . guided tour steps = configuration . get steps ( ) ; this . tour name = configuration . get name ( ) ; if ( this . tour name == null || tour name . is empty ( ) ) { tour name = str ; } this . has welcome step = configuration . get has welcome step ( ) ; start tour ( ) ; }	loads the given json data and start the tour.
private static void run random test ( final int word length , final int byte padding , final int word count ) { final long seed = random long ( ) ; final random random = new random ( seed ) ; final random verification random = new random ( seed ) ; final long word mask ; if ( word length == num ) { word mask = ~ num ; } else { word mask = ( num << word length ) - num ; } final big endian ascending word serializer serializer = new big endian ascending word serializer ( word length , word count , byte padding ) ; for ( int i = num ; i < word count ; i ++ ) { final long value = random . next long ( ) & word mask ; serializer . write word ( value ) ; } final byte [ ] bytes = serializer . get bytes ( ) ; final big endian ascending word deserializer deserializer = new big endian ascending word deserializer ( word length , byte padding , bytes ) ; assert equals ( deserializer . total word count ( ) , word count ) ; for ( int i = num ; i < word count ; i ++ ) { assert equals ( deserializer . read word ( ) , ( verification random . next long ( ) & word mask ) ) ; } }	runs a test which serializes and deserializes random word values .
public void add listener ( t listener ) { if ( listener == null ) { throw new null pointer exception ( ) ; } listeners . add ( listener ) ; }	registers a listener to receive events .
private float clamp mag ( float value , float abs min , float abs max ) { final float abs value = math . abs ( value ) ; if ( abs value < abs min ) return num ; if ( abs value > abs max ) return value > num ? abs max : - abs max ; return value ; }	clamp the magnitude of value for absmin and absmax.
@ override public void handle click ( int x , int y , plot rendering info info ) { }	handles a ' click ' on the plot by updating the anchor values.
private void adjust bc ( instruction barrier ) { normal method source = barrier . position ( ) . method ; if ( source . is for osr specialization ( ) ) { barrier . adjust bytecode index ( - source . get osr prologue length ( ) ) ; } }	the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr_adjustbcindex .
@ override public string to string ( ) { string builder risul = new string builder ( num ) ; risul . append ( str ) ; risul . append ( str ) ; return risul . to string ( ) ; }	used to have some meaningful info on this object mostly used for beanshell.
public static long [ ] interpose ( long [ ] vector , int vector len , int offset , int len ) { long [ ] updated = create ( vector len + len ) ; int idx = offset > > num ; system . arraycopy ( vector , num , updated , num , idx ) ; if ( idx < vector . length ) { int delta = offset & num ; updated [ idx ] |= vector [ idx ] & mask below ( delta ) ; } copy ( vector , offset , updated , offset + len , vector len - offset ) ; return updated ; }	returns a copy of the vector , with an empty bit range inserted at the specified location .
public static file create temporary directory ( string prefix ) { while ( bool ) { string candidate name = prefix + temporary directory prng . next int ( ) ; file result = new file ( system . get property ( str ) , candidate name ) ; if ( result . mkdir ( ) ) { return result ; } } }	creates a unique new temporary directory under " java.
task < void > synchronize all auth data async ( ) { map < string , map < string , string > > auth data ; synchronized ( mutex ) { if ( ! is current user ( ) ) { return task . for result ( null ) ; } auth data = get auth data ( ) ; } list < task < void > > tasks = new array list < > ( auth data . size ( ) ) ; for ( string auth type : auth data . key set ( ) ) { tasks . add ( synchronize auth data async ( auth type ) ) ; } return task . when all ( tasks ) ; }	ensures that all auth sources have auth data ( e.
public static element create element in encryption space ( document doc , string element name ) { if ( doc == null ) { throw new runtime exception ( str ) ; } if ( ( xenc prefix == null ) || ( xenc prefix . length ( ) == num ) ) { return doc . create element ns ( encryption constants . ns , element name ) ; } return doc . create element ns ( encryption constants . ns , xenc prefix + str + element name ) ; }	creates an element in the xml encryption specification namespace .
void scrap active views ( ) { final view [ ] active views = m active views ; final boolean multiple scraps = m view type count > num ; array list < view > scrap views = m current scrap ; final int count = active views . length ; for ( int i = count - num ; i >= num ; i -- ) { final view victim = active views [ i ] ; if ( victim != null ) { final layout params lp = ( layout params ) victim . get layout params ( ) ; active views [ i ] = null ; final boolean scrap has transient state = view compat . has transient state ( victim ) ; int view type = lp . view type ; if ( ! should recycle view type ( view type ) || scrap has transient state ) { if ( view type != item view type header or footer || scrap has transient state ) { remove detached view ( victim , bool ) ; } if ( scrap has transient state ) { if ( m transient state views == null ) { m transient state views = new sparse array compat < view > ( ) ; } m transient state views . put ( m first active position + i , victim ) ; } continue ; } if ( multiple scraps ) { scrap views = m scrap views [ view type ] ; } lp . position = m first active position + i ; scrap views . add ( victim ) ; } } prune scrap views ( ) ; }	move all views remaining in mactiveviews to mscrapviews .
private void draw wind ( canvas canvas , float y , float x offset ) { float cof = ( m screen width + x offset ) / ( loading animation coefficient / slow down animation coefficient ) ; float time = m loading animation time ; if ( m last animation time - m loading animation time > num ) { m inverse direction = bool ; time = ( loading animation coefficient / slow down animation coefficient ) - m loading animation time ; } else { m new wind set = bool ; m inverse direction = bool ; } float x = ( m screen width - ( time * cof ) ) + x offset - m wind line width ; float x end = x + m wind line width ; canvas . draw line ( x , y , x end , y , m wind paint ) ; }	draw wind on loading animation.
private boolean has proxy settings ( properties settings ) { string proxy host = settings . get property ( str , null ) ; return proxy host != null && proxy host . length ( ) > num ; }	checks if we have proxy configuration settings in the properties .
public boolean equals default ( ) { return ( double . double to long bits ( value ) == num ) ; }	check if the expression is equal to its default static value.
public static map < string , string > parse key and value to map ( string source , boolean ignore space ) { return parse key and value to map ( source , default key and value separator , default key and value pair separator , ignore space ) ; }	parse key - value pairs to map , ignore empty key.
@ override protected void on size changed ( int w , int h , int oldw , int oldh ) { super . on size changed ( w , h , oldw , oldh ) ; setup bounds ( w , h ) ; setup paints ( ) ; invalidate ( ) ; }	use onsizechanged instead of onattachedtowindow to get the dimensions of the view , because this method is called after measuring the dimensions of match_parent & wrap_content.
private void need new buffer ( int newcount ) { if ( current buffer index < buffers . size ( ) - num ) { filled buffer sum += current buffer . length ; current buffer index ++ ; current buffer = buffers . get ( current buffer index ) ; } else { int new buffer size ; if ( current buffer == null ) { new buffer size = newcount ; filled buffer sum = num ; } else { new buffer size = math . max ( current buffer . length << num , newcount - filled buffer sum ) ; filled buffer sum += current buffer . length ; } current buffer index ++ ; current buffer = new byte [ new buffer size ] ; buffers . add ( current buffer ) ; } }	makes a new buffer available either by allocating a new one or re - cycling an existing one .
@ nullable public static website address create ( string origin or host or pattern ) { if ( origin or host or pattern == null || origin or host or pattern . is empty ( ) ) { return null ; } if ( origin or host or pattern . starts with ( any subdomain pattern ) ) { string origin = null ; string scheme = null ; string host = origin or host or pattern . substring ( any subdomain pattern . length ( ) ) ; boolean omit protocol and port = bool ; return new website address ( origin or host or pattern , origin , scheme , host , omit protocol and port ) ; } if ( origin or host or pattern . index of ( scheme suffix ) != - num ) { uri uri = uri . parse ( origin or host or pattern ) ; string origin = trim trailing backslash ( origin or host or pattern ) ; boolean omit protocol and port = http scheme . equals ( uri . get scheme ( ) ) && ( uri . get port ( ) == - num || uri . get port ( ) == num ) ; return new website address ( origin or host or pattern , origin , uri . get scheme ( ) , uri . get host ( ) , omit protocol and port ) ; } string origin = null ; string scheme = null ; boolean omit protocol and port = bool ; return new website address ( origin or host or pattern , origin , scheme , origin or host or pattern , omit protocol and port ) ; }	creates a new websiteaddress from | originorhostorpattern | .
public void test filter 001 ( ) throws io { final file basefile = file . create temp file ( get name ( ) , str ) ; try { final string basename = basefile . to string ( ) ; final name and extension filter log filter = new name and extension filter ( basename , str ) ; assert same files ( new file [ ] { } , log filter . get files ( ) ) ; } finally { basefile . delete ( ) ; } }	test verifies that no files are found using a guarenteed unique basename .
public void reset tele missile attacks ( ) { pending tele missile attacks . remove all elements ( ) ; }	resets the pending rams list .
public int add padding ( byte [ ] in , int in off ) { byte code = ( byte ) ( in . length - in off ) ; while ( in off < ( in . length - num ) ) { in [ in off ] = ( byte ) random . next int ( ) ; in off ++ ; } in [ in off ] = code ; return code ; }	add the pad bytes to the passed in block , returning the number of bytes added .
public void add commands ( pdf page , matrix extra ) { synchronized ( commands ) { add push ( ) ; if ( extra != null ) { add xform ( extra ) ; } commands . add all ( page . get commands ( ) ) ; add pop ( ) ; } update images ( ) ; }	add a collection of commands to the page list.
public string to string ( ) { string buffer sb = new string buffer ( ) ; char [ ] separator = { str , str } ; int n = rows . length ; for ( int i = num ; i < n ; i ++ ) { separator [ num ] = str ; for ( int j = num ; j <= i ; j ++ ) { sb . append ( separator ) ; sb . append ( rows [ i ] [ j ] ) ; separator [ num ] = str ; } sb . append ( str ) ; sb . append ( str ) ; } return sb . to string ( ) ; }	returns a string representation of the system .
public void add last ( statement sequence statements ) { if ( statements != null ) { sequence . add all ( statements . sequence ) ; } }	adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .
private void notify activity state changed ( bundle bundle ) { if ( ! m records . is empty ( ) ) { log . d ( tag , str + m records . size ( ) ) ; synchronized ( m records ) { iterator < record > iterator = m records . iterator ( ) ; while ( iterator . has next ( ) ) { record record = ( record ) iterator . next ( ) ; fm radio listener listener = record . m callback ; if ( listener == null ) { iterator . remove ( ) ; return ; } listener . on call back ( bundle ) ; } } } }	call back from service to activity.
public double elasticity ( final double spot ) { final double val = value ( ) ; final double del = delta ( spot ) ; if ( val > constants . ql epsilon ) return del / val * spot ; else if ( math . abs ( del ) < constants . ql epsilon ) return num ; else if ( del > num ) return double . max value ; else return double . min value ; }	sensitivity in percent to a percent change in the underlying spot price .
private byte [ ] entity to bytes ( http entity entity , request request ) throws io , server error { pooling byte array output stream bytes = new pooling byte array output stream ( m pool , ( int ) entity . get content length ( ) ) ; byte [ ] buffer = null ; try { input stream in = entity . get content ( ) ; if ( in == null ) { throw new server error ( ) ; } buffer = m pool . get buf ( num ) ; int progress = num ; int count ; while ( ( count = in . read ( buffer ) ) != - num ) { bytes . write ( buffer , num , count ) ; progress += count ; request . progress update ( progress ) ; } return bytes . to byte array ( ) ; } finally { try { entity . consume content ( ) ; } catch ( io e ) { vinci log . d ( str ) ; } m pool . return buf ( buffer ) ; bytes . close ( ) ; } }	reads the contents of httpentity into a byte [ ] .
@ override public foo fetch by uuid ( string uuid , order by comparator < foo > order by comparator ) { list < foo > list = find by uuid ( uuid , num , num , order by comparator ) ; if ( ! list . is empty ( ) ) { return list . get ( num ) ; } return null ; }	returns the first foo in the ordered set where uuid = & # 63 ; .
public static float round decimal ( float value ) { return round decimal ( value , math . log10 ( int precision ) ) ; }	static method to round a float value to the number of decimal places defined by decimal_places .
@ assisted inject public runner impl ( @ not null runner localization constant locale , @ not null runner counter runner counter , @ not null get environments util util , @ not null @ assisted run options run options , @ not null @ assisted scope environment scope , @ nullable @ assisted string environment name ) { this . run options = run options ; this . ram = run options . get memory size ( ) ; this . title = runner name + runner counter . get runner number ( ) + ( environment name == null ? str : str + get correct name ( environment name ) ) ; this . active tab = locale . runner tab console ( ) ; this . status = in queue ; this . scope = environment scope ; creation time = system . current time millis ( ) ; string environment id = run options . get environment id ( ) ; if ( environment id == null || environment id . starts with ( str ) ) { this . type = util . get type ( ) ; } else { this . type = util . get correct category name ( run options . get environment id ( ) ) ; } if ( environment id != null ) { run options . set environment id ( environment id ) ; } }	this runner needs runner options ( user configurations ) and environment name ( inputted by user ).
public static boolean is windows me ( ) { return os name . index of ( str ) > - num && os version . equals ( str ) ; }	is operating system windows me ?.
private string date to string ( date input ) { if ( input == null ) { return null ; } else { return input . to string ( ) ; } }	converts the input to a string with special missing value handling.
private static int component size ( component component , form spec form spec , int cell size , form layout . measure min measure , form layout . measure pref measure ) { if ( form spec == null ) { return pref measure . size of ( component ) ; } else if ( form spec . get size ( ) == sizes . minimum ) { return min measure . size of ( component ) ; } else if ( form spec . get size ( ) == sizes . preferred ) { return pref measure . size of ( component ) ; } else { return math . min ( cell size , pref measure . size of ( component ) ) ; } }	computes and returns the pixel size of the given component using the given form specification , measures , and cell size .
public static boolean is same element type ( ast node1 , ast node2 ) { return node1 != null && node2 != null && node1 . get element type ( ) == node1 . get element type ( ) ; }	checks if ielementtype of both nodes are the same.
public void append data to ( string builder string builder ) { string builder . append ( buffer ) ; }	appends this node ' s text content to the given builder .
public static string to string ( long l ) { if ( l < numbers min || l > numbers max ) { return long . to string ( l , num ) ; } return numbers [ ( int ) l ] ; }	cast a long value to a string.
@ override public synchronized void reset ( ) { pos = num ; }	resets this stream to the beginning of the source string .
public static int read single byte ( input stream in ) throws io { byte [ ] buffer = new byte [ num ] ; int result = in . read ( buffer , num , num ) ; return ( result != - num ) ? buffer [ num ] & num : - num ; }	implements inputstream . read ( int ) in terms of inputstream . read ( byte [ ] , int , int ) . inputstream assumes that you implement inputstream . read ( int ) and provides default implementations of the others , but often the opposite is more efficient .
public static void write ( file file , char sequence data ) throws io { write ( file , data , charset . default charset ( ) , bool ) ; }	writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .
protected boolean is idp ( fs authn request ) throws fs { if ( authn request . get minor version ( ) != ifs . ff 12 protocol minor version ) { return bool ; } fs scoping = authn request . get scoping ( ) ; if ( scoping != null && scoping . get proxy count ( ) == num ) { return bool ; } string enabled string = idff . get first attribute value from config ( sp config , ifs . enable idp proxy ) ; if ( enabled string != null && enabled string . equals ignore case ( str ) ) { return bool ; } else { return bool ; } }	checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .
private void compile prolog ( object id prolog , file temp dir ) throws io , compile exception { file temp rules = copy to temp file ( prolog , temp dir ) ; try { compiler comp = new compiler ( ) ; comp . prolog to java source ( temp rules . get path ( ) , temp dir . get path ( ) ) ; } finally { temp rules . delete ( ) ; } }	creates a copy of rules.
public spring remove all listeners ( ) { m listeners . clear ( ) ; return this ; }	remove all of the listeners.
public selection input dialog ( window owner , string key , boolean editable , t [ ] selection values , t initial selection value , input validator < t > input validator , object ... key arguments ) { this ( owner , key , selection values , initial selection value , input validator , key arguments ) ; combo box . set editable ( editable ) ; }	create a selectioninputdialog whose combobox can be editable .
public void build ( solr core core , solr index searcher searcher ) throws io { log . info ( str ) ; dictionary = dictionary factory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( store dir != null ) { file target = new file ( store dir , factory . store file name ( ) ) ; if ( ! lookup . store ( new file output stream ( target ) ) ) { log . error ( str ) ; } else { log . info ( str + target . get absolute path ( ) ) ; } } }	build the underlying lucene suggester.
public static string convert class name to resource path ( string class name ) { assert . not null ( class name , str ) ; return class name . replace ( str , str ) ; }	convert a " . " - based fully qualified class name to a " / " - based resource path .
public uri ( string scheme , string scheme specific part , string fragment ) throws uri { string builder uri = new string builder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( str ) ; } if ( scheme specific part != null ) { all legal encoder . append encoded ( uri , scheme specific part ) ; } if ( fragment != null ) { uri . append ( str ) ; all legal encoder . append encoded ( uri , fragment ) ; } parse uri ( uri . to string ( ) , bool ) ; }	creates a new uri instance of the given unencoded component parts .
private int add to population ( solution solution ) { int id = next free id ( ) ; solutions . put ( id , solution ) ; return id ; }	adds the specified solution to the population , returning its assigned identifier .
public byte [ ] to byte array ( ) { return arrays . copy of ( buf , cnt ) ; }	creates a newly allocated byte array.
public void create disk async ( final string project id , final disk create spec disk create spec , final future callback < task > response callback ) throws io { final string path = string . format ( str , get base path ( ) , project id ) ; create object async ( path , serialize object as json ( disk create spec ) , response callback ) ; }	create a disk in the specified project .
@ override public boolean domain match ( final string host , final string domain ) { return host . ends with ( domain ) ; }	performs domain - match as described in the netscape draft .
public synchronized void disable attribute ( string name ) { enabled attributes . remove element ( name ) ; }	disables all the attribute change notifications the attribute name of which equals the specified attribute name to be sent to the listener.
public void push ( final handle handle ) { mv . visit ldc insn ( handle ) ; }	generates the instruction to push a handle on the stack .
@ deprecated public static string encode post body ( bundle parameters , string boundary ) { if ( parameters == null ) return str ; string builder sb = new string builder ( ) ; for ( string key : parameters . key set ( ) ) { object parameter = parameters . get ( key ) ; if ( ! ( parameter instanceof string ) ) { continue ; } sb . append ( str + key + str + ( string ) parameter ) ; sb . append ( str + str + boundary + str ) ; } return sb . to string ( ) ; }	generate the multi - part post body providing the parameters and boundary string.
public static i lookup ( string key ) { int key length = key . length ( ) ; if ( key length > num && character . is digit ( key . char at ( key length - num ) ) ) { string builder builder = new string builder ( ) ; for ( int index = num ; index < key length ; index ++ ) { char character = key . char at ( index ) ; if ( character . is digit ( character ) ) { if ( builder . char at ( builder . length ( ) - num ) != str ) { builder . append ( str ) ; } } else { builder . append ( character ) ; } } return standard keys . get ( builder . to string ( ) ) ; } return standard keys . get ( key ) ; }	lookup a string key in the standard key sets .
@ override public void write ( kryo kryo , output output ) { int size = index . size ( ) ; output . write int ( size + num , bool ) ; for ( int i = num ; i < size ; ++ i ) { string s = index . get ( i ) ; if ( s == null ) { throw new runtime exception ( str + integer . to string ( i ) ) ; } output . write string ( s ) ; } }	custom serializer . follows kryo ' s stringarrayserializer example .
public final object property < control > toggle node property ( ) { return this . toggle node ; }	* public properties *.
private static int decode octets ( int i , byte buffer bb , string builder sb ) { if ( bb . limit ( ) == num && ( bb . get ( num ) & num ) < num ) { sb . append ( ( char ) bb . get ( num ) ) ; return i + num ; } else { char buffer cb = utf 8 charset . decode ( bb ) ; sb . append ( cb . to string ( ) ) ; return i + bb . limit ( ) * num - num ; } }	decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .
public array field vector ( field vector < t > v1 , t [ ] v2 ) throws null argument exception { math utils . check not null ( v1 ) ; math utils . check not null ( v2 ) ; field = v1 . get field ( ) ; final t [ ] v1 data = ( v1 instanceof array field vector ) ? ( ( array field vector < t > ) v1 ) . data : v1 . to array ( ) ; data = math arrays . build array ( field , v1 data . length + v2 . length ) ; system . arraycopy ( v1 data , num , data , num , v1 data . length ) ; system . arraycopy ( v2 , num , data , v1 data . length , v2 . length ) ; }	construct a vector by appending one vector to another vector .
public void reverse ( ) { final array list < animator > animators = m animated vector state . m animators ; final int size = animators . size ( ) ; for ( int i = num ; i < size ; i ++ ) { final animator animator = animators . get ( i ) ; if ( can reverse ( animator ) ) { reverse ( animator ) ; } else { log . w ( log tag , str ) ; } } }	reverses ongoing animations or starts pending animations in reverse.
public void start ( ) { if ( s logger . is activated ( ) ) { s logger . info ( str ) ; } m cleanup executor = executors . new single thread executor ( ) ; if ( ! m observer is registered ) { m contacts contract observer = new contacts contract observer ( new handler ( ) ) ; m contacts contract cursor = m content resolver . query ( phone . content uri , null , null , null , null ) ; cursor util . assert cursor is not null ( m contacts contract cursor , phone . content uri ) ; m contacts contract cursor . register content observer ( m contacts contract observer ) ; m observer is registered = bool ; } }	start address book monitoring.
protected final void fire vetoable change ( string property name , double old value , double new value ) throws property veto exception { fire vetoable change ( property name , double . value of ( old value ) , double . value of ( new value ) ) ; }	support for reporting changes for constrained integer properties.
public void test lm ( ) throws io { float p = ( freq + num * ( total term freq + num ) / ( number of field tokens + num ) ) / ( doc len + num ) ; float a = num / ( doc len + num ) ; float gold = ( float ) ( math . log ( p / ( a * ( total term freq + num ) / ( number of field tokens + num ) ) ) + math . log ( a ) ) ; correctness test core ( new lm ( ) , gold ) ; }	correctness test for the dirichlet lm model .
public void on sinks received ( string source urn , list < media sink > sinks ) { m sinks . put ( source urn , sinks ) ; native on sinks received ( m native media router android , source urn , sinks . size ( ) ) ; }	called when the sinks found by the media route provider for the particular | sourceurn | have changed .
public user to entity ( dto dto ) { return to entity ( dto , num ) ; }	converts the passed dto to a user.
protected void write external foreign key drop stmt ( table table , foreign key foreign key , string builder ddl ) { write table alter stmt ( table , ddl ) ; ddl . append ( str ) ; print identifier ( get foreign key name ( table , foreign key ) , ddl ) ; print end of statement ( ddl ) ; }	generates the statement to drop a foreignkey constraint from the database using an alter table statement .
public void obtain ( long timeout ms ) throws io , interrupted exception , timeout exception { long quit time = system . current time millis ( ) + timeout ms ; if ( file lock != null && file lock . is valid ( ) ) { return ; } do { try { file lock = file to lock . try lock ( ) ; return ; } catch ( overlapping file lock exception e ) { thread . sleep ( num ) ; } } while ( system . current time millis ( ) < quit time ) ; throw new timeout exception ( ) ; }	locks the file , with a timeout ( non - blocking ) .
@ deprecated public void point to data ( data o ) throws fits exception { o . fill header ( this ) ; }	create a header which points to the given data object .
@ not null protected virtual file [ ] collect affected files ( @ not null project project , @ not null virtual file [ ] files ) { list < virtual file > affected files = new array list < virtual file > ( files . length ) ; project level vcs manager project level vcs manager = project level vcs manager . get instance ( project ) ; for ( virtual file file : files ) { if ( ! file . is directory ( ) && project level vcs manager . get vcs for ( file ) instanceof git vcs ) { affected files . add ( file ) ; } else if ( file . is directory ( ) && is recursive ( ) ) { add children ( project , affected files , file ) ; } } return vfs util core . to virtual file array ( affected files ) ; }	given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents.
public void update position ( particle particle , long elapsed time ) { vector3f speed = particle . get speed ( ) ; float delta = elapsed time / num ; float dx = speed . x * delta ; float dy = speed . y * delta ; float dz = speed . z * delta ; vector3f pos = particle . get position ( ) ; particle . set position ( pos . x + dx , pos . y + dy , pos . z + dz ) ; }	updates a particle position.
protected void update ( int length ) { tick label values . clear ( ) ; tick labels . clear ( ) ; tick label positions . clear ( ) ; if ( scale . is log scale enabled ( ) ) { update tick label for log scale ( length ) ; } else { update tick label for linear scale ( length ) ; } update tick visibility ( ) ; update tick label max length and height ( ) ; }	updates the tick labels .
private static boolean is within bounds ( visual position target position , visual position start position , visual position end position ) { return target position . line >= start position . line && target position . line <= end position . line && target position . column >= start position . column && target position . column <= end position . column ; }	allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .
static public void assert statement indices consistent ( final abstract triple store db , final int maxerrors ) { if ( log . is info enabled ( ) ) log . info ( str ) ; final atomic integer nerrs = new atomic integer ( num ) ; final int from , to ; if ( db . get spo ( ) == num ) { from = spo . first triple index ; to = spo . last triple index ; } else { from = spo . first quad index ; to = spo . last quad index ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assert same statements ( db , spo . value of ( i ) , spo . value of ( j ) , nerrs , maxerrors ) ; } } assert equals ( num , nerrs . get ( ) ) ; }	validates that the same statements are found in each of the statement indices .
public void show ( @ id res final int item id ) { map . add ( item id ) ; navigation . invalidate badge ( item id ) ; }	request to display a new badge over the passed menu item id.
public options put ( string option , integer value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option , value . to string ( ) ) ; return this ; }	put an option integer value .
private int determine target page ( int current page , float page offset , int velocity , int delta x ) { int target page ; if ( math . abs ( delta x ) > fling distance && math . abs ( velocity ) > minimum velocity ) { if ( virtual pos < num ) { target page = velocity > num ? current page : current page + num ; } else { target page = velocity > num ? current page + num : current page ; } } else { final float truncator = current page >= current item ? num : num ; target page = ( int ) ( current page + page offset + truncator ) ; } if ( items . size ( ) > num ) { final item info first item = items . get ( num ) ; final item info last item = items . get ( items . size ( ) - num ) ; target page = math . max ( first item . position , math . min ( target page , last item . position ) ) ; } if ( target page > current page && on card change listener != null ) { on card change listener . on card dismissed ( current page , virtual pos > num ) ; } return target page ; }	figure out what the target page would be given current scroll and velocity .
protected string form ( d matrix , int index , former formatter ) { object value = matrix . get ( index ) ; if ( value == null ) return str ; return string . value of ( value ) ; }	converts a given cell to a string ; no alignment considered .
public void clone ( vector3f source ) { system . arraycopy ( source . points , num , points , num , num ) ; }	clone the input vector so that this vector has the same values .
public static string to regex ( string glob , string separator ) { check not null ( separator , str ) ; check argument ( separator . length ( ) == num , str , separator ) ; return to regex ( glob , separator . char at ( num ) ) ; }	converts the given glob pattern into a regular expression .
protected void force no loss ( boolean value ) { }	should the data of this tile be forced to case no data loss.
public static string [ ] split without escaped ( string str , char separator char , boolean retain empty ) { int len = str . length ( ) ; if ( len == num ) { return new string [ num ] ; } list < string > list = new array list < string > ( ) ; int i = num ; int start = num ; boolean match = bool ; while ( i < len ) { if ( str . char at ( i ) == str ) { match = bool ; i += num ; } else if ( str . char at ( i ) == separator char ) { if ( retain empty || match ) { list . add ( str . substring ( start , i ) ) ; match = bool ; } start = ++ i ; } else { match = bool ; i ++ ; } } if ( retain empty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . to array ( new string [ list . size ( ) ] ) ; }	does not take into account escaped separators.
public void test split escaped semicolons ( ) { properties inner = property utils . split properties on semicolon ( property utils . escape back slashes if not null ( str ) ) ; assert equals ( num , inner . size ( ) ) ; assert equals ( str , inner . get property ( str ) ) ; assert equals ( str , inner . get property ( str ) ) ; assert equals ( str , inner . get property ( str ) ) ; assert equals ( str , inner . get property ( str ) ) ; }	test split of escaped semicolons .
public static void remove object at offset ( object [ ] source array , object [ ] destination array , int offset ) { system . arraycopy ( source array , num , destination array , num , offset ) ; system . arraycopy ( source array , offset + num , destination array , offset , source array . length - offset - num ) ; }	removes the object at the source array offset and copies all other objects to the destination array.
@ suppress warnings ( str ) public dictionary adapter ( context context , file db path , string db name , string default table ) { m context = context ; m db name = db name ; m default table = default table ; m db path = db path ; m db file = new file ( db path , m db name ) ; if ( m db file . exists ( ) ) { open ( ) ; } }	open the database if it exists or create it if it doesn ' t.
public boolean is tab associated with non destroyed activity ( boolean is incognito , int tab id ) { list < weak reference < activity > > activities = application status . get running activities ( ) ; for ( weak reference < activity > ref : activities ) { activity activity = ref . get ( ) ; if ( activity != null && is valid activity ( is incognito , activity . get intent ( ) ) && get tab id from intent ( activity . get intent ( ) ) == tab id && ! is activity destroyed ( activity ) ) { return bool ; } } return bool ; }	check if the tab is associated with an activity that hasn ' t been destroyed.
http stream wrapper ( http stream stream ) throws io { stream = stream ; }	create a new http stream .
public boolean handle file ( file file ) { if ( debug ) { logger . fine ( str + file . get absolute path ( ) ) ; } filenames . add ( file ) ; return bool ; }	when a file is found , add it .
public boolean looks like number coming ( ) { if ( n >= s . length ( ) ) return bool ; return character . is digit ( s . char at ( n ) ) ; }	peeks the next char , without gobbling it.
public partial hull ( i first , i second ) { points . add ( first ) ; points . add ( second ) ; }	construct the initial partial hull .
public short read short ( ) throws io { return primitive types . read short ( ) ; }	reads a short ( 16 bit ) from the source stream .
public void print ( int inum ) { print ( string . value of ( inum ) ) ; }	prints the string representation of the specified integer to the target .
public static < node type extends i < ? > > zy proximity node < ? > create proximity node ( final d graph , final zy graph node < ? > attached node , final int degree , final boolean is incoming ) { preconditions . check not null ( graph , str ) ; preconditions . check not null ( attached node , str ) ; final zy label content labelcontent = new zy label content ( null ) ; labelcontent . add line content ( new zy line content ( string . value of ( degree ) , new font ( str , font . plain , num ) , null ) ) ; final zy proximity node realizer < node type > r = new zy proximity node realizer < node type > ( labelcontent ) ; final node node = graph . create node ( r ) ; @ suppress warnings ( str ) final zy proximity node < node type > info node = new zy proximity node < node type > ( node , r , ( zy graph node < node type > ) attached node , is incoming ) ; final zy node data < zy proximity node < node type > > data = new zy node data < zy proximity node < node type > > ( info node ) ; r . set user data ( data ) ; return info node ; }	creates a proximity browsing node .
public static boolean is zoning required ( db client db client , uri varray uri ) { if ( varray uri != null ) { virtual array nh = db client . query object ( virtual array . class , varray uri ) ; if ( nh != null ) { return is zoning required ( db client , nh ) ; } } return bool ; }	looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .
public void reply ( list < string > response headers , boolean out ) throws io { assert ( ! thread . holds lock ( spdy stream . this ) ) ; boolean out finished = bool ; synchronized ( this ) { if ( response headers == null ) { throw new null pointer exception ( str ) ; } if ( is locally initiated ( ) ) { throw new illegal state exception ( str ) ; } if ( this . response headers != null ) { throw new illegal state exception ( str ) ; } this . response headers = response headers ; if ( ! out ) { this . out . finished = bool ; out finished = bool ; } } connection . write syn reply ( id , out finished , response headers ) ; }	sends a reply to an incoming stream .
protected cc ( string name , float delay , array list < cc > frames ) { delay = delay ; name = name ; frames = new array list < cc > ( ) ; if ( frames != null ) frames . add all ( frames ) ; }	initializes a ccanimation with a name , delay and an array of ccspriteframes .
private void navigate to dump ( ) { tree path current path = tree . get selection path ( ) ; tree . set selection path ( current path . get parent path ( ) ) ; tree . scroll path to visible ( current path . get parent path ( ) ) ; }	navigate to root node of currently active dump.
public synchronized void add messages ( array list < sms mms message > new messages ) { if ( new messages != null ) { messages . add all ( num , new messages ) ; update message count ( ) ; } }	add a list of new messages to the end of the current message list .
public static cache . entry make random cache entry ( byte [ ] data , boolean is expired , boolean needs refresh ) { random random = new random ( ) ; cache . entry entry = new cache . entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . next int ( num ) ] ; } entry . etag = string . value of ( random . next long ( ) ) ; entry . server date = random . next long ( ) ; entry . ttl = is expired ? num : long . max value ; entry . soft ttl = needs refresh ? num : long . max value ; return entry ; }	makes a random cache entry .
public int swap ( ) { if ( ! egl . egl swap buffers ( egl display , egl surface ) ) { return egl . egl get error ( ) ; } return eg . egl success ; }	display the current render surface .
public static list < window > windows ( string words , int window size ) { string tokenizer tokenizer = new string tokenizer ( words ) ; list < string > list = new array list < string > ( ) ; while ( tokenizer . has more tokens ( ) ) list . add ( tokenizer . next token ( ) ) ; return windows ( list , window size ) ; }	constructs a list of window of size windowsize.
public static string build path ( json path json path ) { list < string > url parts = new linked list < > ( ) ; json path current json path = json path ; string path part ; do { if ( current json path instanceof relationships path ) { path part = relationship mark + separator + current json path . get element name ( ) ; } else if ( current json path instanceof field path ) { path part = current json path . get element name ( ) ; } else { path part = current json path . get element name ( ) ; if ( current json path . get ids ( ) != null ) { path part += separator + merge ids ( current json path . get ids ( ) ) ; } } url parts . add ( path part ) ; current json path = current json path . get parent resource ( ) ; } while ( current json path != null ) ; collections . reverse ( url parts ) ; return separator + string utils . join ( separator , url parts ) + separator ; }	creates a path using the provided jsonpath structure .
private static object add ( final object array , final int index , final object element , final class < ? > clss ) { if ( array == null ) { if ( index != num ) { throw new index out of bounds exception ( str + index + str ) ; } object joined array = array . new instance ( clss , num ) ; array . set ( joined array , num , element ) ; return joined array ; } int length = array . get length ( array ) ; if ( index > length || index < num ) { throw new index out of bounds exception ( str + index + str + length ) ; } object result = array . new instance ( clss , length + num ) ; system . arraycopy ( array , num , result , num , index ) ; array . set ( result , index , element ) ; if ( index < length ) { system . arraycopy ( array , index , result , index + num , length - index ) ; } return result ; }	underlying implementation of add ( array , index , element ) methods.
public double double value ( ) { return d . double value ( ) ; }	get the double value corresponding to the instance .
public string to matlab ( ) { string buffer result ; int i ; int n ; result = new string buffer ( ) ; result . append ( str ) ; for ( i = num ; i < get row dimension ( ) ; i ++ ) { if ( i > num ) { result . append ( str ) ; } for ( n = num ; n < get column dimension ( ) ; n ++ ) { if ( n > num ) { result . append ( str ) ; } result . append ( double . to string ( get ( i , n ) ) ) ; } } result . append ( str ) ; return result . to string ( ) ; }	converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e.
public file input reader ( file f ) throws io { if ( debug . debugging ( str ) ) { debug . output ( str + f . get absolute path ( ) ) ; } name = f . get name ( ) ; absolute path = f . get absolute path ( ) ; input file = init ( f ) ; }	constructs a new binaryfile with the specified file as the input.
public static object output stream new object output stream ( path self ) throws io { return new object output stream ( files . new output stream ( self ) ) ; }	create an object output stream for this path .
@ override public set < k > key set ( ) { hash set < k > set = new hash set < k > ( ) ; for ( segment < k , v > s : segments ) { set . add all ( s . key set ( ) ) ; } return set ; }	get the set of keys for resident entries .
public void add ( final certificate validity certificate validity ) { certificate validity list . add ( certificate validity ) ; }	this method allows to add a candidate for the signing certificate .
public void add policy listener ( policy listener policy listener ) { policy cache . add policy listener ( policy listener ) ; }	adds a policy listener that would be notified whenever a policy is added , removed or changed.
public static result verify ( string sid , string code ) { string id = str + sid ; code c = ( code ) cache . get ( id ) ; if ( c == null ) { log . warn ( str + sid ) ; return result . badcode ; } else if ( ! x . is same ( code , c . code ) ) { log . warn ( str + c . code + str + code ) ; return result . badcode ; } else if ( c . expired < system . current time millis ( ) ) { log . warn ( str + c . expired ) ; return result . expired ; } return result . ok ; }	verify the code associated.
private script engine new script engine ( file file ) throws script exception { string filename = file . get name ( ) ; int index = filename . last index of ( str ) ; if ( ( index < num ) || ( index >= filename . length ( ) - num ) ) { throw new script exception ( str ) ; } string extension = filename . substring ( index + num ) ; script engine manager manager = new script engine manager ( ) ; script engine engine = manager . get engine by extension ( extension ) ; if ( engine == null ) { throw new script exception ( str + extension ) ; } return engine ; }	returns a new scripting engine for the scripting language identified by the file name extension .
protected static i find raw module ( final int raw module id , final list < i > raw modules ) { preconditions . check argument ( raw module id > num , str , raw module id ) ; preconditions . check not null ( raw modules , str ) ; for ( final i raw module : raw modules ) { if ( raw module . get id ( ) == raw module id ) { return raw module ; } } throw new illegal state exception ( str ) ; }	returns the raw module with the given id .
public static object extract type checked ( list < object > args , int i , class clazz , function < list < object > , object > extract func ) { if ( args . size ( ) < i + num ) { return null ; } else if ( clazz . is instance ( args . get ( i ) ) ) { return extract func . apply ( args ) ; } else { return null ; } }	extract type - checked value from an argument list using the specified type check and extraction function.
@ override public japanese date date year day ( int proleptic year , int day of year ) { return new japanese date ( local date . of year day ( proleptic year , day of year ) ) ; }	obtains a local date in japanese calendar system from the proleptic - year and day - of - year fields.
private pair < entry , char [ ] > recover entry ( key store ks , string alias , char [ ] pstore , char [ ] pkey ) throws exception { if ( ks . contains alias ( alias ) == bool ) { message format form = new message format ( rb . get string ( str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } password protection pp = null ; entry entry ; try { entry = ks . get entry ( alias , pp ) ; pkey = null ; } catch ( unrecoverable entry exception une ) { if ( keystore . equals ignore case ( ks . get type ( ) ) || key store util . is windows key store ( ks . get type ( ) ) ) { throw une ; } if ( pkey != null ) { pp = new password protection ( pkey ) ; entry = ks . get entry ( alias , pp ) ; } else { try { pp = new password protection ( pstore ) ; entry = ks . get entry ( alias , pp ) ; pkey = pstore ; } catch ( unrecoverable entry exception une2 ) { if ( keystore . equals ignore case ( ks . get type ( ) ) ) { throw une2 ; } else { pkey = get key passwd ( alias , null , null ) ; pp = new password protection ( pkey ) ; entry = ks . get entry ( alias , pp ) ; } } } } return pair . of ( entry , pkey ) ; }	recovers entry associated with given alias .
url new loader ( url base ) { return new url ( new url [ ] { base } ) ; }	creates a class loader with the given base url as its classpath .
public void test min unequal1 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal c number = new big decimal ( new big integer ( c ) , c scale ) ; assert equals ( str , c number , a number . min ( b number ) ) ; }	min ( ) for unequal bigdecimals.
public wiser ( ) { this . server = new smtp ( new simple message listener adapter ( this ) ) ; }	create a new smtp server with this class as the listener.
protected static int [ ] concat ( @ nullable int [ ] arr , int ... obj ) { int [ ] new arr ; if ( arr == null || arr . length == num ) new arr = obj ; else { new arr = arrays . copy of ( arr , arr . length + obj . length ) ; system . arraycopy ( obj , num , new arr , arr . length , obj . length ) ; } return new arr ; }	concatenates elements to an int array .
public void truck camera ( float size ) { move to position ( - ( float ) ( target xoff + ( size * math . sin ( math . to radians ( zrot - num ) ) ) ) , - ( float ) ( target yoff + ( size * math . cos ( math . to radians ( zrot - num ) ) ) ) ) ; }	change camera position horizontally ( left or right ) .
public void shutdown ( ) { scheduled executor service . shutdown now ( ) ; }	shut down the health checker .
public builder clear ( ) { locale builder . clear ( ) ; return this ; }	resets the builder to its initial , empty state .
public static string deflate ( string previous , string current ) { if ( previous == null ) return current ; string builder buf = new string builder ( ) ; int start1 = num ; int start2 = num ; while ( start1 < previous . length ( ) && start2 < current . length ( ) ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous . length ( ) && end2 <= current . length ( ) ) { int c1 = ( end1 < previous . length ( ) ? previous . char at ( end1 ) : str ) ; int c2 = ( end2 < current . length ( ) ? current . char at ( end2 ) : str ) ; if ( c1 == c2 ) { if ( c1 == str ) { buf . append ( str ) ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous . length ( ) && previous . char at ( end1 ) != str ) { end1 ++ ; } while ( end2 < current . length ( ) && current . char at ( end2 ) != str ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) buf . append ( current . char at ( i ) ) ; break ; } } start1 = end1 + num ; start2 = end2 + num ; if ( start2 < current . length ( ) ) buf . append ( str ) ; } return buf . to string ( ) ; }	deflate current sam line by replacing all fields that equalovershorterofboth previous line by an ampersand.
protected int split list index ( list < pair < double , integer > > s ) { return s . size ( ) / num ; }	determines which index to use as the splitting index for the vp radius.
public static void e ( string tag , string msg , object ... args ) { if ( s level > level error ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . e ( tag , msg ) ; }	send an error log message.
public static synchronized void add property change listener ( property change listener l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }	register for notification on changes to specific types.
private static void clean directory ( file path ) { if ( path == null ) return ; if ( path . exists ( ) ) { for ( file f : path . list files ( ) ) { if ( f . is directory ( ) ) clean directory ( f ) ; f . delete ( ) ; } } }	recursive remove all from directory.
private grid cache version min version ( iterable < ignite tx entry > entries , grid cache version min , ignite internal tx tx ) { for ( ignite tx entry tx entry : entries ) { grid cache entry ex cached = tx entry . cached ( ) ; assert tx entry . is read ( ) || ! cached . obsolete ( tx . xid version ( ) ) : str + cached + str + tx + str ; for ( grid cache mvcc candidate cand : cached . remote mvcc snapshot ( ) ) if ( min == null || cand . version ( ) . is less ( min ) ) min = cand . version ( ) ; } return min ; }	go through all candidates for entries involved in transaction and find their min version.
public dimensioned scalar ( string field value ) throws illegal argument exception { super ( str , str ) ; matcher matcher = pattern . matcher ( field value ) ; if ( matcher . find ( ) ) { string name = matcher . group ( num ) ; string dimensions = matcher . group ( num ) ; string value = matcher . group ( num ) ; set name ( name ) ; set value ( value ) ; this . dimensions = new dimensions ( dimensions ) ; } else { throw new dictionary exception ( str + field value + str ) ; } }	la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita ' di misura.
public void characters ( char ch [ ] , int start , int length ) throws sax { m value buffer . append ( ch , start , length ) ; }	characters read from xml are assigned to a variable , based on the current m_context.
protected double compute std dev ( instance inst , matrix k ) throws exception { double kappa = m kernel . eval ( - num , - num , inst ) + m delta squared ; double s = num ; int n = m l . length ; for ( int i = num ; i < n ; i ++ ) { double t = num ; for ( int j = num ; j < n ; j ++ ) { t -= k . get ( j , num ) * ( i > j ? m l [ i ] [ j ] : m l [ j ] [ i ] ) ; } s += t * k . get ( i , num ) ; } double sigma = m delta ; if ( kappa > s ) { sigma = math . sqrt ( kappa - s ) ; } return sigma ; }	computes standard deviation for given instance , without transforming target back into original space .
protected void initialize ( properties p ) { }	sub - classes can override to initialize other properties .
public void add ( int index , int element ) { check range including endpoint ( index ) ; ensure capacity ( size + num ) ; int numtomove = size - index ; system . arraycopy ( array , index , array , index + num , numtomove ) ; array [ index ] = element ; size ++ ; }	inserts the specified element at the specified position in this list.
public multiplex manager ( data store ... data stores ) { this . data stores = arrays . as list ( data stores ) ; }	create a single datastore to handle provided managers within a single transaction .
public boolean matches raw name pattern ( object item ) { string prefix = pattern matcher . get pattern ( ) ; string text = get element name ( item ) ; if ( text == null ) return bool ; int text length = text . length ( ) ; int prefix length = prefix . length ( ) ; if ( text length < prefix length ) { return bool ; } for ( int i = prefix length - num ; i >= num ; i -- ) { if ( character . to lower case ( prefix . char at ( i ) ) != character . to lower case ( text . char at ( i ) ) ) return bool ; } return bool ; }	general method for matching raw name pattern.
public static @ nonnull < t > t value or default ( @ nullable t value , @ nonnull t default value ) { return value == null ? default value : value ; }	returns a value if that value is not null , or a specified default value otherwise .
protected abstract int compare to last msg ( pair < k , v > tuple key value , pair < byte [ ] , byte [ ] > last received key value ) ;	compare the incoming tuple with the last received message in kafka .
public void paint component ( graphics g ) { g . draw image ( track , num , num , null ) ; d g2d = ( d ) g . create ( ) ; g2d . translate ( car position . x , car position . y ) ; g2d . rotate ( math . to radians ( car rotation ) ) ; g2d . translate ( - ( car position . x ) , - ( car position . y ) ) ; g2d . draw image ( car , car position . x - car w , car position . y - car h , null ) ; }	render the track and car.
public static java . sql . time to sql time ( string time ) { java . util . date new date = to date ( str , time ) ; if ( new date != null ) { return new java . sql . time ( new date . get time ( ) ) ; } else { return null ; } }	converts a time string into a java.
public string choose server alias ( string key type , principal [ ] issuers , socket socket ) { return default x509 km . choose server alias ( key type , issuers , socket ) ; }	returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
public static double pdf ( double x , double shape , double scale , double factor ) { if ( x <= num ) return num ; final double a = math . exp ( shape * math . log ( scale ) - ( shape + num ) * math . log ( x ) - ( scale / x ) - gamma function . ln gamma ( shape ) ) ; return factor * a ; }	probability density function of the gamma distribution.
public string charge ( properties ctx , int window no , grid tab m tab , grid field m field , object value ) { integer c id = ( integer ) value ; if ( c id == null || c id . int value ( ) == num ) return str ; string sql = str ; prepared statement pstmt = null ; result set rs = null ; try { pstmt = db . prepare statement ( sql , null ) ; pstmt . set int ( num , c id . int value ( ) ) ; rs = pstmt . execute query ( ) ; if ( rs . next ( ) ) { m tab . set value ( str , rs . get big decimal ( num ) ) ; } } catch ( sql e ) { log . log ( level . severe , sql , e ) ; return e . get localized message ( ) ; } finally { db . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx , window no , m tab , m field , value ) ; }	invoice batch line - charge . - updates priceentered from charge calles tax.
protected array < actor > parse ( ) { actors = gdx arrays . new array ( actor . class ) ; invoke pre listeners ( actors ) ; final string builder builder = new string builder ( ) ; while ( template reader . has next character ( ) ) { final char character = template reader . next character ( ) ; if ( character == syntax . get argument opening ( ) ) { process argument ( ) ; } else if ( character == syntax . get tag opening ( ) ) { if ( is next character comment opening ( ) ) { process comment ( ) ; continue ; } if ( current parent tag != null ) { current parent tag . handle data between tags ( builder ) ; } strings . clear builder ( builder ) ; process tag ( builder ) ; } else { builder . append ( character ) ; } } if ( current parent tag != null ) { throw error ( str + current parent tag . get tag name ( ) + str ) ; } invoke port listeners ( actors ) ; return actors ; }	does the actual parsing.
public void test a c ( ) throws exception { bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; start all brokers ( ) ; destination dest = create destination ( str , bool ) ; message consumer client a = create consumer ( str , dest ) ; message consumer client b = create consumer ( str , dest ) ; message consumer client c = create consumer ( str , dest ) ; thread . sleep ( num ) ; send messages ( str , dest , message count ) ; send messages ( str , dest , message count ) ; send messages ( str , dest , message count ) ; message id list msgs a = get consumer messages ( str , client a ) ; message id list msgs b = get consumer messages ( str , client b ) ; message id list msgs c = get consumer messages ( str , client c ) ; msgs a . wait for messages to arrive ( message count ) ; msgs b . wait for messages to arrive ( message count * num ) ; msgs c . wait for messages to arrive ( message count ) ; assert equals ( message count , msgs a . get message count ( ) ) ; assert equals ( message count * num , msgs b . get message count ( ) ) ; assert equals ( message count , msgs c . get message count ( ) ) ; }	brokera - > brokerb < - brokerc.
public void flush ( ) throws io { wsp util . write uint8 ( os , num ) ; write public identifier ( os , public id ) ; wsp util . write uintvar ( os , wap constants . mib enum utf 8 ) ; write string table ( os ) ; wbxml body . close ( ) ; wbxml body . write to ( os ) ; os . flush ( ) ; }	writes the wbxml to stream .
public static void discard ( ) { current . remove ( ) ; }	discards any active baggage currently in this thread.
private token to asi ( i leaf ) { if ( leaf . is hidden ( ) ) { return new semicolon token ( leaf ) ; } else { if ( ! leaf nodes . has next ( ) ) { int token type = token type mapper . get internal token type ( leaf ) ; int semicolon token type = token type mapper . get internal token type ( semicolon ) ; if ( token type == semicolon token type ) { return new common token ( semicolon token type , leaf . get text ( ) ) ; } if ( leaf . get total end offset ( ) == end offset ) { leaf nodes = iterators . empty iterator ( ) ; return new common token ( token type , leaf . get text ( ) ) ; } next = new common token ( semicolon token type , leaf . get text ( ) ) ; return new common token ( token type , leaf . get text ( ) ) ; } else if ( leaf . get grammar element ( ) == right curly in block || leaf . get grammar element ( ) == right curly in arrow expression ) { int token type = token type mapper . get internal token type ( leaf ) ; next = new common token ( token type ) ; return new common token ( token type mapper . get internal token type ( semicolon ) , leaf . get text ( ) ) ; } else { return new semicolon token ( leaf ) ; } } }	produces either one or two tokens from the given leaf which represents a location where the production parser inserted a semicolon .
@ override public packet buffer write ( packet buffer buf ) { values . for each ( null ) ; return buf ; }	writes this packet to the given buffer.
public final void register file type ( @ not null file type type , @ non nls @ nullable string ... default associated extensions ) { list < file name matcher > matchers = new array list < file name matcher > ( ) ; if ( default associated extensions != null ) { for ( string extension : default associated extensions ) { matchers . add ( new extension file name matcher ( extension ) ) ; } } register file type ( type , matchers ) ; }	registers a file type .
public int parse int ( string locale formatted integer ) { return integer . parse int ( locale formatted integer ) ; }	parses an integer based on locale conventions.
public static request security token response parse xml ( string xml ) throws ws { document doc = xml . to dom ( xml , debug ) ; element root = doc . get document element ( ) ; return new request security token response ( root ) ; }	returns requestsecuritytokenresponse object based on the xml document received from server.
@ override public void request resources ( samza resource request resource request ) { final int default priority = num ; log . info ( str + resource request . get preferred host ( ) + str + resource request . get container id ( ) ) ; int memory mb = resource request . get memory mb ( ) ; int cpu cores = resource request . get num cores ( ) ; string container label = yarn config . get container label ( ) ; string preferred host = resource request . get preferred host ( ) ; resource capability = resource . new instance ( memory mb , cpu cores ) ; priority priority = priority . new instance ( default priority ) ; amrm . container request issued request ; if ( preferred host . equals ( str ) ) { log . info ( str + preferred host ) ; issued request = new amrm . container request ( capability , null , null , priority , bool , container label ) ; } else { log . info ( str + preferred host ) ; issued request = new amrm . container request ( capability , new string [ ] { preferred host } , null , priority , bool , container label ) ; } synchronized ( lock ) { requests map . put ( resource request , issued request ) ; am client . add container request ( issued request ) ; } }	request resources for running container processes .
private collection < extracted items collection > filter items by level ( player player , list < extracted items collection > items collections ) { int player level = player . get level ( ) ; collection < extracted items collection > result = new array list < extracted items collection > ( ) ; for ( extracted items collection collection : items collections ) { if ( collection . get min level ( ) > player level ) { continue ; } if ( collection . get max level ( ) > num && collection . get max level ( ) < player level ) { continue ; } result . add ( collection ) ; } return result ; }	add to result collection only items witch suits player ' s level.
public static int binary search floor ( long [ ] a , long key , boolean inclusive , boolean stay in bounds ) { int index = arrays . binary search ( a , key ) ; index = index < num ? - ( index + num ) : ( inclusive ? index : ( index - num ) ) ; return stay in bounds ? math . max ( num , index ) : index ; }	returns the index of the largest value in an array that is less than ( or optionally equal to ) a specified key.
public boolean add ( symbol sym ) throws internal error { object previous ; not null ( sym ) ; previous = all . put ( sym . name ( ) , sym ) ; return previous == null ; }	add a single symbol to the set .
protected static final string add escapes ( string str ) { string buffer retval = new string buffer ( ) ; char ch ; for ( int i = num ; i < str . length ( ) ; i ++ ) { switch ( str . char at ( i ) ) { case num : continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; case str : retval . append ( str ) ; continue ; default : if ( ( ch = str . char at ( i ) ) < num || ch > num ) { string s = str + integer . to string ( ch , num ) ; retval . append ( str + s . substring ( s . length ( ) - num , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to string ( ) ; }	replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string.
public final int size ( ) { if ( gwt . is script ( ) ) { return js array . size ( ) ; } else { return java array . size ( ) ; } }	return the list size.
public static long long from base64 ( string value ) { int pos = num ; long long val = base64 values [ value . char at ( pos ++ ) ] ; int len = value . length ( ) ; while ( pos < len ) { long val <<= num ; long val |= base64 values [ value . char at ( pos ++ ) ] ; } return long val ; }	decode a base64 string into a long value .
public list < local time > bottom ( int n ) { list < local time > bottom = new array list < > ( ) ; int [ ] values = data . to int array ( ) ; int arrays . parallel quick sort ( values ) ; for ( int i = num ; i < n && i < values . length ; i ++ ) { bottom . add ( packed local time . as local time ( values [ i ] ) ) ; } return bottom ; }	returns the smallest ( " bottom " ) n values in the column.
public double sum outlink authority score ( page page ) { list < string > out links = page . get outlinks ( ) ; double auth score = num ; for ( int i = num ; i < out links . size ( ) ; i ++ ) { page out link = p table . get ( out links . get ( i ) ) ; if ( out link != null ) { auth score += out link . authority ; } } return auth score ; }	calculate the hub score of a page by summing the authority scores of that page ' s outlinks .
public synchronized void end ( ) { graphics to be drawn . close ( ) ; if ( current graphics != null ) { graphics drawn . append ( current graphics ) ; } graphics drawn . close when empty ( ) ; if ( printer job thread != null && printer job thread . is alive ( ) ) { try { printer job thread . join ( ) ; } catch ( interrupted exception e ) { } } }	ends the print job and does any necessary cleanup .
public list < file status > browse ( string file path ) throws exception { log . info ( str + file path + str + hdfs end point ) ; file system hdfs file system = null ; file status [ ] list status ; try { configuration config = create config ( ) ; hdfs file system = get file system ( config ) ; path path = new path ( file path ) ; list status = hdfs file system . list status ( path ) ; } catch ( exception ex ) { log . error ( str + file path , ex . get message ( ) ) ; throw new exception ( str + ex . get message ( ) ) ; } finally { if ( hdfs file system != null ) hdfs file system . close ( ) ; } return arrays . as list ( list status ) ; }	brows the files for the specific path.
public void append ( char sequence s ) { text . append ( s ) ; }	add a string to the end of the buffer .
public eip model wizard initial object creation page ( string page id ) { super ( page id ) ; }	pass in the selection . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void unwrap data ( ) throws ignite checked exception , ssl { if ( log . is debug enabled ( ) ) log . debug ( str ) ; in net buf . flip ( ) ; ssl res = unwrap0 ( ) ; in net buf . compact ( ) ; check status ( res ) ; renegotiate if needed ( res ) ; }	unwraps user data to the application buffer .
public boolean is attribute specified ( int attribute handle ) { int type = get node type ( attribute handle ) ; if ( dtm . attribute node == type ) { attr attr = ( attr ) get node ( attribute handle ) ; return attr . get specified ( ) ; } return bool ; }	5 . [ specified ] a flag indicating whether this attribute was actually specified in the start - tag of its element , or was defaulted from the dtd .
private static void check permission ( ) throws security exception { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check permission ( new joda time permission ( str ) ) ; } }	checks whether the provider may be changed using permission ' currenttime.
private void store password ( string password ) { if ( is store && shared state != null ) { shared state . put ( get pwd key ( ) , password ) ; } }	stores password into shared state map.
void delete child ( policy node child node ) { if ( is immutable ) { throw new illegal state exception ( str ) ; } m children . remove ( child node ) ; }	deletes the specified child node of this node , if it exists .
public void test float value plus zero ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; int zero = num ; float result = a number . float value ( ) ; assert true ( str , float . float to int bits ( result ) == zero ) ; }	float value of a small positive bigdecimal.
public external process result await termination and result ( int timeout ms , boolean destroy on error ) throws interrupted exception , timeout exception , operation cancellation , io { await termination ( timeout ms , destroy on error ) ; return new external process result ( process . exit value ( ) , get std out bytes ( ) , get std err bytes ( ) ) ; }	awaits for successful process termination , as well as successful termination of reader threads , throws an exception otherwise ( and destroys the process ) .
public void refresh inherited methods ( set modified super expandos ) { for ( iterator i = modified super expandos . iterator ( ) ; i . has next ( ) ; ) { expando meta class super expando = ( expando meta class ) i . next ( ) ; if ( super expando != this ) { refresh inherited methods ( super expando ) ; } } }	called from expandometaclasscreationhandle in the registry if it exists to set up inheritance handling.
@ override protected void failed ( ) { relation . set canceled ( bool ) ; super . failed ( ) ; }	marks the relation as canceled and invokes the the handler ' s failed ( ) method .
private void change annotation document state ( source document a source document , user a user , annotation document state transition a annotation document state transition ) { annotation document annotation document = repository . get annotation document ( a source document , a user ) ; annotation document . set state ( annotation document state transition . transition ( a annotation document state transition ) ) ; try { repository . create annotation document ( annotation document ) ; } catch ( io e ) { log . info ( str ) ; } }	change the state of an annotation document . used to re - open closed documents.
boolean remove edge ( sparse edge e ) { boolean removed edge = edges . remove ( e ) ; boolean removed neighbour = neighbours . remove ( e . get opposite ( this ) ) ; if ( removed edge && removed neighbour ) return bool ; else if ( ! removed edge && ! removed neighbour ) return bool ; else throw new runtime exception ( str ) ; }	disconnects this vertex from an edge .
protected void long key press ( int key code ) { }	if this component is focused this method is invoked when the user presses and holds the key.
public boolean has descendant ( pattern pattern ) { queue < b > nodes to process = new linked list < b > ( ) ; nodes to process . add ( this ) ; while ( ! nodes to process . is empty ( ) ) { b current node = nodes to process . poll ( ) ; for ( b descendant node : current node . get output nodes ( ) ) { matcher matcher = pattern . matcher ( descendant node . get id ( ) ) ; if ( matcher . matches ( ) ) { return bool ; } if ( ! nodes to process . contains ( descendant node ) ) { nodes to process . add ( descendant node ) ; } } } return bool ; }	returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise.
public int file write ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < num || offset > buffer . length || buffer . length - offset < count ) { throw new array index out of bounds exception ( str + buffer . length + str + offset + str + count ) ; } if ( count == num ) { return num ; } byte [ ] data = buffer ; if ( offset > num ) { data = new byte [ count ] ; system . arraycopy ( buffer , offset , data , num , count ) ; } int out bytes written out = new int out ( ) ; try { check result ( i . afc file write ( get ref ( ) , handle , data , count , bytes written out ) ) ; int bytes written = bytes written out . get value ( ) ; return bytes written ; } finally { bytes written out . delete ( ) ; } }	writes a given number of bytes to a file .
private static void generate files ( ) { string [ ] class names ; resource bundle rules , info ; info = resource bundle . get bundle ( str , new locale ( language , country , valiant ) , rb . instance ) ; class names = info . get string array ( str ) ; rules = resource bundle . get bundle ( str , new locale ( language , country , valiant ) , rb . instance ) ; if ( info . contains key ( str ) ) { generate data file ( info . get string ( str ) , rules . get string ( str ) , class names [ num ] ) ; } if ( info . contains key ( str ) ) { generate data file ( info . get string ( str ) , rules . get string ( str ) , class names [ num ] ) ; } if ( info . contains key ( str ) ) { generate data file ( info . get string ( str ) , rules . get string ( str ) , class names [ num ] ) ; } if ( info . contains key ( str ) ) { generate data file ( info . get string ( str ) , rules . get string ( str ) , class names [ num ] ) ; } }	generate data files whose names are included in sun.
public static boolean is cglib proxy ( object object ) { return class utils . is cglib proxy class ( object . get class ( ) ) ; }	check whether the given object is a cglib proxy .
private float [ ] calculate image indents ( ) { m temp matrix . reset ( ) ; m temp matrix . set rotate ( - get current angle ( ) ) ; float [ ] unrotated image corners = arrays . copy of ( m current image corners , m current image corners . length ) ; float [ ] unrotated crop bounds corners = rect utils . get corners from rect ( m crop rect ) ; m temp matrix . map points ( unrotated image corners ) ; m temp matrix . map points ( unrotated crop bounds corners ) ; f unrotated image rect = rect utils . trap to rect ( unrotated image corners ) ; f unrotated crop rect = rect utils . trap to rect ( unrotated crop bounds corners ) ; float delta left = unrotated image rect . left - unrotated crop rect . left ; float delta top = unrotated image rect . top - unrotated crop rect . top ; float delta right = unrotated image rect . right - unrotated crop rect . right ; float delta bottom = unrotated image rect . bottom - unrotated crop rect . bottom ; float indents [ ] = new float [ num ] ; indents [ num ] = ( delta left > num ) ? delta left : num ; indents [ num ] = ( delta top > num ) ? delta top : num ; indents [ num ] = ( delta right < num ) ? delta right : num ; indents [ num ] = ( delta bottom < num ) ? delta bottom : num ; m temp matrix . reset ( ) ; m temp matrix . set rotate ( get current angle ( ) ) ; m temp matrix . map points ( indents ) ; return indents ; }	first , un - rotate image and crop rectangles ( make image rectangle axis - aligned ).
public void test bug10630 ( ) throws exception { connection conn2 = null ; statement stmt2 = null ; try { conn2 = get connection with props ( ( properties ) null ) ; stmt2 = conn2 . create statement ( ) ; conn2 . close ( ) ; stmt2 . get warnings ( ) ; fail ( str ) ; } catch ( sql sql ex ) { assert equals ( sql . sql state illegal argument , sql ex . get sql ( ) ) ; } finally { if ( stmt2 != null ) { stmt2 . close ( ) ; } if ( conn2 != null ) { conn2 . close ( ) ; } } }	tests fix for bug # 10630 , statement.
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == num ) { return field2 == null || field2 . length == num ; } else { return arrays . equals ( field1 , field2 ) ; } }	checks repeated boolean field equality ; null - value and 0 - length fields are considered equal .
public void to front ( final workflow annotation anno ) { if ( anno == null ) { throw new illegal argument exception ( str ) ; } synchronized ( lock ) { if ( annotations draw order . remove ( anno ) ) { annotations draw order . add ( anno ) ; } if ( annotations event order . remove ( anno ) ) { annotations event order . add ( num , anno ) ; } } }	bring the given annotation to the front.
public synchronized void add frame ( final image image , final long frame duration ) { total duration += frame duration ; frames . add ( new anim frame ( image , total duration ) ) ; }	adds an image to the animation with the specified duration ( time to display the image ) .
public static string print code point as string ( int code point ) { string builder builder = new string builder ( num ) ; builder . append ( str ) ; try { print string code point ( builder , code point ) ; } catch ( io e ) { throw new error ( e ) ; } builder . append ( str ) ; return builder . to string ( ) ; }	builds a string denoting an ascii - encoded ion string , with double - quotes surrounding a single unicode code point .
private void cleanup minidump file ( ) { if ( ! crash file manager . try mark as uploaded ( m file to upload ) ) { log . w ( tag , str + m file to upload + str ) ; if ( ! m file to upload . delete ( ) ) { log . w ( tag , str + m file to upload ) ; } } }	mark file we just uploaded for cleanup later.
boolean close outbound ( ) throws ssl { if ( ssl engine == null || ssl engine . is outbound done ( ) ) { return bool ; } ssl engine . close outbound ( ) ; create out net buffer ( num ) ; ssl result ; for ( ; ; ) { result = ssl engine . wrap ( empty buffer . buf ( ) , out net buffer . buf ( ) ) ; if ( result . get status ( ) == ssl . status . buffer overflow ) { out net buffer . capacity ( out net buffer . capacity ( ) << num ) ; out net buffer . limit ( out net buffer . capacity ( ) ) ; } else { break ; } } if ( result . get status ( ) != ssl . status . closed ) { throw new ssl ( str + result ) ; } out net buffer . flip ( ) ; return bool ; }	start ssl shutdown process .
@ nullable private static bitmap extract thumbnail ( bitmap source , int width , int height ) { return extract thumbnail ( source , width , height , options none ) ; }	creates a centered bitmap of the desired size .
private void write pkg info ( ) throws build exception { file pkg info = new file ( m contents dir , str ) ; print writer writer = null ; try { writer = new print writer ( new buffered writer ( new file writer ( pkg info ) ) ) ; writer . print ( bundle properties . get cf ( ) ) ; writer . println ( bundle properties . get cf ( ) ) ; writer . flush ( ) ; } catch ( io ex ) { throw new build exception ( str + ex ) ; } finally { m file utils . close ( writer ) ; } }	write the pkginfo file into the application bundle.
public event bean [ ] to array ( ) { if ( first event == null ) { return new event bean [ num ] ; } if ( additional events == null ) { return new event bean [ ] { first event } ; } event bean [ ] events = new event bean [ num + additional events . size ( ) ] ; events [ num ] = first event ; int count = num ; for ( event bean the event : additional events ) { events [ count ] = the event ; count ++ ; } return events ; }	returns an array holding the collected events .
private byte [ ] decode ( der input stream in ) throws io { der value val = in . get der value ( ) ; byte [ ] der encoding = val . to byte array ( ) ; der encoding [ num ] = der value . tag ; der input stream der in = new der input stream ( der encoding ) ; der value [ ] der vals = der in . get set ( num , bool ) ; pkc attrib ; object identifier oid ; boolean reuse encoding = bool ; for ( int i = num ; i < der vals . length ; i ++ ) { try { attrib = new pkc ( der vals [ i ] ) ; } catch ( parsing exception e ) { if ( ignore unsupported attributes ) { reuse encoding = bool ; continue ; } else { throw e ; } } oid = attrib . get oid ( ) ; if ( attributes . get ( oid ) != null ) throw new io ( str + oid ) ; if ( permitted attributes != null && ! permitted attributes . contains key ( oid ) ) throw new io ( str + oid + str ) ; attributes . put ( oid , attrib ) ; } return reuse encoding ? der encoding : generate der encoding ( ) ; }	decode this set of pkcs9 attributes from the contents of its der encoding.
string vector process prefix list ( stylesheet handler handler , string uri , string name , string raw name , string value ) throws org . xml . sax . sax { string tokenizer tokenizer = new string tokenizer ( value , str ) ; int n strings = tokenizer . count tokens ( ) ; string vector strings = new string vector ( n strings ) ; for ( int i = num ; i < n strings ; i ++ ) { string prefix = tokenizer . next token ( ) ; string url = handler . get namespace for prefix ( prefix ) ; if ( prefix . equals ( constants . attrval default prefix ) || url != null ) strings . add element ( prefix ) ; else throw new org . xml . sax . sax ( xsl . create message ( xslt . er cant resolve nsprefix , new object [ ] { prefix } ) ) ; } return strings ; }	process an attribute string of type t_prefixlist into a vector of prefixes that may be resolved to urls .
@ override public categorical results clone ( ) { categorical results copy = new categorical results ( n ) ; copy . probabilities = arrays . copy of ( probabilities , probabilities . length ) ; return copy ; }	creates a deep clone of this.
private static string builder dump ( string builder lbuffer , long value ) { for ( int j = num ; j < num ; j ++ ) { lbuffer . append ( hexcodes [ ( int ) ( value > > shifts [ j ] ) & num ] ) ; } return lbuffer ; }	dump a long value into a stringbuilder .
private boolean type special char ( char c ) { switch ( c ) { case str : controller . key press ( key event . vk tab ) ; controller . key release ( key event . vk tab ) ; return bool ; case str : controller . key press ( key event . vk enter ) ; controller . key release ( key event . vk enter ) ; return bool ; default : return bool ; } }	simulate keyboard to type out a special character.
protected static boolean eq ( object o1 , object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }	helper method to check for equality between two object , including null checks .
public static boolean has mime type ( string mime type ) { if ( mime type == null || mime type . is empty ( ) ) { return bool ; } return mime type to extension map . contains key ( mime type ) ; }	returns true if the given mime type has an entry in the map .
public iterable < notification > skip ( @ nonnull final iterable < notification > notifications , final long start id , final boolean inclusive , final int limit size ) { objects . require non null ( notifications ) ; final int position = index of ( notifications , start id ) ; if ( position == - num ) { return iterables . limit ( notifications , limit size ) ; } if ( inclusive ) { return iterables . limit ( iterables . skip ( notifications , position ) , limit size ) ; } return iterables . limit ( iterables . skip ( notifications , position + num ) , limit size ) ; }	returns an iterable that skips forward to a given notification id then only returns count more notifications . if the given notification id is not found.
public boolean write data ( pdx writer writer , object obj ) { if ( is relevant ( obj . get class ( ) ) ) { write data ( writer , obj , get class info ( obj . get class ( ) ) ) ; return bool ; } return bool ; }	using the given pdxwriter , write out the relevant fields for the object instance passed in .
protected final void write c ( byte buffer buf , int value ) { buf . put ( ( byte ) value ) ; }	write byte to buffer .
public boolean is empty ( ) { return priority queue . is empty ( ) ; }	is queue is empty.
public viterbi point ( item item ) { this . item = item ; }	creates a viterbipoint for the given item.
protected void paint content border bottom edge ( graphics g , int x , int y , int w , int h , boolean draw broken , rectangle sel rect , boolean is content border painted ) { if ( is content border painted ) { g . set color ( dark shadow ) ; g . fill rect ( x , y + h - num , w - num , num ) ; } }	draws the bottom edge of the border around the content area.
private void emit list add ( method method , string field name , string builder builder ) { builder . append ( str ) ; builder . append ( get list adder name ( field name ) ) ; builder . append ( str ) ; builder . append ( get type argument impl name ( ( parameterized type ) method . get generic return type ( ) , num ) ) ; builder . append ( str ) ; builder . append ( get ensure name ( field name ) ) ; builder . append ( str ) ; builder . append ( field name ) ; builder . append ( str ) ; builder . append ( str ) ; }	emits an add method to add to a list.
public rsa parse pem ( string pem ) throws general security exception { try { byte [ ] bs = decode ascii armored pem ( pem ) ; byte buffer data = byte buffer . wrap ( bs ) ; final as ob = asn1 parser . parse as ( data ) ; final list < as > seq = asn1 object to sequence ( ob , num ) ; final big integer modulus = asn1 object to big int ( seq . get ( num ) ) ; final big integer exponent = asn1 object to big int ( seq . get ( num ) ) ; return create key from modulus and exponent ( modulus , exponent ) ; } catch ( illegal argument exception e ) { throw new invalid key exception ( ) ; } }	parse a pkcs1 pem encoded rsa public key into the modulus / exponent components and construct a new rsapublickey.
public static < t > parallel publisher < t > from ( publisher < ? extends t > source , boolean ordered , int parallelism ) { return from ( source , ordered , parallelism , px . buffer size ( ) , px . default queue supplier ( px . buffer size ( ) ) ) ; }	take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .
public long next ( long start time , long from time , long current count ) { if ( start time == num ) start time = recurrence util . now ( ) ; if ( from time == num ) from time = start time ; if ( get end time ( ) != num && get end time ( ) <= recurrence util . now ( ) ) return num ; debug . log verbose ( str , module ) ; if ( get count ( ) != - num && current count >= get count ( ) ) return num ; debug . log verbose ( str , module ) ; boolean is seeking = bool ; long next runtime = num ; long seek time = from time ; int loop protection = num ; int max loop = ( num * num * num * num * num ) ; while ( is seeking && loop protection < max loop ) { date next run = get next freq ( start time , seek time ) ; seek time = next run . get time ( ) ; if ( valid by rule ( next run ) ) { is seeking = bool ; next runtime = next run . get time ( ) ; } loop protection ++ ; } return next runtime ; }	returns the next recurrence of this rule .
public void add to queue ( var var ) { add to queue ( collections . singleton ( var ) ) ; }	add a single var to the queue.
public string canonicalize ( string simple url ) { string result url = simple url ; if ( simple url . starts with ( str ) ) { result url = str + simple url ; } else if ( simple url . starts with ( str ) ) { result url = str + simple url ; } else if ( simple url . starts with ( str ) ) { result url = str + simple url ; } else if ( ! has protocol name ( simple url ) ) { if ( is simple host name ( simple url ) ) { simple url = str + simple url + str ; } result url = str + simple url ; } return result url ; }	given a possibly abbreviated url ( missing a protocol name , typically ) , this method ' s job is to transform that url into a canonical form , by including a protocol name and additional syntax , if necessary.
public string read ( string filename ) throws io { return proc file . read file ( string . format ( str , pid , filename ) ) ; }	read the contents of a file in / proc / [ pid ] / [ filename ] .
private long calculate animation duration ( float initial velocity , float displacement ) { return math utils . clamp ( math . round ( math . abs ( num * displacement / initial velocity ) ) , minimum animation duration ms , maximum animation duration ms ) ; }	calculates the animation duration given the | initialvelocity | and a desired | displacement | .
private static double norm ( final double [ ] v ) { double agg = num ; for ( int i = num ; i < v . length ; i ++ ) { agg += ( v [ i ] * v [ i ] ) ; } return math . sqrt ( agg ) ; }	returns the norm l2 . sqrt ( sum_i ( v_i ^ 2 ) ).
private int measure height ( int measure spec ) { float result ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = m paint selected . get stroke width ( ) + get padding top ( ) + get padding bottom ( ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return ( int ) ( ( float ) math . ceil ( result ) ) ; }	determines the height of this view.
public void add ( int i , int data ) { if ( length + num > capacity ) ensure capacity ( length + num ) ; system . arraycopy ( buffer , i , buffer , i + num , length - i ) ; buffer [ i ] = ( byte ) data ; length += num ; }	inserts a byte array.
private double mean ( double [ ] vec ) { double result = num ; for ( int i = num ; i < vec . length ; i ++ ) result += vec [ i ] ; return result / vec . length ; }	the mean of the values in the double array.
private sprite ( float x pos , float y pos , float x vel , float y vel , image ... sprites ) { if ( sprites != null ) sprite frame = new image view ( sprites [ num ] ) ; player states . add all ( arrays . as list ( sprites ) ) ; sprite frame . set translate x ( x pos ) ; sprite frame . set translate y ( y pos ) ; this . x pos = x pos ; this . y pos = y pos ; this . x vel = x vel ; this . y vel = y vel ; }	used internally to create common functions between motion and stationary sprite .
public void close ( ) { out . close ( ) ; }	closes the output stream .
protected static sync token create sync token ( string date string , @ nullable string uuid ) { try { return new sync token ( db date format . parse ( date string ) , uuid ) ; } catch ( parse exception e ) { throw new runtime exception ( e ) ; } }	creates a sync token , and converts any thrown exceptions to runtimeexceptions so it can be used for static fields .
private static boolean equals handles nulls ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	returns true if a and b are equal or are both null .
public void init ( string flagz directory ) throws flag exception , etcd flag field updater exception { this . directory prefix = more objects . first non null ( flagz directory , directory flag . get ( ) ) ; client = new etcd client ( uris . to array ( new uri [ uris . size ( ) ] ) ) ; client . set retry handler ( retry policy ) ; initial set all flagz ( ) ; }	init performs the initial read of values from etcd .
public static void close el ( input stream is ) { try { if ( is != null ) is . close ( ) ; } catch ( throwable t ) { } }	close inputstream without a exception.
public void test random ( ) { extremity monitor monitor = new extremity monitor ( ) ; random random = new random ( num ) ; for ( int i = num ; i < num ; i ++ ) { monitor . update ( random . next double ( ) ) ; } assert true ( monitor . get min ( ) < num ) ; assert true ( monitor . get max ( ) < num ) ; assert true ( monitor . get min ( ) >= num ) ; assert true ( monitor . get max ( ) > num ) ; }	throws a bunch of random numbers between [ 0 , 1 ] at the monitor .
public static string replace ( string str , char old char , string new str ) { string buffer buf = new string buffer ( ) ; for ( int i = num ; i < str . length ( ) ; i ++ ) { char ch = str . char at ( i ) ; if ( ch == old char ) { buf . append ( new str ) ; } else { buf . append ( ch ) ; } } return buf . to string ( ) ; }	returns a string with all occurrences of oldchar replaced by newstr.
@ action ( value = str ) @ validation error page ( value = error ) @ skip validation public string newform ( ) { set login dept ( ) ; simple date format sdf = new simple date format ( str ) ; try { cut off date = sdf . parse ( collections util . get app config value ( collection constants . module name collections config , collection constants . appconfig value collectiondataentrycutoffdate ) ) ; } catch ( parse exception e ) { logger . error ( get text ( str ) + e . get message ( ) ) ; } return new ; }	this method is invoked when the user clicks on create challan from menu tree.
public type declaration canonicalize ( ) { list < type > sts = get satisfied types ( ) ; if ( sts . is empty ( ) ) { return unit . get anything declaration ( ) ; } else if ( sts . size ( ) == num ) { type st = sts . get ( num ) ; if ( st . is exactly nothing ( ) ) { return unit . get nothing declaration ( ) ; } } for ( type st : sts ) { if ( st . is union ( ) ) { list < type > case types = st . get case types ( ) ; list < type > ulist = new array list < type > ( case types . size ( ) ) ; for ( type ct : case types ) { list < type > ilist = new array list < type > ( sts . size ( ) ) ; for ( type pt : sts ) { if ( pt == st ) { add to intersection ( ilist , ct , unit ) ; } else { add to intersection ( ilist , pt , unit ) ; } } type it = canonical intersection ( ilist , unit ) ; add to union ( ulist , it ) ; } type declaration result = new union type ( unit ) ; result . set case types ( ulist ) ; return result ; } } return this ; }	apply the distributive rule x & ( y | z ) = = x & y | x & z to simplify the intersection to a canonical form with no parens.
public static void open other uri ( final string url , final activity activity ) { intent intent = new intent ( intent . action view , uri . parse ( url ) ) ; activity . start activity ( intent ) ; }	start the application in browser to see the url or choose by other application to view this uri.
public static boolean wait for all active and live replicas ( zk state reader zk state reader , int timeout in ms ) { return wait for all active and live replicas ( zk state reader , null , timeout in ms ) ; }	wait to see * all * cores live and active .
public synchronized void add element ( e object ) { if ( element count == element data . length ) { grow by one ( ) ; } element data [ element count ++ ] = object ; mod count ++ ; }	adds the specified object at the end of this vector .
public boolean check for rp ( ) { return null column value getter . is not null value ( get rp copy name ( ) ) ; }	uses a field in the volume to determine if the volume is an rp volume.
public static list < string > split path ( file file ) { list < string > output = new array list < > ( ) ; file current = file ; while ( current != null ) { output . add ( current . get name ( ) ) ; current = current . get parent file ( ) ; } collections . reverse ( output ) ; return output ; }	split a file into a list of directories ending with the file name.
protected boolean is compatible ( taxa taxa , list < taxon > available taxa ) { for ( int i = num ; i < taxa . get taxon count ( ) ; i ++ ) { taxon taxon = taxa . get taxon ( i ) ; if ( ! available taxa . contains ( taxon ) ) { return bool ; } } return bool ; }	returns true if taxa are all found in availabletaxa.
protected int draw label text ( object native graphics , int text decoration , boolean rtl , boolean is ticker running , boolean ends with3 points , object native font , int txt w , int text space w , int shift text , string text , int x , int y , int font height ) { if ( ( ! is ticker running ) || rtl ) { if ( txt w > text space w && text space w > num ) { if ( rtl ) { if ( ( ! is ticker running ) && ends with3 points ) { string points = str ; int points w = string width ( native font , points ) ; draw string ( native graphics , native font , points , shift text + x , y , text decoration , font height ) ; clip rect ( native graphics , points w + shift text + x , y , text space w - points w , font height ) ; } x = x - txt w + text space w ; } else if ( ends with3 points ) { string points = str ; int index = num ; int widest = char width ( native font , str ) ; int points w = string width ( native font , points ) ; int text len = text . length ( ) ; while ( fast char width check ( text , index , text space w - points w , widest , native font ) && index < text len ) { index ++ ; } text = text . substring ( num , math . min ( text len , math . max ( num , index - num ) ) ) + points ; txt w = string width ( native font , text ) ; } } } draw string ( native graphics , native font , text , shift text + x , y , text decoration , font height ) ; return math . min ( txt w , text space w ) ; }	draws the text of a label.
public boolean has map objects ( ) { return map objects != null && ! map objects . is empty ( ) ; }	indicates whether this map layer has any map objects .
public void perform actions ( ) throws throwable { for ( throwing . runnable action : actions ) { action . run ( ) ; } }	runs the commands that have been queued up .
public java . util . collection < object reference > dump thread roots ( int width ) { return collections . empty list ( ) ; }	print the thread roots and return them for processing .
protected void add field name translation ( embeddable mapping embeddable mapping , string override name , database field override field , mapping accessor aggregates accessor ) { database mapping aggregates mapping = aggregates accessor . get mapping ( ) ; database field aggregates mapping field = aggregates mapping . get field ( ) ; if ( aggregates accessor . is id ( ) ) { update primary key field ( aggregates accessor , override field ) ; } if ( override name . contains ( str ) ) { embeddable mapping . add nested field translation ( override name , override field , aggregates mapping field . get name ( ) ) ; } else { embeddable mapping . add field translation ( override field , aggregates mapping field . get name ( ) ) ; } }	internal : process an attribute override for either an embedded object mapping , or an element collection mapping containing embeddable objects .
public dimension minimum layout size ( container target ) { synchronized ( target . get tree lock ( ) ) { dimension dim = new dimension ( num , num ) ; if ( ( chart != null ) && chart . is visible ( ) ) { dimension d = chart . get minimum size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x label != null ) && x label . is visible ( ) ) { dimension d = x label . get minimum size ( ) ; dim . width = math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y label != null ) && y label . is visible ( ) ) { dimension d = y label . get minimum size ( ) ; dim . width += d . width + hgap ; dim . height = math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is visible ( ) ) { dimension d = title . get minimum size ( ) ; dim . width = math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } insets insets = target . get insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }	returns the minimum dimensions needed to layout the components contained in the specified target container .
private void check resource change ( final resource resource , final group group , final callback callback , final atomic boolean is changed ) throws exception { if ( is changed ( resource , group . get name ( ) ) ) { is changed . compare and set ( bool , bool ) ; callback . on resource changed ( resource ) ; lifecycle callback . on resource changed ( resource ) ; } }	will check if a given resource was changed and will invoke the appropriate callback .
public javax2 . sip . address . url create tel url ( string uri ) throws parse exception { if ( uri == null ) throw new null pointer exception ( str ) ; string tel url = str + uri ; try { string msg parser smp = new string msg parser ( ) ; url timp = ( url ) smp . parse url ( tel url ) ; return ( url ) timp ; } catch ( parse exception ex ) { throw new parse exception ( ex . get message ( ) , num ) ; } }	creates a telurl based on given uri string.
public svm ( example set example set , list < support vector > support vectors , kernel kernel , double bias ) { super ( example set , example set utilities . sets compare option . allow superset , example set utilities . types compare option . allow same parents ) ; this . support vectors = support vectors ; if ( support vectors == null || support vectors . size ( ) == num ) { throw new illegal argument exception ( str ) ; } this . kernel = kernel ; this . bias = bias ; if ( this . kernel instanceof dot kernel ) { this . weights = new double [ get number of attributes ( ) ] ; for ( int i = num ; i < get number of support vectors ( ) ; i ++ ) { support vector sv = get support vector ( i ) ; if ( sv != null ) { double [ ] x = sv . get x ( ) ; double alpha = sv . get alpha ( ) ; double y = sv . get y ( ) ; for ( int j = num ; j < weights . length ; j ++ ) { weights [ j ] += y * alpha * x [ j ] ; } } else { this . weights = null ; break ; } } } }	creates a classification model .
private synchronized boolean restart ( ) throws servlet exception { if ( singelton != null ) singelton . reset ( ) ; init engine ( ) ; system . gc ( ) ; return bool ; }	restart the cfml engine.
public sorter ( ) { use default visual ( ) ; set layout ( new border layout ( ) ) ; add ( m visual , border layout . center ) ; m env = environment . get system wide ( ) ; m stop requested = new atomic boolean ( bool ) ; }	constructs a new sorter.
public string to string ( ) { return character . to string ( get value ( ) ) ; }	obtains the string representation of this object .
public static double logpdf ( double x , double mu , double shape ) { if ( ! ( x > num ) || x == double . positive infinity ) { return double . negative infinity ; } final double v = ( x - mu ) / mu ; return v < double . max value ? num * math . log ( shape / ( math util . twopi * x * x * x ) ) - shape * v * v / ( num * x ) : double . negative infinity ; }	probability density function of the wald distribution .
public static format generate format ( string codec ) { return ( format ) supported codecs . get ( codec . to lower case ( ) ) ; }	generate the format associated to the codec name.
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . sax { int start old = start ; if ( m in entity ref ) return ; if ( m elem context . m start tag open ) { close start tag ( ) ; m elem context . m start tag open = bool ; } else if ( m need to call start document ) { start document internal ( ) ; m need to call start document = bool ; } try { final int limit = start + length ; boolean was dash = bool ; if ( m cdata tag open ) close cdata ( ) ; if ( should indent ( ) ) indent ( ) ; final java . io . writer writer = m writer ; writer . write ( comment begin ) ; for ( int i = start ; i < limit ; i ++ ) { if ( was dash && ch [ i ] == str ) { writer . write ( ch , start , i - start ) ; writer . write ( str ) ; start = i + num ; } was dash = ( ch [ i ] == str ) ; } if ( length > num ) { final int remaining chars = ( limit - start ) ; if ( remaining chars > num ) writer . write ( ch , start , remaining chars ) ; if ( ch [ limit - num ] == str ) writer . write ( str ) ; } writer . write ( comment end ) ; } catch ( io e ) { throw new sax ( e ) ; } m start new line = bool ; if ( m tracer != null ) super . fire comment event ( ch , start old , length ) ; }	receive notification of an xml comment anywhere in the document.
public optional int max by int ( int unary operator key extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ num ] == num ? optional int . of ( result [ num ] ) : optional int . empty ( ) ; }	returns the maximum element of this stream according to the provided key extractor function.
public t find by commit counter ( final long commit counter ) { if ( commit counter < num ) throw new illegal argument exception ( ) ; final lock lock = read lock ( ) ; lock . lock ( ) ; try { @ suppress warnings ( str ) final i < t > itr = range iterator ( null , null , num , i . default | i . reverse , null ) ; while ( itr . has next ( ) ) { final i < t > t = itr . next ( ) ; final t r = t . get object ( ) ; final i rb = r . get root block ( ) ; if ( rb . get commit counter ( ) <= commit counter ) { return r ; } } return null ; } finally { lock . unlock ( ) ; } }	find the oldest entry whose commit counter is lte the specified commit counter .
private void start animation ( ) { value animator animator = value animator . of float ( num ) ; array list < name values holder > name value list = ( array list < name values holder > ) m pending animations . clone ( ) ; m pending animations . clear ( ) ; int property mask = num ; int property count = name value list . size ( ) ; for ( int i = num ; i < property count ; ++ i ) { name values holder name values holder = name value list . get ( i ) ; property mask |= name values holder . m name constant ; } m animator map . put ( animator , new property bundle ( property mask , name value list ) ) ; animator . add update listener ( m animator event listener ) ; animator . add listener ( m animator event listener ) ; if ( m start delay set ) { animator . set start delay ( m start delay ) ; } if ( m duration set ) { animator . set duration ( m duration ) ; } if ( m interpolator set ) { animator . set interpolator ( m interpolator ) ; } animator . start ( ) ; }	starts the underlying animator for a set of properties.
public static string trace excetion ( throwable ex ) { final writer result = new string writer ( ) ; final print writer print writer = new print writer ( result ) ; ex . print stack trace ( print writer ) ; string stacktrace = result . to string ( ) ; log . e ( tag , str + stacktrace ) ; return stacktrace ; }	write exception throw in log.
public static pair < string , string > split ( string var name ) { int split index = var name . index of ( str ) ; if ( split index < num ) { return null ; } string left = var name . substring ( num , split index ) ; string right = var name . substring ( split index + num ) ; if ( left == null || left . length ( ) == num || right == null || right . length ( ) == num ) { return null ; } return pair . of ( left , right ) ; }	splits a qualified varname into two parts , a left and a right left will be the text before the first instance of ' . ' right will be everything else returns null if the varname could not be split for any reason.
public void on child thread resume end ( ) { thread count . get and decrement ( ) ; wake ( ) ; }	end housekeeping for a child thread managed by the launcher ' s housekeeping , but not spawned by the launcher itself , e.
public static void register transport m ( string container name ) { m m bean server = get m ( container name ) ; if ( m bean server == null ) return ; m transport connections info m = new transport protocol monitor ( ) ; object name obj name = transport constants . create transport m ( container name ) ; if ( ! m bean server . is registered ( obj name ) ) { try { m bean server . register m ( transport connections info m , obj name ) ; } catch ( instance already exists exception e ) { if ( logger . is loggable ( level . config ) ) { logger . config ( already registred transport m + container name + str ) ; } } catch ( m e ) { if ( logger . is loggable ( level . warning ) ) { logger . log ( level . severe , failed transport m + container name + str , e ) ; } } catch ( m e ) { if ( logger . is loggable ( level . severe ) ) { logger . log ( level . severe , failed transport m + container name + str , e ) ; } } if ( logger . is loggable ( level . config ) ) { logger . config ( successful transport m + container name + str ) ; } } else { if ( logger . is loggable ( level . config ) ) { logger . config ( already registred transport m ) ; } } }	create management bean for jspace container .
public static int update ( string where , object [ ] args , v sets , class < ? extends bean > t ) { table mapping = ( table ) t . get annotation ( table . class ) ; if ( mapping == null ) { if ( log . is error enabled ( ) ) log . error ( str + t + str ) ; return - num ; } if ( ! x . is empty ( mapping . name ( ) ) ) { return update table ( mapping . name ( ) , where , args , sets ) ; } return - num ; }	update the data using values.
private void stop video fading edges screen timer ( ) { if ( null != m video fading edges timer ) { m video fading edges timer . cancel ( ) ; m video fading edges timer = null ; m video fading edges timer task = null ; } }	stop the video fading timer .
public void remove listener ( final timeout event listener listener ) { listeners . remove ( listener ) ; }	deregisters a timeout event listener for timeout notification .
protected static void process generic properties creator props ( file props file ) { try { properties exp props = new properties ( ) ; buffered input stream bi = new buffered input stream ( new file input stream ( props file ) ) ; exp props . load ( bi ) ; bi . close ( ) ; bi = null ; properties gpc = generic properties creator . get global input properties ( ) ; set < object > keys = exp props . key set ( ) ; iterator < object > keys i = keys . iterator ( ) ; while ( keys i . has next ( ) ) { string key = ( string ) keys i . next ( ) ; string existing val = gpc . get property ( key , str ) ; if ( existing val . length ( ) > num ) { string new val = exp props . get property ( key ) ; if ( existing val . index of ( new val ) < num ) { new val = existing val + str + new val ; gpc . put ( key , new val ) ; } } else { string new val = exp props . get property ( key ) ; gpc . put ( key , new val ) ; } } } catch ( exception ex ) { } }	process a package ' s genericpropertiescreator . props file.
private synchronized void add table lock object ( absolute table identifier absolute table identifier ) { if ( null == table lock map . get ( absolute table identifier ) ) { table lock map . put ( absolute table identifier , new object ( ) ) ; } }	method to add table level lock if lock is not present for the table.
private static string random element ( array list < string > list ) { int index = random . next int ( list . size ( ) ) ; return list . get ( index ) ; }	utility to grab a random element from an array of strings .
public static < t > void update mapping to immutable set ( map < t , set < annotation mirror > > map , t key , set < annotation mirror > new qual ) { set < annotation mirror > result = annotation utils . create annotation set ( ) ; if ( ! map . contains key ( key ) ) { result . add all ( new qual ) ; } else { result . add all ( map . get ( key ) ) ; result . add all ( new qual ) ; } map . put ( key , collections . unmodifiable set ( result ) ) ; }	see checkers . types . qualifierhierarchy # updatemappingtomutableset ( qualifierhierarchy , map , object , annotationmirror ) ( not linked because it is in an independent project .
public static void join ( final async invocation < ? > async , final long timeout milliseconds ) { join ( async . get thread ( ) , timeout milliseconds ) ; }	wait for a thread to join .
void define ( member definition field , int slot , int from , int to ) { if ( from >= to ) { return ; } for ( int i = num ; i < len ; i ++ ) { if ( ( locals [ i ] . field == field ) && ( locals [ i ] . slot == slot ) && ( from <= locals [ i ] . to ) && ( to >= locals [ i ] . from ) ) { locals [ i ] . from = math . min ( locals [ i ] . from , from ) ; locals [ i ] . to = math . max ( locals [ i ] . to , to ) ; return ; } } if ( len == locals . length ) { local variable newlocals [ ] = new local variable [ len * num ] ; system . arraycopy ( locals , num , newlocals , num , len ) ; locals = newlocals ; } locals [ len ++ ] = new local variable ( field , slot , from , to ) ; }	define a new local variable.
protected connection open connection ( boolean autocommit ) throws sql { connection conn = data src . get connection ( ) ; conn . set auto commit ( autocommit ) ; return conn ; }	gets connection from a pool .
public void error ( x xctxt , string msg , object [ ] args ) throws javax . xml . transform . transformer exception { java . lang . string fmsg = xsl . create xpath ( msg , args ) ; if ( null != xctxt ) { error listener eh = xctxt . get error listener ( ) ; transformer exception te = new transformer exception ( fmsg , this ) ; eh . fatal error ( te ) ; } }	tell the user of an error , and probably throw an exception .
public void mouse pressed ( mouse event e ) { int nclicks = swing utilities2 . get adjusted click count ( get component ( ) , e ) ; if ( swing utilities . is left mouse button ( e ) ) { if ( e . is consumed ( ) ) { should handle release = bool ; } else { should handle release = bool ; adjust caret and focus ( e ) ; if ( nclicks == num && swing utilities2 . can event access system clipboard ( e ) ) { select word ( e ) ; } } } }	if button 1 is pressed , this is implemented to request focus on the associated text component , and to set the caret position.
public static byte [ ] decode ( string str , int flags ) { return decode ( str . get bytes ( ) , flags ) ; }	decode the base64 - encoded data in input and return the data in a new byte array.
public object apply ( string source , int line no , int column no , object func body , vector param names , vector arguments ) throws bsf { object object = eval ( source , line no , column no , func body ) ; if ( object instanceof closure ) { closure closure = ( closure ) object ; return closure . call ( arguments . to array ( ) ) ; } return object ; }	allow an anonymous function to be declared and invoked.
public set key set ( ) { return total key set ( ) ; }	returns the total key set of all scopes.
public void output ( list list , writer out ) throws io { print content range ( out , list , num , list . size ( ) , num , create namespace stack ( ) ) ; out . flush ( ) ; }	this will handle printing out a list of nodes.
private int [ ] mod ( int [ ] a , int [ ] f ) { int df = compute degree ( f ) ; if ( df == - num ) { throw new arithmetic exception ( str ) ; } int [ ] result = new int [ a . length ] ; int hc = head coefficient ( f ) ; hc = field . inverse ( hc ) ; system . arraycopy ( a , num , result , num , result . length ) ; while ( df <= compute degree ( result ) ) { int [ ] q ; int coeff = field . mult ( head coefficient ( result ) , hc ) ; q = mult with monomial ( f , compute degree ( result ) - df ) ; q = mult with element ( q , coeff ) ; result = add ( q , result ) ; } return result ; }	reduce a polynomial modulo another polynomial .
@ override public enumeration < option > list options ( ) { vector < option > result = enum to vector ( super . list options ( ) ) ; result . add element ( new option ( str + default num clusters ( ) + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + default min inst num ( ) + str + default max inst num ( ) + str + str + str , str , num , str ) ) ; result . add element ( new option ( str + default min radius ( ) + str + default max radius ( ) + str + str + str , str , num , str ) ) ; result . add element ( new option ( str + default dist mult ( ) + str , str , num , str ) ) ; result . add element ( new option ( str + default num cycles ( ) + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + default noise rate ( ) + str + str + str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static void append hex java script representation ( string builder sb , char c ) { sb . append ( str ) ; string val = integer . to hex string ( c ) ; for ( int j = val . length ( ) ; j < num ; j ++ ) { sb . append ( str ) ; } sb . append ( val ) ; }	returns a javascript representation of the character in a hex escaped format.
private void print bootstrap map ( ) { log . info ( str ) ; for ( integer i : chain map . key set ( ) ) { log . info ( string . format ( str , i , chain map . get ( i ) ) ) ; } }	just a small method to show how many times each activity chain index was sampled.
public vector < option > enum to vector ( enumeration < option > enu ) { vector < option > options = new vector < option > ( ) ; options . add all ( collections . list ( enu ) ) ; return options ; }	convenience method . turns the given enumeration of options into a vector .
private void add token ( int token ) { try { f tokens [ f token count ] = token ; } catch ( array index out of bounds exception ex ) { int [ ] old list = f tokens ; f tokens = new int [ f token count << num ] ; system . arraycopy ( old list , num , f tokens , num , f token count ) ; f tokens [ f token count ] = token ; } f token count ++ ; }	add the specified int token.
private p filter large value sets ( filter spec fs , meta data object root meta , f root , boolean force entity based , join type default predicate join type ) { array list < filter spec > specs = new array list < > ( ) ; list < ? > list = new array list < > ( ( collection < ? > ) fs . get value ( ) ) ; for ( int i = num ; i < list . size ( ) ; i += oracle param limit ) { int next offset = i + math . min ( list . size ( ) - i , oracle param limit ) ; list < ? > batch list = list . sub list ( i , next offset ) ; specs . add ( new filter spec ( fs . get attribute path ( ) , fs . get operator ( ) , batch list ) ) ; } filter spec or spec = filter spec . or ( specs ) ; return filter spec list to predicate ( root meta , root , or spec , force entity based , default predicate join type ) ; }	split filters with two many value possibilities.
protected void add tags ( e data , builder builder ) { platform ident platform ident = cached data service . get platform ident for id ( data . get platform ident ( ) ) ; builder . tag ( series . tag agent id , string . value of ( data . get platform ident ( ) ) ) ; if ( null != platform ident ) { builder . tag ( series . tag agent name , platform ident . get agent name ( ) ) ; } }	adds needed tags related to the data to the builder.
private static int load build number ( context context , package manager package manager ) { try { application info app info = package manager . get application info ( context . get package name ( ) , package manager . get meta data ) ; bundle meta data = app info . meta data ; if ( meta data != null ) { return meta data . get int ( bundle build number , num ) ; } } catch ( package manager . name not found exception e ) { l . e ( str ) ; e . print stack trace ( ) ; } return num ; }	helper method to load the build number from the androidmanifest .
public static left regular bipartite graph segment build random left regular bipartite graph ( int left size , int right size , int left degree , random random ) { left regular bipartite graph segment left regular bipartite graph segment = new left regular bipartite graph segment ( left size / num , left degree , right size / num , left size / num , num , integer . max value , new identity edge type mask ( ) , new null stats receiver ( ) ) ; long set added ids = new long open hash set ( left degree ) ; for ( int i = num ; i < left size ; i ++ ) { added ids . clear ( ) ; for ( int j = num ; j < left degree ; j ++ ) { long id to add ; do { id to add = random . next int ( right size ) ; } while ( added ids . contains ( id to add ) ) ; added ids . add ( id to add ) ; left regular bipartite graph segment . add edge ( i , id to add , ( byte ) num ) ; } } return left regular bipartite graph segment ; }	build a random left - regular bipartite graph of given left and right sizes .
@ override public void add focusables ( array list < view > views , int direction , int focusable mode ) { final int focusable count = views . size ( ) ; final int descendant focusability = get descendant focusability ( ) ; if ( descendant focusability != focus block descendants ) { for ( int i = num ; i < get child count ( ) ; i ++ ) { final view child = get child at ( i ) ; if ( child . get visibility ( ) == visible ) { item info ii = info for child ( child ) ; if ( ii != null && ii . position == m cur item ) { child . add focusables ( views , direction , focusable mode ) ; } } } } if ( descendant focusability != focus after descendants || ( focusable count == views . size ( ) ) ) { if ( ! is focusable ( ) ) { return ; } if ( ( focusable mode & focusables touch mode ) == focusables touch mode && is in touch mode ( ) && ! is focusable in touch mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }	we only want the current page that is being shown to be focusable .
protected url configure request ( final url request ) { if ( credentials != null ) request . set request property ( header authorization , credentials ) ; request . set request property ( header user agent , user agent ) ; request . set request property ( header accept , get header accept ( ) ) ; return request ; }	configure request with standard headers.
public static string convert to title ( int n ) { if ( n <= num ) return str ; string builder title = new string builder ( ) ; while ( n > num ) { n -- ; int r = n % num ; title . insert ( num , ( char ) ( str + r ) ) ; n = n / num ; } return title . to string ( ) ; }	get the remainder in each loop it should be the last digit note that the map shall have 1 offset.
private char read escape character ( ) throws json { char escaped = in . char at ( pos ++ ) ; switch ( escaped ) { case str : if ( pos + num > in . length ( ) ) { throw syntax error ( str ) ; } string hex = in . substring ( pos , pos + num ) ; pos += num ; return ( char ) integer . parse int ( hex , num ) ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : case str : case str : default : return escaped ; } }	unescapes the character identified by the character or characters that immediately follow a backslash.
static public void process ( string input , string output , string pack file name ) { process ( new settings ( ) , input , output , pack file name ) ; }	packs using defaults settings .
private replicator runtime conf ( string service name ) { replicator home dir = locate replicator home dir ( ) ; replicator log dir = locate replicator log dir ( ) ; replicator conf dir = locate replicator conf dir ( ) ; replicator properties = new file ( locate replicator conf dir ( ) , str + service name + str ) ; if ( ! replicator properties . is file ( ) || ! replicator properties . can read ( ) ) { throw new server runtime exception ( str + replicator properties ) ; } replicator dynamic properties = new file ( replicator conf dir , str + service name + str ) ; replicator dynamic role = new file ( replicator conf dir , str + service name + str ) ; this . clear dynamic properties = boolean . parse boolean ( system . get property ( clear dynamic properties ) ) ; }	creates a new instance .
private string to local number ( double n ) { return m decimal format . format ( n ) ; }	converts the given double to a localized string version .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java security do privileged ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java security do privileged ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java security do privileged ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java security do privileged ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java security get stack access control context ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java security get inherited access control context ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public static long [ ] as long array ( final list < long > l ) { final long [ ] a = new long [ l . size ( ) ] ; for ( int i = num ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }	return list of boxed longs as a primitive array .
private void update menu state ( ) { m append and . set enabled ( m criterium node . allow append ( c . class ) ) ; m append or . set enabled ( m criterium node . allow append ( c . class ) ) ; m append not . set enabled ( m criterium node . allow append ( c . class ) ) ; m insert and . set enabled ( m criterium node . allow insert ( c . class ) ) ; m insert or . set enabled ( m criterium node . allow insert ( c . class ) ) ; m insert not . set enabled ( m criterium node . allow insert ( c . class ) ) ; m condition submenu . set enabled ( m criterium node . allow append ( c . class ) ) ; m remove . set enabled ( ! m criterium node . is root ( ) ) ; m remove all . set enabled ( m criterium node . get child count ( ) != num ) ; }	updates the state of the context menu depending on the state of the criterium tree .
public void test put get remove ( ) throws exception { init store ( num ) ; set < integer > exp ; try { exp = run put get remove multithreaded ( num , num ) ; } finally { shutdown store ( ) ; } map < integer , string > map = delegate . get map ( ) ; collection < integer > extra = new hash set < > ( map . key set ( ) ) ; extra . remove all ( exp ) ; assert true ( str + extra , extra . is empty ( ) ) ; collection < integer > missing = new hash set < > ( exp ) ; missing . remove all ( map . key set ( ) ) ; assert true ( str + missing , missing . is empty ( ) ) ; for ( integer key : exp ) assert equals ( str + key , str + key , map . get ( key ) ) ; }	this test performs complex set of operations on store from multiple threads .
public static string format list to string ( list < string > list ) { string result = str ; for ( string s : list ) result += s + str ; result = result . trim ( ) ; return result . to upper case ( ) ; }	formats the list objects from the pokemodel into formatted strings that are easily readable .
@ override public void remove notification listener ( notification listener listener ) throws listener not found exception { if ( snmp adaptor logger . is loggable ( level . finest ) ) { snmp adaptor logger . logp ( level . finest , dbg tag , str , str + listener ) ; } notif broadcaster . remove notification listener ( listener ) ; }	removes the specified listener from this communicatorserver.
private static void d ucumm ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprods = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) arrays . fill ( cprods , num ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { product agg ( a , cprods , aix , num , n ) ; system . arraycopy ( cprods , num , c , aix , n ) ; } }	cumprod , opcode : ucum * , dense input .
public static list < module spec > expand spec wildcards ( file dir , list < module spec > modules , backend for backend ) { list < file > dirs = new array list < file > ( ) ; dirs . add ( dir ) ; return expand spec wildcards ( dirs , modules , for backend ) ; }	given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory.
private static string report list contents ( collection < process error state info > err list ) { if ( err list == null ) return null ; string builder builder = new string builder ( ) ; iterator < process error state info > iter = err list . iterator ( ) ; while ( iter . has next ( ) ) { process error state info entry = iter . next ( ) ; string condition ; switch ( entry . condition ) { case activity manager . process error state info . crashed : condition = str ; break ; case activity manager . process error state info . not responding : condition = str ; break ; default : condition = str ; break ; } builder . append ( string . format ( str , entry . process name , condition , entry . short msg ) ) ; if ( entry . condition == activity manager . process error state info . crashed ) { builder . append ( string . format ( str , entry . stack trace ) ) ; } builder . append ( str ) ; } return builder . to string ( ) ; }	this helper function will dump the actual error reports .
public void test get issuer names ( ) { crl selector = new crl ( ) ; byte [ ] iss1 = new byte [ ] { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte [ ] iss2 = new byte [ ] { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; assert null ( str , selector . get issuer names ( ) ) ; try { selector . add issuer name ( iss1 ) ; selector . add issuer name ( iss2 ) ; } catch ( io e ) { e . print stack trace ( ) ; fail ( str ) ; } collection < object > result = selector . get issuer names ( ) ; assert equals ( str , num , result . size ( ) ) ; }	getissuernames ( ) method testing.
@ override public boolean start ( ) throws io { log . info ( str , initial checkpoint generator ) ; try { kinesis reader checkpoint initial checkpoint = initial checkpoint generator . generate ( kinesis ) ; list < shard records iterator > iterators = new array list ( ) ; for ( shard checkpoint checkpoint : initial checkpoint ) { iterators . add ( checkpoint . get shard records iterator ( kinesis ) ) ; } shard iterators = new round robin < > ( iterators ) ; } catch ( transient kinesis exception e ) { throw new io ( e ) ; } return advance ( ) ; }	generates initial checkpoint and instantiates iterators for shards .
@ override public xa create xa ( properties properties ) throws sql { properties properties copy = new properties ( ) ; if ( properties != null ) { properties copy . put all ( properties ) ; } reject unsupported options ( properties copy ) ; reject pooling options ( properties copy ) ; jdbc data source data source = new jdbc data source ( ) ; setup h2 data source ( data source , properties copy ) ; return data source ; }	creates a pooled xa data source .
public static double to degrees ( double x ) { if ( double . is infinite ( x ) || x == num ) { return x ; } final double facta = num ; final double factb = num ; double xa = double high part ( x ) ; double xb = x - xa ; return xb * factb + xb * facta + xa * factb + xa * facta ; }	convert radians to degrees , with error of less than 0 . 5 ulp.
public void add header view ( view v ) { add header view ( v , null , bool ) ; }	add a fixed view to appear at the top of the grid.
public static boolean is absolute path ( string system id ) { if ( system id == null ) return bool ; final file file = new file ( system id ) ; return file . is absolute ( ) ; }	return true if the local path is an absolute path .
void init demand and collection map ( final list < string > prepare field names , final map < string , big decimal > demand , final map < string , big decimal > collection , final map < string , big decimal > rebates ) { if ( prepare field names != null && ! prepare field names . is empty ( ) ) for ( final string field name : prepare field names ) { demand . put ( field name , big decimal . zero ) ; collection . put ( field name , big decimal . zero ) ; rebates . put ( field name , big decimal . zero ) ; } }	method called internally to prepare the map with fieldnames dynamically ( i . e field names can be verified depending upon the client ).
protected instance specifier ( int i ) { return m . get ( i ) ; }	get the template at the given position .
public shaped crafting recipe ( item nominal output , recipe function recipe function , string format , boolean mirrored , item ingredient ... ingredients ) { this . nominal output = nominal output ; string [ ] format lines = format . split ( str ) ; int num ingredients = num ; int width = num ; for ( string format line : format lines ) { width = math . max ( width , format line . length ( ) ) ; for ( char c : format line . to char array ( ) ) { if ( c == str ) { continue ; } else if ( c >= str && c <= str ) { num ingredients ++ ; } else { throw new illegal argument exception ( str + format + str + c ) ; } } } this . width = width ; this . height = format lines . length ; this . posx = new int [ num ingredients ] ; this . posy = new int [ num ingredients ] ; this . ingredients = new item ingredient [ num ingredients ] ; this . mirrored = mirrored ; int ingredient index = num ; for ( int y = num ; y < this . height ; y ++ ) { string format line = format lines [ y ] ; for ( int x = num ; x < format line . length ( ) ; x ++ ) { char c = format line . char at ( x ) ; if ( c == str ) { continue ; } this . posx [ ingredient index ] = x ; this . posy [ ingredient index ] = y ; this . ingredients [ ingredient index ] = ingredients [ c - str ] ; ingredient index ++ ; } } this . recipe function = recipe function ; this . last ingredient index on first line = get last ingredient index on first line ( ) ; }	defines an advanced crafting recipe , using a format string .
public void write tag ( string tag , font value ) { start tag ( tag ) ; write tag ( str , value . get name ( ) ) ; int style = value . get style ( ) ; if ( ( style & font . bold ) != num && ( style & font . italic ) != num ) { write tag ( style , str ) ; } else if ( ( style & font . bold ) != num ) { write tag ( style , str ) ; } else if ( ( style & font . italic ) != num ) { write tag ( style , str ) ; } else { write tag ( style , str ) ; } write tag ( str , value . get size ( ) ) ; close tag ( ) ; }	writes & lt ; tag & gt ; value & lt ; / tag & gt ; to output stream.
private void internal write ( byte [ ] b , int off , int len , boolean finish ) throws io { coder . output = embiggen ( coder . output , coder . max output size ( len ) ) ; if ( ! coder . process ( b , off , len , finish ) ) { throw new base64 data exception ( str ) ; } out . write ( coder . output , num , coder . op ) ; }	write the given bytes to the encoder / decoder .
private socket connect ( string host , string port string ) throws io { int port = num ; socket sock = null ; boolean debug = debug . debugging ( str ) ; try { port = integer . parse int ( port string , num ) ; } catch ( number format exception e ) { if ( debug ) debug . output ( str + host + str + port string ) ; throw new io ( str + port string ) ; } if ( debug ) debug . output ( str + host + str + port ) ; try { sock = new socket ( host , port ) ; } catch ( io e ) { if ( sock != null ) sock . close ( ) ; if ( debug ) { debug . output ( str + host + str + port + str + e ) ; } throw e ; } return sock ; }	a general connection method that returns a socket for a host and port .
@ override public boolean batch finished ( ) { if ( get input format ( ) == null ) { throw new illegal state exception ( str ) ; } instances to filter = get input format ( ) ; int cut off = ( int ) math . round ( to filter . num instances ( ) * m / num ) ; if ( m ) { for ( int i = num ; i < cut off ; i ++ ) { push ( to filter . instance ( i ) ) ; } } else { for ( int i = cut off ; i < to filter . num instances ( ) ; i ++ ) { push ( to filter . instance ( i ) ) ; } } flush input ( ) ; m = bool ; m = bool ; return ( num pending output ( ) != num ) ; }	signify that this batch of input to the filter is finished.
protected ok http client configure http client ( ) { final ok http client . builder builder = new ok http client . builder ( ) ; final cookie manager cookie manager = new cookie manager ( ) ; cookie manager . set cookie policy ( cookie policy . accept all ) ; builder . cookie jar ( new java net cookie jar ( cookie manager ) ) ; builder . connect timeout ( num , time unit . seconds ) ; builder . write timeout ( num , time unit . seconds ) ; builder . read timeout ( num , time unit . seconds ) ; return builder . build ( ) ; }	configures the http client .
public string parse file ( file file ) { log . config ( file . get absolute path ( ) ) ; string line = null ; try { buffered reader in = new buffered reader ( new input stream reader ( new file input stream ( file ) , ini . get charset ( ) ) , num ) ; string err msg = str ; int line no = num ; while ( ( line = in . read line ( ) ) != null && err msg . length ( ) == num ) { err msg = parse line ( line , line no ) ; line no ++ ; } line = null ; in . close ( ) ; if ( err msg . length ( ) != num ) return err msg ; } catch ( exception ioe ) { string s = ioe . get localized message ( ) ; if ( s == null || s . length ( ) == num ) s = ioe . to string ( ) ; return str + line + str + s ; } return str ; }	read and parse file.
public static test suite ( ) throws exception { return suite ( bool ) ; }	skip the dataset tests for now until we can figure out what is wrong with them.
public void load ( element element , object o ) { log . error ( str ) ; }	update static data from xml file.
public om ( double lt , double ln , int offset x1 , int offset y1 , image icon ii ) { this ( lt , ln , offset x1 , offset y1 , ii . get image ( ) ) ; }	create an omraster , lat / lon with x / y placement with an imageicon .
private synchronized boolean start dequeue ( ) { int threads = math . min ( queue . size ( ) , max threads ) ; for ( int i = num ; i < threads ; i ++ ) { resource thread t = ( resource thread ) queue . first element ( ) ; queue . remove element at ( num ) ; running . add element ( t ) ; thread count ++ ; } for ( enumeration e = running . elements ( ) ; e . has more elements ( ) ; ) { resource thread t = ( resource thread ) e . next element ( ) ; t . go ( ) ; } return ( threads > num ) ; }	starts dequeuing the queue into the running pool and launch them.
public void property change ( property change event evt ) { string name = evt . get property name ( ) ; if ( name == str || name == str ) { invalidate width cache ( ) ; fire column margin changed ( ) ; } }	property change listener change method.
public static void assert equals ( object object1 , object object2 ) { check assertion ( object1 . equals ( object2 ) , null ) ; }	asserts that given object1 equals object2 .
public static string flag names ( long flags ) { string builder sbuf = new string builder ( ) ; int i = num ; long f = flags & standard flags ; while ( f != num ) { if ( ( f & num ) != num ) { sbuf . append ( str ) ; sbuf . append ( flag name [ i ] ) ; } f = f > > num ; i ++ ; } return sbuf . to string ( ) ; }	return flags as a string , separated by " " .
public string format sql ( object obj , object expr ) { string sql = null ; if ( expr instanceof string ) { sql = ( string ) expr ; if ( log . is loggable ( level . finest ) ) { log . finest ( str + sql ) ; } } else if ( obj != null ) { sql = to string ( obj ) ; if ( sql != null ) { if ( sql . starts with ( str ) ) { sql = sql . replace first ( str , str ) ; } sql = sql . replace all ( str , binary sql marker ) ; } if ( log . is loggable ( level . finest ) ) { log . finest ( str + sql ) ; } } return sql ; }	this method attempts to return a sql statement.
public void indent ( ) { indent . append ( str ) ; }	indent text by two spaces.
public void add fake view ( view child view ) { child view . layout ( num , num , get width ( ) , child view . get measured height ( ) ) ; views . add ( child view ) ; }	add a view for the dummyview to draw .
public void compile projects ( list < file > projects , issue acceptor issue acceptor ) throws js { compile projects ( arrays . as list ( new file ( str ) ) , projects , collections . empty list ( ) , issue acceptor ) ; }	compile a list of projects .
protected final void print contact info ( object info panel p window , java . util . locale p locale ) { collection < brd item > contacts = get normal contacts ( ) ; if ( contacts . is empty ( ) ) return ; gui resources resources = r board . new gui resources ( str ) ; p window . append ( str + resources . get string ( str ) + str ) ; integer contact count = contacts . size ( ) ; p window . append items ( contact count . to string ( ) , resources . get string ( str ) , contacts ) ; }	internal function used in the implementation of print_info.
@ suppress warnings ( str ) public promise < result , progress > resolve ( result result ) { list < done callback < result > > done callbacks ; list < always callback > always callbacks ; synchronized ( this ) { validate in pending state ( ) ; m state = state resolved ; print state changed ( str ) ; m result = result ; done callbacks = m callbacks . clone done callbacks ( ) ; always callbacks = m callbacks . clone always callbacks ( ) ; clear callbacks ( ) ; } if ( done callbacks . size ( ) > num || always callbacks . size ( ) > num ) { trigger all dones ( done callbacks ) ; trigger all always ( always callbacks ) ; } return this ; }	resolves the promise , triggers any done / always callbacks.
private void adjust name and position ( node node , int delta x , int delta y ) { string original name = node . get name ( ) ; string unique name = next unique name ( original name ) ; if ( ! unique name . equals ( original name ) ) { node . set name ( unique name ) ; node . set center x ( node . get center x ( ) + delta x ) ; node . set center y ( node . get center y ( ) + delta y ) ; } }	adjusts the name to avoid name conflicts in the new session and , if the name is adjusted , adjusts the position so the user can see the two nodes .
private void create snapshot ( block snapshot snapshot , snap unity snap , storage system storage , db client db client ) { snapshot . set native id ( unity snap . get id ( ) ) ; snapshot . set native guid ( guid . generate native guid ( storage , snapshot ) ) ; snapshot . set device label ( unity snap . get name ( ) ) ; snapshot . set is sync active ( bool ) ; snapshot . set inactive ( bool ) ; snapshot . set creation time ( calendar . get instance ( ) ) ; snapshot . set wwn ( unity snap . get attached wwn ( ) ) ; snapshot . set allocated capacity ( unity snap . get size ( ) ) ; snapshot . set provisioned capacity ( unity snap . get size ( ) ) ; db client . create object ( snapshot ) ; }	create the blocksnapshot in db.
public void save ( ) throws io { if ( ! props . is empty ( ) ) { configuration util . save configuration properties ( props , props file , bool ) ; } configuration util . save configuration properties ( props , new file ( props file . get parent file ( ) , props file . get name ( ) + str ) , bool ) ; }	saves the currently known settings .
public static int len ( string list , string delimiter , boolean ignore empty ) { if ( delimiter . length ( ) == num ) return len ( list , delimiter . char at ( num ) , ignore empty ) ; char [ ] del = delimiter . to char array ( ) ; int len = string util . length ( list ) ; if ( len == num ) return num ; int count = num ; int last = num ; char c ; for ( int i = num ; i < len ; i ++ ) { c = list . char at ( i ) ; for ( int y = num ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignore empty || last < i ) count ++ ; last = i + num ; break ; } } } if ( ! ignore empty || last < len ) count ++ ; return count ; }	returns count of items in the list.
public string build uri ( string representation id , int segment number , int bandwidth , long time ) { string builder builder = new string builder ( ) ; for ( int i = num ; i < identifier count ; i ++ ) { builder . append ( url pieces [ i ] ) ; if ( identifiers [ i ] == representation id ) { builder . append ( representation id ) ; } else if ( identifiers [ i ] == number id ) { builder . append ( string . format ( locale . us , identifier format tags [ i ] , segment number ) ) ; } else if ( identifiers [ i ] == bandwidth id ) { builder . append ( string . format ( locale . us , identifier format tags [ i ] , bandwidth ) ) ; } else if ( identifiers [ i ] == time id ) { builder . append ( string . format ( locale . us , identifier format tags [ i ] , time ) ) ; } } builder . append ( url pieces [ identifier count ] ) ; return builder . to string ( ) ; }	constructs a uri from the template , substituting in the provided arguments.
static void dispose ( long p data , long p config info ) { ogl rq = ogl . get instance ( ) ; rq . lock ( ) ; try { ogl . set scratch surface ( p config info ) ; render buffer buf = rq . get buffer ( ) ; rq . ensure capacity and alignment ( num , num ) ; buf . put int ( dispose surface ) ; buf . put long ( p data ) ; rq . flush now ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native resources associated with the given oglsurfacedata ( referenced by the pdata parameter ).
private void write kanji resource file ( file file ) throws io { file output stream output = null ; kanji escape output stream kanji = null ; output stream writer writer = null ; buffered writer w = null ; try { output = new file output stream ( file ) ; kanji = new kanji escape output stream ( output ) ; writer = new output stream writer ( kanji ) ; w = new buffered writer ( writer ) ; w . write ( sb . to string ( ) ) ; } finally { util . close ( w ) ; util . close ( writer ) ; util . close ( kanji ) ; util . close ( output ) ; } }	handle japanese encoding - by toshimm .
public scanner exception ( file file , error messages message ) { this ( file , error messages . get ( message ) , message , - num , - num ) ; }	creates a new scannerexception for a file with a message only .
void render normal ( ) { gl enable ( gl depth test ) ; gl use program ( this . normal program ) ; gl uniform matrix4fv ( view matrix uniform , bool , view matrix . get ( matrix buffer ) ) ; gl uniform matrix4fv ( proj matrix uniform , bool , proj matrix . get ( matrix buffer ) ) ; gl uniform matrix3fv ( normal matrix uniform , bool , normal matrix . get ( matrix buffer ) ) ; gl bind framebuffer ext ( gl framebuffer ext , fbo ) ; gl clear ( gl color buffer bit | gl depth buffer bit ) ; gl bind buffer ( gl array buffer , this . cube vbo ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num , num ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num , normals offset ) ; gl draw arrays ( gl triangles , num , num vertices ) ; gl disable vertex attrib array ( num ) ; gl disable vertex attrib array ( num ) ; gl bind buffer ( gl array buffer , num ) ; gl bind framebuffer ext ( gl framebuffer ext , num ) ; gl use program ( num ) ; }	render the normals into a texture .
private < t extends cwl > list < t > look for resources ( cwl type , class < t > clazz ) { list < t > resources = get requirements ( type , clazz ) ; if ( resources == null || resources . size ( ) == num ) { resources = get hints ( type , clazz ) ; } return resources ; }	find all resources by type.
private void calc y ( ) { m y = num ; for ( int i = num ; i < m y . size ( ) ; i ++ ) { entry e = m y . get ( i ) ; if ( e != null ) m y += math . abs ( e . get val ( ) ) ; } }	calculates the sum of all y - values.
@ override public boolean release ( int decrement ) { if ( is empty ) { return bool ; } if ( decrement < num ) { throw new illegal state exception ( string . format ( str , decrement , to verbose string ( ) ) ) ; } final int ref cnt = ledger . decrement ( decrement ) ; if ( base allocator . debug ) { historical log . record event ( str , decrement , ref cnt + decrement ) ; } if ( ref cnt < num ) { throw new illegal state exception ( string . format ( str , id , to verbose string ( ) ) ) ; } return ref cnt == num ; }	release the provided number of reference counts .
int list size ( ) { int result = mem size ( ) ; for ( iterator it = iterator ( ) ; it . has next ( ) ; ) { ast child = ( ast ) it . next ( ) ; result += child . tree size ( ) ; } return result ; }	returns an estimate of the memory footprint in bytes of this node list and all its subtrees .
public connection tcp find connection by thread id ( long thread id ) { for ( port tcp listener : get ports ( ) ) { connection tcp conn = listener . find connection by thread id ( thread id ) ; if ( conn != null ) return conn ; } return null ; }	finds the tcpconnection given the threadid.
public uniform distribution estimate ( double min , double max , final int count ) { double grow = ( count > num ) ? num * ( max - min ) / ( count - num ) : num ; return new uniform distribution ( math . max ( min - grow , - double . max value ) , math . min ( max + grow , double . max value ) ) ; }	estimate from simple characteristics .
public static repository meta data read from ( stream input in ) throws io { string name = in . read string ( ) ; string type = in . read string ( ) ; settings settings = settings . read settings from stream ( in ) ; return new repository meta data ( name , type , settings ) ; }	reads repository metadata from stream input.
public static boolean is primitive datatype ( iri datatype ) { return datatype . equals ( xml . duration ) || datatype . equals ( xml . datetime ) || datatype . equals ( xml . time ) || datatype . equals ( xml . date ) || datatype . equals ( xml . gyearmonth ) || datatype . equals ( xml . gyear ) || datatype . equals ( xml . gmonthday ) || datatype . equals ( xml . gday ) || datatype . equals ( xml . gmonth ) || datatype . equals ( xml . string ) || datatype . equals ( xml . boolean ) || datatype . equals ( xml . bas binary ) || datatype . equals ( xml . hexbinary ) || datatype . equals ( xml . float ) || datatype . equals ( xml . decimal ) || datatype . equals ( xml . double ) || datatype . equals ( xml . anyuri ) || datatype . equals ( xml . qname ) || datatype . equals ( xml . notation ) ; }	checks whether the supplied datatype is a primitive xml schema datatype .
protected void append line ( j c ) { c . set alignment x ( num ) ; contents . add ( c ) ; }	handle gui layout details during construction .
public void post process ( ) { if ( foreign column name != null ) { foreign auto refresh = bool ; } if ( foreign auto refresh && max foreign auto refresh level == database field . no max foreign auto refresh level specified ) { max foreign auto refresh level = database field . default max foreign auto refresh level ; } }	process the settings when we are going to consume them .
public boolean contains ( node s ) { run to ( - num ) ; if ( null == m map ) return bool ; for ( int i = num ; i < m first free ; i ++ ) { node node = m map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return bool ; } return bool ; }	tell if the table contains the given node .
private void persist new temp ( file file cfg ) { if ( hs delete on exit . size ( ) == num ) { log debug ( log area . config , str ) ; file cfg . delete ( ) ; return ; } log debug ( log area . config , str , hs delete on exit . size ( ) , file cfg . get absolute path ( ) ) ; buffered writer writer = null ; try { writer = new buffered writer ( new file writer ( file cfg ) ) ; for ( file file : hs delete on exit ) { if ( ! file . delete ( ) ) { string f = file . get canonical path ( ) ; writer . write ( f ) ; writer . new line ( ) ; log warn ( log area . jar , str , f ) ; } } } catch ( io e ) { } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( io e ) { } } } }	creates file with temporary files list.
public void add written ( byte [ ] value ) { write set lock . lock ( ) ; write set . add ( new timestamp value pair ( ets , value ) ) ; write set lock . unlock ( ) ; }	add a value that shall be written to the writeset.
public void load ( entity unit ) throws illegal argument exception { if ( ! can load ( unit ) ) { throw new illegal argument exception ( str + unit . get short name ( ) + str ) ; } current space -= num ; troops . add element ( unit . get id ( ) ) ; }	load the given unit .
private void process worker exit ( worker w , boolean completed abruptly ) { if ( completed abruptly ) decrement worker count ( ) ; final reentrant lock main lock = this . main lock ; main lock . lock ( ) ; try { completed task count += w . completed tasks ; workers . remove ( w ) ; } finally { main lock . unlock ( ) ; } try terminate ( ) ; int c = ctl . get ( ) ; if ( run state less than ( c , stop ) ) { if ( ! completed abruptly ) { int min = allow core thread time out ? num : core pool size ; if ( min == num && ! work queue . is empty ( ) ) min = num ; if ( worker count of ( c ) >= min ) return ; } add worker ( null , bool ) ; } }	performs cleanup and bookkeeping for a dying worker.
public void finish ( ) throws io { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , num , buf . length ) ; if ( def . finished ( ) && len <= buf . length - trailer size ) { write trailer ( buf , len ) ; len = len + trailer size ; out . write ( buf , num , len ) ; return ; } if ( len > num ) out . write ( buf , num , len ) ; } byte [ ] trailer = new byte [ trailer size ] ; write trailer ( trailer , num ) ; out . write ( trailer ) ; } }	finishes writing compressed data to the output stream without closing the underlying stream.
public boolean free ( t obj ) { atomic integer top ref = top ; while ( bool ) { final int top = top ref . get ( ) ; if ( capacity <= top ) { return bool ; } boolean is free = free stack . compare and set ( top , null , obj ) ; top ref . compare and set ( top , top + num ) ; if ( is free ) { return bool ; } } }	frees the object . if the free list is full , the object will be garbage collected .
public static boolean has binding ( injector injector , key < ? > key ) { binding < ? > binding = get binding ( injector , key ) ; return binding != null ; }	returns true if a binding exists for the given key.
private m create internal service ( string service name ) throws replicator exception { logger . info ( str + service name ) ; try { open replicator manager orm = new open replicator manager ( service name ) ; orm . set rmi host ( manager rmi ) ; orm . set rmi port ( manager rmi ) ; orm . set host time zone ( host time zone ) ; orm . set replicator time zone ( replicator time zone ) ; orm . advertise internal ( ) ; orm . set security info ( this . security info ) ; return ( m ) orm ; } catch ( exception e ) { throw new replicator exception ( string . format ( str , service name ) , e ) ; } }	creates a replication service that will run as a thread internal to the replicationservicemanager .
public static check index . status check index ( directory dir ) throws io { return check index ( dir , bool ) ; }	this runs the checkindex tool on the index in.
public tagged output stream ( output stream proxy ) { super ( proxy ) ; }	creates a tagging decorator for the given output stream .
public list < m > build ( ) { is clean = bool ; if ( ! is messages list mutable && builders == null ) { return messages ; } boolean all messages in sync = bool ; if ( ! is messages list mutable ) { for ( int i = num ; i < messages . size ( ) ; i ++ ) { message message = messages . get ( i ) ; single field builder < m , b , i > builder = builders . get ( i ) ; if ( builder != null ) { if ( builder . build ( ) != message ) { all messages in sync = bool ; break ; } } } if ( all messages in sync ) { return messages ; } } ensure mutable message list ( ) ; for ( int i = num ; i < messages . size ( ) ; i ++ ) { messages . set ( i , get message ( i , bool ) ) ; } messages = collections . unmodifiable list ( messages ) ; is messages list mutable = bool ; return messages ; }	builds the list of messages from the builder and returns them .
public static void put short ( long addr , short val ) { if ( unaligned ) unsafe . put short ( addr , val ) ; else put short by byte ( addr , val , big endian ) ; }	stores given short value.
public static byte [ ] hash twice ( byte [ ] input , int offset , int length ) { message digest digest = new digest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( digest . digest ( ) ) ; }	calculates the sha - 256 hash of the given byte range , and then hashes the resulting hash again .
public fsm ( url url , boolean scan from front ) throws io { this . scan from front = scan from front ; input stream is = utilities . get input stream ( url ) ; load text ( is ) ; is . close ( ) ; }	constructs a pronounceablefsm with information in the given url .
public object put ( string key , object value ) { final int len = key . length ( ) ; if ( len > m char buffer . length ) { m char buffer = new char [ len ] ; } node node = m ; for ( int i = num ; i < len ; i ++ ) { node next node = node . m next char [ character . to lower case ( key . char at ( i ) ) ] ; if ( next node != null ) { node = next node ; } else { for ( ; i < len ; i ++ ) { node new node = new node ( ) ; if ( m lower case only ) { node . m next char [ character . to lower case ( key . char at ( i ) ) ] = new node ; } else { node . m next char [ character . to upper case ( key . char at ( i ) ) ] = new node ; node . m next char [ character . to lower case ( key . char at ( i ) ) ] = new node ; } node = new node ; } break ; } } object ret = node . m ; node . m = value ; return ret ; }	put an object into the trie for lookup .
@ override public void make immutable ( ) { if ( is mutable ) { if ( authn statements != null ) { int length = authn statements . size ( ) ; for ( int i = num ; i < length ; i ++ ) { authn statement authn = ( authn statement ) authn statements . get ( i ) ; authn . make immutable ( ) ; } authn statements = collections . unmodifiable list ( authn statements ) ; } if ( authz decision statements != null ) { int length = authz decision statements . size ( ) ; for ( int i = num ; i < length ; i ++ ) { authz decision statement authz = ( authz decision statement ) authz decision statements . get ( i ) ; authz . make immutable ( ) ; } authz decision statements = collections . unmodifiable list ( authz decision statements ) ; } if ( attribute statements != null ) { int length = attribute statements . size ( ) ; for ( int i = num ; i < length ; i ++ ) { attribute statement attr = ( attribute statement ) attribute statements . get ( i ) ; attr . make immutable ( ) ; } attribute statements = collections . unmodifiable list ( attribute statements ) ; } if ( statements != null ) { statements = collections . unmodifiable list ( statements ) ; } if ( conditions != null ) { conditions . make immutable ( ) ; } if ( issuer != null ) { issuer . make immutable ( ) ; } if ( subject != null ) { subject . make immutable ( ) ; } if ( advice != null ) { advice . make immutable ( ) ; } is mutable = bool ; } }	makes the object immutable.
@ override public string find library ( string name ) { string system name = system . map library name ( name ) ; array list < loader > loaders = get loaders ( ) ; for ( int i = num ; i < loaders . size ( ) ; i ++ ) { loader loader = loaders . get ( i ) ; path path = loader . get path ( system name ) ; if ( path != null && path . can read ( ) ) { return path . get native path ( ) ; } path = loader . get path ( str + system name ) ; if ( path != null && path . can read ( ) ) { return path . get native path ( ) ; } } for ( int i = num ; i < native path . size ( ) ; i ++ ) { path path = native path . get ( i ) ; if ( path . can read ( ) ) return path . get native path ( ) ; } return super . find library ( name ) ; }	returns the full library path for the name .
public void remove component listener ( final component update listener listener ) { component listeners . remove ( listener ) ; }	removes a component listener from this instance .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return appkey ; case num : return send time ; case num : return load info ; case num : return status ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static boolean is empty ( char sequence text ) { return text == null || text . length ( ) == num ; }	returns true if the string is null or 0 - length .
protected byte [ ] assert encode decode ( final i decl , final i expected ) { if ( expected == null ) throw new illegal argument exception ( ) ; final xdr xdr = new xdr ( i . buffer size ) ; final ganglia message encoder31 message encoder = new ganglia message encoder31 ( ) ; final ganglia message decoder31 message decoder = new ganglia message decoder31 ( ) ; if ( expected . is metric request ( ) ) { message encoder . write request ( xdr , ( i ) expected ) ; } else if ( expected . is metric metadata ( ) ) { message encoder . write metadata ( xdr , ( i ) expected ) ; } else if ( expected . is metric value ( ) ) { if ( decl == null ) throw new illegal argument exception ( str ) ; message encoder . write metric ( xdr , decl , ( i ) expected ) ; } else { throw new assertion error ( ) ; } final i actual = message decoder . decode ( xdr . get buffer ( ) , num , xdr . get length ( ) ) ; assert equals ( str , expected , actual ) ; final byte [ ] actual data = new byte [ xdr . get length ( ) ] ; system . arraycopy ( xdr . get buffer ( ) , num , actual data , num , actual data . length ) ; return actual data ; }	verify that we can encode and decode a record .
private boolean is indexable ( string term ) { return ( term . length ( ) < num ) && ( term . length ( ) > num ) ; }	checks a term if it can be processed indexed .
private void send response ( string status , string mime , properties header , input stream data ) { try { if ( status == null ) throw new error ( str ) ; output stream out = my socket . get output stream ( ) ; print writer pw = new print writer ( out ) ; pw . print ( str + status + str ) ; if ( mime != null ) pw . print ( str + mime + str ) ; if ( header == null || header . get property ( str ) == null ) pw . print ( str + gmt frmt . format ( new date ( ) ) + str ) ; if ( header != null ) { enumeration e = header . keys ( ) ; while ( e . has more elements ( ) ) { string key = ( string ) e . next element ( ) ; string value = header . get property ( key ) ; pw . print ( key + str + value + str ) ; } } pw . print ( str ) ; pw . flush ( ) ; if ( data != null ) { byte [ ] buff = new byte [ num ] ; while ( bool ) { int read = data . read ( buff , num , num ) ; if ( read <= num ) break ; out . write ( buff , num , read ) ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( io ioe ) { try { my socket . close ( ) ; } catch ( throwable t ) { } } }	sends given response to the socket .
public static string decode ( string encoded , am encr ) { if ( check caller ( ) ) { try { is isp = new is ( str , str ) ; if ( security manager != null ) { security manager . check permission ( isp ) ; } } catch ( security exception e ) { debug debug = debug . get instance ( str ) ; debug . error ( str + str , e ) ; return null ; } } if ( encoded == null || encoded . length ( ) == num ) { return ( null ) ; } byte [ ] enc data = null ; enc data = base64 . decode ( encoded . trim ( ) ) ; if ( enc data == null ) { return null ; } byte [ ] raw data = encr . decrypt ( enc data ) ; if ( raw data == null ) { return ( null ) ; } string answer = null ; try { answer = new string ( raw data , str ) ; } catch ( unsupported encoding exception uue ) { debug debug = debug . get instance ( str ) ; debug . error ( str , uue ) ; answer = new string ( raw data ) ; } return ( answer ) ; }	decode an encoded string.
protected void wait for shutdown signal ( ) throws interrupted exception { if ( mutex waiting == null ) mutex waiting = new object ( ) ; try { synchronized ( mutex waiting ) { mutex waiting . wait ( ) ; } } catch ( interrupted exception e ) { if ( ! shutdown ) throw e ; } }	causes the current thread to block until signalshutdown is called.
public void add connection ( connection connection ) { if ( connection == null ) throw new illegal argument exception ( str ) ; synchronized ( connections lock ) { connection [ ] new connections = new connection [ connections . length + num ] ; new connections [ num ] = connection ; system . arraycopy ( connections , num , new connections , num , connections . length ) ; connections = new connections ; } connection . add listener ( invoke listener ) ; if ( trace ) trace ( str , str + connection ) ; }	allows the remote end of the specified connection to access objects registered in this objectspace .
public double distance ( d pt ) { final double x distance = ( pt . get x ( ) - x ) * ( pt . get x ( ) - x ) ; final double y distance = ( pt . get y ( ) - y ) * ( pt . get y ( ) - y ) ; return math . sqrt ( x distance + y distance ) ; }	returns the euclidean distance between a specified point and this point .
private static int convert to int ( string value , int default value ) { string trim = value . trim ( ) ; if ( trim . length ( ) == num ) { return default value ; } return integer . parse int ( trim ) ; }	convert a string to an int treating empty strings as the default value .
public chain iterable < t > add item ( @ not null t item ) { return ( chain iterable < t > ) super . add ( collections . < t > singleton ( item ) ) ; }	convenience : add an item wrapping it into a singleiterable behind the scenes .
private void update state view ( int it count , collection < individual < double > > gen ) { platform . run later ( null ) ; sim pane ctrl . wait after step ( ) ; }	caution : while the background thread should be slowed down , updates of the gui have to be done in the gui thread !.
@ override public void run ( ) { try { for ( ; ; ) { int n = port getn ( port , buffer address , max event count ) ; assert n > num ; long address = buffer address ; for ( int i = num ; i < n ; i ++ ) { boolean shutdown = process event ( address ) ; if ( shutdown ) return ; address += sizeof port event ; } } } catch ( unix exception x ) { x . print stack trace ( ) ; } }	poller main loop . blocks on port_getn waiting for events and then processes them .
@ override public list < string > all keys ( ) { list < string > name files = new array list < > ( ) ; file [ ] files = cache directory . list files ( ) ; if ( files == null ) return name files ; for ( file file : files ) { if ( file . is file ( ) ) { name files . add ( file . get name ( ) ) ; } } return name files ; }	retrieve the names from all files in dir.
public dialogue recorder ( dialogue system system ) { this . settings = system . get settings ( ) ; }	creates a new dialogue recorder for the dialogue system.
private string generate unique future id ( ) { return string . value of ( m id counter . get and increment ( ) ) ; }	generates unique id for requestfuture .
private static final void reschedule missed alarms ( content resolver cr , context context , alarm manager interface manager ) { long now = system . current time millis ( ) ; long ancient = now - date utils . day in millis ; string [ ] projection = new string [ ] { calendar contract . calendar alerts . alarm time } ; if ( build . version . sdk int >= num && context compat . check self permission ( context , manifest . permission . read calendar ) != package manager . permission granted ) { log . d ( tag , str ) ; return ; } cursor cursor = cr . query ( calendar alerts . content uri , projection , where reschedule missed alarms , ( new string [ ] { long . to string ( now ) , long . to string ( ancient ) , long . to string ( now ) } ) , sort order alarmtime asc ) ; if ( cursor == null ) { return ; } if ( debug ) { log . d ( tag , str + cursor . get count ( ) ) ; } try { long alarm time = - num ; while ( cursor . move to next ( ) ) { long new alarm time = cursor . get long ( num ) ; if ( alarm time != new alarm time ) { if ( debug ) { log . w ( tag , str + new alarm time ) ; } alert utils . schedule alarm ( context , manager , new alarm time ) ; alarm time = new alarm time ; } } } finally { cursor . close ( ) ; } }	searches the calendaralerts table for alarms that should have fired but have not and then reschedules them.
public void add name ( string name ) { m names . add ( name ) ; }	add a column name to this projection .
@ override default completable future < optional double > min double ( final to double function < ? super t > fn ) { return completable future . supply async ( null , get exec ( ) ) ; }	perform an asynchronous min operation.
private boolean to state ( lifecycle state new state ) { lifecycle state state ; synchronized ( this ) { state = state ; state = new state ; last change time = current time . current time ( ) ; } if ( log != null && log . is loggable ( low level ) ) { log . log ( low level , new state + str + name ) ; } notify listeners ( state , new state ) ; return bool ; }	changes to the next state .
@ override protected string date to string ( date time data date ) { string buffer message = new string buffer ( num ) ; message . append ( str ) ; message . append ( str ) ; append ( message , date . month , num ) ; append ( message , ( char ) date . utc , num ) ; return message . to string ( ) ; }	converts month object representation to string.
private void add test ( test new test ) { if ( m == null ) { m = new array list < test > ( ) ; } m . add ( new test ) ; }	adds the given test to the list.
public void swap ( int i , int j ) { x . assert true ( i < list . size ( ) ) ; x . assert true ( j < list . size ( ) ) ; list . set ( i , list . set ( j , list . get ( i ) ) ) ; }	swaps in place the elements at the specified positions in the specified list.
private list < name value pair > build ipt ( ipt ipt , string organisation key ) { list < name value pair > data = new array list < name value pair > ( ) ; if ( ipt != null && organisation key != null ) { data . add ( new basic name value pair ( str , string utils . trim to empty ( organisation key ) ) ) ; data . add ( new basic name value pair ( str , string utils . trim to empty ( ipt . get name ( ) ) ) ) ; data . add ( new basic name value pair ( str , string utils . trim to empty ( ipt . get description ( ) ) ) ) ; data . add ( new basic name value pair ( str , string utils . trim to empty ( ipt . get primary contact type ( ) ) ) ) ; data . add ( new basic name value pair ( str , string utils . trim to empty ( ipt . get primary contact name ( ) ) ) ) ; data . add ( new basic name value pair ( str , string utils . trim to empty ( ipt . get primary contact email ( ) ) ) ) ; data . add ( new basic name value pair ( str , service type rss ) ) ; data . add ( new basic name value pair ( str , get rss feed url ( ) ) ) ; } else { log . debug ( str ) ; } return data ; }	populate a list of name value pairs used in the common ws requests for ipt registrations and updates .
public static < t , u extends closeable > t with closeable ( u self , @ closure params ( value = first param . class ) closure < t > action ) throws io { try { t result = action . call ( self ) ; closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { default groovy methods support . close with warning ( self ) ; } }	allows this closeable to be used within the closure , ensuring that it is closed once the closure has been executed and before this method returns .
public static boolean is match ( string actual string , linked list patterns , char wild card ) { boolean matched = bool ; for ( list iterator iter = patterns . list iterator ( num ) ; iter . has next ( ) ; ) { if ( is match ( actual string , ( string ) iter . next ( ) , wild card ) ) { matched = bool ; break ; } } return matched ; }	check whether the string matches the pattern .
public synchronized void add server ( server location location , string [ ] groups , server load initial load , long load poll interval ) { server group map . put ( location , groups ) ; load holder connection load = new load holder ( location , initial load . get connection load ( ) , initial load . get load per connection ( ) , load poll interval ) ; add groups ( connection load map , groups , connection load ) ; load holder queue load = new load holder ( location , initial load . get subscription connection load ( ) , initial load . get load per subscription connection ( ) , load poll interval ) ; add groups ( queue load map , groups , queue load ) ; update load ( location , initial load ) ; }	add a new server to the load snapshot .
public void add leaf ( catalog tree leaf leaf ) { leaves . add ( leaf ) ; }	append leaf to the end of the leaves list.
private static string stamp to string ( long tstamp , string format mask ) { string builder sb = new string builder ( num ) ; formatter fmt = new formatter ( sb , locale . us ) ; int [ ] pieces = new int [ numidx ] ; component time . unpack bits ( tstamp , pieces ) ; fmt . format ( format mask , pieces [ yidx ] , pieces [ midx ] , pieces [ didx ] , pieces [ hidx ] , pieces [ iidx ] , pieces [ sidx ] , pieces [ uidx ] ) ; fmt . close ( ) ; return ( sb . to string ( ) ) ; }	convenience method for converting component time longs to strings.
public http request content length ( final string value ) { return content length ( integer . parse int ( value ) ) ; }	set the ' content - length ' request header to the given value.
public boolean draw ( canvas canvas ) { update ( ) ; final float center x = m bounds . center x ( ) ; final float center y = m bounds . height ( ) - m radius ; canvas . scale ( num , math . min ( m glow scale y , num ) * m base glow scale , center x , num ) ; final float displacement = math . max ( num , math . min ( m displacement , num ) ) - num ; float translate x = m bounds . width ( ) * displacement / num ; m paint . set alpha ( ( int ) ( num * m glow alpha ) ) ; canvas . draw circle ( center x + translate x , center y , m radius , m paint ) ; boolean one last frame = bool ; if ( m state == state recede && m glow scale y == num ) { m state = state idle ; one last frame = bool ; } return m state != state idle || one last frame ; }	draw into the provided canvas.
public vn modify lun async ( lun modify param param , string resource id ) { string builder url bld = new string builder ( url resource ) ; url bld . append ( resource id ) ; url bld . append ( url lun modify action ) ; url = url bld . to string ( ) ; return post request async ( param ) ; }	modify lun ( export / unexport / expand etc ) in async mode.
public string replace ( char sequence target , char sequence replacement ) { if ( target == null ) { throw new null pointer exception ( str ) ; } if ( replacement == null ) { throw new null pointer exception ( str ) ; } string ts = target . to string ( ) ; int index = index of ( ts , num ) ; if ( index == - num ) return this ; string rs = replacement . to string ( ) ; string builder buffer = new string builder ( count ) ; int tl = target . length ( ) ; int tail = num ; do { buffer . append ( value , offset + tail , index - tail ) ; buffer . append ( rs ) ; tail = index + tl ; } while ( ( index = index of ( ts , tail ) ) != - num ) ; buffer . append ( value , offset + tail , count - tail ) ; return buffer . to string ( ) ; }	copies this string replacing occurrences of the specified target sequence with another sequence.
public void delete ( ) throws io { close ( ) ; delete contents ( directory ) ; }	closes the cache and deletes all of its stored values.
public boolean similar to ( object o ) { if ( o == null ) { return bool ; } if ( ! ( o instanceof semantic concept ) ) { return bool ; } semantic concept other concept = ( semantic concept ) o ; hash set < integer > synset intersection = new hash set < integer > ( this . synsets ) ; synset intersection . retain all ( other concept . synsets ) ; if ( ! synset intersection . is empty ( ) ) { return bool ; } hash set < string > concept intersection = new hash set < string > ( this . concepts ) ; concept intersection . retain all ( other concept . concepts ) ; return ! concept intersection . is empty ( ) ; }	semanticconcepts are similar if they share a synset or a concept.
public void j google analytics tracker ( final string event type , final string version , final string tracker id ) { final j tracker = new j ( str , version , tracker id ) ; final focus point focus point = new focus point ( event type . to lower case ( ) ) ; tracker . track asynchronously ( focus point ) ; }	google analytics usage tracking.
protected final tuple add internal ( tuple t ) { if ( m tuples . add ( t ) ) { return t ; } else { return null ; } }	adds a tuple without firing a notification .
public void put ( song song ) { if ( ! m songs . contains ( song ) ) { m songs . add ( song ) ; } }	adds a song to the adapter.
@ not null public psi query children named ( @ not null final class < ? extends psi named element > clazz , @ not null final string name ) { final list < psi element > result = new array list < psi element > ( ) ; for ( final psi element element : my psi elements ) { for ( final psi named element child : psi tree util . find children of type ( element , clazz ) ) { if ( name . equals ( child . get name ( ) ) ) { result . add ( child ) ; } } } return new psi query ( result . to array ( new psi element [ result . size ( ) ] ) ) ; }	filter children by name and class.
private void emit map put ( method method , string field name , string builder builder ) { builder . append ( str ) ; builder . append ( get map putter name ( field name ) ) ; builder . append ( str ) ; builder . append ( get type argument impl name ( ( parameterized type ) method . get generic return type ( ) , num ) ) ; builder . append ( str ) ; builder . append ( get ensure name ( field name ) ) ; builder . append ( str ) ; builder . append ( field name ) ; builder . append ( str ) ; builder . append ( str ) ; }	emits a put method to put a value into a map.
@ override public boolean equals ( object o ) { return o . hash code ( ) == hash code ( ) ; }	returns true if the object is a complex effect with an identical content.
@ override public string to string ( ) { if ( get user object ( ) instanceof tv show ) { tv show tv show = ( tv show ) get user object ( ) ; return tv show . get title ( ) ; } return super . to string ( ) ; }	provides the right name of the node for display .
private array list < string > parse json ( string text ) { text = text . substring ( text . index of ( str ) + size of events , text . index of ( str ) ) ; array list < string > events = new array list < string > ( ) ; if ( text . is empty ( ) ) { return events ; } int start index = num , end index = num ; while ( end index != - num ) { end index = text . index of ( str , start index + delimiter size ) ; string event text = ( end index == - num ? text . substring ( start index ) : text . substring ( start index , end index ) ) ; pattern pattern = pattern . compile ( str ) ; matcher matcher = pattern . matcher ( event text ) ; event text = matcher . replace all ( str ) ; pattern = pattern . compile ( str ) ; matcher = pattern . matcher ( event text ) ; if ( matcher . find ( ) ) { event text = matcher . replace first ( matcher . group ( num ) + str ) ; } event text = str + event text ; start index = end index + num ; events . add ( event text ) ; } collections . reverse ( events ) ; return events ; }	parse json - formatted list of events / births / deaths from wikipedia , extract list of events and split the events into a string array of individual events.
@ override public void remove table model listener ( table model listener l ) { m . remove ( l ) ; }	removes a listener from the list that is notified each time a change to the data model occurs.
public str builder replace ( int start index , int end index , string replace str ) { end index = validate range ( start index , end index ) ; int insert len = ( replace str == null ? num : replace str . length ( ) ) ; replace impl ( start index , end index , end index - start index , replace str , insert len ) ; return this ; }	replaces a portion of the string builder with another string.
public static void add permission recursive ( path path , posix file permission permission ) throws io { change permissions recursive ( path , permission change . add , collections . singleton ( permission ) ) ; }	recursively adds a permission to a directory .
private void run timeout task ( ) { while ( is active ( ) ) { reap timeouts ( ) ; try { thread . sleep ( timeout reap interval ) ; } catch ( exception e ) { } } }	running process accepting connections .
public i learn entity ( long mac address , short vlan , integer ipv4 address , long switch dpid , integer switch port , boolean process updates ) { list < i > listeners = device listeners . get ordered listeners ( ) ; if ( ! process updates ) { device listeners . clear listeners ( ) ; } vlan vid v ; i i ; datapath id d ; of p ; if ( vlan != null && vlan . short value ( ) <= num ) vlan = null ; if ( ipv4 address != null && ipv4 address == num ) ipv4 address = null ; if ( vlan == null ) { v = vlan vid . of vlan ( - num ) ; } else { v = vlan vid . of vlan ( vlan ) ; } if ( ipv4 address == null ) { i = i . none ; } else { i = i . of ( ipv4 address ) ; } if ( switch dpid == null ) { d = datapath id . of ( num ) ; } else { d = datapath id . of ( switch dpid . long value ( ) ) ; } if ( switch port == null ) { p = of . zero ; } else { p = of . of ( switch port ) ; } i res = learn device by entity ( new entity ( mac address . of ( mac address ) , v , i , d , p , new date ( ) ) ) ; if ( listeners != null ) { for ( i listener : listeners ) { device listeners . add listener ( str , listener ) ; } } return res ; }	learn a device using the given characteristics .
public static boolean is valid type signature ( string sig , boolean allow void ) { int len = sig . length ( ) ; return check type signature ( sig , num , len , allow void ) == len ; }	returns true if the given type signature is valid , false if it is not .
public void test case19 ( ) { byte a bytes [ ] = { - num , num , num , num , num , - num , num , - num , num , num } ; byte b bytes [ ] = { num , - num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , - num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . remainder ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	remainder of division of two numbers of different signs.
public static boolean has visible children ( action group group , presentation factory factory , action manager action manager , perspective manager perspective manager ) { action event event = new action event ( factory . get presentation ( group ) , action manager , perspective manager ) ; for ( action an action : group . get children ( event ) ) { if ( an action == null ) { log . error ( utils . class , str + group + str + factory . get presentation ( group ) ) ; continue ; } if ( an action instanceof separator ) { continue ; } final presentation presentation = factory . get presentation ( an action ) ; an action . update ( new action event ( presentation , action manager , perspective manager ) ) ; if ( an action instanceof action group ) { action group child group = ( action group ) an action ; if ( child group . is popup ( ) ) { if ( ! presentation . is visible ( ) ) { continue ; } } if ( has visible children ( child group , factory , action manager , perspective manager ) ) { return bool ; } } else if ( presentation . is visible ( ) ) { return bool ; } } return bool ; }	returns true if action group has visible children .
private static void check arg references ( string type snippet , int number of args ) { matcher arg ref matcher = arg ref pattern . matcher ( type snippet ) ; while ( arg ref matcher . find ( ) ) { int index = integer . parse int ( arg ref matcher . group ( num ) , num ) - num ; preconditions . check argument ( index >= num , str , arg ref matcher . group ( num ) ) ; preconditions . check argument ( index < number of args , str , arg ref matcher . group ( num ) ) ; } }	check that all % d references in the given type snippet are within bounds .
public void randomize ( ) { randomize incoming weights ( ) ; normalize incoming weights ( ) ; }	randomize and normalize weights .
public static void save as image ( int x , int y , int width , int height , string path , compress format compress format , int quality ) throws file not found exception { bitmap bmp = get pixels from buffer ( x , y , width , height ) ; try { file file = new file ( path ) ; try { file . create new file ( ) ; } catch ( io e1 ) { e1 . print stack trace ( ) ; } file output stream fos = new file output stream ( file ) ; bmp . compress ( compress format , quality , fos ) ; try { fos . flush ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } try { fos . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } catch ( file not found exception e ) { throw ( e ) ; } }	saves the pixels from the buffer on the sd card .
private boolean is file valid ( file file , string method name ) { if ( file == null ) { log . print concat line ( name , str , method name , str ) ; return bool ; } string file name = file . get name ( ) ; if ( file name == null || file name . length ( ) == num ) { log . print concat line ( name , str + method name , str ) ; return bool ; } return bool ; }	check if the file is valid or not.
public void remove src class ( soot class clz ) { src classes . remove ( clz . get name ( ) ) ; }	remove a class from the list of src classes .
private void update range ( double value ) { m min value = math . min ( m min value , value ) ; m max value = math . max ( m max value , value ) ; }	updates the values range .
json close ( scope empty , scope nonempty , string close bracket ) throws json { scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new json ( str ) ; } stack . remove ( stack . size ( ) - num ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close bracket ) ; return this ; }	closes the current scope by appending any necessary whitespace and the given bracket .
public void append ( byte [ ] bytes ) { append ( bytes , num , bytes . length ) ; }	append specified bytes to the buffer.
public static boolean enough space on phone ( long update size ) { return get real size on phone ( ) > update size ; }	checks if there is enough space on phone self.
public void cancel button action performed ( ) { edit mode = bool ; cur node = null ; add button . set visible ( bool ) ; edit button . set visible ( bool ) ; delete button . set visible ( bool ) ; done button . set visible ( bool ) ; update button . set visible ( bool ) ; cancel button . set visible ( bool ) ; node addr field . set visible ( bool ) ; node addr static . set visible ( bool ) ; status text1 . set text ( std status1 ) ; status text2 . set text ( std status2 ) ; status text3 . set text ( std status3 ) ; }	method to handle cancel button.
public void add attribute ( attributed character iterator . attribute attribute , object value ) { if ( attribute == null ) { throw new null pointer exception ( str ) ; } if ( text . is empty ( ) ) { throw new illegal argument exception ( str ) ; } list < range > ranges = attribute map . get ( attribute ) ; if ( ranges == null ) { ranges = new array list < range > ( num ) ; attribute map . put ( attribute , ranges ) ; } else { ranges . clear ( ) ; } ranges . add ( new range ( num , text . length ( ) , value ) ) ; }	applies a given attribute to this string .
private object string to value ( object old value , string new value ) throws replicator exception { if ( old value instanceof string ) { return new value ; } else if ( old value instanceof integer ) { return integer . value of ( new value ) ; } else if ( old value instanceof serial blob ) { try { return database helper . get safe blob ( new value . get bytes ( ) ) ; } catch ( sql e ) { throw new replicator exception ( str + e , e ) ; } } else { return new value ; } }	converts string back to correct ( previous ) data type .
public string to z ( ) { string builder buffer = new string builder ( num ) ; try { print z ( buffer ) ; } catch ( io e ) { throw new runtime exception ( str , e ) ; } return buffer . to string ( ) ; }	returns the string representation ( in ion format ) of this timestamp in utc .
public void record state ( dialogue state state , string name ) { states . put ( name , state ) ; if ( ! list model . contains ( name ) ) { int position = name . contains ( current ) ? num : math . min ( num , list model . size ( ) ) ; list model . add ( position , name ) ; } }	records a dialogue state in the component and makes it available for display in the network selection list on the left side.
public int write ut ( final char sequence chars , int off , int len ) { if ( len > remaining ( ) ) { return write ut ( chars , off , len ) ; } final block block = current ; int limit = block . limit ; char ch = str ; int octets = num ; while ( len > num ) { ch = chars . char at ( off ) ; if ( ch >= ut 2 octet min value ) { break ; } block . data [ limit ++ ] = ( byte ) ch ; octets ++ ; off ++ ; len -- ; } block . limit = limit ; if ( len > num ) { if ( ch < ut 3 octet min value ) { return octets + write ut ( chars , off , len ) ; } if ( ch >= low surrogate first && ch <= low surrogate last ) { throw new illegal argument exception ( str + ch ) ; } if ( ch >= high surrogate first && ch <= high surrogate last ) { return octets + write ut ( chars , off , len ) ; } return octets + write ut ( chars , off , len ) ; } return octets ; }	returns the number of octets written .
public wps ( geo server connection connection ) { this . connection = connection ; }	instantiates a new geo server wps client .
static boolean verify zip file ( file file ) { try { zip file zip file = new zip file ( file ) ; try { zip file . close ( ) ; return bool ; } catch ( io e ) { log . w ( tag , str + file . get absolute path ( ) ) ; } } catch ( zip exception ex ) { log . w ( tag , str + file . get absolute path ( ) + str , ex ) ; } catch ( io ex ) { log . w ( tag , str + file . get absolute path ( ) , ex ) ; } return bool ; }	returns whether the file is a valid zip file .
long cleanup ( long now ) { int in use connection count = num ; int idle connection count = num ; real connection longest idle connection = null ; long longest idle duration ns = long . min value ; synchronized ( this ) { for ( iterator < real connection > i = connections . iterator ( ) ; i . has next ( ) ; ) { real connection connection = i . next ( ) ; if ( prune and get allocation count ( connection , now ) > num ) { in use connection count ++ ; continue ; } idle connection count ++ ; long idle duration ns = now - connection . idle at nanos ; if ( idle duration ns > longest idle duration ns ) { longest idle duration ns = idle duration ns ; longest idle connection = connection ; } } if ( longest idle duration ns >= this . keep alive duration ns || idle connection count > this . max idle connections ) { connections . remove ( longest idle connection ) ; } else if ( idle connection count > num ) { return keep alive duration ns - longest idle duration ns ; } else if ( in use connection count > num ) { return keep alive duration ns ; } else { cleanup running = bool ; return - num ; } } close quietly ( longest idle connection . socket ( ) ) ; return num ; }	performs maintenance on this pool , evicting the connection that has been idle the longest if either it has exceeded the keep alive limit or the idle connections limit.
public state info ( ) { }	creates a new stateinfo .
public boolean compare ( object expected , object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( num ) ; } return equal ; }	this is used to compare the expected and current versions of the class.
private static byte [ ] generate seed ( ) { try { byte array output stream seed buffer = new byte array output stream ( ) ; data output stream seed buffer out = new data output stream ( seed buffer ) ; seed buffer out . write long ( system . current time millis ( ) ) ; seed buffer out . write long ( system . nano time ( ) ) ; seed buffer out . write int ( process . my pid ( ) ) ; seed buffer out . write int ( process . my uid ( ) ) ; seed buffer out . write ( build fingerprint and device serial ) ; seed buffer out . close ( ) ; return seed buffer . to byte array ( ) ; } catch ( io e ) { throw new security exception ( str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
boolean need to check exclude ( ) { return bool ; }	return whether we need to check namespace prefixes against and exclude result prefixes list .
public static byte [ ] decode ( string hexa ) throws coder exception { if ( hexa == null ) { throw new coder exception ( str ) ; } if ( ( hexa . length ( ) % num ) != num ) { throw new coder exception ( str ) ; } int tam array = hexa . length ( ) / num ; byte [ ] retorno = new byte [ tam array ] ; for ( int i = num ; i < tam array ; i ++ ) { retorno [ i ] = hex to byte ( hexa . substring ( i * num , i * num + num ) ) ; } return retorno ; }	decodes back a string to a byte array.
private list < user namespace authorization > create user namespace authorizations from entities ( list < user namespace authorization entity > user namespace authorization entities ) { list < user namespace authorization > user namespace authorizations = new array list < > ( ) ; for ( user namespace authorization entity user namespace authorization entity : user namespace authorization entities ) { user namespace authorizations . add ( create user namespace authorization from entity ( user namespace authorization entity ) ) ; } return user namespace authorizations ; }	creates a list of user namespace authorizations from the list of persisted entities .
private void read header ( ) throws open stego exception { this . data header = new dct ( this , this . config ) ; }	method to read header data from the input stream.
protected void draw text ( string text1 , string text2 , int x , int y , canvas c ) { if ( text paint == null ) { paint p = new paint ( ) ; p . set typeface ( roboto light typeface . get instance ( context ) ) ; p . set color ( text color ) ; p . set text size ( num * pixel density ) ; this . text paint = p ; } float w = text paint . measure text ( text1 , num , text1 . length ( ) ) ; int offset = ( int ) w / num ; c . draw text ( text1 , x - offset , y + ( num * pixel density ) , text paint ) ; w = text paint . measure text ( text2 , num , text2 . length ( ) ) ; offset = ( int ) w / num ; c . draw text ( text2 , x - offset , y + ( num * pixel density ) , text paint ) ; }	draw the text under the graphics.
public boolean is less then or equal to ( percent percent ) { assert defined ( ) ; big decimal this value = not null ( this ) ; big decimal parameter = not null ( percent ) ; return ( this value . compare to ( parameter ) <= num ) ; }	compares two percent objects .
public object clone ( ) throws clone not supported exception { predicated node test clone = ( predicated node test ) super . clone ( ) ; if ( ( null != this . m proximity positions ) && ( this . m proximity positions == clone . m proximity positions ) ) { clone . m proximity positions = new int [ this . m proximity positions . length ] ; system . arraycopy ( this . m proximity positions , num , clone . m proximity positions , num , this . m proximity positions . length ) ; } if ( clone . m lpi == this ) clone . m lpi = ( loc path iterator ) clone ; return clone ; }	get a cloned prdicatednodetest .
public static boolean point outside pref size ( j table , int row , int column , point p ) { if ( table . convert column index to model ( column ) != num || row == - num ) { return bool ; } table cell renderer tcr = table . get cell renderer ( row , column ) ; object value = table . get value at ( row , column ) ; component cell = tcr . get table cell renderer component ( table , value , bool , bool , row , column ) ; dimension item size = cell . get preferred size ( ) ; rectangle cell bounds = table . get cell rect ( row , column , bool ) ; cell bounds . width = item size . width ; cell bounds . height = item size . height ; assert ( p . x >= cell bounds . x && p . y >= cell bounds . y ) ; return p . x > cell bounds . x + cell bounds . width || p . y > cell bounds . y + cell bounds . height ; }	returns true if the given point is outside the preferredsize of the item at the given row of the table.
public builder add source folder ( @ non null file folder ) { folders to scan . add ( folder ) ; return this ; }	root folder for labels - > documents . each subfolder name will be presented as label , and contents of this folder will be represented as labelleddocument , with label attached.
public method suspend srdf ( final uri system uri , final remote director group group , final list < uri > source volumes , final list < uri > target volumes ) { return new workflow . method ( suspend srdf group method , system uri , group , source volumes , target volumes ) ; }	returns a workflow . method for suspending srdf group.
@ override public double calculate m ( double delta , double epsilon ) { double i = num ; while ( conf ( i , delta ) > epsilon / num ) { i = i + num ; } if ( i > num ) { i = i - num ; } while ( conf ( i , delta ) > ( epsilon / num ) ) { i ++ ; } return math . ceil ( i ) ; }	calculates the m - value needed for the gss algorithm .
public static server socket create server socket ( int port , inet address bind address ) throws io { server socket socket = null ; if ( sys properties . enable anonymous tls ) { remove anon from legacy algorithms ( ) ; } set keystore ( ) ; server socket factory f = ssl . get default ( ) ; ssl secure socket ; if ( bind address == null ) { secure socket = ( ssl ) f . create server socket ( port ) ; } else { secure socket = ( ssl ) f . create server socket ( port , num , bind address ) ; } secure socket . set enabled protocols ( disable ssl ( secure socket . get enabled protocols ( ) ) ) ; if ( sys properties . enable anonymous tls ) { string [ ] list = enable anonymous ( secure socket . get enabled cipher suites ( ) , secure socket . get supported cipher suites ( ) ) ; secure socket . set enabled cipher suites ( list ) ; } socket = secure socket ; return socket ; }	create a secure server socket.
public void print bytes ( byte [ ] data , int offset , int length ) throws io { int i ; for ( ; length >= num ; length -= num ) { int chunk = ( ( ( data [ offset ] & num ) << num ) + ( ( data [ offset + num ] & num ) << num ) + ( data [ offset + num ] & num ) ) ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk ) ) ; offset += num ; } if ( length == num ) { int chunk = ( ( data [ offset ] & num ) << num ) + ( data [ offset + num ] & num ) ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( str ) ; } else if ( length == num ) { int chunk = data [ offset ] & num ; os . write ( base64encode ( chunk > > num ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( str ) ; os . write ( str ) ; } }	prints a byte array to the stream , properly encoded in base64 .
public void delete v ( string native id ) throws exception { log . info ( str ) ; client response client resp = null ; final string path = message format . format ( uri delete cg , native id ) ; log . info ( str + path ) ; try { client resp = delete ( path ) ; if ( client resp == null ) { log . error ( str ) ; throw new h par ( str ) ; } else if ( client resp . get status ( ) != num ) { string err resp = get response details ( client resp ) ; throw new h par ( err resp ) ; } else { log . info ( str ) ; } } catch ( exception e ) { throw e ; } finally { if ( client resp != null ) { client resp . close ( ) ; } log . info ( str ) ; } }	delete a vv set or consistency group.
private int find key comment index ( string key name ) { for ( int i = num ; i < key val comments . size ( ) ; i ++ ) { string t = key val comments . get ( i ) ; string targeted key = str + key name + str ; if ( t . starts with ( targeted key ) ) { return i ; } } if ( log . is debug enabled ( ) ) { log . debug ( str + key name ) ; } return - num ; }	finds the index of the specified key within the array containing key / value comments.
public boolean is expired ( ) { return ( cookie expiry date != null && cookie expiry date . get time ( ) <= system . current time millis ( ) ) ; }	returns true if this cookie has expired .
public static boolean is add to home intent supported ( context context ) { package manager pm = context . get package manager ( ) ; intent i = new intent ( install shortcut ) ; list < resolve info > receivers = pm . query broadcast receivers ( i , package manager . get intent filters ) ; return ! receivers . is empty ( ) ; }	utility method to check if a shortcut can be added to the home screen .
in memory entry store ( ) { entries = maps . new hash map ( ) ; top level entries = sets . new hash set ( ) ; children = hash multimap . create ( ) ; }	creates a new inmemoryentrystore which provides constant time storage and retrieval of entries by id or parent id .
public class annotator ( url [ ] codebase , properties props ) { if ( props != null ) properties . put all ( props ) ; set annotation ur ( codebase ) ; }	constructs a new classannotator for the specified codebase urls.
public int next ( ) { return mix ( gen . get and increment ( ) ) ; }	produce the next identifier .
public input stream put ( final url connection , final boolean flush cache on close ) { final string key = get key ( connection ) ; if ( key == null ) return null ; if ( ! is cacheable ( ( url ) connection ) ) try { cache . remove ( key ) ; return null ; } catch ( io e ) { return null ; } string etag = connection . get header field ( header etag ) ; if ( etag == null || etag . length ( ) == num ) return null ; editor editor ; try { editor = cache . edit ( key ) ; } catch ( io e ) { return null ; } if ( editor == null ) return null ; try { editor . set ( etag , etag ) ; } catch ( io e ) { try { editor . abort ( ) ; } catch ( io ignored ) { } return null ; } input stream input ; try { input = connection . get input stream ( ) ; if ( ! ( input instanceof inflater input stream ) && encoding gzip . equals ( connection . get header field ( header content encoding ) ) ) input = new gzip ( input ) ; } catch ( io e ) { return null ; } output stream output ; try { output = editor . new output stream ( body ) ; } catch ( io e ) { return null ; } if ( output != null ) return new cache stream ( input , output , editor , this , flush cache on close ) ; else return null ; }	create stream that will be cached after it is read.
public static string [ ] parse title ( string title ) { string v [ ] = { str , str } ; if ( title == null ) return v ; pattern p = pattern . compile ( str , pattern . case insensitive ) ; matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { v [ num ] = m . group ( num ) ; v [ num ] = m . group ( num ) ; } else { v [ num ] = title ; } return v ; }	return a 2 element array . 0 = title ; 1 = date parses the title in the format title year or title ( year ).
public string sel ( ) { return m selection . to string ( ) ; }	returns the selection produced by this object .
public double calculate excitatory ratio ( ) { excitatory ratio = ex synapse set . size ( ) / ( double ) size ( ) ; if ( double . is na n ( excitatory ratio ) ) { return num ; } return excitatory ratio ; }	if a randomize operation changes the ratio of excitatory to inhibitory synapses , this method can be called to change the excitatoryratio to reflect this value.
public void root removed ( isvn root ) { iterator it = listeners . iterator ( ) ; while ( it . has next ( ) ) { i listener = ( i ) it . next ( ) ; listener . repository removed ( root ) ; } }	a repository root has been removed .
public synchronized void insert ( double priority , object data ) { num elements ++ ; if ( num elements == queue . length ) { priority queue node [ ] tmp = new priority queue node [ ( int ) ( queue . length * num ) ] ; system . arraycopy ( queue , num , tmp , num , queue . length ) ; for ( int i = queue . length ; i < tmp . length ; i ++ ) { tmp [ i ] = new priority queue node ( ) ; } queue = tmp ; } queue [ num elements ] . data = data ; queue [ num elements ] . priority = priority ; reheapify ( num elements ) ; }	insert the object passed with the priority value passed.
protected message ( ) { }	creates a new message with no specified message type .
protected string wrap linux command ( string command ) throws io , interrupted exception { string set group = str + get gid ( ) + str + get gid ( ) + str + get gid ( ) + str ; string set user = str + get uid ( ) + str + get uid ( ) + str + get gid ( ) + str ; string chown command = str ; return set group + str + set user + str + chown command + str + command + str + chown command ; }	wrap the given command into a command with chown . also add group / user that match host environment if not exists.
public dml parse sql query ( sql sql query , i space ) throws sql { dml query = ( dml ) get query from cache ( get unique key ( sql query ) ) ; try { if ( query == null ) { if ( logger . is loggable ( level . fine ) ) { logger . fine ( str ) ; } sql parser parser = init parser ( sql query . get query ( ) ) ; query = parse ( parser ) ; query . set table name ( sql query . get type name ( ) ) ; query . validate query ( space ) ; if ( ! query . is prepared ( ) && ! query . contains sub queries ( ) ) query . build ( ) ; add query to cache ( get unique key ( sql query ) , query ) ; if ( ! query . is prepared ( ) ) return query ; } query = query . clone ( ) ; return query ; } catch ( sql sql ex ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str + sql query . get query ( ) + str , sql ex ) ; } throw sql ex ; } catch ( throwable t ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str + sql query . get query ( ) + str , t ) ; } sql sql ex = new sql ( str + sql query . get query ( ) + str + t , str , - num ) ; sql ex . init cause ( t ) ; throw sql ex ; } }	the main method to handle the query.
private int index of element in level ( int element , int level [ ] ) throws exception { for ( int i = num ; i < level . length ; i ++ ) { if ( level [ i ] == element ) { return i ; } } throw new exception ( str + m nodes . get ( element ) . id + str + str ) ; }	returns the index of an element in a level.
public int size ( ) { return attrs . size ( ) ; }	get the number of attributes in the attribute set.
public string consume tag name ( ) { int start = pos ; while ( ! is empty ( ) && ( matches word ( ) || matches any ( str , str , str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume an tag name off the queue ( word or : , _ , - ).
public void deep sort ( int [ ] set feature sequence ) { feature sequence = set feature sequence ; number of leaves = num ; tree = new mary node ( num , feature vectors . length ) ; sort node ( num , tree ) ; }	launches a deep sort on the array of feature vectors.
public void remove listeners ( ) { listeners . clear ( ) ; }	remove all existing listeners .
public string decrypt ( string s cipher text ) { int n len = ( s cipher text . length ( ) > > num ) & ~ num ; if ( n len < ecb . blocksize ) return null ; byte [ ] cbciv = new byte [ ecb . blocksize ] ; int n num of bytes = bin converter . bin hex to bytes ( s cipher text , cbciv , num , num , ecb . blocksize ) ; if ( n num of bytes < ecb . blocksize ) return null ; m bfish . set cbciv ( cbciv ) ; n len -= ecb . blocksize ; if ( n len == num ) return str ; byte [ ] buf = new byte [ n len ] ; n num of bytes = bin converter . bin hex to bytes ( s cipher text , buf , ecb . blocksize * num , num , n len ) ; if ( n num of bytes < n len ) return null ; m bfish . decrypt ( buf ) ; int n pad byte = buf [ buf . length - num ] & num ; if ( ( n pad byte > num ) || ( n pad byte < num ) ) n pad byte = num ; n num of bytes -= n pad byte ; if ( n num of bytes < num ) return str ; return bin converter . byte array to unc ( buf , num , n num of bytes ) ; }	decrypts a hexbin string ( handling is case sensitive ).
public static double l ( int y [ ] , int r [ ] ) { int l = y . length ; array list < integer > t i = new array list < integer > ( ) ; array list < integer > f i = new array list < integer > ( ) ; for ( int j = num ; j < l ; j ++ ) { if ( y [ j ] == num ) { t i . add ( j ) ; } else { f i . add ( j ) ; } } if ( ! t i . is empty ( ) && ! f i . is empty ( ) ) { int c = num ; for ( int k : t i ) { for ( int l : f i ) { if ( position ( k , r ) < position ( l , r ) ) { c ++ ; } } } return ( double ) c / ( double ) ( t i . size ( ) * f i . size ( ) ) ; } else { return num ; } }	rank loss - the average fraction of labels which are not correctly ordered.
private double add recursively ( array list < double [ ] > hull , hierarchy < cluster < model > > hier , cluster < model > clus ) { final dbi ids = clus . get i ( ) ; double weight = ids . size ( ) ; for ( dbid iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { double [ ] proj p = proj . fast project data to render space ( rel . get ( iter ) ) ; if ( proj p [ num ] != proj p [ num ] || proj p [ num ] != proj p [ num ] ) { continue ; } hull . add ( proj p ) ; } for ( iter < cluster < model > > iter = hier . iter children ( clus ) ; iter . valid ( ) ; iter . advance ( ) ) { weight += num * add recursively ( hull , hier , iter . get ( ) ) ; } return weight ; }	recursively add a cluster and its children .
public void attribute update ( print service attribute event psae ) { log . fine ( str + psae ) ; }	print service attribute listener .
public static boolean decode to file ( string data to decode , string filename ) { boolean success = bool ; base64 . output stream bos = null ; try { bos = new base64 . output stream ( new java . io . file output stream ( filename ) , base64 . decode ) ; bos . write ( data to decode . get bytes ( preferred encoding ) ) ; success = bool ; } catch ( java . io . io e ) { success = bool ; } finally { try { bos . close ( ) ; } catch ( exception e ) { } } return success ; }	convenience method for decoding data to a file .
public void evict ( ) throws exception { assert open ( ) ; boolean is empty ; synchronized ( this ) { is empty = pool . is empty ( ) ; } if ( ! is empty ) { if ( soft min evictable idle time millis > num ) { int num to evict = get num idle ( ) - get min idle ( ) ; evict ( system . current time millis ( ) - soft min evictable idle time millis , num to evict ) ; } if ( min evictable idle time millis > num ) { int num to evict = get num idle ( ) ; evict ( system . current time millis ( ) - min evictable idle time millis , num to evict ) ; } } }	make one pass of the idle object evictor .
protected void generate random population ( int population size ) { logger . debug ( str ) ; for ( int i = num ; i < population size ; i ++ ) { t individual = chromosome factory . get chromosome ( ) ; for ( fitness function < ? > fitness function : this . fitness functions ) { individual . add fitness ( fitness function ) ; } population . add ( individual ) ; if ( is finished ( ) ) break ; } logger . debug ( str + population . size ( ) + str ) ; }	generate random population of given size.
public session ( ) { long uptime = system . current time millis ( ) ; m main handler = new handler ( looper . get main looper ( ) ) ; m timestamp = ( uptime / num ) << num & ( ( ( uptime - ( ( uptime / num ) * num ) ) > > num ) / num ) ; m origin = str ; try { s signal . await ( ) ; } catch ( interrupted exception e ) { } }	creates a streaming session that can be customized by adding tracks .
public list < visitante > listar ( ) { list < visitante > dados = new array list < > ( ) ; try { string sql = str ; stm = conector . prepare statement ( sql ) ; rs = stm . execute query ( sql ) ; while ( rs . next ( ) ) { dados . add ( new visitante ( rs . get int ( num ) , rs . get string ( num ) , rs . get string ( num ) , rs . get string ( num ) , rs . get string ( num ) , rs . get string ( num ) , tempo . to date ( rs . get timestamp ( num ) ) , rs . get string ( num ) , rs . get string ( num ) ) ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( sql ex ) { mensagem . erro ( str + ex ) ; } return dados ; }	consultar todos visitantes cadastrdos na base de dados.
private void assert all from tbl1 ( statement stmt , string [ ] ones , short [ ] twos ) throws sql { result set rs = stmt . execute query ( str ) ; int i = num ; for ( ; rs . next ( ) ; i ++ ) { assert true ( i < ones . length ) ; assert equals ( ones [ i ] , rs . get string ( str ) ) ; assert equals ( twos [ i ] , rs . get short ( str ) ) ; } assert true ( i == ones . length ) ; }	asserts that the expected values can be selected from the test table .
@ override public writer append ( char value ) { builder . append ( value ) ; return this ; }	append a single character to this writer .
private void insert before ( instruction [ ] list , instruction s ) { for ( instruction x : list ) { s . insert before ( x ) ; } }	inserts each instruction in a list before another instruction .
public static builder new builder ( ) { return new builder ( ) ; }	creates a new persistent subscription settings builder .
public int count array ( string [ ] array ) { return array . length ; }	counts the size of an array .
private void process unprocessed ( ) { boolean clean processings = boolean . get boolean ( str ) ; logger . info ( str + str + clean processings + str ) ; product service . process unprocessed ( ! clean processings ) ; }	run recovery of stopped scanners.
public double [ ] popy ( double x [ ] ) { return pop y ( new double [ ] [ ] { x } ) [ num ] ; }	forward pass - given input x_ , get output y_ .
public void goto frame ( int frame number ) throws io { print ( str , new string [ ] { integer . to string ( frame number ) } ) ; }	description of the method.
public void delete ( string name ) throws io { if ( name . equals ignore case ( subject name ) ) { names = null ; } else { throw new io ( str + str ) ; } encode this ( ) ; }	delete the attribute value .
public void push elem attribute set ( elem attribute set attr set ) { m attr set stack . push ( attr set ) ; }	push an executing attribute set , so we can check for recursive attribute definitions .
private void finish scroll stacks ( ) { cancel animation ( this , property . stack snap ) ; final int current model index = get tab stack index ( ) ; float delta = math . abs ( current model index + m rendered scroll offset ) ; float target = - current model index ; if ( delta != num ) { long duration = fling min duration + ( long ) math . abs ( delta * get full scroll distance ( ) / m fling speed ) ; add to animation ( this , property . stack snap , m rendered scroll offset , target , duration , num ) ; } else { set property ( property . stack snap , target ) ; if ( m temporary selected stack != null ) { m tab model selector . select model ( m temporary selected stack ) ; m temporary selected stack = null ; } } }	animate to the final position of the stack.
public geo distance builder add unbounded from ( string key , double from ) { ranges . add ( new range ( key , from , null ) ) ; return this ; }	add a new range with no upper bound .
private void send response ( document doc , message factory message factory , string content type , http servlet response res ) throws io , soap { soap reply = message factory . create message ( ) ; soap header = reply . get soap ( ) ; header . detach node ( ) ; soap reply body = reply . get soap ( ) ; res . set header ( str , content type ) ; reply body . add document ( doc ) ; reply . save changes ( ) ; output stream os = res . get output stream ( ) ; reply . write to ( os ) ; os . flush ( ) ; }	send a response back to the client.
public static string replace chars ( string str , string oldchars , char newchar ) { int pos = index of chars ( str , oldchars ) ; if ( pos == - num ) { return str ; } string builder buf = new string builder ( str ) ; do { buf . set char at ( pos , newchar ) ; pos = index of chars ( str , oldchars , pos + num ) ; } while ( pos != - num ) ; return buf . to string ( ) ; }	like string . replace ( ) except that it accepts any number of old chars . replaces any occurrances of ' oldchars ' in ' str ' with ' newchar ' . example : replacechars ( " hello , world ! " , " h , ! " , ' ' ) returns " ello world ".
public final char sequence yytext ( ) { return zz buffer . sub sequence ( zz start read , zz marked pos ) ; }	returns the text matched by the current regular expression .
public static string canonicalize path ( string path , boolean discard relative prefix ) { int segment start = num ; int deletable segments = num ; for ( int i = num ; i <= path . length ( ) ; ) { int next segment start ; if ( i == path . length ( ) ) { next segment start = i ; } else if ( path . char at ( i ) == str ) { next segment start = i + num ; } else { i ++ ; continue ; } if ( i == segment start + num && path . region matches ( segment start , str , num , num ) ) { path = path . substring ( num , segment start ) + path . substring ( next segment start ) ; i = segment start ; } else if ( i == segment start + num && path . region matches ( segment start , str , num , num ) ) { if ( deletable segments > num || discard relative prefix ) { deletable segments -- ; int prev segment start = path . last index of ( str , segment start - num ) + num ; path = path . substring ( num , prev segment start ) + path . substring ( next segment start ) ; i = segment start = prev segment start ; } else { i ++ ; segment start = i ; } } else { if ( i > num ) { deletable segments ++ ; } i ++ ; segment start = i ; } } return path ; }	returns the path will relative path segments like ".
public in memory message exchange store ( final network config config , token provider token provider ) { if ( config == null ) { throw new null pointer exception ( str ) ; } if ( token provider == null ) { throw new null pointer exception ( str ) ; } this . token provider = token provider ; this . config = config ; }	creates a new store for configuration values .
public static void next ( ) { try { if ( music playback service != null ) { music playback service . next ( ) ; } } catch ( final remote exception ignored ) { } }	changes to the next track.
private void draw bitmap with stroke ( canvas canvas , bitmap bitmap , int center x , int center y , float radius , paint draw paint ) { draw paint . set style ( paint . style . fill ) ; float stroke radius = radius + m radius stroke width ; draw paint . set xfermode ( new porter duff xfermode ( porter duff . mode . clear ) ) ; canvas . draw circle ( center x , center y , stroke radius , draw paint ) ; draw paint . set xfermode ( null ) ; final int half bitmap width = bitmap . get width ( ) / num ; final int half bitmap height = bitmap . get height ( ) / num ; bitmap shader bitmap shader = new bitmap shader ( bitmap , shader . tile mode . repeat , shader . tile mode . repeat ) ; matrix shader matrix = new matrix ( ) ; float min size = bitmap . get width ( ) > bitmap . get height ( ) ? bitmap . get height ( ) : bitmap . get width ( ) ; float scale = radius * num / min size ; shader matrix . set scale ( scale , scale ) ; shader matrix . post translate ( center x - ( half bitmap width * scale ) , center y - ( half bitmap height * scale ) ) ; bitmap shader . set local matrix ( shader matrix ) ; draw paint . set shader ( bitmap shader ) ; canvas . draw circle ( center x , center y , radius , draw paint ) ; draw paint . set shader ( null ) ; }	draw single bitmap with the giving centerx , centery and radius.
public mqtt device mqtt device ( ) { return mqtt device ; }	get the application ' s mqttdevice.
public abba locking detector start collecting ( ) { thread = new thread ( this , str ) ; thread . set daemon ( bool ) ; thread . start ( ) ; return this ; }	start collecting locking data .
protected object read object override ( ) throws optional data exception , class not found exception , io { if ( input == null ) { return null ; } throw new io ( ) ; }	method to be overridden by subclasses to read the next object from the source stream .
public float to meters ( double pixels ) { return ( float ) ( pixels * meters per pixels ) ; }	converts pixels to meters.
boolean add to buffer ( char c ) throws io { int len = sb . length ( ) ; if ( len == num && c != char lt ) return bool ; sb . append ( c ) ; if ( ++ len >= min tag len ) { boolean is closing tag = ( len >= num && sb . char at ( num ) == char sl ) ; string substr ; if ( is closing tag ) substr = sb . substring ( num ) ; else substr = sb . substring ( num ) ; for ( int i = num ; i < exclude tags . length ; i ++ ) { if ( substr . equals ignore case ( exclude tags [ i ] ) ) { if ( is closing tag ) { depth dec ( i ) ; print buffer ( ) ; last char = num ; } else { depth inc ( i ) ; } } } } return bool ; }	checks if a character is part of an open html tag or close html tag , and if so adds it to the buffer , otherwise returns false .
public static double length ( double x , double y , double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }	computes the length of a vector.
private cache create cache ( ) throws cache exception { final properties props = new properties ( ) ; props . set property ( locators , str ) ; props . set property ( mcast port , str ) ; return cache factory . create ( distributed system . connect ( props ) ) ; }	creates the cache instance for the test.
public attribute list panel ( ) { m . set selection mode ( list selection model . single selection ) ; m . set column selection allowed ( bool ) ; m . set preferred scrollable viewport size ( new dimension ( num , num ) ) ; set layout ( new border layout ( ) ) ; add ( new j ( m ) , border layout . center ) ; }	creates the attribute selection panel with no initial instances .
private environment ( ) { throw contract utils . unreachable ( ) ; }	make sure nobody can instantiate the class.
public void remove photo ( photo entity photo ) { photos . remove ( photo ) ; }	removes the given photo from this user.
public static int binary search ( double [ ] array , int start index , int end index , double value ) { check index for binary search ( array . length , start index , end index ) ; long long bits = double . double to long bits ( value ) ; int low = start index , mid = - num , high = end index - num ; while ( low <= high ) { mid = ( low + high ) > > > num ; if ( less than ( array [ mid ] , value ) ) { low = mid + num ; } else if ( long bits == double . double to long bits ( array [ mid ] ) ) { return mid ; } else { high = mid - num ; } } if ( mid < num ) { int insert point = end index ; for ( int index = start index ; index < end index ; index ++ ) { if ( value < array [ index ] ) { insert point = index ; } } return - insert point - num ; } return - mid - ( less than ( value , array [ mid ] ) ? num : num ) ; }	performs a binary search for the specified element in a part of the specified sorted array .
public static void compute ( double min score , double top percent , double max expected , float min percent identity , i read block , string classification name , bit set active matches for classification ) { active matches for classification . clear ( ) ; for ( int i = num ; i < read block . get number of available match blocks ( ) ; i ++ ) { final i match block = read block . get match block ( i ) ; if ( ! match block . is ignore ( ) && match block . get bit score ( ) >= min score && match block . get expected ( ) <= max expected && match block . get percent identity ( ) >= min percent identity ) { if ( match block . get id ( classification name ) > num ) active matches for classification . set ( i ) ; } } float best score = num ; for ( int i = active matches for classification . next set bit ( num ) ; i != - num ; i = active matches for classification . next set bit ( i + num ) ) { final i match block = read block . get match block ( i ) ; float score = match block . get bit score ( ) ; if ( score > best score ) best score = score ; } apply top percent filter ( top percent , best score , min percent identity , read block , active matches for classification ) ; }	get the set of matches active for the given read.
public e [ ] to array ( e [ ] a ) { if ( a . length != array . length ( ) ) { throw new elasticsearch generation exception ( str ) ; } for ( int i = num ; i < array . length ( ) ; i ++ ) { a [ i ] = array . get ( i ) ; } return a ; }	copies the content of the underlying atomic array to a normal one .
synchronized public void fail on ( failure fail ) { if ( failures == null ) { failures = new array list < > ( ) ; } failures . add ( fail ) ; }	add a failure object to the list of objects to be evaluated at every potential failure point.
public void dump stack ( ) { if ( stack == null ) { debug message ( str ) ; return ; } debug message ( str ) ; for ( int i = num ; i < stack . size ( ) ; i ++ ) { debug message ( str + ( ( symbol ) stack . element at ( i ) ) . sym + str + ( ( symbol ) stack . element at ( i ) ) . parse state ) ; } debug message ( str ) ; }	dump the parse stack for debugging purposes .
private static set < string > create categories set ( set < string > categories ) { set < string > result = new hash set < > ( ) ; for ( string cat : categories ) { result . add ( string util . to lower case ( cat ) ) ; } return result ; }	creates a new set with the given categories , making them all lowercase in the process.
public void load listener ( string server key ) throws generic service exception { server server = servers . get ( server key ) ; if ( server == null ) throw new generic service exception ( str ) ; load listener ( server key , server ) ; }	load a jms message listener .
public void upload ( file file , long restart at , ftp listener ) throws illegal state exception , file not found exception , io , ftp , ftp , ftp , ftp { if ( ! file . exists ( ) ) { throw new file not found exception ( file . get absolute path ( ) ) ; } input stream input stream = null ; try { input stream = new file input stream ( file ) ; } catch ( io e ) { throw new ftp ( e ) ; } try { upload ( file . get name ( ) , input stream , restart at , restart at , listener ) ; } catch ( illegal state exception e ) { throw e ; } catch ( io e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } finally { if ( input stream != null ) { try { input stream . close ( ) ; } catch ( throwable t ) { ; } } } }	this method uploads a file to the remote server.
public ssl create ssl ( socket socket ) throws io { ssl sf = ( ( ssl ) ssl . get default ( ) ) ; inet socket address remote address = ( inet socket address ) socket . get remote socket address ( ) ; ssl s = ( ssl ) ( sf . create socket ( socket , remote address . get host name ( ) , socket . get port ( ) , bool ) ) ; s . set use client mode ( bool ) ; s . set enabled cipher suites ( s . get supported cipher suites ( ) ) ; return s ; }	create a ssl socket that wraps the existing socket.
private string format node ( right threaded binary node < t > node ) { right threaded binary node < t > n ; string builder response = new string builder ( str ) ; if ( ( n = node . get left son ( ) ) != null ) { response . append ( format node ( n ) ) ; } response . append ( node . to string ( ) ) ; if ( ( n = node . get right son ( ) ) != null ) { response . append ( format node ( n ) ) ; } response . append ( str ) ; return response . to string ( ) ; }	format the node , recursively .
public static void unregister m ( class < ? > mbean interface ) { m mbs = management factory . get platform m ( ) ; try { object name name = generate m ( mbean interface ) ; if ( mbs . is registered ( name ) ) { logger . info ( str + name . to string ( ) ) ; mbs . unregister m ( name ) ; } else { logger . warn ( str + name . to string ( ) ) ; } } catch ( exception e ) { throw new server runtime exception ( str + mbean interface , e ) ; } }	server helper method to register a jmx mbean.
public void write exif ( input stream jpeg stream , string exif out file name ) throws file not found exception , io { if ( jpeg stream == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = null ; try { s = get exif writer stream ( exif out file name ) ; do exif stream io ( jpeg stream , s ) ; s . flush ( ) ; } catch ( io e ) { close silently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .
public void sort ( comparator < ? super t > comparator ) { synchronized ( m lock ) { if ( m original values != null ) { collections . sort ( m original values , comparator ) ; } else { collections . sort ( m objects , comparator ) ; } } if ( m notify on change ) notify data set changed ( ) ; }	sorts the content of this adapter using the specified comparator .
static boolean caused by rde ( disk access exception dae ) { boolean result = bool ; if ( dae != null ) { throwable cause = dae . get cause ( ) ; while ( cause != null ) { if ( cause instanceof region destroyed exception ) { result = bool ; break ; } cause = cause . get cause ( ) ; } } return result ; }	return true if dae was caused by a regiondestroyedexception.
public json array add ( string value ) { values . add ( json . value ( value ) ) ; return this ; }	appends the json representation of the specified string to the end of this array .
public magic variables arguments bundle ( @ non null map < string , string > arguments , @ non null map < string , string > variables , string layer name , @ non null display metrics metrics ) { super ( arguments , metrics ) ; m variables = variables ; m layer name prefix = str + layer name . replace ( str , str ) + str ; }	create a new simple arguments bundle implementation from provided key - & gt ; value map .
@ hle @ hle ( nid = num , version = num ) public int sce usb cam setup video ex ( psp usb cam setup video ex param usb cam setup video ex param , t work area , int work area size ) { this . work area = work area . get address ( ) ; this . work area size = work area size ; resolution = convert resolution ex to resolution ( usb cam setup video ex param . resolution ) ; frame rate = usb cam setup video ex param . framerate ; white balance = usb cam setup video ex param . wb ; saturation = usb cam setup video ex param . saturation ; brightness = usb cam setup video ex param . brightness ; contrast = usb cam setup video ex param . contrast ; sharpness = usb cam setup video ex param . sharpness ; image effect mode = usb cam setup video ex param . effectmode ; frame size = usb cam setup video ex param . framesize ; ev level = usb cam setup video ex param . evlevel ; if ( ! setup video ( ) ) { log . warn ( string . format ( str ) ) ; return sce kernel errors . error usbcam not ready ; } return num ; }	set ups the parameters for video capture ( with more options ).
public list < user > load all deep from cursor ( cursor cursor ) { int count = cursor . get count ( ) ; list < user > list = new array list < user > ( count ) ; if ( cursor . move to first ( ) ) { if ( identity scope != null ) { identity scope . lock ( ) ; identity scope . reserve room ( count ) ; } try { do { list . add ( load current deep ( cursor , bool ) ) ; } while ( cursor . move to next ( ) ) ; } finally { if ( identity scope != null ) { identity scope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static date convert is ( string date string ) throws parse exception { date format date format = new simple date format ( str ) ; date date = date format . parse ( date string ) ; return date ; }	method that converts a an iso 8601 string to java date.
public static document create dom ( input stream is ) throws parser configuration exception , sax , io { document builder factory dbf = document builder factory . new instance ( ) ; dbf . set validating ( bool ) ; dbf . set ignoring comments ( bool ) ; dbf . set ignoring element content whitespace ( bool ) ; dbf . set namespace aware ( bool ) ; dbf . set feature ( xml . feature secure processing , bool ) ; dbf . set feature ( disallow doctype decl , bool ) ; dbf . set feature ( external general entities , bool ) ; dbf . set feature ( external parameter entities , bool ) ; dbf . set feature ( load external dtd , bool ) ; document builder db = null ; db = dbf . new document builder ( ) ; db . set entity resolver ( new null resolver ( ) ) ; db . set error handler ( new saml parser error handler ( ) ) ; return db . parse ( is ) ; }	create dom from iostream .
public string to string ( ) { return double . to string ( get value ( ) ) ; }	obtains the string representation of this object .
public void reset count ( ) { msg cnt . set ( num ) ; }	resets counter to zero .
public void schedule at fixed rate ( timer task task , date when , long period ) { if ( period <= num || when . get time ( ) < num ) { throw new illegal argument exception ( ) ; } long delay = when . get time ( ) - system . current time millis ( ) ; schedule impl ( task , delay , period , bool ) ; }	schedule a task for repeated fixed - rate execution after a specific time has been reached .
void decode attribute body ( byte [ ] attribute value , char offset , char length ) throws stun exception { realm = new byte [ length ] ; system . arraycopy ( attribute value , offset , realm , num , length ) ; }	copies the value of the realm attribute from the specified attributevalue .
public static void copy assets ( context context , string assets filename , file file , string mode ) throws io , interrupted exception { string abi = build . cpu abi ; string library name ; if ( abi . equals ignore case ( str ) ) { library name = str ; } else if ( abi . equals ignore case ( str ) ) { library name = str ; } else if ( abi . contains ( str ) ) { library name = str ; } else { return ; } asset manager manager = context . get assets ( ) ; final input stream is = manager . open ( library name + str + assets filename ) ; copy file ( file , is , mode ) ; }	copy file in assets into destination file.
public boolean is same ( object obj ) { if ( this == obj ) return bool ; if ( obj == null ) return bool ; if ( get class ( ) != obj . get class ( ) ) return bool ; house number other = ( house number ) obj ; if ( number == null ) { if ( name == null ) { if ( other . name != null ) return bool ; } else if ( ! name . equals ( other . name ) ) return bool ; } else if ( ! number . equals ( other . number ) ) return bool ; if ( street == null ) { if ( other . street != null ) return bool ; } else if ( ! street . equals ( other . street ) ) return bool ; return bool ; }	check if address are content identical if number are equals and street ( if number is null , we look at the name ).
public static double next up ( double d ) { if ( d == double . positive infinity ) return d ; else { d += num ; return double . long bits to double ( double . double to raw long bits ( d ) + ( ( d >= num ) ? + num : - num ) ) ; } }	replacement for the math.
public int three way distance ( key k1 , key k2 ) { byte [ ] h0 = hash ; byte [ ] h1 = k1 . hash ; byte [ ] h2 = k2 . hash ; int mmi = mismatch ( h1 , h2 ) ; if ( mmi == - num ) return num ; int h = byte . to unsigned int ( h0 [ mmi ] ) ; int a = byte . to unsigned int ( h1 [ mmi ] ) ; int b = byte . to unsigned int ( h2 [ mmi ] ) ; return integer . compare unsigned ( a ^ h , b ^ h ) ; }	compares the distance of two keys relative to this one using the xor metric.
static byte [ ] discard whitespace ( byte [ ] data ) { byte groomed data [ ] = new byte [ data . length ] ; int bytes copied = num ; for ( int i = num ; i < data . length ; i ++ ) { switch ( data [ i ] ) { case ( byte ) str : case ( byte ) str : case ( byte ) str : case ( byte ) str : break ; default : groomed data [ bytes copied ++ ] = data [ i ] ; } } byte packed data [ ] = new byte [ bytes copied ] ; system . arraycopy ( groomed data , num , packed data , num , bytes copied ) ; return packed data ; }	discards any whitespace from a base - 64 encoded block .
public async selector ( ) throws io { this ( selector . open ( ) ) ; }	construct asyncselector with brand new selector.
public void remove child at ( int index ) { if ( ( index < num ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new array index out of bounds exception ( ) ; } element child = ( element ) children . get ( index ) ; child . set parent ( null ) ; children . remove ( index ) ; }	removes the child at the given index.
private linked list < diff > diff bisect split ( string text1 , string text2 , int x , int y , long deadline ) { string text1a = text1 . substring ( num , x ) ; string text2a = text2 . substring ( num , y ) ; string text1b = text1 . substring ( x ) ; string text2b = text2 . substring ( y ) ; linked list < diff > diffs = diff main ( text1a , text2a , bool , deadline ) ; linked list < diff > diffsb = diff main ( text1b , text2b , bool , deadline ) ; diffs . add all ( diffsb ) ; return diffs ; }	given the location of the ' middle snake ' , split the diff in two parts and recurse .
private void paint ( painter p , synth context ctx , graphics g , int x , int y , int w , int h , affine transform transform ) { if ( p != null ) { if ( g instanceof d ) { d gfx = ( d ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create inverse ( ) ) ; } catch ( noninvertible transform exception e ) { e . print stack trace ( ) ; } } } else { buffered image img = new buffered image ( w , h , buffered image . type int argb ) ; d gfx = img . create graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw image ( img , x , y , null ) ; img = null ; } } }	paint the provided painter using the provided transform at the specified position and size.
static void load directory ( file file , module candidate candidate ) throws io { file [ ] files = file . list files ( ) ; if ( files != null ) for ( file f : files ) load sub directory ( file , f , candidate ) ; }	load a module candidate from a directory.
public static boolean has suppressed ( @ nullable throwable t , @ nullable class < ? extends throwable > cls ) { if ( t == null || cls == null ) return bool ; if ( t . get suppressed ( ) != null ) { for ( throwable th : t . get suppressed ( ) ) { if ( cls . is assignable from ( th . get class ( ) ) ) return bool ; if ( has suppressed ( th , cls ) ) return bool ; } } return bool ; }	checks if passed throwable has given class in one of the suppressed exceptions .
static int write var long ( output stream out , long x ) throws io { int len = num ; while ( ( x & ~ num ) != num ) { out . write ( ( byte ) ( num | ( x & num ) ) ) ; x >>>= num ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }	write a variable size long value .
protected void engine update ( byte b ) throws signature exception { message digest . update ( b ) ; needs reset = bool ; }	updates the data to be signed or verified using the specified byte .
private void write object ( java . io . object output stream s ) throws java . io . io { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { s . default write object ( ) ; for ( node < e > p = first ; p != null ; p = p . next ) s . write object ( p . item ) ; s . write object ( null ) ; } finally { lock . unlock ( ) ; } }	saves this deque to a stream ( that is , serializes it ) .
private boolean check if initiator for rp ( initiator initiator ) { if ( initiator == null ) { return bool ; } boolean is rp = bool ; if ( null column value getter . is null value ( initiator . get host name ( ) ) || ! null column value getter . is null uri ( initiator . get host ( ) ) ) { is rp = bool ; } log . debug ( str + ( is rp ? str : str ) ) ; return is rp ; }	check if the passed in initiator is for rp.
@ override public collection < serial message > initialize ( boolean refresh ) { array list < serial message > result = new array list < serial message > ( ) ; if ( is support request supported == bool && ( refresh == bool || initialise done == bool ) && get version ( ) > num ) { result . add ( get supported message ( ) ) ; } return result ; }	initializes the meter command class.
public static dml read configuration file ( string config path ) throws parse exception , file not found exception { dml config = new dml ( ) ; if ( config path != null ) { try { config = new dml ( config path , bool ) ; } catch ( file not found exception fnfe ) { log . error ( str + config path + str ) ; throw fnfe ; } catch ( parse exception e ) { throw e ; } } else { try { config = new dml ( default systemml config filepath , bool ) ; } catch ( file not found exception fnfe ) { log . info ( str + str ) ; config = new dml ( ) ; } catch ( parse exception e ) { throw e ; } } return config ; }	start with the internal default settings , then merge in the settings from any specified configuration file , if available.
default b with default ( string key , int value ) { return with default ( key , integer . to string ( value ) ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
private string [ ] combine results from multiple reads ( string [ ] buffer , string [ ] last read ) { string [ ] t = new string [ buffer . length + last read . length ] ; system . arraycopy ( buffer , num , t , num , buffer . length ) ; system . arraycopy ( last read , num , t , buffer . length , last read . length ) ; return t ; }	for multi line records this method combines the current result with the result from previous read ( s ) .
private static boolean is retina ( ) { if ( system info . is apple jvm ) { return has apple retina device ( ) ; } if ( system info . is mac ) { graphics environment e = graphics environment . get local graphics environment ( ) ; graphics device [ ] devices = e . get screen devices ( ) ; for ( graphics device device : devices ) { if ( is oracle mac retina device ( device ) ) { return bool ; } } } return bool ; }	checks that at least one retina device is present.
public void p oln ( object o ) throws io { p o ( o . to string ( ) ) ; pln ( ) ; }	indent out ; write object ; end current line .
public activity resolve info ( resolve info resolve info ) { this . resolve info = resolve info ; }	creates a new instance .
private static pair < string , string > post indexed lsr ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value1 , final string register node value2 , final string immediate node value ) { final string address = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string index = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create str ( base offset ++ , dw , register node value1 , dw , address ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , dw , str + immediate node value , qw , tmp var1 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , qw , tmp var1 , dw , d word bit mask , dw , index ) ) ; instructions . add ( reil helpers . create add ( base offset ++ , dw , register node value1 , dw , index , dw , tmp var2 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var2 , dw , d word bit mask , dw , register node value1 ) ) ; return new pair < string , string > ( address , register node value1 ) ; }	operation : [ < rn > ] , + / - < rm > , lsr # < shift_imm > address = rn 0b01 / lsr / if shift_imm = = 0 then / lsr # 32 / index = 0 else index = rm logical_shift_right shift_imm if conditionpassed ( cond ) then if u = = 1 then rn = rn + index else / u = = 0 / rn = rn - index.
private void end formals ( ) { if ( has formals ) { has formals = bool ; buf . append ( str ) ; } }	ends the formal type parameters section of the signature .
public boolean next is sep ( ) { if ( character . is letter or digit ( str . char at ( current position ) ) ) return bool ; else return bool ; }	tells if there is a digit or a letter character ahead .
private string extract project name from uri ( @ not null string uri ) { int index finish project name = uri . last index of ( str ) ; int index start project name = uri . last index of ( str ) != - num ? uri . last index of ( str ) + num : ( uri . last index of ( str ) + num ) ; if ( index start project name != num && index start project name < index finish project name ) { return uri . substring ( index start project name , index finish project name ) ; } if ( index start project name != num ) { return uri . substring ( index start project name ) ; } return str ; }	gets project name from uri .
public final void add reference ( object ref ) { ref set . add ( ref ) ; }	adds the given object to the set of hard references , which will prevent that object from being disposed until the queue has been flushed completely.
private void reset notes2 ( ) { if ( error in status2 ) { if ( edit mode ) { status text1 . set text ( edit status2 ) ; } else { status text2 . set text ( std status2 ) ; } error in status2 = bool ; } }	reset the second line of notes area.
public requirements builder add require property ( string name , requirements builder builder ) { add property ( name , builder ) ; required properties . add ( name ) ; return this ; }	add a required property of type object .
private cell detect and add hit ( float x , float y ) { final cell cell = check for new hit ( x , y ) ; if ( cell != null ) { cell fill in gap cell = null ; final array list < cell > pattern = m pattern ; if ( ! pattern . is empty ( ) ) { final cell last cell = pattern . get ( pattern . size ( ) - num ) ; int d row = cell . row - last cell . row ; int d column = cell . column - last cell . column ; int fill in row = last cell . row ; int fill in column = last cell . column ; if ( math . abs ( d row ) == num && math . abs ( d column ) != num ) { fill in row = last cell . row + ( ( d row > num ) ? num : - num ) ; } if ( math . abs ( d column ) == num && math . abs ( d row ) != num ) { fill in column = last cell . column + ( ( d column > num ) ? num : - num ) ; } fill in gap cell = cell . of ( fill in row , fill in column ) ; } if ( fill in gap cell != null && ! m pattern draw lookup [ fill in gap cell . row ] [ fill in gap cell . column ] ) { add cell to pattern ( fill in gap cell ) ; } add cell to pattern ( cell ) ; if ( m enable haptic feedback ) { perform haptic feedback ( haptic feedback constants . virtual key , haptic feedback constants . flag ignore view setting | haptic feedback constants . flag ignore global setting ) ; } return cell ; } return null ; }	determines whether the point x , y will add a new point to the current pattern ( in addition to finding the cell , also makes heuristic choices such as filling in gaps based on current pattern ) .
public head rule ( string dir , string rule ) { string [ ] tmp = p tagsets . split ( rule ) ; int i , size = tmp . length ; b r2l = dir . equals ( dir right to left ) ; a tag sets = new head tag set [ size ] ; for ( i = num ; i < size ; i ++ ) a tag sets [ i ] = new head tag set ( tmp [ i ] ) ; }	constructs a new headrule by decoding the specific head tagsets .
public void test neg pos first shorter ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; int a sign = - num ; int b sign = num ; byte r bytes [ ] = { - num , num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	or for two negative numbers ; the first is shorter.
@ override public < t > future < t > submit ( callable < t > task ) { synchronized ( this ) { active . increment and get ( ) ; long timeout = num ; while ( queue . remaining capacity ( ) == num ) { try { if ( timeout <= giveup time ) { thread . sleep ( default sleep ) ; timeout += default sleep ; } else { throw new runtime exception ( str ) ; } } catch ( interrupted exception e ) { throw new runtime exception ( e ) ; } } return super . submit ( task ) ; } }	this is a thread safe way to avoid rejection exception.
public void test subtract math context diff scale pos neg ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = - num ; string c = str ; int c scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; math context mc = new math context ( num , rounding mode . down ) ; big decimal result = a number . subtract ( b number , mc ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	subtract two numbers of different scales using mathcontext ; the first is positive.
protected xsqlda allocate x ( row descriptor row descriptor ) { if ( row descriptor == null || row descriptor . get count ( ) == num ) { final xsqlda x sql da = new xsqlda ( num ) ; x sql da . sqld = x sql da . sqln = num ; return x sql da ; } final xsqlda x sql da = new xsqlda ( row descriptor . get count ( ) ) ; for ( int idx = num ; idx < row descriptor . get count ( ) ; idx ++ ) { final field descriptor field descriptor = row descriptor . get field descriptor ( idx ) ; final xsqlvar x sql var = x sql da . sqlvar [ idx ] ; x sql var . sqltype = ( short ) ( field descriptor . get type ( ) | num ) ; x sql var . sqlsubtype = ( short ) field descriptor . get sub type ( ) ; x sql var . sqlscale = ( short ) field descriptor . get scale ( ) ; x sql var . sqllen = ( short ) field descriptor . get length ( ) ; x sql var . sqlind = new short by reference ( ) ; final int required data size = field descriptor . is varying ( ) ? field descriptor . get length ( ) + num : field descriptor . get length ( ) + num ; x sql var . sqldata = new memory ( required data size ) ; } return x sql da ; }	creates an xsqlda , populates type information and allocates memory for the sqldata fields .
public static void overwrite ( long [ ] vector , long val , int offset , int len ) { int idx = offset > > num ; int bit idx = offset & num ; int truncated val len = math . min ( len , num - bit idx ) ; vector [ idx ] &= ~ ( mask below ( truncated val len ) << bit idx ) ; vector [ idx ] |= val << bit idx ; if ( len != truncated val len ) { long mask = mask below ( len - truncated val len ) ; vector [ idx + num ] &= ~ mask ; vector [ idx + num ] |= ( val > > > truncated val len ) ; } }	overwrites a bit range within the vector .
public static boolean is empty ( string string ) { if ( null == string ) return bool ; return string . equals ( empty ) ; }	check if the given string is empty or null.
public void add scroll view listener ( wx scroll view listener ) { if ( ! m scroll view listeners . contains ( scroll view listener ) ) { m scroll view listeners . add ( scroll view listener ) ; } }	add listener for scrollview .
callbacks try get callbacks ( callbacks old callbacks ) { synchronized ( m lock ) { if ( m stopped ) { return null ; } if ( m callbacks == null ) { return null ; } final callbacks callbacks = m callbacks . get ( ) ; if ( callbacks != old callbacks ) { return null ; } if ( callbacks == null ) { log . w ( tag , str ) ; return null ; } return callbacks ; } }	gets the callbacks object.
public void begin update memory used ( long bytes used , boolean will send event ) ;	called at the beginning of updatememoryused .
@ override public point translate java2 d ( d java2 d ) { insets insets = get insets ( ) ; int x = ( int ) ( java2 d . get x ( ) * this . scale x + insets . left ) ; int y = ( int ) ( java2 d . get y ( ) * this . scale y + insets . top ) ; return new point ( x , y ) ; }	translates a java2d point on the chart to a screen location .
private void update traffic projections ( ) { list < air map traffic > updated = new array list < > ( ) ; for ( air map traffic traffic : all traffic ) { if ( traffic . get ground speed kt ( ) > - num && traffic . get true heading ( ) > - num ) { all traffic . remove ( traffic ) ; coordinate projected = projected coordinate ( traffic ) ; traffic . set coordinate ( projected ) ; traffic . set show alert ( bool ) ; all traffic . add ( traffic ) ; updated . add ( traffic ) ; } } notify updated ( updated ) ; }	update all the traffic projections based on their heading and ground speed.
public static void log stack trace ( level level , throwable throwable ) { log stack trace ( level , throwable , null ) ; }	logs the stack trace for the given throwable if logger is initialized else prints the stack trace using system.
@ override public int read ( ) throws io { int ch = super . read ( ) ; if ( ch != - num ) { branch . write ( ch ) ; } return ch ; }	reads a single byte from the proxied input stream and writes it to the associated output stream .
public static string decode bcd ( final short bcd ) { return string . format ( str , ( bcd & num ) > > num , bcd & num ) ; }	decodes a binary - coded decimal into a string and returns it .
public void draw background ( graphics g ) { g . fill rect ( num , num , get width ( ) , get height ( ) ) ; }	assume that the graphics has been set with the paint / color needed , just render the shape of the background .
public void put ( int key , int value ) { int i = binary search ( m keys , num , m size , key ) ; if ( i >= num ) { m values [ i ] = value ; } else { i = ~ i ; if ( m size >= m keys . length ) { int n = math . max ( m size + num , m keys . length * num ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } if ( m size - i != num ) { system . arraycopy ( m keys , i , m keys , i + num , m size - i ) ; system . arraycopy ( m values , i , m values , i + num , m size - i ) ; } m keys [ i ] = key ; m values [ i ] = value ; m size ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
public void add layout editor ( layout editor panel ) { if ( panels . size ( ) > num ) { for ( int i = num ; i < panels . size ( ) ; i ++ ) { layout editor ed = panels . get ( i ) ; if ( ed == panel ) { return ; } } } panels . add ( panel ) ; }	keeps track of layouteditor panels that are using this layoutblock.
void trigger wildcard expander ( final collection < file > all files , final wildcard context wildcard context ) throws io { log . debug ( str , all files ) ; if ( all files . is empty ( ) ) { final string message = string . format ( str , wildcard context . get wildcard ( ) ) ; log . warn ( message ) ; throw new io ( message ) ; } if ( wildcard expander handler != null ) { try { wildcard expander handler . apply ( all files ) ; } catch ( final io e ) { throw e ; } catch ( final exception e ) { log . debug ( str , e ) ; throw new io ( str + e . get message ( ) ) ; } } }	uses the wildcardexpanderhandler to process all found files and directories .
@ post @ consumes ( { media type . application xml , media type . application json } ) @ produces ( { media type . application xml , media type . application json } ) @ check permission ( roles = { role . tenant admin } ) @ path ( str ) public ip interface rest rep create ip interface ( @ path param ( str ) uri id , ip interface create param create param ) throws database exception { host host = query object ( host . class , id , bool ) ; validate ip interface data ( create param , null ) ; ip interface ip interface = new ip interface ( ) ; ip interface . set host ( host . get id ( ) ) ; ip interface . set id ( uri . create id ( ip interface . class ) ) ; populate ip interface ( create param , ip interface ) ; db client . create object ( ip interface ) ; audit op ( operation type enum . create host ipinterface , bool , null , ip interface . audit parameters ( ) ) ; return map ( ip interface ) ; }	creates a new ip interface for a host .
protected list < i > collect edit proposals ( ) { list < i > proposals = new array list < i > ( ) ; view selected view = get selected view ( ) ; if ( selected view != null ) { if ( proposal providers != null ) { for ( i provider : proposal providers ) { for ( i edit proposal : provider . get proposals ( selected view ) ) { if ( edit proposal . is applicable ( ) ) proposals . add ( edit proposal ) ; } } } } return proposals ; }	collects all edit proposals from contained poroposal providers .
public extension query ( string plugin id , string extension point name , string attribute name ) { this . plugin id = extension point name . contains ( str ) ? null : plugin id ; this . extension point name = extension point name ; this . attribute name = attribute name ; }	create a new instance .
private void ensure namespace exists ( result result ) { docker image image = docker image . from image name ( result . name ) ; if ( image . get namespace ( ) == null ) { result . name = string . format ( str , default namespace , image . get repository ( ) ) ; } }	ensures that an image name has a namespace prefix.
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 , k k5 , v v5 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; return map ; }	returns map containing the given entries .
public void test filtered classifier ( ) { instances data ; int i ; if ( m == null ) { return ; } try { data = get filtered classifier data ( ) ; m . build classifier ( data ) ; for ( i = num ; i < data . num instances ( ) ; i ++ ) { m . classify instance ( data . instance ( i ) ) ; } } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } }	tests the filter in conjunction with the filteredclassifier.
public static string upper first char ( string string ) { if ( string == null ) return null ; if ( string . length ( ) <= num ) return string . to lower case ( ) ; string builder sb = new string builder ( string ) ; sb . set char at ( num , character . to upper case ( sb . char at ( num ) ) ) ; return sb . to string ( ) ; }	changes the first letter of the passed string to upper case .
protected int choose random index based on proportions ( double [ ] proportion array , random random ) { double prob sum ; double val ; int index ; double sum ; prob sum = utils . sum ( proportion array ) ; val = random . next double ( ) * prob sum ; index = num ; sum = num ; while ( ( sum <= val ) && ( index < proportion array . length ) ) { sum += proportion array [ index ++ ] ; } return index - num ; }	returns a random index based on the given proportions.
private void check width ( final int [ ] rect ) { final int x1 = rect [ num ] ; final int y2 = rect [ num ] ; final int y1 = y2 + rect [ num ] ; final int x2 = x1 + rect [ num ] ; if ( x1 < page x1 ) { page x1 = x1 ; } if ( x2 > page x2 ) { page x2 = x2 ; } if ( y1 > page y1 ) { page y1 = y1 ; } if ( y2 < page y2 ) { page y2 = y2 ; } }	track actual size of shape.
@ not null public static map < rad component , list < rad component > > group siblings ( @ not null list < ? extends rad component > components ) { map < rad component , list < rad component > > sibling lists = new hash map < rad component , list < rad component > > ( ) ; if ( components . is empty ( ) ) { return sibling lists ; } if ( components . size ( ) == num ) { rad component component = components . get ( num ) ; sibling lists . put ( component . get parent ( ) , collections . singleton list ( component ) ) ; return sibling lists ; } for ( rad component component : components ) { rad component parent = component . get parent ( ) ; list < rad component > children = sibling lists . get ( parent ) ; if ( children == null ) { children = new array list < rad component > ( ) ; sibling lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling lists ; }	partitions the given list of components into a map where each value is a list of siblings , in the same order as in the original list , and where the keys are the parents ( or null for the components that do not have a parent ).
private int count non newline ( string str , int off , int len ) { for ( int cnt = num ; cnt < len ; cnt ++ ) { final int pos = off + cnt ; if ( str . char at ( pos ) == unix newline ) { return cnt ; } if ( str . char at ( pos ) == carriage return ) { return cnt ; } } return len ; }	count the number of non - newline characters before first newline in the string .
private static int convert span to sparse grid ( int cur ix , int span , tree set < integer > indexes ) { int last ix = cur ix + span ; int ret span = num ; for ( integer ix : indexes ) { if ( ix <= cur ix ) continue ; if ( ix >= last ix ) break ; ret span ++ ; } return ret span ; }	spanning is specified in the uncompressed grid number.
@ override public boolean equals ( object other rules ) { if ( this == other rules ) { return bool ; } if ( other rules instanceof zone rules ) { zone rules other = ( zone rules ) other rules ; return arrays . equals ( standard transitions , other . standard transitions ) && arrays . equals ( standard offsets , other . standard offsets ) && arrays . equals ( savings instant transitions , other . savings instant transitions ) && arrays . equals ( wall offsets , other . wall offsets ) && arrays . equals ( last rules , other . last rules ) ; } return bool ; }	checks if this set of rules equals another.
public string description ( ) { string builder sb = new string builder ( ) ; if ( is combo ( ) ) { int i = num ; for ( new combo leg leg : m combo legs ) { if ( i ++ > num ) { sb . append ( str ) ; } sb . append ( leg . to string ( ) ) ; } } else { sb . append ( m symbol ) ; app ( sb , m sec type ) ; app ( sb , m exchange ) ; if ( m exchange != null && m exchange . equals ( str ) && m primary exch != null ) { app ( sb , m primary exch ) ; } app ( sb , m expiry ) ; if ( m strike != num ) { app ( sb , m strike ) ; } if ( m right != right . none ) { app ( sb , m right ) ; } } return sb . to string ( ) ; }	returns a text description that can be used for display .
public void add claimed signer role ( final string claimed signer role ) { if ( ( claimed signer role == null ) || ( claimed signer role . length ( ) == num ) ) { throw new null pointer exception ( str ) ; } if ( claimed signer roles == null ) { claimed signer roles = new array list < string > ( ) ; } claimed signer roles . add ( claimed signer role ) ; }	adds a claimed signer role.
@ suppress warnings ( str ) @ gwt incompatible ( str ) public static < k extends object , v extends object > void write map ( map < k , v > map , object output stream stream ) throws io { stream . write int ( map . size ( ) ) ; for ( map . entry < k , v > entry : map . entry set ( ) ) { stream . write object ( entry . get key ( ) ) ; stream . write object ( entry . get value ( ) ) ; } }	stores the contents of a map in an output stream , as part of serialization.
protected void sleep ( int sleep millis , int sleep nanos ) throws interrupted exception { thread . sleep ( sleep millis , sleep nanos ) ; }	sub classes ( tests basically ) can use this to override how the sleep is being done.
public static void restore previous out and err stream ( ) { if ( ! already muted ) { return ; } system . set out ( latest out ) ; system . set err ( latest err ) ; already muted = bool ; }	allow again printing to previous streams that were muted.
public static big integer crt ( list < big integer > congs , list < big integer > moduli ) { big integer [ ] cs = array converter . convert list to array ( congs ) ; big integer [ ] ms = array converter . convert list to array ( moduli ) ; return crt ( cs , ms ) ; }	computes chinese reminder theorem : x = = congs [ i ] mod moduli [ i ].
private int measure height ( int measure spec ) { int result = num ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; m ascent = ( int ) m text paint . ascent ( ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = ( int ) ( - m ascent + m text paint . descent ( ) ) + get padding top ( ) + get padding bottom ( ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return result ; }	determines the height of this view.
public byte vector put byte array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { system . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }	puts an array of bytes into this byte vector.
protected < t extends task service document < e > , e extends enum < e > > t wait for task completion ( string document self link , class < t > type ) throws throwable { return wait for property value ( document self link , type , task service document . field name task stage , arrays . as list ( task stage . finished , task stage . failed , task stage . cancelled ) , bool , wait for stage change count longer ( ) ) ; }	waits until the given task completes and returns its final state .
public action ( string content , int priority ) { this . content = content . trim ( ) ; this . priority = priority ; }	creates a new action object with specified content and line number .
private list < end island > find surrounding islands ( int chunk x , int chunk y , int chunks per fragment x , int chunks per fragment y ) { list < end island > result = new linked list < end island > ( ) ; for ( int y = - surrounding chunks ; y <= chunks per fragment y + surrounding chunks ; y ++ ) { for ( int x = - surrounding chunks ; x <= chunks per fragment x + surrounding chunks ; x ++ ) { end island island = try create end island ( chunk x + x , chunk y + y ) ; if ( island != null ) { result . add ( island ) ; } } } return result ; }	returns a list of all islands that might be touching a chunk - area .
void insert function2 ( byte buffer bb ) { int base sec = ( int ) ( window id > > num ) ; bb . put int ( base sec ) ; integer oper id = operator id ; for ( int i = num ; i < num ; i ++ ) { byte num = ( byte ) ( oper id > > num * ( num - i ) ) ; bb . put ( num ) ; } bb . put short ( ( short ) ( window id & num ) ) ; for ( int i = num ; i < num ; i ++ ) { byte num = ( byte ) ( tuple id > > num * ( num - i ) ) ; bb . put ( num ) ; } }	4b basesec | 3b operatorid | 2b windowid | 3b tupleid.
private static boolean calculate gap ( rectangle a , rectangle b , rectangle gap ) { if ( a . intersects ( b ) ) { gap . width = num ; return bool ; } int ax1 = a . x ; int ax2 = a . x + a . width ; int ay1 = a . y ; int ay2 = a . y + a . height ; int bx1 = b . x ; int bx2 = b . x + b . width ; int by1 = b . y ; int by2 = b . y + b . height ; int x overlap = math . min ( ax2 , bx2 ) - math . max ( ax1 , bx1 ) ; int y overlap = math . min ( ay2 , by2 ) - math . max ( ay1 , by1 ) ; if ( x overlap <= num && y overlap <= num ) { gap . width = num ; return bool ; } if ( x overlap > num ) { gap . x = math . max ( ax1 , bx1 ) ; gap . y = ( ay1 > by1 ) ? by2 : ay2 ; gap . width = x overlap ; gap . height = - y overlap ; } if ( y overlap > num ) { gap . x = ( ax1 > bx1 ) ? bx2 : ax2 ; gap . y = math . max ( ay1 , by1 ) ; gap . width = - x overlap ; gap . height = y overlap ; } return bool ; }	calculate the gap rectangle between two rectangles.
public boolean next tile ( ) throws model control exception { boolean moved to row = super . next tile ( ) ; if ( moved to row ) { cur tile = get tile index ( ) ; set display field value ( txt parent index , parent idx ) ; set display field value ( txt choice , choices [ cur tile ] ) ; set display field value ( txt index , integer . to string ( cur tile ) ) ; } return moved to row ; }	moves the current tile position to the next available tile .
public boolean has myomer booster ( ) { for ( mounted m equip : get misc ( ) ) { misc type mtype = ( misc type ) m equip . get type ( ) ; if ( mtype . has flag ( misc type . f masc ) && ! m equip . is inoperable ( ) ) { return bool ; } } return bool ; }	does this ba mount a myomer booster ?.
public static boolean is intent available ( context context , string action ) { final package manager package manager = context . get package manager ( ) ; final intent intent = new intent ( action ) ; log . d ( mp tag , str + action ) ; list < resolve info > list = package manager . query intent services ( intent , package manager . match default only ) ; return list . size ( ) > num ; }	indicates whether the specified action can be used as an intent.
@ known failure ( str ) public void test wrap 02 ( ) throws ssl { string host = str ; int port = num ; byte buffer bb = byte buffer . allocate ( num ) ; byte buffer [ ] bb a = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; ssl sse = get engine ( host , port ) ; sse . set use client mode ( bool ) ; try { sse . wrap ( bb a , - num , num , bb ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . wrap ( bb a , num , - num , bb ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . wrap ( bb a , bb a . length + num , bb a . length , bb ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . wrap ( bb a , num , bb a . length + num , bb ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } }	javax . net . ssl . sslengine # wrap ( bytebuffer [ ] srcs , int offset , int length , bytebuffer dst ) exception case : indexoutofboundsexception should be thrown .
private void send connect ( ) throws io { int port = url . get port ( ) ; requests . set ( num , http connect + str + connect request uri ( url ) + str + http version , null ) ; requests . set if not set ( str , user agent ) ; string host = url . get host ( ) ; if ( port != - num && port != url . get default port ( ) ) { host += str + string . value of ( port ) ; } requests . set if not set ( str , host ) ; requests . set if not set ( str , accept string ) ; if ( http . get http keep alive set ( ) ) { requests . set if not set ( str , str ) ; } set preemptive proxy authentication ( requests ) ; if ( logger . is loggable ( platform logger . level . fine ) ) { logger . fine ( requests . to string ( ) ) ; } http . write requests ( requests , null ) ; }	send a connect request for establishing a tunnel to proxy server.
private boolean is self signed ( x509 certificate cert ) { return signed by ( cert , cert ) ; }	returns true if the certificate is self - signed , false otherwise .
@ request mapping ( value = { str , str } , method = request method . put ) @ response body public rest wrapper insert ( @ model attribute ( str ) @ valid user roles user roles , binding result binding result , principal principal ) { rest wrapper rest wrapper = null ; if ( binding result . has errors ( ) ) { binding result error binding result error = new binding result error ( ) ; return binding result error . error message ( binding result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . user roles jpa user roles = new com . wipro . ats . bdre . md . dao . jpa . user roles ( ) ; jpa user roles . set user role id ( user roles . get user role id ( ) ) ; jpa user roles . set role ( user roles . get role ( ) ) ; users users = new users ( ) ; users . set username ( user roles . get username ( ) ) ; jpa user roles . set users ( users ) ; integer user roles id = user roles dao . insert ( jpa user roles ) ; user roles . set user role id ( user roles id ) ; rest wrapper = new rest wrapper ( user roles , rest wrapper . ok ) ; logger . info ( str + user roles . get user role id ( ) + str + principal . get name ( ) + user roles ) ; } catch ( exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls proc insertuserroles and adds a record in userroles table.
public set < word token > nearest words ( final int distance , final word token ... start ) { return nearest words ( distance , null , arrays . as list ( start ) ) ; }	find the nearest neighbours within dependency distance links of the provided start dependencies .
public derutc ( date time ) { simple date format date f = new simple date format ( str ) ; date f . set time zone ( new simple time zone ( num , str ) ) ; this . time = strings . to byte array ( date f . format ( time ) ) ; }	base constructer from a java.
public void add ( string category , string [ ] titles , double [ ] values ) { m categories . add ( category ) ; m titles . add ( titles ) ; m values . add ( values ) ; }	adds a new value to the series .
public void rewind ( ) { synchronized ( used ) { for ( parameter pair pair : used ) { current . add parameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }	rewind the configuration to the initial situation.
public list < interval > merge ( list < interval > intervals ) { list < interval > res = new array list < > ( ) ; if ( intervals == null || intervals . size ( ) == num ) { return res ; } collections . sort ( intervals , null ) ; interval prev = null ; for ( interval i : intervals ) { if ( prev == null || prev . end < i . start ) { res . add ( i ) ; prev = i ; } else if ( i . end > prev . end ) { prev . end = i . end ; } } return res ; }	sort and merge , o ( nlogn ) time.
private string format type ( object type rep ) { string tokenizer tokenizer = new string tokenizer ( type rep . to string ( ) , str , bool ) ; string builder sb = new string builder ( ) ; while ( tokenizer . has more tokens ( ) ) { string token = tokenizer . next token ( ) ; if ( token . length ( ) == num || token . last index of ( str ) == - num ) sb . append ( token ) ; else { int index = token . last index of ( str ) ; sb . append ( token . substring ( index + num ) ) ; } } return sb . to string ( ) ; }	outputs the simple name of the type.
@ not null public static string sha1 ( @ not null file key store file ) throws exception { return sha1 ( key store file , null , null ) ; }	get the sha1 hash of the first signing certificate inside a keystore , encoded as base16 ( each byte separated by ' : ' ) .
@ override public void pan domain axes ( double pan range , plot rendering info info , d source ) { xy subplot = find subplot ( info , source ) ; if ( subplot == null ) { return ; } if ( ! subplot . is domain pannable ( ) ) { return ; } plot rendering info subplot info = info . get subplot info ( info . get subplot index ( source ) ) ; if ( subplot info == null ) { return ; } for ( int i = num ; i < subplot . get domain axis count ( ) ; i ++ ) { value axis domain axis = subplot . get domain axis ( i ) ; if ( domain axis != null ) { domain axis . pan ( pan range ) ; } } }	pans all domain axes by the specified percentage .
private void init ( ) { start controller = new pour start controller ( ) ; start controller . set check view ( this ) ; wave controller = new wave controller ( ) ; wave controller . set check view ( this ) ; pour finish controller finish controller = new pour finish controller ( ) ; finish controller . set check view ( this ) ; tick controller tick controller = new tick controller ( ) ; tick controller . set check view ( this ) ; list < base controller > finish controllers = new array list < > ( ) ; finish controllers . add ( finish controller ) ; finish controllers . add ( tick controller ) ; this . finish controllers = finish controllers ; }	basic animations to build the liquidbutton.
private j create icon label ( j check box ) { check box . set opaque ( bool ) ; check box . set size ( check box . get minimum size ( ) ) ; image image = new buffered image ( check box . get width ( ) , check box . get height ( ) , transparency . translucent ) ; graphics g = image . get graphics ( ) ; check box . paint ( g ) ; g . dispose ( ) ; return new j ( new image icon ( image ) ) ; }	creates an image of the checkbox and puts it in a label .
public void close window ( ) { window event ev = new window event ( frame , window event . window closing ) ; frame . dispatch event ( ev ) ; }	closes the window ( and opendial ) .
public void engine delete entry ( string alias ) throws key store exception { synchronized ( entries ) { entries . remove ( alias . to lower case ( locale . english ) ) ; } }	deletes the entry identified by the given alias from this keystore .
public disjoint sets ( int num elements ) { array = new int [ num elements ] ; arrays . fill ( array , - num ) ; }	construct a disjoint sets object .
public final void print clusters ( print writer out , list < cluster data > cluster data , int [ ] mat index to msg internal id ) throws ade exception { if ( m final clusters == null ) { update clusters ( cluster data , mat index to msg internal id ) ; } for ( map . entry < string , collection < integer > > entry : m final clusters . entry set ( ) ) { final string n = entry . get key ( ) ; final collection < integer > c = entry . get value ( ) ; out . printf ( str , n ) ; for ( int m : c ) { out . printf ( str , mat index to msg internal id [ m ] ) ; } out . println ( ) ; } }	prints out the cluster information .
protected void add to gui ( j gui , j b , string cmd ) { b . set action command ( cmd ) ; b . add action listener ( this ) ; gui . add ( b ) ; }	adds a feature to the gui attribute of the e00layer object.
public synchronized void remove ( int index ) { m categories . remove ( index ) ; m values . remove ( index ) ; }	removes an existing value from the series .
static token stream wrap ( string field name , analyzer index analyzer , string content , char split char ) throws io { if ( index analyzer . get offset gap ( field name ) != num ) { throw new illegal argument exception ( str + field name + str ) ; } int split char idx = content . index of ( split char ) ; if ( split char idx == - num ) { return index analyzer . token stream ( field name , content ) ; } token stream sub token stream = index analyzer . token stream ( field name , content . substring ( num , split char idx ) ) ; return new multi value token stream ( sub token stream , field name , index analyzer , content , split char , split char idx ) ; }	note : the caller must remember to close the tokenstream eventually .
public final boolean check trace ( polyline p polyline , int p half width , int p layer , net nos list p net no arr , int p clearance class no , int p max recursion depth , int p max via recursion depth , int p max spring over recursion depth ) { awtree shape search search tree = search tree manager . get default tree ( ) ; int compensated half width = p half width + search tree . get clearance compensation ( p clearance class no , p layer ) ; array list < shape tile > trace shapes = p polyline . offset shapes ( compensated half width , num , p polyline . corner count ( ) ) ; for ( int index = num ; index < trace shapes . size ( ) ; ++ index ) { shape tile curr trace shape = trace shapes . get ( index ) ; brd from side from side = new brd from side ( p polyline , index + num , curr trace shape ) ; boolean check shove ok = shove trace algo . shove trace check ( curr trace shape , from side , null , p layer , p net no arr , p clearance class no , p max recursion depth , p max via recursion depth , p max spring over recursion depth , null ) ; if ( ! check shove ok ) return bool ; } return bool ; }	checks , if a trace polyline with the input parameters can be inserted while shoving aside obstacle traces and vias .
public static void delete ( file file or folder ) throws io { if ( file or folder != null ) delete ( file or folder . to path ( ) ) ; }	a method that will delete a file or folder.
public static double [ ] expand array d ( int buffer size , double [ ] current array ) { if ( current array == null ) { return new double [ buffer size * num ] ; } int length = current array . length ; double [ ] ret = new double [ length + buffer size * num ] ; system . arraycopy ( current array , num , ret , num , length ) ; return ret ; }	create an array to hold double data for 3d polygons and lines .
protected int encode ( double value , double lower , double upper , int nbits ) { if ( value < lower ) return num ; int maxval = ( int ) ( math . pow ( num , nbits ) - num ) ; if ( value >= upper ) return maxval ; return ( int ) ( ( value - lower ) * ( ( maxval - num ) / ( upper - lower ) ) ) ; }	encode value as an nbits unsigned integer.
public long skip bytes ( long n ) throws io { long count = num ; long gotsofar = num ; if ( input stream == null ) { reopen ( ) ; if ( input stream == null ) { reopen ( ) ; throw new io ( str ) ; } } while ( count < n ) { gotsofar = input stream . skip ( n - count ) ; if ( gotsofar == num ) { debug . error ( str + n + str ) ; break ; } count += gotsofar ; } count ( ( int ) count ) ; return count ; }	skip over n bytes in the input file.
private void create lock ( ) throws io { synchronized ( lockable file writer . class ) { if ( ! lock file . create new file ( ) ) { throw new io ( str + lock file . get absolute path ( ) + str ) ; } lock file . delete on exit ( ) ; } }	creates the lock file .
public void handle tbl ds ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; wspp ds vb = ( wspp ds ) get view bean ( wspp ds . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . populate values ( ( string ) get display field value ( str ) ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; forward to ( ) ; } }	handles edit ldap attribute mapping request .
private v do get ( object key ) { if ( key == null ) throw new null pointer exception ( ) ; comparator < ? super k > cmp = comparator ; outer : for ( ; ; ) { for ( node < k , v > b = find predecessor ( key , cmp ) , n = b . next ; ; ) { object v ; int c ; if ( n == null ) break outer ; node < k , v > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == num ) { @ suppress warnings ( str ) v vv = ( v ) v ; return vv ; } if ( c < num ) break outer ; b = n ; n = f ; } } return null ; }	gets value for key . almost the same as findnode , but returns the found value ( to avoid retries during re - reads ).
void handle swf loaded event ( swf loaded event e ) { dump swf loaded line ( e ) ; }	called when a swf has been loaded by the player.
private void quick reply ( ) { quick reply sms message = sms popup pager . get active message ( ) ; quick reply ( quick reply sms message . get reply text ( ) ) ; }	show the quick reply dialog , resetting the text in the edittext and storing the current smsmmsmessage ( in case another message comes in ).
@ override protected synchronized void write ( long offset , byte [ ] b ) throws io { if ( byte buffer != null ) { byte buffer . position ( ( int ) offset ) ; byte buffer . put ( b ) ; } else { throw new io ( str + get path ( ) + str ) ; } }	writes bytes to the underlying rrd file on the disk.
public boolean has changed ( ) { return system . identity hash code ( config ) != initial hash ; }	checks if the config has changed since it was loaded .
void fix compatibility ( view root ) { queue < view > queue = new linked list < view > ( ) ; queue . add ( root ) ; view view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof view group ) { view group group = ( view group ) view ; for ( int i = num ; i < group . get child count ( ) ; i ++ ) { queue . add ( group . get child at ( i ) ) ; } } } }	iterate through each view in the view hiearchy and implement standout specific compatibility workarounds.
protected abstract set < socket address > bind internal ( list < ? extends socket address > local addresses ) throws exception ;	starts the acceptor , and register the given addresses.
public void substitute header ( int state , string header ) throws auth login exception { if ( debug . message enabled ( ) ) { debug . message ( str + state + str + header ) ; } if ( state > state length ) { throw new auth login exception ( bundle name , str , new object [ ] { new integer ( state ) } ) ; } callback [ ] ext = get callback ( state ) ; if ( ext . length <= num ) { throw new auth login exception ( bundle name , str , null ) ; } if ( ( header != null ) && ( header . length ( ) != num ) ) { page properties callback pc = ( page properties callback ) ( ( callback [ ] ) internal . get ( state - num ) ) [ num ] ; pc . set header ( header ) ; } }	use this method to replace the header text from the xml file with new text.
public static service create service ( pattern timetable timetable ) { calendar calendar = new calendar ( ) ; calendar . monday = timetable . monday ? num : num ; calendar . tuesday = timetable . tuesday ? num : num ; calendar . wednesday = timetable . wednesday ? num : num ; calendar . thursday = timetable . thursday ? num : num ; calendar . friday = timetable . friday ? num : num ; calendar . saturday = timetable . saturday ? num : num ; calendar . sunday = timetable . sunday ? num : num ; string builder name builder = new string builder ( str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; name builder . append ( timetable . monday ? str : str ) ; service service = new service ( name builder . to string ( ) ) ; calendar . start date = num ; calendar . end date = num ; service . calendar = calendar ; return service ; }	creates a gtfs - lib service object based on the information in the given patterntimetable , which is usually part of a modification deserialized from json .
public boolean remove ( image info object ) { final int location = get location ( object ) ; final boolean removed = data . remove ( object ) ; notify item removed ( location ) ; return removed ; }	removes the first occurrence of the specified object from the data .
public t allowed users ( user ... users ) { list < user > users list = arrays . as list ( users ) ; this . user predicate = null ; return instance ( ) ; }	allow a list of users to use this menu.
v find distributed device ( string device name ) throws v { return find distributed device ( device name , bool ) ; }	finds the distributed device with the passed name .
static copy state read copy state ( data input in ) throws io { byte [ ] infos bytes = new byte [ in . read v ( ) ] ; in . read bytes ( infos bytes , num , infos bytes . length ) ; long gen = in . read v ( ) ; long version = in . read v ( ) ; map < string , file meta data > files = read files meta data ( in ) ; int count = in . read v ( ) ; set < string > completed merge files = new hash set < > ( ) ; for ( int i = num ; i < count ; i ++ ) { completed merge files . add ( in . read string ( ) ) ; } long primary gen = in . read v ( ) ; return new copy state ( files , version , gen , infos bytes , completed merge files , primary gen , null ) ; }	pulls copystate off the wire.
public void notify tasks ( ) { if ( tracker . should interrupt task ( ) ) { for ( thread t : thread map . values ( ) ) { t . interrupt ( ) ; } } }	interrupts currently running tasks .
public request params ( object ... keys and values ) { int len = keys and values . length ; if ( len % num != num ) throw new illegal argument exception ( str ) ; for ( int i = num ; i < len ; i += num ) { string key = string . value of ( keys and values [ i ] ) ; string val = string . value of ( keys and values [ i + num ] ) ; put ( key , val ) ; } }	constructs a new requestparams instance and populate it with multiple initial key / value string param .
public boolean confirm overwrite ( final file file ) { string message = str + file . get name ( ) + str ; object [ ] options = { str , str } ; return j . yes option == j . show option dialog ( null , message , str , j . default option , j . warning message , null , options , options [ num ] ) ; }	ask user whether to overwrite the give existing file .
public tv show update datasource task ( string datasource ) { super ( bundle . get string ( str ) + str + datasource + str ) ; tv show list = tv show list . get instance ( ) ; data sources = new array list < > ( num ) ; data sources . add ( datasource ) ; }	instantiates a new scrape task - to update a single datasource.
public int find line ( int offset ) { int line = line starts . length - num ; while ( ( line starts [ line ] > offset ) && ( line > num ) ) { line -- ; } return line ; }	line in the original source file for the given offset .
public void clear ( ) { set < sensor > old selection = new hash set < sensor > ( selection ) ; selection . clear ( ) ; if ( ! old selection . is empty ( ) ) { fire selection changed ( old selection , selection ) ; } }	clear this sensor selection model .
public object new non movable array ( class < ? > component type , int length ) { return array . new instance ( component type , length ) ; }	returns an array allocated in an area of the java heap where it will never be moved.
private void load file recursively ( string path , map < string , thrift file element > loaded files ) throws io { thrift file element element = null ; file dir = null ; file file = find first existing ( path , null ) ; if ( file != null ) { file = file . get canonical file ( ) ; if ( loaded files . contains key ( file . get absolute path ( ) ) ) { return ; } dir = file . get parent file ( ) ; element = load single file ( file . get parent file ( ) , file . get name ( ) ) ; } if ( element == null ) { throw new file not found exception ( str + path + str + include paths ) ; } loaded files . put ( file . get absolute path ( ) , element ) ; immutable list < include element > includes = element . includes ( ) ; if ( includes . size ( ) > num ) { include paths . add first ( dir ) ; for ( include element include : includes ) { if ( ! include . is cpp ( ) ) { load file recursively ( include . path ( ) , loaded files ) ; } } include paths . remove first ( ) ; } }	loads and parses a thrift file and all files included ( both directly and transitively ) by it .
public void assure proxy ok ( ) { if ( socket . is closed ( ) ) { restart ( ) ; } }	assure that proxy is in a stable status .
@ override public boolean add ( i message ) { return add ( message , bool ) ; }	this adds a message object to the internal message cache .
public key ( byte [ ] hash ) { if ( hash . length != sh hash length ) { throw new illegal argument exception ( str + hash . length ) ; } system . arraycopy ( hash , num , this . hash , num , sh hash length ) ; }	creates a key with this hash.
public static int [ ] concat all int ( int [ ] ... arrays ) { int total length = num ; final int sub array count = arrays . length ; for ( int i = num ; i < sub array count ; ++ i ) { total length += arrays [ i ] . length ; } int [ ] result = arrays . copy of ( arrays [ num ] , total length ) ; int offset = arrays [ num ] . length ; for ( int i = num ; i < sub array count ; ++ i ) { system . arraycopy ( arrays [ i ] , num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of int arrays into a single array .
private static road permission road flag comparision ( way iosm way , string new tag , string new value , enum set < edge store . edge flag > forward expected , enum set < edge store . edge flag > backward expected ) { way osm way = new way ( ) ; string joiner string joiner = new string joiner ( str ) ; for ( osm . tag tag : iosm way . tags ) { osm way . add tag ( tag . key , tag . value ) ; string joiner . add ( tag . key + str + tag . value ) ; } if ( new tag != null && new value != null ) { osm way . add tag ( new tag , new value ) ; string joiner . add ( new tag + str + new value ) ; } set < edge store . edge flag > forward filtered ; set < edge store . edge flag > backward filtered ; road permission road permission = traversal permission labeler . get permissions ( osm way ) ; forward filtered = filter flags ( road permission . forward ) ; backward filtered = filter flags ( road permission . backward ) ; string tags = str + string joiner . to string ( ) ; assert equals ( tags , forward expected , forward filtered ) ; assert equals ( tags , backward expected , backward filtered ) ; return road permission ; }	makes comparision of way with osmway tags and newtag with newvalue and compares forward and backward permissions with expected permissions copy of osmway is made since otherwise tags would be changed.
public byte [ ] read bytes ( ) throws io { int len = read int ( ) ; if ( len == - num ) { return null ; } byte [ ] b = data utils . new bytes ( len ) ; in . read fully ( b ) ; return b ; }	read a byte array .
protected int chunk size ( int n ) { int power = ( n == num || n == num ) ? initial chunk power : math . min ( initial chunk power + n - num , abstract spined buffer . max chunk power ) ; return num << power ; }	how big should the nth chunk be ?.
public string use relative path tip text ( ) { return str ; }	tip text suitable for displaying int the gui.
public joiner join ( class < ? extends data object > clazz , string alias , uri ... ids ) { return join ( clazz , alias , new array list < uri > ( arrays . as list ( ids ) ) ) ; }	starts a new query not related to a previous class query .
public void close file ( ) { close file ( bool ) ; }	closes the current tab.
public list < interface > show interface ( ) throws network device controller exception { list < interface > interfaces = new array list < interface > ( ) ; ssh [ ] prompts = { ssh . pound , ssh . greater than } ; string builder buf = new string builder ( ) ; ssh prompt = send wait for ( mds . get string ( str ) , num , prompts , buf ) ; string [ ] lines = get lines ( buf ) ; string [ ] regex = { mds . get string ( str ) , mds . get string ( str ) , mds . get string ( str ) , mds . get string ( str ) , mds . get string ( str ) , mds . get string ( str ) } ; string [ ] groups = new string [ num ] ; interface intf = null ; for ( string line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case num : intf = new interface ( groups [ num ] ) ; intf . set status ( groups [ num ] ) ; interfaces . add ( intf ) ; break ; case num : intf . set description ( groups [ num ] ) ; break ; case num : intf . set wwpn ( groups [ num ] ) ; break ; case num : intf . set mode ( groups [ num ] ) ; intf . set fcid ( groups [ num ] ) ; break ; case num : intf . set vsan ( groups [ num ] ) ; break ; case num : intf . set mode ( groups [ num ] ) ; break ; } } return interfaces ; }	issues the " show interface " command and collects in information into a list of interfaces.
protected void clear data lists ( int obd service ) { switch ( obd service ) { case obd svc data : case obd svc freezeframe : pid supported . clear ( ) ; pid pvs . clear ( ) ; break ; case obd svc read codes : case obd svc pendingcodes : case obd svc permacodes : t codes . clear ( ) ; break ; case obd svc veh info : pid supported . clear ( ) ; vid pvs . clear ( ) ; break ; } }	clear data lists for selected service.
public quad edge make edge ( vertex o , vertex d ) { quad edge q = quad edge . make edge ( o , d ) ; quad edges . add ( q ) ; return q ; }	creates a new quadedge , recording it in the edges list .
public static void sort seqs ( list < string > seqs ) { collections . sort ( seqs , null ) ; }	sort n string sequence list .
default b with ( string key , long value ) { return with ( key , long . to string ( value ) ) ; }	associate the given value with the specified key .
private void list directory ( file directory , relative directory subdirectory , set < java file object . kind > file kinds , boolean recurse , list buffer < java file object > result list ) { file d = subdirectory . get file ( directory ) ; if ( ! case map check ( d , subdirectory ) ) return ; file [ ] files = d . list files ( ) ; if ( files == null ) return ; if ( sort files != null ) arrays . sort ( files , sort files ) ; for ( file f : files ) { string fname = f . get name ( ) ; if ( f . is directory ( ) ) { if ( recurse && source version . is identifier ( fname ) ) { list directory ( directory , new relative directory ( subdirectory , fname ) , file kinds , recurse , result list ) ; } } else { if ( is valid file ( fname , file kinds ) ) { java file object fe = new regular file object ( this , fname , new file ( d , fname ) ) ; result list . append ( fe ) ; } } } }	insert all files in subdirectory subdirectory of directory directory which match filekinds into resultlist.
private shape decode edge ( int width , int height ) { path . reset ( ) ; path . move to ( width - num , num ) ; path . line to ( width - num , height - num ) ; path . line to ( width - num , height - num ) ; path . line to ( num , height - num ) ; return path ; }	create the button edge shape .
public void dispose ( ) throws iab async in progress exception { synchronized ( m async in progress lock ) { if ( m async in progress ) { throw new iab async in progress exception ( str + str + m async operation + str ) ; } } log debug ( str ) ; m setup done = bool ; if ( m service conn != null ) { log debug ( str ) ; if ( m context != null ) m context . unbind service ( m service conn ) ; } m disposed = bool ; m context = null ; m service conn = null ; m service = null ; m purchase listener = null ; }	dispose of object , releasing resources.
private void test scenario ( string a configuration , boolean an expecting an exception , list < method > a methods to call ) throws exception { if ( a methods to call . is empty ( ) ) { test scenario ( a configuration , an expecting an exception , ( method ) null ) ; } else { for ( method my method : a methods to call ) { test scenario ( a configuration , an expecting an exception , my method ) ; } } }	load an element with default configuration and call tostring.
private static file create reserve disk cache dir ( context context ) { file cache dir = storage utils . get cache directory ( context , bool ) ; file individual dir = new file ( cache dir , str ) ; if ( individual dir . exists ( ) || individual dir . mkdir ( ) ) { cache dir = individual dir ; } return cache dir ; }	creates reserve disk cache folder which will be used if primary disk cache folder becomes unavailable.
public boolean has been called ( string resource name ) { return uris . contains ( resource name ) ; }	checks if a resource has been requested using the short name of the resource .
@ override public void read external ( object input in ) throws io , class not found exception { super . read external ( in ) ; is leaf = in . read boolean ( ) ; num entries = in . read int ( ) ; }	reads the id of this node , the numentries and the entries array from the specified stream .
public obj id map ( ) { this ( num , num ) ; }	creates a new , empty map with the default initial capacity ( 11 buckets ) and load factor ( 0.
public criteria or ( ) { criteria criteria = create criteria internal ( ) ; ored criteria . add ( criteria ) ; return criteria ; }	this method was generated by mybatis generator . this method corresponds to the database table company.
public static connection factory new failover connection pool ( set < ldapurl > servers , string username , char [ ] password , int max size , int heart beat interval , string heart beat time unit , options ldap options ) { list < connection factory > factories = new array list < connection factory > ( servers . size ( ) ) ; for ( ldapurl ldapurl : servers ) { connection factory cf = connections . new fixed connection pool ( new connection factory ( ldapurl , username , password , heart beat interval , heart beat time unit , ldap options ) , max size ) ; factories . add ( cf ) ; } return load balance factories ( factories ) ; }	creates a new connection pool that is capable to failover to the servers defined in case there is an error .
public printf format ( final string fmt arg ) throws illegal argument exception { this ( locale . get default ( ) , fmt arg ) ; }	constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings.
public static void init cause ( throwable throwable , throwable cause ) { if ( init cause method != null ) { try { init cause method . invoke ( throwable , new object [ ] { cause } ) ; } catch ( exception e ) { } } }	if we ' re running on jdk 1.
public message property key ( string description , integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }	creates a parameterized instance .
private node add waiter ( node mode ) { node node = new node ( thread . current thread ( ) , mode ) ; node pred = tail ; if ( pred != null ) { node . prev = pred ; if ( compare and set tail ( pred , node ) ) { pred . next = node ; return node ; } } enq ( node ) ; return node ; }	creates and enqueues node for current thread and given mode .
private void assert bounded ( sorted set < string > deserialized , boolean bounded ) { if ( bounded ) { try { deserialized . add ( str ) ; fail ( ) ; } catch ( illegal argument exception expected ) { } } else { assert true ( deserialized . add ( str ) ) ; assert true ( deserialized . remove ( str ) ) ; } }	regrettably , serializing a treeset causes it to forget its bounds.
public void paint border ( component c , graphics g , int x , int y , int width , int height ) { j comp = ( c instanceof j ) ? ( j ) c : null ; if ( g instanceof d ) { d g2 = ( d ) g ; g2 . translate ( x , y ) ; paint ( g2 , comp , width , height ) ; g2 . translate ( - x , - y ) ; } else { buffered image img = new buffered image ( img size , img size , buffered image . type int argb ) ; d g2 = ( d ) img . get graphics ( ) ; paint ( g2 , comp , width , height ) ; g2 . dispose ( ) ; image scaling helper . paint ( g , x , y , width , height , img , insets , insets , image scaling helper . paint type . pain stretch , image scaling helper . paint all ) ; } }	paints the border for the specified component with the specified position and size .
@ suppress warnings ( { str , str } ) public static line by line file input operator restore check point ( line by line file input operator check point oper , byte array output stream bos ) throws exception { kryo kryo = new kryo ( ) ; input l input = new input ( bos . to byte array ( ) ) ; line by line file input operator oper = kryo . read object ( l input , check point oper . get class ( ) ) ; l input . close ( ) ; return oper ; }	restores the checkpointed operator .
private static byte [ ] read class ( final input stream is , boolean close ) throws io { if ( is == null ) { throw new io ( str ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = num ; while ( bool ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - num ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; system . arraycopy ( b , num , c , num , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < num ) { return b ; } byte [ ] c = new byte [ b . length + num ] ; system . arraycopy ( b , num , c , num , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }	reads the bytecode of a class .
private static synchronized boolean is supported impl ( http caller info hci ) { if ( supported == null ) { supported = new hash map < string , boolean > ( ) ; cache = new hash map < string , negotiator > ( ) ; } string hostname = hci . host ; hostname = hostname . to lower case ( ) ; if ( supported . contains key ( hostname ) ) { return supported . get ( hostname ) ; } negotiator neg = negotiator . get negotiator ( hci ) ; if ( neg != null ) { supported . put ( hostname , bool ) ; cache . put ( hostname , neg ) ; return bool ; } else { supported . put ( hostname , bool ) ; return bool ; } }	find out if the httpcallerinfo supports negotiate protocol.
public c ( final i project , final listener provider < i > listeners , final sql provider , final int project id , final string name , final string description , final date creation date , final date modification date , final list < debugger template > assigned debuggers ) { m project = project ; m listeners = listeners ; m provider = provider ; m id = project id ; m name = name ; m description = description ; m creation date = new date ( creation date . get time ( ) ) ; m modification date = new date ( modification date . get time ( ) ) ; m assigned debuggers = new array list < debugger template > ( assigned debuggers ) ; }	creates a new configuration object .
public shape chart to screen shape ( shape s ) { general path p = new general path ( ) ; transform inverse = transform . make translation ( get absolute x ( ) , get absolute y ( ) ) ; if ( current transform != null ) { inverse . concatenate ( current transform ) ; } p . append ( s . get path iterator ( inverse ) , bool ) ; return p ; }	converts a screen coordinate spaced shape to the same shape in the chart coordinate space.
@ override public void add shutdown window ( final window window ) { if ( m is shut down ) { close window ( window ) ; return ; } synchronized ( this ) { if ( m is shut down ) { close window ( window ) ; return ; } m windows to close on shutdown . add ( window ) ; } }	add a latch that will be released when the game shuts down .
public performance logger ( ) { time1 = system . current time millis ( ) ; }	instantiates a new performance logger .
public auth request authenticate ( list discoveries , string return to url ) throws consumer exception , message exception { return authenticate ( discoveries , return to url , return to url ) ; }	builds a authentication request message for the user specified in the discovery information provided as a parameter.
public hash ( string hex ) { if ( hex . length ( ) != num ) { throw new illegal argument exception ( str ) ; } this . bytes = byte utils . reverse ( byte utils . from hex ( hex ) ) ; }	create a hash from a hexadecimal representation of the digest note that this is in the reverse byte order of the internal binary representation .
private string [ ] diff half match i ( string longtext , string shorttext , int i ) { string seed = longtext . substring ( i , i + longtext . length ( ) / num ) ; int j = - num ; string best common = str ; string best longtext a = str , best longtext b = str ; string best shorttext a = str , best shorttext b = str ; while ( ( j = shorttext . index of ( seed , j + num ) ) != - num ) { int prefix length = diff common prefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffix length = diff common suffix ( longtext . substring ( num , i ) , shorttext . substring ( num , j ) ) ; if ( best common . length ( ) < suffix length + prefix length ) { best common = shorttext . substring ( j - suffix length , j ) + shorttext . substring ( j , j + prefix length ) ; best longtext a = longtext . substring ( num , i - suffix length ) ; best longtext b = longtext . substring ( i + prefix length ) ; best shorttext a = shorttext . substring ( num , j - suffix length ) ; best shorttext b = shorttext . substring ( j + prefix length ) ; } } if ( best common . length ( ) * num >= longtext . length ( ) ) { return new string [ ] { best longtext a , best longtext b , best shorttext a , best shorttext b , best common } ; } else { return null ; } }	does a substring of shorttext exist within longtext such that the substring is at least half the length of longtext ?.
public boolean is numerical run ( string pin ) { final int len = pin . length ( ) ; int prev digit = character . digit ( pin . char at ( num ) , num ) ; int prev diff = integer . max value ; boolean is run = bool ; for ( int i = num ; is run && i < len ; i ++ ) { final int digit = character . digit ( pin . char at ( i ) , num ) ; final int diff = digit - prev digit ; if ( prev diff != integer . max value && diff != prev diff ) { is run = bool ; } prev diff = diff ; prev digit = digit ; } return is run ; }	tests the string to see if it contains a numeric run.
public static int uri type ( string uri ) { if ( uri . index of ( str ) != - num ) { return abs uri ; } else if ( uri . starts with ( str ) ) { return root rel uri ; } else { return noroot rel uri ; } }	returns the type of a uri : abs_uri root_rel_uri noroot_rel_uri.
public static void add glue ( j b , boolean horiz ) { b . add ( horiz ? box . create horizontal glue ( ) : box . create vertical glue ( ) ) ; }	add a glue , or variable spacing , to a ui component.
public static boolean is resource reference ( string str ) { return str . starts with ( big quote left ) && str . ends with ( big quote right ) && str . char at ( num ) == at . char at ( num ) ; }	return the str is resource reference or not .
public boolean leave ( ) throws keeper exception , interrupted exception { zoo keeper . delete ( root path + str + name , num ) ; while ( bool ) { synchronized ( mutex ) { list < string > list = zoo keeper . get children ( root path , bool ) ; if ( list . size ( ) > num ) { mutex . wait ( ) ; } else { return bool ; } } } }	wait until all nodes leave barrier.
public enumeration < ? extends principal > members ( ) { vector < principal > v = new vector < principal > ( num ) ; v . add element ( this ) ; return v . elements ( ) ; }	returns an enumeration which contains the subnet mask .
public select clause add with as provided name ( string property name , string as name ) { select list . add ( new select clause expression ( new property value expression ( property name ) , as name ) ) ; return this ; }	adds a single property name and an " as " - asname for the column .
public void add interface ( string interface name ) { short interface index = its constant pool . add class ( interface name ) ; its interfaces . add ( short . value of ( interface index ) ) ; }	add an interface implemented by this class.
public static string cut from index of ( string string , string substring ) { int i = string . index of ( substring ) ; if ( i != - num ) { string = string . substring ( i ) ; } return string ; }	cuts the string from the first index of provided substring to the end .
private response request http get from registry ( string url ) throws registry exception { try { response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new registry exception ( type . bad response , str ) ; } } catch ( class cast exception e ) { throw new registry exception ( type . bad response , e ) ; } catch ( connect exception e ) { throw new registry exception ( type . proxy , e ) ; } catch ( unknown host exception e ) { try { http . get ( str ) ; } catch ( exception e1 ) { throw new registry exception ( type . no internet , e1 ) ; } throw new registry exception ( type . site down , e ) ; } catch ( io e ) { throw new registry exception ( type . io error , e ) ; } catch ( uri e ) { throw new registry exception ( type . bad request , str + ( ( url != null ) ? url : str ) ) ; } }	executes an http get request against the gbif registry.
public void test iterator ( ) throws interrupted exception { linked blocking queue q = populated queue ( size ) ; iterator it = q . iterator ( ) ; while ( it . has next ( ) ) { assert equals ( it . next ( ) , q . take ( ) ) ; } }	iterator iterates through all elements.
public void init ( remote authenticated user current user ) { this . current user = current user ; }	creates a new sharedconnectiondirectory which exposes share keys as connections.
public static void invoke finalize ( object o ) throws throwable { o . finalize ( ) ; }	call the object finalize method on the given object.
private void remove tv show ( tv show tv show ) { synchronized ( root ) { tv show tree node child = ( tv show tree node ) node map . get ( tv show ) ; default mutable tree node parent = root ; if ( child != null ) { int index = get index of child ( parent , child ) ; node map . remove ( tv show ) ; for ( tv show episode episode : new array list < > ( tv show . get episodes ( ) ) ) { node map . remove ( episode ) ; episode . remove property change listener ( property change listener ) ; } tv show . remove property change listener ( property change listener ) ; child . remove all children ( ) ; child . remove from parent ( ) ; if ( index > - num ) { tree model event event = new tree model event ( this , parent . get path ( ) , new int [ ] { index } , new object [ ] { child } ) ; for ( tree model listener listener : listeners ) { try { listener . tree nodes removed ( event ) ; } catch ( null pointer exception | array index out of bounds exception npe ) { } } } } } }	removes the tv show .
private compliance feature check encrypt policy ( org . wso2 . emm . agent . beans . operation operation ) { boolean encrypt status = ( device policy manager . get storage encryption status ( ) != device policy manager . encryption status unsupported && device policy manager . get storage encryption status ( ) != device policy manager . encryption status inactive ) ; if ( ( operation . is enabled ( ) && encrypt status ) || ( ! operation . is enabled ( ) && ! encrypt status ) ) { policy . set compliance ( bool ) ; } else { policy . set compliance ( bool ) ; policy . set message ( resources . get string ( r . string . error encrypt policy ) ) ; } return policy ; }	checks device encrypt policy on the device ( device external storage encryption ) .
public static int instance of ( object o , class < ? > c ) { if ( o == null ) return false ; return c . is assignable from ( o . get class ( ) ) ? true : false ; }	replacement function for the java instanceof instruction , which returns a distance integer.
@ override public void add ( int location , e object ) { insert element at ( object , location ) ; }	adds the specified object into this vector at the specified location.
private long cache response age ( ) { long apparent received age = served date != null ? math . max ( num , received response millis - served date . get time ( ) ) : num ; long received age = age seconds != - num ? math . max ( apparent received age , seconds . to millis ( age seconds ) ) : apparent received age ; long response duration = received response millis - sent request millis ; long resident duration = now millis - received response millis ; return received age + response duration + resident duration ; }	returns the current age of the response , in milliseconds.
private static int array index ( int i ) { return ( i > > shift per word ) ; }	returns the array element holding the bit value for the given integer.
protected static void invalidate switch points ( ) { if ( log enabled ) { log . info ( str ) ; } synchronized ( indy interface . class ) { switch point old = switch point ; switch point = new switch point ( ) ; switch point . invalidate all ( new switch point [ ] { old } ) ; } }	callback for constant meta class update change.
public vdc config to config param ( properties vdc info ) { log . info ( str , vdc info . get property ( geo service job . vdc short id ) ) ; vdc config vdc config = new vdc config ( ) ; vdc config . set id ( uri . uri ( vdc info . get property ( geo service job . operated vdc id ) ) ) ; vdc config . set short id ( vdc info . get property ( geo service job . vdc short id ) ) ; vdc config . set secret key ( vdc info . get property ( geo service job . vdc secrete key ) ) ; string name = vdc info . get property ( geo service job . vdc name ) ; if ( ( name != null ) && ( ! name . is empty ( ) ) ) { vdc config . set name ( name ) ; } string description = vdc info . get property ( geo service job . vdc description ) ; if ( ( description != null ) && ( ! description . is empty ( ) ) ) { vdc config . set description ( description ) ; } string end pnt = vdc info . get property ( geo service job . vdc api endpoint ) ; if ( end pnt != null ) { vdc config . set api endpoint ( end pnt ) ; } vdc config . set geo command endpoint ( vdc info . get property ( geo service job . vdc geocommand endpoint ) ) ; vdc config . set geo data endpoint ( vdc info . get property ( geo service job . vdc geodata endpoint ) ) ; return vdc config ; }	build vdcconfig for a vdc for syncvdcconfig call.
protected osx ( string proxy signature , object target , method handler ) { this . proxy signature = proxy signature ; this . target object = target ; this . target method = handler ; }	each osxadapter has the name of the eawt method it intends to listen for ( handleabout , for example ) , the object that will ultimately perform the task , and the method to be called on that object .
private double prediction ( instance inst ) { double [ ] normalized instance = normalized instance ( inst ) ; double normalized prediction = prediction ( normalized instance ) ; return denormalized prediction ( normalized prediction ) ; }	output the prediction made by this perceptron on the given instance.
protected object finish ( map settings ) throws wizard exception { return provider . finish ( settings ) ; }	instantiate whatever object ( if any ) the wizard creates from its gathered data .
public boolean is valid attachment point ( datapath id switch dpid , of switch port ) { if ( topology . is attachment point port ( switch dpid , switch port ) == bool ) return bool ; if ( suppress a . contains ( new switch port ( switch dpid , switch port ) ) ) return bool ; return bool ; }	check whether the given attachment point is valid given the current topology.
protected void fire cluster change ( long timestamp , string type , string message ) { if ( listeners != null && ! listeners . is empty ( ) ) { cluster event event = new cluster event ( this , timestamp , type , message ) ; vector targets ; synchronized ( this ) { targets = ( vector ) listeners . clone ( ) ; } enumeration e = targets . elements ( ) ; while ( e . has more elements ( ) ) { cluster event listener l = ( cluster event listener ) e . next element ( ) ; l . change cluster ( event ) ; } } }	fire a clusterchangeevent to all registered listeners.
public batched image request ( request < ? > request , image container container ) { m request = request ; m containers . add ( container ) ; }	constructs a new batchedimagerequest object.
public int rgb for ( int pixel ) { return surface type . rgb for ( pixel , color model ) ; }	returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .
private boolean check for carry ( final char [ ] ca1 , final int icarry ) { boolean carry = bool ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == str || ca1 [ icarry ] == str || ca1 [ icarry ] == str || ca1 [ icarry ] == str ) { carry = bool ; } else if ( ca1 [ icarry ] == str ) { int ii = icarry + num ; for ( ; ii < ca1 . length ; ii ++ ) { if ( ca1 [ ii ] != str ) { break ; } } carry = ii < ca1 . length ; if ( ! carry && icarry > num ) { carry = ( ca1 [ icarry - num ] == str || ca1 [ icarry - num ] == str || ca1 [ icarry - num ] == str || ca1 [ icarry - num ] == str || ca1 [ icarry - num ] == str ) ; } } } return carry ; }	check to see if the digits that are going to be truncated because of the precision should force a round in the preceding digits .
protected void add bottom component ( component bottom component ) { c . weighty = num ; layout . set constraints ( bottom component , c ) ; content panel . add ( bottom component ) ; }	subclasses might add an additional component here which is seen during all steps , e.
public static boolean delete directory files ( set < string > input file paths and names ) { if ( ( input file paths and names == null ) ) { return bool ; } boolean did successfully delete all files = bool ; try { for ( string file path and name : input file paths and names ) { file file = new file ( file path and name ) ; if ( ! file . is directory ( ) ) { boolean delete success = delete file ( file path and name ) ; if ( ! delete success ) { logger . debug ( str + file path and name + str ) ; did successfully delete all files = bool ; } } } } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; return bool ; } return did successfully delete all files ; }	this is a quiet method.
public static file create temp dir ( file dir , boolean cleanup ) throws io { if ( ! dir . mkdirs ( ) && ! dir . exists ( ) ) { throw new io ( string . format ( str , dir . to string ( ) ) ) ; } if ( cleanup ) { add cleanup hook ( dir . to path ( ) ) ; } return dir ; }	create directory that is automatically cleaned up after the jvm shuts down through use of a runtime shutdown hook .
public void emit init ( ) { out . append ( str ) ; out . append ( const name ( ) ) ; out . append ( str ) ; out . append ( name ) ; out . append ( str ) ; nl ( ) ; next chunk ( ) ; }	emit declaration of decoded member and open first chunk .
public static string read cookie ignore special characters ( http servlet request request , string cookie name ) { string cs = request . get header ( str ) ; if ( cs == null ) return null ; int start = cs . index of ( cookie name ) ; if ( start < num ) return null ; cs = cs . substring ( start + num + cookie name . length ( ) ) ; int end = cs . index of ( str ) ; if ( end > num ) { cs = cs . substring ( num , end ) ; } return cs ; }	read all cookies from the request ' s ' cookie ' header , and parse it based on cookie version 1.
protected final void merge ( @ not null set < local resource repository > visited , @ not null resource type type , @ not null set multimap < string , string > seen qualifiers , @ not null list multimap < string , resource item > result ) { if ( visited . contains ( this ) ) { return ; } visited . add ( this ) ; do merge ( visited , type , seen qualifiers , result ) ; }	if this repository has not already been visited , merge its items of the given type into result .
private byte [ ] translate transferable string ( string str , long format ) throws io { long l format = long . value of ( format ) ; string charset = get best charset for text format ( l format , null ) ; string eoln = ( string ) native eol . get ( l format ) ; if ( eoln != null ) { int length = str . length ( ) ; string buffer buffer = new string buffer ( length * num ) ; for ( int i = num ; i < length ; i ++ ) { if ( str . starts with ( eoln , i ) ) { buffer . append ( eoln ) ; i += eoln . length ( ) - num ; continue ; } char c = str . char at ( i ) ; if ( c == str ) { buffer . append ( eoln ) ; } else { buffer . append ( c ) ; } } str = buffer . to string ( ) ; } byte [ ] bytes = str . get bytes ( charset ) ; integer terminators = ( integer ) native terminators . get ( l format ) ; if ( terminators != null ) { int num terminators = terminators . int value ( ) ; byte [ ] terminated bytes = new byte [ bytes . length + num terminators ] ; system . arraycopy ( bytes , num , terminated bytes , num , bytes . length ) ; for ( int i = bytes . length ; i < terminated bytes . length ; i ++ ) { terminated bytes [ i ] = num ; } bytes = terminated bytes ; } return bytes ; }	translation function for converting string into a byte array.
private byte [ ] create preview buffer ( size preview size ) { int bits per pixel = image format . get bits per pixel ( image format . n ) ; long size in bits = preview size . get height ( ) * preview size . get width ( ) * bits per pixel ; int buffer size = ( int ) math . ceil ( size in bits / num ) + num ; byte [ ] byte array = new byte [ buffer size ] ; byte buffer buffer = byte buffer . wrap ( byte array ) ; if ( ! buffer . has array ( ) || ( buffer . array ( ) != byte array ) ) { throw new illegal state exception ( str ) ; } m bytes to byte buffer . put ( byte array , buffer ) ; return byte array ; }	creates one buffer for the camera preview callback.
public void add ( int pos , box b ) { children . add ( pos , b ) ; b . parent = this ; b . elder parent = elder parent ; }	inserts the given box at the given position in the list of child boxes .
public position create position ( int offset ) throws bad location exception { while ( queue . poll ( ) != null ) { unused marks ++ ; } if ( unused marks > math . max ( num , ( marks . size ( ) / num ) ) ) { remove unused marks ( ) ; } int g0 = get gap start ( ) ; int g1 = get gap end ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort index = find sort index ( search ) ; mark data m ; sticky position position ; if ( sort index < marks . size ( ) && ( m = marks . element at ( sort index ) ) . index == index && ( position = m . get position ( ) ) != null ) { } else { position = new sticky position ( ) ; m = new mark data ( index , position , queue ) ; position . set mark ( m ) ; marks . insert element at ( m , sort index ) ; } return position ; }	creates a position within the content that will track change as the content is mutated .
public static string pad ( string string , int n , string padding , boolean right ) { if ( n < num ) { n = num ; } if ( n < string . length ( ) ) { return string . substring ( num , n ) ; } else if ( n == string . length ( ) ) { return string ; } char padding char ; if ( padding == null || padding . length ( ) == num ) { padding char = str ; } else { padding char = padding . char at ( num ) ; } string builder buff = new string builder ( n ) ; n -= string . length ( ) ; if ( right ) { buff . append ( string ) ; } for ( int i = num ; i < n ; i ++ ) { buff . append ( padding char ) ; } if ( ! right ) { buff . append ( string ) ; } return buff . to string ( ) ; }	pad a string . this method is used for the sql function rpad and lpad .
private final void reset dtx ( affine transform at ) { fsref = null ; dtx = at ; invdtx = null ; if ( ! dtx . is identity ( ) ) { try { invdtx = dtx . create inverse ( ) ; } catch ( noninvertible transform exception e ) { } } if ( gti != null ) { gti . strikes ref = null ; } }	change the dtx for the strike refs we use.
public static void add activity listener ( activity listener listener ) { if ( listener != null ) { start tracking ( ) ; listeners . add ( listener ) ; } }	adds a listener that will be informed one time about user activity , then removed .
public void add muted username ( final string username , final date mute till ) { if ( is username muted ( username ) ) { remove muted username ( username ) ; } timestamp mute till ts = null ; if ( mute till != null ) { mute till ts = new timestamp ( mute till . get time ( ) ) ; } s logger . fine ( str + username ) ; final connection con = database . get connection ( ) ; try { final prepared statement ps = con . prepare statement ( str ) ; ps . set string ( num , username ) ; ps . set timestamp ( num , mute till ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final sql sqle ) { if ( sqle . get error code ( ) == num ) { s logger . info ( str + username + str + sqle . get message ( ) ) ; return ; } s logger . log ( level . severe , str + username , sqle ) ; throw new illegal state exception ( sqle . get message ( ) ) ; } finally { db util . close connection ( con ) ; } }	mute the given username.
private response < bitmap > do parse ( network response response ) { byte [ ] data = response . data ; log . d ( str , str ) ; bitmap factory . options decode options = new bitmap factory . options ( ) ; bitmap bitmap = null ; log . d ( str , str ) ; decode options . in just decode bounds = bool ; bitmap factory . decode byte array ( data , num , data . length , decode options ) ; int actual width = decode options . out width ; int actual height = decode options . out height ; int desired width = get resized dimension ( m max width , m max height , actual width , actual height , m scale type ) ; int desired height = get resized dimension ( m max height , m max width , actual height , actual width , m scale type ) ; decode options . in just decode bounds = bool ; decode options . in sample size = find best sample size ( actual width , actual height , desired width , desired height ) ; bitmap temp bitmap = bitmap factory . decode byte array ( data , num , data . length , decode options ) ; if ( temp bitmap != null && ( temp bitmap . get width ( ) > desired width || temp bitmap . get height ( ) > desired height ) ) { bitmap = bitmap . create scaled bitmap ( temp bitmap , desired width , desired height , bool ) ; temp bitmap . recycle ( ) ; } else { bitmap = temp bitmap ; } if ( bitmap == null ) { return response . error ( new parse error ( response ) ) ; } else { return response . success ( bitmap , http header parser . parse cache headers ( response ) ) ; } }	the real guts of parsenetworkresponse.
public void apply component orientation ( component orientation o ) { possibly fix cursor ( o . is left to right ( ) ) ; super . apply component orientation ( o ) ; }	overridden to ensure that the cursor for this component is appropriate for the orientation .
public boolean is empty ( ) { return m selected widgets . is empty ( ) ; }	check if the selection is empty.
public void close ( ) throws io { if ( ! closed ) { try { finish ( ) ; } finally { out . close ( ) ; closed = bool ; } } }	writes any remaining uncompressed data to the output stream and closes the underlying output stream .
protected abstract c new parcelable adapter instance ( list < object > items ) ;	create a new instance of your parcelableadapter using the provided list of items .
public static void next bytes ( byte [ ] bytes ) { was accessed = bool ; for ( int i = num ; i < bytes . length ; ) for ( int rnd = next int ( ) , n = math . min ( bytes . length - i , num ) ; n -- > num ; rnd >>= num ) bytes [ i ++ ] = ( byte ) rnd ; }	replacement function for nextbytes.
protected void draw low far out ( double a radius , d g2 , double xx , double m ) { double side = a radius * num ; g2 . draw ( new d . double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new d . double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new d . double ( xx + side , m - side , xx , m ) ) ; }	draws a triangle to indicate the presence of far out values .
public boolean is java library class ( ) { if ( name . starts with ( str ) || name . starts with ( str ) || name . starts with ( str ) || name . starts with ( str ) || name . starts with ( str ) || name . starts with ( str ) ) return bool ; return bool ; }	sometimes we need to know which class is a jdk class.
private set < object name > object names from filtered named objects ( set < named object > list , query exp query ) { set < object name > result = new hash set < object name > ( ) ; if ( query == null ) { for ( named object no : list ) { result . add ( no . get name ( ) ) ; } } else { final m old server = query eval . get m ( ) ; query . set m ( server ) ; try { for ( named object no : list ) { boolean res ; try { res = query . apply ( no . get name ( ) ) ; } catch ( exception e ) { res = bool ; } if ( res ) { result . add ( no . get name ( ) ) ; } } } finally { query . set m ( old server ) ; } } return result ; }	applies the specified queries to the set of namedobjects .
private boolean check touch slop ( view child , float dx , float dy ) { if ( child == null ) { return bool ; } final boolean check horizontal = m callback . get view horizontal drag range ( child ) > num ; final boolean check vertical = m callback . get view vertical drag range ( child ) > num ; if ( check horizontal && check vertical ) { return dx * dx + dy * dy > m touch slop * m touch slop ; } else if ( check horizontal ) { return math . abs ( dx ) > m touch slop ; } else if ( check vertical ) { return math . abs ( dy ) > m touch slop ; } return bool ; }	check if we ' ve crossed a reasonable touch slop for the given child view.
private element create end point ( string name , string attr binding , string attr location , string attr response location ) throws dom { if ( name == null ) { throw new illegal argument exception ( str ) ; } if ( attr binding == null ) { throw new illegal argument exception ( str ) ; } if ( attr location == null ) { throw new illegal argument exception ( str ) ; } element end pt = doc . create element ( name ) ; end pt . set attribute ( saml . binding , attr binding ) ; end pt . set attribute ( saml . location , attr location ) ; if ( attr response location != null ) { end pt . set attribute ( saml . resploc , attr response location ) ; } return end pt ; }	create end point element in dom .
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( str ) ; buffer . append ( is use default ( ) ) ; buffer . append ( str ) ; buffer . append ( use locale format ) ; if ( pattern != null ) { buffer . append ( str ) ; buffer . append ( pattern ) ; } if ( locale != null ) { buffer . append ( str ) ; buffer . append ( locale ) ; } buffer . append ( str ) ; return buffer . to string ( ) ; }	provide a string representation of this number converter .
public void test multiple resource locking resources10 locktries10 ( ) throws exception { final properties properties = new properties ( ) ; properties . set property ( test options . nthreads , str ) ; properties . set property ( test options . ntasks , str ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . max lock tries , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; properties . set property ( test options . timeout , long . to string ( num * num ) ) ; do comparison test ( properties ) ; }	test where each operation locks one or more resources.
public void start element ( string namespace uri , string local name , string q name , attributes atts ) throws org . xml . sax . sax { throw new stop parse exception ( ) ; }	the spec notes that " the xml - stylesheet processing instruction is allowed only in the prolog of an xml document.
public synchronized byte [ ] to byte array ( ) { byte [ ] new array = new byte [ count ] ; system . arraycopy ( buf , num , new array , num , count ) ; return new array ; }	returns the contents of this bytearrayoutputstream as a byte array.
calendar to calendar ( string value , string pattern , locale locale ) { calendar calendar = null ; try { date format format = ( locale == null ) ? new simple date format ( pattern ) : new simple date format ( pattern , locale ) ; format . set lenient ( bool ) ; format . parse ( value ) ; calendar = format . get calendar ( ) ; } catch ( exception e ) { fail ( str + value + str + pattern + str + e . to string ( ) ) ; } return calendar ; }	parse a string value to a calendar.
private byte [ ] convert bitmap to bytes ( final bitmap bitmap ) { int size = bitmap . get row bytes ( ) * bitmap . get height ( ) ; byte array output stream out = new byte array output stream ( size ) ; try { if ( bitmap . compress ( bitmap . compress format . png , num , out ) ) { return out . to byte array ( ) ; } if ( s logger . is activated ( ) ) { s logger . debug ( str ) ; } return null ; } finally { closeable utils . try to close ( out ) ; } }	converts the specified bitmap to a byte array .
private static void save template ( file parent dir , file template base template , final string line separator ) throws io { final file template file = new file ( parent dir , encode file name ( template . get name ( ) , template . get extension ( ) ) ) ; file output stream file output stream ; try { file output stream = new file output stream ( template file ) ; } catch ( file not found exception e ) { file util . delete ( template file ) ; file output stream = new file output stream ( template file ) ; } output stream writer output stream writer = new output stream writer ( file output stream , charset toolkit . ut charset ) ; string content = template . get text ( ) ; if ( ! line separator . equals ( str ) ) { content = string util . convert line separators ( content , line separator ) ; } output stream writer . write ( content ) ; output stream writer . close ( ) ; file output stream . close ( ) ; }	save template to file.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void add composite ( transform tree node node ) { parts . add ( node ) ; }	adds a composite operation to the transform node.
protected static void post process flood ( i [ ] hex set , int modifier ) { int n ; i field ; i f = terrains . get terrain factory ( ) ; for ( n = num ; n < hex set . length ; n ++ ) { field = hex set [ n ] ; int elev = field . get level ( ) - modifier ; if ( ( elev == num ) && ! ( field . contains terrain ( terrains . water ) ) && ! ( field . contains terrain ( terrains . pavement ) ) ) { field . add terrain ( f . create terrain ( terrains . swamp , num ) ) ; } else if ( elev < num ) { if ( elev < - num ) { elev = - num ; } field . remove all terrains ( ) ; field . add terrain ( f . create terrain ( terrains . water , - elev ) ) ; field . set level ( modifier ) ; } } }	flood negative hex levels shoreline / salt marshes effect works best with more elevation.
private static void expand2 digit number ( string number string , word relation word relation , item token item ) { if ( number string . char at ( num ) == str ) { if ( number string . char at ( num ) == str ) { } else { string number = digit2num [ number string . char at ( num ) - str ] ; word relation . add word ( token item , number ) ; } } else if ( number string . char at ( num ) == str ) { string number = digit2enty [ number string . char at ( num ) - str ] ; word relation . add word ( token item , number ) ; } else if ( number string . char at ( num ) == str ) { string number = digit2teen [ number string . char at ( num ) - str ] ; word relation . add word ( token item , number ) ; } else { string enty = digit2enty [ number string . char at ( num ) - str ] ; word relation . add word ( token item , enty ) ; expand digits ( number string . substring ( num , number string . length ( ) ) , word relation , token item ) ; } }	expands a two - digit string into a list of english words .
protected int index of ( string buffer , int start , int end , char ch ) { for ( int i = start ; i < end ; i ++ ) { if ( buffer . char at ( i ) == ch ) { return i ; } } return - num ; }	computes index of given char within stringbuffer.
public factory ( javac messages messages , string prefix ) { this . prefix = prefix ; this . formatter = new basic diagnostic formatter ( messages ) ; default error flags = enum set . of ( diagnostic flag . mandatory ) ; }	create a new diagnostic factory .
@ override protected boolean is frontier empty ( ) { clean up frontier ( ) ; update metrics ( frontier . size ( ) ) ; return frontier . is empty ( ) ; }	pops nodes of already explored states from the head of the frontier and checks whether there are still some nodes left .
@ override public boolean is enabled ( ) { if ( ( attribute selection panel != null ) && ! is value only ( ) ) { return attribute selection panel . is enabled ( ) ; } else { if ( this . crs combo box != null ) { return crs combo box . is enabled ( ) ; } } return bool ; }	checks if is enabled .
public static double variance ( double [ ] x , double mean ) { double var = num ; int count = x . length ; for ( double a x : x ) { if ( double . is na n ( a x ) ) { count -- ; } else { double diff = a x - mean ; var += diff * diff ; } } if ( count < num ) { count = num ; } else { count = count - num ; } return var / ( double ) count ; }	compute variance ( ml estimator ).
private void stash request user ( request and response request and response ) { if ( request and response . was user already stashed ) { return ; } request and response . was user already stashed = bool ; final user user = db logic . get user by id ( get effective user id ( request and response ) ) ; if ( user != null ) { request and response . user is admin = user . get is admin ( ) ; request and response . user is account closed = user . get is account closed ( ) ; request and response . user options = user . get options ( ) ; } else { request and response . user options = str ; } }	stashes user information in the requestandresponse to reduce the number of queries and transactions .
@ override public void send location list ( ) { list < location > location list = lm . get locations by name list ( ) ; array list < attribute > location ; for ( location loc : location list ) { location = new array list < attribute > ( num ) ; location . add ( new attribute ( locations , loc ) ) ; try { send message ( location ) ; } catch ( io ioe ) { log . debug ( str + loc . get name ( ) ) ; } } }	send a list of locations known by operations to the client.
protected void serialize text ( text node ) throws sax { if ( f next is raw ) { f next is raw = bool ; f serializer . processing instruction ( javax . xml . transform . result . pi disable output escaping , str ) ; dispatach chars ( node ) ; f serializer . processing instruction ( javax . xml . transform . result . pi enable output escaping , str ) ; } else { boolean b dispatch = bool ; if ( ( f features & wellformed ) != num ) { is text well formed ( node ) ; } boolean is element content whitespace = bool ; if ( f is level3 dom ) { is element content whitespace = node . is element content whitespace ( ) ; } if ( is element content whitespace ) { if ( ( f features & elem content whitespace ) != num ) { b dispatch = bool ; } } else { b dispatch = bool ; } if ( ! apply filter ( node , node filter . show text ) ) { return ; } if ( b dispatch ) { dispatach chars ( node ) ; } } }	serializes an text node .
@ override public boolean is inside soft wrap ( @ not null visual position visual ) { return is inside soft wrap ( visual , bool ) ; }	allows to answer if given visual position points to soft wrap - introduced virtual space .
public boolean is valid ( world world ) { return bool ; }	used to determine if a task is valid.
public void clear ( ) { arrays . fill ( ritems , num , rsize , null ) ; arrays . fill ( pitems , num , psize , null ) ; rsize = num ; psize = num ; }	clear both rendering and picking queues .
private parse position next ( final parse position pos ) { pos . set index ( pos . get index ( ) + num ) ; return pos ; }	convenience method to advance parse position by 1.
public final ac grow prio ( int p ) { return grow prio ( p , cur ix ) ; }	specifies the current row / column ' s grow priority.
private int flush ( int offset ) { try { os . write ( buffer , num , offset ) ; offset = num ; return num ; } catch ( io e ) { throw new h3 exception out ( e ) ; } }	flush the buffer and set the offset to zero .
protected string generate section label ( pie dataset dataset , comparable key ) { string result = null ; if ( dataset != null ) { object [ ] items = create item array ( dataset , key ) ; result = message format . format ( this . label format , items ) ; } return result ; }	generates a label for a pie section .
public synchronized void remove graph listener ( graph listener cl ) { m graph listeners . remove ( cl ) ; }	remove a graph listener.
abstract protected void do fade in ( ) ;	fade in then play this audiosource.
public void exec ( string description , string [ ] base command ) throws backup exception { exec ( description , base command , null , null , null , bool , bool ) ; }	convenience method to execute command without providing input or output .
public int increment ( int offset ) { char sequence txt = get text ( ) ; int i ; if ( txt != null ) { try { i = integer . parse int ( txt . to string ( ) ) ; } catch ( number format exception e ) { i = num ; } } else { i = num ; } i = i + offset ; set text ( string . value of ( i ) ) ; return i ; }	increment the numeric badge label.
public static service configuration create ( input stream in stream ) throws io , illegal argument exception { try { check not null ( in stream ) ; properties properties = new properties ( ) ; properties . load ( in stream ) ; return ( create ( properties ) ) ; } finally { if ( in stream != null ) { in stream . close ( ) ; } } }	creates serviceconfiguration and loads it with populated attribute values loaded from provided inputstream property file .
protected int [ ] split sentence ( string sentence ) { string [ ] w = sentence . split ( str ) ; int [ ] words = new int [ w . length ] ; for ( int i = num ; i < w . length ; i ++ ) words [ i ] = vocabulary . id ( w [ i ] ) ; return words ; }	splits a sentence ( on white space ) , then looks up the integer representations of each word using the supplied symbol table .
public static boolean is failure ( list < action > actions ) { return actions . is empty ( ) ; }	checks whether a list of actions is empty .
public void add to dictionary ( string s ) { if ( ! get auto complete ( ) ) return ; if ( dict == null ) { set up ( ) ; this . dict = create default dictionary ( ) ; } dict . add entry ( s . trim ( ) ) ; }	adds the specified string to the underlying dictionary.
public static int [ ] [ ] deep copy ( int m [ ] [ ] ) { int [ ] [ ] c = new int [ m . length ] [ ] ; for ( int i = num ; i < c . length ; i ++ ) { c [ i ] = arrays . copy of ( m [ i ] , m [ i ] . length ) ; } return c ; }	deep copy - make a deep copy of m [ ] [ ] .
public final boolean check tag ( int identifier ) { return arrays . binary search ( identifiers [ num ] , identifier ) >= num ; }	tests whether one of choice alternatives has the same identifier or not .
public void wait for message to arrive ( ) { log . info ( str ) ; long start = system . current time millis ( ) ; synchronized ( messages ) { try { while ( has received message ( ) ) { messages . wait ( num ) ; } } catch ( interrupted exception e ) { log . info ( str + e ) ; } } long end = system . current time millis ( ) - start ; log . info ( str + end + str ) ; }	use to wait for a single message to arrive .
public date ( string date ) { string [ ] fields = date . split ( str ) ; if ( fields . length != num ) { throw new illegal argument exception ( str ) ; } month = integer . parse int ( fields [ num ] ) ; day = integer . parse int ( fields [ num ] ) ; year = integer . parse int ( fields [ num ] ) ; if ( ! is valid ( month , day , year ) ) throw new illegal argument exception ( str ) ; }	initializes new date specified as a string in form mm / dd / yyyy .
public static void copy ( file src , file dst ) throws io { if ( src . is directory ( ) ) { ensure directory exists ( dst ) ; string [ ] files list = src . list ( ) ; for ( string file : files list ) { file src file = new file ( src , file ) ; file dest file = new file ( dst , file ) ; copy ( src file , dest file ) ; } } else { copy file ( src , dst ) ; } }	copy file object from one place to another.
public map objects ( pokemon go api ) { this . api = api ; }	instantiates a new map objects .
@ override public byte [ ] read ( int length ) throws io { if ( length > available ( ) ) { throw new end of buffer exception ( ) ; } byte [ ] res = new byte [ length ] ; system . arraycopy ( buffer , read pos , res , num , length ) ; read pos = read pos + length ; return res ; }	reads vector of opaque values.
public string encode ( string p string ) throws encoder exception { if ( p string == null ) { return null ; } try { return encode ( p string , get default charset ( ) ) ; } catch ( unsupported encoding exception e ) { throw new encoder exception ( e . get message ( ) ) ; } }	encodes a string into its url safe form using the default string charset.
public void test sorts according number of attributes ( ) throws exception { xpp dom dom1 = xpp factory . build dom ( str ) ; xpp dom dom2 = xpp factory . build dom ( str ) ; assert equals ( - num , comparator . compare ( dom1 , dom2 ) ) ; assert equals ( str , xpath . get ( ) ) ; assert equals ( num , comparator . compare ( dom2 , dom1 ) ) ; assert equals ( str , xpath . get ( ) ) ; }	tests comparison of different number of attributes .
public in space predicate ( object ... values ) { in values = new hash set < object > ( ) ; for ( object value : values ) { in values . add ( value ) ; } }	creates an in predicate using the specified values .
private static void delete ( file f ) { if ( f . is directory ( ) ) { for ( file c : f . list files ( ) ) { delete ( c ) ; } } if ( ! f . delete ( ) ) { print stream err = system . err ; err . println ( str + f ) ; } }	recursively deletes a file that may represent a directory .
protected list < string > prepare sort key statements ( list < sort key > sort keys ) { list < string > keys = new array list < string > ( ) ; for ( int i = num ; i < sort keys . size ( ) ; i ++ ) { sort key sort key = sort keys . get ( i ) ; keys . add ( explicit mapping . get db column name ( sort key . get field ( ) ) + ( sort key . is ascending order ( ) ? str : str ) ) ; } return keys ; }	loops through sort keys constructing the key statements .
public static string experimenter to string ( of inst , logger log ) { return long . to string ( inst . get experimenter ( ) ) ; }	convert an ofinstructionexperimenter to string form.
public static void print magnitudes ( ) { print magnitudes ( system . out ) ; }	prints the relative magnitudes of the collected timer data to the standard output stream .
private optional < curator framework > create client ( string zookeeper url ) { if ( string utils . is not blank ( zookeeper url ) ) { curator framework client = configurations utils . get client ( zookeeper url ) ; client . start ( ) ; return optional . of ( client ) ; } else { return optional . empty ( ) ; } }	creates a zookeeper client .
public static string add cv description ( string tool tip , string cv description , string mask ) { string desc string = cv description ; string temp = get mask description ( mask ) ; if ( temp . length ( ) > num ) { desc string = desc string + str + temp ; } if ( pane prog frame . get show cv numbers ( ) && ( desc string != null ) ) { if ( tool tip == null ) { tool tip = desc string ; } else { tool tip = add text htm ( tool tip , str + desc string + str ) ; } } else if ( tool tip == null ) { tool tip = str ; } return tool tip ; }	optionally add cv numbers and bit numbers to tool tip text based on roster preferences setting.
public final static int read raw until ( final string builder out , final string in , final int start , final char end ) { int pos = start ; while ( pos < in . length ( ) ) { final char ch = in . char at ( pos ) ; if ( ch == end ) { break ; } out . append ( ch ) ; pos ++ ; } return ( pos == in . length ( ) ) ? - num : pos ; }	reads characters until the end character is encountered , ignoring escape sequences .
private static void convert to htm ( attribute set from , mutable attribute set to ) { enumeration keys = from . get attribute names ( ) ; string value = str ; while ( keys . has more elements ( ) ) { object key = keys . next element ( ) ; if ( key instanceof css . attribute ) { value = value + str + key + str + from . get attribute ( key ) + str ; } else { to . add attribute ( key , from . get attribute ( key ) ) ; } } if ( value . length ( ) > num ) { to . add attribute ( html . attribute . style , value ) ; } }	copies the given attributeset to a new set , converting any css attributes found to arguments of an html style attribute .
public synchronized void close ( ) throws io { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }	closes this input stream and releases any system resources associated with the stream.
public void update amount ( ) { set amt ( get total amount ( ) ) ; }	updates the amount on the document.
public void test creation unique ( ) { instances data ; array list < attribute > atts ; string rel name ; rel name = str ; atts = new array list < attribute > ( ) ; atts . add ( new attribute ( str ) ) ; atts . add ( new attribute ( str ) ) ; atts . add ( new attribute ( str , str ) ) ; atts . add ( new attribute ( str , new array list < string > ( arrays . as list ( new string [ ] { str , str , str } ) ) ) ) ; atts . add ( new attribute ( str , new array list < string > ( arrays . as list ( new string [ ] { str , str } ) ) ) ) ; atts . add ( new attribute ( str , ( array list < string > ) null ) ) ; data = new instances ( rel name , atts , num ) ; assert equals ( str , rel name , data . relation name ( ) ) ; assert equals ( str , atts . size ( ) , data . num attributes ( ) ) ; }	tests the creation of a dataset ( unique attribute names ) .
public string evaluate ( x xctxt , int context , org . apache . xml . utils . prefix resolver ns node ) throws javax . xml . transform . transformer exception { if ( null != m simple string ) { return m simple string ; } else if ( null != m parts ) { final fast string buffer buf = get buffer ( ) ; string out = null ; int n = m parts . size ( ) ; try { for ( int i = num ; i < n ; i ++ ) { avt part = ( avt ) m parts . element at ( i ) ; part . evaluate ( xctxt , buf , context , ns node ) ; } out = buf . to string ( ) ; } finally { if ( use object pool ) { string buffer pool . free ( buf ) ; } else { buf . set length ( num ) ; } } return out ; } else { return str ; } }	evaluate the avt and return a string .
public static byte [ ] read dex ( file file ) throws io { return read dex ( file . to path ( ) ) ; }	read the dex file from file , if the file is a zip file , it will return the content of classes.
public void add update listener ( animator update listener listener ) { if ( m update listeners == null ) { m update listeners = new array list < animator update listener > ( ) ; } m update listeners . add ( listener ) ; }	adds a listener to the set of listeners that are sent update events through the life of an animation.
public void run commercial ( string stream , int length ) { if ( stream == null || stream . is empty ( ) ) { commercial result ( stream , str , twitch api . request result . failed ) ; } else { string channel = str + stream ; if ( is channel open ( channel ) ) { g . print line ( channel , str + length + str ) ; } else { g . print line ( str + length + str + stream + str ) ; } api . run commercial ( stream , settings . get string ( str ) , length ) ; } }	tries to run a commercial on the given stream with the given length.
public void add sub tree ( int index , list < node > children ) { list < node descriptor > node descriptors = convert tree nodes helper ( children ) ; roots . add children ( index , node descriptors ) ; list < node > nodes = new array list < > ( ) ; for ( node descriptor child : node descriptors ) { nodes . add ( child . get node ( ) ) ; } if ( ! nodes . is empty ( ) ) { fire event ( new store add event ( index , nodes ) ) ; } }	imports a list of subtrees at the given position in the root of the tree .
void generate while ( tree . while statement that ) { tree . while clause while clause = that . get while clause ( ) ; list < var holder > vars = special conditions and block ( while clause . get condition list ( ) , while clause . get block ( ) , str , bool ) ; for ( var holder v : vars ) { v . forget ( ) ; } }	generates js code for a whilestatement .
public static double igamma ( double a , double x ) { double coef = ( math . exp ( - x ) * math . pow ( x , a ) ) / gamma ( a ) ; double sum = num ; for ( int i = num ; i < num ; i ++ ) { sum += ( gamma ( a ) / gamma ( a + num + ( double ) i ) ) * math . pow ( x , ( double ) i ) ; } return ( coef * sum ) ; }	calculates the incomplete gamma function for two doubles.
public void initialize active slots list ( string slots ) { if ( active slots list == null ) { active slots list = new array list < string > ( ) ; } for ( string s : slots . split ( str ) ) { active slots list . add ( s ) ; } }	add slots to list where slotactivateditem can be activated when equipped .
private static string convert action type to intent ( raml action type action type , boolean is target collection ) { switch ( action type ) { case delete : return str ; case get : return str ; case post : if ( is target collection ) { return str ; } case put : return str ; case patch : return str ; default : return str ; } }	attempts to convert the http verb into a textual representation of intent based on rest conventions.
public static string hide ( final string key ) { return is hidden ( key ) ? key : hidden prefix . concat ( key ) ; }	turn the provided key into a hidden key.
private synchronized i remove mqtt token ( bundle data ) { string activity token = data . get string ( mqtt service constants . callback activity token ) ; if ( activity token != null ) { int token number = integer . parse int ( activity token ) ; i token = token map . get ( token number ) ; token map . delete ( token number ) ; return token ; } return null ; }	get a token identified by a string , and remove it from our map.
public static boolean is explicit all type ( string [ ] types ) { return types != null && types . length == num && all . equals ( types [ num ] ) ; }	identifies whether the array containing type names given as argument explicitly refers to all types the empty or null array doesn ' t explicitly map to all types.
private string read until ( char [ ] delimiter , boolean return text ) throws io , xml pull parser exception { int start = position ; string builder result = null ; if ( return text && text != null ) { result = new string builder ( ) ; result . append ( text ) ; } search : while ( bool ) { if ( position + delimiter . length > limit ) { if ( start < position && return text ) { if ( result == null ) { result = new string builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill buffer ( delimiter . length ) ) { check relaxed ( unexpected eof ) ; type = comment ; return null ; } start = position ; } for ( int i = num ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! return text ) { return null ; } else if ( result == null ) { return string pool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . to string ( ) ; } }	reads text until the specified delimiter is encountered.
private config ( ) { throw new assertion error ( str ) ; }	this class cannot be instantiated .
public boolean is leaf ( ) { return children == null || children . is empty ( ) ; }	true , if the node is a leaf .
private boolean is valid ( char sequence text ) { for ( int i = num ; i < text . length ( ) ; i ++ ) { char c = text . char at ( i ) ; boolean valid = c == num || c == num || c == num || ( c >= num && c <= num ) || ( c >= num && c <= num ) ; if ( ! valid ) { return bool ; } } return bool ; }	returns true if all of the characters in the text are permitted for use in xml documents .
public static void interrupt ( final thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }	interrupts the specified thread , guarding against null . < p / >.
private void write object ( java . io . object output stream s ) throws java . io . io { s . default write object ( ) ; s . write int ( attrs . size ( ) ) ; enumeration < attribute > attr enum = attrs . elements ( ) ; while ( attr enum . has more elements ( ) ) { s . write object ( attr enum . next element ( ) ) ; } }	overridden to avoid exposing implementation details .
public static container east ( component east ) { return container . enclose in ( new border layout ( ) , east , border layout . east ) ; }	convenience method that creates a border layout container and places the given component in the east.
public static object [ ] put all ( ) { region region = cache . get region ( region . separator + region name ) ; assert not null ( region ) ; try { map map = new linked hash map ( ) ; map . put ( putall ke , putall valu ) ; map . put ( putall ke , putall valu ) ; map . put ( putall ke , putall valu ) ; map . put ( putall ke , putall valu ) ; map . put ( putall ke , putall valu ) ; region . put all ( map , str ) ; id [ ] evids = new id [ num ] ; evids [ num ] = put allevent id1 ; evids [ num ] = put allevent id2 ; evids [ num ] = put allevent id3 ; evids [ num ] = put allevent id4 ; evids [ num ] = put allevent id5 ; assert not null ( evids [ num ] ) ; assert not null ( evids [ num ] ) ; assert not null ( evids [ num ] ) ; assert not null ( evids [ num ] ) ; assert not null ( evids [ num ] ) ; return evids ; } catch ( exception e ) { fail ( str + e ) ; } return null ; }	does an update and return the eventid generated . eventid is caught in the listener and stored in a static variable.
public void load layout ( file o file , boolean new tab ) { load layout ( o file , new tab , bool ) ; }	load a layout from a file . supports loading binary and xml serialized flow files.
public void track ( file file , object marker , file delete strategy delete strategy ) { if ( file == null ) { throw new null pointer exception ( str ) ; } add tracker ( file . get path ( ) , marker , delete strategy ) ; }	track the specified file , using the provided marker , deleting the file when the marker instance is garbage collected.
public static string separators to unix ( string path ) { if ( path == null || path . index of ( windows separator ) == - num ) { return path ; } return path . replace ( windows separator , unix separator ) ; }	converts all separators to the unix separator of forward slash .
public boolean has parameter ( string name ) { return parameters . has parameter ( name ) ; }	checks if the extension contains a parameter .
@ override public long free memory ( long window id ) throws io { long size = key stream . data size up to window ( window id ) + value stream . data size up to window ( window id ) ; windows for free memory . add ( window id ) ; return size ; }	free memory up to the given windowid this method will be called by another thread.
public static boolean is sq ( string identifier ) { if ( identifier == null ) { throw new null pointer exception ( str ) ; } return arrays . binary search ( sq non reserved , identifier . to upper case ( ) ) >= num ; }	returns true if the given identifier is a sql - 99 non - reserved keyword .
@ suppress warnings ( str ) public static < t > void sort ( list < t > list , comparator < ? super t > comparator ) { t [ ] array = list . to array ( ( t [ ] ) new object [ list . size ( ) ] ) ; arrays . sort ( array , comparator ) ; int i = num ; list iterator < t > it = list . list iterator ( ) ; while ( it . has next ( ) ) { it . next ( ) ; it . set ( array [ i ++ ] ) ; } }	sorts the specified list using the specified comparator.
@ override public long handle commit ( final long commit time ) { if ( error != null ) throw new index inconsistent error ( error ) ; final i view = journal . get root block view ( ) ; final byte buffer rbv = view . as read only buffer ( ) ; final byte buffer bb = byte buffer . allocate ( rbv . capacity ( ) ) ; for ( int i = num ; i < rbv . capacity ( ) ; i ++ ) { bb . put ( rbv . get ( ) ) ; } bb . flip ( ) ; return journal . write ( bb ) ; }	write the current root block to the journal and return its address to be stored in the commitrecord .
public boolean is append task name ( ) { return append task name ; }	checks if the appendtaskname flag is set .
public static final string to string ( string str ) { if ( str == null ) return str ; byte array output stream buffer = new byte array output stream ( ) ; to byte array ( buffer , str ) ; return buffer . to string ( ) ; }	provides a java string literal representing the parameter string.
public static cache . entry make random cache entry ( byte [ ] data , boolean is expired , boolean needs refresh ) { random random = new random ( ) ; cache . entry entry = new cache . entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . next int ( num ) ] ; } entry . etag = string . value of ( random . next long ( ) ) ; entry . last modified = random . next long ( ) ; entry . ttl = is expired ? num : long . max value ; entry . soft ttl = needs refresh ? num : long . max value ; return entry ; }	makes a random cache entry .
public static double max ( double [ ] data ) { double max = double . n ; for ( int i = num ; i < data . length ; i ++ ) { if ( double . is na n ( data [ i ] ) ) continue ; if ( double . is na n ( max ) || data [ i ] > max ) max = data [ i ] ; } return max ; }	find the maximum of all elements in the array , ignoring elements that are nan .
private static boolean is start element ( string line ) { int first = line . last index of ( str ) ; int last = line . last index of ( str ) ; if ( last < first ) { return bool ; } else { int first end = line . last index of ( str ) ; int last end = line . last index of ( str ) ; if ( ( first end != first ) && ( ( last end + num ) != last ) ) { return bool ; } } return bool ; }	tries to find out if the line finishes with an element start.
long read long ( ) throws io { return ( ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) << num ) | ( ( long ) is . read ( ) ) ) ; }	parses a 64 - bit int .
@ override public instance remove ( int index ) { return m . remove ( index ) ; }	removes the instance at the given position .
protected static string extract access key ( string s3uri ) { return s3uri . substring ( s3uri . index of ( str ) + num , s3uri . index of ( str , s3uri . index of ( str ) + num ) ) ; }	extracts the accesskey from the given uri.
public boolean do transaction ( db db , object threadstate ) throws workload exception { boolean ret = bool ; long st = system . nano time ( ) ; string op = operationchooser . next string ( ) ; if ( op . compare to ( str ) == num ) { ret = do transaction read ( db ) ; } else if ( op . compare to ( str ) == num ) { ret = do transaction update ( db ) ; } else if ( op . compare to ( str ) == num ) { ret = do transaction insert ( db ) ; } else if ( op . compare to ( str ) == num ) { ret = do transaction scan ( db ) ; } else { ret = do transaction read modify write ( db ) ; } long en = system . nano time ( ) ; measurements . measure ( operations . get ( op ) , ( int ) ( ( en - st ) / num ) ) ; if ( ret ) measurements . report return code ( operations . get ( op ) , - num ) ; else { measurements . report return code ( operations . get ( op ) , num ) ; } actualopcount . add and get ( num ) ; return ret ; }	do one transaction operation.
public to string helper add value ( boolean value ) { return add holder ( string . value of ( value ) ) ; }	adds an unnamed value to the formatted output .
public static void copy except ( object src , object dst , int old size , int remove index ) { if ( remove index > num && old size > num ) { system . arraycopy ( src , num , dst , num , remove index ) ; } if ( remove index < old size ) { system . arraycopy ( src , remove index + num , dst , remove index , old size - remove index - num ) ; } }	copy the elements of an array , and remove one element .
public site monitor ( string [ ] url list ) { site url list = url list ; }	constructs a webtopnaming $ sitemonitor object with the provided site urls .
private set union ip ( byte [ ] ip with submask1 , byte [ ] ip with submask2 ) { set set = new hash set ( ) ; if ( arrays . are equal ( ip with submask1 , ip with submask2 ) ) { set . add ( ip with submask1 ) ; } else { set . add ( ip with submask1 ) ; set . add ( ip with submask2 ) ; } return set ; }	calculates the union if two ip ranges .
public optional < blaze vertex > vertex ( final string vertex id ) { try ( final closeable iterator < vertex > it = vertices ( vertex id ) ) { final optional < blaze vertex > v = it . has next ( ) ? optional . of ( ( blaze vertex ) it . next ( ) ) : optional . empty ( ) ; if ( it . has next ( ) ) { throw new illegal state exception ( str + vertex id ) ; } return v ; } }	lookup a vertex by id .
public static long add and get ( atomic long current , long to add ) { long u , r ; do { r = current . get ( ) ; if ( r == long . max value ) { return long . max value ; } u = add cap ( r , to add ) ; } while ( ! current . compare and set ( r , u ) ) ; return u ; }	concurrent addition bound to long.
private void start ( http servlet request request , http servlet response response ) throws io { string label = request . get parameter ( str ) ; string detail = request . get parameter ( str ) ; mon key key = get mon key ( label , detail , default units ) ; start mon ( key ) ; print writer out = response . get writer ( ) ; out . println ( ok + str + label ) ; }	start a monitor by providing a summary label and optionally a detail string.
public double norm ( ) { double sum = num ; for ( int i = num ; i < components . length ; i ++ ) sum += components [ i ] * components [ i ] ; return math . sqrt ( sum ) ; }	computes the norm of a vector .
public static double p ( int y [ ] [ ] , int ypred [ ] [ ] ) { int all missings = num ; int n = y . length ; double loss = num ; for ( int i = num ; i < n ; i ++ ) { if ( all missing ( y [ i ] ) ) { all missings ++ ; continue ; } double cur loss = p ( y [ i ] , ypred [ i ] ) ; if ( double . is na n ( cur loss ) ) { all missings ++ ; continue ; } loss += cur loss ; } return loss / ( double ) ( n - all missings ) ; }	harmonic accuracy - - average over all labels.
public void write entry ( c cos ) throws io { cos . write16 ( ad type ) ; cos . write32 ( ad data . length ) ; cos . write ( ad data , num , ad data . length ) ; }	writes the entry ' s data fields in fcc format to an output stream .
public closeable animated bitmap ( list < bitmap > bitmaps , list < integer > durations , resource releaser < bitmap > resource releaser ) { preconditions . check not null ( bitmaps ) ; preconditions . check state ( bitmaps . size ( ) >= num , str ) ; m bitmaps = new array list < > ( ) ; m bitmap references = new array list < > ( ) ; for ( bitmap bitmap : bitmaps ) { m bitmap references . add ( closeable reference . of ( bitmap , resource releaser ) ) ; m bitmaps . add ( bitmap ) ; } m durations = preconditions . check not null ( durations ) ; preconditions . check state ( m durations . size ( ) == m bitmaps . size ( ) , str ) ; }	creates a new instance of a closeablestaticbitmap .
public static string read label file ( string entry separator , boolean ensure initial boundary , string trfname ) throws io { buffered reader lab = new buffered reader ( new file reader ( trfname ) ) ; try { xwaves labelfile reader xlds = new xwaves labelfile reader ( trfname ) ; string result = string utils . join ( entry separator , xlds . get label symbols ( ) ) ; if ( ensure initial boundary && result . char at ( num ) != str ) { result = str + entry separator + result ; } return result ; } finally { lab . close ( ) ; } }	this reads in a label file and returns a string of the phonetic symbols , separated by the entry separator character entryseparator .
converter set add ( converter converter , converter [ ] removed ) { converter [ ] converters = i converters ; int length = converters . length ; for ( int i = num ; i < length ; i ++ ) { converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ num ] = null ; } return this ; } if ( converter . get supported type ( ) == existing . get supported type ( ) ) { converter [ ] copy = new converter [ length ] ; for ( int j = num ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ num ] = existing ; } return new converter set ( copy ) ; } } converter [ ] copy = new converter [ length + num ] ; system . arraycopy ( converters , num , copy , num , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ num ] = null ; } return new converter set ( copy ) ; }	returns a copy of this set , with the given converter added.
private void parse ( ) throws sax { x xstream = ( x ) properties . get ( configured xstream property ) ; if ( xstream == null ) { xstream = new x ( ) ; } final list < ? > source = ( list < ? > ) properties . get ( source object list property ) ; if ( source == null || source . is empty ( ) ) { throw new sax ( str + source object list property + str ) ; } try { start document ( bool ) ; for ( final object name : source ) { xstream . marshal ( name , this ) ; } end document ( bool ) ; } catch ( final stream exception e ) { if ( e . get cause ( ) instanceof sax ) { throw ( sax ) e . get cause ( ) ; } else { throw new sax ( e ) ; } } }	serializes the java objects of the configured list into a flow of sax events .
private sorted map < message uid , maildir message name > truncate map ( map < message uid , maildir message name > map , message uid from , message uid to ) { tree map < message uid , maildir message name > sorted map ; if ( map instanceof tree map < ? , ? > ) sorted map = ( tree map < message uid , maildir message name > ) map ; else sorted map = new tree map < message uid , maildir message name > ( map ) ; if ( to != null ) return sorted map . sub map ( from , to . next ( ) ) ; return sorted map . tail map ( from ) ; }	sorts the given map and returns a subset which is constricted by a lower and an upper limit .
public void dump index ( boolean show bounds ) throws io { byte ix record [ ] = new byte [ spatial index record length ] ; int rec num = num ; if ( shp file name == null ) { return ; } binary buffered file ssx = new binary buffered file ( ssx ( shp file name ) ) ; ssx . seek ( num ) ; while ( bool ) { int result = ssx . read ( ix record , num , spatial index record length ) ; if ( result <= num ) { logger . info ( str + rec num + str ) ; break ; } else { rec num ++ ; int offset = read be ( ix record , num ) ; int length = read be ( ix record , num ) ; logger . info ( str + rec num + str + offset + str + length + ( show bounds ? ( str + read le ( ix record , num ) + str + read le ( ix record , num ) + str + read le ( ix record , num ) + str + read le ( ix record , num ) ) : str ) ) ; } } ssx . close ( ) ; }	displays the contents of this index .
private static boolean compare param ( string jdiff param , type reflection param type ) { if ( jdiff param == null ) { return bool ; } string reflection param = type to string ( reflection param type ) ; if ( jdiff param . equals ( reflection param ) ) { return bool ; } int jdiff param end offset = jdiff param . index of ( str ) ; int reflection param end offset = reflection param . index of ( str ) ; if ( jdiff param end offset != - num && reflection param end offset != - num ) { jdiff param = jdiff param . substring ( num , jdiff param end offset ) ; reflection param = reflection param . substring ( num , reflection param end offset ) ; return jdiff param . equals ( reflection param ) ; } return bool ; }	compares the parameter from the api and the parameter from reflection .
public static void random number ( int [ ] num , int n ) { for ( int j = num ; j < n ; j ++ ) { num [ j ] = ( int ) ( math . random ( ) * num ) ; } }	generate random number of size n directly into num.
private static string escape json ( string text ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; for ( int index = num ; index < text . length ( ) ; index ++ ) { char chr = text . char at ( index ) ; switch ( chr ) { case str : case str : builder . append ( str ) ; builder . append ( chr ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; default : if ( chr < str ) { string t = str + integer . to hex string ( chr ) ; builder . append ( str + t . substring ( t . length ( ) - num ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( str ) ; return builder . to string ( ) ; }	escape a string to create a valid json string.
public void write to ( output stream out ) throws io { byte string [ ] cached flush buffers ; byte [ ] cached buffer ; int cached buffer pos ; synchronized ( this ) { cached flush buffers = flushed buffers . to array ( new byte string [ flushed buffers . size ( ) ] ) ; cached buffer = buffer ; cached buffer pos = buffer pos ; } for ( byte string byte string : cached flush buffers ) { byte string . write to ( out ) ; } out . write ( copy array ( cached buffer , cached buffer pos ) ) ; }	writes the complete contents of this byte array output stream to the specified output stream argument .
private void check headings hierarchy ( elements elements , test solution handler test solution handler ) { if ( elements . is empty ( ) ) { test solution handler . add test solution ( test solution . not applicable ) ; return ; } test solution check result = test solution . passed ; iterator < element > iter = elements . iterator ( ) ; element element = iter . next ( ) ; int index of reference = get header index ( element ) ; int current index ; int previous index = index of reference ; element element of reference = element ; element previous element = element ; while ( iter . has next ( ) ) { element = iter . next ( ) ; current index = get header index ( element ) ; if ( current index != - num ) { if ( current index - previous index >= num ) { check result = test solution . failed ; add source code remark ( test solution . failed , element , header not hierarchically well defined msg , get evidence element ( previous h tag index ee , get evidence element msg ( previous index , previous element ) ) ) ; } else if ( current index < index of reference ) { check result = test solution . failed ; add source code remark ( test solution . failed , element , header not hierarchically well defined msg , get evidence element ( first h tag index ee , get evidence element msg ( index of reference , element of reference ) ) ) ; } previous index = current index ; previous element = element ; } } test solution handler . add test solution ( check result ) ; }	this methods checks whether the headings hierarchy is well - structured.
public iterator < json element > iterator ( ) { return elements . iterator ( ) ; }	returns an iterator to navigate the elements of the array.
public void mouse wheel moved ( mouse wheel event e ) { boolean accepted = check modifiers ( e ) ; if ( accepted == bool ) { visualization viewer < ? , ? > vv = ( visualization viewer < ? , ? > ) e . get source ( ) ; d mouse = e . get point ( ) ; d center = vv . get center ( ) ; int amount = e . get wheel rotation ( ) ; if ( zoom at mouse ) { if ( amount > num ) { scaler . scale ( vv , in , mouse ) ; } else if ( amount < num ) { scaler . scale ( vv , out , mouse ) ; } } else { if ( amount > num ) { scaler . scale ( vv , in , center ) ; } else if ( amount < num ) { scaler . scale ( vv , out , center ) ; } } e . consume ( ) ; vv . repaint ( ) ; } }	zoom the display in or out , depending on the direction of the mouse wheel motion .
protected void assert func equals ( final string ... inputs ) throws exception { solr query request req = req ( ) ; try { assert func equals ( req , inputs ) ; } finally { req . close ( ) ; } }	the function name for val parser coverage checking is extracted from the first input.
public boolean equivalent ( imf other ) { if ( other == null ) { return bool ; } boolean result = bool ; result &= offset . equals ( other . get offset ( ) ) ; result &= label . equivalent ( other . get label ( ) ) ; return result ; }	a method to determine the equivalence of any two markers .
public static array list < long > load workspace screens db ( context context ) { final content resolver content resolver = context . get content resolver ( ) ; final uri screens uri = launcher settings . workspace screens . content uri ; final cursor sc = content resolver . query ( screens uri , null , null , null , launcher settings . workspace screens . screen rank ) ; array list < long > screen ids = new array list < long > ( ) ; try { final int id index = sc . get column index or throw ( launcher settings . workspace screens . id ) ; while ( sc . move to next ( ) ) { try { screen ids . add ( sc . get long ( id index ) ) ; } catch ( exception e ) { launcher . add dump log ( tag , str + str + e , bool ) ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return screen ids ; }	loads the workspace screen ids in an ordered list .
private boolean render output ( node node , internal context adapter context , writer writer ) throws io , method invocation exception , resource not found exception { string arg = str ; if ( node == null ) { rsvc . error ( str ) ; return bool ; } object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( str ) ; return bool ; } arg = value . to string ( ) ; resource resource = null ; try { resource = rsvc . get content ( arg , get input encoding ( context ) ) ; } catch ( resource not found exception rnfe ) { rsvc . error ( str + arg + str + context . get current template name ( ) + str + get line ( ) + str + get column ( ) + str ) ; throw rnfe ; } catch ( exception e ) { rsvc . error ( str + arg + str + context . get current template name ( ) + str + get line ( ) + str + get column ( ) + str + e ) ; } if ( resource == null ) return bool ; writer . write ( ( string ) resource . get data ( ) ) ; return bool ; }	does the actual rendering of the included file.
protected string e ( string s ) throws exception { return fmt . format ( parser . parse ( s , null ) ) ; }	macro : expected : parses s , fmts.
public matrix4 multiply by scale ( double x scale , double y scale , double z scale ) { double [ ] m = this . m ; m [ num ] *= x scale ; m [ num ] *= x scale ; m [ num ] *= x scale ; m [ num ] *= x scale ; m [ num ] *= y scale ; m [ num ] *= y scale ; m [ num ] *= y scale ; m [ num ] *= y scale ; m [ num ] *= z scale ; m [ num ] *= z scale ; m [ num ] *= z scale ; m [ num ] *= z scale ; return this ; }	multiplies this matrix by a scale matrix with specified values .
public void change state ( ) { linked = ! linked ; link = linked ? linked im ic . get image ( ) : unlinked im ic . get image ( ) ; repaint ( ) ; }	changes the lock icon ' s image to whatever it currently is not.
public static geometry buffer by segments ( geometry g , double distance ) { geometry segs = line handling functions . extract segments ( g ) ; double pos dist = math . abs ( distance ) ; geometry seg buf = buffer by components ( segs , pos dist ) ; if ( distance < num ) return g . difference ( seg buf ) ; return g . union ( seg buf ) ; }	buffer polygons by buffering the individual boundary segments and either unioning or differencing them .
public void record end time ( ) { int ms diff = ( int ) ( system . current time millis ( ) - current request start time . get ( ) ) ; log . info ( str , ms diff ) ; update or reset req rsp avg lst hr ( update or reset req rsp avg lst min ( ms diff , bool ) , bool ) ; update min max req rsp ms ( ms diff ) ; if ( ms diff >= suspiscious rsp time ms ) { alert log . warn ( message format . format ( str , ms diff ) ) ; } current request start time . remove ( ) ; }	computes the response time of the request that just finished for the local thread and updates the request response average in the last minute , and propagates to the request response per minute per hour counter.
private boolean is accessible user to kibana ( set < string > filters ) { if ( filters . contains ( str ) ) { return bool ; } return bool ; }	check if an user has auth to kibana.
public boolean clear ( ) { try { list . clear ( ) ; fire table data changed ( ) ; } catch ( exception e ) { return bool ; } return bool ; }	remove all entries from the table list .
public static final int type index ( class type ) { class [ ] list = primitive types ; int n = list . length ; for ( int i = num ; i < n ; i ++ ) if ( list [ i ] == type ) return i ; throw new runtime exception ( str + type . get name ( ) ) ; }	returns an index for accessing arrays in this class .
public boolean load ( file fi ) throws jmri configure xml exception { return load ( fi , bool ) ; }	load a file . < p > handles problems locally to the extent that it can , by routing them to the creationerrorencountered method .
public string parameter to string ( object param ) { if ( param == null ) { return str ; } else if ( param instanceof date ) { return format date ( ( date ) param ) ; } else if ( param instanceof collection ) { string builder b = new string builder ( ) ; for ( object o : ( collection ) param ) { if ( b . length ( ) > num ) { b . append ( str ) ; } b . append ( string . value of ( o ) ) ; } return b . to string ( ) ; } else { return string . value of ( param ) ; } }	format the given parameter object into string .
private void calculate grid sizes ( float numbers radius , float x center , float y center , float text size , float [ ] text grid heights , float [ ] text grid widths ) { float offset1 = numbers radius ; float offset2 = numbers radius * ( ( float ) math . sqrt ( num ) ) / num ; float offset3 = numbers radius / num ; m paint . set text size ( text size ) ; y center -= ( m paint . descent ( ) + m paint . ascent ( ) ) / num ; text grid heights [ num ] = y center - offset1 ; text grid widths [ num ] = x center - offset1 ; text grid heights [ num ] = y center - offset2 ; text grid widths [ num ] = x center - offset2 ; text grid heights [ num ] = y center - offset3 ; text grid widths [ num ] = x center - offset3 ; text grid heights [ num ] = y center ; text grid widths [ num ] = x center ; text grid heights [ num ] = y center + offset3 ; text grid widths [ num ] = x center + offset3 ; text grid heights [ num ] = y center + offset2 ; text grid widths [ num ] = x center + offset2 ; text grid heights [ num ] = y center + offset1 ; text grid widths [ num ] = x center + offset1 ; }	using the trigonometric unit circle , calculate the positions that the text will need to be drawn at based on the specified circle radius.
public synchronized void flush ( ) throws io { check not closed ( ) ; trim to size ( ) ; trim to file count ( ) ; journal writer . flush ( ) ; }	force buffered operations to the filesystem .
private final string [ ] expand seen names ( string [ ] old shared ) { int len = old shared . length ; string [ ] new shared ; if ( len == num ) { new shared = smile buffer recycler . alloc seen names buffer ( ) ; if ( new shared == null ) { new shared = new string [ smile buffer recycler . default name buffer length ] ; } } else if ( len == smile constants . max shared names ) { new shared = old shared ; seen name count = num ; } else { int new size = ( len == smile buffer recycler . default string value buffer length ) ? num : smile constants . max shared names ; new shared = new string [ new size ] ; system . arraycopy ( old shared , num , new shared , num , old shared . length ) ; } return new shared ; }	method called to try to expand shared name area to fit one more potentially shared string . if area is already at its biggest size , will just clear the area ( by setting next - offset to 0 ).
public void add request property ( string key , string value ) { if ( connected ) throw new illegal state exception ( str ) ; if ( key == null ) throw new null pointer exception ( str ) ; if ( requests == null ) requests = new message header ( ) ; requests . add ( key , value ) ; }	adds a general request property specified by a key - value pair.
server member update ( address client address , instant time ) { if ( client address != null ) { this . client address = client address ; if ( time . is after ( updated ) ) { this . updated = assert . not null ( time , str ) ; } } return this ; }	updates the member client address .
public static boolean is org level only ( int ad id , int ad id ) { boolean share = is shared ( ad id , ad id ) ; if ( share != null ) return ! share . boolean value ( ) ; return bool ; }	is table org level only.
public runnable decrement as runnable ( ) { return m decrement runnable ; }	convenience method to decrement this trigger as a runnable .
@ override public void action performed ( action event event ) { string command = event . get action command ( ) ; if ( command . equals ( str ) ) { attempt modify background paint ( ) ; } }	handles user interactions with the panel .
public byte [ ] serialize to buffer ( object o ) throws io { byte array output stream buf out = new byte array output stream ( ) ; try { serialize ( buf out , o ) ; buf out . flush ( ) ; return buf out . to byte array ( ) ; } finally { buf out . close ( ) ; } }	serializes the object into a byte buffer .
module pointer resolve ( string mod name ) { return ( module pointer ) context . get ( mod name ) ; }	find the modulepointer that the string modname resolves to ; return null if either modname is not found in the context or if it is found and resolves to null , i.
public void add cert store ( cert store store ) { if ( store == null ) { return ; } if ( cert stores == null ) { cert stores = new array list < cert store > ( ) ; } cert stores . add ( store ) ; }	adds a certificate store to the list of certificate stores that are used to find certificates and crls .
public nar class loader ( final file nar working directory ) throws class not found exception , io { super ( new url [ num ] ) ; this . nar working directory = nar working directory ; update classpath ( nar working directory ) ; }	construct a nar class loader .
public block block ( ) { return block ; }	returns the basic block indicated by this node .
public static type binding [ ] substitute ( substitution substitution , type binding [ ] original types ) { if ( original types == null ) return null ; type binding [ ] substituted types = original types ; for ( int i = num , length = original types . length ; i < length ; i ++ ) { type binding original type = original types [ i ] ; type binding substituted parameter = substitute ( substitution , original type ) ; if ( substituted parameter != original type ) { if ( substituted types == original types ) { system . arraycopy ( original types , num , substituted types = new type binding [ length ] , num , i ) ; } substituted types [ i ] = substituted parameter ; } else if ( substituted types != original types ) { substituted types [ i ] = original type ; } } return substituted types ; }	returns an array of types , where original types got substituted given a substitution.
private boolean check if scrolling ( float [ ] last points , motion event ev ) { float [ ] point = new float [ num ] ; point [ num ] = ev . get raw x ( ) ; point [ num ] = ev . get raw y ( ) ; float delta = get distance ( last points , point ) ; return math . abs ( delta ) > m slop ; }	checks to see if the user is currently scrolling the menu .
public void test merge one filter into document with same filter ( ) throws exception { string src xml = str + str + str + str + str + str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge filters ( merge web xml ) ; assert true ( web xml utils . has filter ( src web xml , str ) ) ; }	tests whether a single filter in the merge descriptor is ignored because a filter with the same name already exists in the source descriptor .
public edge ( s src , symbol symbol , s dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . src item = src . get first item ( ) ; this . hash cache = calc hash code ( ) ; }	edge which leads to another non - accepting state .
public void push ( final type value ) { if ( value == null ) { mv . visit insn ( opcodes . aconst null ) ; } else { switch ( value . get sort ( ) ) { case type . boolean : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . char : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . byte : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . short : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . int : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . float : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . long : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; case type . double : mv . visit field insn ( opcodes . getstatic , str , str , cldesc ) ; break ; default : mv . visit ldc insn ( value ) ; } } }	generates the instruction to push the given value on the stack .
public extended text label create extended ( font font , core metrics lm , decoration decorator , int start , int limit ) { if ( start >= limit || start < line start || limit > line limit ) { throw new illegal argument exception ( str + start + str + limit ) ; } int level = line bidi == null ? num : line bidi . get level at ( start - line start ) ; int linedir = ( line bidi == null || line bidi . base is left to right ( ) ) ? num : num ; int layout flags = flags & ~ num ; if ( ( level & num ) != num ) layout flags |= num ; if ( ( linedir & num ) != num ) layout flags |= num ; text source source = new standard text source ( text , start , limit - start , line start , line limit - line start , level , layout flags , font , frc , lm ) ; return new extended text source label ( source , decorator ) ; }	create an extended glyph array for the text between start and limit .
public static string right pad ( string s , int min length , char filling ) { int ln = s . length ( ) ; if ( min length <= ln ) { return s ; } string builder res = new string builder ( min length ) ; res . append ( s ) ; int dif = min length - ln ; for ( int i = num ; i < dif ; i ++ ) { res . append ( filling ) ; } return res . to string ( ) ; }	pads the string at the right with the specified character until it reaches the desired length.
public final boolean is supported ( string feature , string version ) { return implementation . has feature ( feature , version ) ; }	ask whether we support a given dom feature.
public void clear ( ) { fully lock ( ) ; try { for ( node < e > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . get and set ( num ) == capacity ) not full . signal ( ) ; } finally { fully unlock ( ) ; } }	atomically removes all of the elements from this queue.
private static string read quoted descriptor ( final substring reader reader , final boolean allow compat chars ) throws decode exception { int length = num ; reader . skip whitespaces ( ) ; try { char c = reader . read ( ) ; if ( c != str ) { throw decode exception . error ( err attr syntax expected quote at po . get ( reader . pos ( ) - num , c ) ) ; } reader . mark ( ) ; while ( ( c = reader . read ( ) ) != str ) { if ( length == num && ! is alpha ( c ) ) { throw decode exception . error ( err attr syntax illegal char in string oi . get ( c , reader . pos ( ) - num ) ) ; } if ( ! is key char ( c , allow compat chars ) ) { throw decode exception . error ( err attr syntax illegal char in string oi . get ( c , reader . pos ( ) - num ) ) ; } length ++ ; } reader . reset ( ) ; final string descr = reader . read ( length ) ; reader . read ( ) ; return descr ; } catch ( final string index out of bounds exception e ) { throw decode exception . error ( err attr syntax truncated valu . get ( ) ) ; } }	reads the value of a string enclosed in single quotes , skipping over the quotes and any leading spaces .
public string to csv ( ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( str ) ; for ( t predicted : classes ) { builder . append ( string . format ( str , predicted ) ) ; } builder . append ( str ) ; string first column label = str ; for ( t actual : classes ) { builder . append ( first column label ) ; first column label = str ; builder . append ( string . format ( str , actual ) ) ; for ( t predicted : classes ) { builder . append ( get count ( actual , predicted ) ) ; builder . append ( str ) ; } builder . append ( get actual total ( actual ) ) ; builder . append ( str ) ; } builder . append ( str ) ; for ( t predicted : classes ) { builder . append ( get predicted total ( predicted ) ) ; builder . append ( str ) ; } builder . append ( str ) ; return builder . to string ( ) ; }	outputs the confusionmatrix as comma - separated values for easy import into spreadsheets.
public void test case9 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two positive numbers of different length.
public object assign id value ( object data , number val , object cache object cache ) throws sql { object id val = data persister . convert id number ( val ) ; if ( id val == null ) { throw new sql ( str + data persister + str + this ) ; } else { assign field ( data , id val , bool , object cache ) ; return id val ; } }	assign an id value to this field .
public static void write swapped integer ( output stream output , int value ) throws io { output . write ( ( byte ) ( ( value > > num ) & num ) ) ; output . write ( ( byte ) ( ( value > > num ) & num ) ) ; output . write ( ( byte ) ( ( value > > num ) & num ) ) ; output . write ( ( byte ) ( ( value > > num ) & num ) ) ; }	writes a " int " value to an outputstream.
public final boolean is open ( ) { return closed . get ( ) == bool ; }	returns true if this lock is still open ie.
public static map < string , object > perform find list ( dispatch context dctx , map < string , object > context ) { integer view size = ( integer ) context . get ( str ) ; if ( view size == null ) view size = integer . value of ( num ) ; context . put ( str , view size ) ; integer view index = ( integer ) context . get ( str ) ; if ( view index == null ) view index = integer . value of ( num ) ; context . put ( str , view index ) ; map < string , object > result = perform find ( dctx , context ) ; int start = view index . int value ( ) * view size . int value ( ) ; list < generic value > list = null ; integer list size = num ; try { entity list iterator it = ( entity list iterator ) result . get ( str ) ; list = it . get partial list ( start + num , view size ) ; list size = it . get results size after partial list ( ) ; it . close ( ) ; } catch ( exception e ) { debug . log info ( str + e , module ) ; } result . put ( str , list size ) ; result . put ( str , list ) ; result . remove ( str ) ; return result ; }	same as performfind but now returning a list instead of an iterator extra parameters viewindex : startpage of the partial list ( 0 = first page ) viewsize : the length of the page ( number of records ) extra output parameter : listsize : size of the totallist list : the list itself .
public static string soap to string ( soap element ) { return dom to string ( element . get owner document ( ) ) ; }	converts a javax . xml . soap . soapelement to a string can be used for soapui requests be carefull : to convert a soapmessage sm , you must use sm . getsoappart ( ) . getenvelope ( ) ;.
@ override public void close ( ) throws io { try { out . close ( ) ; } finally { lock file . delete ( ) ; } }	closes the file writer and deletes the lockfile ( if possible ) .
public static void init ( context context ) { if ( camera manager == null ) { camera manager = new camera manager ( context ) ; } }	initializes this static object with the context of the calling activity .
@ override public boolean equals ( object x , object y ) throws hibernate exception { if ( x == null ) { return y == null ; } return x . equals ( y ) ; }	compare two instances of the class mapped by this type for persistence " equality ".
@ override public final void write boolean ( boolean v ) throws io { dis . write boolean ( v ) ; }	write a booleans as one byte .
public void train ( set < string > s file names ) { iterator < string > i file = s file names . iterator ( ) ; while ( i file . has next ( ) ) { string s text = utils . load file to string ( i file . next ( ) ) ; train ( s text ) ; } }	train the statistics of the chunker from a given file set .
public void test find spring open ldap with limit ( ) { ldap proxy proxy = get ldap open ldap ( ) ; list result = null ; int limit = num ; try { result = proxy . find ( get ldap search vo ( str , limit , str , str , null , ldap scope constants . scope subtree ) ) ; } catch ( exception e ) { } assert not null ( result ) ; if ( result != null ) { assert equals ( limit , result . size ( ) ) ; } }	test de busqueda open ldap con limite.
public printf format ( string fmt arg ) throws illegal argument exception { this ( locale . get default ( ) , fmt arg ) ; }	constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings.
static double svd pythag ( double a , double b ) { double p , r , s , t , u , temp ; p = svd dmax ( math . abs ( a ) , math . abs ( b ) ) ; if ( p != num ) { temp = svd dmin ( math . abs ( a ) , math . abs ( b ) ) / p ; r = temp * temp ; t = num + r ; while ( t != num ) { s = r / t ; u = num + num * s ; p *= u ; temp = s / u ; r *= temp * temp ; t = num + r ; } } return p ; }	funtions used - - - - - - - - - - - - - utility dmax , dmin.
public static void write fix int32 ( final output stream output , final int val ) throws io { output . write ( ( val > > > num ) & num ) ; output . write ( ( val > > > num ) & num ) ; output . write ( ( val > > > num ) & num ) ; output . write ( val & num ) ; }	write a fixed - width 32 bit integer in network byte order ( big - endian ) .
public static void queue cube load ( i world , io loader , cube provider server cache , int x , int y , int z , consumer < cube > runnable ) { queued cube key = new queued cube ( x , y , z , world ) ; io task = cube tasks . get ( key ) ; if ( task == null ) { task = new io ( key , loader ) ; task . add callback ( runnable ) ; cube tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add callback ( runnable ) ; } column loaded column ; if ( ( loaded column = cache . get loaded column ( x , z ) ) == null ) { cache . async get column ( x , z , i . requirement . light , null ) ; } else { task . set column ( loaded column ) ; } }	queue a cube load , running the specified callback when the load has finished.
public static boolean is object available now ( final boolean enabled , final date available from , final date available to , final date now ) { if ( ! enabled ) { return bool ; } if ( available from != null && now . before ( available from ) ) { return bool ; } if ( available to != null && now . after ( available to ) ) { return bool ; } return bool ; }	check availability of an object .
public void button clicked ( action event e ) ;	invoked when the button part is clicked .
private long load largest message id ( ) { release message release message = release message repository . find top by order by id desc ( ) ; return release message == null ? num : release message . get id ( ) ; }	find largest message id as the current start point.
public void remove change listener ( change listener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }	removes a changelistener from this loader .
public static request log dump ( ) { request log current = rlog . get ( ) ; request log copy = new request log ( current ) ; current . clear ( ) ; rlog . remove ( ) ; return copy ; }	exports a snapshot of the request log of the current thread and also resets the request log for that thread .
public static string url decode ( string str ) { try { return ( url . decode ( str , str ) ) ; } catch ( exception e ) { return ( str ) ; } }	description of the method.
public void test get tables ( ) throws exception { database meta data dmd = con . get meta data ( ) ; result set rs = dmd . get tables ( null , null , null , null ) ; assert not null ( rs ) ; rs . close ( ) ; }	test for bug [ 998765 ] exception with sybase and metadata . gettables ( ).
public void add all ( collection < ? extends t > collection ) { if ( m event delegate != null ) m event delegate . add data ( collection == null ? num : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != num ) { synchronized ( m lock ) { m objects . add all ( collection ) ; } } if ( m notify on change ) notify data set changed ( ) ; }	adds the specified collection at the end of the array .
public static void reset current file list ( string log name ) { current file list . remove ( prefix + log name ) ; }	reset the current file list for the logger .
void init compose state ( ) { m compose state = new compose state ( ) ; }	initialize a new composestate .
@ override public abstract list < j > create tool bars ( application a , @ nullable view p ) ;	creates toolbars for the application .
public static date parse date ( string date value ) throws date parse exception { return parse date ( date value , null , null ) ; }	parses a date value.
public regex file filter ( string pattern , io case sensitivity ) { if ( pattern == null ) { throw new illegal argument exception ( str ) ; } int flags = num ; if ( case sensitivity != null && ! case sensitivity . is case sensitive ( ) ) { flags = pattern . case insensitive ; } this . pattern = pattern . compile ( pattern , flags ) ; }	construct a new regular expression filter with the specified flags case sensitivity .
public static synchronized result set execute query ( string sql statement ) { logger . trace ( string . format ( str , sql statement ) ) ; result set r = null ; final statement s = get statement ( ) ; if ( s == null ) { logger . error ( str ) ; return null ; } try { r = s . execute query ( sql statement ) ; logger . trace ( str + ( null == r ) ) ; return r ; } catch ( throwable t ) { surface throwable ( string . format ( str , sql statement ) , t ) ; cleanup ( s , r ) ; } return null ; }	this method is a thin wrapper for jdbc executequery ( ).
public void write ( byte [ ] buf ) throws io { output . write ( buf ) ; bytes written += buf . length ; }	counts the written bytes .
public static string url encode ( @ nullable string s ) { if ( s == null ) { return str ; } try { return url . encode ( s , str ) ; } catch ( unsupported encoding exception e ) { throw new assertion error ( str ) ; } }	url - encodes a nullable string , catching the useless exception that never happens .
public currency read ( string symbol ) { return currency . get instance ( symbol ) ; }	this method is used to convert the string value given to an appropriate representation.
public static float parse float ( string s ) { if ( positive infinity . equals ( s ) ) { return float . positive infinity ; } else if ( negative infinity . equals ( s ) ) { return float . negative infinity ; } else if ( n . equals ( s ) ) { return float . n ; } else { s = trim plus sign ( s ) ; return float . parse float ( s ) ; } }	parses the supplied xsd : float string and returns its value .
public object new instance ( class java content interface ) throws jaxb { if ( java content interface == null ) { throw new jaxb ( messages . format ( messages . ci not null ) ) ; } try { class c = gi . get default implementation ( java content interface ) ; if ( c == null ) throw new jaxb ( messages . format ( messages . missing interface , java content interface ) ) ; return c . new instance ( ) ; } catch ( exception e ) { throw new jaxb ( e ) ; } }	create an instance of the specified java content interface .
public void request password for share via link ( boolean create share ) { share password dialog fragment dialog = share password dialog fragment . new instance ( m file , create share ) ; dialog . show ( get fragment manager ( ) , share password dialog fragment . password fragment ) ; }	starts a dialog that requests a password to the user to protect a share link .
private void force out of memory ( ) { array list junk = new array list ( ) ; for ( ; ; ) { junk . add ( new long [ num ] ) ; } }	allocate objects until death.
@ override public synchronized void put ( string key , entry entry ) { prune if needed ( entry . data . length ) ; file file = get file for key ( key ) ; try { buffered output stream fos = new buffered output stream ( new file output stream ( file ) ) ; cache header e = new cache header ( key , entry ) ; boolean success = e . write header ( fos ) ; if ( ! success ) { fos . close ( ) ; volley log . d ( str , file . get absolute path ( ) ) ; throw new io ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; put entry ( key , e ) ; return ; } catch ( io e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { volley log . d ( str , file . get absolute path ( ) ) ; } }	puts the entry with the specified key into the cache .
public static double enlargement scaled ( spatial comparable exist , spatial comparable addit , double scale ) { final int dim = assert same dimensionality ( exist , addit ) ; double v1 = num ; double v2 = num ; for ( int i = num ; i < dim ; i ++ ) { final double emin = exist . get min ( i ) ; final double emax = exist . get max ( i ) ; final double amin = addit . get min ( i ) ; final double amax = addit . get max ( i ) ; final double min = math . min ( emin , amin ) ; final double max = math . max ( emax , amax ) ; v1 *= ( max - min ) * scale ; v2 *= ( emax - emin ) * scale ; } return v2 - v1 ; }	compute the enlargement obtained by adding an object to an existing object .
public void intersection ( d r ) { if ( status == invalid ) return ; if ( status == empty ) { set clip ( r ) ; status = inuse ; return ; } clip [ num ] = math . max ( clip [ num ] , r . get min x ( ) ) ; clip [ num ] = math . max ( clip [ num ] , r . get min y ( ) ) ; clip [ num ] = math . min ( clip [ num ] , r . get max x ( ) ) ; clip [ num ] = math . min ( clip [ num ] , r . get max y ( ) ) ; }	intersect this clip with another region.
public boolean can get int ( ) { return can get ( int . class ) ; }	indicates if convenience get method can be called without an exception being thrown for the int type .
private node add condition waiter ( ) { node t = last waiter ; if ( t != null && t . wait status != node . condition ) { unlink cancelled waiters ( ) ; t = last waiter ; } node node = new node ( thread . current thread ( ) , node . condition ) ; if ( t == null ) first waiter = node ; else t . next waiter = node ; last waiter = node ; return node ; }	adds a new waiter to wait queue .
void clear ( ) ;	clears the ring buffer but moving the read position to the write position.
@ tcb static string strip banned codeunits ( string s ) { int safe limit = longest prefix of good codeunits ( s ) ; if ( safe limit < num ) { return s ; } string builder sb = new string builder ( s ) ; strip banned codeunits ( sb , safe limit ) ; return sb . to string ( ) ; }	returns the portion of its input that consists of xml safe chars .
public static void assert linewise equals ( string message , string expected , string actual ) { try ( scanner expected scanner = new scanner ( expected ) ; scanner actual scanner = new scanner ( actual ) ) { string expected line = null ; string actual line = null ; int line counter = num ; while ( expected scanner . has next line ( ) ) { expected line = expected scanner . next line ( ) ; if ( actual scanner . has next line ( ) ) { actual line = actual scanner . next line ( ) ; } else { fail ( str + line counter + str + expected line ) ; } assert equals ( str + line counter + str + message + str + expected + str + actual , expected line , actual line ) ; ++ line counter ; } } }	compares a string linewise , i.
private void warning ( string msg , throwable th ) { warning ( msg ) ; th . print stack trace ( ) ; }	used internally to log a message about the class at level warning , in case an exception was thrown.
public string full form ( final string str , final string low string ) { string ret = low string ; prefix entry found = prefix map . get ( str ) ; if ( found != null ) { ret = found . prefix singular + ret ; } else { for ( prefix entry entry : prefix end list ) { if ( str . ends with ( entry . keyword ) ) { ret = grammar . add prefix if not already there ( ret , entry . prefix singular , entry . prefix plural ) ; break ; } } } return ret ; }	prefix one of the registered nouns with an expression like " piece of " .
public void clear password expiration warned time ( ) { operations . add ( password policy state operation type . clear password expiration warned time ) ; }	clears the password expiration warned time .
private static locale strip ( locale locale ) { string language = locale . get language ( ) ; string country = locale . get country ( ) ; string variant = locale . get variant ( ) ; if ( ! variant . is empty ( ) ) { variant = str ; } else if ( ! country . is empty ( ) ) { country = str ; } else if ( ! language . is empty ( ) ) { language = str ; } else { return null ; } return new locale ( language , country , variant ) ; }	returns a locale with the most - specific field removed , or null if this locale had an empty language , country and variant .
private void append time zone ( string buffer buffer , int count , boolean general time zone ) { if ( general time zone ) { time zone tz = calendar . get time zone ( ) ; boolean daylight = ( calendar . get ( calendar . dst offset ) != num ) ; int style = count < num ? time zone . short : time zone . long ; if ( ! format data . custom zone strings ) { buffer . append ( tz . get display name ( daylight , style , format data . locale ) ) ; return ; } string custom = time zone names . get display name ( format data . zone strings , tz . get id ( ) , daylight , style ) ; if ( custom != null ) { buffer . append ( custom ) ; return ; } } append numeric time zone ( buffer , count , general time zone ) ; }	append a representation of the time zone of ' calendar ' to ' buffer ' .
public void remove listeners ( ) { if ( global listener != null ) { try { invoker helper . invoke method ( current object , str , global listener ) ; } catch ( exception e ) { } global listener = null ; } if ( local listener != null ) { try { invoker helper . invoke method ( current object , str , new object [ ] { property name , local listener } ) ; } catch ( exception e ) { } local listener = null ; } if ( synthetic full binding != null ) { synthetic full binding . unbind ( ) ; } }	remove listeners , believing that our bould flags are accurate and it removes only as declared .
public static string pad left ( string str , int total chars ) { if ( str == null ) str = str ; string builder sb = new string builder ( ) ; for ( int i = num ; i < total chars - str . length ( ) ; i ++ ) { sb . append ( str ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	pads the given string to the left with spaces to ensure that it ' s at least totalchars long .
public void show scores ( boolean flag ) { m show scores = flag ; swing utilities . invoke later ( null ) ; }	set whether to show scores on the plot lines.
public static void write ( file file , char sequence data , boolean append ) throws io { write ( file , data , charset . default charset ( ) , append ) ; }	writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .
protected double kernel helper ( int n , char [ ] s , int end index s , char [ ] t , int end index t ) { if ( n <= num ) { return get return value ( n ) ; } if ( math . min ( end index s + num , end index t + num ) < n ) { return get return value ( n ) ; } int adr = num ; if ( m use recursion cache ) { adr = m mult x * n + m mult y * end index s + m mult z * end index t ; if ( cachekh k [ adr % max cache ] == adr + num ) { return cachekh [ adr % max cache ] ; } } double result = num ; result = m lambda * kernel helper ( n , s , end index s - num , t , end index t ) + kernel helper2 ( n , s , end index s , t , end index t ) ; if ( m use recursion cache ) { cachekh k [ adr % max cache ] = adr + num ; cachekh [ adr % max cache ] = result ; } return result ; }	the kernel helper function , called k ' in [ 1 ] and [ 2 ] .
protected connection open h2 connection ( boolean autocommit ) throws sql { system . set property ( str , str ) ; string db name = str ; connection conn = driver manager . get connection ( str + db name + str ) ; conn . set auto commit ( autocommit ) ; return conn ; }	gets connection from a pool .
private void emit clear ( string field name , string builder builder ) { builder . append ( str ) ; builder . append ( get clear name ( field name ) ) ; builder . append ( str ) ; builder . append ( get ensure name ( field name ) ) ; builder . append ( str ) ; builder . append ( field name ) ; builder . append ( str ) ; builder . append ( str ) ; }	emits a method to clear a list or map.
protected void start recoarding ( ) { coordinates . clear ( ) ; enabled = bool ; }	start recording the gesture.
public void add input method listener ( input method listener l ) { m text pane . add input method listener ( l ) ; }	add input method listener.
public void add footer view ( view v , object data , boolean is selectable ) { fixed view info info = new fixed view info ( ) ; info . view = v ; info . data = data ; info . is selectable = is selectable ; m footer view infos . add ( info ) ; if ( m adapter != null && m observer != null ) { m observer . on changed ( ) ; } }	add a fixed view to appear at the bottom of the list.
public static void load ( string url ) { string driver = get driver ( url ) ; if ( driver != null ) { load user class ( driver ) ; } }	load the driver class for the given url , if the database url is known .
public void add document ( document d ) { if ( ! m read mode ) { try { writer . add document ( d ) ; m hit count cache . clear ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } else { throw new illegal state exception ( str + str ) ; } }	add a document to the lucene search index .
protected void put command ( final class command class , final string [ ] names ) { check . is true ( names . length > num , str ) ; commands to canonical names . put ( command class , names [ num ] ) ; for ( int i = num ; i < names . length ; i ++ ) { aliases to commands . put ( names [ i ] , command class ) ; } }	add a command in the hash map .
protected void write column auto increment stmt ( table table , column column , string builder ddl ) { ddl . append ( str ) ; }	prints that the column is an auto increment column .
private void gcm ( ) { try { shared preferences preferences = get shared preferences ( ) ; shared preferences . editor editor = preferences . edit ( ) ; editor . put string ( prefs pusher app id key , m pusher app id ) ; editor . put string ( prefs pusher url key , m pusher url ) ; editor . put string ( prefs pusher file tag key , m pusher base file tag ) ; editor . commit ( ) ; } catch ( exception e ) { log . e ( log tag , str + e . get localized message ( ) ) ; } }	save the gcm info to the preferences.
public void write block light ( byte buf output ) { output . write bytes ( block light . get handle ( ) ) ; }	write the block light to a buffer.
public string search ( ) throws exception { execute query ( ) ; return success ; }	execute a fulltextsearch from the request parameters.
public string next ( pattern pattern ) { check open ( ) ; check not null ( pattern ) ; match successful = bool ; save current status ( ) ; if ( ! set token region ( ) ) { recover previous status ( ) ; throw new no such element exception ( ) ; } matcher . use pattern ( pattern ) ; if ( ! matcher . matches ( ) ) { recover previous status ( ) ; throw new input mismatch exception ( ) ; } match successful = bool ; return matcher . group ( ) ; }	returns the next token if it matches the specified pattern.
public void add new duration ( long duration ) { calls number . increment and get ( ) ; total . add and get ( duration ) ; synchronized ( lock ) { if ( duration < minimum . long value ( ) ) { minimum . set ( duration ) ; } if ( duration > maximum . long value ( ) ) { maximum . set ( duration ) ; } } }	add a new operation duration to this class . total is updated and calls is incremented.
private void paint background solid ( d g , j c , int x , int y , int width , int height ) { color color = c . get background ( ) ; if ( type == common control state . disabled ) { color = new color ( color . get red ( ) , color . get green ( ) , color . get blue ( ) , num ) ; } shape s = shape generator . create round rectangle ( x - num , y - num , width + num , height + num , corner size . border ) ; g . set paint ( color ) ; g . fill ( s ) ; if ( is paint line seperators ( c ) ) { paint line separator ( g , c , width , height ) ; } }	paint the background of an uneditable control , e.
public static void add attribute default values ( string service name , string sub schema name , string schema type , string attribute name , set default values ) throws upgrade exception { string class method = str ; if ( debug . message enabled ( ) ) { debug . message ( class method + str ) ; debug . message ( str + service name + str + attribute name ) ; } service schema ss = get service schema ( service name , sub schema name , schema type ) ; try { map attribute defaults = ss . get attribute defaults ( ) ; set old attr values = ( set ) attribute defaults . get ( attribute name ) ; set new attr values = ( ( old attr values == null ) || old attr values . is empty ( ) ) ? new hash set ( ) : new hash set ( old attr values ) ; new attr values . add all ( default values ) ; ss . set attribute defaults ( attribute name , new attr values ) ; } catch ( sso ssoe ) { throw new upgrade exception ( str ) ; } catch ( sms sme ) { throw new upgrade exception ( str + str ) ; } }	adds default values to an existing attribute.
private string encode product ( ) { string buffer tokens = new string buffer ( ) ; list iterator it = product tokens . list iterator ( ) ; while ( it . has next ( ) ) { tokens . append ( ( string ) it . next ( ) ) ; } return tokens . to string ( ) ; }	return canonical form . pmusgrave - put a space between products ( preserves format of header ).
public boolean is metadata modified since last publication ( ) { return metadata modified since last publication ; }	called from manage resource page .
public options resource dirs ( list < file > value ) { resource dirs . clear ( ) ; resource dirs . add all ( value ) ; return this ; }	sets the list of directories where the resources come from.
private static class node make type ( class node cn , boolean using class ) { if ( using class ) { class node clazz type = class . get plain node reference ( ) ; clazz type . set generics types ( new generics type [ ] { new generics type ( cn ) } ) ; return clazz type ; } else { return cn ; } }	wrap type in class & lt ; & gt ; if usingclass = = true.
void push import url ( string href url ) { m import stack . push ( href url ) ; }	push an import href onto the stylesheet stack .
protected string to message ( map < string , string > results ) { string builder builder = new string builder ( ) ; if ( results != null ) { for ( map . entry < string , string > entry : results . entry set ( ) ) { builder . append ( entry . get key ( ) + str + entry . get value ( ) + str ) ; } } return builder . to string ( ) ; }	returns a formatted string of the results .
public test tree sort ( ) { collections . sort ( suites ) ; suites . for each ( null ) ; return this ; }	sorts the encapsulated test suites by their name in alphabetic order , then returns with the current ( sorted ) instance .
public static event bean [ ] add to array ( event bean [ ] array , collection < event bean > events to add ) { event bean [ ] new array = new event bean [ array . length + events to add . size ( ) ] ; system . arraycopy ( array , num , new array , num , array . length ) ; int counter = array . length ; for ( event bean event to add : events to add ) { new array [ counter ++ ] = event to add ; } return new array ; }	expand the array passed in by the multiple elements to add .
public synchronized void add ( string name , long thread id ) { if ( m finished ) { throw new illegal state exception ( str ) ; } m markers . add ( new marker ( name , thread id , system clock . elapsed realtime ( ) ) ) ; }	adds a marker to this log with the specified name .
public static string replace ( string a , string b , string c ) { string builder result = new string builder ( c . length ( ) ) ; int i = num ; int j = c . index of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to string ( ) ; }	replaces a with b in c .
private void reflect member variables in final button ( ) { final boolean last page reached = ( view pager . get current item ( ) + num ) == pages . size ( ) ; final boolean button should be invisible = ! last page reached || final button disabled ; final boolean button is currently invisible = final button . get visibility ( ) == view . invisible ; final boolean should update button = button should be invisible != button is currently invisible ; if ( should update button ) { final animator button animator = button should be invisible ? button animator factory . new final button disappear animator ( final button ) : button animator factory . new final button appear animator ( final button ) ; if ( button should be invisible ) { disable button ( button animator , final button ) ; } else { enable button ( button animator , final button ) ; } } }	enables or disables the final button , so that it matches the current member variables .
public void test decoder6 ( ) { boolean res ; string original app id name = m app id name ; int original content type value = m content type value ; random rd = new random ( ) ; for ( int i = num ; i < oma application id names . length ; i ++ ) { m app id name = oma application id names [ i ] ; m content type value = rd . next int ( num ) ; byte [ ] pdu = create pdu ( num ) ; wsp type decoder pdu decoder = new wsp type decoder ( pdu ) ; res = pdu decoder . seek x ( m wsp header start , m wsp header start + m wsp header len - num ) ; assert true ( res ) ; int index = ( int ) pdu decoder . get value32 ( ) ; res = pdu decoder . decode x ( index ) ; assert true ( res ) ; log . d ( log tag , str + m app id name + str + pdu decoder . get value string ( ) + str ) ; assert true ( m app id name . equals ( pdu decoder . get value string ( ) ) ) ; } m app id name = original app id name ; m content type value = original content type value ; }	wsptypedecoder test , decode string appid test.
public final void remove all ( ) { action list . clear ( ) ; constraints list . clear ( ) ; need sorting = bool ; }	removes all children actions ( separators as well ) from the group .
private static boolean is writable ( @ non null final file file ) { boolean is existing = file . exists ( ) ; try { file output stream output = new file output stream ( file , bool ) ; try { output . close ( ) ; } catch ( io e ) { } } catch ( java . io . file not found exception e ) { return bool ; } boolean result = file . can write ( ) ; if ( ! is existing ) { file . delete ( ) ; } return result ; }	check is a file is writable.
public gm publishing priority ( ) { }	creates a gm : publishing_priority tag .
private relying party validate relying party ( http servlet request request , string tenant name ) { validate . not null ( request , str ) ; validate . not empty ( tenant name , str ) ; default idm accessor factory idm factory = new default idm accessor factory ( ) ; validate . not null ( idm factory , str ) ; idm accessor idm accessor = idm factory . get idm accessor ( ) ; idm accessor . set tenant ( tenant name ) ; string encoded entity id = request . get parameter ( shared . relyingparty entityid ) ; if ( encoded entity id == null || encoded entity id . is empty ( ) ) { logger . error ( str ) ; return null ; } string rp entity id = new string ( base64 . decode ( encoded entity id ) ) ; relying party rp = idm accessor . get relying party by url ( rp entity id ) ; if ( rp != null ) { return rp ; } else { logger . error ( str + rp entity id ) ; return null ; } }	this method validates the relying party .
public void rotate z ( double theta ) { d tmp = new d ( ) ; double c = math . cos ( theta ) ; double s = math . sin ( theta ) ; tmp . set ( num , num , c ) ; tmp . set ( num , num , - s ) ; tmp . set ( num , num , s ) ; tmp . set ( num , num , c ) ; pre multiply ( tmp ) ; }	rotate transformation about the z axis.
public service host start factory ( service instance service ) { final class < ? extends service > service class = instance service . get class ( ) ; return start factory ( service class , null ) ; }	starts a default factory service for the given instance service.
void wake out ( ) { on available out flow = out flow ; if ( out flow == null ) { return ; } if ( credits in <= queue . head ( ) ) { return ; } state out pipe state old ; state out pipe state new ; do { state old = state out ref . get ( ) ; if ( ! state old . is full ( ) ) { return ; } state new = state old . to wake ( ) ; } while ( ! state out ref . compare and set ( state old , state new ) ) ; try ( outbox amp outbox = outbox amp . current or create ( out ref . services ( ) ) ) { objects . require non null ( outbox ) ; pipe wake out message < t > msg = new pipe wake out message < > ( outbox , out ref , this , out flow ) ; outbox . offer ( msg ) ; } }	notify the reader of available space in the pipe.
public static int columns number ( char c , int x , int prev x , int plain space size ) { if ( c != str ) { return num ; } int result = ( x - prev x ) / plain space size ; if ( ( x - prev x ) % plain space size > num ) { result ++ ; } return result ; }	allows to answer how many columns are necessary for representation of the given char on a screen .
private optional ( t value ) { this . value = objects . require non null ( value ) ; }	constructs an instance with the value present .
public kafka message listener container ( consumer factory < k , v > consumer factory , container properties container properties , topic partition initial offset ... topic partitions ) { super ( container properties ) ; assert . not null ( consumer factory , str ) ; this . consumer factory = consumer factory ; if ( topic partitions != null ) { this . topic partitions = arrays . copy of ( topic partitions , topic partitions . length ) ; } else { this . topic partitions = container properties . get topic partitions ( ) ; } }	construct an instance with the supplied configuration properties and specific topics / partitions / initialoffsets .
public void engine delete entry ( string alias ) throws key store exception { key k = ( key ) keys . remove ( alias ) ; certificate c = ( certificate ) certs . remove ( alias ) ; if ( c != null ) { chain certs . remove ( new cert id ( c . get public key ( ) ) ) ; } if ( k != null ) { string id = ( string ) local ids . remove ( alias ) ; if ( id != null ) { c = ( certificate ) key certs . remove ( id ) ; } if ( c != null ) { chain certs . remove ( new cert id ( c . get public key ( ) ) ) ; } } }	this is not quite complete - we should follow up on the chain , a bit tricky if a certificate appears in more than one chain.
private string to string ( matcher m , int group ) { return ( group == num ) ? str : m . group ( group ) ; }	captures the group passed in by matching against a pattern .
public pla line int translate by ( pla vector int p vector ) { if ( p vector . equals ( pla vector int . zero ) ) return this ; pla point int new a = point a . translate by ( p vector ) ; pla point int new b = point b . translate by ( p vector ) ; return new pla line int ( new a , new b ) ; }	translates the line by p_vector.
@ suppress warnings ( str ) final void reject ( runnable command ) { handler . rejected execution ( command , this ) ; }	invokes the rejected execution handler for the given command.
private int calculate menu margin ( ) { window manager wm = ( window manager ) get system service ( context . window service ) ; display display = wm . get default display ( ) ; point size = new point ( ) ; display . get size ( size ) ; int height = size . y ; return ( int ) math . round ( height * menu margin relative modifier ) ; }	method that calculates space left for edittext when format text panel is visible.
public void add ram ( attack action ea ) { pending rams . add element ( ea ) ; process game event ( new game new action event ( this , ea ) ) ; }	adds a pending ramming attack to the list for this phase .
public static list < integer > create colors ( resources r , int [ ] colors ) { list < integer > result = new array list < integer > ( ) ; for ( int i : colors ) { result . add ( r . get color ( i ) ) ; } return result ; }	turn an array of resource - colors ( contains resource - id integers ) into an array list of actual color integers.
public void test config file property ( ) throws exception { file config home = new file ( configuration . get home ( ) ) ; assert true ( str , config home . exists ( ) && config home . is directory ( ) ) ; file existing file = create file ( config home , str , str ) ; assert equals ( str , read file ( existing file ) ) ; string file name = str ; string file contents = str ; file file = create file ( config file directory , file name , file contents ) ; file config config file = new file config ( ) ; config file . set file ( get absolute path ( file ) ) ; config file . set to file ( str ) ; config file . set overwrite ( bool ) ; config file . set configfile ( bool ) ; configuration . set property ( str , str ) ; configuration . set config file property ( config file ) ; configuration . do configure ( null ) ; file copied file = new file ( configuration . get home ( ) + str ) ; assert true ( str , copied file . exists ( ) ) ; assert equals ( str , read file ( copied file ) ) ; }	test configuration file property .
protected byte [ ] generate salt ( ) { return header . get bytes ( constants . ut ) ; }	generate the random salt bytes if required .
public void add listener ( final projector listener projector listener ) { if ( listeners == null ) { listeners = new array list < projector listener > ( ) ; } listeners . add ( projector listener ) ; }	add a projector listener .
protected tuple expr select next tuple expr ( list < tuple expr > expressions , map < tuple expr , double > cardinality map , map < tuple expr , list < var > > vars map , map < var , integer > var freq map , set < string > bound vars ) { tuple expr result = null ; if ( expressions . size ( ) > num ) { double lowest cardinality = double . positive infinity ; for ( tuple expr tuple expr : expressions ) { double cardinality = get tuple expr cardinality ( tuple expr , cardinality map , vars map , var freq map , bound vars ) ; if ( cardinality < lowest cardinality || result == null ) { lowest cardinality = cardinality ; result = tuple expr ; } } } else { result = expressions . get ( num ) ; } return result ; }	selects from a list of tuple expressions the next tuple expression that should be evaluated.
public static void write bcd number ( output stream os , string number ) throws io { int bcd = num ; int n = num ; for ( int i = num ; i < number . length ( ) ; i ++ ) { switch ( number . char at ( i ) ) { case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; case str : bcd |= num ; break ; } n ++ ; if ( n == num ) { os . write ( bcd ) ; n = num ; bcd = num ; } else { bcd >>= num ; } } if ( n == num ) { bcd |= num ; os . write ( bcd ) ; } }	writes the given phonenumber to the stream ( bcd coded ).
public void add message ( string message ) { messages . add last ( message ) ; if ( messages . size ( ) > max history ) { messages . remove first ( ) ; } pointer = messages . size ( ) ; }	add a message to the history.
@ visible for testing protected void start executor ( final int container ) { log . info ( str + container ) ; final process container executor = start executor process ( container ) ; process to container . put ( container executor , container ) ; log . info ( str + container ) ; start executor monitor ( container , container executor ) ; }	start the executor for the given container.
public static date string to date ( string s , date format formatter ) { try { return formatter . parse ( s ) ; } catch ( parse exception e ) { return null ; } }	convert a date time string ( e.
public void accept ( abstract reporter r ) { r . test start ( this ) ; r . browser info entry ( browser info entry ) ; iterator < log entry > entry iterator = log entries . iterator ( ) ; while ( entry iterator . has next ( ) ) { log entry entry = entry iterator . next ( ) ; if ( ! entry iterator . has next ( ) ) { entry . set last ( bool ) ; } visit ( entry , r ) ; } r . test end ( this ) ; }	implementation of visitor pattern.
private void load latest extension versions ( ) { try { list < extension > all = registry manager . get extensions ( ) ; if ( ! all . is empty ( ) ) { set latest extension versions ( get latest versions ( all ) ) ; } } catch ( registry exception e ) { string msg = registry exception . log registry exception ( e . get type ( ) , this ) ; warnings . add startup error ( msg ) ; log . error ( msg ) ; msg = get text ( str , new string [ ] { cfg . get registry url ( ) } ) ; warnings . add startup error ( msg ) ; log . error ( msg ) ; } finally { if ( get latest extension versions ( ) == null ) { set latest extension versions ( new array list < extension > ( ) ) ; } } }	reload the list of registered extensions , loading only the latest extension versions .
protected void start node ( node node ) throws org . xml . sax . sax { if ( node instanceof locator ) { locator loc = ( locator ) node ; f locator . set column number ( loc . get column number ( ) ) ; f locator . set line number ( loc . get line number ( ) ) ; f locator . set public id ( loc . get public id ( ) ) ; f locator . set system id ( loc . get system id ( ) ) ; } else { f locator . set column number ( num ) ; f locator . set line number ( num ) ; } switch ( node . get node type ( ) ) { case node . document type node : serialize doc type ( ( document type ) node , bool ) ; break ; case node . comment node : serialize comment ( ( comment ) node ) ; break ; case node . document fragment node : break ; case node . document node : break ; case node . element node : serialize element ( ( element ) node , bool ) ; break ; case node . processing instruction node : serialize pi ( ( processing instruction ) node ) ; break ; case node . cdata section node : serialize cdata ( ( cdata ) node ) ; break ; case node . text node : serialize text ( ( text ) node ) ; break ; case node . entity reference node : serialize entity reference ( ( entity reference ) node , bool ) ; break ; default : } }	start processing given node.
public void test clear bit negative inside2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; int number = num ; byte r bytes [ ] = { - num , num , - num , - num , num , num , - num , - num , - num , - num , num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . clear bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	clearbit ( int n ) inside a negative number.
public void test compare greater scale2 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; int result = - num ; assert equals ( str , result , a number . compare to ( b number ) ) ; }	compare to a number of an greater scale.
public int read ( ) throws io { int val ; if ( ( val = is . read ( ) ) < num ) { return - num ; } if ( bo == str ) { val = ( char ) ( ( val << num ) | ( is . read ( ) & num ) ) ; } else { val = ( char ) ( ( is . read ( ) << num ) | ( val & num ) ) ; } return val ; }	reads a single character .
public void cancel auto completion ( ) { if ( in completion ) { text field . set text ( text before ) ; text field . set caret position ( caret pos before ) ; prev completion = null ; prev completion index = num ; in completion = bool ; } }	cancels the current completion , which means the state of the text is returned to what it was before completion and the info popup is closed if necessary .
public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add ( new option ( str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public client properties builder with proxy host name ( string proxy host name ) { properties . set property ( client service proxy host name , proxy host name ) ; return this ; }	if a proxy is used to access the odata web service this specifies it ' s host name / ip address .
public static void verify setter methods ( class < ? > clazz , mapped field ... fields ) { string method name = null ; string field name = null ; class < ? > field type = null ; try { for ( mapped field field : fields ) { field name = field . get name ( ) ; field type = field . get type ( ) ; string custom set = field . set method ( ) ; if ( ! is null ( custom set ) && ! custom set . equals ( constants . default accessor value ) ) try { clazz . get method ( custom set , field type ) ; field . set method ( custom set ) ; continue ; } catch ( exception e ) { error . custom method ( str , custom set , clazz ) ; } method name = m set ( field name ) ; clazz . get method ( method name , field type ) ; field . set method ( method name ) ; } } catch ( exception e ) { error . method ( method name , field name , clazz ) ; } }	verifies that the setter methods are compliant with the naming convention .
private e dequeue ( ) { final object [ ] items = this . items ; @ suppress warnings ( str ) e x = ( e ) items [ take index ] ; items [ take index ] = null ; take index = inc ( take index ) ; count -- ; if ( itrs != null ) itrs . element dequeued ( ) ; not full . signal ( ) ; return x ; }	extracts element at current take position , advances , and signals.
static public string random positive float ( int whole , int decimal ) { string builder output = new string builder ( ) ; output . append ( rnd . next int ( num ) + num ) ; for ( int i = num ; i < whole - num ; i ++ ) { output . append ( rnd . next int ( num ) ) ; } output . append ( str ) ; for ( int i = num ; i < decimal ; i ++ ) { output . append ( rnd . next int ( num ) ) ; } return output . to string ( ) ; }	get a random , positive float.
public void reset text box indexes except ( set < integer > excluded list ) { set < integer > unused text box indexes = new hash set < integer > ( points . get text box indexes ( ) ) ; unused text box indexes . remove all ( excluded list ) ; for ( integer index : unused text box indexes ) { points . remove text box ( index ) ; } }	resets all textbox indexes except those which are contained in the excludedlist.
public i learn entity ( long mac address , short vlan , integer ipv4 address , long switch dpid , integer switch port , boolean process updates ) { list < i > listeners = device listeners . get ordered listeners ( ) ; if ( ! process updates ) { device listeners . clear listeners ( ) ; } if ( vlan != null && vlan . short value ( ) <= num ) vlan = null ; if ( ipv4 address != null && ipv4 address == num ) ipv4 address = null ; i res = learn device by entity ( new entity ( mac address , vlan , ipv4 address , switch dpid , switch port , new date ( ) ) ) ; if ( listeners != null ) { for ( i listener : listeners ) { device listeners . add listener ( str , listener ) ; } } return res ; }	learn a device using the given characteristics .
public double [ ] level zero data ( ) { list < buffer > level zero buffers = buffer map . get ( num ) ; int length = num ; for ( buffer buffer : level zero buffers ) { if ( ! buffer . has capacity ( ) ) { length += buffer . size ; } else { length += buffer . next ; } } int pos = num ; int curr len ; final double [ ] out = new double [ length ] ; for ( buffer buffer : level zero buffers ) { if ( ! buffer . has capacity ( ) ) { curr len = buffer . size ; } else { curr len = buffer . next ; } system . arraycopy ( buffer . data , num , out , pos , curr len ) ; pos += curr len ; } return out ; }	returns a fresh copy of all data from level 0 buffers .
public string [ ] show version ( ) throws network device controller exception { string [ ] return val = new string [ num ] ; ssh [ ] prompts = { ssh . mds pound , ssh . mds greater than } ; string builder buf = new string builder ( ) ; ssh prompt = send wait for ( mds . get string ( str ) , num , prompts , buf ) ; string [ ] lines = get lines ( buf ) ; string [ ] regex = { mds . get string ( str ) , mds . get string ( str ) , mds . get string ( str ) } ; string [ ] groups = new string [ num ] ; for ( string line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case num : return val [ num ] = groups [ num ] ; break ; case num : return val [ num ] = groups [ num ] ; break ; case num : return val [ num ] = groups [ num ] ; break ; } } return return val ; }	returns the device type and software version.
public static int count matches ( string string , char c ) { int n = num ; for ( char tc : string . to char array ( ) ) { if ( c == tc ) n ++ ; } return n ; }	counts the amount of times a certain character is part of a string.
private image icon add color ( image icon icon , color color ) { if ( icon == null || color == null ) { return icon ; } buffered image new image = new buffered image ( icon . get icon width ( ) , icon . get icon width ( ) , buffered image . type int argb ) ; graphics g = new image . get graphics ( ) ; g . set color ( color ) ; g . draw image ( icon . get image ( ) , num , num , color , null ) ; g . dispose ( ) ; return new image icon ( new image ) ; }	adds a background color to the given icon , if an icon and color is actually given , otherwise the original icon is returned .
public static byte [ ] read all limited ( input stream in str , int limit ) throws io { byte array output stream buf = new byte array output stream ( ) ; pipe all limited ( in str , limit , buf ) ; return buf . to byte array ( ) ; }	read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .
protected string search for ( final string target , string start ) { return search for ( target , null , start ) ; }	searches for the given target directory starting in the " plugins " subdirectory of the given location.
private int validate preload order ( cache configuration [ ] cfgs ) throws ignite checked exception { int max order = num ; for ( cache configuration cfg : cfgs ) { int rebalance order = cfg . get rebalance order ( ) ; if ( rebalance order > num ) { if ( cfg . get cache mode ( ) == local ) throw new ignite checked exception ( str + str + u . mask name ( cfg . get name ( ) ) ) ; if ( cfg . get rebalance mode ( ) == cache rebalance mode . none ) throw new ignite checked exception ( str + str + u . mask name ( cfg . get name ( ) ) + str + cfg . get rebalance mode ( ) + str + cfg . get rebalance order ( ) + str ) ; max order = math . max ( max order , rebalance order ) ; } else if ( rebalance order < num ) throw new ignite checked exception ( str + str + u . mask name ( cfg . get name ( ) ) + str + rebalance order + str ) ; } return max order ; }	checks that preload - order - dependant caches has sync or async preloading mode .
public void execute ( ) { m player . set loop mode ( m do loop ) ; m thread = new thread ( this , str ) ; m thread . start ( ) ; }	creates a new thread , and starts execution of the player .
@ override public void remove env var ( env var env var ) { if ( env var != null ) { env var list . remove ( env var ) ; } }	removes the environment variable .
static private string calc threshold ( double score threshold , double lambda ) { final double log prob threshold = math . log ( num - score threshold / num ) ; int max num = num ; if ( calc log prob ( max num , lambda ) > log prob threshold ) { return str ; } int min num = num ; while ( min num < max num ) { final int mid num = ( max num + min num ) / num ; final boolean pass threshold = calc log prob ( mid num , lambda ) <= log prob threshold ; if ( pass threshold ) { max num = mid num ; } else { if ( mid num == min num ) { break ; } min num = mid num ; } } return integer . to string ( max num ) ; }	calculates the minimal number of instances required to achieve a score as high as the given scorethreshold for the given lambda .
private scope peek ( ) throws json { if ( stack . is empty ( ) ) { throw new json ( str ) ; } return stack . get ( stack . size ( ) - num ) ; }	returns the value on the top of the stack .
public void test is signed ( ) { try { assert false ( rsmd . is signed ( num ) ) ; } catch ( sql e1 ) { fail ( str + e1 . get message ( ) ) ; e1 . print stack trace ( ) ; } try { rsmd . is signed ( num ) ; fail ( str ) ; } catch ( sql e ) { } }	tests fail : always returns false.
public static int index of last separator ( string filename ) { if ( filename == null ) return - num ; int last unix pos = filename . last index of ( unix separator ) ; int last windows pos = filename . last index of ( windows separator ) ; return math . max ( last unix pos , last windows pos ) ; }	returns the index of the last directory separator character.
public static boolean point in view ( view v , float local x , float local y , float slop ) { return local x >= - slop && local y >= - slop && local x < ( v . get width ( ) + slop ) && local y < ( v . get height ( ) + slop ) ; }	utility method to determine whether the given point , in local coordinates , is inside the view , where the area of the view is expanded by the slop factor.
private static type [ ] unroll bounds ( final map < type variable < ? > , type > type arguments , final type [ ] bounds ) { type [ ] result = bounds ; int i = num ; for ( ; i < result . length ; i ++ ) { final type unrolled = unroll variables ( type arguments , result [ i ] ) ; if ( unrolled == null ) { result = array utils . remove ( result , i -- ) ; } else { result [ i ] = unrolled ; } } return result ; }	local helper method to unroll variables in a type bounds array .
public void delete quota ( string id ) throws isilon exception { delete ( base url . resolve ( uri quotas ) , id , str ) ; }	delete a smart quota.
public static map < string , string > create basic auth header ( string username , string password , map < string , string > header map ) { if ( header map == null ) header map = new hash map < > ( ) ; string credentials = username + str + password ; string base64 encoded credentials = base64 . encode to string ( credentials . get bytes ( ) , base64 . no wrap ) ; header map . put ( str , str + base64 encoded credentials ) ; return header map ; }	method to create a basic http base64 encrypted authentication header.
private void add extent entry ( ) { extent model . add new entry ( ) ; remove extent button . set enabled ( bool ) ; }	adds a new extent entry .
private transport network check cached ( string network id ) { try { string filename = network id + str + r5 version . version + str ; file cache location = new file ( cache dir , network id + str + r5 version . version + str ) ; if ( cache location . exists ( ) ) log . info ( str , cache location ) ; else { log . info ( str , cache location ) ; if ( source bucket != null ) { log . info ( str ) ; s3 object tn ; try { tn = s3 . get object ( source bucket , filename ) ; } catch ( amazon service exception ex ) { log . info ( str ) ; return null ; } cache dir . mkdirs ( ) ; log . info ( str , cache location ) ; file output stream fos = new file output stream ( cache location ) ; input stream is = tn . get object content ( ) ; try { byte streams . copy ( is , fos ) ; } finally { is . close ( ) ; fos . close ( ) ; } } else { log . info ( str ) ; return null ; } } log . info ( str , cache location ) ; file input stream fis = new file input stream ( cache location ) ; try { return transport network . read ( fis ) ; } finally { fis . close ( ) ; } } catch ( exception e ) { log . error ( str , e ) ; return null ; } }	if this transport network is already built and cached , fetch it quick.
void read file ( file file ) throws org . jdom2 . jdom , java . io . io { xml file xf = new xml file ( ) { } ; xf . root from file ( file ) ; }	ask sax to read and verify a file.
public boolean is all granted ( ) { int count = num ; for ( int i = num ; i < m perms . size ( ) ; i ++ ) { if ( m perms . get ( m user permission . get ( i ) ) == package manager . permission granted ) count ++ ; } return count == m perms . size ( ) ; }	is all granted boolean .
protected void execute ( runnable evt ) { executor . execute ( evt ) ; }	fires a event on the executor thread.
private void send next message over network ( ) throws exception { raw data raw = outgoing . take ( ) ; if ( raw == null ) throw new null pointer exception ( ) ; send next ( raw ) ; }	get the next message from the outgoing queue and send it over the network .
public void add attribute for ( final field field ) { field to use as attribute . add ( field ) ; }	tells this mapper to use an attribute for this field .
public boolean is session token ( string token ) { synchronized ( session tokens ) { return session tokens . contains ( token ) ; } }	checks if is session token .
public static double root means squared error ( double [ ] real , double [ ] predicted ) { double ret = num ; for ( int i = num ; i < real . length ; i ++ ) { ret += math . pow ( ( real [ i ] - predicted [ i ] ) , num ) ; } return math . sqrt ( ret / real . length ) ; }	this returns the root mean squared error of two data sets.
public void export ( byte buffer buf ) { buf . put int ( seq id ) ; if ( info . is row block enabled ( ) ) buf . put int ( n rows ) ; export ( primary key , buf ) ; for ( byte array cb : cell blocks ) { export ( cb , buf ) ; } }	write data to given buffer , like serialize.
private hash map < string , object > create acc detailmap ( string glcode , big decimal debit amount , big decimal credit amount ) { hash map < string , object > accountdetailmap = new hash map < string , object > ( ) ; accountdetailmap . put ( voucher constant . glcode , glcode ) ; accountdetailmap . put ( voucher constant . debitamount , debit amount ) ; accountdetailmap . put ( voucher constant . creditamount , credit amount ) ; accountdetailmap . put ( voucher constant . functioncode , get functionary code ( ) ) ; return accountdetailmap ; }	creates account details map.
private void rotate right ( node < k , v > root ) { node < k , v > pivot = root . left ; node < k , v > right = root . right ; node < k , v > pivot left = pivot . left ; node < k , v > pivot right = pivot . right ; root . left = pivot right ; if ( pivot right != null ) { pivot right . parent = root ; } replace in parent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = math . max ( right != null ? right . height : num , pivot right != null ? pivot right . height : num ) + num ; pivot . height = math . max ( root . height , pivot left != null ? pivot left . height : num ) + num ; }	rotates the subtree so that its root ' s left child is the new root .
private void update radio links ( ) { m advance data set first . set enabled ( m . get editor active ( ) ) ; m advance iterator first . set enabled ( m . get editor active ( ) ) ; if ( m != null ) { if ( ! m . get editor active ( ) ) { m . set advance data set first ( bool ) ; } else { m . set advance data set first ( m advance data set first . is selected ( ) ) ; } } }	updates the primary loop iteration control of the experiment.
public void update ( long value ) { count . increment and get ( ) ; sample . update ( value ) ; set max ( value ) ; set min ( value ) ; sum . get and add ( value ) ; update variance ( value ) ; }	adds a recorded value .
@ override public void draw series ( canvas canvas , paint paint , list < float > points , xy renderer , float y axis value , int series index , int start index ) { paint . set color ( renderer . get color ( ) ) ; paint . set style ( style . fill ) ; int length = points . size ( ) ; xy series = ( xy ) m dataset . get series at ( series index ) ; double max = series . get max value ( ) ; double coef = max bubble size / max ; for ( int i = num ; i < length ; i += num ) { double size = series . get value ( start index + i / num ) * coef + min bubble size ; draw circle ( canvas , paint , points . get ( i ) , points . get ( i + num ) , ( float ) size ) ; } }	the graphical representation of a series .
public static void check class signature ( final string signature ) { int pos = num ; if ( get char ( signature , num ) == str ) { pos = check formal type parameters ( signature , pos ) ; } pos = check class type signature ( signature , pos ) ; while ( get char ( signature , pos ) == str ) { pos = check class type signature ( signature , pos ) ; } if ( pos != signature . length ( ) ) { throw new illegal argument exception ( signature + str + pos ) ; } }	checks a class signature .
public static byte [ ] select ( string app id , string suffix ) { string cardlet aid = fidesmo aid prefix + app id + suffix ; return select ( cardlet aid ) ; }	builds the select command apdu from a cardlet ' s app id : - builds the cardlet ' s aid appending the fidesmo prefix and a suffix - builds the command concatenating the header , aid lenght and aid.
void internal add root entry ( project comparison entry entry ) { entries . add ( entry ) ; }	should only be invoked from projectcomparisonentry.
public static source from url ( url url , charset cs ) throws io { uri uri ; try { uri = url . to uri ( ) ; } catch ( uri e ) { throw new io ( str , e ) ; } try ( input stream is = url . open stream ( ) ) { return from stream ( is , uri , cs ) ; } }	creates a new source object from a url.
public void test merge one servlet into document with another servlet ( ) throws exception { string src xml = str + str + str + str + str + str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; string merge xml = str + str + str + str + str + str ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( merge xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge ( merge web xml ) ; assert true ( web xml utils . has servlet ( src web xml , str ) ) ; assert true ( web xml utils . has servlet ( src web xml , str ) ) ; }	tests whether a single servlet is correctly merged into a descriptor that already contains the definition of an other servlet .
public re extract re ( ) throws interrupted exception { arden ( ) ; if ( ! coeffs . is empty ( ) ) { throw new runtime exception ( str ) ; } return union r ( terms ) ; }	extract the regular expression associated with this recursive production.
@ deprecated public static void run finalizers on exit ( boolean run ) { finalize on exit = run ; }	sets the flag that indicates whether all objects are finalized when the vm is about to exit.
public void add result ( am id , map attrs ) { search results . add ( id ) ; results map . put ( id , attrs ) ; }	adds an amidentity object to this search result .
public < t extends intention action & local quick fix > void register batch fix ( @ not null t fix , @ nullable text range range , @ nullable final highlight display key key ) { if ( range == null ) { range = new text range ( my start offset , my end offset ) ; } if ( my batch fixes == null ) { my batch fixes = new array list < quick fix info > ( ) ; } my batch fixes . add ( new quick fix info ( fix , range , key ) ) ; }	registers a quickfix which would be available during batch mode only , in particular during com.
protected void create file ( zip entry entry ) { i pathname = new path ( entry . get name ( ) ) ; zip entry parent ; if ( pathname . segment count ( ) == num ) { parent = root ; } else { parent = ( zip entry ) directory entry cache . get ( pathname . remove last segments ( num ) ) ; } add to children ( parent , entry ) ; }	creates a new file zip entry with the specified name .
public void test has attributes1 ( ) throws throwable { document doc ; node list addr list ; node addr node ; boolean state ; doc = ( document ) load ( str , builder ) ; addr list = doc . get elements by tag name ( str ) ; addr node = addr list . item ( num ) ; state = addr node . has attributes ( ) ; assert false ( str , state ) ; }	runs the test case .
public void start document ( xml locator , string encoding , namespace context namespace context , augmentations augs ) throws xni { f namespace context = namespace context ; try { if ( f document handler != null ) { if ( locator != null ) { f document handler . set document locator ( new locator proxy ( locator ) ) ; } f document handler . start document ( ) ; } if ( f content handler != null ) { if ( locator != null ) { f content handler . set document locator ( new locator proxy ( locator ) ) ; } f content handler . start document ( ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	the start of the document .
@ override public string dump window hierarchy ( boolean compressed ) { device . set compressed layout heirarchy ( compressed ) ; try { byte array output stream os = new byte array output stream ( ) ; device . dump window hierarchy ( os ) ; os . close ( ) ; return os . to string ( str ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } finally { device . set compressed layout heirarchy ( bool ) ; } return null ; }	helper method used for debugging to dump the current window ' s layout hierarchy .
public void register observer ( rule changes observer observer ) { observers . add ( observer ) ; }	registers an observer to be notified on routing rules changes .
private void send update heartbeats ( ) { heartbeat service local heartbeat = bartender . get heartbeat local ( ) ; if ( heartbeat != null ) { heartbeat . update heartbeats ( ) ; } }	send a heartbeat with the updated pods to other servers in the cluster.
public void serialize ( string name , byte [ ] message , output stream out ) throws io { byte [ ] header = new byte [ num + command len + num + num ] ; uint32 to byte array be ( params . get packet magic ( ) , header , num ) ; for ( int i = num ; i < name . length ( ) && i < command len ; i ++ ) { header [ num + i ] = ( byte ) ( name . code point at ( i ) & num ) ; } utils . uint32 to byte array le ( message . length , header , num + command len ) ; byte [ ] hash = double digest ( message ) ; system . arraycopy ( hash , num , header , num + command len + num , num ) ; out . write ( header ) ; out . write ( message ) ; if ( log . is debug enabled ( ) ) log . debug ( str , name , bytes to hex string ( header ) + bytes to hex string ( message ) ) ; }	writes message to to the output stream .
public ssl init ssl engine ( boolean client ) throws exception { key store key store = load keystore ( properties . ssl key store path ( ) , properties . ssl key store password ( ) ) ; key manager factory key manager factory = key manager factory . get instance ( key manager factory . get default algorithm ( ) ) ; key manager factory . init ( key store , key store key pass ( properties ) ) ; key store trust store ; if ( properties . ssl trust store path ( ) != null ) { logger . debug ( str ) ; trust store = load keystore ( properties . ssl trust store path ( ) , properties . ssl trust store password ( ) ) ; } else { trust store = key store ; logger . debug ( str ) ; } trust manager factory trust manager factory = trust manager factory . get instance ( trust manager factory . get default algorithm ( ) ) ; trust manager factory . init ( trust store ) ; key manager [ ] key managers = key manager factory . get key managers ( ) ; trust manager [ ] trust managers = trust manager factory . get trust managers ( ) ; ssl ssl context = ssl . get instance ( str ) ; ssl context . init ( key managers , trust managers , null ) ; ssl ssl engine = ssl context . create ssl ( ) ; ssl engine . set use client mode ( client ) ; ssl engine . set want client auth ( bool ) ; ssl engine . set enabled protocols ( ssl engine . get supported protocols ( ) ) ; ssl engine . set enabled cipher suites ( ssl engine . get supported cipher suites ( ) ) ; ssl engine . set enable session creation ( bool ) ; return ssl engine ; }	initializes an ssl engine .
public get buffered random access source ( i source ) { this . source = source ; this . get buffer = new byte [ ( int ) math . min ( math . max ( source . length ( ) / num , num ) , num ) ] ; this . get buffer start = - num ; this . get buffer end = - num ; }	constructs a new offsetrandomaccesssource.
public arg parser ( string p name ) { program name = p name ; args = new vector ( ) ; args . add ( new help arg ( ) ) ; }	create a parser for the named program.
public void test set bit zero ( ) { byte a bytes [ ] = { num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	setbit ( int n ) outside zero.
public static void save x ( file save to , object model , instances header ) throws exception { vector < object > v = new vector < object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trim to size ( ) ; x . write ( save to . get absolute path ( ) , v ) ; }	save a model in xstream deep object serialized xml form .
private void sort and collapse ( ) { collections . sort ( m spans ) ; m adds since sort = num ; iterator iter = m spans . iterator ( ) ; span span = null ; if ( iter . has next ( ) ) { span = ( span ) iter . next ( ) ; } while ( iter . has next ( ) ) { span next span = ( span ) iter . next ( ) ; if ( span . subsume ( next span ) ) { iter . remove ( ) ; } else { span = next span ; } } }	sort the spans in ascending order by their start position.
public int split randomly ( dbi ind , int begin , int end , double data store tpro , random rand ) { final int nele = end - begin ; dbid it = ind . iter ( ) ; double rs = tpro . double value ( it . seek ( begin + rand . next int ( nele ) ) ) ; int min ind = begin , max ind = end - num ; while ( min ind < max ind ) { double curr ele = tpro . double value ( it . seek ( min ind ) ) ; if ( curr ele > rs ) { while ( min ind < max ind && tpro . double value ( it . seek ( max ind ) ) > rs ) { max ind -- ; } if ( min ind == max ind ) { break ; } ind . swap ( min ind , max ind ) ; max ind -- ; } min ind ++ ; } if ( min ind == end - num ) { min ind = ( begin + end ) > > > num ; } return min ind ; }	split the data set randomly .
public static string no prefix ( string path , string prefix ) { objects . require non null ( path , str ) ; objects . require non null ( prefix , str ) ; return path . starts with ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }	drops a prefix from a path if it exists or returns original path if prefix does not match .
protected void publish ( ) throws mqtt exception , io { sample client pub = new sample async callback ( url , client id pub , clean session , quiet mode , user name , password ) ; if ( sample client pub != null ) { string topic = str ; int qos = num ; string message = str ; try { sample client pub . publish ( topic , qos , message . get bytes ( ) ) ; } catch ( throwable e ) { e . print stack trace ( ) ; } } }	publish / send a message to an mqtt server.
public void remove ( i a ) { children . remove ( a ) ; }	adds the given adaptable object to this list .
public static int stream concat ( int stream a , int stream b ) { objects . require non null ( a ) ; objects . require non null ( b ) ; spliterator . of int split = new streams . concat spliterator . of int ( a . spliterator ( ) , b . spliterator ( ) ) ; int stream stream = stream support . int stream ( split , a . is parallel ( ) || b . is parallel ( ) ) ; return stream . on close ( streams . composed close ( a , b ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
public boolean equals ( string expected , string actual ) { return framework . equals ( expected , actual ) ; }	compares the values of actual and expected .
public login configuration force auth ( string force auth req param ) { force auth = boolean . parse boolean ( force auth req param ) ; return this ; }	sets the request ' s forceauth parameter .
public user config fetch ( user config config ) { config . add credentials ( this ) ; string xml = post ( this . url + str , config . to xml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { user config user = new user config ( ) ; user . parse xml ( root ) ; return user ; } catch ( exception exception ) { this . exception = sdk . parse failure ( exception ) ; throw this . exception ; } }	fetch the user details for the user credentials.
@ method desc ( description = str , usage = str ) public void stop ( ) throws exception { try { handle event synchronous ( new stop event ( ) ) ; if ( done latch != null ) { done latch . count down ( ) ; } } catch ( exception e ) { logger . error ( str , e ) ; throw new exception ( e . to string ( ) ) ; } }	stop replicator node manager jmx service .
@ override public void push message async ( message msg ) throws org . apache . thrift . t { push message sync ( msg ) ; return ; }	the implementation for pushmessageasync ( ) function .
public boolean write characteristic ( string address , string service uuid , string characteristic uuid , byte [ ] value ) { bluetooth gatt bluetooth gatt = m bluetooth gatt map . get ( address ) ; if ( bluetooth gatt != null ) { bluetooth gatt service service = bluetooth gatt . get service ( uuid . from string ( service uuid ) ) ; bluetooth gatt characteristic characteristic = service . get characteristic ( uuid . from string ( characteristic uuid ) ) ; characteristic . set value ( value ) ; return bluetooth gatt . write characteristic ( characteristic ) ; } return bool ; }	write data to characteristic , and send to remote bluetooth le device .
public string link for message ( proto element element ) { if ( is external file ( element . get file ( ) ) ) { string full name = element . get full name ( ) ; return string . format ( str , full name , full name ) ; } else { string simple name = element . get simple name ( ) ; return string . format ( str , simple name , simple name ) ; } }	returns the jsdoc format of link to the element .
public static < t > array list < t > read ( input stream file stream , string charset name , i < string , t > transformer ) throws file not found exception { scanner scanner = new scanner ( file stream , charset name ) ; array list < t > list = new array list < > ( ) ; while ( scanner . has next line ( ) ) { string line = scanner . next line ( ) ; list . add ( transformer . transform ( line ) ) ; } scanner . close ( ) ; return list ; }	this function reads an inputstream line - by - line and converts each line into an object using a transformer that is passed as a parameter .
public boolean remove ( json element element ) { return elements . remove ( element ) ; }	removes the first occurrence of the specified element from this array , if it is present.
public t < byte [ ] > send bytes ( t < byte [ ] > stream ) { objects . require non null ( stream , str ) ; return send binary ( stream , null ) ; }	send a stream ' s byte [ ] tuples in a websocket binary message .
private void sort broker items ( broker item [ ] broker items , int sort type ) { arrays . sort ( broker items , broker item . get comparatory by type ( sort type ) ) ; }	perform sorting according to sort type.
protected boolean need to escape xml ( string host entity id , string remote entity id , string realm ) { return bool ; }	decides whether it needs to escape xml special characters for attribute values or not .
private void update path constraints ( test chromosome test ) { list < branch condition > path condition = concolic execution . get symbolic path ( test ) ; path conditions . put ( test , path condition ) ; }	calculate and store path constraints for an individual.
public void test journal one index no data ( ) throws io , interrupted exception , execution exception { final file out = file . create temp file ( get name ( ) , options . jnl ) ; try { final journal src = get store ( get properties ( ) ) ; try { final string name = str ; src . register index ( new index metadata ( name , uuid . random uuid ( ) ) ) ; src . commit ( ) ; final future < journal > f = src . compact ( out ) ; final journal new journal = f . get ( ) ; try { assert not null ( new journal . get index ( name ) ) ; b . assert same b ( src . get index ( name ) , new journal . get index ( name ) ) ; } finally { new journal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	test of a journal on which a single index has been register ( and the journal committed ) but no data was written onto the index .
public static boolean p2p loader ( class loader ldr ) { return ldr instanceof grid deployment info ; }	checks if class loader is an internal p2p class loader .
private static string remove sub trailers ( string decoded subject ) { int sub string start = num ; int sub string end = decoded subject . length ( ) ; int original size = decoded subject . length ( ) ; int cur pos = original size - num ; while ( bool ) { char c = decoded subject . char at ( cur pos -- ) ; if ( c == ws ) { sub string end -- ; } else { if ( sub string end > fwd parens . length ( ) && decoded subject . ends with ( fwd parens ) ) { sub string end -= fwd parens . length ( ) ; } break ; } } decoded subject = decoded subject . substring ( sub string start , sub string end ) ; return decoded subject ; }	remove the remove_subj_trailers subj - trailer = " ( fwd ) " / wsp.
boolean next source ( ) throws io { if ( m source it . has next ( ) ) { final input stream is = m source it . next ( ) ; if ( is == null ) { m source = null ; return bool ; } else { m source = new buffered input stream ( is , file utils . buffered stream size ) ; } m source closed = bool ; m input buffer position = num ; m input buffer length = num ; m buffer length = num ; m buffer position = num ; return bool ; } if ( m source != null ) { m source . close ( ) ; } m source = null ; return bool ; }	step to the next input stream .
public static byte [ ] bitmap to bytes ( bitmap bm ) { byte [ ] bytes = null ; if ( bm != null ) { byte array output stream baos = new byte array output stream ( ) ; bm . compress ( bitmap . compress format . png , num , baos ) ; bytes = baos . to byte array ( ) ; } return bytes ; }	bitmap transfer to bytes.
public static string inflate ( string name ) { return inflate ( name , g prefix ) ; }	inflate a short name into a full gdata uri using gprefix ( ending in " # " ).
public void add priority handler ( warning handler handler ) { priority handlers . add ( handler ) ; }	add a warning event handler.
public void print len string ( string v ) throws io { if ( v == null ) { os . write ( num ) ; os . write ( num ) ; } else { int len = v . length ( ) ; os . write ( len > > num ) ; os . write ( len ) ; print string ( v , num , len ) ; } }	prints a string to the stream , encoded as utf - 8 with preceeding length.
private void write attr ( string name , string val ) throws io { write attr ( name , val , bool ) ; }	writes the xml attribute name / val.
final private string syntax def2 syntax desc ( attributes attrs ) throws naming exception { string buffer syntax desc = new string buffer ( str ) ; attribute attr = null ; int count = num ; attr = attrs . get ( numericoid id ) ; if ( attr != null ) { syntax desc . append ( write numeric oid ( attr ) ) ; count ++ ; } else { throw new configuration exception ( str + str ) ; } attr = attrs . get ( desc id ) ; if ( attr != null ) { syntax desc . append ( write qd ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { string attr id = null ; for ( naming enumeration < ? extends attribute > ae = attrs . get all ( ) ; ae . has more elements ( ) ; ) { attr = ae . next ( ) ; attr id = attr . get id ( ) ; if ( attr id . equals ( numericoid id ) || attr id . equals ( desc id ) ) { continue ; } else { syntax desc . append ( write qd ( attr ) ) ; } } } syntax desc . append ( str ) ; return syntax desc . to string ( ) ; }	translate attributes that describe an attribute syntax definition into the string description as defined in rfc 2252 .
@ override public void write ( buffer buffer , boolean is end ) throws io { if ( s == null ) { buffer . free ( ) ; return ; } try { needs flush = bool ; if ( buffer . is direct ( ) ) { total write bytes += buffer . length ( ) ; s . write ( buffer . direct ( ) ) ; return ; } total write bytes += buffer . length ( ) ; while ( buffer . length ( ) > num ) { write buffer . clear ( ) ; buffer . read ( write buffer ) ; write buffer . flip ( ) ; s . write ( write buffer ) ; } } catch ( io e ) { io exn = client disconnect exception . create ( this + str + e , e ) ; try { close ( ) ; } catch ( io e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }	writes an nio buffer to the socket .
private static void skip member value ( int tag , byte buffer buf ) { switch ( tag ) { case str : buf . get int ( ) ; break ; case str : skip annotation ( buf , bool ) ; break ; case str : skip array ( buf ) ; break ; default : buf . get short ( ) ; } }	skips the annotation member value at the current position in the specified byte buffer.
protected void recursive nested join ( event bean lookup event , int nesting order index , event bean [ ] current path , collection < event bean [ ] > result , expr evaluator context expr evaluator context ) { list < event bean [ ] > nested result = new linked list < event bean [ ] > ( ) ; exec node nested exec node = child nodes . get ( nesting order index ) ; nested exec node . process ( lookup event , current path , nested result , expr evaluator context ) ; boolean is last stream = ( nesting order index == nesting order length - num ) ; if ( ! is last stream ) { for ( event bean [ ] row : nested result ) { event bean lookup = row [ nested streams [ nesting order index ] ] ; recursive nested join ( lookup , nesting order index + num , row , result , expr evaluator context ) ; } return ; } for ( event bean [ ] row : nested result ) { result . add ( row ) ; } }	recursive method to run through all child nodes and , for each result set tuple returned by a child node , execute the inner child of the child node until there are no inner child nodes .
public string generate minimal mat ( ) { config config = new config ( ) ; config group ippcm = config . create module ( matrix based pt router config group . group name ) ; ippcm . add param ( matrix based pt router config group . pt stops , this . pt stops ) ; ippcm . add param ( matrix based pt router config group . using pt stops , str ) ; ippcm . add param ( matrix based pt router config group . pt travel times and distances switch , this . use travel times and distances ) ; change mode config group change mode config = config utils . add or get module ( config , change mode config group . config module , change mode config group . class ) ; string [ ] str = { str , str } ; change mode config . set modes ( str ) ; return write config file ( config ) ; }	generates the external matsim config file with the specified parameter settings.
public recorded request take request ( ) throws interrupted exception { return request queue . take ( ) ; }	awaits the next http request , removes it , and returns it.
private int convert location to column ( int x , int y ) { if ( cell width > num ) { if ( layout orientation == j . vertical ) { return num ; } insets insets = list . get insets ( ) ; int col ; if ( is left to right ) { col = ( x - insets . left ) / cell width ; } else { col = ( list . get width ( ) - x - insets . right - num ) / cell width ; } if ( col < num ) { return num ; } else if ( col >= column count ) { return column count - num ; } return col ; } return num ; }	returns the closest column to the passed in location .
public static list < file > find files in dir ( file directory , filename filter filter ) { vector < file > files = new vector < file > ( ) ; file [ ] entries = directory . list files ( ) ; for ( file entry : entries ) { if ( filter == null || filter . accept ( directory , entry . get name ( ) ) ) { files . add ( entry ) ; } if ( entry . is directory ( ) ) { files . add all ( find files in dir ( entry , filter ) ) ; } } return files ; }	given a java . io . file representing a directory , list all the files underneath that directory matching the given filenamefilter .
public string generate drop ( string table ) { string buffer result = new string buffer ( ) ; result . append ( str ) ; result . append ( table ) ; result . append ( str ) ; return result . to string ( ) ; }	generate the drop statement for a table .
private void register child listeners ( ) { iterator < property change listener > iter = f child listeners . iterator ( ) ; while ( iter . has next ( ) ) { property change listener listener = iter . next ( ) ; listener . register ( ) ; } }	register the child listeners on the child preference stores .
boolean is scroll out of bounds ( ) { return float . compare ( get scroll amount out of bounds ( m stack scroll p ) , num ) != num ; }	returns whether the specified scroll is out of bounds.
public list < instruction > reduce instructions ( final list < instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stack size simulator . build stack sizes ( instructions ) ; return reduce instructions internal ( instructions ) ; } finally { lock . unlock ( ) ; } }	returns all instructions which are somewhat " relevant " for the returned object of the method.
protected boolean is locked locally ( uuid new owner id ) { return this node . equals ( get owner node ( ) ) || this node . equals ( new owner id ) ; }	checks if latest call to acquire / release was called on this node.
private boolean try to move ( float delta y ) { if ( ( delta y > num && m current pos == num ) ) { if ( debug ) { log . d ( log tag , string . format ( str ) ) ; } return bool ; } if ( ( delta y < num && m current pos == - m header height ) ) { if ( debug ) { log . d ( log tag , string . format ( str ) ) ; } return bool ; } int to = m current pos + ( int ) delta y ; if ( to < - m header height ) { if ( debug ) { log . d ( log tag , string . format ( str ) ) ; } to = - m header height ; } if ( to > num ) { if ( debug ) { log . d ( log tag , string . format ( str ) ) ; } to = num ; } return move to ( to ) ; }	if deltay > 0 , trytomove the content down.
public void test compare neg neg2 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
@ override public boolean delete left word ( ) { m input connection . begin batch edit ( ) ; if ( m input connection . get selected text ( num ) != null ) { m input connection . commit text ( str , num ) ; } else { char sequence before cursor = m input connection . get text before cursor ( max deletable context , num ) ; if ( before cursor != null ) { int before cursor length = before cursor . length ( ) ; matcher m = whitespace and token . matcher ( before cursor ) ; int last index = num ; while ( m . find ( ) ) { last index = before cursor length == m . end ( ) ? m . start ( ) : m . end ( ) ; } if ( last index > num ) { m input connection . delete surrounding text ( before cursor length - last index , num ) ; } else if ( before cursor length < max deletable context ) { m input connection . delete surrounding text ( before cursor length , num ) ; } } } m input connection . end batch edit ( ) ; return bool ; }	deletes all characters up to the leftmost whitespace from the cursor ( including the whitespace ).
public static double cdf ( double val , double rate ) { if ( val < num ) { return num ; } return num - math . exp ( - rate * val ) ; }	cumulative density , static version.
public static data set read continuous ( file file , char delimiter ) throws io { return read in continuous data ( file , delimiter , collections . singleton ( str ) ) ; }	read in continuous dataset .
public static string generate native guid for storage port from indication ( string source instance system name , string port network id ) { string [ ] splited string = source instance system name . split ( constants . path delimiter regex ) ; return string . format ( str , splited string [ num ] , splited string [ num ] , port network id ) ; }	fc port value from indication sourceinstancesystemname : symmetrix + 000198700406 + fa - 1e iscsi port value from indication sourceinstancesystemname : symmetrix + 000198700406 + se - 1g.
protected boolean are paths contiguous ( tree path [ ] paths ) { if ( row mapper == null || paths . length < num ) return bool ; else { bit set bit set = new bit set ( num ) ; int an index , counter , min ; int path count = paths . length ; int valid count = num ; tree path [ ] temp path = new tree path [ num ] ; temp path [ num ] = paths [ num ] ; min = row mapper . get rows for paths ( temp path ) [ num ] ; for ( counter = num ; counter < path count ; counter ++ ) { if ( paths [ counter ] != null ) { temp path [ num ] = paths [ counter ] ; int [ ] rows = row mapper . get rows for paths ( temp path ) ; if ( rows == null ) { return bool ; } an index = rows [ num ] ; if ( an index == - num || an index < ( min - path count ) || an index > ( min + path count ) ) return bool ; if ( an index < min ) min = an index ; if ( ! bit set . get ( an index ) ) { bit set . set ( an index ) ; valid count ++ ; } } } int max counter = valid count + min ; for ( counter = min ; counter < max counter ; counter ++ ) if ( ! bit set . get ( counter ) ) return bool ; } return bool ; }	returns true if the paths are contiguous , or this object has no rowmapper .
public fast string reader ( string s ) { this . str = s ; this . length = s . length ( ) ; }	creates a new string reader .
public query string query builder field ( string field , float boost ) { if ( fields == null ) { fields = new array list < > ( ) ; } fields . add ( field ) ; if ( fields boosts == null ) { fields boosts = new object float hash map < > ( ) ; } fields boosts . put ( field , boost ) ; return this ; }	adds a field to run the query string against with a specific boost .
public static string now date string ( string format ) { simple date format df = new simple date format ( format ) ; return df . format ( new date ( ) ) ; }	return a string formatted as format.
protected void init stream buffer size ( ) { string stream buffer size param = get init parameter ( str ) ; set stream buffer size ( ( stream buffer size param == null ) ? default stream buffer size : integer . parse int ( stream buffer size param ) ) ; if ( is debug ( ) ) { log ( str + get stream buffer size ( ) ) ; } }	initializer for property streambuffersize .
public void register sensor ( sensor s , int i ) { if ( ( i < num ) || ( i > ( ( num input cards ( ) * bits per card ) - num ) ) || ( i > maxsensors ) ) { log . error ( str + integer . to string ( i + num ) ) ; return ; } has active sensors = bool ; if ( sensor array [ i ] == null ) { sensor array [ i ] = s ; if ( last used sensor < i ) { last used sensor = i ; } } else { log . warn ( str + integer . to string ( ( get node address ( ) * serial sensor manager . sensorsperua ) + i + num ) ) ; } }	the numbers here are 0 to maxsensors , not 1 to maxsensors .
public static number as number ( string value , supplier < number > default value provider ) { if ( value != null ) { try { return short . value of ( value ) ; } catch ( number format exception e1 ) { try { return integer . value of ( value ) ; } catch ( number format exception e2 ) { try { return long . value of ( value ) ; } catch ( number format exception e3 ) { try { return float . value of ( value ) ; } catch ( number format exception e4 ) { try { return double . value of ( value ) ; } catch ( number format exception e5 ) { try { return new big integer ( value ) ; } catch ( number format exception e6 ) { try { return new big decimal ( value ) ; } catch ( number format exception e7 ) { } } } } } } } } return default value provider != null ? default value provider . get ( ) : null ; }	parse the supplied string as a number .
public final void sample ( ) { long sum = sum . get and set ( num ) ; int count = count . get and set ( num ) ; if ( count != num ) value = sum / ( double ) count ; else value = num ; }	return the probe ' s next sample .
private string apply replacement ( final bidi map replacement , string contents ) { for ( object key : replacement . key set ( ) ) { string attribute name = ( string ) key ; string attribute initials = ( string ) replacement . get ( key ) ; contents = contents . replace all ( json . json attribute name ( attribute name ) , json . json attribute name ( attribute initials ) ) ; } return contents ; }	perform the keyword substitution .
public key impl ( kerberos principal principal , char [ ] password , string algorithm ) { try { principal name princ = new principal name ( principal . get name ( ) ) ; encryption key key = new encryption key ( password , princ . get salt ( ) , algorithm ) ; this . key bytes = key . get bytes ( ) ; this . key type = key . get e ( ) ; } catch ( krb exception e ) { throw new illegal argument exception ( e . get message ( ) ) ; } }	constructs a keyimpl from a password .
@ override public string to string ( ) { string result = str ; result += get compatibility state ( ) ; if ( m == null ) { result += str ; } else { result += str + utils . back quote chars ( m . relation name ( ) ) ; } return result ; }	gets a text descrption of the result producer .
public static void process ( list < packages > pkg list ) throws exception { init ( ) ; string [ ] temps = templates . split ( str ) ; string [ ] vm files = new string [ temps . length ] ; for ( int i = num ; i < temps . length ; i ++ ) { vm files [ i ] = temps [ i ] + str ; } for ( packages pkg : pkg list ) { for ( string vm file : vm files ) { generator ( vm file , pkg ) ; } } }	process main logic for create file.
public boolean check ( final direction dir , final boolean facing ) { if ( this . dir != dir ) { return bool ; } if ( this . facing != facing ) { return bool ; } final long now = system . current time millis ( ) ; if ( now >= expiration ) { return bool ; } expiration = now + delay ; return bool ; }	check if a new direction matches the existing one , and if so , reset the expiration point .
private void parse ( string path ) throws exception { if ( path != null ) { count = path . length ( ) ; data = new char [ count ] ; path . get chars ( num , count , data , num ) ; } path ( ) ; }	this method is used to parse the provided xpath expression.
public void record variable ( string type desc , string var name , int var no , symbol table tbl ) throws compile error { char c ; int dim = num ; while ( ( c = type desc . char at ( dim ) ) == str ) ++ dim ; int type = member resolver . desc to type ( c ) ; string cname = null ; if ( type == class ) { if ( dim == num ) cname = type desc . substring ( num , type desc . length ( ) - num ) ; else cname = type desc . substring ( dim + num , type desc . length ( ) - num ) ; } declarator decl = new declarator ( type , cname , dim , var no , new symbol ( var name ) ) ; tbl . append ( var name , decl ) ; }	makes the given variable name available .
protected synchronized void read dont verify ( ) throws io , file encryption exception { if ( backing random access file . length ( ) < header size ( ) ) { throw new file encryption exception ( str ) ; } long oldpos = backing random access file . get file pointer ( ) ; backing random access file . seek ( num ) ; byte [ ] header data = new byte [ header size ( ) - file header . auth tag size ] ; backing random access file . read ( header data ) ; backing random access file . seek ( oldpos ) ; data input stream istream = new data input stream ( new byte array input stream ( header data ) ) ; byte [ ] tmpmagic = new byte [ panbox file magic . length ] ; istream . read ( tmpmagic ) ; if ( ! arrays . equals ( tmpmagic , panbox file magic ) ) { throw new file encryption exception ( str ) ; } byte [ ] tmpversion = new byte [ panbox file version . length ] ; istream . read ( tmpversion ) ; if ( ! arrays . equals ( tmpversion , panbox file version ) ) { throw new file encryption exception ( str + panbox file version . to string ( ) ) ; } this . share key version = istream . read int ( ) ; istream . close ( ) ; }	reads magic + share key version without verification.
private boolean is media type supported ( string media ) { for ( int i = num ; i < supported media types . length ; i ++ ) { if ( media . equals ignore case ( supported media types [ i ] ) ) { return bool ; } } return bool ; }	returns true if the specified css media type is unsupported , false otherwise.
private void export dependencies ( j jcas ) { dependencies = new linked hash map < token , list < dependency > > ( ) ; list < token > non governed = new array list < token > ( nodes . key set ( ) ) ; for ( dependency dependency : select ( jcas , dependency . class ) ) { token governor = dependency . get governor ( ) ; token dependent = dependency . get dependent ( ) ; list < dependency > l = dependencies . get ( governor ) ; if ( l == null ) { dependencies . put ( governor , new array list < dependency > ( ) ) ; l = dependencies . get ( governor ) ; } l . add ( dependency ) ; non governed . remove ( dependent ) ; } for ( token t : non governed ) { traverse dependents ( t , str , - num ) ; write to file ( str , component id , str , str , str ) ; component id ++ ; } }	traverse the dependency structure beginning from all " roots " , i.
public static char [ ] fix83600 ( char [ ] signature ) { if ( signature == null || signature . length < num ) return signature ; return signature . remove capture ( signature ) ; }	todo this is a temporary workaround for https : / / bugs.
public static boolean is network available ( context context ) { connectivity manager connectivity manager = ( connectivity manager ) context . get system service ( context . connectivity service ) ; network info info = connectivity manager . get active network info ( ) ; return info != null && info . is connected ( ) ; }	returns network availability status .
public static string random regexpish string ( random r ) { return random regexpish string ( r , num ) ; }	returns a string thats " regexpish " ( contains lots of operators typically found in regular expressions ) if you call this enough times , you might get a valid regex !.
public list < expected partition value entity > create expected partition value entities ( string partition key group name , list < string > expected partition values ) { partition key group entity partition key group entity = partition key group dao . get partition key group by name ( partition key group name ) ; if ( partition key group entity == null ) { partition key group entity = partition key group dao test helper . create partition key group entity ( partition key group name ) ; } list < expected partition value entity > expected partition value entities = new array list < > ( ) ; for ( string expected partition value : expected partition values ) { expected partition value entity expected partition value entity = new expected partition value entity ( ) ; expected partition value entity . set partition key group ( partition key group entity ) ; expected partition value entity . set partition value ( expected partition value ) ; expected partition value entities . add ( expected partition value dao . save and refresh ( expected partition value entity ) ) ; } return expected partition value entities ; }	creates and persists specified partition value entities.
public string to string ( ) { return text ( ) ; }	returns the text of this gpathresult .
public static low memory watcher register ( @ not null runnable runnable ) { return new low memory watcher ( runnable ) ; }	registers a runnable to run on low memory events.
public void write data ( data output dout ) throws io { dout . write ( get message ( ) ) ; }	writedata - - output the completed modbus message to dout.
public object extract hard ref ( object o ) { soft reference w = ( soft reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }	extracts the hard reference from the soft / weak reference given.
public static string format long ( long number ) { return int format . format ( number ) ; }	formats a long value.
public static void uncontribute ( component addon component ) { contributed components . remove ( component ) ; if ( current addon != null ) { component . uninitialize ( current addon ) ; } }	removes the contribution of the given addon.
public synchronized int copy direct ( int page id , output stream out ) throws io { byte [ ] buffer = new byte [ page size ] ; if ( page id >= page count ) { return - num ; } file . seek ( ( long ) page id << page size shift ) ; file . read fully direct ( buffer , num , page size ) ; read count ++ ; out . write ( buffer , num , page size ) ; return page id + num ; }	copy the next page to the output stream .
public void write raw bytes ( final byte [ ] value , int offset , int length ) throws io { if ( limit - position >= length ) { system . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { throw new out of space exception ( position , limit ) ; } }	write part of an array of bytes .
private void assert backup status ( final backup status backup status ) { map < distributed member , set < id > > backup map = backup status . get backed up disk stores ( ) ; assert false ( backup map . is empty ( ) ) ; for ( distributed member member : backup map . key set ( ) ) { for ( id id : backup map . get ( member ) ) { assert not null ( id . get host ( ) ) ; assert not null ( id . get uuid ( ) ) ; assert not null ( id . get directory ( ) ) ; } } }	used to confirm valid backupstatus data . confirms fix for defect # 45657.
@ request mapping ( value = str ) public void metadata error ( locale locale , @ path variable ( value = str ) string tenant , http servlet response response ) throws io { logger . info ( str , locale . to string ( ) , tenant ) ; metadata default tenant binding error ( locale , response ) ; }	handle request sent with a wrong binding.
public synchronized void check state ( state ... required states ) throws illegal state exception { for ( state required state : required states ) { if ( required state . equals ( current state ) ) { return ; } } throw new illegal state exception ( string . format ( locale . us , str , lists . new array list ( required states ) , current state ) ) ; }	checks that the machine is in one of the given states.
public void sort movies ( ) { synchronized ( movies ) { utils . sort list ( movies , movie set comparator ) ; movie ids . clear ( ) ; for ( movie movie : movies ) { movie ids . add ( movie . get db id ( ) ) ; } } fire property change ( str , null , movies ) ; }	sort movies inside this movie set by using either the sort title , release date or year .
public key value list parser ( string pair delimiter regex , string key val delimiter regex ) { pair delimiter = pattern . compile ( pair delimiter regex ) ; key val delimiter = pattern . compile ( key val delimiter regex ) ; }	create a parser that uses the given regexes to parse a list of key value pairs .
private synchronized boolean poll stats broker ( destination queue ) { stats message listener . set destination ( queue ) ; timestamp timestamp = new timestamp ( system . current time millis ( ) ) ; logger . debug ( str + get queue name ( queue ) + str + timestamp ) ; jms template . execute ( stats broker destination + get queue name ( queue ) , new producer callback impl ( stats queue ) ) ; try { thread . sleep ( num * num ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } return stats message listener . get stats ( ) != null ; }	poll the statistics broker plugin.
public file make acceptable ( file pathname ) { if ( accept ( pathname ) ) { return pathname ; } else { return new file ( pathname . get path ( ) + str + default extension ) ; } }	appends the extension to the filename , in case it is missing .
private static boolean edge intersects cell boundary ( s2 point a , s2 point b , s2 cell cell ) { s2 point [ ] vertices = new s2 point [ num ] ; for ( int i = num ; i < num ; ++ i ) { vertices [ i ] = cell . get vertex ( i ) ; } for ( int i = num ; i < num ; ++ i ) { s2 point from point = vertices [ i ] ; s2 point to point = vertices [ ( i + num ) % num ] ; if ( lenient crossing ( a , b , from point , to point ) ) { return bool ; } } return bool ; }	returns true if the edge and the cell ( including boundary ) intersect .
protected void update overlay contents ( look at look at , camera camera ) { lat view . set text ( format latitude ( look at . latitude ) ) ; lon view . set text ( format longitude ( look at . longitude ) ) ; alt view . set text ( format altitude ( camera . altitude ) ) ; }	displays navigator state information in the status overlay views .
public string js type name ( type ref type ref ) { switch ( type ref . get kind ( ) ) { case type message : return str ; case type enum : return str ; default : { string name = primitive type names . get ( type ref . get kind ( ) ) ; if ( ! strings . is null or empty ( name ) ) { return name ; } throw new illegal argument exception ( str + type ref . get kind ( ) ) ; } } }	returns the name of js type for the given typeref .
public state machine create state machine ( state machine definition state machine definition ) { final map < event definition , event data > event data map = state machine definition . get event data map ( ) ; set < event > all events = create all events ( event data map ) ; set < state definition > state definitions = state machine definition . get states ( ) ; set < state > states = new hash set < > ( ) ; for ( state definition state definition : state definitions ) { state state = convert state definition to state ( state definition ) ; states . add ( state ) ; } state machine state machine = new state machine ( state machine definition . get version ( ) , state machine definition . get name ( ) , state machine definition . get description ( ) , states , state machine definition . get correlation id ( ) ) ; state machines dao . create ( state machine ) ; for ( event event : all events ) { event . set state machine instance id ( state machine . get id ( ) ) ; event persistence service . persist event ( event ) ; } for ( state state : state machine . get states ( ) ) { audit dao . create ( new audit record ( state machine . get id ( ) , state . get id ( ) , num , status . initialized , null , null ) ) ; } return state machine ; }	converts state machine definition to state machine domain object and saves in db .
public void dispose ( ) { clear listeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }	method called when layer detects that it has been removed from maphandler , assumes it ' s being thrown away.
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; registrar id = new id ( in ) ; if ( server == null ) { throw new invalid object exception ( str ) ; } }	reads the default serializable field value for this instance , followed by the registrar ' s service id encoded as specified by the serviceid.
public shape triangle right ( float x , float y , float height ) { m path . reset ( ) ; m path . move to ( x , y + height ) ; m path . line to ( x + height , y + height / num ) ; m path . line to ( x , y ) ; m path . close path ( ) ; return m path ; }	returns a right - pointing triangle of the given dimenisions .
public static terminal find ( string with name ) { if ( with name == null ) return null ; else return ( terminal ) all . get ( with name ) ; }	lookup a terminal by name string .
public layout block create new layout block ( string system name , string user name ) { layout block block = null ; if ( user name == null || user name . equals ( str ) ) { log . error ( str ) ; return null ; } block = get by user name ( user name ) ; if ( block != null ) { return null ; } string s name = str ; if ( system name == null ) { boolean found = bool ; while ( found ) { s name = str + blk num ; blk num ++ ; block = get by system name ( s name ) ; if ( block == null ) { found = bool ; } } } else { block = get by system name ( ( system name . to upper case ( ) ) ) ; if ( block != null ) { return null ; } s name = system name . to upper case ( ) ; } block = new layout block ( s name , user name ) ; register ( block ) ; return block ; }	method to create a new layoutblock if the layoutblock does not exist returns null if a layoutblock with the same systemname or username already exists , or if there is trouble creating a new layoutblock.
@ override public void modify nonstatic j ( final map values ) throws pdf exception { options . set ( values ) ; if ( values . contains key ( j . display background ) ) { } }	allow user to alter certain values in software such as colour , please note all color and text highlighting values are static and common across the jvm.
public static string escape regex ( final string regex ) { matcher match = regex chars . matcher ( regex ) ; return match . replace all ( str ) ; }	this function will escape special characters within a string to ensure that the string will not be parsed as a regular expression.
public char buffer ( string string ) { int length = string . length ( ) ; int capacity = length + min capacity ; init ( new char [ capacity ] , num , length ) ; string . get chars ( num , length , buffer ( ) , num ) ; }	constructs a char buffer with the given initial string.
private void update promo visibility ( float percentage ) { if ( is promo available ( ) ) { m promo visible = bool ; m promo height px = math . round ( math utils . clamp ( percentage * m promo content height px , num , m promo content height px ) ) ; m promo opacity = percentage ; } else { m promo visible = bool ; m promo height px = num ; m promo opacity = num ; } }	updates the ui state for opt out promo .
private value geometry ( byte [ ] bytes , geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hash code = arrays . hash code ( bytes ) ; }	create a new geometry objects .
@ override public void do after propagation ( ) { for ( heap ins interval manager im : new pts . values ( ) ) { im . flush ( ) ; } new pts = new hash map < alloc node , heap ins interval manager > ( ) ; }	remember to clean the is_new flag.
static boolean is exist ( string lib name , int version ) { string file = target so file ( lib name , version ) ; file a = new file ( file ) ; return a . exists ( ) ; }	tell whether the so is extracted .
private void finish common ( ) { if ( ! unknown subjects . is empty ( ) ) { if ( statements . is empty ( ) && restored statements . is empty ( ) ) { throw new bad subject exception ( unknown subjects . key set ( ) , uris ) ; } else { log . info ( str , unknown subjects . key set ( ) , uris . entity data ( ) , uris . entity ( ) ) ; } } if ( revision id == null ) { throw new contained exception ( str + statements ) ; } if ( last modified == null ) { throw new contained exception ( str + statements ) ; } for ( pair < uri , literal > data statement : data statements ) { statements . add ( new statement impl ( entity uri impl , data statement . get left ( ) , data statement . get right ( ) ) ) ; } statements . add all ( restored statements ) ; }	perform all munge completion tasks that are required no matter the configuration.
public static final void show gui ( final string user message , final buffered image image , final string title ) { if ( image == null ) { return ; } final image panel display = new image panel ( image ) ; display . set layout ( new border layout ( ) ) ; if ( user message != null ) { display . add ( new j ( user message ) , border layout . south ) ; } final int width = image . get width ( ) ; final int height = image . get height ( ) ; display . set size ( new dimension ( width + num , height + num ) ) ; j . show confirm dialog ( content pane , display , title , j . default option , j . plain message ) ; }	display message if in gui mode.
private void dyn init ( ) { }	dynamic init . table layout , visual , listener.
@ override public path call ( ) throws exception { final set < file visit option > options ; if ( follow links ) { options = enum set . of ( file visit option . follow links ) ; } else { options = enum set . none of ( file visit option . class ) ; } logger . info ( string . format ( str , path ) ) ; try { files . walk file tree ( path , options , max depth , this ) ; } catch ( io e ) { logger . log ( level . severe , string . format ( str , path ) , e ) ; throw e ; } logger . info ( string . format ( str , path ) ) ; return path ; }	recursively walks the file tree of a directory .
private void baseline layout ( int origin , int size ) { int ascent ; int descent ; if ( baseline anchored to top ) { ascent = pref ascent ; descent = size - ascent ; } else { ascent = size - pref descent ; descent = pref descent ; } for ( spring spring : springs ) { alignment alignment = spring . get alignment ( ) ; if ( alignment == null || alignment == alignment . baseline ) { int baseline = spring . get baseline ( ) ; if ( baseline >= num ) { int spring max = spring . get maximum size ( vertical ) ; int spring pref = spring . get preferred size ( vertical ) ; int height = spring pref ; int y ; switch ( spring . get baseline resize behavior ( ) ) { case constant ascent : y = origin + ascent - baseline ; height = math . min ( descent , spring max - baseline ) + baseline ; break ; case constant descent : height = math . min ( ascent , spring max - spring pref + baseline ) + ( spring pref - baseline ) ; y = origin + ascent + ( spring pref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . set size ( vertical , y , height ) ; } else { set child size ( spring , vertical , origin , size ) ; } } else { set child size ( spring , vertical , origin , size ) ; } } }	lays out springs that have a baseline along the baseline.
public static int read int ( final json json array , final int index , final boolean required , final boolean not null ) throws json { if ( required ) { return json array . get int ( index ) ; } if ( not null && json array . is null ( index ) ) { throw new json ( string . format ( locale . us , null value format array , index ) ) ; } int value = num ; if ( ! json array . is null ( index ) ) { value = json array . get int ( index ) ; } return value ; }	reads the int value from the json array for specified index.
public void add property change listener ( property change listener pcl ) { m pc support . add property change listener ( pcl ) ; }	add a property change listener.
private void unregister dependent ( preference dependent ) { if ( m dependents != null ) { m dependents . remove ( dependent ) ; } }	removes a dependent preference on this preference .
private void validate storage policy selection ( storage policy selection storage policy selection ) { assert . not null ( storage policy selection , str ) ; business object data helper . validate business object data key ( storage policy selection . get business object data key ( ) , bool , bool ) ; storage policy helper . validate storage policy key ( storage policy selection . get storage policy key ( ) ) ; assert . not null ( storage policy selection . get storage policy version ( ) , str ) ; }	validates the storage policy selection.
@ override public string to string ( ) { string buffer text = new string buffer ( ) ; if ( m cobweb tree == null ) { return str ; } else { m cobweb tree . dump tree ( num , text ) ; return str + m number merges + str + m number splits + str + number of clusters ( ) + str + text . to string ( ) + str ; } }	returns a description of the clusterer as a string .
public static object to array ( collection < ? > collection , class < ? > component type ) { if ( component type . is primitive ( ) ) { object array = array . new instance ( component type , collection . size ( ) ) ; int index = num ; for ( object value : collection ) { array . set ( array , index ++ , value ) ; } return array ; } return collection . to array ( ( object [ ] ) array . new instance ( component type , collection . size ( ) ) ) ; }	returns a new array of the given component type ( possibly a java primitive ) that is a copy of the content of the given collection .
gradle exception format violations for ( formatter formatter , list < file > problem files ) throws io { return new gradle exception ( diff message formatter . message for ( this , formatter , problem files ) ) ; }	returns an exception which indicates problem files nicely .
public void label distances ( hypergraph < v , e > graph , v root ) { label distances ( graph , collections . singleton ( root ) ) ; }	computes the distances of all the node from the specified root node.
public int position ( ) { return line buffer == null ? num : line buffer . length ( ) ; }	gets the current column position of this log stream .
public void add frequency ( frequency frequency ) { frequencies . add ( frequency ) ; }	adds a new frequency.
public final static header element parse header element ( final string value , header value parser parser ) throws parse exception { if ( value == null ) { throw new illegal argument exception ( str ) ; } if ( parser == null ) parser = save header value parser . default ; char array buffer buffer = new char array buffer ( value . length ( ) ) ; buffer . append ( value ) ; save parser cursor cursor = new save parser cursor ( num , value . length ( ) ) ; return parser . parse header element ( buffer , cursor ) ; }	parses an element with the given parser .
public static list < interval > slice intervals ( interval interval , time grain time grain ) { date time interval end = interval . get end ( ) ; date time slice start = interval . get start ( ) ; date time period start = time grain . round floor ( slice start ) ; if ( ! slice start . equals ( period start ) ) { log . info ( str , interval , time grain , period start ) ; throw new illegal argument exception ( str + period start ) ; } list < interval > interval slices = new array list < > ( ) ; while ( slice start . is before ( interval end ) ) { date time slice end = date time utils . add time grain ( slice start , time grain ) ; interval sliced interval = new interval ( slice start , slice end ) ; if ( ! interval . contains ( sliced interval ) ) { log . info ( str , interval , time grain ) ; throw new illegal argument exception ( str ) ; } interval slices . add ( sliced interval ) ; slice start = slice end ; } log . debug ( str , interval , interval slices . size ( ) , time grain ) ; return interval slices ; }	slices the intervals into smaller intervals of the timegrain duration .
public boolean is gerund ( ) { return type string . starts with ( verb gerund ) ; }	determine if the expression contains a verb in gerund form .
protected void error ( string msg , exception e ) throws org . xml . sax . sax { sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; transformer exception pe ; if ( ! ( e instanceof transformer exception ) ) { pe = ( null == e ) ? new transformer exception ( msg , locator ) : new transformer exception ( msg , locator , e ) ; } else pe = ( transformer exception ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } } else throw new org . xml . sax . sax ( pe ) ; }	tell the user of an error , and probably throw an exception .
private json object create request ( map < string , object > headers , string uri , http method method , json object payload ) { json object request = new json object ( ) ; json array json headers = new json array ( ) ; headers . for each ( null ) ; request . put ( str , json headers ) ; request . put ( str , uri ) ; request . put ( str , method . to string ( ) ) ; request . put ( str , payload ) ; return request ; }	creates a new request with the given parameters .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { child . replace data ( - num , num , str ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
private long download tlog files ( file tmp tlog dir , long latest generation ) throws exception { log . info ( str + tlog files to download ) ; tlog files downloaded = collections . synchronized list ( new array list < > ( ) ) ; long bytes downloaded = num ; boolean status = tmp tlog dir . mkdirs ( ) ; if ( ! status ) { throw new solr exception ( solr exception . error code . server error , str + tmp tlog dir . get name ( ) ) ; } for ( map < string , object > file : tlog files to download ) { string save as = ( string ) ( file . get ( alias ) == null ? file . get ( name ) : file . get ( alias ) ) ; local file fetcher = new local fs file fetcher ( tmp tlog dir , file , save as , tlog file , latest generation ) ; current file = file ; local file fetcher . fetch file ( ) ; bytes downloaded += local file fetcher . get bytes downloaded ( ) ; tlog files downloaded . add ( new hash map < > ( file ) ) ; } return bytes downloaded ; }	download all the tlog files to the temp tlog directory .
static windows file attributes read attributes ( long handle ) throws windows exception { native buffer buffer = native buffers . get native buffer ( sizeof file information ) ; try { long address = buffer . address ( ) ; get file information by handle ( handle , address ) ; int reparse tag = num ; int file attrs = unsafe . get int ( address + offsetof file information attributes ) ; if ( is reparse point ( file attrs ) ) { int size = maximum reparse data buffer size ; native buffer reparse buffer = native buffers . get native buffer ( size ) ; try { device io control get reparse point ( handle , reparse buffer . address ( ) , size ) ; reparse tag = ( int ) unsafe . get long ( reparse buffer . address ( ) ) ; } finally { reparse buffer . release ( ) ; } } return from file information ( address , reparse tag ) ; } finally { buffer . release ( ) ; } }	reads the attributes of an open file.
protected void add all for replay ( collection < participant > participants ) { iterator < participant > it = participants . iterator ( ) ; while ( it . has next ( ) ) { participant p = it . next ( ) ; replay completion ( p ) ; } }	utility method for subclasses .
public static j create checkbox ( string boxlabel , string [ ] buttons , boolean [ ] checked , action listener al ) { j jp = create palette j ( boxlabel ) ; for ( int j = num ; j < buttons . length ; j ++ ) { j jcb = new j ( buttons [ j ] ) ; jcb . set action command ( integer . to string ( j ) ) ; if ( al != null ) jcb . add action listener ( al ) ; jcb . set selected ( checked [ j ] ) ; jp . add ( jcb ) ; } return jp ; }	create a panel containing a checkbox .
public static double assign probabilities to instances ( relation < ? extends number vector > relation , list < ? extends em < ? > > models , writable data store < double [ ] > prob cluster i x ) { final int k = models . size ( ) ; double em sum = num ; for ( dbid iditer = relation . iter dbi ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { number vector vec = relation . get ( iditer ) ; double [ ] probabilities = new double [ k ] ; { int i = num ; for ( em < ? > m : models ) { probabilities [ i ] = m . estimate density ( vec ) ; ++ i ; } } double prior probability = num ; for ( int i = num ; i < k ; i ++ ) { prior probability += probabilities [ i ] ; } double log p = math . max ( math . log ( prior probability ) , min loglikelihood ) ; em sum += ( log p == log p ) ? log p : num ; double [ ] cluster probabilities = new double [ k ] ; if ( prior probability > num ) { for ( int i = num ; i < k ; i ++ ) { cluster probabilities [ i ] = probabilities [ i ] / prior probability ; } } prob cluster i x . put ( iditer , cluster probabilities ) ; } return em sum / relation . size ( ) ; }	assigns the current probability values to the instances in the database and compute the expectation value of the current mixture of distributions.
public static string as string ( uri value ) { return value != null ? value . to string ( ) : null ; }	gets the value of the uri as a string , returns null if the uri is null .
public kernel ( int offset , double [ ] values ) { this . values = arrays . copy of ( values , values . length ) ; this . offset = offset ; }	creates a new kernel object with the specified offset and values .
private void initialize work list ( ) { for ( gv c : b ) { if ( c . size ( ) == num ) { continue ; } iterator < value graph vertex > i = c . iterator ( ) ; value graph vertex first = i . next ( ) ; while ( i . has next ( ) ) { value graph vertex v = i . next ( ) ; if ( ! check congruence ( first , v ) ) { work list . push ( c ) ; break ; } } } }	initialize the work list.
@ override protected void before model linked ( e model , i diagnostics consumer ) { imported names adapter adapter = imported names adapter . find ( model . e resource ( ) ) ; if ( adapter != null ) adapter . clear ( ) ; union member scope . clear cached composed members ( model ) ; }	removes the imported names before linking and cleans other caches attached to the ast .
protected abstract void add file ( string relative filename ) throws command exception ;	runs the dvcs command for adding a new file , e.
public void tree expanded ( tree expansion event event ) { inspector window . update view ( director . all ) ; }	called whenever an item in the tree has been expanded .
public boolean has item ( t object ) { synchronized ( m lock ) { return source . contains ( object ) ; } }	determine if the object provide is in this adapter.
private static boolean version matches ( integer v1 , int v2 ) { if ( v1 == null || v1 == num || v2 == num ) { return bool ; } return v1 . equals ( v2 ) ; }	determines if a kvno matches another kvno.
protected void on failed closing url connection ( url url connection , io cause ) { }	override if you want to get notified if the url connection fails to close.
private void on schema complex type ( element schema complex type , datatype element factory element factory ) { iterator < element > iter = schema complex type . element iterator ( xsd attribute ) ; while ( iter . has next ( ) ) { element xsd attribute = iter . next ( ) ; string name = xsd attribute . attribute value ( str ) ; q qname = get q ( name ) ; xs data type = data type for xsd attribute ( xsd attribute ) ; if ( data type != null ) { element factory . set attribute xs ( qname , data type ) ; } } element schema sequence = schema complex type . element ( xsd sequence ) ; if ( schema sequence != null ) { on child elements ( schema sequence , element factory ) ; } element schema choice = schema complex type . element ( xsd choice ) ; if ( schema choice != null ) { on child elements ( schema choice , element factory ) ; } element schema all = schema complex type . element ( xsd all ) ; if ( schema all != null ) { on child elements ( schema all , element factory ) ; } }	processes an xml schema & lt ; complextypegt ; tag.
private void push annotators ref ( string values ) { annotators ref . push ( annotators ref . peek ( ) ) ; set annotators ref ( values ) ; }	pushes a new level of annotators references and base the new one on the given values .
public string version compact ( ) { return properties . get property ( str ) ; }	returns the compact version string for this product , suitable for use in path names and similar cases .
private void sequence query ( query entry entry , server session context session , completable future < query response > future ) { if ( entry . get sequence ( ) > session . get command sequence ( ) ) { session . register sequence query ( entry . get sequence ( ) , null ) ; } else { index query ( entry , future ) ; } }	sequences the given query .
private boolean expunge stale entries ( ) { if ( size == num ) return bool ; object r ; boolean result = bool ; while ( ( r = queue . poll ( ) ) != null ) { result = bool ; entry e = ( entry ) r ; int h = e . hash ; int i = index for ( h , table . length ) ; entry prev = table [ i ] ; entry p = prev ; while ( p != null ) { entry next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . next = null ; size -- ; break ; } prev = p ; p = next ; } } return result ; }	expunge stale entries from the table .
public static < t > list < t > rest ( list < t > l ) { return l . sub list ( num , l . size ( ) ) ; }	get a sublist of all of the elements in the list except for first .
public static list < integer > create ranges ( int ... start ends ) { assert start ends . length % num == num ; array list < integer > ret = new array list < integer > ( ) ; for ( int si = num ; si < start ends . length ; si ++ ) { final int start = start ends [ si ++ ] ; final int end = start ends [ si ] ; assert end >= start ; ret . ensure capacity ( ret . size ( ) + ( ( end - start ) + num ) ) ; for ( int i = start ; i <= end ; i ++ ) { ret . add ( new integer ( i ) ) ; } } return ret ; }	create a list of integers consisting of the ranges defined by the provided argument e.
@ after public void tear down ( ) { web client . close all windows ( ) ; }	tear down after testing .
public void find and undo ( object some obj ) { if ( some obj instanceof com . bbn . openmap . map bean ) { logger . fine ( str ) ; map bean map = get map bean ( ) ; if ( map != null && map == ( map bean ) some obj ) { set map bean ( null ) ; } } }	look at the object received in a maphandler status message and disconnect from it if necessary .
public timestamp recalculate estimated completion date ( long priority , timestamp start date ) { if ( exist ( ) ) { get production run routing tasks ( ) ; if ( quantity == null ) get quantity ( ) ; timestamp end date = null ; for ( iterator < generic value > iter = production run routing tasks . iterator ( ) ; iter . has next ( ) ; ) { generic value routing task = iter . next ( ) ; if ( priority . compare to ( routing task . get long ( str ) ) <= num ) { long total time = production run . get estimated task time ( routing task , quantity , dispatcher ) ; end date = tech data services . add forward ( tech data services . get tech data calendar ( routing task ) , start date , total time ) ; routing task . set ( str , start date ) ; routing task . set ( str , end date ) ; start date = end date ; } } return end date ; } else { return null ; } }	recalculated the estimatedcompletiondate property.
public void add document type ( document type document type ) { m document types . add ( document type ) ; }	add a document type to the document type list .
public boolean table exists ( database meta data db meta data , string table name ) throws sql { return ( table exists case sensitive ( db meta data , table name ) || table exists case sensitive ( db meta data , table name . to upper case ( locale . us ) ) || table exists case sensitive ( db meta data , table name . to lower case ( locale . us ) ) ) ; }	checks database metadata to see if a table exists.
public void test has attributes1 ( ) throws throwable { document doc ; element element ; node list element list ; boolean has attributes ; doc = ( document ) load ( str , builder ) ; element list = doc . get elements by tag name ( str ) ; element = ( element ) element list . item ( num ) ; has attributes = element . has attributes ( ) ; assert false ( str , has attributes ) ; element list = doc . get elements by tag name ( str ) ; element = ( element ) element list . item ( num ) ; has attributes = element . has attributes ( ) ; assert true ( str , has attributes ) ; }	runs the test case .
private static position next token pos ( position pos , token [ ] [ ] spec ) { if ( pos == null ) { return null ; } int next item = pos . item + num ; if ( ( next item < spec [ pos . line ] . length ) && ( ( pos . line < pcal end . line ) || ( next item < pcal end . item ) ) ) { return new position ( pos . line , next item ) ; } int next line = pos . line + num ; while ( ( next line < spec . length ) && ( spec [ next line ] . length == num ) ) { next line ++ ; } if ( ( next line < spec . length ) && ( ( next line < pcal end . line ) || ( ( next line == pcal end . line ) && ( num < pcal end . item ) ) ) ) { return new position ( next line , num ) ; } return null ; }	returns the position of the next token after position pos in specification spec if that token exists and is in the pluscal algorithm ; otherwise , it returns null.
public void update ( g gl ) { if ( task queue . size ( ) > num ) { gl res ; while ( ( res = task queue . poll ( ) ) != null ) { res . perform ( gl ) ; } } }	method is called from update cycle , perform all tasks in gl thread.
public static double [ ] hpd ( double proportion , double [ ] x , int [ ] indices ) { double min range = double . max value ; int hpd index = num ; final int diff = ( int ) math . round ( proportion * ( double ) x . length ) ; for ( int i = num ; i <= ( x . length - diff ) ; i ++ ) { final double min value = x [ indices [ i ] ] ; final double max value = x [ indices [ i + diff - num ] ] ; final double range = math . abs ( max value - min value ) ; if ( range < min range ) { min range = range ; hpd index = i ; } } return new double [ ] { x [ indices [ hpd index ] ] , x [ indices [ hpd index + diff - num ] ] } ; }	determine the highest posterior density for a list of values.
private void check if directories exist ( file [ ] disk dirs ) { disk store factory impl . check if directories exist ( disk dirs ) ; }	checks if directories exist.
public void add port to already allocated context ( storage port port , ha ha domain , storage system . type array type , string switch name ) { string engine = get engine ( port , ha domain , array type ) ; if ( engine != null ) { already allocated engines . add ( engine ) ; } string director type = get director type ( array type , ha domain ) ; if ( director type != null ) { already allocated director types . add ( director type ) ; } string director = get director ( port , ha domain ) ; if ( director != null ) { already allocated directors . add ( director ) ; } string cpu = get cpu ( port , ha domain , array type ) ; if ( cpu != null ) { already allocated cpus . add ( cpu ) ; } if ( switch name != null ) { already allocated switches . add ( switch name ) ; } }	allocates existing ports to the already allocated context ( only ).
public string convert ( ) { if ( s == null ) { try { byte array input stream bs = new byte array input stream ( bytes ) ; data input stream d = new data input stream ( bs ) ; string buf = d . read utf ( ) ; s hash code = buf . hash code ( ) ; return buf ; } catch ( io e ) { return str ; } } return s ; }	converts internal representation into an actual string .
public static void write list of longs ( list list , boolean has long i , data output out ) throws io { if ( list == null ) { out . write int ( - num ) ; } else { out . write int ( list . size ( ) ) ; out . write boolean ( has long i ) ; for ( iterator it = list . iterator ( ) ; it . has next ( ) ; ) { long l = ( long ) it . next ( ) ; if ( has long i ) { out . write long ( l . long value ( ) ) ; } else { out . write int ( ( int ) l . long value ( ) ) ; } } } }	write a set of long objects.
public boolean is defined ( object attr name ) { return table . contains key ( attr name ) ; }	tells whether a given attribute is defined .
private void show preloading stage ( ) { stage preloading stage = new stage ( stage style . undecorated ) ; preloading stage . init owner ( primary stage ) ; preloading stage . set scene ( new preloading scene ( ) ) ; preloading stage . show ( ) ; primary stage . set on showing ( null ) ; }	shows preloading stage with scene while fxgl is being configured .
@ override public void clear ( ) { if ( element count > num ) { element count = num ; arrays . fill ( element data , null ) ; mod count ++ ; while ( reference queue . poll ( ) != null ) { } } }	removes all mappings from this map , leaving it empty .
public v remove ( object key ) { int hash = hash ( key . hash code ( ) ) ; segment < k , v > s = segment for hash ( hash ) ; return s == null ? null : s . remove ( key , hash , null ) ; }	removes the key ( and its corresponding value ) from this map.
public void test copy stream full block ( ) throws io { final string id = str ; final int version = num ; random r = new random ( ) ; final byte [ ] expected = new byte [ block size ] ; r . next bytes ( expected ) ; assert equals ( str , expected . length , repo . copy stream ( id , version , new byte array input stream ( expected ) ) ) ; assert equals ( str , num , repo . get block count ( id , version ) ) ; assert same iterator ( str , new long [ ] { num } , repo . blocks ( id , version ) ) ; assert equals ( str , expected , read ( repo . input stream ( id , version ) ) ) ; }	test copy of an stream containing exactly one block ' s data .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string bad string ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { bad string = child . substring data ( - num , num ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
private static int ip to bytes ( string ip , byte [ ] bytes , boolean must have4 ) throws ip { string [ ] parts = ip . split ( str ) ; if ( parts . length > num || must have4 && parts . length != num ) { throw new ip ( str + ip ) ; } try { for ( int i = num ; i < parts . length ; i ++ ) { int p = integer . parse int ( parts [ i ] ) ; if ( p < num || p > num ) { throw new ip ( str + ip ) ; } bytes [ i ] = ( byte ) ( p < num ? p : p - num ) ; } } catch ( number format exception nfe ) { throw new ip ( str + ip , nfe ) ; } return parts . length ; }	fill out a given four - byte array with the ipv4 address specified in the given string.
protected void reply ( request context context , string key , string message ) { try { http servlet request request = context . get request ( ) ; string filename = request . get remote addr ( ) ; end ( filename , key , message ) ; } catch ( exception e ) { } }	emits an " end " line for a successful reply .
protected void add headers ( url connection , string tenant id ) { if ( tenant id == null ) { tenant id = property util . get property ( property util . hawkular tenant ) ; } if ( tenant id != null ) { connection . set request property ( hawkular tenant , tenant id ) ; } if ( authorization == null && username != null ) { string auth string = username + str + password ; string encoded = encoder . encode to string ( auth string . get bytes ( ) ) ; authorization = str + encoded ; } if ( authorization != null ) { connection . set request property ( str , authorization ) ; } }	add the header values to the supplied connection .
public void add long selection listener ( selection listener listener ) { if ( listener == null ) throw new illegal argument exception ( ) ; if ( hex edit control == null ) { if ( list of long listeners == null ) list of long listeners = new array list < > ( ) ; list of long listeners . add ( listener ) ; } else { hex edit control . add long selection listener ( listener ) ; } }	adds a long selection listener.
public void println ( ) throws io { out . write ( strategy . get printer newline ( ) ) ; new line = bool ; }	output a blank line.
@ override public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; boolean first time = bool ; for ( entry < integer , string > entry : m capabilities . entry set ( ) ) { if ( first time ) { first time = bool ; } else { sb . append ( str ) ; } sb . append ( entry . get key ( ) ) ; sb . append ( str ) ; sb . append ( entry . get value ( ) ) ; sb . append ( str ) ; return m capabilities . to string ( ) ; } return sb . to string ( ) ; }	convert to string for debugging.
public debug ( string client id , client comms comms ) { this . client id = client id ; this . comms = comms ; log . set resource name ( client id ) ; }	set the debug facility up for a specific client.
protected string alter case ( string value ) { switch ( get case ( ) ) { case uppercase : return value . to upper case ( ) ; case lowercase : return value . to lower case ( ) ; default : return value ; } }	alter the case of this element so that it is rendered according to whatever the value of case_type is . default is mixedcase.
private boolean is ack required ( ) { return this . ack required ; }	return true if a distributed ack message is required.
@ override public synchronized string to string ( ) { if ( element count == num ) { return str ; } int length = element count - num ; string buffer buffer = new string buffer ( element count * num ) ; buffer . append ( str ) ; for ( int i = num ; i < length ; i ++ ) { if ( element data [ i ] == this ) { buffer . append ( str ) ; } else { buffer . append ( element data [ i ] ) ; } buffer . append ( str ) ; } if ( element data [ length ] == this ) { buffer . append ( str ) ; } else { buffer . append ( element data [ length ] ) ; } buffer . append ( str ) ; return buffer . to string ( ) ; }	returns the string representation of this vector .
void add reporter ( string text reporter , int xx , int yy ) { reporter icon l = new reporter icon ( this ) ; l . set reporter ( text reporter ) ; l . set location ( xx , yy ) ; l . set size ( l . get preferred size ( ) . width , l . get preferred size ( ) . height ) ; l . set display level ( labels ) ; set dirty ( bool ) ; put item ( l ) ; }	add a reporter icon to the panel.
private void draw selection rectangle ( d g2 ) { if ( this . selection rectangle != null ) { if ( this . fill selection rectangle ) { g2 . set paint ( this . selection fill paint ) ; g2 . fill ( selection rectangle ) ; } else { g2 . set paint ( this . selection outline paint ) ; g2 . draw ( selection rectangle ) ; } } }	draws zoom rectangle ( if present ).
public conversion exception ( final throwable cause ) { super ( cause . get message ( ) ) ; this . cause = cause ; }	construct a new exception with the specified root cause .
private boolean has connectivity to all systems ( initiator initiator , collection < uri > storage systems , export group export group ) { return has connectivity to all systems ( initiator , storage systems , null , export group ) ; }	checks if an initiator has connectivity to a storage system in a varray .
private derivation < tk , fv > construct derivation ( derivation < tk , fv > marked node , int source input id , feature extractor < tk , fv > featurizer , scorer < fv > scorer , search heuristic < tk , fv > heuristic , output space < tk , fv > output space ) { final list < derivation < tk , fv > > nodes = new linked list < > ( ) ; derivation < tk , fv > p = marked node ; while ( p != null ) { nodes . add ( num , p ) ; p = p . parent ; } p = marked node . best child ; while ( p != null ) { nodes . add ( p ) ; p = p . best child ; } derivation < tk , fv > goal hyp = null ; for ( derivation < tk , fv > node : nodes ) { goal hyp = goal hyp == null ? node : new derivation < > ( source input id , node . rule , goal hyp . length , goal hyp , featurizer , scorer , heuristic , output space ) ; } return goal hyp ; }	construct a new derivation from a node of interest .
public void test plus math context positive ( ) { string a = str ; int a scale = num ; int precision = num ; rounding mode rm = rounding mode . floor ; math context mc = new math context ( precision , rm ) ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal res = a number . plus ( mc ) ; assert equals ( str , c , res . to string ( ) ) ; assert equals ( str , c scale , res . scale ( ) ) ; }	plus ( mathcontext ) for a positive bigdecimal.
public void test radix24 neg ( ) { string value = str ; int radix = num ; big integer a number = new big integer ( value , radix ) ; string result = a number . to string ( radix ) ; assert true ( result . equals ( value ) ) ; }	test negative number of radix 24.
private static i convert or ( final common tree ast ) throws recognition exception { final list < i > children = new array list < i > ( ) ; for ( final object child object : ast . get children ( ) ) { children . add ( convert ( ( common tree ) child object ) ) ; } return new c ( children ) ; }	converts an antrl or ast into a filter or ast .
public j display panel in window ( final j panel , string title ) { j frame = new j ( ) ; frame . set content pane ( panel ) ; frame . pack ( ) ; frame . set title ( title ) ; frame . set visible ( bool ) ; return frame ; }	a copy of displaypanel except returning a subclass of window.
public json ( reader reader ) { this . reader = reader . mark supported ( ) ? reader : new buffered reader ( reader ) ; this . eof = bool ; this . use previous = bool ; this . previous = num ; this . index = num ; this . character = num ; this . line = num ; }	construct a jsontokener from a reader .
public static void compress ( ) { string s = binary std in . read string ( ) ; char [ ] input = s . to char array ( ) ; int [ ] freq = new int [ r ] ; for ( int i = num ; i < input . length ; i ++ ) freq [ input [ i ] ] ++ ; node root = build trie ( freq ) ; string [ ] st = new string [ r ] ; build code ( st , root , str ) ; write trie ( root ) ; binary std out . write ( input . length ) ; for ( int i = num ; i < input . length ; i ++ ) { string code = st [ input [ i ] ] ; for ( int j = num ; j < code . length ( ) ; j ++ ) { if ( code . char at ( j ) == str ) { binary std out . write ( bool ) ; } else if ( code . char at ( j ) == str ) { binary std out . write ( bool ) ; } else throw new illegal state exception ( str ) ; } } binary std out . close ( ) ; }	reads a sequence of 8 - bit bytes from standard input ; compresses them using huffman codes with an 8 - bit alphabet ; and writes the results to standard output .
public builder with tokenizer ( class < ? extends tokenizer factory > factory , map < string , string > params ) throws io { objects . require non null ( factory , str ) ; tokenizer . set ( apply resource loader ( new factory class instance ( factory , apply default params ( params ) ) ) ) ; components added = bool ; return this ; }	uses the given tokenizer .
protected double compute azimuth label offset ( double radius , double max radius ) { return math . asin ( azimuth label offset * max radius / radius ) ; }	compute an angular offset to apply to a azimuth label.
protected void add resource ( list defaults , string bundle name ) { resource bundle bundle = resource bundle . get bundle ( bundle name ) ; for ( enumeration keys = bundle . get keys ( ) ; keys . has more elements ( ) ; ) { string key = ( string ) keys . next element ( ) ; defaults . add ( key ) ; defaults . add ( bundle . get object ( key ) ) ; } }	adds the all keys / values from the given named resource bundle to the defaults.
public void display changed ( ) { execute display changed on edt ( get graphics configuration ( ) ) ; }	from the displaychangedlistener interface ; called from x11graphicsdevice when the display mode has been changed .
private static stream < method > extract methods ( class clazz ) { try { method [ ] methods = clazz . get methods ( ) ; if ( methods . length > num ) { return stream . of ( methods ) ; } } catch ( exception | error e ) { log . warn ( str , clazz , e ) ; } return stream . empty ( ) ; }	extract a set of methods from a given class .
@ override public void update server address ( application application , string docker manager ip , string server port , string server manager port ) { string suffix cloud unit = application . get suffix cloud unit io ( ) ; jedis pool pool = null ; jedis jedis = null ; try { pool = new jedis pool ( new jedis pool config ( ) , redis ip , integer . parse int ( redis port ) , num ) ; jedis = pool . get resource ( ) ; string sub name space = concat sub name space ( application ) ; string key = sub name space + suffix cloud unit ; string frontend = str + key . to lower case ( ) ; jedis . lset ( frontend , num , str + docker manager ip + str + server port ) ; string frontend server manager = str + key . to lower case ( ) ; jedis . lset ( frontend server manager , num , str + docker manager ip + str + server manager port ) ; } catch ( jedis connection exception | unsupported encoding exception e ) { logger . error ( str , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }	update the server address.
protected void remove ( int item position ) { if ( item position >= num && item position < get item count ( ) ) { list . remove ( item position ) ; } }	remove an item from the adapter ' s list .
protected string choose random enemys ( ) { final list < string > enemy list = new linked list < string > ( enemy forces . key set ( ) ) ; final int enemy size = enemy list . size ( ) ; final int position = rand . rand ( enemy size ) ; return enemy list . get ( position ) ; }	function for choosing random enemy from map.
public boolean is route to dest valid ( block protecting , block destination ) { if ( protecting == destination ) { log . debug ( str ) ; if ( get adjacency ( protecting ) != null ) { return bool ; } } else if ( get valid route ( protecting , destination ) != null ) { return bool ; } return bool ; }	is the route to the destination block , going via our neighbouring block valid.
public void sort pools ( list < storage pool > storage pools ) { port metrics processor . compute storage pools avg port metrics ( storage pools ) ; collections . sort ( storage pools , storage pool comparator ) ; }	sort list of storage pools based on its storage system ' s average usage port metrics usage . its secondary sorting components are free and subscribed capacity.
public rhythm group add overlays ( collection < rhythm overlay > overlays ) { m overlays . add all ( overlays ) ; if ( m current overlay index == no overlay ) { select overlay ( num ) ; } return this ; }	add multiple rhythm overlays to this group.
public static resource for path ( final string path ) throws unknown resource exception { resource resource ; if ( path . starts with ( classpath resource . prefix + str ) ) { resource = new classpath resource ( path ) ; } else if ( path . starts with ( file resource . prefix + str ) ) { resource = new file resource ( path ) ; } else { resource = for path ( file resource . prefix + str + path ) ; } return resource ; }	creates an instance for a path prefixed by either classpath : or file : .
private static boolean is older than leopard ( ) { string version = system . get property ( str ) ; string tokenizer tk = new string tokenizer ( version , str ) ; int major = integer . parse int ( tk . next token ( ) ) ; int minor = integer . parse int ( tk . next token ( ) ) ; return major == num && minor < num ; }	determines if this is running a mac osx lower than leopard.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static string xml content escape ( string s ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : break ; default : sb . append ( c ) ; } } return sb . to string ( ) ; }	escape a string for use inside as xml element content.
private void feed forward ( vec input , list < vec > activations , list < vec > derivatives ) { vec x = input ; for ( int i = num ; i < ws . size ( ) ; i ++ ) { matrix w i = ws . get ( i ) ; vec b i = bs . get ( i ) ; vec a i = activations . get ( i ) ; a i . zero out ( ) ; w i . multiply ( x , num , a i ) ; a i . mutable add ( b i ) ; a i . apply function ( f ) ; vec d i = derivatives . get ( i ) ; a i . copy to ( d i ) ; d i . apply function ( f . get d ( ) ) ; x = a i ; } }	feeds a vector through the network to get an output.
private file find file ( file directory , string name ) throws file not found exception { file file = new file ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for ( string child : directory . list ( ) ) { if ( child . equals ignore case ( name ) ) { return new file ( directory , child ) ; } } throw new file not found exception ( str + file ) ; }	finds the named file in the named directory.
public static boolean compare results ( solr client control client , solr client cloud client ) throws solr server exception , io { return compare results ( control client , cloud client , null , null ) ; }	compares the results of the control and cloud clients .
public array list < string > get element list ( string x path expression ) { try { array list < string > values = new array list < string > ( ) ; list < ? > node list = x . select nodes ( this . xml document , x path expression ) ; iterator < ? > iter = node list . iterator ( ) ; while ( iter . has next ( ) ) { org . jdom . element element = ( org . jdom . element ) iter . next ( ) ; values . add ( element . get text ( ) ) ; } return values ; } catch ( exception ex ) { log . error ( str + ex . get message ( ) , ex ) ; return null ; } }	retrieves the text elements for a given xpath expression.
public static cl create context from current gl ( ) { runtime exception first = null ; for ( cl platform : list platforms ( ) ) { try { cl ctx = platform . create context from current gl ( ) ; if ( ctx != null ) return ctx ; } catch ( runtime exception ex ) { if ( first == null ) first = ex ; } } throw new runtime exception ( str , first ) ; }	creates an opencl context able to share entities with the current opengl context .
public void collapse tree ( ) { for ( int i = num ; i < tree . get row count ( ) ; ++ i ) { tree . collapse row ( i ) ; } }	collapse the tree so that only the root node is visible .
static void queue player cape replacement ( abstract client player player ) { final string display name = player . get display name string ( ) ; logger . info ( str , display name ) ; thread pool . submit ( null ) ; }	queue the replacement of a player ' s cape with the testmod3 cape.
public void remove vetoable change listener ( vetoable change listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable support != null ) { vetoable support . remove vetoable change listener ( listener ) ; } } } }	removes a vetoablechangelistener from the listener list.
public stream throughput ( string status message prefix ) { m instance count = num ; m sample count = num ; m num samples = num ; m cumulative time = num ; m start time = system . current time millis ( ) ; m status message prefix = status message prefix ; }	construct a new streamthroughput.
protected void parse command ( final string ... args ) { for ( string arg : args ) { final command command = command . value of name ( arg ) ; if ( command != null ) { set command ( command ) ; break ; } } }	iterates the list of arguments in search of the target locator launcher command .
@ request mapping ( value = str , method = request method . put ) public response entity < bookmark > edit bookmark ( @ path variable ( value = str ) string username , @ path variable ( value = str ) int bookmark id , @ request body string json ) throws io , bookmark not found exception , illegal access exception , invocation target exception { optional < bookmark > optional = bookmarks repository . find by id and user username ( bookmark id , username ) ; if ( optional . is present ( ) ) { object mapper mapper = new object mapper ( ) ; map < string , string > change map = mapper . read value ( json , hash map . class ) ; bookmark bookmark = optional . get ( ) ; bean utils . populate ( bookmark , change map ) ; bookmark = bookmarks repository . save ( bookmark ) ; return new response entity < > ( bookmark , http status . ok ) ; } else { throw new bookmark not found exception ( str + bookmark id ) ; } }	a method to edit a bookmark .
public static string convert from utf32 ( int [ ] text , int start pos , int end pos ) { string builder sb = new string builder ( ) ; for ( int i = start pos ; i < end pos ; i ++ ) { sb . append ( convert from utf32 to char array ( text [ i ] ) ) ; } return sb . to string ( ) ; }	/ converts a utf32 code point sequence to a string with the corresponding character ( s ) .
public void create bounds ( ) { if ( is empty ( ) || has single element ( ) ) { m bounds = null ; return ; } int l = integer . max value ; int t = integer . max value ; int r = num ; int b = num ; for ( selection . element selection : get elements ( ) ) { constraint widget w = selection . widget ; l = math . min ( w . get draw x ( ) , l ) ; t = math . min ( w . get draw y ( ) , t ) ; r = math . max ( w . get draw right ( ) , r ) ; b = math . max ( w . get draw bottom ( ) , b ) ; } constraint widget bounds = new constraint widget ( l , t , r - l , b - t ) ; bounds . set companion widget ( widget companion . create ( bounds ) ) ; m bounds = new element ( bounds ) ; update origin from bounds ( ) ; }	if the selection has more than one element , it will create a temporary element object as the bounds of the entire selection.
protected static void record pattern ( bit array row , int start , int [ ] counters ) throws not found exception { int num counters = counters . length ; arrays . fill ( counters , num , num counters , num ) ; int end = row . get size ( ) ; if ( start >= end ) { throw not found exception . get not found instance ( ) ; } boolean is white = ! row . get ( start ) ; int counter position = num ; int i = start ; while ( i < end ) { if ( row . get ( i ) ^ is white ) { counters [ counter position ] ++ ; } else { counter position ++ ; if ( counter position == num counters ) { break ; } else { counters [ counter position ] = num ; is white = ! is white ; } } i ++ ; } if ( ! ( counter position == num counters || ( counter position == num counters - num && i == end ) ) ) { throw not found exception . get not found instance ( ) ; } }	records the size of successive runs of white and black pixels in a row , starting at a given point.
public static object [ ] find method with list parameters ( object service , string method name , list < ? > args ) { object [ ] arguments = new object [ args . size ( ) ] ; for ( int i = num ; i < args . size ( ) ; i ++ ) { arguments [ i ] = args . get ( i ) ; } return find method with list parameters ( service , method name , arguments ) ; }	returns ( method , params ) for the given service or ( null , null ) if no method was found .
static int first illegal character ( string source ) { for ( int i = num ; i < source . length ( ) ; i ++ ) { if ( is legal ( source . char at ( i ) ) == bool ) { return i ; } } return - num ; }	utility method to find the first invalid character as per rfc 2396 section 2.
private coder result decode byte buffer to character buffer ( boolean end of input ) throws decoding exception { buffer . flip ( ) ; return decode more bytes to character buffer ( end of input ) ; }	decodes contents of the byte buffer to the character buffer.
protected void new fast clock minute ( ) { for ( int i = delayed trains . size ( ) - num ; i >= num ; i -- ) { active train at = delayed trains . get ( i ) ; if ( ( ! at . get started ( ) ) && at . get delayed start ( ) != active train . nodelay ) { if ( at . get delayed start ( ) == active train . timeddelay ) { if ( is fast clock time ge ( at . get departure time hr ( ) , at . get departure time min ( ) ) ) { at . set started ( ) ; delayed trains . remove ( i ) ; if ( auto allocate ) { auto allocate . scan allocation request list ( allocation requests ) ; } } } } else if ( at . get started ( ) && at . get status ( ) == active train . ready && at . reached restart point ( ) ) { if ( is fast clock time ge ( at . get restart depart hr ( ) , at . get restart depart min ( ) ) ) { at . restart ( ) ; delayed trains . remove ( i ) ; if ( auto allocate ) { auto allocate . scan allocation request list ( allocation requests ) ; } } } } }	handle activity that is triggered by the fast clock.
public void add ( final creature respawn point point ) { respawn points . add ( point ) ; }	add a creature respawn point to the zone .
private void load org access role ( array list < org access > list ) { prepared statement pstmt = null ; result set rs = null ; string sql = str + str ; try { pstmt = db . prepare statement ( sql , get ( ) ) ; pstmt . set int ( num , get ad id ( ) ) ; rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { m oa = new m ( get ctx ( ) , rs , get ( ) ) ; load org access add ( list , new org access ( oa . get ad id ( ) , oa . get ad id ( ) , oa . is read only ( ) ) ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } finally { db . close ( rs , pstmt ) ; } }	load org access role.
public void test bytes as source ( ) throws exception { string json = str ; byte [ ] b = json . get bytes ( str ) ; int offset = num ; int len = b . length ; byte [ ] src = new byte [ offset + len + offset ] ; system . arraycopy ( b , num , src , offset , len ) ; json factory jf = new json factory ( ) ; json parser jp = jf . create json parser ( src , offset , len ) ; assert token ( json token . start array , jp . next token ( ) ) ; assert token ( json token . value number int , jp . next token ( ) ) ; assert equals ( num , jp . get int value ( ) ) ; assert token ( json token . value number int , jp . next token ( ) ) ; assert equals ( num , jp . get int value ( ) ) ; assert token ( json token . value number int , jp . next token ( ) ) ; assert equals ( num , jp . get int value ( ) ) ; assert token ( json token . value number int , jp . next token ( ) ) ; assert equals ( num , jp . get int value ( ) ) ; assert token ( json token . end array , jp . next token ( ) ) ; assert null ( jp . next token ( ) ) ; jp . close ( ) ; }	simple unit test that verifies that passing in a byte array as source works as expected .
public java . security . cert . certificate engine generate certificate ( input stream in ) throws certificate exception { if ( current stream == null ) { current stream = in ; s data = null ; s data object count = num ; } else if ( current stream != in ) { current stream = in ; s data = null ; s data object count = num ; } try { if ( s data != null ) { if ( s data object count != s data . size ( ) ) { return get certificate ( ) ; } else { s data = null ; s data object count = num ; return null ; } } pushback input stream pis = new pushback input stream ( in ) ; int tag = pis . read ( ) ; if ( tag == - num ) { return null ; } pis . unread ( tag ) ; if ( tag != num ) { return read pem ( pis ) ; } else { return read der ( new as ( pis ) ) ; } } catch ( exception e ) { throw new ex certificate exception ( e ) ; } }	generates a certificate object and initializes it with the data read from the input stream instream .
public string to string ( object value ) { return to pretty string ( value ) ; }	returns pretty string representation of the object .
@ override public list < period > generate rolling periods ( date time unit date time unit ) { calendar cal = get calendar ( ) ; date time unit . set day ( num ) ; date time unit = cal . minus months ( date time unit , num ) ; list < period > periods = lists . new array list ( ) ; for ( int i = num ; i < num ; i ++ ) { periods . add ( create period ( date time unit , cal ) ) ; date time unit = cal . plus months ( date time unit , num ) ; } return periods ; }	generates the last 12 months where the last one is the month which the given date is inside .
@ suppress warnings ( str ) public synchronized t find counter ( enum < ? > counter key ) throws illegal access exception , instantiation exception { t counter = cache . get ( counter key ) ; if ( counter == null ) { counter = counter type . new instance ( ) ; cache . put ( counter key , counter ) ; } return counter ; }	returns the counter associated with the key.
public static uri add message to uri ( content resolver resolver , uri uri , string address , string body , string subject , long date , boolean read , boolean delivery report , long thread id ) { content values values = new content values ( num ) ; values . put ( sms . address , address ) ; if ( date != null ) { values . put ( sms . date , date ) ; } values . put ( sms . read , read ? integer . value of ( num ) : integer . value of ( num ) ) ; values . put ( sms . subject , subject ) ; values . put ( sms . body , body ) ; if ( delivery report ) { values . put ( sms . status , sms . status pending ) ; } if ( thread id != - num ) { values . put ( sms . thread id , thread id ) ; } return resolver . insert ( uri , values ) ; }	add an sms to the given uri with the specified thread id .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; }	runs the test case .
protected void engine set mode ( string mode ) { if ( ! mode . equals ignore case ( str ) ) { throw new illegal argument exception ( str + mode ) ; } }	should never be called .
@ suppress warnings ( str ) private void expunge stale entries ( ) { synchronized ( sync ) { list weak reference r ; while ( ( r = ( list weak reference ) queue . poll ( ) ) != null ) { list entry le = r . get list entry ( ) ; int i = list . index of ( le ) ; if ( i != - num ) { list . remove ( i ) ; } } } }	expunge stale entries from the list .
protected void work ( final i resource , final list < work item > resources , i monitor ) { i store = findbugs plugin . get plugin preferences ( get project ( ) ) ; boolean run as job = store . get boolean ( find bugs constants . key run analysis as extra job ) ; find bugs job fb job = new started from builder job ( str + resource . get name ( ) + str , resource , resources ) ; if ( run as job ) { if ( debug ) { findbugs plugin . log ( str ) ; } find bugs job . cancel similar jobs ( fb job ) ; if ( debug ) { findbugs plugin . log ( str ) ; } fb job . schedule as system ( ) ; if ( debug ) { findbugs plugin . log ( str ) ; } } else { if ( debug ) { findbugs plugin . log ( str ) ; } fb job . run ( monitor ) ; if ( debug ) { findbugs plugin . log ( str ) ; } } }	run a findbugs analysis on the given resource as build job but not delaying the current java build.
public void fire vetoable change ( string name , object old value , object new value ) throws property veto exception { super . fire vetoable change ( name , old value , new value ) ; bean context child support . fire vetoable change ( name , old value , new value ) ; }	report a vetoable property update to any registered listeners.
@ override public void on full backup ( full backup data output output ) throws io { if ( m volumes != null ) { if ( debug ) slog . i ( tag , str + m volumes . length + str ) ; hash set < string > external files dir filter = new hash set < string > ( ) ; final file external android root = new file ( environment . get external storage directory ( ) , environment . directory android ) ; external files dir filter . add ( external android root . get canonical path ( ) ) ; for ( int i = num ; i < m volumes . length ; i ++ ) { storage volume v = m volumes [ i ] ; string domain = full backup . shared prefix + i ; full backup file tree ( null , domain , v . get path ( ) , external files dir filter , output ) ; } } }	full backup of the shared - storage filesystem.
public static void remove connection list ( integer tab ) { tabbed connections . remove ( tab . int value ( ) ) ; }	remove the list of connections at the supplied index.
protected void paint range rings ( d origin pnt , d dest , graphics graphics , map bean the map ) { geo origin geo = new geo ( origin pnt . get y ( ) , origin pnt . get x ( ) , bool ) ; geo dest geo = new geo ( dest . get y ( ) , dest . get x ( ) , bool ) ; double distance = origin geo . distance ( dest geo ) ; for ( int i = num ; i <= math . max ( num , num rings ) ; i ++ ) { double ring dist = distance * ( double ) i ; paint circle ( origin geo , ring dist , graphics , the map ) ; paint label ( origin geo , ring dist , graphics , the map ) ; } }	paints the circles and their labels on the given graphics .
public static string separators to windows ( string path ) { if ( path == null || path . index of ( unix separator ) == - num ) { return path ; } return path . replace ( unix separator , windows separator ) ; }	converts all separators to the windows separator of backslash .
public void translate and append pending ( int backoff ) throws unsupported encoding exception { int buffer end = current - backoff ; int len = buffer end - complete ; output . append ( new string ( input , offset + complete , len , charset ) ) ; complete = buffer end ; }	translate pending bytes using selected character set.
@ override public trie optimize ( trie orig ) { list < char sequence > cmds = orig . cmds ; list < row > rows = new array list < > ( ) ; list < row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - num ; j >= num ; j -- ) { lift up ( orows . get ( j ) , orows ) ; } arrays . fill ( remap , - num ) ; rows = remove gaps ( orig . root , orows , new array list < row > ( ) , remap ) ; return new trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }	optimize ( eliminate rows with no content ) the given trie and return the reduced trie .
private handler < void > install after handler ( final http server request request , final buffer buffer , final list < listener > after listener ) { handler < void > after handler = null ; return after handler ; }	this handler is called after the self request ( original request ) is performed successfully.
private void try shutdown ( ) { if ( is closing ( ) && is ok to close ( ) ) shutdown ( close future . get ( ) ) ; }	close was signaled in closeasync ( ) but there were pending messages at that time.
public storage entity create storage entity ( string storage name , storage platform entity storage platform entity , list < attribute > attributes ) { storage entity storage entity = new storage entity ( ) ; storage entity . set name ( storage name ) ; storage entity . set storage platform ( storage platform entity ) ; if ( ! collection utils . is empty ( attributes ) ) { list < storage attribute entity > attribute entities = new array list < > ( ) ; storage entity . set attributes ( attribute entities ) ; for ( attribute attribute : attributes ) { storage attribute entity attribute entity = new storage attribute entity ( ) ; attribute entities . add ( attribute entity ) ; attribute entity . set storage ( storage entity ) ; attribute entity . set name ( attribute . get name ( ) ) ; attribute entity . set value ( attribute . get value ( ) ) ; } } return storage dao . save and refresh ( storage entity ) ; }	creates and persists a new storage entity .
public void display info line ( string info line , int label designator ) { if ( info line holder != null ) { set label ( ( info line != null && info line . length ( ) > num ) ? info line : fudge string , label designator ) ; } }	display a line of text in a designated info line .
public console format ( string format , object ... args ) { formatter f = new formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }	writes a formatted string to the console using the specified format string and arguments .
public void test signer string identity scope ( ) throws exception { signer s = new signer stub ( str , identity scope . get system scope ( ) ) ; assert not null ( s ) ; assert equals ( str , s . get name ( ) ) ; assert same ( identity scope . get system scope ( ) , s . get scope ( ) ) ; assert null ( s . get private key ( ) ) ; try { signer s2 = new signer stub ( str , identity scope . get system scope ( ) ) ; fail ( str ) ; } catch ( key management exception e ) { } signer s2 = new signer stub ( null ) ; assert null ( s2 . get name ( ) ) ; }	verify signer ( string , identityscope ) creates instance.
public static object invoke static method ( bsh class manager bcm , class clas , string method name , object [ ] args ) throws reflect error , util eval error , invocation target exception { interpreter . debug ( str ) ; method method = resolve expected java method ( bcm , clas , null , method name , args , bool ) ; return invoke method ( method , null , args ) ; }	invoke a method known to be static.
protected np ( string pattern , boolean case sensitive , double confidence ) { this ( pattern . compile ( pattern , case sensitive ? num : pattern . case insensitive ) , num , confidence ) ; }	new instance , based on the supplied pattern.
private static void remove loop safepoint ( structured graph graph ) { loop begin node loop begin = find first loop ( graph ) ; loop begin . disable safepoint ( ) ; }	remove the safepoint from the first loop in the test method , so only the safepoints on monitorenter and monitorexit remain in the loop.
protected abstract void bind item ( data bound view holder < t > holder , int position , list < object > payloads ) ;	override this method to handle binding your items into views.
public void test case7 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add two positive numbers of different length.
public synchronized void add ( double min value , double max value ) { super . add ( min value ) ; m max values . add ( max value ) ; }	adds new values to the series.
public static date days before ( date date inst , int num days ) { if ( ( num days <= num ) || ( date inst == null ) ) { throw new illegal argument exception ( ) ; } final calendar cal = new gregorian calendar ( ) ; cal . set time ( date inst ) ; cal . add ( calendar . day of year , - num days ) ; return cal . get time ( ) ; }	method to return a date instance which is exactly numdays days before the point in time designated by the input date .
public final int remaining capacity ( ) { return math . max ( num , capacity - cache . size ( ) ) ; }	gets the number of entries that can be added to this cache without the need for removing stale entries .
@ override public void write external ( object output out ) throws io { super . write external ( out ) ; out . write object ( conservative approximation ) ; }	calls the super method and writes the conservative approximation of the knn distances of this entry to the specified stream .
int put data ( object data ) throws fits exception { long lsize = array funcs . compute l ( data ) ; if ( lsize > integer . max value ) { throw new fits exception ( str ) ; } int size = ( int ) lsize ; expand heap ( size ) ; byte array output stream bo = new byte array output stream ( size ) ; try { buffered data output stream o = new buffered data output stream ( bo ) ; o . write array ( data ) ; o . flush ( ) ; o . close ( ) ; } catch ( io e ) { throw new fits exception ( str , e ) ; } system . arraycopy ( bo . to byte array ( ) , num , this . heap , this . heap size , size ) ; int old offset = this . heap size ; this . heap size += size ; return old offset ; }	add some data to the heap .
public void paint ( graphics g ) { try { super . paint ( g ) ; } catch ( exception e ) { } int focused row = get focused row ( bool ) ; if ( focused row != - num && focused row < get row count ( ) ) { border row border = ui . get border ( str ) ; if ( row border != null ) { rectangle rect = get cell rect ( focused row , num , bool ) ; rect . width = get width ( ) ; row border . paint border ( this , g , rect . x , rect . y , rect . width , rect . height ) ; } } }	paints the table & a focused row border .
private void add ( final j label , final j field ) { panel . add ( label ) ; panel . add ( field ) ; if ( previous == null ) { layout . put constraint ( spring layout . north , panel , - spacing , spring layout . north , label ) ; } else { layout . put constraint ( spring layout . north , label , spacing , spring layout . south , previous ) ; } layout . put constraint ( spring layout . west , panel , - spacing , spring layout . west , label ) ; layout . put constraint ( spring layout . south , panel , spacing , spring layout . south , label ) ; layout . put constraint ( spring layout . east , field , - spacing , spring layout . east , panel ) ; layout . put constraint ( spring layout . west , field , - ( text field width + spacing ) , spring layout . east , panel ) ; layout . put constraint ( spring layout . south , field , spacing , spring layout . south , label ) ; previous = label ; }	adds a label and a field combination .
private void on track point start ( attributes attributes ) { latitude = attributes . get value ( attribute lat ) ; longitude = attributes . get value ( attribute lon ) ; altitude = null ; time = null ; }	on track point start .
public static byte [ ] combine ( final list < byte [ ] > data chunks ) { int total size = num ; for ( final byte [ ] data part : data chunks ) { total size += data part . length ; } final byte [ ] data = new byte [ total size ] ; int index = num ; for ( final byte [ ] data part : data chunks ) { system . arraycopy ( data part , num , data , index , data part . length ) ; index += data part . length ; } return data ; }	combines a list of byte arrays into one big byte array .
public void commit ( i [ ] resources , string comment , boolean keep locks , i monitor ) throws team exception { if ( monitor == null ) { monitor = new null progress monitor ( ) ; } map table = get provider mapping ( resources ) ; set key set = table . key set ( ) ; monitor . begin task ( str , key set . size ( ) * num ) ; monitor . set task name ( policy . bind ( str ) ) ; iterator iterator = key set . iterator ( ) ; while ( iterator . has next ( ) ) { i sub monitor = new sub progress monitor ( monitor , num ) ; svn provider = ( svn ) iterator . next ( ) ; list list = ( list ) table . get ( provider ) ; i [ ] provider resources = ( i [ ] ) list . to array ( new i [ list . size ( ) ] ) ; provider . checkin ( provider resources , comment , keep locks , i . depth infinite , sub monitor ) ; } }	commit the given resources to their associated providers .
public boolean can spawn workers ( ) { boolean can spawn worker = bool ; if ( verbose log level > num ) { utilities . verbose log ( str + grid name + str + tier + str + max tier depth + str + life remaining ( ) + str + maximum life millis ) ; } if ( ! grid name . equals ( str ) ) { return bool ; } if ( cluster state != null ) { long time since cluster last updated cluster state = system . current time millis ( ) - cluster state . get last updated ( ) ; utilities . verbose log ( str + time since cluster last updated cluster state ) ; if ( time since cluster last updated cluster state > num * grid check interval * num ) { utilities . verbose log ( str + cluster state . to string ( ) ) ; return bool ; } } else { return bool ; } if ( tier == max tier depth ) { return bool ; } if ( life remaining ( ) < ( maximum life millis * num ) ) { return bool ; } switch ( tier ) { case num : can spawn worker = bool ; break ; case num : can spawn worker = bool ; break ; case num : can spawn worker = bool ; break ; case num : can spawn worker = bool ; break ; default : if ( grid throttle ) { can spawn worker = bool ; } else { can spawn worker = bool ; } } return can spawn worker ; }	check if this worker can spawn any worker.
public boolean equals ( object object ) { if ( object == null || ! ( object instanceof id ) ) { return bool ; } id another = ( id ) object ; return encrypted string . equals ( another . encrypted string ) ; }	compares this session id to the specified object.
public static boolean are identical ( string player ident , offline player compare to ) { return player ident . equals ( get identification for as string ( compare to ) ) ; }	returns whether a given ident matches that of another offline player.
builder add lenient ( string name , string value ) { names and values . add ( name ) ; names and values . add ( value . trim ( ) ) ; return this ; }	add a field with the specified value without any validation.
protected string string without header ( ) { string buffer text = new string buffer ( ) ; for ( int i = num ; i < num instances ( ) ; i ++ ) { text . append ( instance ( i ) ) ; if ( i < num instances ( ) - num ) { text . append ( str ) ; } } return text . to string ( ) ; }	returns the instances in the dataset as a string in arff format.
protected boolean is always non null ( value v ) { return bool ; }	this can be overwritten by sublasses to mark a certain value as constantly non - null .
public final < t > void remove internal ( list < t > list , int position ) { if ( has header view ( ) && position == num ) return ; if ( enable load more ( ) && position == get item count ( ) - num ) return ; if ( list . size ( ) > num ) { synchronized ( m lock ) { list . remove ( has header view ( ) ? position - num : position ) ; } remove notify external ( position ) ; notify item removed ( position ) ; } }	remove a item of the list of the adapter.
public am ( string name ) { super ( name ) ; }	creates an instance of base view bean object .
public boolean consumed gesture ( ) { return reacted ; }	returns true if the gesture was consumed by the server .
private void initialize layer ( list < neuron > layer , neuron update rule node type , int nodes ) { for ( int i = num ; i < nodes ; i ++ ) { neuron node = new neuron ( get parent network ( ) , node type ) ; layer . add ( node ) ; } }	helper method to initialize a layer by adding the desired number of neurons with the desired neuron update rule .
public static double angle ( coordinate p ) { return math . atan2 ( p . y , p . x ) ; }	returns the angle that the vector from ( 0 , 0 ) to p , relative to the positive x - axis.
public void fire neuron moved ( final neuron moved ) { for ( neuron listener listener : neuron listeners ) { listener . neuron moved ( new network event < neuron > ( this , moved ) ) ; } }	fire a network changed event to all registered model listeners .
public static x509 certificate create certificate from bytes ( byte [ ] cert bytes ) { x509 certificate cert = null ; certificate factory cert factory ; try { cert factory = certificate factory . get instance ( str ) ; input stream in = new byte array input stream ( cert bytes ) ; cert = ( x509 certificate ) cert factory . generate certificate ( in ) ; } catch ( certificate exception e ) { logger . warn ( str + str , e ) ; } return cert ; }	creates an x509 certificate for a given byte array.
void handle selection changed ( string selection ) { if ( m did expand selection ) { m did expand selection = bool ; return ; } if ( selection == null || selection . is empty ( ) ) { schedule invalid tap notification ( ) ; if ( m selection type == selection type . tap ) { reset selection states ( ) ; return ; } } if ( selection != null && ! selection . is empty ( ) ) { unschedule invalid tap notification ( ) ; } m selected text = selection ; if ( m was tap gesture detected ) { m selection type = selection type . tap ; handle selection ( selection , m selection type ) ; m was tap gesture detected = bool ; } else { m handler . handle selection modification ( selection , m x , m y ) ; } }	handles a change in the current selection .
public terms ack parser parse ( ) throws parser configuration exception , sax , parse failure exception { try { sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; parser . parse ( m input source , this ) ; return this ; } catch ( io e ) { throw new parse failure exception ( str , e ) ; } }	parse the terms ack information.
public static string format ( final string value , string ... params ) { validate ( value , null string predicate , null string msg supplier ) ; pattern p = pattern . compile ( str ) ; matcher m = p . matcher ( value ) ; string result = value ; while ( m . find ( ) ) { int param number = integer . parse int ( m . group ( num ) ) ; if ( params == null || param number >= params . length ) { throw new illegal argument exception ( str + m . group ( ) ) ; } result = result . replace ( m . group ( ) , params [ param number ] ) ; } return result ; }	formats a string using parameters.
public builder server ( string server ) { if ( server . ends with ( str ) == bool ) { server = server + str ; } this . server = server ; return this ; }	set the server url to be used by parse.
private response packet execute count ( query template packet template , ij space , transaction txn ) throws sql { try { template . set routing ( get routing ( ) ) ; template . set explain plan ( get explain plan ( ) ) ; int count = space . count ( template , txn , get read modifier ( ) ) ; response packet response = new response packet ( ) ; object [ ] [ ] values = new object [ num ] [ num ] ; values [ num ] [ num ] = count ; result entry result = new result entry ( new string [ ] { get count column name ( ) } , new string [ ] { get count column label ( ) } , new string [ ] { str } , values ) ; response . set result entry ( result ) ; return response ; } catch ( exception e ) { if ( logger . is loggable ( level . severe ) ) { logger . log ( level . severe , e . get message ( ) , e ) ; } throw new sql ( str + e , str , - num ) ; } }	handle read query - check if it is a read query or a readmultiple and execute it.
void derive confidence value ( double base count ) { if ( utils . is missing value ( m confidence ) && ! utils . is missing value ( base count ) && base count > num ) { m confidence = m record count / base count ; } }	backfit confidence value ( does nothing if the confidence value is already set ) .
public modifiable solr params add ( string name , string ... val ) { string [ ] old = vals . put ( name , val ) ; if ( old != null ) { if ( val == null || val . length < num ) { string [ ] both = new string [ old . length + num ] ; system . arraycopy ( old , num , both , num , old . length ) ; both [ old . length ] = null ; vals . put ( name , both ) ; } else { string [ ] both = new string [ old . length + val . length ] ; system . arraycopy ( old , num , both , num , old . length ) ; system . arraycopy ( val , num , both , old . length , val . length ) ; vals . put ( name , both ) ; } } return this ; }	add the given values to any existing name.
public byte array data source ( input stream is , string type ) { try { byte array output stream os = new byte array output stream ( ) ; int ch ; while ( ( ch = is . read ( ) ) != - num ) { os . write ( ch ) ; } m data = os . to byte array ( ) ; } catch ( io ioex ) { log . log ( level . warning , str , ioex ) ; } if ( type != null && type . length ( ) > num ) m type = type ; }	create a datasource from an input stream.
object to type ( string value , string pattern , locale locale ) { calendar calendar = to calendar ( value , pattern , locale ) ; return to type ( calendar ) ; }	parse a string value to the required type.
public void add limit line ( limit line l ) { m limit lines . add ( l ) ; if ( m limit lines . size ( ) > num ) { log . e ( str , str ) ; } }	adds a new limitline to this axis .
public void read data ( data input din ) throws io { function = din . read unsigned short ( ) ; data = ( short ) ( din . read short ( ) & num ) ; }	readdata - - read the function code and data value.
int read results ( final byte [ ] b , final int b pos , final int b avail , final context context ) { if ( context . buffer != null ) { final int len = math . min ( available ( context ) , b avail ) ; system . arraycopy ( context . buffer , context . read pos , b , b pos , len ) ; context . read pos += len ; if ( context . read pos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? eof : num ; }	extracts buffered data into the provided byte [ ] array , starting at position bpos , up to a maximum of bavail bytes.
public static int inflate ( byte [ ] previous , int previous length , byte [ ] current , int current length , byte [ ] result ) { if ( previous == null ) { system . arraycopy ( current , num , result , num , current length ) ; return current length ; } int length = num ; int start1 = num ; int start2 = num ; while ( start1 < previous length && start2 < current length ) { int end1 = start1 ; while ( end1 < previous length && previous [ end1 ] != str ) { end1 ++ ; } int end2 = start2 ; while ( end2 < current length && current [ end2 ] != str ) { end2 ++ ; } if ( current [ start2 ] == str && end2 == start2 + num ) { for ( int i = start1 ; i < end1 ; i ++ ) result [ length ++ ] = previous [ i ] ; } else { for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; } if ( end2 < current length ) result [ length ++ ] = str ; start1 = end1 + num ; start2 = end2 + num ; } return length ; }	inflate the current sam line by replacing all & by the corresponding field in the previous sam line.
public object [ ] to array ( ) { final object [ ] items = this . items ; final reentrant lock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; object [ ] a = new object [ count ] ; int n = items . length - take index ; if ( count <= n ) { system . arraycopy ( items , take index , a , num , count ) ; } else { system . arraycopy ( items , take index , a , num , n ) ; system . arraycopy ( items , num , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this queue , in proper sequence.
private void legends ( list < string > legends list , list < integer > color code list ) { text paint . set color ( color . black ) ; text paint . set text size ( num ) ; int left = ( int ) ( graphwidth * num ) ; for ( int i = num ; i < legends list . size ( ) ; i ++ ) { string label = legends list . get ( i ) ; float text width = text paint . measure text ( label , num , label . length ( ) ) ; int color = color code list . get ( i ) ; if ( ! ( ( graphwidth - legend left ) > ( text width + num ) ) ) { legend top -= num ; legend left = left ; } add legends ( canvas , color , legend top , legend left , legend right , legend bottom , label ) ; legend left += ( ( int ) text width + num ) ; } }	this function calculates the position for each legend.
private void fetch metadata ( table map log event table event ) throws sql , replicator exception { if ( metadata cache == null ) metadata cache = new table metadata cache ( num ) ; table table = metadata cache . retrieve ( table event . get database name ( ) , table event . get table name ( ) ) ; if ( table == null || table . get table id ( ) != table event . get table id ( ) ) { prepare metadata connection ( ) ; table = metadata connection . find table ( table event . get database name ( ) , table event . get table name ( ) , bool ) ; if ( table != null ) { table . set table id ( table event . get table id ( ) ) ; metadata cache . store ( table ) ; } } else if ( logger . is debug enabled ( ) ) logger . debug ( str + table event . get database name ( ) + str + table event . get table name ( ) + str ) ; if ( table == null ) { logger . warn ( str + table event . get database name ( ) + str + table event . get table name ( ) ) ; } else { table event . set table ( table ) ; } }	fetches metadata for the table from the cache or from the database if needed.
public string encode ( ) { string buffer sb = new string buffer ( ) ; encode ( sb ) ; return sb . to string ( ) ; }	returns the encoded string representing the object type signature .
@ override public int read ( byte [ ] buf , int offset , int len ) throws io { int available = available ; if ( available > num ) { len = math . min ( len , available ) ; len = next . read ( buf , offset , len ) ; if ( len > num ) { available -= len ; } } else if ( available == num ) { available = read chunk length ( ) ; if ( available > num ) { len = math . min ( len , available ) ; len = next . read ( buf , offset , len ) ; if ( len > num ) available -= len ; } else { available = - num ; len = - num ; } } else { len = - num ; } return len ; }	reads more data from the input stream .
@ override public void flush ( ) { flush task task ; synchronized ( log records ) { task = new flush task ( new array list < string > ( log records ) ) ; log records . clear ( ) ; } task . run ( ) ; }	flushes the buffered logrecords .
public static array list < page > page creator buttons ( array list < page > pages , item manual type ) { array list < page > new pages = new array list < > ( ) ; int page amount = pages . size ( ) ; int times = num ; while ( page amount > num ) { array list < page > pages temp = new array list < > ( ) ; pages temp . add all ( pages . sub list ( num * times , ( page amount > num ? num + num * times : num * times + page amount ) ) ) ; int height = num ; array list < manual widget base > widgets = new array list < > ( ) ; for ( page page : pages temp ) { widgets . add ( new button widget ( num , num + height , page ) ) ; height += num ; } new pages . add ( new page ( str + times , ( array list < manual widget base > ) widgets . clone ( ) , bool , manual type ) ) ; widgets . clear ( ) ; pages temp . clear ( ) ; page amount -= num ; times ++ ; } return new pages ; }	creates the button pages for a category.
public void test pos pos first longer ( ) { byte a bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , - num , - num , num , num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	and for two positive numbers ; the first is longer.
protected list < string > create new export mask workflow for initiators ( list < uri > initiator ur , export group export group , workflow workflow , map < uri , integer > volume map , storage system storage , string token , string previous step ) throws exception { list < string > new steps = new array list < > ( ) ; if ( ! initiator ur . is empty ( ) ) { map < string , list < uri > > compute resource to initiators = map initiators to compute resource ( export group , initiator ur ) ; for ( map . entry < string , list < uri > > resource entry : compute resource to initiators . entry set ( ) ) { string compute key = resource entry . get key ( ) ; list < uri > compute initiator ur = resource entry . get value ( ) ; log . info ( string . format ( str , compute key ) ) ; gen export mask create workflow result result = generate device specific export mask create work flow ( workflow , previous step , storage , export group , compute initiator ur , volume map , token ) ; previous step = result . get step id ( ) ; new steps . add ( previous step ) ; } } if ( new steps . is empty ( ) && previous step != null ) { new steps . add ( previous step ) ; } return new steps ; }	creates a new exportmask for host for the given initiators .
public boolean is less then ( percent percent ) { assert defined ( ) ; big decimal this value = not null ( this ) ; big decimal parameter = not null ( percent ) ; return ( this value . compare to ( parameter ) < num ) ; }	compares two percent objects .
@ override public uri to edge uri ( final object key ) { return to uri ( key . to string ( ) ) ; }	override to allow for colons in the id without urlencoding them .
short read short ( ) throws io { m dex file . read fully ( tmp buf , num , num ) ; if ( is big endian ) { return ( short ) ( ( tmp buf [ num ] & num ) | ( ( tmp buf [ num ] & num ) << num ) ) ; } else { return ( short ) ( ( tmp buf [ num ] & num ) | ( ( tmp buf [ num ] & num ) << num ) ) ; } }	reads a signed 16 - bit integer , byte - swapping if necessary .
public static list < i > load projects ( final sql provider , final debugger template manager debugger manager ) throws couldnt load data exception { sql . check arguments ( provider , debugger manager ) ; final c connection = provider . get connection ( ) ; final list < i > projects = new array list < > ( ) ; if ( ! sql . has table ( connection , c . projects table ) ) { return projects ; } string query = str + str + c . address spaces table + str + c . projects table + str + str + c . projects table ; try ( result set result set = connection . execute query ( query , bool ) ) { while ( result set . next ( ) ) { final int project id = result set . get int ( str ) ; final string name = sql . read string ( result set , str ) ; final string description = sql . read string ( result set , str ) ; final int address space count = result set . get int ( str ) ; final timestamp creation date = result set . get timestamp ( str ) ; final timestamp modification date = result set . get timestamp ( str ) ; final list < debugger template > debuggers = sql . get assigned debuggers ( connection , project id , debugger manager ) ; projects . add ( new c ( project id , name , description == null ? str : description , creation date , modification date , address space count , debuggers , provider ) ) ; } } catch ( final sql e ) { throw new couldnt load data exception ( e ) ; } return new array list < i > ( projects ) ; }	loads the projects of a database .
public string syllabify ( string phone string ) { linked list < string > phone list = split into allophones ( phone string ) ; syllabify ( phone list ) ; string builder sb = new string builder ( ) ; for ( string p : phone list ) { if ( sb . length ( ) > num ) sb . append ( str ) ; sb . append ( p ) ; } return sb . to string ( ) ; }	syllabify a phonetic string , marking syllable boundaries with dash characters in the output.
@ override protected node remove from frontier ( ) { clean up frontier ( ) ; node result = frontier . remove ( ) ; update metrics ( frontier . size ( ) ) ; set explored ( result ) ; return result ; }	cleans up the head of the frontier , removes the first node of a non - explored state from the head of the frontier , adds it to the corresponding explored map , and returns the node .
public static boolean is file ( string path ) { file f = new file ( path ) ; return f . is file ( ) ; }	checks if the given path is a file.
public boolean equals ( object object ) { if ( ! ( object instanceof object instance ) ) { return bool ; } object instance val = ( object instance ) object ; if ( ! name . equals ( val . get object name ( ) ) ) return bool ; if ( class name == null ) return ( val . get class name ( ) == null ) ; return class name . equals ( val . get class name ( ) ) ; }	compares the current object instance with another object instance .
public zookeeper embedded ( int port ) { this . port = port ; this . log dir = new file ( system . get property ( str ) , str + port ) ; }	create zookeeper testing server .
public basic condition ( string variable , value value , relation relation ) { this . variable = template . create ( variable ) ; this . template value = template . create ( value . to string ( ) ) ; this . ground value = value ; this . relation = relation ; }	creates a new basic condition , given a variable label , an expected value , and a relation to hold between the variable and its value.
public static set < string > read stopwords path ( path path , boolean lowercase ) throws io { return read stopwords input stream ( files . new input stream ( path ) , lowercase ) ; }	read a file containing stopwords ( one per line ).
@ override public string to string ( ) { string builder s rep = new string builder ( ) ; s rep . append ( str ) ; s rep . append ( article id ) ; s rep . append ( str ) ; s rep . append ( revision counter ) ; s rep . append ( str ) ; s rep . append ( time stamp ) ; s rep . append ( str ) ; s rep . append ( revision id ) ; if ( revision text != null ) { s rep . append ( str ) ; s rep . append ( revision text . length ( ) ) ; } s rep . append ( str ) ; return s rep . to string ( ) ; }	returns the string representation of this object .
private void break barrier ( ) { generation . broken = bool ; count = parties ; trip . signal all ( ) ; }	sets current barrier generation as broken and wakes up everyone.
public list < entry > filter ( list < entry > points , double tolerance ) { if ( tolerance <= num ) return points ; keep = new boolean [ points . size ( ) ] ; switch ( m type ) { case douglas peucker : return reduce with douglas peuker ( points , tolerance ) ; case none : return points ; default : return points ; } }	filters according to type .
protected void send log event ( string component , string message , callback < object > callback ) { string syslog message = string . format ( locale . us , str , get sys log formatted date ( ) , utils . get application name ( context ) , component , message ) ; send data over udp ( syslog message , callback ) ; }	create properly formatted message to send over udp that acts like a syslog message syslog format : " & lt ; priority & gt ; timestamp orange_link blue_link : message " details : http : / / en.
public static < t extends throwable > t write stack traces ( t throwable , stream output out ) throws io { stack trace element [ ] stack trace = throwable . get stack trace ( ) ; out . write v ( stack trace . length ) ; for ( stack trace element element : stack trace ) { out . write string ( element . get class name ( ) ) ; out . write optional string ( element . get file name ( ) ) ; out . write string ( element . get method name ( ) ) ; out . write v ( element . get line number ( ) ) ; } throwable [ ] suppressed = throwable . get suppressed ( ) ; out . write v ( suppressed . length ) ; for ( throwable t : suppressed ) { out . write throwable ( t ) ; } return throwable ; }	serializes the given exceptions stacktrace elements as well as it ' s suppressed exceptions to the given output stream .
public distributed log multi stream writer build ( ) { preconditions . check argument ( ( null != streams && ! streams . is empty ( ) ) , str ) ; preconditions . check not null ( client , str ) ; preconditions . check not null ( codec , str ) ; preconditions . check argument ( first speculative timeout ms > num && first speculative timeout ms <= max speculative timeout ms && speculative backoff multiplier > num && max speculative timeout ms < request timeout ms , str ) ; return new distributed log multi stream writer ( streams , client , math . min ( buffer size , max logrecordset size ) , flush interval micros , request timeout ms , first speculative timeout ms , max speculative timeout ms , speculative backoff multiplier , codec , ticker , executor service ) ; }	build the multi stream writer .
public static string number to string ( number number ) throws json { if ( number == null ) { throw new json ( str ) ; } test validity ( number ) ; string string = number . to string ( ) ; if ( string . index of ( str ) > num && string . index of ( str ) < num && string . index of ( str ) < num ) { while ( string . ends with ( str ) ) { string = string . substring ( num , string . length ( ) - num ) ; } if ( string . ends with ( str ) ) { string = string . substring ( num , string . length ( ) - num ) ; } } return string ; }	produce a string from a number .
private image element ( int ad id ) { load attachment ( ad id ) ; }	create image from attachment.
public thread register values ( final thread registers values ) { m tid = values . get tid ( ) ; for ( final register value value : values . get registers ( ) ) { m values . add ( new register ( value ) ) ; } }	creates a new thread register values object .
public launcher discovery request builder configuration parameters ( map < string , string > configuration parameters ) { preconditions . not null ( configuration parameters , str ) ; configuration parameters . for each ( null ) ; return this ; }	add all of the supplied configuration parameters to the request .
public boolean is triggered ( ) { return checkbox . is selected ( ) ; }	see if this anti - ba pod should be triggered.
public void add all ( int index , int [ ] data ) { int data len = data . length ; if ( data len == num ) { return ; } int newcap = size + ( int ) ( data len * num ) + num ; ensure capacity ( newcap ) ; system . arraycopy ( array , index , array , index + data len , size - index ) ; system . arraycopy ( data , num , array , index , data len ) ; size += data len ; }	appends all of the elements in the specified array at the specified position in this list .
private static float calculate score ( final int [ ] play counts ) { if ( play counts == null ) { return num ; } float score = num ; for ( int i = num ; i < math . min ( play counts . length , num weeks ) ; i ++ ) { score += play counts [ i ] * get score multiplier for week ( i ) ; } return score ; }	calculates the score of the song given the play counts.
public void remove scanning callback ( one sheeld scanning callback scanning callback ) { if ( scanning callback != null && scanning callbacks . contains ( scanning callback ) ) scanning callbacks . remove ( scanning callback ) ; }	remove a scanning callback .
public void paint rect ( graphics g , j c , int x , int y , int w , int h ) { rectangle bounds = c . get bounds ( ) ; check ( bounds ) ; g . draw image ( m back image , x , y , x + w , h + y , x , y , x + w , y + h , c ) ; }	paint / copy background to component rectangle.
@ override public final void sample ( ) { value = acquire count . get ( ) - release count . get ( ) ; }	return the probe ' s next average .
private boolean is page break ( int row ) { for ( int i = num ; i < m page break . size ( ) ; i ++ ) { integer rr = ( integer ) m page break . get ( i ) ; if ( rr . int value ( ) + num == row ) return bool ; else if ( rr . int value ( ) > row ) return bool ; } return bool ; }	check for for pagebreak.
public executor service shutdown ( ) { pool . shutdown ( ) ; return pool ; }	shuts down the internal thread pool.
public static boolean is proposition symbol identifier part ( char ch ) { return character . is java identifier part ( ch ) ; }	determine if the given character is part of a proposition symbol .
public static void o ( zdiagmat d ) { o ( d , parameters . output field width , parameters . output frac places ) ; }	prints a zdiagmat in default format .
public int search ( string txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = num ; i <= n - m ; i += skip ) { skip = num ; for ( int j = m - num ; j >= num ; j -- ) { if ( pat . char at ( j ) != txt . char at ( i + j ) ) { skip = math . max ( num , j - right [ txt . char at ( i + j ) ] ) ; break ; } } if ( skip == num ) return i ; } return n ; }	returns the index of the first occurrence of the pattern string in the text string .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public string to chars ( int [ ] indices ) { string builder s = new string builder ( indices . length ) ; for ( int i = num ; i < indices . length ; i ++ ) s . append ( to char ( indices [ i ] ) ) ; return s . to string ( ) ; }	returns the characters corresponding to the argument indices .
public static final string trunc ( final string str , final int length ) { if ( str == null ) { return str ; } if ( str . length ( ) <= length ) { return str ; } return str . substring ( num , length ) ; }	truncate string to a given length .
public void clear transactions ( int from height ) { lock . lock ( ) ; try { if ( from height == num ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; transactions . clear ( ) ; } else { throw new unsupported operation exception ( ) ; } } finally { lock . unlock ( ) ; } }	deletes transactions which appeared above the given block height from the wallet , but does not touch the keys.
@ override public boolean load ( final player player , final list < string > args ) { groovy binding . set variable ( str , player ) ; if ( args != null ) { groovy binding . set variable ( str , args . to array ( new string [ args . size ( ) ] ) ) ; } else { groovy binding . set variable ( str , new string [ num ] ) ; } final groovy shell interp = new groovy shell ( groovy binding ) ; boolean ret = bool ; pre execute ( player , args ) ; try { final file f = new file ( groovy script ) ; interp . evaluate ( f ) ; } catch ( final exception e ) { logger . error ( str + groovy script , e ) ; set message ( e . get message ( ) ) ; ret = bool ; } catch ( final error e ) { logger . error ( str + groovy script , e ) ; set message ( e . get message ( ) ) ; ret = bool ; } post execute ( player , args , ret ) ; return ( ret ) ; }	initial load of this script .
private void clean dirty region ( float event x , float event y ) { dirty rect . left = math . min ( last touch x , event x ) ; dirty rect . right = math . max ( last touch x , event x ) ; dirty rect . top = math . min ( last touch y , event y ) ; dirty rect . bottom = math . max ( last touch y , event y ) ; }	retrieve the region needing to be redrawn.
public sort ( string [ ] fields ) { this ( fields , new boolean [ fields . length ] ) ; arrays . fill ( m ascend , bool ) ; }	creates a new sort specification that sorts on the given fields , all in ascending order .
@ override public boolean was successful ( ) { return is finished ( ) && get current points ( ) >= success threashold ; }	the attack is only successful if the xsw message is accepted .
void start locating phone ( ) { intent intent = new intent ( s context , location service . class ) ; intent . set action ( location service . start service ) ; intent . put extra ( str , this . m answer to ) ; s context . start service ( intent ) ; }	starts the geolocation service.
public void delete resource config ( string cluster name , resource type resource type , string ds name ) throws configuration exception { if ( get cluster home ( ) == null ) { throw new configuration exception ( str ) ; } file resources = get dir ( get resource config dir name ( get cluster home ( ) , cluster name , resource type ) ) ; string del file name = resources . get absolute path ( ) + file . separator + ds name + str ; del file ( del file name ) ; }	delete a specific resource configuration .
public bus movement ( bus movement proto ) { super ( proto ) ; this . control system = proto . control system ; this . id = next id ++ ; control system . register bus ( this ) ; start mode = bool ; }	create a new instance from a prototype.
private int remove next ( ) { if ( last usage dates . is empty ( ) ) { return invalid size ; } long oldest usage = null ; file most long used file = null ; set < entry < file , long > > entries = last usage dates . entry set ( ) ; synchronized ( last usage dates ) { for ( entry < file , long > entry : entries ) { if ( most long used file == null ) { most long used file = entry . get key ( ) ; oldest usage = entry . get value ( ) ; } else { long last value usage = entry . get value ( ) ; if ( last value usage < oldest usage ) { oldest usage = last value usage ; most long used file = entry . get key ( ) ; } } } } int file size = num ; if ( most long used file != null ) { if ( most long used file . exists ( ) ) { file size = get size ( most long used file ) ; if ( most long used file . delete ( ) ) { last usage dates . remove ( most long used file ) ; } } else { last usage dates . remove ( most long used file ) ; } } return file size ; }	remove next file and returns it ' s size.
private void create gui ( ) { for ( final i panel : m factory ) { m tabbed pane . add tab ( panel . get title ( ) , panel . get component ( ) ) ; } add ( m tabbed pane , border layout . center ) ; m tabbed pane . set visible ( bool ) ; }	creates the sub - components of the panel .
public static float generate random float between ( float lower limit , float upper limit ) { return lower limit + ( ( upper limit - lower limit ) * r . next float ( ) ) ; }	generates a random float between two limits.
public s ( ) { supported types . add ( i . class ) ; supported types . add ( i . class ) ; supported types . add ( i . class ) ; supported types . add ( i . class ) ; supported types . add ( i . class ) ; }	this constructs an instance . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
synchronized void add tracer ( tracer tracer ) { if ( cur tracers . add ( tracer ) ) { log . trace ( to string ( ) + str + tracer . to string ( ) ) ; } }	add a new tracer .
private void grow ( ) { int new cap = ( entries . length << num ) + num ; object [ ] new entries = new object [ new cap ] ; system . arraycopy ( entries , num , new entries , num , size ) ; entries = new entries ; }	expands capacity of internal arrays .
public void damage ( double value ) { set value ( math . max ( num , get value ( ) - value ) ) ; }	damage component by given value .
@ ignore ( str ) @ test public void test concurrent events on empty region ( ) { version test concurrent events on empty region ( ) ; }	this tests the concurrency versioning system to ensure that event conflation happens correctly and that the statistic is being updated properly.
public graph ( ) { roots = new array list < node > ( ) ; nodes = new array list < node > ( ) ; string = str ; }	constructs an empty graph.
private static string trim version ( string api version ) { if ( api version == null ) { return null ; } else { string [ ] version parts = api version . split ( str ) ; return version parts [ version parts . length - num ] ; } }	separates apiversion for apigroup / apiversion combination .
private inventory query inventory ( boolean query sku details , list < string > more item skus ) throws iab exception { check not disposed ( ) ; check setup done ( str ) ; try { inventory inv = new inventory ( ) ; int r = query purchases ( inv , item type inapp ) ; if ( r != billing response result ok ) { throw new iab exception ( r , str ) ; } if ( query sku details ) { r = query sku details ( item type inapp , inv , more item skus ) ; if ( r != billing response result ok ) { throw new iab exception ( r , str ) ; } } if ( m subscriptions supported ) { r = query purchases ( inv , item type subs ) ; if ( r != billing response result ok ) { throw new iab exception ( r , str ) ; } if ( query sku details ) { r = query sku details ( item type subs , inv , more item skus ) ; if ( r != billing response result ok ) { throw new iab exception ( r , str ) ; } } } return inv ; } catch ( remote exception e ) { throw new iab exception ( iabhelper remote exception , str , e ) ; } catch ( json e ) { throw new iab exception ( iabhelper bad response , str , e ) ; } }	queries the inventory . this will query all owned items from the server , as well as information on additional skus , if specified . this method may block or take long to execute .
@ override public void incoming object ( i analyzed interval ) throws ade exception { if ( ! m percentiles with empty intervals && analyzed interval . get num unique message ids ( ) == num ) { return ; } final double raw score = calc raw score ( analyzed interval ) ; if ( ! seen huge log prob ( analyzed interval ) ) { m raw scores . add ( raw score ) ; ++ m interval count ; } }	if we do not use empty intervals to compute percentiles and there are no unique messages for this interval then we simply return.
public static string read file as string ( file file , string encoding ) throws io { byte buffer buffer = read file ( file ) ; if ( null == encoding ) { encoding = str ; } string converted = new string ( buffer . array ( ) , encoding ) ; return converted ; }	new nio based method to read a file as a string with the given encoding .
public em bayes estimator editor ( em bayes estimator wrapper em bayes est wrapper ) { this ( em bayes est wrapper . get estimate bayes im ( ) , em bayes est wrapper . get data set ( ) ) ; }	constructs a new bayes im editor from a bayes estimator wrapper .
private boolean save data to disk ( boolean exit , boolean complete , string updated save name ) { return save data to disk ( exit , complete , updated save name , bool ) ; }	saves data and writes it to disk.
public static final void write map xml ( map val , string name , xml serializer out , write map callback callback ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } write map xml ( val , out , callback ) ; out . end tag ( null , str ) ; }	flatten a map into an xmlserializer.
public boolean need preload key ( int idx ) { return preload keys != null && preload keys . get ( idx ) ; }	checks whether entry info should be sent to primary node from backup .
public int generate challenge token ( inet socket address address ) { int token = random . next int ( ) ; challenge tokens . put ( address , token ) ; return token ; }	generate a new token .
@ override public void perform ( ir ir ) { for ( enumeration < basic block > e = ir . get basic blocks ( ) ; e . has more elements ( ) ; ) { basic block bb = e . next element ( ) ; if ( bb . is empty ( ) ) continue ; container . counter2 ++ ; if ( bb . get infrequent ( ) ) { container . counter1 ++ ; if ( ir . options . freq focus effort ) continue ; } for ( enumeration < instruction > ie = bb . forward instr enumerator ( ) ; ie . has more elements ( ) ; ) { instruction s = ie . next element ( ) ; if ( type check . conforms ( s ) && ( invert null and type checks ( s ) || push type check below if ( s , ir ) ) ) { ie = bb . forward instr enumerator ( ) ; } } } }	main routine : perform the transformation .
public void run with retries ( retryable task task ) throws exception { boolean max sleep interval hit = bool ; for ( int i = num ; i < num attempts ; i ++ ) { try { task . run ( ) ; return ; } catch ( exception e ) { if ( i == num attempts - num ) { throw e ; } int sleep time ; if ( max sleep interval hit ) { sleep time = max sleep interval ; } else { sleep time = base sleep interval * ( int ) math . pow ( num , i ) ; } log . error ( str + sleep time + str , e ) ; try { thread . sleep ( sleep time * num ) ; } catch ( interrupted exception ie ) { log . error ( str , ie ) ; throw ie ; } } } }	run a task , retrying a fixed number of times if there is a failure .
public object pack ( ) { if ( collection ) { list l = ( list ) value ; if ( types . is array ( type ) ) { object [ ] o = ( object [ ] ) array . new instance ( item type , l . size ( ) ) ; l . to array ( o ) ; return o ; } } return value ; }	based on accumulated value , produce a value for this property .
public void remove request ( interrupt request interrupt request ) { synchronized ( interrupt request queue ) { interrupt request queue . remove ( interrupt request ) ; } }	this is the way to remove a specific request object.
@ override public final void on heatmap failed ( ) { update pending = bool ; }	callback function when heatmap generation has failed.
@ suppress lint ( str ) @ nullable public static drawable inflate ( boolean force system handling when possible , @ non null resources resources , @ drawable res int id ) { boolean system handling = is system handling ( force system handling when possible ) ; log . d ( log tag , string . format ( str , integer . to hex string ( id ) , system handling ) ) ; if ( system handling ) { return resources . get drawable ( id , null ) ; } try { return vector drawable . create ( resources , id ) ; } catch ( resources . not found exception e ) { return null ; } }	inflate a drawable from a vector xml resource .
public static long object field offset ( field field ) { return unsafe . object field offset ( field ) ; }	returns object field offset .
public void add annotation ( string annotation , double x , double y ) { m annotations . add ( annotation ) ; m string xy . put ( x , y ) ; }	add an string at ( x , y ) coordinates.
protected synchronized void write ( long offset , byte [ ] b ) throws io { if ( byte buffer != null ) { byte buffer . position ( ( int ) offset ) ; byte buffer . put ( b ) ; } else { throw new io ( str + get path ( ) + str ) ; } }	writes bytes to the underlying rrd file on the disk.
public static byte [ ] iv cipher concat ( byte [ ] iv , byte [ ] cipher text ) { byte [ ] combined = new byte [ iv . length + cipher text . length ] ; system . arraycopy ( iv , num , combined , num , iv . length ) ; system . arraycopy ( cipher text , num , combined , iv . length , cipher text . length ) ; return combined ; }	concatinate the iv to the ciphertext using array copy.
long timestamp ( long timestamp ) { this . timestamp = math . max ( this . timestamp , timestamp ) ; return this . timestamp ; }	returns an updated executor timestamp .
public material package ( bo material package bo , list < generic track > generic tracks ) { super ( material package bo ) ; this . material package bo = material package bo ; this . generic tracks = collections . unmodifiable list ( generic tracks ) ; }	instantiates a new materialpackage object.
public edge find edge in same direction ( coordinate p0 , coordinate p1 ) { for ( int i = num ; i < edges . size ( ) ; i ++ ) { edge e = ( edge ) edges . get ( i ) ; coordinate [ ] e coord = e . get coordinates ( ) ; if ( match in same direction ( p0 , p1 , e coord [ num ] , e coord [ num ] ) ) return e ; if ( match in same direction ( p0 , p1 , e coord [ e coord . length - num ] , e coord [ e coord . length - num ] ) ) return e ; } return null ; }	returns the edge which starts at p0 and whose first segment is parallel to p1.
public void acquire probabilities ( final string string ) { if ( string . length ( ) < num ) { return ; } for ( int i = num ; i < string . length ( ) ; ++ i ) { final char previous char = string . char at ( i - num ) ; final char current char = string . char at ( i - num ) ; final char next char = string . char at ( i ) ; final string key = previous char + str + current char ; if ( ! sequences . contains ( key ) ) { sequences . add ( key ) ; } hash map < character , integer > probabilities = sequence probabilities . get ( key ) ; if ( probabilities == null ) { probabilities = new hash map < > ( ) ; sequence probabilities . put ( key , probabilities ) ; } int existing value = probabilities . get or default ( next char , num ) ; ++ existing value ; probabilities . put ( next char , existing value ) ; } }	parses the specified string to determine the probability of a character appearing after the previous two characters beginning with the third character in the string and ending with the last .
protected final void resolve issue ( health issue health issue ) { event bus event bus ; boolean was issue active ; synchronized ( m lock ) { if ( m health event bus == null ) { log . w ( str + str , health issue . to string ( ) ) ; return ; } event bus = m health event bus ; was issue active = m active issues . remove ( health issue ) ; } if ( was issue active ) { event bus . post ( health issue . resolved ) ; } }	marks as resolved the specified issue.
public static byte [ ] decode ( string s ) { return decode ( s , no options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
private static boolean test ( o pool , string db url , string user , string password , boolean final try ) { o db = null ; try { logger . info ( str ) ; db = pool . acquire ( db url , user , password ) ; iterator < o > iter = db . browse class ( str ) ; if ( iter . has next ( ) ) { iter . next ( ) ; } } catch ( o ex ) { if ( final try ) { logger . info ( str , ex ) ; } else { logger . debug ( str , ex ) ; } return bool ; } finally { if ( db != null ) { db . close ( ) ; } } return bool ; }	perform a basic access on the db for a rudimentary test.
@ override public void agg ( object new val ) { if ( new val instanceof byte [ ] ) { byte [ ] values = ( byte [ ] ) new val ; byte buffer buffer = byte buffer . wrap ( values ) ; buffer . rewind ( ) ; while ( buffer . has remaining ( ) ) { value set . add ( buffer . get int ( ) ) ; } return ; } else { double value = new double ( new val . to string ( ) ) ; agg ( value ) ; } }	distinct count aggregate function which update the distinct count.
public boolean is unparsed entity ( string entity name ) { entity entity = ( entity ) f entities . get ( entity name ) ; if ( entity == null ) { return bool ; } return entity . is unparsed ( ) ; }	checks whether an entity given by name is unparsed .
public void flush ( ) throws io { out . flush ( ) ; }	flush any buffered messages .
private static string url encode ( final string text ) throws unsupported encoding exception { return url . encode ( text , str ) ; }	encode text as utf - 8.
protected void process focus event ( focus event evt ) { super . process focus event ( evt ) ; if ( evt . get id ( ) == focus event . focus lost ) { if ( popup != null ) hide popup ( ) ; } }	ensures that if we lose focus , the popup goes away .
@ override public synchronized void add request property ( string key , string value ) { if ( connected || connecting ) throw new illegal state exception ( str ) ; if ( key == null ) throw new null pointer exception ( str ) ; if ( is external message header allowed ( key , value ) ) { requests . add ( key , value ) ; if ( ! key . equals ignore case ( str ) ) { user headers . add ( key , value ) ; } } }	adds a general request property specified by a key - value pair.
public void execute ( abortable task task ) { aborting runnable ar = new aborting runnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( rejected execution exception e ) { tasks . remove ( ar ) ; throw e ; } }	executes the task using the embedded executor .
default byte buffer serialize ( t value ) { byte buffer buffer = byte buffer . allocate ( size ( value ) ) ; serialize ( value , buffer ) ; return buffer ; }	serialize to a byte buffer.
private void load submissions ( ) { submissions . clear ( ) ; string [ ] users = j . users list ( ) ; for ( int i = num ; i < users . length ; i ++ ) { access structure [ ] subm = j . list access structures ( users [ i ] ) ; if ( subm != null && subm . length != num ) { for ( int j = num ; j < subm . length ; j ++ ) { submissions . add ( subm [ j ] ) ; } } } }	used to actualize the vector containing all submissions.
public static bit value of ( string bit ) throws number format exception { final int i = integer . parse int ( bit ) ; if ( i != num && i != num ) { throw new number format exception ( str + bit + str ) ; } return ( i > num ) ? true : false ; }	method to construct a bit for a given string expression .
public boolean next ( ) throws eof { if ( limit >= file size ) { throw new eof ( str ) ; } if ( mem . get long volatile ( structure . limit ) <= limit ) { return bool ; } byte commit = mem . get byte volatile ( limit ) ; byte rollback = mem . get byte volatile ( limit + length . commit ) ; if ( rollback == rollback . set ) { limit += length . record header + record size ; timeout counter = num ; timer start = num ; return bool ; } if ( commit == commit . set ) { timeout counter = num ; timer start = num ; return bool ; } timeout counter ++ ; if ( timeout counter >= max timeout count ) { if ( timer start == num ) { timer start = system . current time millis ( ) ; } else { if ( system . current time millis ( ) - timer start >= max timeout ) { mem . put byte volatile ( limit + length . commit , rollback . set ) ; limit += length . record header + record size ; timeout counter = num ; timer start = num ; return bool ; } } } return bool ; }	steps forward to the next record if there ' s one available.
private int compose component ( int a , int b ) { return math . min ( b + b * a / dimming factor , num ) ; }	apply composition to an individual color component of a pixel .
public synchronized void write to ( output stream out ) throws io { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; out . write ( buf , num , c ) ; remaining -= c ; if ( remaining == num ) { break ; } } }	writes the entire contents of this byte stream to the specified output stream .
public void remove tree model listener ( tree model listener l ) { tree model listeners . remove element ( l ) ; }	removes a listener previously added with addtreemodellistener ( ) .
public uri ( string name ) throws io { try { uri = new uri ( name ) ; } catch ( uri use ) { throw new io ( str + name , use ) ; } if ( uri . get scheme ( ) == null ) { throw new io ( str + name ) ; } host = uri . get host ( ) ; if ( host != null ) { if ( host . char at ( num ) == str ) { string ip v6 host = host . substring ( num , host . length ( ) - num ) ; try { host ip = new ip ( ip v6 host ) ; } catch ( io ioe ) { throw new io ( str + str + name ) ; } } else { try { host dns = new dns ( host ) ; } catch ( io ioe ) { try { host ip = new ip ( host ) ; } catch ( exception ioe2 ) { throw new io ( str + str + str + name ) ; } } } } }	create the uriname object with the specified name .
public projected stream add view ( string namespace , string name , list < expression > parameters ) { views . add ( view . create ( namespace , name , parameters ) ) ; return this ; }	adds a parameterized view to the stream .
protected int read ( speech record recorder , byte [ ] buffer ) { int len = buffer . length ; int num of bytes = recorder . read ( buffer , num , len ) ; int status = get status ( num of bytes , len ) ; if ( status == num ) { system . arraycopy ( buffer , num , m recording , m recorded length , num of bytes ) ; m recorded length += len ; } return status ; }	copy data from the given recorder into the given buffer , and append to the complete recording . public int read ( byte [ ] audiodata , int offsetinbytes , int sizeinbytes ).
public void touch ( ) { candies store = null ; }	cleans the candies store so that it will be read from file next time .
public static int hash ( object o ) { int h = o == null ? num : o instanceof byte [ ] ? arrays . hash code ( ( byte [ ] ) o ) : o . hash code ( ) ; h += ( h << num ) ^ num ; h ^= ( h > > > num ) ; h += ( h << num ) ; h ^= ( h > > > num ) ; h += ( h << num ) + ( h << num ) ; return h ^ ( h > > > num ) ; }	gets hash code for a given object .
public void add parse template ( string parse template ) { parse templates . add ( parse template ) ; }	adds a template which should be " parsed " while the parsing process .
private void attach image from camera ( ) { try { if ( null != m shooted picture path ) { uri uri = uri . from file ( new file ( m shooted picture path ) ) ; try { bitmap preview bitmap = vector app . get saved picker image preview ( ) ; string thumbnail path = get thumbnail path ( m shooted picture path ) ; int rotation angle = image utils . get rotation angle for bitmap ( vector medias picker activity . this , uri ) ; if ( num != rotation angle ) { android . graphics . matrix bitmap matrix = new android . graphics . matrix ( ) ; bitmap matrix . post rotate ( num - rotation angle ) ; preview bitmap = bitmap . create bitmap ( preview bitmap , num , num , preview bitmap . get width ( ) , preview bitmap . get height ( ) , bitmap matrix , bool ) ; } file file = new file ( thumbnail path ) ; file output stream out stream = new file output stream ( file ) ; preview bitmap . compress ( bitmap . compress format . jpeg , num , out stream ) ; out stream . flush ( ) ; out stream . close ( ) ; } catch ( exception e ) { log . e ( log tag , str ) ; } bundle con data = new bundle ( ) ; intent intent = new intent ( ) ; intent . set data ( uri ) ; intent . put extras ( con data ) ; set result ( result ok , intent ) ; } } catch ( exception e ) { set result ( result canceled , null ) ; } finally { vector app . set saved camera image preview ( null ) ; finish ( ) ; } }	return the taken image from the camera to the calling activity.
private double min ignore na n ( double a , double b ) { if ( double . is na n ( a ) ) { return b ; } if ( double . is na n ( b ) ) { return a ; } return math . min ( a , b ) ; }	a function to find the minimum of two values , but ignoring any double.
public object name pre register ( m server , object name name ) throws exception { set m ( server ) ; if ( name == null ) { name = new object name ( server . get default domain ( ) + str + service name . mlet ) ; } this . mlet object name = name ; return this . mlet object name ; }	allows the m - let to perform any operations it needs before being registered in the mbean server . if the objectname is null , the m - let provides a default name for its registration & lt ; defaultdomain & gt ; : type = mlet.
static string match string or throw ( pattern p , to date parser params , enum < ? > a enum ) { string s = params . get input str ( ) ; matcher matcher = p . matcher ( s ) ; if ( ! matcher . find ( ) ) { throw exception ( params , format ( str , a enum . name ( ) ) ) ; } return matcher . group ( num ) ; }	match the pattern , or if not possible throw an exception .
string source form for initializer ( annotation value annotation value , processing environment processing env , string member name , element context ) { source form visitor visitor = new initializer source form visitor ( processing env , member name , context ) ; string builder sb = new string builder ( ) ; visitor . visit ( annotation value , sb ) ; return sb . to string ( ) ; }	returns a string representation of the given annotation value , suitable for inclusion in a java source file as the initializer of a variable of the appropriate type .
static byte buffer new byte buffer ( int capacity ) { byte buffer newbb = byte buffer . allocate ( capacity ) ; newbb . order ( byte order . little endian ) ; return newbb ; }	create a ` bytebuffer ` with a given capacity .
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; m value . add ( value ) ; update range ( value ) ; }	adds a new value to the series .
private void validate collection attribute ( collection attribute collection , set < string > all collections ) { if ( collection == null || all collections == null ) { return ; } for ( rest method rest method : collection . get methods ( ) ) { if ( all collections . contains ( rest method . get rest full method name ( ) ) ) { aspect . warning ( simple location . toplevel , str + str + str + str , collection . get full name ( ) , rest method . get rest method name ( ) ) ; } } }	validates if the collection does not contain same named elements ( methods and resources ) .
public void put string no null ( string s ) { ensure capacity ( s . length ( ) * num ) ; system . arraycopy ( s . get bytes ( ) , num , this . byte buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; }	put a string in the buffer.
public void external entity decl ( string name , xml identifier , augmentations augs ) throws xni { try { if ( f decl handler != null ) { string public id = identifier . get public id ( ) ; string system id = f resolve dtdur ? identifier . get expanded system id ( ) : identifier . get literal system id ( ) ; f decl handler . external entity decl ( name , public id , system id ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	an external entity declaration .
public holt winters model builder alpha ( double alpha ) { this . alpha = alpha ; return this ; }	alpha controls the smoothing of the data.
public static @ check for null class descriptor create class descriptor from field signature ( string signature ) { int start = signature . index of ( str ) ; if ( start < num ) { return null ; } int end = signature . index of ( str , start ) ; if ( end < num ) { return null ; } return create class descriptor ( signature . substring ( start + num , end ) ) ; }	create a class descriptor from a field signature.
private static service ticket response check get nfc service ticket response ( service ticket response service ticket response ) throws rpc exception { logger . info ( str , service ticket response ) ; switch ( service ticket response . get result ( ) ) { case ok : break ; case system error : throw new system error exception ( service ticket response . get error ( ) ) ; case not found : throw new datastore not found exception ( service ticket response . get error ( ) ) ; default : throw new rpc exception ( string . format ( str , service ticket response . get error ( ) ) ) ; } return service ticket response ; }	this method validates a serviceticketresponse object , raising an exception if the response reflects an operation failure .
public void schedule ( timer task task , long delay ) { if ( delay < num ) throw new illegal argument exception ( str ) ; sched ( task , system . current time millis ( ) + delay , num ) ; }	schedules the specified task for execution after the specified delay .
public void filled ellipse ( double x , double y , double semi major axis , double semi minor axis ) { if ( semi major axis < num ) throw new illegal argument exception ( str ) ; if ( semi minor axis < num ) throw new illegal argument exception ( str ) ; double xs = scale x ( x ) ; double ys = scale y ( y ) ; double ws = factor x ( num * semi major axis ) ; double hs = factor y ( num * semi minor axis ) ; if ( ws <= num && hs <= num ) pixel ( x , y ) ; else offscreen . fill ( new d . double ( xs - ws / num , ys - hs / num , ws , hs ) ) ; draw ( ) ; }	draws an ellipse with given semimajor and semiminor axes , centered on ( x , y ) .
@ override public cursor swap cursor ( cursor new cursor ) { m alphabet indexer . set cursor ( new cursor ) ; return super . swap cursor ( new cursor ) ; }	overrides swapcursor to move the new cursor into the alphabetindex as well as the cursoradapter .
public void lock flushing ( ) { flush lock . lock ( ) ; }	lock the flushing mechanism in order to prevent a thread flushing this buffer while another thread is doing a physiological operation .
public static boolean can be randomized ( class clazz ) { return class utils . is primitive or wrapper ( clazz ) || clazz . equals ( string . class ) || clazz . equals ( i . class ) ; }	checks if the class is supported to be randomized without recursion .
public static string generate native guid ( string device type , string serial number ) { return string . format ( str , device type map . get ( device type ) , serial number ) ; }	the format of this native guid using the given devicetype & serialnumber .
public static secret keys keys ( string keys str ) throws invalid key exception { string [ ] keys arr = keys str . split ( str ) ; if ( keys arr . length != num ) { throw new illegal argument exception ( str ) ; } else { byte [ ] confidentiality key = base64 . decode ( keys arr [ num ] , bas flags ) ; if ( confidentiality key . length != aes key length bits / num ) { throw new invalid key exception ( str + aes key length bits + str ) ; } byte [ ] integrity key = base64 . decode ( keys arr [ num ] , bas flags ) ; if ( integrity key . length != hmac key length bits / num ) { throw new invalid key exception ( str + hmac key length bits + str ) ; } return new secret keys ( new secret key spec ( confidentiality key , num , confidentiality key . length , cipher ) , new secret key spec ( integrity key , hmac algorithm ) ) ; } }	an aes key derived from a base64 encoded key.
public writable raster create writable child ( int x , int y , int width , int height , int x0 , int y0 , int band list [ ] ) { if ( x < this . min x ) { throw new raster format exception ( str ) ; } if ( y < this . min y ) { throw new raster format exception ( str ) ; } if ( ( x + width < x ) || ( x + width > this . min x + this . width ) ) { throw new raster format exception ( str ) ; } if ( ( y + height < y ) || ( y + height > this . min y + this . height ) ) { throw new raster format exception ( str ) ; } sample model sm ; if ( band list != null ) sm = sample model . create subset sample model ( band list ) ; else sm = sample model ; int delta x = x0 - x ; int delta y = y0 - y ; return new short banded raster ( sm , data buffer , new rectangle ( x0 , y0 , width , height ) , new point ( sample model translate x + delta x , sample model translate y + delta y ) , this ) ; }	creates a writable subraster given a region of the raster.
private void sort children ( final j parent node ) { final list < j > operators = new array list < j > ( ) ; final list < j > conditions = new array list < j > ( ) ; final list < j > minus = new array list < j > ( ) ; final enumeration < ? > children = parent node . children ( ) ; while ( children . has more elements ( ) ) { final j child = ( j ) children . next element ( ) ; final i type = child . get criterium ( ) ; if ( type instanceof c ) { conditions . add ( child ) ; } else { operators . add ( child ) ; } } parent node . remove all children ( ) ; for ( final j child : operators ) { parent node . add ( child ) ; child . set parent ( parent node ) ; } for ( final j child : conditions ) { parent node . add ( child ) ; child . set parent ( parent node ) ; } for ( final j child : minus ) { parent node . add ( child ) ; child . set parent ( parent node ) ; } }	sorts visible tree nodes .
public static int poisson ( double lambda ) { int k = num ; double p = num ; double l = math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >= l ) ; return k - num ; }	return an integer with a poisson distribution with mean lambda .
public boolean is builtin sound available ( string sound identifier ) { return builtin sounds . contains key ( sound identifier ) ; }	indicates whether a user installed or system sound is available.
public iterator < string > iterate serializers ( ) { return serializers . iterator ( ) ; }	iterate over view serializers.
private static void check key ( string key ) throws malformed object name exception { if ( key == null ) throw new null pointer exception ( str ) ; final int len = key . length ( ) ; if ( len == num ) throw new malformed object name exception ( str ) ; final char [ ] k = key . to char array ( ) ; final int end key = parse key ( k , num ) ; if ( end key < len ) throw new malformed object name exception ( str + k [ end key ] + str ) ; }	check if the supplied key is a valid key .
public abstract boolean is shutdown ( ) ;	tells whether or not this asynchronous channel group is shutdown .
protected abstract void init ( ) ;	initializes the storage elements of the tree .
private void draw arc ( canvas canvas ) { if ( m current dash mode . equals ( dash mode . download ) ) { mn indeterminate start position += ( num - mn progress ) * mn start speed ; if ( ( mn indeterminate start position > circular factor ) || ( mn indeterminate start position < num ) ) { mn indeterminate start position = num ; } rect curr rect = new rect ( ) ; get local visible rect ( curr rect ) ; float n ring boundary inner = mn ring radius - ( mn ring width / num ) - ( mn arc width / num ) ; m arc rect . set ( mn view center - n ring boundary inner , mn view center - n ring boundary inner , mn view center + n ring boundary inner , mn view center + n ring boundary inner ) ; m paint . set color ( m arc color ) ; m paint . set style ( paint . style . stroke ) ; m paint . set stroke width ( mn arc width ) ; m paint . set stroke cap ( paint . cap . round ) ; canvas . draw arc ( m arc rect , mn indeterminate start position , mn arc length , bool , m paint ) ; } }	draw the arc around the ring only for the download mode.
public static string format date time ( java . util . date date , string format , string locale , string time zone ) { simple date format date format = get date format ( format , locale , time zone ) ; synchronized ( date format ) { return date format . format ( date ) ; } }	formats a date using a format string .
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { decoder decoder = new decoder ( flags , new byte [ len * num / num ] ) ; if ( ! decoder . process ( input , offset , len , bool ) ) { throw new illegal argument exception ( str ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; system . arraycopy ( decoder . output , num , temp , num , decoder . op ) ; return temp ; }	decode the base64 - encoded data in input and return the data in a new byte array.
protected message digest ( string algorithm ) { this . algorithm = algorithm ; }	creates a message digest with the specified algorithm name .
public static int [ ] merge sort ( int [ ] a ) { if ( a . length == num ) return a ; int [ ] x = merge sort ( arrays . copy of range ( a , num , a . length / num ) ) ; int [ ] y = merge sort ( arrays . copy of range ( a , a . length / num , a . length ) ) ; return merge ( x , y ) ; }	merge sort . < p / > time complexity : o ( n log n ) space complexity : o ( n ) ( also needs o ( log n ) stack space as it is recursive ).
private void copy a ( final list < access control level > access control levels2 ) { for ( access control level acl : this . access control levels ) { access control levels2 . add ( new access control level ( acl ) ) ; } }	copy acls for new configuration .
public void put ( byte buffer byte buffer , int content length ) { if ( content length > ( bytes . length - this . content length ) ) { throw new illegal argument exception ( str ) ; } byte buffer . get ( bytes , this . content length , content length ) ; this . content length += content length ; }	appends content from the specified bytebuffer to this bytearray.
private void handle response ( avs response response ) { boolean check after = ( avs queue . size ( ) == num ) ; if ( response != null ) { for ( int i = response . size ( ) - num ; i >= num ; i -- ) { if ( response . get ( i ) instanceof avs replace all item || response . get ( i ) instanceof avs replace enqueued item ) { avs queue . clear ( ) ; response . remove ( i ) ; } } log . i ( tag , str + response . size ( ) + str ) ; avs queue . add all ( response ) ; } if ( check after ) { check queue ( ) ; } }	handle the response sent back from alexa ' s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen ).
protected synchronized void request ( string stream ) { if ( stream == null || stream . is empty ( ) ) { return ; } stream = stream . to lower case ( locale . english ) ; follower info cached info = cached . get ( stream ) ; if ( cached info == null || check time passed ( cached info ) ) { if ( type == follower . type . follower ) { api . request followers ( stream ) ; } else if ( type == follower . type . subscriber ) { api . request subscribers ( stream ) ; } } else { if ( type == follower . type . follower ) { listener . received followers ( cached info ) ; } else if ( type == follower . type . subscriber ) { listener . received subscribers ( cached info ) ; } } }	checks if there is info already cached and whether it is old enough to be updated , in which case it requests the data from the api .
boolean remove view if hidden ( view view ) { final int index = m callback . index of child ( view ) ; if ( index == - num ) { if ( m hidden views . remove ( view ) && debug ) { throw new illegal state exception ( str ) ; } return bool ; } if ( m bucket . get ( index ) ) { m bucket . remove ( index ) ; m callback . remove view at ( index ) ; if ( ! m hidden views . remove ( view ) && debug ) { throw new illegal state exception ( str ) ; } return bool ; } return bool ; }	removes a view from the viewgroup if it is hidden .
public string consume css identifier ( ) { int start = pos ; while ( ! is empty ( ) && ( matches word ( ) || matches any ( str , str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume a css identifier ( id or class ) off the queue ( letter , digit , - , _ ) http : / / www.
@ ignore ( str ) @ test public void test populate1kbwrites ( ) { final byte [ ] value = new byte [ entry size ] ; arrays . fill ( value , ( byte ) num ) ; for ( int i = num ; i < op count ; i ++ ) { region . put ( new integer ( i ) , value ) ; } close down ( ) ; }	currently not being executed for congo but after transition to jdk 1.
public void serialize ( k serializer ) throws io { serializer . start tag ( ns , tag ) ; serialize attribute ( serializer , name attr , m name ) ; serialize attribute ( serializer , app package name attr , m app package name ) ; serialize attribute ( serializer , digest attr , get digest ( ) ) ; if ( signature test pkg . equals ( m name ) ) { serializer . attribute ( ns , str , str ) ; } m suite root . serialize ( serializer ) ; serializer . end tag ( ns , tag ) ; }	serialize this object and all its contents to xml .
public void rollback ( throwable t ) { log . debug ( str + temp file + str + t ) ; try { file content store . delete ( temp file , node ) ; } catch ( exception e ) { t . add suppressed ( e ) ; } }	rollback the download ( delete the temporary file ).
protected void parse geometry string ( ) { int i = num ; byte [ ] bytes = geometry string . get bytes ( ) ; xgrav = new string ( bytes , num , num ) ; for ( i = num ; i < bytes . length ; i ++ ) { if ( ( bytes [ i ] == str ) || ( bytes [ i ] == str ) ) break ; } if ( i == bytes . length ) return ; ygrav = ( bytes [ i ] == str ) ? str : str ; xpos = integer . parse int ( new string ( bytes , num , i - num ) ) ; ++ i ; ypos = integer . parse int ( new string ( bytes , i , bytes . length - i ) ) ; }	parse x - like geometry string .
@ override protected final synchronized boolean write data ( byte buffer data ) { aion server packet packet = send msg queue . poll first ( ) ; if ( packet == null ) { return bool ; } packet . set buf ( data ) ; packet . write ( this ) ; return bool ; }	this method will be called by dispatcher , and will be repeated till return false .
public synchronized int last index of ( object object , int location ) { if ( location < element count ) { if ( object != null ) { for ( int i = location ; i >= num ; i -- ) { if ( object . equals ( element data [ i ] ) ) { return i ; } } } else { for ( int i = location ; i >= num ; i -- ) { if ( element data [ i ] == null ) { return i ; } } } return - num ; } throw array index out of bounds exception ( location , element count ) ; }	searches in this vector for the index of the specified object.
@ override public boolean can undo ( ) { return ! m . is empty ( ) ; }	returns whether an undo is possible , i.
protected void calculate destination ( i uxf , i referencing compilation unit , destination dest ) throws core exception { i uxf dest = calculate img destination ( uxf , referencing compilation unit ) ; if ( uxf dest != null ) { dest . img file destination = uxf dest ; } }	calculate the destination of the given umlet diagram . return null if the diagram reference does not need to be updated.
@ override public void on event ( project event event ) { if ( event . get type ( ) == project event . event type . updated || event . get type ( ) == project event . event type . created ) { update ( event ) ; } }	there is a change on the project that we ' re monitoring , whatever the type of event is , we need to updated the runner .
protected abstract boolean on mouse click ( point point ) ;	called on left mouse single click .
public void update visible ids ( list < integer > priority ) { if ( m native tab content manager != num ) { int ids size = math . min ( m full res thumbnails max size , priority . size ( ) ) ; if ( ids size != m priority tab ids . length ) { m priority tab ids = new int [ ids size ] ; } for ( int i = num ; i < ids size ; i ++ ) { m priority tab ids [ i ] = priority . get ( i ) ; } native update visible ids ( m native tab content manager , m priority tab ids ) ; } }	update the priority - ordered list of visible tabs .
public final void walk graph ( hashtable sem nodes table ) { integer uid = new integer ( my uid ) ; if ( sem nodes table . get ( uid ) != null ) return ; sem nodes table . put ( new integer ( my uid ) , this ) ; }	tostring , leveldatatostring , and walkgraph methods to implement explorenode interface.
public boolean show previous notification ( ) { int i = get selected index ( ) ; if ( i != - num && i > num ) { model . set selected item ( model . get element at ( i - num ) ) ; return bool ; } return bool ; }	scrolls to the previous notification .
@ override public void write external ( object output out ) throws io { super . write external ( out ) ; out . write boolean ( is leaf ) ; out . write int ( num entries ) ; }	calls the super method and writes the id of this node , the numentries and the entries array to the specified stream .
protected void add input node internal ( b input node ) { if ( input nodes . contains key ( input node . get id ( ) ) ) { log . warning ( str + input node . get id ( ) + str + node id ) ; } input nodes . put ( input node . get id ( ) , input node ) ; }	adds a new incoming relation to the node.
public static void initialize ( final c configuration ) throws couldnt load driver exception , couldnt connect exception , sql { check driver ( configuration ) ; final string url = postgres driver + str + configuration . get host ( ) + str + postgres default db ; connection connection = null ; try { connection = driver manager . get connection ( url , configuration . get user ( ) , configuration . get password ( ) ) ; } catch ( final sql exception ) { c . log exception ( exception ) ; throw new couldnt connect exception ( exception , exception . get error code ( ) , exception . get sql ( ) ) ; } final string statement = str + configuration . get name ( ) + str ; final prepared statement prepared statement = connection . prepare statement ( statement ) ; try { prepared statement . execute ( ) ; } finally { prepared statement . close ( ) ; connection . close ( ) ; } }	initializes a new postgresql database.
private void register object read ( object obj , int handle , boolean unshared ) throws io { if ( unshared ) { obj = unshared obj ; } int index = handle - object stream constants . base wire handle ; int size = objects read . size ( ) ; while ( index > size ) { objects read . add ( null ) ; ++ size ; } if ( index == size ) { objects read . add ( obj ) ; } else { objects read . set ( index , obj ) ; } }	associates a read object with the its serialization handle .
public static void add extension header ( string header name , string class name ) { name map . put ( header name . to lower case ( ) , class name ) ; }	add an extension header to this map .
public boolean merge ( final frame < ? extends v > frame , final interpreter < v > interpreter ) throws analyzer exception { if ( top != frame . top ) { throw new analyzer exception ( null , str ) ; } boolean changes = bool ; for ( int i = num ; i < locals + top ; ++ i ) { v v = interpreter . merge ( values [ i ] , frame . values [ i ] ) ; if ( ! v . equals ( values [ i ] ) ) { values [ i ] = v ; changes = bool ; } } return changes ; }	merges this frame with the given frame .
public static void keytool ( string cmd ) { log . info ( str + cmd ) ; array list < string > list = new array list < string > ( ) ; string tokenizer st = new string tokenizer ( cmd , str ) ; string quote buffer = null ; while ( st . has more tokens ( ) ) { string token = st . next token ( ) ; if ( quote buffer == null ) { if ( token . starts with ( str ) ) quote buffer = token . substring ( num ) ; else list . add ( token ) ; } else quote buffer += str + token ; if ( token . ends with ( str ) ) { string str = quote buffer . substring ( num , quote buffer . length ( ) - num ) ; list . add ( str ) ; quote buffer = null ; } } string [ ] args = new string [ list . size ( ) ] ; list . to array ( args ) ; try { key tool . main ( args ) ; } catch ( exception e ) { } }	submit command to key tool.
private void smooth snap to position ( int scroll y , int available scroll height , alphabetical apps list . fast scroll section info info ) { m rv . remove callbacks ( m smooth snap next frame runnable ) ; m rv . remove callbacks ( m fast scroll to target section runnable ) ; track all child views ( ) ; if ( m has fast scroll touch settled ) { m current fast scroll section = info . section name ; m target fast scroll section = null ; update tracked views fast scroll focus state ( ) ; } else { m current fast scroll section = null ; m target fast scroll section = info . section name ; m has fast scroll touch settled = bool ; update tracked views fast scroll focus state ( ) ; m rv . post delayed ( m fast scroll to target section runnable , m has fast scroll touch settled at least once ? repeat touch settling duration : initial touch settling duration ) ; } int new scroll y = math . min ( available scroll height , m rv . get padding top ( ) + m rv . get top ( info . fast scroll to item . row index ) ) ; int num frames = m fast scroll frames . length ; for ( int i = num ; i < num frames ; i ++ ) { m fast scroll frames [ i ] = ( new scroll y - scroll y ) / num frames ; } m fast scroll frame index = num ; m rv . post on animation ( m smooth snap next frame runnable ) ; }	smoothly snaps to a given position.
private void update property to value2 ( ) throws exception { properties . put ( test key , test value 2 ) ; update properties file ( ) ; }	updates the key in the persistent property store to " value 2 " .
public void unassign services ( string universal id , set service names ) throws am { if ( ( service names != null ) && ! service names . is empty ( ) ) { string [ ] params = new string [ num ] ; params [ num ] = universal id ; string current svc = str ; try { am amid = id utils . get identity ( get user sso ( ) , universal id ) ; for ( iterator iter = service names . iterator ( ) ; iter . has next ( ) ; ) { current svc = ( string ) iter . next ( ) ; params [ num ] = current svc ; log event ( str , params ) ; amid . unassign service ( current svc ) ; log event ( str , params ) ; } } catch ( sso e ) { string [ ] params ex = { universal id , current svc , get error string ( e ) } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } catch ( id repo exception e ) { string [ ] params ex = { universal id , current svc , get error string ( e ) } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } } }	unassigns services from an entity .
private cluster < t > expand cluster ( final cluster < t > cluster , final t point , final list < t > neighbors , final collection < t > points , final map < clusterable , point status > visited ) { cluster . add point ( point ) ; visited . put ( point , point status . part of cluster ) ; list < t > seeds = new array list < t > ( neighbors ) ; int index = num ; while ( index < seeds . size ( ) ) { final t current = seeds . get ( index ) ; point status p status = visited . get ( current ) ; if ( p status == null ) { final list < t > current neighbors = get neighbors ( current , points ) ; if ( current neighbors . size ( ) >= min pts ) { seeds = merge ( seeds , current neighbors ) ; } } if ( p status != point status . part of cluster ) { visited . put ( current , point status . part of cluster ) ; cluster . add point ( current ) ; } index ++ ; } return cluster ; }	expands the cluster to include density - reachable items .
private static address get float array elements ( jni env , int array jref , address is copy address ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { float [ ] source array = ( float [ ] ) env . get jni ( array jref ) ; int size = source array . length ; if ( memory manager . will never move ( source array ) ) { jni . set bool star ( is copy address , bool ) ; return magic . object as address ( source array ) ; } else { address copy buffer = sys call . sys malloc ( size << log bytes in float ) ; if ( copy buffer . is zero ( ) ) { env . record exception ( new out of memory error ( ) ) ; return address . zero ( ) ; } memory . memcopy ( copy buffer , magic . object as address ( source array ) , size << log bytes in float ) ; jni . set bool star ( is copy address , bool ) ; return copy buffer ; } } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return address . zero ( ) ; } }	getfloatarrayelements : get all the elements of a float array.
private void prepare transfers ( ) throws lib usb exception { if ( m available transfers == null ) { m available transfers = new linked transfer queue < > ( ) ; for ( int x = num ; x < transfer buffer pool size ; x ++ ) { transfer transfer = lib usb . alloc transfer ( ) ; if ( transfer == null ) { throw new lib usb exception ( str , lib usb . error no mem ) ; } final byte buffer buffer = byte buffer . allocate direct ( m buffer size ) ; lib usb . fill bulk transfer ( transfer , m device handle , usb endpoint , buffer , buffer processor . this , str , usb timeout us ) ; m available transfers . add ( transfer ) ; } } }	prepares ( allocates ) a set of transfer buffers for use in transferring data from the tuner via the bulk interface.
private void output full lines ( ) throws io { for ( ; ; ) { int left len = left buf . index of ( str ) ; if ( left len < num ) { return ; } int right len = right buf . index of ( str ) ; if ( right len < num ) { return ; } if ( left len != num ) { out . write ( left buf . substring ( num , left len ) ) ; } if ( right len != num ) { write spaces ( out , left width - left len ) ; out . write ( right buf . substring ( num , right len ) ) ; } out . write ( str ) ; left buf . delete ( num , left len + num ) ; right buf . delete ( num , right len + num ) ; } }	outputs to the final destination as many full line pairs as there are in the pending output , removing those lines from their respective buffers.
@ secured public void add pay ( long user id , big decimal amount , date created , payment type pay type , string details , boolean update cache ) throws concurrent update sql exception , exception { check access for admin ( ) ; amount = amount . abs ( ) ; long id = universal . next seq for ( payments ) ; payment ext payment = payment ext . create system payment ( id , user id , amount , created , pay type , details ) ; big decimal new val = do payment ( user id , payment , update cache ) ; log . info ( str + user id + ( new val != null ? str + new val : str ) + str + get req info str ( ) ) ; }	positive amount . no unblocks if blocked.
public void register unregistered namespaces ( ) { for ( int i = num ; i < m unregistered extensions . size ( ) ; i ++ ) { string ns = ( string ) m unregistered extensions . get ( i ) ; extension namespace support ext ns spt = define java namespace ( ns ) ; if ( ext ns spt != null ) m extensions . add ( ext ns spt ) ; } }	attempt to register any unregistered extension namespaces .
private void remove all objects ( ) { logger . debug ( str ) ; texts . clear ( ) ; }	remove all map objects .
public builder delete display name ( ) { delete fields . add ( str ) ; return this ; }	deletes the display name of a existing user.
public static type new type ( ast ast , variable declaration declaration ) { return new type ( ast , declaration , null , null ) ; }	returns the new type node corresponding to the type of the given declaration including the extra dimensions .
public void delete ( ) throws io { close ( ) ; util . delete contents ( directory ) ; }	closes the cache and deletes all of its stored values.
private void wait for iterators cleared ( ignite cache < string , integer > cache , int secs ) throws interrupted exception { for ( int i = num ; i < secs ; i ++ ) { try { cache . size ( ) ; check iterators cleared ( ) ; } catch ( assertion failed error e ) { if ( i == num ) { for ( int j = num ; j < grid count ( ) ; j ++ ) execute on local or remote jvm ( j , new print iterator state task ( ) ) ; throw e ; } log . info ( str ) ; thread . sleep ( num ) ; } } }	checks iterators are cleared .
public void add lifecycle listener ( lifecycle listener lifecycle listener ) { if ( ! lifecycle listeners . contains ( lifecycle listener ) ) { lifecycle listeners . add ( lifecycle listener ) ; } }	adds a listener for all of this controller ' s lifecycle events.
private int index of ( string full path ) { for ( int i = num , length = this . relative paths . length ; i < length ; i ++ ) { string current relative path = this . relative paths [ i ] ; if ( current relative path == null ) continue ; string current container path = this . container paths [ i ] ; string current full path = current relative path . length ( ) == num ? current container path : ( current container path + str + current relative path ) ; if ( encloses ( current full path , full path , i ) ) return i ; } return - num ; }	returns paths list index of given path or - 1 if not found . note : use indexof ( string , string ) for path inside jars.
boolean destroy volume ( boolean force ) { na element elem = new na element ( str ) ; elem . add new child ( str , boolean . to string ( force ) ) ; elem . add new child ( str , name ) ; try { server . invoke elem ( elem ) ; return bool ; } catch ( exception e ) { string msg = str + name ; log . error ( msg , e ) ; throw new net app exception ( msg , e ) ; } }	destroys a volume , releasing all storage blocks assigned to it .
public static general path stack spline ( general path p , float [ ] pts , float epsilon , float slack , boolean closed , float tx , float ty ) { int npoints = num ; for ( ; npoints < pts . length ; ++ npoints ) if ( float . is na n ( pts [ npoints ] ) ) break ; return stack spline ( p , pts , num , npoints / num , epsilon , slack , closed , tx , ty ) ; }	computes a set of curves using the cardinal spline approach , but using straight lines for completely horizontal or vertical segments .
private boolean validate cooldown setting ( string app id , auto scaler policy trigger policy trigger , string trigger id ) { auto scaling data store state store = auto scaling data store factory . get auto scaling data store ( ) ; app auto scale state app state = null ; app state = state store . get scaling state ( app id ) ; if ( app state == null ) { return bool ; } else if ( ( app state . get instance count state ( ) != scaling state manager . scaling state completed ) && ( app state . get instance count state ( ) != scaling state manager . scaling state failed ) ) { long last start time = app state . get last action start time ( ) ; long current time = system . current time millis ( ) ; boolean time expired = ( current time - last start time ) > this . event timeout ; if ( time expired ) { logger . debug ( str + app id + str ) ; return bool ; } logger . debug ( str + app id + str ) ; return bool ; } else { long cooldown endtime = app state . get last action end time ( ) + num * get cooldown secs ( policy trigger , trigger id ) ; if ( system . current time millis ( ) < cooldown endtime ) { logger . debug ( str + app id + str ) ; return bool ; } } return bool ; }	checks if the app should be scaled in / out according to cooldown settings.
private long convert to bytes ( int mega bytes ) { long bytes = mega bytes ; bytes = bytes * num * num ; return bytes ; }	takes an int which is supposed to be in megabytes and converts it to a long.
private string generate zoneset clone name ( string zoneset to clone ) { try { thread . sleep ( num ) ; } catch ( interrupted exception ex ) { log . warn ( ex . get localized message ( ) ) ; } calendar cal = calendar . get instance ( ) ; date format date format = new simple date format ( str ) ; string date string = date format . format ( cal . get time ( ) ) ; string long name = mds . get string ( str ) ; if ( ! long name . contains ( str ) ) { return long name ; } return str + zoneset to clone + str + date string ; }	generate a unique name for the zoneset clone.
protected abstract void write signature block ( byte [ ] signature , output stream out ) throws io ;	write a . rsa file with a digital signature .
private string buffer build select query ( string schema name , string table name , array list < one row change . column spec > keys , array list < one row change . column val > key values ) { string buffer stmt = new string buffer ( ) ; stmt . append ( str ) ; stmt . append ( conn . get database object name ( schema name ) + str + conn . get database object name ( table name ) ) ; stmt . append ( str ) ; print column spec ( stmt , keys , key values , print mode . assignment , str ) ; return stmt ; }	constructs a sql statement template later used for prepared statement .
public void show ( animation anim ) { m anim = anim ; show ( ) ; }	starts the animation given as parameter .
public static boolean is uri key ( string key ) { return key . ends with ( str ) || key . ends with ( str ) ; }	this method determines if the supplied key relates to a uri .
public int receive ( byte [ ] buffer , int offset , int count , int timeout ) { check array bounds ( buffer , offset , count ) ; if ( count == num ) { return num ; } byte [ ] data = buffer ; if ( offset > num ) { data = new byte [ count ] ; } int out bytes received out = new int out ( ) ; try { i . check result ( i . idevice connection receive timeout ( get ref ( ) , data , count , bytes received out , timeout ) ) ; int bytes read = bytes received out . get value ( ) ; if ( bytes read > num && data != buffer ) { system . arraycopy ( data , num , buffer , offset , bytes read ) ; } return bytes read ; } finally { bytes received out . delete ( ) ; } }	receives data from the device.
public synchronized void add of ( of h ) { connected channel handlers . add ( h ) ; h . send role request ( this . role ) ; }	add a newly connected ofchannelhandler.
public boolean send ( byte [ ] bytes ) { if ( ! connected ) return bool ; try { output stream . write ( bytes ) ; output stream . flush ( ) ; return bool ; } catch ( io e ) { connected = bool ; log . e ( tag , str ) ; return bool ; } finally { if ( ! connected ) { close connection ( ) ; } } }	send array of bytes to bluetooth output stream .
public copy on write array list ( collection c ) { object [ ] elements = new object [ c . size ( ) ] ; int size = num ; for ( iterator itr = c . iterator ( ) ; itr . has next ( ) ; ) { object e = itr . next ( ) ; elements [ size ++ ] = e ; } set array ( elements ) ; }	creates a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
private byte [ ] entity to bytes ( http entity entity ) throws io , server error { pooling byte array output stream bytes = new pooling byte array output stream ( m pool , ( int ) entity . get content length ( ) ) ; byte [ ] buffer = null ; try { input stream in = entity . get content ( ) ; if ( in == null ) { throw new server error ( ) ; } buffer = m pool . get buf ( num ) ; int count ; while ( ( count = in . read ( buffer ) ) != - num ) { bytes . write ( buffer , num , count ) ; } return bytes . to byte array ( ) ; } finally { try { entity . consume content ( ) ; } catch ( io e ) { volley log . v ( str ) ; } m pool . return buf ( buffer ) ; bytes . close ( ) ; } }	reads the contents of httpentity into a byte [ ] .
public void add tail arg ( string arg ) { tail args . add ( arg ) ; }	adds an arg after the command and any options .
public uri ( final string namespace ) { this . namespace = namespace ; this . len = namespace . length ( ) ; }	create a handler for the supplied namespace prefix - the handler will be invoked iff it is the registered handler having the longest prefix lte to the actual uri .
private double [ ] calc variable coef ( variogram variogram , kriging point p , list < kriging point > nn ) { int n = nn . size ( ) ; double [ ] mat = new double [ n + num ] ; double dist = num ; for ( int i = num ; i < n ; i ++ ) { dist = math . sqrt ( math . abs ( math . pow ( nn . get ( i ) . x - p . x , num ) ) + math . abs ( math . pow ( nn . get ( i ) . y - p . y , num ) ) ) ; mat [ i ] = get theoretical sv ( dist , variogram ) ; } mat [ n ] = num ; return mat ; }	calculates the d matrix for kriging system.
public static object deserialization ( string file path ) { object input stream in = null ; try { in = new object input stream ( new file input stream ( file path ) ) ; object o = in . read object ( ) ; in . close ( ) ; return o ; } catch ( file not found exception e ) { throw new runtime exception ( str , e ) ; } catch ( class not found exception e ) { throw new runtime exception ( str , e ) ; } catch ( io e ) { throw new runtime exception ( str , e ) ; } finally { io . close ( in ) ; } }	deserialization object from file .
private static boolean is merged segment ( string seg name ) { if ( seg name . contains ( str ) ) { return bool ; } return bool ; }	to check if the segment is merged or not .
public static cipher parameters make pbe ( pbe key spec , int type , int hash , int key size ) { pbe generator = make pbe ( type , hash ) ; byte [ ] key ; cipher parameters param ; key = convert password ( type , key spec ) ; generator . init ( key , key spec . get salt ( ) , key spec . get iteration count ( ) ) ; param = generator . generate derived mac parameters ( key size ) ; for ( int i = num ; i != key . length ; i ++ ) { key [ i ] = num ; } return param ; }	generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .
public void add emojicon group ( list < ease emojicon group entity > group entitie list ) { for ( int i = num ; i < group entitie list . size ( ) ; i ++ ) { ease emojicon group entity group entity = group entitie list . get ( i ) ; emojicon group list . add ( group entity ) ; pager view . add emojicon group ( group entity , i == group entitie list . size ( ) - num ? bool : bool ) ; tab bar . add tab ( group entity . get icon ( ) ) ; } }	add emojicon group list.
public void update end ( logger log ) { m instance count ++ ; m sample count ++ ; double end = system . current time millis ( ) ; double temp = end - m update start ; m cumulative time += temp ; boolean to fast to measure = bool ; if ( ( end - m start time ) >= m sample time ) { compute update ( end ) ; if ( log != null ) { log . status message ( m status message prefix + str + m instance count + str + m av insts per sec / m num samples + str + ( to fast to measure ? str : str ) ) ; } m sample count = num ; m cumulative time = num ; m start time = system . current time millis ( ) ; } }	register a throughput measurement end point.
public boolean should include ( final path path ) { return include matchers . size ( ) == num || matches ( path , include matchers ) ; }	check whether a path should be included .
public array list < mech summary > generate units ( int num , unit filter filter ) { array list < mech summary > ret val = new array list < > ( ) ; for ( int i = num ; i < num ; i ++ ) { mech summary ms = generate unit ( filter ) ; if ( ms != null ) { ret val . add ( ms ) ; } } return ret val ; }	selects a number of units from the table with a filter .
static public automaton concatenate ( automaton a1 , automaton a2 ) { return concatenate ( arrays . as list ( a1 , a2 ) ) ; }	returns an automaton that accepts the concatenation of the languages of the given automata.
public void contents changed ( list data event e ) { object old selection = selected item reminder ; object new selection = data model . get selected item ( ) ; if ( old selection == null || ! old selection . equals ( new selection ) ) { selected item changed ( ) ; if ( ! selecting item ) { fire action event ( ) ; } } }	this method is public as an implementation side effect.
protected void create from h ( int [ ] h values , int partitions ) { arrays . sort ( h values ) ; this . splits = new int [ partitions ] ; int max h = num ; for ( int i = num ; i < splits . length ; i ++ ) { int quantile = ( int ) ( ( long ) ( i + num ) * h values . length / partitions ) ; this . splits [ i ] = quantile == h values . length ? max h : h values [ quantile ] ; } }	create a hilbertcurvepartitioner from a list of points.
private void read object ( object input stream oos ) throws io , class not found exception { i instant = ( local date time ) oos . read object ( ) ; date time field type type = ( date time field type ) oos . read object ( ) ; i field = type . get field ( i instant . get chronology ( ) ) ; }	reads the property from a safe serialization format .
public void test constructor i i ( ) throws exception { int sport = start server ( str ) ; ssl ssl = get ssl ( inet address . get local host ( ) , sport , inet address . get local host ( ) , num ) ; assert not null ( ssl ) ; assert equals ( sport , ssl . get port ( ) ) ; ssl . close ( ) ; try { get ssl ( inet address . get local host ( ) , num , inet address . get local host ( ) , num ) ; fail ( ) ; } catch ( io expected ) { } try { get ssl ( inet address . get local host ( ) , - num , inet address . get local host ( ) , sport + num ) ; fail ( ) ; } catch ( illegal argument exception expected ) { } try { get ssl ( inet address . get local host ( ) , sport , inet address . get local host ( ) , - num ) ; fail ( ) ; } catch ( illegal argument exception expected ) { } try { get ssl ( inet address . get local host ( ) , integer . min value , inet address . get local host ( ) , sport + num ) ; fail ( ) ; } catch ( io expected on ri ) { assert true ( standard names . is ri ) ; } catch ( illegal argument exception expected on android ) { assert false ( standard names . is ri ) ; } try { get ssl ( inet address . get local host ( ) , sport , inet address . get local host ( ) , integer . max value ) ; fail ( ) ; } catch ( illegal argument exception expected on android ) { assert false ( standard names . is ri ) ; } }	javax . net . ssl . sslsocket # sslsocket ( inetaddress address , int port , inetaddress clientaddress , int clientport ).
private string convert user input into a ( final string user input ) { if ( file utils . denotes absolute path ( user input ) ) { return user input ; } if ( user input . starts with ( home directory symbol ) ) { assert . not null ( home , str ) ; if ( user input . length ( ) > num ) { return home + user input . substring ( num ) ; } } string full path = get working directory as string ( ) + user input ; return full path ; }	if the user input starts with a tilde character ( ~ ) , replace the tilde character with the user ' s home directory.
static final int resize stamp ( int n ) { return integer . number of leading zeros ( n ) | ( num << ( resize stamp bits - num ) ) ; }	returns the stamp bits for resizing a table of size n.
public byte read byte ( ) throws io { return dis . read byte ( ) ; }	read a byte from the input stream .
protected static byte [ ] hkdf expand ( byte [ ] ikm , byte [ ] salt , byte [ ] info , int length ) throws invalid key exception , no such algorithm exception { hkdf hkdf = new hkdf ( new sh ( ) ) ; hkdf . init ( new hkdf ( ikm , salt , info ) ) ; byte [ ] okm = new byte [ length ] ; hkdf . generate bytes ( okm , num , length ) ; return okm ; }	convenience method for computing the hmac key derivation function.
public boolean is emote ignored ( emoticon emote ) { return ignored emotes . contains ( emote . code ) ; }	check if the given emote is on the list of ignored emotes.
public boolean is property allowed ( name name ) { return properties allowed . contains ( name ) ; }	is the given word the name of an allowed css property ?.
@ suppress warnings ( str ) public void read file ( string file name ) throws jdom , io { if ( check file ( file name ) ) { element root = root from name ( file name ) ; element roster ; if ( root == null ) { log . warn ( str ) ; return ; } roster = root . get child ( str ) ; if ( roster == null ) { log . debug ( str ) ; return ; } iterator < element > consist iterator = root . get descendants ( new element filter ( str ) ) ; try { element consist ; do { consist = consist iterator . next ( ) ; consist from xml ( consist ) ; } while ( consist iterator . has next ( ) ) ; } catch ( no such element exception nde ) { log . debug ( str ) ; } } else { log . info ( str ) ; } }	read all consists from a file .
public void test constructor sign bytes zero null2 ( ) { byte a bytes [ ] = { } ; int a sign = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
private int accept ( file descriptor ssfd , file descriptor newfd , inet socket address [ ] isaa ) throws io { return accept0 ( ssfd , newfd , isaa ) ; }	accept a connection on a socket .
protected void transcode ( file file , transcoder transcoder ) throws io , transcoder exception { transcoder . add transcoding hint ( xml . key xml parser validating , boolean . false ) ; svg doc = clone document ( ) ; transcoder input input = new transcoder input ( doc ) ; output stream out = new buffered output stream ( new file output stream ( file ) ) ; transcoder output output = new transcoder output ( out ) ; transcoder . transcode ( input , output ) ; out . flush ( ) ; out . close ( ) ; }	transcode a document into a file using the given transcoder .
private void report progress ( state state , inner state inner state ) { long now = system . current time millis ( ) ; if ( inner state . m bytes so far - inner state . m bytes notified > constants . min progress step && now - inner state . m time last notification > constants . min progress time ) { m info . m current bytes = inner state . m bytes so far ; m db . update download current bytes ( m info ) ; inner state . m bytes notified = inner state . m bytes so far ; inner state . m time last notification = now ; long total bytes so far = inner state . m bytes this session + m service . m bytes so far ; if ( constants . logvv ) { log . v ( constants . tag , str + m info . m current bytes + str + m info . m total bytes ) ; log . v ( constants . tag , str + total bytes so far + str + m service . m total length ) ; } m service . notify update bytes ( total bytes so far ) ; } }	report download progress through the database if necessary .
@ override public document new document ( ) { return new mf . org . apache . xerces . dom . document impl ( ) ; }	non - preferred : use the getdomimplementation ( ) method instead of this one to get a dom level 2 domimplementation object and then use dom level 2 methods to create a dom document object .
@ hle ( nid = num , version = num , check inside interrupt = bool ) public int sce sas set grain ( int sas core , int grain ) { check sas handle good ( sas core ) ; grain samples = grain ; return num ; }	set the number of samples generated by one __scesascore call .
public void handle tbl request handler list button add request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; scsam soap vb = ( scsam soap ) get view bean ( scsam soap . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles add request handler request .
protected static void draw data point ( double x , double y , double xprev , double yprev , int size , int shape , graphics gx ) { draw data point ( x , y , size , shape , gx ) ; gx . draw line ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }	draws a data point at a given set of panel coordinates at a given size and connects a line to the previous point .
static boolean chunk set ( internal distributed member recipient , set set , int chunk size in bytes , boolean include values , object int procedure proc ) throws io { iterator it = set . iterator ( ) ; boolean keep going = bool ; boolean sent last chunk = bool ; final heap data output stream mos = new heap data output stream ( initial image operation . chunk size in bytes + num , recipient . get version object ( ) ) ; do { mos . reset ( ) ; int avg item size = num ; int item count = num ; while ( ( mos . size ( ) + avg item size ) < initial image operation . chunk size in bytes && it . has next ( ) ) { object key = it . next ( ) ; data serializer . write object ( key , mos ) ; item count ++ ; avg item size = mos . size ( ) / item count ; } data serializer . write object ( ( object ) null , mos ) ; int last msg = it . has next ( ) ? num : num ; keep going = proc . execute with ( mos , last msg ) ; sent last chunk = last msg == num && keep going ; } while ( keep going && it . has next ( ) ) ; return sent last chunk ; }	serialize the given set ' s elments into byte [ ] chunks , calling proc for each one.
private int [ ] parse meta data information ( ) throws user error { int [ ] selected columns = new int [ meta data . size ( ) ] ; set < string > used column names = new hash set < > ( ) ; int column index = num ; int used column index = num ; for ( column meta data column : meta data ) { if ( ! column . is removed ( ) ) { selected columns [ used column index ] = column index ; used column index ++ ; string column name = column . get name ( ) ; if ( ! used column names . contains ( column name ) ) { used column names . add ( column name ) ; } else { throw new user error ( null , str , column name ) ; } } column index ++ ; } int [ ] attribute columns = arrays . copy of ( selected columns , used column index ) ; return attribute columns ; }	goes once through the metadata , checks which columns are removed and checks that the remaining columns have unique names .
static field find field ( object instance , string name ) throws no such field exception { for ( class < ? > clazz = instance . get class ( ) ; clazz != null ; clazz = clazz . get superclass ( ) ) { try { field field = clazz . get declared field ( name ) ; if ( ! field . is accessible ( ) ) { field . set accessible ( bool ) ; } return field ; } catch ( no such field exception e ) { } } throw new no such field exception ( str + name + str + instance . get class ( ) ) ; }	locates a given field anywhere in the class inheritance hierarchy .
ssl to session ( byte [ ] data , string host , int port ) { byte array input stream bais = new byte array input stream ( data ) ; data input stream dais = new data input stream ( bais ) ; try { int type = dais . read int ( ) ; if ( type != open ssl ) { log ( new assertion error ( str + type ) ) ; return null ; } int length = dais . read int ( ) ; byte [ ] session data = new byte [ length ] ; dais . read fully ( session data ) ; int count = dais . read int ( ) ; x509 certificate [ ] certs = new x509 certificate [ count ] ; for ( int i = num ; i < count ; i ++ ) { length = dais . read int ( ) ; byte [ ] cert data = new byte [ length ] ; dais . read fully ( cert data ) ; certs [ i ] = ssl . from x509 der ( cert data ) ; } return new ssl ( session data , host , port , certs , this ) ; } catch ( io e ) { log ( e ) ; return null ; } }	creates a session from the given bytes .
private void add dump file ( ) { add dump file ( dump file ) ; }	add the set dumpfilestream to the tree.
private static boolean date by ordinal ( date time formatter builder bld , collection < date time field type > fields , boolean extended , boolean strict iso ) { boolean reduced prec = bool ; if ( fields . remove ( date time field type . year ( ) ) ) { bld . append ( year element ( ) ) ; if ( fields . remove ( date time field type . day of year ( ) ) ) { append separator ( bld , extended ) ; bld . append day of year ( num ) ; } else { reduced prec = bool ; } } else if ( fields . remove ( date time field type . day of year ( ) ) ) { bld . append literal ( str ) ; bld . append day of year ( num ) ; } return reduced prec ; }	creates a date using the ordinal date format.
public boolean is page in range ( int page number ) { for ( int ind = num ; ind < sequence starts . size ( ) ; ind ++ ) { if ( sequence starts . get ( ind ) <= page number && page number <= sequence ends . get ( ind ) ) return bool ; } return bool ; }	checks if a given page is present in the range built so far .
public void dispose ( ) { log debug ( str ) ; m setup done = bool ; if ( m service conn != null ) { log debug ( str ) ; if ( m context != null ) m context . unbind service ( m service conn ) ; } m disposed = bool ; m context = null ; m service conn = null ; m service = null ; m purchase listener = null ; }	dispose of object , releasing resources.
@ suppress warnings ( str ) public static < t extends dimensional item object > list < t > as typed list ( collection < dimensional item object > collection ) { list < t > list = new array list < > ( ) ; if ( collection != null ) { for ( dimensional item object object : collection ) { list . add ( ( t ) object ) ; } } return list ; }	returns a list typed with the desired erasure based on the given collection.
public put index template request aliases ( x source ) { return aliases ( source . bytes ( ) ) ; }	sets the aliases that will be associated with the index when it gets created.
void add new table ( string name , int tdef page number , short type , string linked db name , string linked table name ) throws io { add table ( name , integer . value of ( tdef page number ) , type , linked db name , linked table name ) ; add to system catalog ( name , tdef page number , type , linked db name , linked table name , table parent id ) ; add to access control entries ( tdef page number , table parent id , new table si ) ; }	adds a newly created table to the relevant internal database structures .
public void remove listener ( @ not null configuration listener listener ) { if ( my listeners != null ) { my listeners . remove ( listener ) ; if ( my listeners . is empty ( ) ) { my listeners = null ; } } }	removes a listener such that it is no longer notified of changes.
void reclaim scrap views ( list < view > views ) { if ( m view type count == num ) { views . add all ( m current scrap ) ; } else { final int view type count = m view type count ; final array list < view > [ ] scrap views = m scrap views ; for ( int i = num ; i < view type count ; ++ i ) { final array list < view > scrap pile = scrap views [ i ] ; views . add all ( scrap pile ) ; } } }	puts all views in the scrap heap into the supplied list .
public void do window open ( ) { do connect ( ) ; }	this method is fired after the tab has been created and placed in the tab controller .
public boolean schedule ( runnable task , class loader loader ) { boolean is priority = bool ; boolean is queue = bool ; boolean is wake = bool ; return schedule impl ( task , loader , max expire , is priority , is queue , is wake ) ; }	schedules a new task .
public static int hash2 ( int hash , object x , object y ) { return num | ( hash + num * system . identity hash code ( x ) + num * system . identity hash code ( y ) ) ; }	utility method to combine a base hash with the identity hash of one or more objects .
public static double [ ] parse vector string ( string vector string ) { string [ ] parsed string = vector string . split ( str ) ; double [ ] vector = new double [ parsed string . length ] ; for ( int j = num ; j < parsed string . length ; j ++ ) { double val = utils . double parsable ( parsed string [ j ] ) ; vector [ j ] = double . is na n ( val ) ? num : val ; } return vector ; }	converts a string representation of a vector ( e.
public string global info ( ) { return str + str + str + str + str + str ; }	returns a string describing this filter.
public static < t > stream < t > concat ( stream < ? extends t > a , stream < ? extends t > b ) { objects . require non null ( a ) ; objects . require non null ( b ) ; @ suppress warnings ( str ) spliterator < t > split = new streams . concat spliterator . of ref < > ( ( spliterator < t > ) a . spliterator ( ) , ( spliterator < t > ) b . spliterator ( ) ) ; stream < t > stream = stream support . stream ( split , a . is parallel ( ) || b . is parallel ( ) ) ; return stream . on close ( streams . composed close ( a , b ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
public void find and init ( iterator it ) { while ( it . has next ( ) ) { find and init ( it . next ( ) ) ; } }	the method called by beancontextmembershiplistener methods to find components in the maphandler .
public static data source properties interface decode xml ( document document , string element name ) { if ( ( document == null ) || ( element name == null ) ) { return null ; } map < string , string > map = new linked hash map < string , string > ( ) ; node list node list = document . get elements by tag name ( element name ) ; if ( node list . get length ( ) > num ) { node node = node list . item ( num ) ; node child = node . get first child ( ) ; while ( child != null ) { if ( child . get node type ( ) == node . element node ) { map . put ( child . get node name ( ) , child . get text content ( ) ) ; } child = child . get next sibling ( ) ; } return data source connector factory . get data source properties ( map ) ; } else { return data source connector factory . get no data source ( ) ; } }	decode the data source properties from xml .
@ override public char next ( ) { ++ doc pos ; if ( doc pos < segment end || segment end >= doc . get length ( ) ) { return text . next ( ) ; } try { doc . get text ( segment end , doc . get length ( ) - segment end , text ) ; } catch ( bad location exception e ) { throw new runtime exception ( e ) ; } segment end += text . count ; return text . current ( ) ; }	increments the iterator ' s index by one and returns the character at the new index .
private void adjust row heights ( j table ) { for ( int row = num ; row < table . get row count ( ) ; row ++ ) { int row height = table . get row height ( ) ; for ( int column = num ; column < table . get column count ( ) ; column ++ ) { component comp = table . prepare renderer ( table . get cell renderer ( row , column ) , row , column ) ; row height = math . max ( row height , comp . get preferred size ( ) . height ) ; } table . set row height ( row , row height ) ; } }	adjust the row heights of a table based on the table contents .
public list < uri > volume ur ( list < uri > uris , boolean delete , boolean remediate , val ck ... checks ) { list < uri > remediated ur = new array list < uri > ( ) ; list < volume > volumes = db client . query object ( volume . class , uris ) ; list < volume > remediated volumes = volumes ( volumes , delete , remediate , checks ) ; for ( volume volume : remediated volumes ) { remediated ur . add ( volume . get id ( ) ) ; } return remediated ur ; }	validates a list of volumes.
private format string [ ] parse ( string s ) { array list < format string > al = new array list < > ( ) ; matcher m = fs pattern . matcher ( s ) ; for ( int i = num , len = s . length ( ) ; i < len ; ) { if ( m . find ( i ) ) { if ( m . start ( ) != i ) { check text ( s , i , m . start ( ) ) ; al . add ( new fixed string ( s . substring ( i , m . start ( ) ) ) ) ; } al . add ( new format specifier ( m ) ) ; i = m . end ( ) ; } else { check text ( s , i , len ) ; al . add ( new fixed string ( s . substring ( i ) ) ) ; break ; } } return al . to array ( new format string [ al . size ( ) ] ) ; }	finds format specifiers in the format string .
private void update index column buttons ( ) { index remove button . set enabled ( bool ) ; index up button . set enabled ( bool ) ; index down button . set enabled ( bool ) ; int index = selected columns . get selection index ( ) ; if ( index >= num ) { index remove button . set enabled ( bool ) ; if ( index > num ) { index up button . set enabled ( bool ) ; } else if ( index < selected columns . get item count ( ) - num ) { index down button . set enabled ( bool ) ; } } }	updates status of index column up / down buttons .
public string url for poi ( string tag , bounding box bb , int limit , int timeout ) { string builder s = new string builder ( ) ; s . append ( m service + str ) ; string s bb = str + bb . get lat south ( ) + str + bb . get lon west ( ) + str + bb . get lat north ( ) + str + bb . get lon east ( ) + str ; string data = str + timeout + str + str + tag + str + s bb + str + str + tag + str + s bb + str + str + tag + str + s bb + str + str + limit + str ; log . d ( bonus pack helper . log tag , str + data ) ; s . append ( url . encode ( data ) ) ; return s . to string ( ) ; }	build the url to search for elements having a specific osm tag ( key = value ) , within a bounding box.
public void wait for decoding to finish ( ) { while ( is decoding ) { try { thread . sleep ( num ) ; } catch ( final interrupted exception e ) { log writer . write log ( str + e . get message ( ) ) ; is decoding = bool ; } } }	wait for decoding to finish.
private static string wiki to plain text ( string content ) { content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . replace all ( str , str ) ; content = content . trim ( ) ; final int size = content . length ( ) ; int end of first paragraph = content . index of ( str , num ) ; if ( end of first paragraph < num ) { end of first paragraph = size ; } content = content . substring ( num , math . min ( end of first paragraph , num ) ) ; return content ; }	extract plain text from wikipedia article content .
public final byte [ ] update ( byte [ ] input ) { if ( mode != encrypt mode && mode != decrypt mode ) { throw new illegal state exception ( ) ; } if ( input == null ) { throw new illegal argument exception ( str ) ; } if ( input . length == num ) { return null ; } return spi impl . engine update ( input , num , input . length ) ; }	continues a multi - part transformation ( encryption or decryption ).
private static int create packed params ( d sg2d , glyph list gl ) { return ( ( ( gl . use positions ( ) ? num : num ) << offset positions ) | ( ( gl . is sub pix pos ( ) ? num : num ) << offset subpixpos ) | ( ( gl . is rgb ( ) ? num : num ) << offset rgborder ) | ( ( sg2d . lcd text contrast & num ) << offset contrast ) ) ; }	packs the given parameters into a single int value in order to save space on the rendering queue.
public static int update ( string sql , object [ ] args ) { connection c = null ; prepared statement p = null ; try { c = get connection ( ) ; if ( c == null ) return - num ; p = c . prepare statement ( sql ) ; int order = num ; if ( args != null ) { for ( int i = num ; i < args . length ; i ++ ) { object o = args [ i ] ; set parameter ( p , order ++ , o ) ; } } return p . execute update ( ) ; } catch ( exception e ) { if ( log . is error enabled ( ) ) log . error ( sql + to string ( args ) , e ) ; } finally { close ( p , c ) ; } return num ; }	update the data using the sql sentence .
public boolean is lock subject ( ) { return bool ; }	if entryholder is used as lockobject ( for example in all_in_cache ) - its the lock subject itself.
@ override public int hash code ( ) { int code = num ; if ( f public id != null ) { code += f public id . hash code ( ) ; } if ( f literal system id != null ) { code += f literal system id . hash code ( ) ; } if ( f base system id != null ) { code += f base system id . hash code ( ) ; } if ( f expanded system id != null ) { code += f expanded system id . hash code ( ) ; } if ( f namespace != null ) { code += f namespace . hash code ( ) ; } return code ; }	returns a hash code for this object .
public quick action view add action ( action action ) { check shown ( ) ; m actions . add ( action ) ; return this ; }	adds an action to the quickactionview.
protected boolean display ( file help file ) throws help exception { if ( help file . exists ( ) ) { load and write ( help file ) ; return bool ; } else { file not found = new file ( help dir , not found ) ; if ( not found . exists ( ) ) load and write ( not found ) ; else throw new help exception ( str ) ; return bool ; } }	displays the requested help file if it is found.
public static void store location ( context context , lat lng location ) { shared preferences prefs = preference manager . get default shared preferences ( context ) ; shared preferences . editor editor = prefs . edit ( ) ; editor . put long ( preferences lat , double . double to raw long bits ( location . latitude ) ) ; editor . put long ( preferences lng , double . double to raw long bits ( location . longitude ) ) ; editor . apply ( ) ; }	store the location in the app preferences .
public d either ( ) { return best1 ; }	returns one of the points in the closest pair of points .
@ override public boolean equals ( object object ) { if ( this == object ) { return bool ; } if ( object instanceof list ) { list < ? > list = ( list < ? > ) object ; if ( list . size ( ) != size ( ) ) { return bool ; } iterator < ? > it1 = iterator ( ) , it2 = list . iterator ( ) ; while ( it1 . has next ( ) ) { object e1 = it1 . next ( ) , e2 = it2 . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return bool ; } } return bool ; } return bool ; }	compares the specified object to this list and return true if they are equal.
public static string row to string ( json ja ) { string buffer sb = new string buffer ( ) ; for ( int i = num ; i < ja . length ( ) ; i += num ) { if ( i > num ) { sb . append ( str ) ; } object object = ja . opt ( i ) ; if ( object != null ) { string string = object . to string ( ) ; if ( string . length ( ) > num && ( string . index of ( str ) >= num || string . index of ( str ) >= num || string . index of ( str ) >= num || string . index of ( num ) >= num || string . char at ( num ) == str ) ) { sb . append ( str ) ; int length = string . length ( ) ; for ( int j = num ; j < length ; j += num ) { char c = string . char at ( j ) ; if ( c >= str && c != str ) { sb . append ( c ) ; } } sb . append ( str ) ; } else { sb . append ( string ) ; } } } sb . append ( str ) ; return sb . to string ( ) ; }	produce a comma delimited text row from a jsonarray.
private static void remove table ( connection conn , string name ) throws sql { name = name . replace ( str , str ) ; statement stat = conn . create statement ( ) ; stat . execute ( str + name ) ; db . commit el ( conn ) ; }	remove a table from the memory database.
public boolean contains category ( string category ) { return ! hidden bug category set . contains ( category ) ; }	returns false if the given category is hidden in the project filter settings .
public static boolean is volume full copy source ( volume volume , db client db client ) { boolean is full copy source = bool ; string set full copy ids = volume . get full copies ( ) ; if ( ( full copy ids != null ) && ( ! full copy ids . is empty ( ) ) ) { iterator < string > full copy ids iter = full copy ids . iterator ( ) ; while ( full copy ids iter . has next ( ) ) { uri full copy uri = uri . create ( full copy ids iter . next ( ) ) ; volume full copy volume = db client . query object ( volume . class , full copy uri ) ; if ( ( full copy volume != null ) && ( ! full copy volume . get inactive ( ) ) ) { is full copy source = bool ; } } } return is full copy source ; }	determine if the passed volume is a source volume for any full copies .
@ override public void assert equals ( string message , object expected obj , object actual obj ) { linear regression model expected = ( linear regression model ) expected obj ; linear regression model actual = ( linear regression model ) actual obj ; message = message + str + actual . get source ( ) + str ; assert . assert array equals ( message + str , expected . get coefficients ( ) , actual . get coefficients ( ) , num ) ; assert . assert array equals ( message + str , expected . get probabilities ( ) , actual . get probabilities ( ) , num ) ; assert . assert array equals ( message + str , expected . get selected attribute names ( ) , actual . get selected attribute names ( ) ) ; assert . assert array equals ( message + str , expected . get selected attributes ( ) , actual . get selected attributes ( ) ) ; assert . assert array equals ( message + str , expected . get standard errors ( ) , actual . get standard errors ( ) , num ) ; assert . assert array equals ( message + str , expected . get standardized coefficients ( ) , actual . get standardized coefficients ( ) , num ) ; assert . assert array equals ( message + str , expected . get tolerances ( ) , actual . get tolerances ( ) , num ) ; assert . assert array equals ( message + str , expected . get t ( ) , actual . get t ( ) , num ) ; }	tests two linearregression models by comparing all values.
public static map < string , object > entity maint perm check ( dispatch context dctx , map < string , ? extends object > context ) { generic value user login = ( generic value ) context . get ( str ) ; locale locale = ( locale ) context . get ( str ) ; security security = dctx . get security ( ) ; map < string , object > result map = null ; if ( security . has permission ( str , user login ) ) { result map = service util . return success ( ) ; result map . put ( str , bool ) ; } else { result map = service util . return failure ( util properties . get message ( resource , str , locale ) ) ; result map . put ( str , bool ) ; } return result map ; }	performs an entity maintenance security check.
public void test quorum succeed ( ) { quorum . succeed ( ) ; quorum . fail ( ) ; assert equals ( callback result . get ( ) , num ) ; quorum . fail ( ) ; quorum . succeed ( ) ; assert equals ( callback result . get ( ) , num ) ; }	tests a successful quorum .
public void request after explanation ( @ non null string [ ] permissions ) { array list < string > permissions to request = new array list < > ( ) ; for ( string permission name : permissions ) { if ( is permission declined ( permission name ) ) { permissions to request . add ( permission name ) ; } else { permission callback . on permission pre granted ( permission name ) ; } } if ( permissions to request . is empty ( ) ) return ; permissions = permissions to request . to array ( new string [ permissions to request . size ( ) ] ) ; context . request permissions ( permissions , request permissions ) ; }	to be called when explanation is presented to the user.
static void pause thread ( long duration ) { try { thread . sleep ( duration ) ; } catch ( exception e ) { s logger . warn ( str , e ) ; } }	simple puts the thread to sleep for the passed duration .
final public void println ( string v ) { try { out . println ( v ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	writes a string followed by a newline .
public int read ( char cbuf [ ] , int offset , int length ) throws io { return sd . read ( cbuf , offset , length ) ; }	reads characters into a portion of an array .
public int read ( ) throws io { int val ; if ( ( val = is . read ( ) ) < num ) { return - num ; } switch ( val & num ) { case num : case num : val = ( ( val & num ) << num ) | ( is . read ( ) & num ) ; break ; case num : val = ( ( val & num ) << num ) | ( ( is . read ( ) & num ) << num ) | ( is . read ( ) & num ) ; break ; case num : throw new unsupported encoding exception ( ) ; default : break ; } return val ; }	reads a single character .
private static boolean v ( jni env , int obj jref , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , type reference . boolean , bool ) ; return reflection . unwrap boolean ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return bool ; } }	callnonvirtualbooleanmethodv : invoke a virtual method that returns a boolean value.
private boolean r contains rm ( program block pb , string var name ) { if ( pb instanceof while program block ) { while program block tmp = ( while program block ) pb ; for ( program block c : tmp . get child blocks ( ) ) if ( r contains rm ( c , var name ) ) return bool ; } else if ( pb instanceof if program block ) { if program block tmp = ( if program block ) pb ; for ( program block c : tmp . get child blocks if body ( ) ) if ( r contains rm ( c , var name ) ) return bool ; for ( program block c : tmp . get child blocks else body ( ) ) if ( r contains rm ( c , var name ) ) return bool ; } else if ( pb instanceof for program block ) { for program block tmp = ( for program block ) pb ; for ( program block c : tmp . get child blocks ( ) ) if ( r contains rm ( c , var name ) ) return bool ; } else if ( pb instanceof function program block ) { } else { for ( instruction inst : pb . get instructions ( ) ) { string inst str = inst . to string ( ) ; if ( inst str . contains ( str + lop . operand delimitor + var name ) || inst str . contains ( str + lop . operand delimitor + var name ) ) { return bool ; } } } return bool ; }	determines if the given program block includes a rmvar or rmfilevar instruction for the given varname .
public project importer ( final file root folder ) { assert not null ( str , root folder ) ; assert true ( str + root folder , root folder . exists ( ) ) ; assert true ( str + root folder , root folder . is directory ( ) ) ; assert true ( str + root folder , root folder . can read ( ) ) ; assert true ( str + root folder , null != root folder . list files ( ) ) ; this . root folder = root folder ; }	creates a project importer with the root folder of all projects that has to be imported for the test .
public void test doubles ( ) throws exception { double [ ] values = new double [ ] { double . negative infinity , - num , - num , - num , - num , - num , - num , + num , num , num , num , num , num , double . positive infinity , double . n } ; long [ ] encoded = new long [ values . length ] ; for ( int i = num ; i < values . length ; i ++ ) { encoded [ i ] = numeric utils . double to sortable long ( values [ i ] ) ; assert true ( str , double . compare ( values [ i ] , numeric utils . sortable long to double ( encoded [ i ] ) ) == num ) ; } for ( int i = num ; i < encoded . length ; i ++ ) { assert true ( str , encoded [ i - num ] < encoded [ i ] ) ; } }	check various sorted values of doubles ( including extreme values ) check for correct ordering of the encoded bytes and that values round - trip .
public static boolean is registered ( class < ? > clazz ) { return reg modules . contains key ( clazz . get name ( ) ) ; }	has this class already been registered .
public class < ? > load class ( string name ) throws class not found exception { return class . for name ( name ) ; }	return the class with the given name .
public void wait for operations ( ) { operator . wait for operations ( ) ; }	wait for the bucket operator to complete any pending asynchronous operations .
protected boolean is all test components in target ( geometry test geom ) { list coords = component coordinate extracter . get coordinates ( test geom ) ; for ( iterator i = coords . iterator ( ) ; i . has next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = target point locator . locate ( p ) ; if ( loc == location . exterior ) return bool ; } return bool ; }	tests whether all components of the test geometry are contained in the target geometry.
private object create inner ( simple object post , request context context ) throws response exception { try { string xml = complete xform ( convert uuids to ids ( post ) ) ; file file = file . create temp file ( str , null ) ; processor . process x ( xml , file . get absolute path ( ) , bool , context . get request ( ) ) ; } catch ( io e ) { throw new generic rest exception ( str , e ) ; } catch ( response exception e ) { throw e ; } catch ( exception e ) { throw new conversion exception ( str , e ) ; } encounter encounter = guess encounter from xform submission ( post ) ; if ( encounter == null ) { return post ; } simple object return json = new simple object ( ) ; encounter resource . populate json properties ( encounter , return json ) ; return return json ; }	accepts a submitted form instance .
public endpoint ( uri endpoint url , security mode ... modes ) { if ( modes == null || endpoint url == null ) throw new illegal argument exception ( str ) ; for ( security mode m : modes ) { if ( m == null ) throw new illegal argument exception ( str ) ; hash = num * hash + m . hash code ( ) ; } this . endpoint url = endpoint url . to string ( ) ; this . modes = modes ; this . endpoint configuration = endpoint configuration . defaults ( ) ; hash = num * hash + endpoint url . hash code ( ) ; }	create a new endpoint .
protected value parse value ( ) throws io , rdf , rdf { int c = peek code point ( ) ; if ( c == str ) { return parse uri ( ) ; } else if ( c == str || turtle util . is prefix start char ( c ) ) { return parse q ( ) ; } else if ( c == str ) { return parse node id ( ) ; } else if ( c == str || c == str ) { return parse quoted literal ( ) ; } else if ( ascii . is number ( c ) || c == str || c == str || c == str ) { return parse number ( ) ; } else if ( c == - num ) { throw eof ( ) ; return null ; } else { report fatal error ( str + new string ( character . to chars ( c ) ) + str ) ; return null ; } }	parses an rdf value.
public time series collection ( ) { this ( null , time zone . get default ( ) ) ; }	constructs an empty dataset , tied to the default timezone .
public static < e > list < e > of ( e e1 , e e2 , e e3 ) { list < e > list = new array list < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; list . add ( e3 ) ; return list ; }	returns a list of the given elements , in order .
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { byte [ ] aux = new byte [ len + block size ] ; system . arraycopy ( array , num , aux , num , len ) ; array = aux ; } n += size ; return index ; }	this is to implement memory allocation in the array.
@ override public void add attribute ( string name , float value ) { string str = float . to string ( value ) ; if ( str . ends with ( str ) ) str = str . substring ( num , str . length ( ) - num ) ; current . set attribute ( name , str ) ; }	adds an attribute to current element of the dom document .
@ request mapping ( value = str , method = request method . post ) @ response body public json response create directory ( @ path variable final string container id , @ path variable final string application name , @ request param ( str ) string path ) throws service exception , check exception , io { if ( logger . is debug enabled ( ) ) { logger . debug ( str + container id ) ; logger . debug ( str + application name ) ; logger . debug ( str + path ) ; } file service . create directory ( application name , container id , path ) ; return new http ok ( ) ; }	create resources ( files and folders ) into a container for a path.
public void fill ellipse arr ( pla ellipse [ ] p ellipse arr , graphics p g , color p color , double p translucency factor ) { if ( p color == null ) return ; if ( p ellipse arr . length <= num ) return ; general path draw path = new general path ( general path . wind even odd ) ; for ( pla ellipse curr ellipse : p ellipse arr ) { d center = coordinate transform . board to screen ( curr ellipse . center ) ; double bigger radius = coordinate transform . board to screen ( curr ellipse . bigger radius ) ; if ( ! point near rectangle ( center . get x ( ) , center . get y ( ) , ( rectangle ) p g . get clip ( ) , bigger radius ) ) { continue ; } double smaller radius = coordinate transform . board to screen ( curr ellipse . smaller radius ) ; d draw ellipse = new d . double ( center . get x ( ) - bigger radius , center . get y ( ) - smaller radius , num * bigger radius , num * smaller radius ) ; double rotation = coordinate transform . board to screen angle ( curr ellipse . rotation ) ; affine transform affine transform = new affine transform ( ) ; affine transform . rotate ( rotation , center . get x ( ) , center . get y ( ) ) ; shape rotated ellipse = affine transform . create transformed shape ( draw ellipse ) ; draw path . append ( rotated ellipse , bool ) ; } d g2 = ( d ) p g ; g2 . set color ( p color ) ; set translucency ( g2 , p translucency factor ) ; g2 . set rendering hint ( rendering hints . key antialiasing , rendering hints . value antialias on ) ; g2 . fill ( draw path ) ; }	draws the interiour of an array of ellipses.
@ override public void zoom domain axes ( double factor , plot rendering info state , d source ) { }	multiplies the range on the domain axis / axes by the specified factor .
private void refresh challenge counts ( ) { m due challenge counts = m due challenge logic . get due challenge counts ( m categories ) ; }	reloads the due challenge counts from the database .
public identity ( final int dim ) { this ( dim , enum set . none of ( address . flags . class ) ) ; }	creates an identity matrix.
private image data awt to swt ( final buffered image buffered image , final int width , final int height ) { final int [ ] awt pixels = new int [ width * height ] ; final image data swt image data = new image data ( width , height , num , palette data ) ; swt image data . transparent pixel = transparent color ; final int step = swt image data . depth / num ; final byte [ ] data = swt image data . data ; buffered image . get rgb ( num , num , width , height , awt pixels , num , width ) ; for ( int i = num ; i < height ; i ++ ) { int idx = ( num + i ) * swt image data . bytes per line + num * step ; for ( int j = num ; j < width ; j ++ ) { final int rgb = awt pixels [ j + i * width ] ; for ( int k = swt image data . depth - num ; k >= num ; k -= num ) { data [ idx ++ ] = ( byte ) ( rgb > > k & num ) ; } } } return swt image data ; }	transform a java2d bufferedimage to a swt image .
public static boolean is unlimited strength policy available ( ) { try { return cipher . get max allowed key length ( str ) >= num ; } catch ( final no such algorithm exception e ) { e . print stack trace ( ) ; } return bool ; }	helper method to check whether the jvm has the unlimited strength policy installed.
public long rsslim ( ) { return long . parse long ( fields [ num ] ) ; }	current soft limit in bytes on the rss of the process ; see the description of rlimit_rss in getrlimit ( 2 ) .
public void add totals ( info column [ ] layout ) { add totals ( ( column info [ ] ) layout ) ; }	adding a new row with the totals.
private void fill stack trace ( string buffer buffer , stack trace element [ ] elements ) { for ( int index = num ; index < elements . length ; index ++ ) { buffer . append ( elements [ index ] ) ; buffer . append ( str ) ; } }	creates a printing stacktrace from the given elements .
public static boolean is file type supported ( int file type ) { list providers = get midi file writers ( ) ; for ( int i = num ; i < providers . size ( ) ; i ++ ) { midi file writer writer = ( midi file writer ) providers . get ( i ) ; if ( writer . is file type supported ( file type ) ) { return bool ; } } return bool ; }	indicates whether file writing support for the specified midi file type is provided by the system .
public void make immutable ( ) { if ( is mutable ) { is mutable = bool ; } }	makes this object immutable .
public static double uniform ( ) { return random . next double ( ) ; }	returns a random real number uniformly in [ 0 , 1 ) .
private am ds ( ) { map map = services default values . get default values ( ) ; ds manager = ( string ) map . get ( setup constants . config var ds mgr dn ) ; suffix = ( string ) map . get ( setup constants . config var root suffix ) ; ds host name = ( string ) map . get ( setup constants . config var directory server host ) ; ds port = ( string ) map . get ( setup constants . config var directory server port ) ; ds admin pwd = ( string ) map . get ( setup constants . config var ds mgr pwd ) ; basedir = ( string ) map . get ( setup constants . config var base dir ) ; deployuri = ( string ) map . get ( setup constants . config var server uri ) ; }	constructs a new instance .
private boolean compare and increment worker count ( int expect ) { return ctl . compare and set ( expect , expect + num ) ; }	attempts to cas - increment the workercount field of ctl .
private void make items ( int finger position , list < view > view list ) { if ( finger position >= view list . size ( ) ) { return ; } for ( int i = num ; i < view list . size ( ) ; i ++ ) { int translation y = math . min ( math . max ( math . abs ( finger position - i ) * interval height , num ) , max translation height ) ; update item height animator ( view list . get ( i ) , translation y ) ; } }	calculates every icon ' s height needed and start animation.
private boolean path is windows ( string path ) { if ( path != null && path . length ( ) > num ) { return ( character . is letter ( path . char at ( num ) ) && path . char at ( num ) == str ) || ( path . starts with ( str ) || path . starts with ( str ) ) ; } return bool ; }	returns true if the path is on windows .
object process char ( stylesheet handler handler , string uri , string name , string raw name , string value , elem template element owner ) throws org . xml . sax . sax { if ( get supports avt ( ) ) { try { avt avt = new avt ( handler , uri , name , raw name , value , owner ) ; if ( ( avt . is simple ( ) ) && ( value . length ( ) != num ) ) { handle error ( handler , xslt . invalid tchar , new object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } } else { if ( value . length ( ) != num ) { handle error ( handler , xslt . invalid tchar , new object [ ] { name , value } , null ) ; return null ; } return new character ( value . char at ( num ) ) ; } }	process an attribute string of type t_char into a character value .
public static element add child element value ( element element , string child element name , string child element value , document document ) { element new element = add child element ( element , child element name , document ) ; new element . append child ( document . create text node ( child element value ) ) ; return new element ; }	creates a child element with the given name and appends it to the element child node list.
public boolean is segment balanced ( ) { if ( m lines . size ( ) == num || m doc . is multi currency ( ) ) return bool ; m [ ] elements = m acct schema . get acct schema elements ( ) ; for ( int i = num ; i < elements . length ; i ++ ) { m ase = elements [ i ] ; if ( ase . is balanced ( ) && ! is segment balanced ( ase . get element type ( ) ) ) return bool ; } return bool ; }	are all segments balanced.
attributes parse attributes ( ) throws jasper exception { attributes impl attrs = new attributes impl ( ) ; reader . skip spaces ( ) ; while ( parse attribute ( attrs ) ) reader . skip spaces ( ) ; return attrs ; }	attributes : : = ( s attribute ) * s ?.
public static byte [ ] read binary file ( file source file ) { byte [ ] result = null ; try { buffered input stream input ; input = new buffered input stream ( new file input stream ( source file ) ) ; int num = input . available ( ) ; result = new byte [ num ] ; input . read ( result , num , num ) ; input . close ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; result = null ; } return result ; }	reads a binary input file into a byte array.
@ suppress warnings ( str ) public void test stream api ( ) { final list < i > expected solutions = new array list < i > ( ) ; { final i expected = new list binding set ( ) ; expected . set ( var . var ( str ) , new constant < iv > ( term id ) ) ; expected solutions . add ( expected ) ; } { final i expected = new list binding set ( ) ; expected . set ( var . var ( str ) , new constant < iv > ( term id ) ) ; expected . set ( var . var ( str ) , new constant < iv > ( blob iv ) ) ; expected solutions . add ( expected ) ; } do encode decode test ( expected solutions ) ; }	unit test of the stream - oriented api .
public void add term ( split condition condition ) { terms . add ( condition ) ; }	this method adds a condition to the conjunction in the rule ' s head.
@ override protected void threshold reached ( ) throws io { if ( prefix != null ) { output file = file . create temp file ( prefix , suffix , directory ) ; } file output stream fos = new file output stream ( output file ) ; memory output stream . write to ( fos ) ; current output stream = fos ; memory output stream = null ; }	switches the underlying output stream from a memory based stream to one that is backed by disk.
public void remove index interval ( int index0 , int index1 ) { int rm min index = math . min ( index0 , index1 ) ; int rm max index = math . max ( index0 , index1 ) ; int gap length = ( rm max index - rm min index ) + num ; for ( int i = rm min index ; i <= max index ; i ++ ) { set state ( i , value . get ( i + gap length ) ) ; } int lead index = this . lead index ; if ( lead index == num && rm min index == num ) { } else if ( lead index > rm max index ) { lead index = this . lead index - gap length ; } else if ( lead index >= rm min index ) { lead index = rm min index - num ; } int anchor index = this . anchor index ; if ( anchor index == num && rm min index == num ) { } else if ( anchor index > rm max index ) { anchor index = this . anchor index - gap length ; } else if ( anchor index >= rm min index ) { anchor index = rm min index - num ; } if ( lead index != this . lead index || anchor index != this . anchor index ) { update lead anchor indices ( anchor index , lead index ) ; } fire value changed ( ) ; }	remove the indices in the interval index0 , index1 ( inclusive ) from the selection model.
public void rebuild event list ( boolean reset selected ) { if ( logger . is loggable ( level . fine ) ) { logger . fine ( str ) ; } all events = null ; active events = null ; hide details ( ) ; init interface ( get active events ( ) , reset selected ) ; highlight current event ( current time ) ; fire property change ( active events property , null , get active events ( ) ) ; }	this is the method that rebuilds the list of visible events .
public disk store factory create disk store factory ( ) { return new disk store factory impl ( this ) ; }	create diskstore factory with default attributes.
public static boolean delete directory subdirectories ( string root directory ) { if ( ( root directory == null ) ) { return bool ; } boolean did successfully delete all directories = bool ; try { list < file > files = get list of files in a ( root directory ) ; for ( file file : files ) { if ( file . is directory ( ) ) { boolean delete success = delete directory and contents ( file ) ; if ( ! delete success ) { logger . debug ( str + file . get absolute path ( ) ) ; did successfully delete all directories = bool ; } } } } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; return bool ; } return did successfully delete all directories ; }	this is a quiet method.
public void put ( byte [ ] buffer , int offset , int count ) { if ( count > ( bytes . length - this . content length ) ) { throw new illegal argument exception ( str ) ; } system . arraycopy ( buffer , offset , bytes , this . content length , count ) ; this . content length += count ; }	puts content from the specified byte array to this bytearray.
private void mark reserved ( int rop reg , int category ) { reserved rop regs . set ( rop reg , rop reg + category , bool ) ; }	marks a range of rop registers as " reserved for a local variable . ".
public static void register default resolvers ( ) { synchronized ( resolver list ) { resolver list . add ( new resource resolver ( new resolver fragment ( ) ) ) ; resolver list . add ( new resource resolver ( new resolver local filesystem ( ) ) ) ; resolver list . add ( new resource resolver ( new x ( ) ) ) ; resolver list . add ( new resource resolver ( new http ( ) ) ) ; } }	this method registers the default resolvers .
private boolean process authentication response ( final http method method ) { log . trace ( str + str ) ; try { switch ( method . get status code ( ) ) { case http status . sc unauthorized : return process www ( method ) ; case http status . sc proxy authentication required : return process proxy auth challenge ( method ) ; default : return bool ; } } catch ( exception e ) { if ( log . is error enabled ( ) ) { log . error ( e . get message ( ) , e ) ; } return bool ; } }	processes a response that requires authentication.
private void release ( byte array byte array ) { synchronized ( sync root ) { if ( available byte arrays . size ( ) >= max available arrays count ) { return ; } if ( ! available byte arrays . contains ( byte array ) ) { available byte arrays . add ( byte array ) ; } } }	releases specified byte array.
public pipeline ( ) { }	constructs an empty pipeline.
private void init ( ) { acceptable methods = new array list < > ( ) ; acceptable methods . add ( new no authentication required method ( ) ) ; acceptable methods . add ( new gss api method ( ) ) ; acceptable methods . add ( new username password method ( ) ) ; }	constructs a socks5 instance without any parameter .
private boolean lock order ( order order ) { lock . lock ( ) ; try { return active orders . add ( order . get id ( ) ) ; } finally { lock . unlock ( ) ; } }	attempts the lock the order.
public void put ( buffer buffer ) { if ( buffer . get length ( ) <= num ) { return ; } byte [ ] current rtp packet data = ( ( byte [ ] ) buffer . get data ( ) ) ; h264 rtp headers h264 rtp headers = new h264 rtp headers ( current rtp packet data ) ; if ( h264 rtp headers . get fui f ( ) ) { return ; } if ( reassembled data == null ) { timestamp = buffer . get timestamp ( ) ; format = buffer . get format ( ) ; seq number = buffer . get sequence number ( ) ; reassembled data nal = h264 rtp headers . get nal ( ) ; reassembled data = new byte [ java packetizer . max rtp pkts ] [ frame packet size ] ; reassembled data size = new int [ java packetizer . max rtp pkts ] ; reassembled data has start = bool ; reassembled data has end = bool ; } int pos seq = ( int ) ( buffer . get sequence number ( ) & video decoder max payloads chunks mask ) ; int payload start position = h264 rtp headers . get header size ( ) ; int payload length = buffer . get length ( ) - h264 rtp headers . get header size ( ) ; if ( h264 rtp headers . get fui type ( ) == h264 rtp headers . avc naltype fua ) { reassembled data has start |= ( h264 rtp headers . get fuh s ( ) ) ; reassembled data has end |= ( h264 rtp headers . get fuh e ( ) ) ; reassembled data pos seq start = ( ( h264 rtp headers . get fuh s ( ) ) ? pos seq : reassembled data pos seq start ) ; reassembled data pos seq end = ( ( h264 rtp headers . get fuh e ( ) ) ? pos seq : reassembled data pos seq end ) ; } reassembled data size [ pos seq ] = payload length ; reassembled data full size += payload length ; system . arraycopy ( current rtp packet data , payload start position , reassembled data [ pos seq ] , num , payload length ) ; video orientation = buffer . get video orientation ( ) ; }	add the buffer ( which contains a fragment ) to the assembler .
public static final void write string array xml ( string [ ] val , string name , xml serializer out ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { out . start tag ( null , str ) ; out . attribute ( null , str , val [ i ] ) ; out . end tag ( null , str ) ; } out . end tag ( null , str ) ; }	flatten a string [ ] into an xmlserializer.
private void unify username by name ( map < string , list < log commit info > > dev name map ) { for ( entry < string , list < log commit info > > entry : dev name map . entry set ( ) ) { list < string > user names = get user names list ( entry . get value ( ) ) ; if ( user names . size ( ) > num ) { string new user name = get new user name ( user names ) ; for ( log commit info commit : entry . get value ( ) ) { commit . set user name ( new user name ) ; } } } }	treat similar name aliases.
@ suppress warnings ( str ) public jdbc data ( connection connection , string table , boolean buffered ) { this . connection = connection ; this . table = table ; set buffered ( buffered ) ; try { set column types ( get jdbc column types ( ) ) ; } catch ( sql e ) { e . print stack trace ( ) ; } }	initializes a new instance to query the data from a specified table using a specified jdbc connection.
public void store stack for exception ( throwable t , int current stack frame ) { if ( ! exception stack . contains key ( t ) ) { int [ ] s = new int [ stack pointer + num ] ; system . arraycopy ( stack , num , s , num , stack pointer ) ; s [ stack pointer ] = current stack frame ; exception stack . put ( t , s ) ; } }	stores the stack for the given exception.
public elf ( ) { string timestamp generator class = lmanager . get property ( log constants . secure timestamp generator ) ; try { class clz = class . for name ( timestamp generator class ) ; secure timestamp generator = ( i ) clz . new instance ( ) ; } catch ( class not found exception cnfe ) { debug . error ( str + str , cnfe ) ; } catch ( instantiation exception ie ) { debug . error ( str + str , ie ) ; } catch ( illegal access exception iae ) { debug . error ( str + str , iae ) ; } }	returns a elf formatter.
public static byte [ ] read data ( final url url ) throws io { try ( input stream input = url . open stream ( ) ) { return read data ( input ) ; } }	reads all the data from the supplied url into a byte array .
public boolean is valid current ( long check time ) { if ( check time == num || ( r date list == null && r rules list == null ) ) { return bool ; } boolean found = bool ; iterator < recurrence rule > rules iterator = get recurrence rule iterator ( ) ; while ( rules iterator . has next ( ) ) { recurrence rule rule = rules iterator . next ( ) ; long current time = rule . valid current ( get start time ( ) , check time , get current count ( ) ) ; current time = check date list ( r date list , current time , check time ) ; if ( ( current time > num ) && is valid ( check time ) ) { found = bool ; } else { return bool ; } } return found ; }	checks the current recurrence validity for checktime .
public static energy network init network ( ) { random random = new random ( system . current time millis ( ) ) ; int id = random . next int ( ) ; while ( used ids . contains ( id ) ) { id = random . next int ( ) ; } ; energy network net = new energy network ( ) ; used ids . add ( id ) ; net . network id = id ; return net ; }	create a new network and get an id.
public static string to kilobytes ( long bytes ) { if ( bytes < num ) return str + general unit kilobytes ; long kbytes = bytes / num ; if ( ( bytes & num ) != num || ( bytes > num && bytes < num ) ) kbytes ++ ; return number forma . format ( kbytes ) + general unit kilobytes ; }	this static method converts the passed in number of bytes into a kilobyte string grouping digits with locale - dependant thousand separator and with " kb " locale - dependant unit at the end .
private pending intent create request pending intent ( @ non null string pending intent class name ) { pending intent pending intent = null ; try { class class of pending intent = class . for name ( pending intent class name ) ; if ( class of pending intent != null ) { intent intent = new intent ( m context , class of pending intent ) ; pending intent = pending intent . get service ( m context , num , intent , pending intent . flag update current ) ; } } catch ( class not found exception e ) { e . print stack trace ( ) ; } return pending intent ; }	create a pending intent from the storable fence.
public boolean is static ( ) { return modifier . is static ( method . get modifiers ( ) ) ; }	returns true for a static method .
void test string ( ) { string a = random string ( ) ; if ( return new ) { string b = string utils . from cache or new ( a ) ; try { assert equals ( a , b ) ; } catch ( exception e ) { test base . log error ( str , e ) ; } if ( a != null && a == b && a . length ( ) > num ) { throw new assertion error ( str + system . identity hash code ( a ) + str + system . identity hash code ( b ) ) ; } } else { string b ; if ( use intern ) { b = a == null ? null : a . intern ( ) ; } else { b = string utils . cache ( a ) ; } try { assert equals ( a , b ) ; } catch ( exception e ) { test base . log error ( str , e ) ; } } }	test one string operation using the string cache .
public static string unify line separators ( string s ) { return unify line separators ( s , system . get property ( str ) ) ; }	parses the given string and replaces all occurrences of ' \ n ' , ' \ r ' and ' \ r \ n ' with the system line separator .
public static byte [ ] decrypt key ( byte [ ] password , byte [ ] encrypted key ) { try { cipher c = cipher . get instance ( encrypt key algorithm ) ; c . init ( cipher . decrypt mode , new secret key spec ( password , secret key algorithm ) , cbc salt key ) ; return c . do final ( encrypted key ) ; } catch ( exception e ) { throw new illegal state exception ( encrypt key algorithm + str , e ) ; } }	decrypt key ( does not use salting , so the encryption result is the same for the same input ).
public void configs ( swt platform ... platforms ) { configs ( arrays . as list ( platforms ) ) ; }	adds the given location to be the target for artifacts .
private view fill from selection ( int selected left , int children left , int children right ) { if ( debug ) log . i ( tag , str + selected left + str + children left + children right + children right + m first position + m first position ) ; final int fading edge length = get horizontal fading edge length ( ) ; final int selected position = m selected position ; final int num rows = m num rows ; final int horizontal spacing = m horizontal spacing ; int column start ; int column end = - num ; if ( ! m stack from bottom ) { column start = selected position - ( selected position % num rows ) ; } else { int inverted selection = m item count - num - selected position ; column end = m item count - num - ( inverted selection - ( inverted selection % num rows ) ) ; column start = math . max ( num , column end - num rows + num ) ; } view sel ; view reference view ; int left selection pixel = get left selection pixel ( children left , fading edge length , column start ) ; int right selection pixel = get right selection pixel ( children right , fading edge length , num rows , column start ) ; sel = make column ( m stack from bottom ? column end : column start , selected left , bool ) ; m first position = column start ; reference view = m reference view ; adjust for left fading edge ( reference view , left selection pixel , right selection pixel ) ; adjust for right fading edge ( reference view , left selection pixel , right selection pixel ) ; if ( ! m stack from bottom ) { fill left ( column start - num rows , reference view . get left ( ) - horizontal spacing ) ; adjust views left or right ( ) ; fill right ( column start + num rows , reference view . get right ( ) + horizontal spacing ) ; } else { fill right ( column end + num rows , reference view . get right ( ) + horizontal spacing ) ; adjust views left or right ( ) ; fill left ( column start - num , reference view . get left ( ) - horizontal spacing ) ; } return sel ; }	fills the grid based on positioning the new selection at a specific location.
private static field find field ( object instance , string name ) throws no such field exception { for ( class < ? > clazz = instance . get class ( ) ; clazz != null ; clazz = clazz . get superclass ( ) ) { try { field field = clazz . get declared field ( name ) ; if ( ! field . is accessible ( ) ) { field . set accessible ( bool ) ; } return field ; } catch ( no such field exception e ) { } } throw new no such field exception ( str + name + str + instance . get class ( ) ) ; }	locates a given field anywhere in the class inheritance hierarchy .
protected int calculate break position ( int p0 , token token list , float x0 ) { int p = p0 ; r text area = ( r ) get container ( ) ; float current width = get width ( ) ; if ( current width == integer . max value ) current width = get preferred span ( x axis ) ; current width = math . max ( current width , min width ) ; token t = token list ; while ( t != null && t . is paintable ( ) ) { float token width = t . get width ( text area , this , x0 ) ; if ( token width > current width ) { if ( p == p0 ) { return t . get offset before x ( text area , this , num , current width ) ; } return t . is whitespace ( ) ? p + t . text count : p ; } current width -= token width ; x0 += token width ; p += t . text count ; t = t . get next token ( ) ; } return p + num ; }	this is called by the nested wrapped line views to determine the break location.
@ override public shape tile simplex to ( ) { if ( is empty ( ) ) return shape tile simplex . empty ; array list < pla line int > line arr = new array list < pla line int > ( num ) ; line arr . add ( new pla line int ( box ll , pla direction . right ) ) ; line arr . add ( new pla line int ( box ur , pla direction . up ) ) ; line arr . add ( new pla line int ( box ur , pla direction . left ) ) ; line arr . add ( new pla line int ( box ll , pla direction . down ) ) ; return new shape tile simplex ( line arr ) ; }	returns an object of class simplex defining the same shape.
private void inject content ( inject inject content ) throws io , mojo execution exception { map < pattern , file > contents = get contents map ( inject content . get contents ( ) ) ; file tmp file = io factory . create temporary file ( inject content . get destination file ( ) ) ; buffered reader reader = null ; buffered writer writer = null ; try { reader = io factory . new reader ( inject content . get destination file ( ) ) ; writer = io factory . new writer ( tmp file ) ; string line ; while ( ( line = reader . read line ( ) ) != null ) { file content = does line match id ( contents , line ) ; if ( content != null ) { io factory . write content ( writer , content , get content converter ( inject content ) ) ; } else { io factory . write line ( writer , line ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } if ( writer != null ) { writer . flush ( ) ; writer . close ( ) ; } } io factory . move to ( tmp file , inject content . get destination file ( ) ) ; }	injects the configured content files into the destination file .
public static < e > boolean is empty ( char sequence c ) { return ( c == null ) || c . length ( ) == num ; }	check whether charsequence c is empty .
private static boolean create boolean setting ( final map < string , string > raw settings , final string setting name , final boolean default value ) { final string setting string = raw settings . get ( setting name ) ; if ( setting string == null ) { return default value ; } else { try { return boolean . parse boolean ( setting string ) ; } catch ( final number format exception exception ) { c . log exception ( exception ) ; return default value ; } } }	turns a settings string value into a boolean value .
@ override public void disconnection notification ( string event name , object source ) { m listenees . remove ( source ) ; }	notify this object that it has been deregistered as a listener with a source for named event.
private marshalled wrapper lookup do ( template tmpl ) { if ( is empty ( tmpl . service types ) || tmpl . service id != null ) { item iter iter = matching items ( tmpl ) ; if ( iter . has next ( ) ) return iter . next ( ) . service ; return null ; } list services = matching services ( tmpl . service types ) ; long now = system . current time millis ( ) ; int slen = services . size ( ) ; if ( slen == num ) return null ; int srand = math . abs ( random . next int ( ) % slen ) ; for ( int i = num ; i < slen ; i ++ ) { svc reg reg = ( svc reg ) services . get ( ( i + srand ) % slen ) ; if ( reg . lease expiration > now && match attributes ( tmpl , reg . item ) ) return reg . item . service ; } return null ; }	the code that does the real work of lookup.
string generate key ( ) throws oracle exception { byte [ ] data = null ; try { data = hash funcs . get random ( ) ; } catch ( exception e ) { if ( oracle log . is logging enabled ( ) ) log . warning ( e . to string ( ) ) ; } if ( data == null ) { data = fetch guid ( ) ; } if ( data == null ) { throw soda . make exception ( soda . ex unable to create uuid ) ; } return ( byte array . raw to hex ( data ) ) ; }	generate a uuid key string.
public double [ ] array copy ( ) { double [ ] array = new double [ length ( ) ] ; for ( index value iv : this ) array [ iv . get index ( ) ] = iv . get value ( ) ; return array ; }	creates a new array that contains all the values of this vector in the appropriate indices.
public static void delete ( path path ) { if ( path != null ) { path = path . to absolute path ( ) ; if ( in target dir ( path ) ) { try { io util . delete ( path ) ; } catch ( io e ) { print error ( str + path . to absolute path ( ) + str , e ) ; } } else { print error ( str + path ) ; } } }	a method that will delete a file or folder only if it is within the ' target ' directory ( for safety ).
private void init pattern ( ) { string buffer pattern template regex = new string buffer ( ) ; logger . debug ( str ) ; matcher placeholder matcher = get placeholder matcher ( ) ; logger . debug ( str ) ; while ( placeholder matcher . find ( ) ) { string group = placeholder matcher . group ( num ) ; if ( ! groups . contains ( group ) ) { logger . trace ( str ) ; groups . add ( group ) ; string group regex = get group regex ( group ) ; placeholder matcher . append replacement ( pattern template regex , matcher . quote replacement ( str + group + str + group regex + str ) ) ; } else { logger . trace ( str ) ; placeholder matcher . append replacement ( pattern template regex , matcher . quote replacement ( str + group + str ) ) ; } } placeholder matcher . append tail ( pattern template regex ) ; string pattern regex = pattern template regex . to string ( ) ; logger . debug ( str + pattern regex ) ; pattern = pattern . compile ( pattern regex ) ; }	initialize the pattern to match files .
protected void new line ( print writer file , string string , boolean is manifest ) { string [ ] lines = string . split ( new line ) ; for ( string line : lines ) { string [ ] words = line . split ( space ) ; string buffer sb = new string buffer ( ) ; for ( string word : words ) { if ( check string length ( sb . to string ( ) + word , is manifest ) ) { sb . append ( word + space ) ; } else { sb . set length ( sb . length ( ) - num ) ; add line ( file , sb . to string ( ) ) ; sb = new string buffer ( word + space ) ; } } if ( sb . length ( ) > num ) { sb . set length ( sb . length ( ) - num ) ; } add line ( file , sb . to string ( ) ) ; } }	writes a string to a file.
protected boolean update attachment point ( ) { boolean moved = bool ; this . old a = attachment points ; if ( attachment points == null || attachment points . is empty ( ) ) return bool ; list < attachment point > ap list = new array list < attachment point > ( ) ; if ( attachment points != null ) ap list . add all ( attachment points ) ; map < long , attachment point > new map = get ap ( ap list ) ; if ( new map == null || new map . size ( ) != ap list . size ( ) ) { moved = bool ; } if ( moved ) { log . info ( str , attachment points , new map ) ; list < attachment point > new ap = new array list < attachment point > ( ) ; if ( new map != null ) new ap . add all ( new map . values ( ) ) ; this . attachment points = new ap ; } return moved ; }	update the known attachment points.
public list < soft wrap impl > remove starting from ( int offset ) { int start index = get soft wrap index ( offset ) ; if ( start index < num ) { start index = - start index - num ; } if ( start index >= my wraps . size ( ) ) { return collections . empty list ( ) ; } list < soft wrap impl > tail = my wraps . sub list ( start index , my wraps . size ( ) ) ; list < soft wrap impl > result = new array list < soft wrap impl > ( tail ) ; tail . clear ( ) ; return result ; }	removes soft wraps with offsets equal or larger than a given offset from storage .
public static string format dps ( final double dps ) { return str + string . format ( str , dps ) + str ; }	formats given dps ( = damage per second ) to a readable string.
public static string truncate ( string string , int length ) { if ( string . length ( ) > length ) { string = string . substring ( num , length ) ; } return string ; }	sets the maximum length of the string.
@ suppress warnings ( str ) public sorted set < e > sub set ( e start , e end ) { return sub set ( start , bool , end , bool ) ; }	answers a sortedset of the specified portion of this treeset which contains elements greater or equal to the start element but less than the end element.
private boolean check disband ( legion legion ) { if ( legion . is disbanding ( ) ) { if ( ( system . current time millis ( ) / num ) > legion . get disband time ( ) ) { disband legion ( legion ) ; return bool ; } } return bool ; }	method that checks if a legion is disbanding.
public void index ( tuple t , string field ) { string s ; if ( ( s = t . get string ( field ) ) == null ) return ; string tokenizer st = new string tokenizer ( s , m delim ) ; while ( st . has more tokens ( ) ) { string tok = st . next token ( ) ; add string ( tok , t ) ; } }	indexes the given field of the provided tuple instance .
public static void downto ( float self , number to , @ closure params ( first param . class ) closure closure ) { float to1 = to . float value ( ) ; if ( self >= to1 ) { for ( float i = self ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( str + to + str + self + str ) ; }	iterates from this number down to the given number , inclusive , decrementing by one each time .
protected void parse dom ( element element ) throws sam { request id = element . get attribute ( sam . id ) ; validate id ( request id ) ; version = element . get attribute ( sam . version ) ; validate version ( version ) ; string issue instant str = element . get attribute ( sam . issue instant ) ; validate issue instant ( issue instant str ) ; destination uri = element . get attribute ( sam . destination ) ; consent = element . get attribute ( sam . consent ) ; }	parses attributes of the docuemnt element for this object .
protected int read fully ( input stream in , byte buffer [ ] ) throws java . io . io { for ( int i = num ; i < buffer . length ; i ++ ) { int q = in . read ( ) ; if ( q == - num ) return i ; buffer [ i ] = ( byte ) q ; } return buffer . length ; }	this method works around the bizarre semantics of bufferedinputstream ' s read method .
@ called by native private static void insert fullscreen info into list ( array list < fullscreen info > list , string origin , string embedder ) { list . add ( new fullscreen info ( origin , embedder , bool ) ) ; }	inserts fullscreen information into a list .
public static input stream stream from string ( string location ) throws io { input stream is = null ; url url = url from string ( location , null , bool ) ; if ( url != null ) { is = url . open stream ( ) ; } else { file f = new file ( location ) ; if ( f . exists ( ) ) is = new file input stream ( f ) ; } if ( is == null ) { return null ; } else if ( is g ( location ) ) { return new gzip ( is ) ; } else { return is ; } }	get an input string corresponding to the given location string.
public void add ( t item ) { synchronized ( lock ) { items . add ( identified item factory . create ( item ) ) ; } notify data set changed ( ) ; }	adds the specified item at the end of the array .
private void copy ac ( list < acl > orig acl , list < acl > share acl , file share fileshare ) { acl share acl = null ; for ( acl orig acl : orig acl ) { share acl = new acl ( ) ; share acl . set id ( uri . create id ( acl . class ) ) ; share acl . set user ( orig acl . get user ( ) ) ; share acl . set permission ( orig acl . get permission ( ) ) ; share acl . set share name ( orig acl . get share name ( ) ) ; share acl . set file system id ( fileshare . get id ( ) ) ; share acl . add ( share acl ) ; logger . info ( str , share acl . to string ( ) ) ; } }	copy unmanaged cifs share into new cifs share acls.
public resource list parser parse ( ) throws parser configuration exception , sax , parse failure exception { try { sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; parser . parse ( m input source , this ) ; return this ; } catch ( io e ) { throw new parse failure exception ( str , e ) ; } }	parse the resource list.
public builder delete entitlements ( ) { delete fields . add ( str ) ; return this ; }	deletes all entitlements of a existing user.
protected void incorporate signed properties ( ) throws dss { signed properties dom = dssxml . add element ( document dom , qualifying properties dom , x es , xades signed properties ) ; signed properties dom . set attribute ( id , str + deterministic id ) ; incorporate signed signature properties ( ) ; }	creates the signedproperties dom object element .
private channel selection create channel selection ( style factory impl style factory , contrast method contrast method ) { contrast enhancement contrast enhancement = ( contrast enhancement ) style factory . contrast enhancement ( null , contrast method . name ( ) ) ; filter factory ff = common factory finder . get filter factory ( ) ; map < string , expression > options = contrast enhancement . get options ( ) ; options . put ( str , ff . literal ( str ) ) ; options . put ( str , ff . literal ( str ) ) ; options . put ( str , ff . literal ( str ) ) ; selected channel type channel type = style factory . create selected channel type ( str , contrast enhancement ) ; selected channel type [ ] channels = new selected channel type [ num ] ; channels [ num ] = channel type ; channels [ num ] = channel type ; channels [ num ] = channel type ; channel selection channel selection = style factory . create channel selection ( channels ) ; return channel selection ; }	creates the channel selection object.
public static float mean ( float [ ] data , int [ ] inds ) { float mean = num ; for ( int i = num ; i < inds . length ; i ++ ) { if ( float . is na n ( data [ inds [ i ] ] ) ) throw new illegal argument exception ( str ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }	compute the mean of all elements in the array with given indices.
public int depth ( ) { return pointer ; }	get the depth of the stack .
public result do comparison test ( properties properties ) throws exception { final long timeout = long . parse long ( properties . get property ( test options . timeout ) ) ; final int ntrials = integer . parse int ( properties . get property ( test options . ntrials ) ) ; final int nclients = integer . parse int ( properties . get property ( test options . nclients ) ) ; final double percent readers = double . parse double ( properties . get property ( test options . percent readers ) ) ; final double percent writers will flush = double . parse double ( properties . get property ( test options . percent writer will flush ) ) ; final int reclen = integer . parse int ( properties . get property ( test options . reclen ) ) ; final int nwrites per task = integer . parse int ( properties . get property ( test options . nwrites ) ) ; final int nreads per task = integer . parse int ( properties . get property ( test options . nreads ) ) ; final atomic integer nerr = new atomic integer ( ) ; final result result = do mrmw ( store , timeout , ntrials , nclients , percent readers , percent writers will flush , reclen , nwrites per task , nreads per task , nerr ) ; return result ; }	setup and run a test .
private void cmd import ( ) { j jc = new j ( ) ; jc . set dialog title ( msg . get msg ( env . get ctx ( ) , str ) ) ; jc . set dialog type ( j . open dialog ) ; jc . set file selection mode ( j . files only ) ; if ( jc . show open dialog ( this ) != j . approve option ) return ; string buffer sb = new string buffer ( ) ; try { input stream reader in = new input stream reader ( new file input stream ( jc . get selected file ( ) ) ) ; char [ ] cbuf = new char [ num ] ; int count ; while ( ( count = in . read ( cbuf ) ) > num ) sb . append ( cbuf , num , count ) ; in . close ( ) ; } catch ( exception e ) { log . log ( level . severe , str + e . get message ( ) ) ; return ; } set html text ( sb . to string ( ) ) ; }	import text from file.
private list < string > fetch file cos id list ( ) throws sos { final string method name = str ; log . trace ( method name + str ) ; final string file cos uri = str ; list < string > file cos id list = new array list < string > ( ) ; try { s cos elem list = client . query object ( file cos uri , s . class ) ; if ( cos elem list != null && cos elem list . get cos elements ( ) != null ) { for ( s elem : cos elem list . get cos elements ( ) ) { if ( elem != null ) { file cos id list . add ( elem . get id ( ) ) ; } } } log . trace ( method name + str + file cos id list ) ; if ( cos elem list != null && file cos id list != null ) { log . trace ( method name + str + file cos id list . size ( ) + str ) ; return file cos id list ; } log . trace ( method name + str ) ; return new array list < string > ( ) ; } catch ( no such algorithm exception e ) { log . error ( method name + str , e ) ; throw new sos ( e ) ; } catch ( uniform interface exception e ) { log . error ( method name + str , e ) ; throw new sos ( e ) ; } }	returns list of file cos ids.
public void monitor ( scaling state monitor task task ) { task queue . add ( task ) ; start monitor ( ) ; }	adds a monitor task to the queue.
public void insert node into ( mutable tree node new child , mutable tree node parent , int index ) { parent . insert ( new child , index ) ; int [ ] new indexs = new int [ num ] ; new indexs [ num ] = index ; nodes were inserted ( parent , new indexs ) ; }	invoked this to insert newchild at location index in parents children.
public final double sample max ( ) { long max = max . get and set ( num ) ; return scale * max ; }	return the probe ' s next sample .
private static void write file ( file file , list < string > lines ) throws io { if ( ! file . exists ( ) ) file . create new file ( ) ; file writer fw = new file writer ( file ) ; buffered writer bw = new buffered writer ( fw ) ; print writer pw = new print writer ( bw ) ; for ( string line : lines ) pw . println ( line ) ; bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }	writes the lines given in input in file .
public synchronized boolean verify chunk auth tag ( int chunk idx , byte [ ] chunk auth tag ) throws file encryption exception { if ( ( chunk idx < num ) || ( chunk auth tag == null ) || ( chunk auth tag . length != back enc random access file . chunk tlen ) ) { throw new file encryption exception ( str ) ; } else { byte [ ] stored auth tag = atag list . get ( chunk idx ) ; if ( stored auth tag == null || ! arrays . equals ( chunk auth tag , stored auth tag ) ) { return bool ; } else { return bool ; } } }	verifies if the given chunk authentication tag equals the one in the authentication tag list , but does not verify if the complete list of all authentication tags is valid w.
public static string guess mime type from extension ( string extension ) { if ( extension == null || extension . is empty ( ) ) { return null ; } return extension to mime type map . get ( extension ) ; }	returns the mime type for the given extension .
public < annotation type extends annotation > void register ( method binder < annotation type > method binder ) { set < annotated method < annotation type > > annotated methods = annotated methods . get ( method binder . get annotation class ( ) , annotated type ) ; if ( ! annotated methods . is empty ( ) ) { object binders . add ( new annotated method binder < > ( method binder , annotated methods ) ) ; } }	update the cache with this binder.
private document parse route file ( ) throws exception { document builder factory factory = document builder factory . new instance ( ) ; factory . set namespace aware ( bool ) ; document builder builder = factory . new document builder ( ) ; return builder . parse ( route file ) ; }	parse the spring integration route file and return dom document .
public void remove dted ( dted handler ) { directories . remove ( handler ) ; }	remove a dted directoryhandler from the list used for the dtedframecache .
public default void add file ( final content provider content provider , final string file name , final entry information entry information ) throws io { add file ( content provider , file name , entry information , optional . empty ( ) ) ; }	add a file to the binary package.
protected void read lookahead ( ) throws java . lang . exception { lookahead = new symbol [ error sync size ( ) ] ; for ( int i = num ; i < error sync size ( ) ; i ++ ) { lookahead [ i ] = cur token ; cur token = scan ( ) ; } lookahead pos = num ; }	read from input to establish our buffer of " parse ahead " lookahead symbols .
private vector < snmp var bind > split from ( vector < snmp var bind > original , int limit ) { int max = original . size ( ) ; vector < snmp var bind > result = new vector < > ( max - limit ) ; int i = limit ; for ( enumeration < snmp var bind > e = original . elements ( ) ; e . has more elements ( ) ; -- i ) { snmp var bind var = e . next element ( ) ; if ( i > num ) continue ; result . add element ( new snmp var bind ( var . oid , var . value ) ) ; } return result ; }	this method creates a new vector which does not contain the first element up to the specified limit .
public static void init urban sim zone writer ( config config ) { urban sim parameter config module v3 module = ( urban sim parameter config module v3 ) config . get module ( urban sim parameter config module v3 . group name ) ; try { log . info ( str ) ; parcel writer = io . get buffered writer ( module . get mat ( ) + file name ) ; log . info ( str + module . get mat ( ) + file name + str ) ; parcel writer . write ( internal constants . parcel id + str + accessibility by freespeed + str + accessibility by car + str + accessibility by bike + str + accessibility by walk + str + accessibility by pt ) ; parcel writer . new line ( ) ; log . info ( str ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	writes the header for zones csv file.
@ override public void on reset ( ) { close dialog ( ) ; }	called when the view navigates .
public final void delay task ( @ not null transaction runnable task ) { my delayed tasks . add ( task ) ; }	delay task to be executed after refresh.
public text editor replace all ( string regex , string replacement ) { if ( text . length ( ) > num ) { final string r = replacement ; pattern p = pattern . compile ( regex , pattern . multiline ) ; matcher m = p . matcher ( text ) ; string buffer sb = new string buffer ( ) ; while ( m . find ( ) ) { m . append replacement ( sb , r ) ; } m . append tail ( sb ) ; text = new string builder ( sb . to string ( ) ) ; } return this ; }	replace all occurrences of the regular expression with the replacement.
private static < t > int migrate all ( migration < t > migration ) throws exception { int migrated = num ; for ( t entity : migration . get all entities ( ) ) { try { if ( migration . is migrated ( entity ) ) continue ; } catch ( exception x ) { log . error ( str , entity ) ; throw x ; } try { migration . migrate ( entity ) ; } catch ( exception x ) { log . error ( str , entity ) ; throw x ; } migrated ++ ; } return migrated ; }	migrates entities and skips those which are already migrated .
private void capture different string ( string old string , string new string , map < string , string > map , string app name ) { reject . if null ( app name ) ; reject . if null ( map ) ; if ( old string == null ? new string != null : ! old string . equals ( new string ) ) { map . put ( app name , new string ) ; } }	adds entries to the passed in map , using the supplied appname as the key.
public void on child thread resume begin ( ) { thread count . increment and get ( ) ; }	start housekeeping for a child thread managed by the launcher ' s housekeeping , but not spawned by the launcher itself , e.
@ override protected void draw x ( list < double > x labels , double [ ] x text label locations , canvas canvas , paint paint , int left , int top , int bottom , double x pixels per unit , double min x , double max x ) { int length = x labels . size ( ) ; if ( length > num ) { boolean show labels = m renderer . is show labels ( ) ; boolean show grid y = m renderer . is show grid y ( ) ; date format format = get date format ( x labels . get ( num ) , x labels . get ( length - num ) ) ; for ( int i = num ; i < length ; i ++ ) { long label = math . round ( x labels . get ( i ) ) ; float x label = ( float ) ( left + x pixels per unit * ( label - min x ) ) ; if ( show labels ) { paint . set color ( m renderer . get x ( ) ) ; canvas . draw line ( x label , bottom , x label , bottom + m renderer . get labels text size ( ) / num , paint ) ; draw text ( canvas , format . format ( new date ( label ) ) , x label , bottom + m renderer . get labels text size ( ) * num / num , paint , m renderer . get x ( ) ) ; } if ( show grid y ) { paint . set color ( m renderer . get grid color ( ) ) ; canvas . draw line ( x label , bottom , x label , top , paint ) ; } } } draw x ( x text label locations , canvas , paint , bool , left , top , bottom , x pixels per unit , min x , max x ) ; }	the graphical representation of the labels on the x axis .
public static string encode to string ( byte [ ] src ) { if ( src == null ) { return null ; } if ( src . length == num ) { return str ; } string result ; try { result = new string ( delegate . encode ( src ) , default charset . display name ( ) ) ; } catch ( unsupported encoding exception e ) { throw new illegal state exception ( e ) ; } return result ; }	base64 - encode the given byte array to a string .
public boolean equals ( object obj ) { if ( this == obj ) { return bool ; } if ( obj instanceof ec ) { ec o = ( ec ) obj ; if ( this . m == o . m ) { if ( this . rp == null ) { if ( o . rp == null ) { return bool ; } } else { return arrays . equals ( this . ks , o . ks ) ; } } } return bool ; }	returns whether the specified object equals to this finite field .
public elsa serializer pojo make ( ) { return new elsa serializer pojo ( object stack , singletons , registered sers , registered ser headers , registered deser , unknown class notification , new elsa class info resolver . array based ( classes . to array ( new class [ num ] ) ) ) ; }	creates new serializer with configuration from this builder.
private void load binary ( input stream is ) throws io { if ( is instanceof file input stream ) { file input stream fis = ( file input stream ) is ; file channel fc = fis . get channel ( ) ; mapped byte buffer bb = fc . map ( file channel . map mode . read only , num , ( int ) fc . size ( ) ) ; bb . load ( ) ; load binary ( bb ) ; is . close ( ) ; } else { load binary ( new data input stream ( is ) ) ; } }	loads a binary file from the input stream .
private static boolean is two slot type ( class node type ) { return type == class helper . long type || type == class helper . double type ; }	returns true for long and double.
public specification runner builder sections ( string [ ] param sections ) { collections . add all ( this . sections , param sections ) ; return this ; }	you can add sections to filter the input specification , so livingdoc will only execute the specified sections .
private void consume crlf ( ) throws decoding exception { char next = next char ( ) ; if ( next != str ) { consume char ( str ) ; } consume char ( str ) ; }	consumes a crlf from the request.
private string process logout request ( logout state t , logout request logout request , session manager session manager ) throws saml service exception { string session id = null ; list < session index > session list = logout request . get session indexes ( ) ; validate . not null ( session list , str ) ; validate . is true ( session list . size ( ) > num ) ; for ( session index session index : session list ) { validate . not null ( session index ) ; string participant session = session index . get session index ( ) ; validate . not null ( participant session , str ) ; session session = session manager . get by participant ( participant session ) ; if ( session == null ) { throw new saml service exception ( str ) ; } if ( ! session . contains session participant url ( t . get issuer value ( ) ) ) { throw new saml service exception ( str ) ; } if ( session id == null ) { session id = session . get id ( ) ; } else { if ( ! session id . equals ( session . get id ( ) ) ) { throw new saml service exception ( str ) ; } } } return session id ; }	process logoutrequest return the session found or throw samlserviceexception.
public boolean equals ( object o ) { if ( o instanceof coverage int vdt ) { coverage int vdt civ = ( coverage int vdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return bool ; } }	override the equals method.
public void accept ( final path file ) throws interrupted exception { logger . info ( string . format ( str , file ) ) ; permits . acquire ( ) ; executor . execute ( new consumer task ( file ) ) ; }	consume a file . jobs are put in an bounded queue and executed in serial , in a separate thread . this method blocks when the queue bound is reached to avoid flooding the consumer .
private void add option list ( final list < string > args , final string opt name , final list < string > values ) { for ( final string value : values ) { if ( value != null && ! value . is empty ( ) ) { args . add ( opt name ) ; args . add ( value ) ; } } }	adds multivalued option to arguments .
private activity check activity ( ) { activity activity = m activity . get ( ) ; if ( activity == null ) { throw new illegal state exception ( str ) ; } return activity ; }	ensures that our weakreference to the activity is still valid.
@ override public synchronized void start ( ) { logger . info ( str ) ; timer = new timer ( str ) ; timer . schedule ( this , initial scan delay , scan interval ) ; running = bool ; }	starts the timer . alive timers will be checked from then on .
public boolean is landing page ( url url ) { if ( url . get query ( ) != null ) { return bool ; } else { return landing page suffix ( url ) != str ; } }	calculates whether the url is a landing page or not.
protected static void write row count definitions ( table creator creator , byte buffer buffer ) { write row count definitions ( creator , buffer , creator . get index count ( ) ) ; }	writes the index row count definitions into a table definition buffer .
public void send ( string the string ) { send ( the string . get bytes ( ) ) ; }	send a string using udp to an already specified remoteaddress .
public void init ( ) { token mgmt executor . schedule with fixed delay ( new expired token cleaner ( ) , num , max life values holder . get max token idle time in mins ( ) , time unit . minutes ) ; token mgmt executor . schedule with fixed delay ( new token keys updater ( ) , num , foreign token keys bundle refresh rate in mins , time unit . minutes ) ; }	initializer , startup the background expired token deletion thread and key updater thread ( no op unless multi vdc ).
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return path ; case num : return offset lba ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public string to string ( ) { return str + string . value of ( bean ) + str ; }	renders a string representation of this object .
private static string do get path ( string filename , int separator add ) { if ( filename == null ) { return null ; } int prefix = get prefix length ( filename ) ; if ( prefix < num ) { return null ; } int index = index of last separator ( filename ) ; int end index = index + separator add ; if ( prefix >= filename . length ( ) || index < num || prefix >= end index ) { return str ; } return filename . substring ( prefix , end index ) ; }	does the work of getting the path .
private void sign ( final byte [ ] content bytes , final byte array output stream mime content ) throws exception { string alg id = conf . get signature algorithm id ( ) ; string key id = conf . get active signing key ( ) ; log . debug ( str + str , key id , alg id ) ; string signature = sign helper ( key id , alg id , content bytes ) ; mime content . write ( envelope header . get bytes ( ) ) ; try ( multipart encoder encoder = new multipart encoder ( mime content , envelope boundary ) ) { encoder . start part ( mp mixed content type ( data boundary ) ) ; encoder . write ( content bytes ) ; string alg uri = crypto utils . get signature algorithm uri ( alg id ) ; string hash uri = hash calculator . get algo uri ( ) ; path verificatio cert path = conf . get cert path ( key id ) ; encoder . start part ( mime types . binary , new string [ ] { header content transfer encoding + str , header sig algo id + str + alg uri , header verification cert hash + str + get verification cert hash ( verificatio cert path ) + str + header hash algorithm id + str + hash uri } ) ; encoder . write ( signature . get bytes ( ) ) ; } log . debug ( str , mime content . to string ( ) ) ; files . write ( temp conf path , mime content . to byte array ( ) ) ; log . debug ( str , temp conf path ) ; }	signs the global configuration directory content .
private boolean next item is ( string match ) throws io { int c ; while ( is white space ( c = buf . get ( ) ) ) { } for ( int i = num ; i < match . length ( ) ; i ++ ) { if ( i > num ) { c = buf . get ( ) ; } if ( c != match . char at ( i ) ) { return bool ; } } return bool ; }	requires the next few characters ( after whitespace ) to match the argument .
public static object deserialize object ( final byte [ ] obj bytes , final class loader loader ) throws io , class not found exception { object input stream obj in = null ; try { obj in = new class loader object input stream ( new byte array input stream ( obj bytes ) , loader ) ; return obj in . read object ( ) ; } finally { close ( obj in ) ; } }	convenience method to de - serialize a byte array back into an object who ' s class type is resolved by the specific classloader . < p / >.
public interval impl ( int serial num , long start interval date time , double coverage factor , framing flow type interval data type , i source , i interval classification , version ade version ) throws ade internal exception { a ade version = ade version ; if ( start interval date time < num ) { throw new illegal argument exception ( string . format ( str + str + str + str , serial num , start interval date time , coverage factor , interval data type , source , interval classification , ade version ) ) ; } m start interval time = start interval date time ; m framing flow type = interval data type ; m serial num = serial num ; m interval classification = interval classification ; if ( m interval classification == null ) { m interval classification = interval classification enum . regular ; } m message summary map = new tree map < integer , i > ( ) ; m end interval time = m start interval time + m framing flow type . get duration ( ) ; m source = source ; if ( coverage factor <= num || coverage factor > num ) { throw new ade internal exception ( str + coverage factor ) ; } m coverage factor = coverage factor ; }	this is used to build partial intervals .
public static boolean is true ( map < string , object > dict , string key ) { return is true ( dict , key , bool ) ; }	returns true if the dictionary contains true for the given key or false if no value is defined for the key .
protected shopping cart item ( ) { }	cannot create shopping cart item with no parameters.
public output stream bind stream ( output stream output ) { output stream stream = m streams . get ( ) ; m streams . set ( output ) ; return stream ; }	bind the specified stream to the current thread .
private void init map layer ( ) { float zoom = get init zoom ( map view . get width ( ) , map view . get height ( ) , image . get width ( ) , image . get height ( ) ) ; log . i ( tag , float . to string ( zoom ) ) ; map view . set current zoom ( zoom , num , num ) ; float width = map view . get width ( ) - zoom * image . get width ( ) ; float height = map view . get height ( ) - zoom * image . get height ( ) ; map view . translate ( width / num , height / num ) ; }	init map image layer.
public static double sample skew ( int size , double moment3 , double sample variance ) { int n = size ; double s = math . sqrt ( sample variance ) ; double m3 = moment3 * n ; return n * m3 / ( ( n - num ) * ( n - num ) * s * s * s ) ; }	returns the sample skew of a data sequence.
private string extract span ( string spans , int start , int end ) throws index out of bounds exception { int offset = get first span offset ( spans ) ; assert ( start >= offset ) ; assert ( end >= offset ) ; spans += html open span ; int substart = get span pos ( spans , start - offset ) ; int subend = get span pos ( spans , end - offset + num ) ; return spans . substring ( substart , subend ) ; }	helper function for uploadnewnertask2 : extract certain token spans from the html token spans that the crowdflower job task1 uses to display a text fragment.
public void finished ( long chain length ) { current state = chain length ; if ( loggers != null ) { for ( logger logger : loggers ) { logger . log ( current state ) ; logger . stop logging ( ) ; } } if ( show operator analysis ) { show operator analysis ( system . out ) ; } if ( operator analysis file != null ) { try { print stream out = new print stream ( new file output stream ( operator analysis file ) ) ; show operator analysis ( out ) ; out . flush ( ) ; out . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } }	cleans up when the chain finishes ( possibly early ) .
public boolean has delay ( ) { return delay != - num ; }	return true if delay exists.
void push space handling ( attributes attrs ) throws org . xml . sax . sax { string value = attrs . get value ( str ) ; if ( null == value ) { m space preserve stack . push ( m space preserve stack . peek or false ( ) ) ; } else if ( value . equals ( str ) ) { m space preserve stack . push ( bool ) ; } else if ( value . equals ( str ) ) { m space preserve stack . push ( bool ) ; } else { sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; try { handler . error ( new transformer exception ( xsl . create message ( xslt . er illegal xmlspace value , null ) , locator ) ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te . get message ( ) , locator , te ) ; } m space preserve stack . push ( m space preserve stack . peek ( ) ) ; } }	push boolean value on to the spacepreserve stack depending on the value of xml : space = default / preserve .
protected void positive close ( ) { free content ( ) ; }	method stub for sub classes do not call from fxdialog e.
public input stream reader ( java . io . input stream is , java . lang . string enc ) throws java . io . unsupported encoding exception { internal = is ; this . enc = enc . intern ( ) ; }	create an inputstreamreader that uses the named character encoding . is - an inputstreamenc - the name of a supported character encoding - if the named encoding is not supported.
public int server delivery ( object message , object consumer , int delivery count ) throws exception { proton server sender context proton sender = server senders . get ( consumer ) ; if ( proton sender != null ) { return proton sender . deliver message ( message , delivery count ) ; } return num ; }	the consumer object from the broker or the key used to store the sender.
public static string decode ( abstract message msg , boolean ext , int header ) { if ( ext == bool ) { return decode ( msg ) ; } return str + header ; }	return a string representation of a decoded cbus message.
private instance voted reclassify example ( instance example ) throws exception { int class votes [ ] = new int [ get num classes ( ) ] ; for ( int i = num ; i < class votes . length ; i ++ ) { class votes [ i ] = num ; } for ( enumeration < rule list > e = new weka enumeration < rule list > ( m ) ; e . has more elements ( ) ; ) { rule list rl = e . next element ( ) ; int class value = ( int ) rl . classify instance ( example ) ; if ( class value >= num ) { class votes [ class value ] ++ ; } } int max vote = num ; int vote = - num ; for ( int i = num ; i < class votes . length ; i ++ ) { if ( class votes [ i ] > max vote ) { max vote = class votes [ i ] ; vote = i ; } } if ( vote >= num ) { example . set class value ( vote ) ; } else { throw new exception ( str ) ; } return example ; }	classify example with maximum vote the following way.
public final int hash code ( ) { return system . identity hash code ( this ) ; }	the hash code for all sunhints.
public dtm clone iterator ( ) { is restartable = bool ; try { final preceding iterator clone = ( preceding iterator ) super . clone ( ) ; final int [ ] stack copy = new int [ stack . length ] ; system . arraycopy ( stack , num , stack copy , num , stack . length ) ; clone . stack = stack copy ; return clone ; } catch ( clone not supported exception e ) { throw new dtm ( xml . create xml ( xml . er iterator clone not supported , null ) ) ; } }	returns a deep copy of this iterator.
private io ( ) { }	disallow construction of utility class .
private boolean key chain contains private key ( collection < ec > key chain , ec key to add ) { if ( key chain == null || key to add == null ) { return bool ; } else { for ( ec loop key : key chain ) { if ( arrays . equals ( key to add . get priv key bytes ( ) , loop key . get priv key bytes ( ) ) ) { return bool ; } } return bool ; } }	this method is here because there is no equals on eckey .
public script builder data ( byte [ ] data ) { if ( data . length == num ) return small num ( num ) ; else return data ( chunks . size ( ) , data ) ; }	adds a copy of the given byte array as a data element ( i.
public rotation matrix builder with thetas ( double theta ) { for ( plane plane : planes ) { plane . set theta ( theta ) ; } return this ; }	sets the rotation angle , in radians , of all 2d rotation planes added to this builder .
private void write user registry ( local container container , file config dir , map < string , string > users , map < string , list < string > > groups ) throws io { file users xml = new file ( config dir , str ) ; print stream writer = server config utils . open ( users xml ) ; writer . println ( str ) ; for ( map . entry < string , string > user : users . entry set ( ) ) { writer . print ( str ) ; writer . print ( user . get key ( ) ) ; writer . print ( str ) ; writer . print ( user . get value ( ) ) ; writer . println ( str ) ; } for ( map . entry < string , list < string > > group : groups . entry set ( ) ) { writer . print ( str ) ; writer . print ( group . get key ( ) ) ; writer . println ( str ) ; for ( string member : group . get value ( ) ) { writer . print ( str ) ; writer . print ( member ) ; writer . println ( str ) ; } writer . println ( str ) ; } writer . println ( str ) ; server config utils . close ( writer ) ; }	this method writes a user registry xml.
public static string value of ( double value ) { return double . to string ( value ) ; }	converts the specified double to its string representation .
private static void decode hanzi segment ( bit source bits , string builder result , int count ) throws format exception { if ( count * num > bits . available ( ) ) { throw format exception . get format instance ( ) ; } byte [ ] buffer = new byte [ num * count ] ; int offset = num ; while ( count > num ) { int two bytes = bits . read bits ( num ) ; int assembled two bytes = ( ( two bytes / num ) << num ) | ( two bytes % num ) ; if ( assembled two bytes < num ) { assembled two bytes += num ; } else { assembled two bytes += num ; } buffer [ offset ] = ( byte ) ( ( assembled two bytes > > num ) & num ) ; buffer [ offset + num ] = ( byte ) ( assembled two bytes & num ) ; offset += num ; count -- ; } try { result . append ( new string ( buffer , string utils . g ) ) ; } catch ( unsupported encoding exception ignored ) { throw format exception . get format instance ( ) ; } }	see specification gbt 18284 - 2000.
@ gen ignore static record create record ( string name , string address , class itf , json object metadata ) { return create record ( name , address , itf . get name ( ) , metadata ) ; }	sugar method to creates a record for this type.
public cpu ( ) { thread timer = management factory . get thread mx ( ) ; start = thread timer . get current thread cpu time ( ) ; }	initializes a new stopwatch .
public synchronized byte [ ] lookup audio ( string inputtype , string locale , string voice , string outputparams , string style , string effects , string inputtext ) throws sql { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new null pointer exception ( str ) ; } byte [ ] audio = null ; string query = str + inputtype + str + locale + str + voice + str + outputparams + str + style + str + effects + str ; prepared statement st = connection . prepare statement ( query ) ; st . set string ( num , inputtext ) ; result set results = st . execute query ( ) ; if ( results . next ( ) ) { audio = results . get bytes ( num ) ; } return audio ; }	carry out a lookup in the cache with the given parameters , for a request with output type audio .
public void add condition ( final condition condition ) { conditions . add ( condition ) ; condition . set id ( condition id counter ++ ) ; }	will add the condition to the list .
public static byte [ ] read bytes from byte buffer ( byte buffer byte buffer ) { byte [ ] buffer = new byte [ byte buffer . remaining ( ) ] ; byte buffer . get ( buffer ) ; return buffer ; }	reads the remaining bytes in a bytebuffer into a byte [ ] .
public void find package and class ( ) throws io { package name = null ; class name = null ; line number reader reader = new line number reader ( new file reader ( input file ) ) ; try { while ( class name == null || package name == null ) { string line = reader . read line ( ) ; if ( line == null ) break ; if ( package name == null ) { matcher matcher = package pattern . matcher ( line ) ; if ( matcher . find ( ) ) { package name = matcher . group ( num ) ; } } if ( class name == null ) { matcher matcher = class pattern . matcher ( line ) ; if ( matcher . find ( ) ) { class name = matcher . group ( num ) ; } } } if ( class name == null ) { class name = str ; } } finally { reader . close ( ) ; } }	peek into . flex file to get package and class name.
public static void log ( final string msg , final throwable t ) { if ( debug ) { log ( msg ) ; t . print stack trace ( system . out ) ; } }	prints msg and exception to system.
public static set < uri > fetch rp ( db client db client ) { set < uri > rp protected target v = new hash set < uri > ( ) ; try { list < uri > vpool protection settings ur = db client . query by type ( vpool protection varray settings . class , bool ) ; iterator < vpool protection varray settings > v pool protection settings itr = db client . query iterative objects ( vpool protection varray settings . class , vpool protection settings ur , bool ) ; while ( v pool protection settings itr . has next ( ) ) { vpool protection varray settings r setting = v pool protection settings itr . next ( ) ; if ( null != r setting && ! null column value getter . is null uri ( r setting . get virtual pool ( ) ) ) { rp protected target v . add ( r setting . get virtual pool ( ) ) ; } } } catch ( exception ex ) { log . error ( str , ex ) ; } return rp protected target v ; }	fetch the rp protected target virtual pool uris .
public ns ( file file ) throws io { bytes = new byte [ ( int ) file . length ( ) ] ; random access file raf = new random access file ( file , str ) ; raf . read ( bytes ) ; raf . close ( ) ; }	creates a nsdata object from a file.
public int cardinality ( ) { int sum = num ; for ( long l : this . data ) sum += long . bit count ( l ) ; return sum ; }	compute the number of bits set to 1.
private string de escape literal ( string lit ) { return lit . replace all ( str , str ) ; }	de - escapes a literal.
private static uri cookie uri ( uri uri , http cookie cookie ) { uri cookie uri = uri ; if ( cookie . get domain ( ) != null ) { string domain = cookie . get domain ( ) ; if ( domain . char at ( num ) == str ) { domain = domain . substring ( num ) ; } try { cookie uri = new uri ( uri . get scheme ( ) == null ? str : uri . get scheme ( ) , domain , cookie . get path ( ) == null ? str : cookie . get path ( ) , null ) ; } catch ( uri e ) { log . w ( tag , e ) ; } } return cookie uri ; }	get the real uri from the cookie " domain " and " path " attributes , if they are not set then uses the uri provided ( coming from the response ).
public static void i ( string msg , object ... args ) { if ( ! allow i ) return ; stack trace element caller = get caller stack trace element ( ) ; string tag = generate tag ( caller ) ; if ( s level > level info ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . i ( tag , msg ) ; }	send an info log message.
public static < v > boolean add list not null value ( list < v > source list , v value ) { return ( source list != null && value != null ) ? source list . add ( value ) : bool ; }	add not null entry to list.
public d ( j parent ) { super ( parent , dialog . modality type . document modal ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dnewkeystoretype dialog .
protected void sprint ( long long field ) { sprint ( string . value of ( long field ) ) ; }	pretty printing accumulator function for longs.
private string substitute sub string ( string input , string find , string replace ) { int find length = find . length ( ) ; int replace length = replace . length ( ) ; string builder output = new string builder ( input ) ; int index = input . index of ( find ) ; int output offset = num ; while ( index > - num ) { output . replace ( index + output offset , index + output offset + find length , replace ) ; output offset = output offset + ( replace length - find length ) ; index = input . index of ( find , index + find length ) ; } return output . to string ( ) ; }	replace substrings of one string with another string and return altered string .
public void remove listener ( final l listener ) { validate . not null ( listener , str ) ; listeners . remove ( listener ) ; }	unregisters an event listener .
public void run ( ) { start ( ) ; try { while ( bool ) { thread . sleep ( interval ) ; process config messages ( ) ; } } catch ( interrupted exception e ) { e . print stack trace ( ) ; log . warn ( str ) ; } finally { log . info ( str ) ; stop ( ) ; } }	this method is an infinite loop that periodically checks if there are any new messages in the job coordinator stream , and reads them if they exist.
private int clamp mag ( int value , int abs min , int abs max ) { final int abs value = math . abs ( value ) ; if ( abs value < abs min ) return num ; if ( abs value > abs max ) return value > num ? abs max : - abs max ; return value ; }	clamp the magnitude of value for absmin and absmax.
private void read object ( java . io . object input stream s ) throws io , class not found exception { s . default read object ( ) ; init ( get name ( ) , get mask ( actions ) ) ; }	readobject is called to restore the state of the servicepermission from a stream .
public int pred block index for sources index ( int sources index ) { return operands . get ( sources index ) . block index ; }	gets the index of the pred block associated with the registerspec at the particular getsources ( ) index .
public lockable file writer ( file file , charset encoding , boolean append , string lock dir ) throws io { super ( ) ; file = file . get absolute file ( ) ; if ( file . get parent file ( ) != null ) { file utils . force mkdir ( file . get parent file ( ) ) ; } if ( file . is directory ( ) ) { throw new io ( str ) ; } if ( lock dir == null ) { lock dir = system . get property ( str ) ; } file lock dir file = new file ( lock dir ) ; file utils . force mkdir ( lock dir file ) ; test lock dir ( lock dir file ) ; lock file = new file ( lock dir file , file . get name ( ) + lck ) ; create lock ( ) ; out = init writer ( file , encoding , append ) ; }	constructs a lockablefilewriter with a file encoding .
void append program description ( final wrapping string builder wb ) { if ( ! m program description . equals ( str ) ) { wb . append ( ls ) ; wb . set wrap indent ( num ) ; wb . wrap text with new lines ( m program description ) ; } }	append the description text for this program , if one exists .
public static byte [ ] decode ( string s ) throws java . io . io { return decode ( s , no options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
@ suppress warnings ( str ) private static final url to url ( string location , boolean file ) { if ( file ) { file f = new file ( location ) ; if ( f . exists ( ) ) { try { return f . to url ( ) ; } catch ( url murl ) { return null ; } } else { return null ; } } else { return get url ( location ) ; } }	makes a url out of a location , as either a file or a resource .
protected object parse value ( string string ) { int open paren = string . index of ( str ) ; string type = string . substring ( num , open paren ) ; string value = string . substring ( open paren + num , string . length ( ) - num ) ; if ( type . equals ( str ) ) { return value ; } else if ( type . equals ( str ) ) { return new float ( float . parse float ( value ) ) ; } else if ( type . equals ( str ) ) { return new integer ( integer . parse int ( value ) ) ; } else if ( type . equals ( str ) ) { string tokenizer tok = new string tokenizer ( value , str ) ; int size = tok . count tokens ( ) ; int [ ] values = new int [ size ] ; for ( int i = num ; i < size ; i ++ ) { float fval = float . parse float ( tok . next token ( ) ) ; values [ i ] = math . round ( fval ) ; } return values ; } else { throw new error ( str + type ) ; } }	coerces a string into a value .
public static string to upper case ( string string ) { boolean changed = bool ; char [ ] chars = string . to char array ( ) ; for ( int i = num ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( str <= ch && str >= ch ) { changed = bool ; chars [ i ] = ( char ) ( ch - str + str ) ; } } if ( changed ) { return new string ( chars ) ; } return string ; }	a locale independent version of touppercase .
@ override public void update ( list < env var > data list ) { env var list . clear ( ) ; if ( data list == null ) { for ( env var env var : built in env var map . values ( ) ) { env var list . add ( env var ) ; } } else { for ( env var env var : data list ) { if ( built in env var map . contains key ( env var . get name ( ) ) ) { env var list . add ( new env var ( env var , bool ) ) ; } else { env var list . add ( new env var ( env var , bool ) ) ; } } } set environment variable values ( ) ; }	update the environment variables .
public void make class ( string str , boolean caseless ) { for ( int i = num ; i < str . length ( ) ; i ++ ) make class ( str . char at ( i ) , caseless ) ; }	creates a new character class for each character of the specified string .
protected void notify timestamps to gateways ( entry event impl event ) { version tag holder update time stamp event = new version tag holder ( event . get version tag ( ) ) ; update time stamp event . set operation ( operation . update version stamp ) ; update time stamp event . set key info ( event . get key info ( ) ) ; update time stamp event . set generate callbacks ( bool ) ; update time stamp event . distributed member = event . get distributed member ( ) ; update time stamp event . set new event id ( get system ( ) ) ; if ( event . get region ( ) instanceof bucket region ) { bucket region br = ( bucket region ) event . get region ( ) ; partitioned region pr = br . get partitioned region ( ) ; update time stamp event . set region ( pr ) ; if ( pr . is parallel wan enabled ( ) ) { br . handle wan ( update time stamp event ) ; } if ( pr . is initialized ( ) ) { pr . notify gateway sender ( enum listener event . timestamp update , update time stamp event ) ; } } else { update time stamp event . set region ( event . get region ( ) ) ; notify gateway sender ( enum listener event . timestamp update , update time stamp event ) ; } }	this notifies all wan sites about updated timestamp on local site .
public token next regex ( pattern pattern ) { if ( ! has next regex ( pattern ) ) throw new illegal state exception ( str ) ; matcher matcher = any mention pattern . matcher ( remaining ) ; if ( ! matcher . find ( ) ) throw new illegal state exception ( str ) ; final int start = current position + matcher . start ( ) ; final int end = current position + matcher . end ( ) ; step to ( end ) ; return new token ( this , start , end ) ; }	returns the next occurrence of the regular expression , stepping forward the tokenizer to the next line .
public boolean remove node ( service node node ) { try { return nodes . remove ( node ) ; } catch ( exception e ) { return bool ; } }	remove a service node from the node list.
public string as string ( ) throws io { long len = get content length ( ) ; byte array output stream buf ; if ( num < len ) { buf = new byte array output stream ( ( int ) len ) ; } else { buf = new byte array output stream ( ) ; } write to ( buf ) ; return decode ( buf . to byte array ( ) , get character encoding ( ) ) ; }	return a copy of the result as a string.
public void execute ( ) throws io { string key = str + ( system . current time millis ( ) / num ) ; string b64 key = base64 . encode ( key ) ; send handshake request ( b64 key ) ; receive handshake response ( b64 key ) ; }	executes a websocket handshake . will throw an ioexception if the handshake fails.
public void calculate min ( double min ) { if ( this . min == - num ) { this . min = min ; } else { this . min = math . min ( this . min , min ) ; } }	sets the minimum and deals with the - 1 initialization ! .
private void emit until ( @ nonnegative int task count allowed ) throws io { try { while ( emit queue . size ( ) > task count allowed ) { future < byte [ ] > future = emit queue . remove ( ) ; byte [ ] to write = future . get ( ) ; block sizes . add ( to write . length ) ; out . write ( to write ) ; } try emit ( ) ; } catch ( execution exception e ) { throw new io ( e ) ; } catch ( interrupted exception e ) { throw new io ( ) ; } }	emits any opportunistically available blocks.
void xrot ( double theta ) { theta *= ( pi / num ) ; double ct = math . cos ( theta ) ; double st = math . sin ( theta ) ; float nyx = ( float ) ( yx * ct + zx * st ) ; float nyy = ( float ) ( yy * ct + zy * st ) ; float nyz = ( float ) ( yz * ct + zz * st ) ; float nyo = ( float ) ( yo * ct + zo * st ) ; float nzx = ( float ) ( zx * ct - yx * st ) ; float nzy = ( float ) ( zy * ct - yy * st ) ; float nzz = ( float ) ( zz * ct - yz * st ) ; float nzo = ( float ) ( zo * ct - yo * st ) ; yo = nyo ; yx = nyx ; yy = nyy ; yz = nyz ; zo = nzo ; zx = nzx ; zy = nzy ; zz = nzz ; }	rotate theta degrees about the x axis.
public void test audit completed ( ) { }	test of auditcompleted method , of class auditservicethreadqueueimpl .
public static void scale rect about center ( rect r , float scale ) { if ( scale != num ) { int cx = r . center x ( ) ; int cy = r . center y ( ) ; r . offset ( - cx , - cy ) ; r . left = ( int ) ( r . left * scale + num ) ; r . top = ( int ) ( r . top * scale + num ) ; r . right = ( int ) ( r . right * scale + num ) ; r . bottom = ( int ) ( r . bottom * scale + num ) ; r . offset ( cx , cy ) ; } }	scales a rect about its centroid.
private static char handler parse unprintable ext codes ( string [ ] code strings ) { if ( code strings . length != num ) { throw new illegal state exception ( str + arrays . as list ( code strings ) ) ; } byte [ ] bytes = codes to bytes ( code strings [ num ] , bool ) ; if ( bytes . length != num ) { throw new illegal state exception ( str + arrays . as list ( code strings ) ) ; } return new unprintable ext char handler ( bytes [ num ] ) ; }	returns a unprintableextcharhandler parsed from the given index code strings .
private int measure height ( int measure spec ) { float result ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = m paint selected . get stroke width ( ) + get padding top ( ) + get padding bottom ( ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return ( int ) math . ceil ( result ) ; }	determines the height of this view.
public static boolean is null ( uri id ) { return ( id == null ) || null uri . equals ( id ) ; }	checks if the id is null ( or matches the null_uri ) .
public void update pending list ( ) { while ( m pending list . size ( ) > num && active list has room ( ) ) { download info runnable pending = m pending list . get ( num ) ; pending . change status state ( new active state ( pending ) ) ; } }	check if there are pending downloads and if so move the top one up to the active list .
@ suppress warnings ( str ) public static float value range limit ( float value , float start value , float end value ) { if ( value < math . min ( start value , end value ) ) return math . min ( start value , end value ) ; if ( value > math . max ( start value , end value ) ) return math . max ( start value , end value ) ; return value ; }	limit number within a values range.
protected void create title ( string title ) { string new title ; new title = str + new version ( ) ; if ( title . length ( ) != num ) { new title += str + title ; } set title ( new title ) ; }	creates and displays the title .
public static boolean is connected ( net type net type , network info network info ) { if ( net type == net type . any && network info != null && is connected ( network info ) ) return bool ; else if ( net type == net type . wifi && network info != null && network info . get type ( ) == connectivity manager . type wifi && is connected ( network info ) ) return bool ; else if ( net type == net type . mobile && network info != null && network info . get type ( ) == connectivity manager . type mobile && is connected ( network info ) ) return bool ; return bool ; }	according to the different type of network to determine whether the network connection .
public void delete item ( int position ) { if ( ! is data list empty ( ) && position >= num && position < m data list . size ( ) ) { m data list . remove ( position ) ; notify item removed ( position ) ; } }	delete an item by position.
private int calculate graident channel ( int source channel , int dest channel , int distance , int offset ) { if ( source channel == dest channel ) { return source channel ; } float ratio = ( ( float ) offset ) / ( ( float ) distance ) ; int pos = ( int ) ( math . abs ( source channel - dest channel ) * ratio ) ; if ( source channel > dest channel ) { return source channel - pos ; } else { return source channel + pos ; } }	converts the color channel value according to the offest within the distance.
public static void add startup listener ( start up listener s ) { m . add ( s ) ; }	add a listener to be notified when startup is complete .
public static void close quiet ( @ nullable selection key rsrc ) { if ( rsrc != null ) close quiet ( rsrc . channel ( ) ) ; }	quietly closes given resource ignoring possible checked exceptions .
public completable future < new file > run ( ) { log . log ( level . fine , str , files . size ( ) ) ; completable future < new file > file creation = new completable future < > ( ) ; final list < ts > fjp files = this . files ; task pool . execute ( null ) ; synchronized ( outstanding ) { outstanding . add ( file creation ) ; } this . files = new linked list < > ( ) ; return file creation ; }	start creating the optimized file.
private static key create des ( byte [ ] bytes , int offset ) { byte [ ] key bytes = new byte [ num ] ; system . arraycopy ( bytes , offset , key bytes , num , num ) ; byte [ ] material = new byte [ num ] ; material [ num ] = key bytes [ num ] ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num | ( key bytes [ num ] & num ) > > > num ) ; material [ num ] = ( byte ) ( key bytes [ num ] << num ) ; odd parity ( material ) ; return new secret key spec ( material , str ) ; }	creates a des encryption key from the given key material .
static void check desc ( final string desc , final boolean can be void ) { int end = check desc ( desc , num , can be void ) ; if ( end != desc . length ( ) ) { throw new illegal argument exception ( str + desc ) ; } }	checks that the given string is a valid type descriptor .
protected js output new js output ( module m ) throws io { return new js output ( m , is compiling language module ( ) ) ; }	this exists solely so that the web ide can override it and use a different jsoutput.
public string text ( ) { string builder sb = new string builder ( ) ; for ( node node : nodes ) { sb . append ( node . get text content ( ) ) ; } return sb . to string ( ) ; }	gets the combined text contents of each element in the set of matched elements , including their descendants.
public void add line ( int start line , string source file , int repeat count , int output line , int output increment ) { lines . add ( new line ( start line , source file , repeat count , output line , output increment ) ) ; }	adds a line from the smap.
public string ( string buffer stringbuffer ) { offset = num ; synchronized ( stringbuffer ) { value = stringbuffer . share value ( ) ; count = stringbuffer . length ( ) ; } }	creates a string from the contents of a stringbuffer .
public int size ( ) { return all . size ( ) ; }	return the number of signers in the collection .
public process execute async ( final command line command , final map < string , string > environment , final execute result handler handler ) throws io { if ( working directory != null && ! working directory . exists ( ) ) { throw new io ( working directory + str ) ; } return execute internal ( command , environment , working directory , stream handler , handler ) ; }	methods for starting asynchronous execution.
public liberty manager client ( ) { }	constructs the libertymanager client.
private void check compliance attributes ( attr set attr set , boolean ignore compliance ) throws am { if ( ! ignore compliance && compliance services impl . is compliance user deletion enabled ( ) ) { compliance impl . verify attributes ( attr set ) ; } }	checks for compliance related attributes if applicable . the check can be over - ridden by setting the ignorecompliance to true.
private void update zoning map ( un managed export mask mask , list < initiator > initiators , list < storage port > storage ports ) { zone info map zoning map = network device controller . get initiators zone info map ( initiators , storage ports ) ; for ( zone info zone info : zoning map . values ( ) ) { log . info ( str , new object [ ] { zone info . get zone name ( ) , zone info . get initiator wwn ( ) , zone info . get port wwn ( ) } ) ; } mask . set zoning map ( zoning map ) ; }	set mask zoning map.
public invitation status wait invitation answer ( ) { return wait invitation answer ( m ringing period ) ; }	wait session invitation answer.
private double [ ] [ ] x prime ( int t ) { double [ ] [ ] x = new double [ num ] [ get num lags ( ) * num vars ] ; for ( int i = num ; i < get num lags ( ) ; i ++ ) { double [ ] [ ] y prime = y prime ( t - i - num ) ; system . arraycopy ( y prime [ num ] , num , x [ num ] , i * num vars , num vars ) ; } return x ; }	constructs the x ( t ) vector .
public int size ( ) { return components . size ( ) ; }	returns the number of components that are stored in this container .
public void test round math context precision0 ( ) { string a = str ; int a scale = num ; int precision = num ; rounding mode rm = rounding mode . half up ; math context mc = new math context ( precision , rm ) ; string res = str ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal result = a number . round ( mc ) ; assert equals ( str , res , result . to string ( ) ) ; assert equals ( str , a scale , result . scale ( ) ) ; }	round ( bigdecimal , mathcontext ) when precision = 0.
public void omit less freq ( ) { if ( name == null ) return ; int threshold = n words [ num ] / less freq ratio ; if ( threshold < minimum freq ) threshold = minimum freq ; set < string > keys = freq . key set ( ) ; int roman = num ; for ( iterator < string > i = keys . iterator ( ) ; i . has next ( ) ; ) { string key = i . next ( ) ; int count = freq . get ( key ) ; if ( count <= threshold ) { n words [ key . length ( ) - num ] -= count ; i . remove ( ) ; } else { if ( key . matches ( str ) ) { roman += count ; } } } if ( roman < n words [ num ] / num ) { set < string > keys2 = freq . key set ( ) ; for ( iterator < string > i = keys2 . iterator ( ) ; i . has next ( ) ; ) { string key = i . next ( ) ; if ( key . matches ( str ) ) { n words [ key . length ( ) - num ] -= freq . get ( key ) ; i . remove ( ) ; } } } }	eliminate below less frequency n - grams and noise latin alphabets.
public static public key selector from string ( string type ) { if ( type != null ) { for ( public key selector key selector : public key selector . values ( ) ) { if ( type . equals ignore case ( key selector . type ) ) { return key selector ; } } } return null ; }	translates a string into a token endpoint auth method type .
public static sorted map < integer , integer > generate sorted tag map ( string [ ] partitions , map < string , string > tags ) { final sorted map < integer , integer > tag hash map = new tree map < integer , integer > ( ) ; for ( map . entry < string , string > entry : tags . entry set ( ) ) { final string tag name = entry . get key ( ) ; final string tag value = entry . get value ( ) ; if ( tag value == null || is partition tag ( partitions , tag name ) ) continue ; tag hash map . put ( tag name . hash code ( ) , tag value . hash code ( ) ) ; } return tag hash map ; }	generate the internal sorted hashmap for tags.
public static void describe shape detail ( shape shape , double flattening ) { path iterator pi2 = shape . get path iterator ( null ) ; flattening path iterator pi = new flattening path iterator ( pi2 , flattening ) ; double [ ] coords = new double [ num ] ; int point count = num ; debug . output ( str + flattening + str ) ; while ( ! pi . is done ( ) ) { int type = pi . current segment ( coords ) ; debug . output ( str + type + str + ( point count ++ ) + str + coords [ num ] + str + coords [ num ] ) ; pi . next ( ) ; } debug . output ( str + point count + str ) ; }	utility method that iterates over a shape object and prints out the points.
protected static string shorten classname ( string nam , char c ) { final int lastdot = nam . last index of ( c ) ; if ( lastdot >= num ) { nam = nam . substring ( lastdot + num ) ; } return nam ; }	shorten the class name .
public void add ( t graphic ) { synchronized ( m lock ) { m graphics . add ( graphic ) ; } post invalidate ( ) ; }	adds a graphic to the overlay .
public string to string ( ) { string buffer sbuf = new string buffer ( ) ; type parameter . to string ( sbuf , type params ) ; sbuf . append ( str ) ; type . to string ( sbuf , params ) ; sbuf . append ( str ) ; sbuf . append ( ret type ) ; if ( exceptions . length > num ) { sbuf . append ( str ) ; type . to string ( sbuf , exceptions ) ; } return sbuf . to string ( ) ; }	returns the string representation .
@ override public void flip ( x11 component peer peer , component target , volatile image x back buffer , int x1 , int y1 , int x2 , int y2 , buffer capabilities . flip contents flip action ) { if ( flip action == buffer capabilities . flip contents . copied ) { surface manager vsm = surface manager . get manager ( x back buffer ) ; surface data sd = vsm . get primary surface data ( ) ; if ( sd instanceof glxv ) { glxv vsd = ( glxv ) sd ; surface data bbsd = vsd . get flip surface ( ) ; d bbg = new d ( bbsd , color . black , color . white , null ) ; try { bbg . draw image ( x back buffer , num , num , null ) ; } finally { bbg . dispose ( ) ; } } else { graphics g = peer . get graphics ( ) ; try { g . draw image ( x back buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip action == buffer capabilities . flip contents . prior ) { return ; } ogl . swap buffers ( peer . get content window ( ) ) ; if ( flip action == buffer capabilities . flip contents . background ) { graphics g = x back buffer . get graphics ( ) ; try { g . set color ( target . get background ( ) ) ; g . fill rect ( num , num , x back buffer . get width ( ) , x back buffer . get height ( ) ) ; } finally { g . dispose ( ) ; } } }	performs the native glx flip operation for the given target component .
public boolean add property ( owl property property ) { property . add restriction ( this ) ; return properties . add ( property ) ; }	add " onproperty p " information , and tell p to point back here .
public static google analytics initialise google analytics ( context context , string tracker id , final exception parser callback ) { m analytics = google analytics . get instance ( context ) ; m analytics . set local dispatch period ( num ) ; m tracker = m analytics . new tracker ( tracker id ) ; m tracker . enable exception reporting ( bool ) ; m tracker . enable auto activity tracking ( bool ) ; thread . uncaught exception handler handler = thread . get default uncaught exception handler ( ) ; if ( handler != null && handler instanceof exception reporter ) { exception reporter exception reporter = ( exception reporter ) handler ; exception reporter . set exception parser ( callback ) ; thread . set default uncaught exception handler ( exception reporter ) ; log . d ( log tag , str ) ; } else { log . e ( log tag , str ) ; } return m analytics ; }	initialise google analytics immediately so it will catch all sorts of errors prior to easytracker onstart.
void on moved ( ) { double diff = system . current time millis ( ) - time stamp ; time stamp = num ; if ( diff > discard threshold ) { return ; } double recent jitter = num ; double sum = num ; for ( int i = num ; i < vector length ; i ++ ) { double old = times [ i ] ; double avg = ( diff + old ) / num ; recent jitter += math . abs ( old - diff ) ; times [ i ] = avg ; diff = old ; sum += avg ; } recent jitter /= num ; jitter = ( jitter + num * math . max ( jitter , recent jitter ) + recent jitter ) / num ; prediction = turn length / ( sum / vector length + jitter ) ; wt window manager wm = wt window manager . get instance ( ) ; wm . set property ( speed property , double . to string ( prediction ) ) ; wm . set property ( jitter property , double . to string ( jitter ) ) ; }	called when the user moves.
public id ( data input in ) throws io { this . most sig = in . read long ( ) ; this . least sig = in . read long ( ) ; }	reads in 16 bytes in standard network byte order .
public void on enter element consumed ( string uri , string local name , string qname , attributes atts ) throws sax { att stack . push ( current atts = new attributes impl ( atts ) ) ; ns effective stack . push ( new integer ( ns effective ptr ) ) ; ns effective ptr = namespaces . size ( ) ; }	called by the generated handler code when an enter element event is consumed.
private void add finally ( array list return list , stmnt finally block ) throws compile error { bytecode bc = bytecode ; int n = return list . size ( ) ; for ( int i = num ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) return list . get ( i ) ; int pc = ret [ num ] ; bc . write16bit ( pc , bc . current pc ( ) - pc + num ) ; return hook hook = new jsr hook2 ( this , ret ) ; finally block . accept ( this ) ; hook . remove ( this ) ; if ( ! has returned ) { bc . add opcode ( opcode . goto ) ; bc . add index ( pc + num - bc . current pc ( ) ) ; } } }	adds a finally clause for earch return statement .
public object next meta ( ) throws json { char c ; char q ; do { c = next ( ) ; } while ( character . is whitespace ( c ) ) ; switch ( c ) { case num : throw syntax error ( str ) ; case str : return xml . lt ; case str : return xml . gt ; case str : return xml . slash ; case str : return xml . eq ; case str : return xml . bang ; case str : return xml . quest ; case str : case str : q = c ; for ( ; ; ) { c = next ( ) ; if ( c == num ) { throw syntax error ( str ) ; } if ( c == q ) { return boolean . true ; } } default : for ( ; ; ) { c = next ( ) ; if ( character . is whitespace ( c ) ) { return boolean . true ; } switch ( c ) { case num : case str : case str : case str : case str : case str : case str : case str : case str : back ( ) ; return boolean . true ; } } } }	returns the next xml meta token.
public static void write json ( collection collection , writer out ) throws io { if ( collection == null ) { out . write ( str ) ; return ; } boolean first = bool ; iterator iter = collection . iterator ( ) ; out . write ( str ) ; while ( iter . has next ( ) ) { if ( first ) first = bool ; else out . write ( str ) ; object value = iter . next ( ) ; if ( value == null ) { out . write ( str ) ; continue ; } json . write json ( value , out ) ; } out . write ( str ) ; }	encode a list into json text and write it to out.
protected int [ ] read color table ( final int ncolors ) { final int nbytes = num * ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { raw data . get ( c ) ; tab = new int [ num ] ; int i = num ; int j = num ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & num ; final int g = ( c [ j ++ ] ) & num ; final int b = ( c [ j ++ ] ) & num ; tab [ i ++ ] = num | ( r << num ) | ( g << num ) | b ; } } catch ( final buffer underflow exception e ) { log . w ( tag , str , e ) ; status = status format error ; } return tab ; }	reads color table as 256 rgb integer values.
void touch ( boolean open read only ) throws io { if ( is read only || open read only ) { throw new io ( str ) ; } last modified = system . current time millis ( ) ; }	update the last modified time .
@ sneaky throws public void add key to keystore ( key store key store , x509 certificate cert , rsa private key , string alias , string password ) { key store . password protection pass = new key store . password protection ( password . to char array ( ) ) ; certificate [ ] certificate chain = { cert } ; key store . set entry ( alias , new key store . private key entry ( private key , certificate chain ) , pass ) ; }	based on a public certificate , private key , alias and password , this method will load the certificate and private key as an entry into the keystore , and it will set the provided alias and password to the keystore entry .
public boolean needs reload ( file file ) { return f files to reoad . contains ( file ) ; }	returns true if the given indicator file needs to be reloaded .
public put repository request source ( byte [ ] repository definition ) { return source ( repository definition , num , repository definition . length ) ; }	parses repository definition . json , smile and yaml formats are supported.
private void disable buttons ( ) { set fire enabled ( bool ) ; set skip enabled ( bool ) ; set twist enabled ( bool ) ; set next enabled ( bool ) ; but done . set enabled ( bool ) ; set flip arms enabled ( bool ) ; set fire mode enabled ( bool ) ; set next target enabled ( bool ) ; }	disables all buttons in the interface.
public boolean is additive number ( string num ) { int n = num . length ( ) ; for ( int i = num ; i <= n / num ; i ++ ) { if ( num . char at ( num ) == str && i > num ) { return bool ; } big integer num1 = new big integer ( num . substring ( num , i ) ) ; for ( int j = num ; math . max ( i , j ) <= n - i - j ; j ++ ) { if ( num . char at ( i ) == str && j > num ) { break ; } big integer num2 = new big integer ( num . substring ( i , i + j ) ) ; if ( is additive number ( num1 , num2 , i + j , num ) ) { return bool ; } } } return bool ; }	recursive . generate the first and second of the sequence , check if the rest of the string match the sum recursively . i is the length of first number , j is the length of thgste second .
@ override public void write ( string str ) { int start = num ; while ( start < str . length ( ) ) { int end = math . min ( start + max message length , str . length ( ) ) ; log . i ( tag , str . substring ( start , end ) ) ; start = end ; } }	writes the given string to android logcat .
protected void add to quarantine queue ( node port tuple npt ) { if ( quarantine queue . contains ( npt ) == bool ) { quarantine queue . add ( npt ) ; } }	add a switch port to the quarantine queue.
private carbon dictionary sort info create column sort info ( carbon dictionary sort model [ ] dictionary sort models ) { int [ ] sort index ; int [ ] sort index inverted ; arrays . sort ( dictionary sort models ) ; sort index = new int [ dictionary sort models . length ] ; sort index inverted = new int [ dictionary sort models . length ] ; for ( int i = num ; i < dictionary sort models . length ; i ++ ) { carbon dictionary sort model dictionary sort model = dictionary sort models [ i ] ; sort index [ i ] = dictionary sort model . get key ( ) ; sort index inverted [ dictionary sort model . get key ( ) - num ] = i + num ; } dictionary sort models = null ; list < integer > sort index list = convert to list ( sort index ) ; list < integer > sort index inverted list = convert to list ( sort index inverted ) ; return new carbon dictionary sort info ( sort index list , sort index inverted list ) ; }	the method prepares the sort_index and sort_index_inverted data.
private void add feature ( json node feature , int index ) { point feature feat = null ; try { feat = point feature . from json node ( feature ) ; } catch ( empty polygon exception e ) { log . warn ( str ) ; return ; } catch ( unsupported geometry exception e ) { log . warn ( e . message ) ; return ; } if ( feat == null ) { return ; } add feature ( feat , index ) ; }	add one geojson feature to this freeformpointset from a jackson node tree.
public bit string ( final string value ) { this ( value . length ( ) ) ; for ( int i = num ; i < value . length ( ) ; i ++ ) { if ( value . char at ( i ) == str ) { set bit ( value . length ( ) - ( i + num ) , bool ) ; } else if ( value . char at ( i ) != str ) { throw new illegal argument exception ( str + i ) ; } } }	initialises the bit string from a character string of 1s and 0s in big - endian order .
public void sort ( comparator < individual > comparator ) { collections . sort ( individuals , comparator ) ; }	sorts the individuals in ascending order according to their performance , thus the best one will be in last position .
public void write ( writer writer ) throws exception { writer . write ( to string ( ) ) ; writer . flush ( ) ; }	writes the current dom document into the given writer .
public safe async task ( ) { this . executor = default executor ; }	sets executor to executors . newfixedthreadpool ( default_pool_size ) and handler to new handler ( ).
public static boolean is cglib renamed method ( method renamed method ) { string name = renamed method . get name ( ) ; if ( name . starts with ( cglib renamed method prefix ) ) { int i = name . length ( ) - num ; while ( i >= num && character . is digit ( name . char at ( i ) ) ) { i -- ; } return ( ( i > cglib renamed method prefix . length ( ) ) && ( i < name . length ( ) - num ) && ( name . char at ( i ) == str ) ) ; } return bool ; }	determine whether the given method is a cglib ' renamed ' method , following the pattern " cglib $ methodname $ 0 " .
public pw ( string bundle name , string err code , object [ ] args ) { super ( bundle name , err code , args ) ; err list = new array list ( num ) ; err list . add ( get message ( ) ) ; }	creates a password reset exception object with localizable error message .
public static string [ ] union arrays ( string [ ] array1 , string [ ] array2 ) { if ( array1 == null ) { return array2 ; } if ( array2 == null ) { return array1 ; } set < string > set = new linked hash set < > ( ) ; set . add all ( arrays . as list ( array1 ) ) ; set . add all ( arrays . as list ( array2 ) ) ; return set . to array ( new string [ set . size ( ) ] ) ; }	returns a union of 2 arrays , ensuring that each string exists only once .
boolean is state change ( x window , x e ) { if ( ! window . is showing ( ) ) { state log . finer ( str ) ; return bool ; } int wm state = window . get wm ( ) ; if ( wm state == x . withdrawn state ) { state log . finer ( str ) ; return bool ; } else { if ( state log . is loggable ( platform logger . level . finer ) ) { state log . finer ( str + wm state ) ; } } boolean is state change = bool ; if ( e . get atom ( ) == xa wm state . get atom ( ) ) { is state change = bool ; } for ( x proto : get protocols ( x . class ) ) { is state change |= proto . is state change ( e ) ; if ( state log . is loggable ( platform logger . level . finest ) ) { state log . finest ( proto + str + is state change ) ; } } return is state change ; }	\ notice window state change when wm changes a property on the window.
@ override public x execute ( x xctxt ) throws javax . xml . transform . transformer exception { node xpath owner node = ( node ) xctxt . get owner object ( ) ; if ( xpath owner node == null ) { return null ; } int xpath owner node dtm = xctxt . get dtm ( xpath owner node ) ; int current node = xctxt . get current node ( ) ; dtm dtm = xctxt . get dtm ( current node ) ; int doc context = dtm . get document ( ) ; if ( dtm . null == doc context ) { error ( xctxt , xpath . er context has no ownerdoc , null ) ; } { document current doc = xml . get owner document ( dtm . get node ( current node ) ) ; document xpath owner doc = xml . get owner document ( xpath owner node ) ; if ( current doc != xpath owner doc ) { throw new transformer exception ( i18n . translate ( str ) ) ; } } x nodes = new x ( xctxt . get dtm ( ) ) ; dtm node set = nodes . mutable nodeset ( ) ; { int here node = dtm . null ; switch ( dtm . get node type ( xpath owner node dtm ) ) { case node . attribute node : case node . processing instruction node : { here node = xpath owner node dtm ; node set . add node ( here node ) ; break ; } case node . text node : { here node = dtm . get parent ( xpath owner node dtm ) ; node set . add node ( here node ) ; break ; } default : break ; } } node set . detach ( ) ; return nodes ; }	the here function returns a node - set containing the attribute or processing instruction node or the parent element of the text node that directly bears the xpath expression.
public list < local time > top ( int n ) { list < local time > top = new array list < > ( ) ; int [ ] values = data . to int array ( ) ; int arrays . parallel quick sort ( values , reverse int comparator . instance ( ) ) ; for ( int i = num ; i < n && i < values . length ; i ++ ) { top . add ( packed local time . as local time ( values [ i ] ) ) ; } return top ; }	returns the largest ( " top " ) n values in the column.
public static string grab class ( string signature ) { matcher matcher = sig re . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group count ( ) != num ) logger . error ( str , signature ) ; return matcher . group ( num ) ; }	grab the class from the signature.
public time series metric delta set ( stream < entry < tags , metric value > > td ) { values = any2 . right ( td . collect ( collectors . to map ( null , null , null , null ) ) ) ; }	create a metricdelta set for tagged metrics and initialize it with the given collection .
public int size ( ) { return nodes . size ( ) ; }	returns the number of nodes in this model ' s nodelist .
@ override public final e next element ( ) { e result = m . get ( m ) ; m ++ ; if ( m == m ) { m ++ ; } return result ; }	returns the next element .
private byte string escape bytes ( final byte string value ) { if ( ! need escaping ( value ) ) { return value ; } final byte string builder builder = new byte string builder ( ) ; for ( int i = num ; i < value . length ( ) ; i ++ ) { final byte b = value . byte at ( i ) ; if ( is byte to escape ( b ) ) { builder . append byte ( dn . normalized esc byte ) ; } builder . append byte ( b ) ; } return builder . to byte string ( ) ; }	return a new byte string with bytes 0x00 , 0x01 and 0x02 escaped.
public input builder < t > repeat all ( int times ) { list < t > to append = new array list < > ( ) ; for ( int i = num ; i < times ; i ++ ) { to append . add all ( input ) ; } input . add all ( to append ) ; return this ; }	repeat the current input list.
public final void rename class ( map classnames ) { string jvm new this name = ( string ) classnames . get ( descriptor . to jvm name ( thisclassname ) ) ; if ( jvm new this name != null ) thisclassname = descriptor . to java name ( jvm new this name ) ; const pool . rename class ( classnames ) ; attribute info . rename class ( attributes , classnames ) ; array list list = methods ; int n = list . size ( ) ; for ( int i = num ; i < n ; ++ i ) { method info minfo = ( method info ) list . get ( i ) ; string desc = minfo . get descriptor ( ) ; minfo . set descriptor ( descriptor . rename ( desc , classnames ) ) ; attribute info . rename class ( minfo . get attributes ( ) , classnames ) ; } list = fields ; n = list . size ( ) ; for ( int i = num ; i < n ; ++ i ) { field info finfo = ( field info ) list . get ( i ) ; string desc = finfo . get descriptor ( ) ; finfo . set descriptor ( descriptor . rename ( desc , classnames ) ) ; attribute info . rename class ( finfo . get attributes ( ) , classnames ) ; } }	replaces all occurrences of several class names in the class file .
@ suppress warnings ( str ) public void handle button3 request ( request invocation event event ) { back trail ( ) ; try { string name = ( string ) get page session attribute ( save vb name ) ; view bean vb = get view bean ( class . for name ( name ) ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( class not found exception e ) { debug . warning ( str , e ) ; } }	called on request from the ui to return to the previous page .
public ion exception ( throwable cause ) { super ( cause . get message ( ) , cause ) ; }	constructs a new exception with the given cause , copying the message from the cause into this instance .
public final double distance ( ) { return math . sqrt ( distance square ( ) ) ; }	the " size " of the line from 0 , 0 to x , y.
@ override public void done ( ) { super . done ( ) ; if ( m num tests expected > m num tests run ) { handle test run failed ( string . format ( str , m num tests expected , m num tests run ) ) ; } else if ( m test run in progress ) { handle test run failed ( str ) ; } }	called by parent when adb session is complete .
public list < challenge > challenges ( ) { string response field ; if ( code == http unauthorized ) { response field = str ; } else if ( code == http proxy auth ) { response field = str ; } else { return collections . empty list ( ) ; } return ok headers . parse challenges ( headers ( ) , response field ) ; }	returns the authorization challenges appropriate for this response ' s code.
byte [ ] to bytes ( ssl session ) { if ( ! ( session instanceof ssl ) ) { return null ; } ssl ssl session = ( ssl ) session ; try { byte array output stream baos = new byte array output stream ( ) ; data output stream daos = new data output stream ( baos ) ; daos . write int ( open ssl ) ; byte [ ] data = ssl session . get encoded ( ) ; daos . write int ( data . length ) ; daos . write ( data ) ; certificate [ ] certs = session . get peer certificates ( ) ; daos . write int ( certs . length ) ; for ( certificate cert : certs ) { data = cert . get encoded ( ) ; daos . write int ( data . length ) ; daos . write ( data ) ; } return baos . to byte array ( ) ; } catch ( io e ) { log ( e ) ; return null ; } catch ( certificate encoding exception e ) { log ( e ) ; return null ; } }	converts the given session to bytes .
public mersenne twister ( ) { mt = new int [ n ] ; set seed ( system . current time millis ( ) + system . identity hash code ( this ) ) ; }	creates a new random number generator.
private void verify timestamp ( x509 certificate cert ) throws cert path validator exception { string msg = str ; if ( debug != null ) debug . println ( str + msg + str + date . to string ( ) + str ) ; try { cert . check validity ( date ) ; } catch ( certificate expired exception e ) { throw new cert path validator exception ( msg + str , e , null , - num , basic reason . expired ) ; } catch ( certificate not yet valid exception e ) { throw new cert path validator exception ( msg + str , e , null , - num , basic reason . not yet valid ) ; } if ( debug != null ) debug . println ( msg + str ) ; }	internal method to verify the timestamp on a certificate.
public static byte [ ] encrypt password ( final string password , final byte [ ] seed ) throws no such algorithm exception { if ( password == null || password . equals ( str ) ) { return new byte [ num ] ; } final message digest message digest = message digest . get instance ( str ) ; final byte [ ] stage1 = message digest . digest ( password . get bytes ( ) ) ; message digest . reset ( ) ; final byte [ ] stage2 = message digest . digest ( stage1 ) ; message digest . reset ( ) ; message digest . update ( seed ) ; message digest . update ( stage2 ) ; final byte [ ] digest = message digest . digest ( ) ; final byte [ ] return bytes = new byte [ digest . length ] ; for ( int i = num ; i < digest . length ; i ++ ) { return bytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return return bytes ; }	encrypts a password < p > protocol for authentication is like this : 1.
public int rows ( ) { return rows ; }	returns the number of rows of the receiver .
public static string array2hex ( final byte [ ] array ) { return byte array2 string ( array , str , str , bool , num ) ; }	a byte array into its hex string representation.
private byte [ ] write checked bytes ( message nano proto ) { backup protos . checked message wrapper = new backup protos . checked message ( ) ; wrapper . payload = message nano . to byte array ( proto ) ; cr checksum = new cr ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . get value ( ) ; return message nano . to byte array ( wrapper ) ; }	wrap a proto in a checkedmessage and compute the checksum .
public double reduce to ( int width , int height , double limit ) { int w = get icon width ( ) ; int h = get icon height ( ) ; double scale = num ; if ( w > width ) { scale = ( ( double ) width ) / w ; } if ( h > height ) { scale = math . min ( scale , ( ( double ) height ) / h ) ; } if ( scale < num ) { if ( limit > num ) { scale = math . max ( scale , limit ) ; } affine transform t = affine transform . get scale instance ( scale , scale ) ; transform image ( ( int ) math . ceil ( scale * w ) , ( int ) math . ceil ( scale * h ) , t , null ) ; } return scale ; }	if necessary , reduce this image to within ' width ' x ' height ' dimensions . limit the reduction by ' limit '.
public void install builtin sound ( string sound identifier , input stream data ) throws io { builtin sounds . put ( sound identifier , convert builtin sound ( data ) ) ; }	installs a replacement sound as the builtin sound responsible for the given sound identifier ( this will override the system sound if such a sound exists ) .
private integer count fragment filtered pages ( list < string > template fragments , boolean whitelist ) throws wiki api exception { try { int count = num ; prepared statement statement = null ; result set result = null ; try { string buffer sql string = new string buffer ( ) ; string buffer subconditions = new string buffer ( ) ; sql string . append ( str + generator constants . table tplid tplname + str + generator constants . table tplid pageid + str + ( whitelist ? str : str ) + str ) ; for ( @ suppress warnings ( str ) string fragment : template fragments ) { if ( subconditions . length ( ) != num ) { subconditions . append ( str ) ; } subconditions . append ( str ) ; } sql string . append ( subconditions ) ; sql string . append ( str ) ; statement = connection . prepare statement ( sql string . to string ( ) ) ; int cur idx = num ; for ( string fragment : template fragments ) { fragment = fragment . to lower case ( ) ; fragment = fragment . trim ( ) ; fragment = fragment . replace all ( str , str ) ; statement . set string ( cur idx ++ , fragment + str ) ; } result = execute ( statement ) ; if ( result == null ) { return num ; } if ( result . next ( ) ) { count = result . get int ( num ) ; } } finally { if ( statement != null ) { statement . close ( ) ; } if ( result != null ) { result . close ( ) ; } } return count ; } catch ( exception e ) { throw new wiki api exception ( e ) ; } }	returns the number of all pages that contain a template the name of which starts with any of the the given strings .
public static int find name ( string name , int [ ] table ) { for ( int i = num ; i < table . length ; i ++ ) { if ( name . equals ( get name ( table [ i ] ) ) ) { return i ; } } return - num ; }	get the encoding value of a glyph given its name and a charset .
private void score track results ( collection < track > tracks , search query query , collection < scored result > output ) { for ( track track : tracks ) { double score = score track result ( query , track ) ; output . add ( new scored result ( track , score ) ) ; } }	scores a collection of track results .
private long current time ( ) { return system . current time millis ( ) / num ; }	returns a current time seconds from epoch .
private static byte [ ] encode ( double latitude , double longitude ) { byte [ ] bytes = new byte [ num * integer . bytes ] ; numeric utils . int to sortable bytes ( encode latitude ( latitude ) , bytes , num ) ; numeric utils . int to sortable bytes ( encode longitude ( longitude ) , bytes , integer . bytes ) ; return bytes ; }	sugar encodes a single point as a byte array.
public static void put long volatile ( object obj , long off , long val ) { unsafe . put long volatile ( obj , off , val ) ; }	stores long value with volatile semantic .
public static list < string > run ( list < string > commands ) { return shell . run ( str , commands . to array ( new string [ commands . size ( ) ] ) , null , bool ) ; }	runs commands as root ( if available ) and return output.
public void circle ( double x , double y , double r ) { if ( r < num ) throw new illegal argument exception ( str ) ; double xs = scale x ( x ) ; double ys = scale y ( y ) ; double ws = factor x ( num * r ) ; double hs = factor y ( num * r ) ; if ( ws <= num && hs <= num ) pixel ( x , y ) ; else offscreen . draw ( new d . double ( xs - ws / num , ys - hs / num , ws , hs ) ) ; draw ( ) ; }	draws a circle of radius r , centered on ( x , y ) .
final public void println ( double v ) { writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( newline , num , newline . length ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a double followed by a newline .
public void write s ( int value ) throws io { flush bits ( ) ; out . write ( value & num ) ; out . write ( value > > num ) ; out . write ( value > > num ) ; out . write ( value > > num ) ; bytes written += num ; }	write a 32 bit signed value.
private static void map ( final string builder buffer , final byte sequence sequence , final boolean trim , final boolean fold case ) { final string value = sequence . to string ( ) ; for ( int i = num ; i < value . length ( ) ; i ++ ) { final char c = value . char at ( i ) ; if ( map 2 null . contains ( c ) ) { continue ; } if ( map 2 space . contains ( c ) ) { if ( can map to space ( buffer , trim ) ) { buffer . append ( space char ) ; } continue ; } if ( fold case ) { final string mapping = case map table . get ( c ) ; if ( mapping != null ) { buffer . append ( mapping ) ; continue ; } } buffer . append ( c ) ; } }	checks each character and replaces it with its mapping .
public void add button pressed listener ( field config string button interface listener ) { if ( button pressed listener list == null ) { button pressed listener list = new array list < field config string button interface > ( ) ; } button pressed listener list . add ( listener ) ; }	adds the button pressed listener .
public void dispose ( ) { log debug ( str ) ; m setup done = bool ; if ( m service conn != null ) { log debug ( str ) ; if ( m context != null ) m context . unbind service ( m service conn ) ; m service conn = null ; m service = null ; m purchase listener = null ; } }	dispose of object , releasing resources.
private void fill xml ( attributes att , int index ) { fill q ( f attribute q , att . get uri ( index ) , att . get local name ( index ) , att . get q ( index ) ) ; string type = att . get type ( index ) ; f attributes . add attribute ns ( f attribute q , ( type != null ) ? type : xml . f cdata , att . get value ( index ) ) ; }	adds an attribute to the xmlattributes object .
public j create property gui ( property consumer pc ) { this . property consumer = pc ; properties props = new properties ( ) ; props = pc . get properties ( props ) ; properties info = new properties ( ) ; info = pc . get property info ( info ) ; string prefix = pc . get property prefix ( ) ; return create property gui ( prefix , props , info ) ; }	creates a jcomponent with the properties to be changed.
public long copy ( string filename , output stream out , long offset , long size ) throws io , interrupted exception { if ( size < num ) { return num ; } buffered input stream is = new buffered input stream ( get file input stream ( filename ) ) ; byte [ ] buf = new byte [ num * num ] ; int bytes read ; long pos = num ; long remaining = size ; try { if ( offset != num ) { is . skip ( offset ) ; pos += offset ; } while ( remaining != num ) { int max = buf . length ; if ( max > remaining ) { max = ( int ) remaining ; } bytes read = is . read ( buf , num , max ) ; if ( bytes read == - num ) { break ; } out . write ( buf , num , bytes read ) ; pos += bytes read ; remaining -= bytes read ; } out . flush ( ) ; } catch ( exception e ) { out . flush ( ) ; } finally { try { is . close ( ) ; } catch ( exception e ) { } } return pos ; }	copies the given file to the output stream continously , i.
private static void deserialize header ( kdb header kdb header , data input data input ) throws io { kdb header . set flags ( data input . read int ( ) ) ; kdb header . set version ( data input . read int ( ) ) ; byte [ ] buffer = new byte [ num ] ; data input . read fully ( buffer ) ; kdb header . set master seed ( buffer ) ; buffer = new byte [ num ] ; data input . read fully ( buffer ) ; kdb header . set encryption iv ( buffer ) ; kdb header . set group count ( data input . read int ( ) ) ; kdb header . set entry count ( data input . read int ( ) ) ; byte [ ] buffer32 = new byte [ num ] ; data input . read fully ( buffer32 ) ; kdb header . set content hash ( buffer32 ) ; buffer32 = new byte [ num ] ; data input . read fully ( buffer32 ) ; kdb header . set transform seed ( buffer32 ) ; kdb header . set transform rounds ( data input . read int ( ) ) ; }	deserialize a header from a source into the supplied kdbheader.
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . insert data ( num , str ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; }	runs the test case .
public boolean are all permissions granted ( ) { return denied permission responses . is empty ( ) ; }	returns whether the user has granted all the requested permission.
private string fetch charset from cache ( client client , locale loc ) { map c cache = ( map ) charset cache . get ( client . get client type ( ) ) ; string val = null ; if ( c cache != null ) { val = ( string ) c cache . get ( loc ) ; } return val ; }	fetches the charset to be used for any given locale from cache.
public shape paint layer ( graphics g , int offs0 , int offs1 , shape bounds , j c , view view ) { g . set color ( get color ( ) ) ; if ( offs0 == view . get start offset ( ) && offs1 == view . get end offset ( ) ) { rectangle alloc ; if ( bounds instanceof rectangle ) alloc = ( rectangle ) bounds ; else alloc = bounds . get bounds ( ) ; paint squiggle ( g , alloc ) ; return alloc ; } try { shape shape = view . model to view ( offs0 , position . bias . forward , offs1 , position . bias . backward , bounds ) ; rectangle r = ( shape instanceof rectangle ) ? ( rectangle ) shape : shape . get bounds ( ) ; paint squiggle ( g , r ) ; return r ; } catch ( bad location exception e ) { e . print stack trace ( ) ; } return null ; }	paints a portion of a highlight .
public void add control roll ( piloting roll data control ) { control rolls . add element ( control ) ; }	adds a pending control roll to the list for this phase .
void process add on changes ( window caller , add on dependency checker . add on changes result changes ) { if ( addons dialog != null ) { addons dialog . set downloading updates ( ) ; } if ( get view ( ) != null ) { set < add on > add ons = new hash set < > ( changes . get uninstalls ( ) ) ; add ons . add all ( changes . get old versions ( ) ) ; set < extension > extensions = new hash set < > ( ) ; extensions . add all ( changes . get unload extensions ( ) ) ; extensions . add all ( changes . get soft unload extensions ( ) ) ; if ( ! warn unsaved resources or active actions ( caller , add ons , extensions , bool ) ) { return ; } } uninstall add ons ( caller , changes . get uninstalls ( ) , bool ) ; set < add on > all addons = new hash set < > ( changes . get new versions ( ) ) ; all addons . add all ( changes . get installs ( ) ) ; for ( add on add on : all addons ) { if ( addons dialog != null ) { addons dialog . notify add on downloading ( add on ) ; } download add on ( add on ) ; } }	processes the given add - on changes .
public void rederive color ( ) { color src = ui . get color ( ui default parent name ) ; if ( src != null ) { float [ ] tmp = color . rg hsb ( src . get red ( ) , src . get green ( ) , src . get blue ( ) , null ) ; tmp [ num ] = clamp ( tmp [ num ] + h offset ) ; tmp [ num ] = clamp ( tmp [ num ] + s offset ) ; tmp [ num ] = clamp ( tmp [ num ] + b offset ) ; int alpha = clamp ( src . get alpha ( ) + a offset ) ; argb value = ( color . hs rgb ( tmp [ num ] , tmp [ num ] , tmp [ num ] ) & num ) | ( alpha << num ) ; } else { float [ ] tmp = new float [ num ] ; tmp [ num ] = clamp ( h offset ) ; tmp [ num ] = clamp ( s offset ) ; tmp [ num ] = clamp ( b offset ) ; int alpha = clamp ( a offset ) ; argb value = ( color . hs rgb ( tmp [ num ] , tmp [ num ] , tmp [ num ] ) & num ) | ( alpha << num ) ; } }	recalculate the derived color from the uimanager parent color and offsets.
public static string to string ( int [ ] oid ) { string builder sb = new string builder ( num * oid . length ) ; for ( int i = num ; i < oid . length - num ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( str ) ; } sb . append ( oid [ oid . length - num ] ) ; return sb . to string ( ) ; }	returns string representation of oid.
public void on idle begin ( ) { idle count . increment and get ( ) ; }	called by the thread before going into the idle state .
private void add span ( cache span span ) { tree set < cache span > spans for key = cached spans . get ( span . key ) ; if ( spans for key == null ) { spans for key = new tree set < cache span > ( ) ; cached spans . put ( span . key , spans for key ) ; } spans for key . add ( span ) ; total space += span . length ; notify span added ( span ) ; }	adds a cached span to the in - memory representation .
public boolean equals ( object obj ) { if ( this == obj ) { return bool ; } if ( ! ( obj instanceof uri ) ) { return bool ; } uri other = ( uri ) obj ; return uri . equals ( other . get uri ( ) ) ; }	compares this name with another , for equality .
void repaint children ( ) { for ( component child : panel . get components ( ) ) { child . repaint ( ) ; } }	request repainting of all the child panels .
private void validate dns name ( string dns name ) throws policy exception { int star index = dns name . index of ( str ) ; if ( ( star index >= num ) && ! dns name . equals ( str ) ) { if ( ( star index > num ) || ( ( star index == num ) && ( ( dns name . index of ( str , num ) != - num ) || ( dns name . char at ( num ) != str ) ) ) ) { string args [ ] = { dns name , dns name } ; throw new policy exception ( res bundle utils . rb name , str , args , null ) ; } } }	validates a dns name for format.
private static string read comment ( string input , int index ) { string comment = null ; matcher matcher = comment pattern . matcher ( input . substring ( index ) ) ; if ( matcher . find ( ) ) { comment = matcher . group ( num ) ; comment = comment . substring ( num ) ; } return comment ; }	reads the first comment line from the input , and returns the comment line ( including the line break character ) without the leading " # " .
public static int find next ( string str , char separator , char escape char , int start , string builder split ) { int num pre escapes = num ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char cur char = str . char at ( i ) ; if ( num pre escapes == num && cur char == separator ) { return i ; } else { split . append ( cur char ) ; num pre escapes = ( cur char == escape char ) ? ( ++ num pre escapes ) % num : num ; } } return - num ; }	finds the first occurrence of the separator character ignoring the escaped separators starting from the index.
private static string guess content type ( string url ) { url = url . to lower case ( ) ; if ( url . ends with ( str ) ) { return str ; } else if ( url . ends with ( str ) ) { return str ; } else if ( url . matches ( str ) ) { return str ; } else if ( url . ends with ( str ) ) { return str ; } else if ( url . ends with ( str ) ) { return str ; } else { return str ; } }	guess a content type from the url .
public static string extract csv ( string csv out ) { string tokens [ ] = csv out . split ( str , - num ) ; return tokens [ num ] ; }	used for testing - - input is a full csv line : < freq , domain , ip , ts , opt : generic >.
public void connect ( ) { connect ( this . log writer ) ; }	connects to the currently configured system .
public static boolean do cache header validation ( final solr query request solr req , final http servlet request req , final method req method , final http servlet response resp ) { if ( method . post == req method || method . other == req method ) { return bool ; } final long last mod = http cache header util . calc last modified ( solr req ) ; final string etag = http cache header util . calc etag ( solr req ) ; resp . set date header ( str , last mod ) ; resp . set header ( str , etag ) ; if ( check e ( req , resp , req method , etag ) ) { return bool ; } if ( check last mod validators ( req , resp , last mod ) ) { return bool ; } return bool ; }	sets http response cache validator headers appropriately and validates the http request against these using any conditional request headers.
public ivr zoneset show active ivr zoneset ( ) throws network device controller exception { list < ivr zoneset > zonesets = show ivr zonesets ( bool ) ; return zonesets . is empty ( ) ? null : zonesets . get ( num ) ; }	collect the active ivr zoneset , and its zones , members.
@ suppress warnings ( str ) public static < k > immutable array < k > empty ( ) { return ( immutable array < k > ) empty ; }	get an empty immutable array .
public void replace non optional non minus nodes with ( final list < i > ordered , final boolean recompute definitely produced ) { non optional non minus nodes . clear ( ) ; non optional non minus nodes . add all ( ordered ) ; if ( recompute definitely produced ) { recompute definitely produced ( ) ; } }	the new ordered list of non - optional non - minus nodes.
public static string to string ( accountable a ) { string builder sb = new string builder ( ) ; to string ( sb , a , num ) ; return sb . to string ( ) ; }	returns a string description of an accountable and any nested resources.
@ override public int hash code ( ) { return type << num | value . hash code ( ) << num | other value . hash code ( ) ; }	returns a hash code for this node .
protected void delete type vertex ( atlas vertex instance vertex , data types . type category type category , boolean force ) throws atlas exception { switch ( type category ) { case struct : case trait : delete type vertex ( instance vertex , force ) ; break ; case class : delete entities ( collections . singleton list ( instance vertex ) ) ; break ; default : throw new illegal state exception ( str + type category + str ) ; } }	deletes a type vertex - can be entity ( class type ) or just vertex ( struct / trait type ).
public static list < string > read to list ( reader r ) throws io { try ( buffered reader in = new buffered reader ( r ) ) { list < string > l = new array list < > ( ) ; string line = null ; while ( ( line = in . read line ( ) ) != null ) l . add ( line ) ; return collections . unmodifiable list ( l ) ; } }	read the reader line for line and return the result in a list.
@ suppress warnings ( str ) public void add cache context ( grid cache context cache ctx ) throws ignite checked exception { if ( ctx map . contains key ( cache ctx . cache id ( ) ) ) { grid cache context < k , v > existing = ctx map . get ( cache ctx . cache id ( ) ) ; throw new ignite checked exception ( str + str + cache ctx . name ( ) + str + existing . name ( ) + str ) ; } cache store manager mgr = cache ctx . store ( ) ; if ( mgr . configured ( ) && mgr . is local ( ) ) loc store cnt . increment and get ( ) ; ctx map . put ( cache ctx . cache id ( ) , cache ctx ) ; }	adds cache context to shared cache context .
protected static boolean is cglib get callbacks ( annotated method am ) { class < ? > rt = am . get raw type ( ) ; if ( rt == null || ! rt . is array ( ) ) { return bool ; } class < ? > comp type = rt . get component type ( ) ; package pkg = comp type . get package ( ) ; if ( pkg != null ) { string pname = pkg . get name ( ) ; if ( pname . starts with ( str ) || pname . starts with ( str ) ) { return bool ; } } return bool ; }	this method was added to address [ jackson - 53 ] : need to weed out cglib - injected " getcallbacks ".
public int compare to ( named media type other ) { return name . compare to ( other . name ) ; }	compares this namedmediatype to another .
public boolean is modified ( ) { synchronized ( this ) { if ( is checking || is modified ) { return is modified ; } is checking = bool ; } try { long now ; now = current time . current time ( ) ; if ( now < last check time + check interval ) return is modified ; last check time = now ; for ( int i = dependency list . size ( ) - num ; i >= num ; i -- ) { dependency dependency = dependency list . get ( i ) ; if ( dependency . is modified ( ) ) { dependency . log modified ( log ( ) ) ; is modified = bool ; return is modified ; } } return is modified ; } finally { is checking = bool ; } }	returns true if the underlying dependencies have changed .
protected replaced element new irreplaceable image element ( int css width , int css height ) { buffered image missing image ; replaced element mre ; try { missing image = image util . create compatible buffered image ( css width , css height , buffered image . type int rgb ) ; d g = missing image . create graphics ( ) ; g . set color ( color . black ) ; g . set background ( color . white ) ; g . set font ( new font ( str , font . plain , num ) ) ; g . draw string ( str , num , num ) ; g . dispose ( ) ; mre = new image replaced element ( missing image , css width , css height ) ; } catch ( exception e ) { mre = new empty replaced element ( css width < num ? num : css width , css height < num ? num : css height ) ; } return mre ; }	returns a replacedelement for some element in the stream which should be replaceable , but is not.
public boolean greater than ( fxg version ) { return ( compare to ( version ) > num ) ; }	compares whether this fxgversion ' s value is greater than the value of the version parameter .
@ override public data source create data source ( properties properties ) throws sql { properties properties copy = new properties ( ) ; if ( properties != null ) { properties copy . put all ( properties ) ; } reject unsupported options ( properties copy ) ; reject pooling options ( properties copy ) ; jdbc data source data source = new jdbc data source ( ) ; setup h2 data source ( data source , properties copy ) ; return data source ; }	creates a basic data source .
public set < string > find ( t object ) { if ( ! locations . contains key ( object ) ) { locations . put ( object , new hash set < > ( ) ) ; } return collections . unmodifiable set ( locations . get ( object ) ) ; }	find the names of a given object .
private void scroll current item to center ( ) { final view item curr item = m view items [ buffer center ] ; if ( curr item == null ) { return ; } final int current view center = curr item . get center x ( ) ; if ( m controller . is scrolling ( ) || m is user scrolling || is current item centered ( ) ) { log . d ( tag , str + m controller . is scrolling ( ) ) ; return ; } int snap in time = ( int ) ( snap in center time ms * ( ( float ) math . abs ( m center x - current view center ) ) / m draw area . width ( ) ) ; log . d ( tag , str ) ; m controller . scroll to position ( current view center , snap in time , bool ) ; }	keep the current item in the center.
public void add meta object ( meta object object ) { for ( int k = num ; k < meta objects . size ( ) ; ++ k ) { if ( meta objects . get ( k ) == null ) { meta objects . set ( k , object ) ; return ; } } meta objects . add ( object ) ; }	add a metaobject to the state .
public boolean remove ( string word ) { return m . remove ( word ) ; }	removes the word from the stopword list.
public void test case12 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	add two numbers of different length and sign.
public synchronized void add recent item ( t item ) { item = from string ( to string ( item ) ) ; if ( m . size ( ) > num ) { if ( item . equals ( m . get ( num ) ) ) return ; } m . remove ( item ) ; m . add ( num , item ) ; while ( m . size ( ) > m ) m . remove ( m . size ( ) - num ) ; if ( m ) return ; write props ( ) ; update menu ( ) ; notify recent item listeners of add ( item ) ; }	adds the item to the internal list .
public void test invoke all2 ( ) throws interrupted exception { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < future < string > > r = e . invoke all ( new array list < callable < string > > ( ) ) ; assert true ( r . is empty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeall ( empty collection ) returns empty collection.
public void cfg package ( configuration value cfgval , string name , string desc ) { packages . add ( new package info ( name , desc ) ) ; package names . add ( name ) ; }	assigns description to a package.
@ override public void close ( ) throws io { input . close ( ) ; }	closes this stream . this implementation closes the source stream .
private void create block mirror data ( string name , int num block mirrors ) throws exception { volume volume = new volume ( ) ; uri volume uri = uri . create id ( volume . class ) ; test volume ur . add ( volume uri ) ; volume . set id ( volume uri ) ; volume . set label ( str ) ; uri cg uri = create block consistency group ( str ) ; volume . set consistency group ( cg uri ) ; db client . create object ( volume ) ; for ( int i = num ; i <= num block mirrors ; i ++ ) { block mirror block mirror = new block mirror ( ) ; uri block mirror uri = uri . create id ( block mirror . class ) ; test block mirror ur . add ( block mirror uri ) ; block mirror . set id ( block mirror uri ) ; block mirror . set label ( name + i ) ; block mirror . set consistency group ( cg uri ) ; db client . create object ( block mirror ) ; } }	creates the blockobject blockmirror data .
@ override public synchronized void start ( ) { if ( running ) { return ; } logger . info ( str ) ; if ( endpoints . is empty ( ) ) { int port = config . get int ( network config . keys . coap port ) ; logger . log ( level . info , str , port ) ; add endpoint ( new coap endpoint ( port , this . config ) ) ; } int started = num ; for ( endpoint ep : endpoints ) { try { ep . start ( ) ; ++ started ; } catch ( io e ) { logger . log ( level . severe , str + ep . get address ( ) + str , e ) ; } } if ( started == num ) { throw new illegal state exception ( str ) ; } else { running = bool ; } }	starts the server by starting all endpoints this server is assigned to.
public boolean retain all ( abstract float list other ) { if ( other . size ( ) == num ) { if ( size == num ) return bool ; set size ( num ) ; return bool ; } int limit = other . size ( ) - num ; int j = num ; for ( int i = num ; i < size ; i ++ ) { if ( other . index of from to ( get quick ( i ) , num , limit ) >= num ) set quick ( j ++ , get quick ( i ) ) ; } boolean modified = ( j != size ) ; set size ( j ) ; return modified ; }	retains ( keeps ) only the elements in the receiver that are contained in the specified other list.
@ override public void exception caught ( io session session , throwable cause ) { final io session input stream in = ( io session input stream ) session . get attribute ( key in ) ; io e = null ; if ( cause instanceof stream io exception ) { e = ( io ) cause . get cause ( ) ; } else if ( cause instanceof io ) { e = ( io ) cause ; } if ( e != null && in != null ) { in . throw exception ( e ) ; } else { logger . warn ( str , cause ) ; session . close ( bool ) ; } }	forwards caught exceptions to input stream .
protected void clear result ( ) { md . clear result ( ) ; localization result . set text ( str ) ; }	clears the result that may has been set .
public static < t > string to string ( collection < t > collection ) { if ( collection == null ) { return str ; } if ( collection . is empty ( ) ) { return str ; } string builder buf = new string builder ( ) ; string delimiter = str ; for ( t t : collection ) { if ( t == null ) { continue ; } buf . append ( delimiter ) ; buf . append ( t ) ; delimiter = str ; } return buf . to string ( ) ; }	returns a list of the elements invoking tostring on non - null elements .
public static float between ( float val , float min , float max ) { return math . max ( math . min ( val , max ) , min ) ; }	check if value within allowed range .
public static string buffer replace string ( string buffer buffer , string [ ] parameters ) { int place holder position = - num ; string place holder = null ; for ( int i = num ; i < parameters . length ; i ++ ) { if ( parameters [ i ] == null ) { break ; } place holder = str + ( i + num ) + str ; place holder position = buffer . index of ( place holder ) ; if ( place holder position != - num ) { buffer . replace ( place holder position , place holder position + place holder . length ( ) , parameters [ i ] ) ; } else { break ; } } return buffer ; }	replaces the place holders by parameters.
private static int lookup qual selector ( xmp array node , string qual name , string qual value , int alias form ) throws xmp { if ( xml lang . equals ( qual name ) ) { qual value = utils . normalize lang value ( qual value ) ; int index = xmp . lookup language item ( array node , qual value ) ; if ( index < num && ( alias form & alias options . prop array alt text ) > num ) { xmp lang node = new xmp ( array item name , null ) ; xmp xdefault = new xmp ( xml lang , x default , null ) ; lang node . add qualifier ( xdefault ) ; array node . add child ( num , lang node ) ; return num ; } else { return index ; } } else { for ( int index = num ; index < array node . get children length ( ) ; index ++ ) { xmp curr item = array node . get child ( index ) ; for ( iterator it = curr item . iterate qualifier ( ) ; it . has next ( ) ; ) { xmp qualifier = ( xmp ) it . next ( ) ; if ( qual name . equals ( qualifier . get name ( ) ) && qual value . equals ( qualifier . get value ( ) ) ) { return index ; } } } return - num ; } }	searches for a qualifier selector in a node : [ ? qualname = " value " ] - an element in an array , chosen by a qualifier value.
public boolean is multiple allowed ( string frame id ) { return multiple frames . contains ( frame id ) ; }	are multiple occurrences of frame allowed.
public string [ ] parse configuration ( file xml file ) throws sax , io { document document = builder . parse ( xml file ) ; return ( parse configuration ( document ) ) ; }	parse an xml configuration from a file.
public void create ( string [ ] rpf file paths , string output file ) throws make toc exception { create ( rpf file paths , output file , bool ) ; }	create a a . toc file specificed by the frame file list , at the location specified .
private synchronized void post event ( event info event info ) { event queue . add ( event info ) ; notify all ( ) ; }	queue the given event in the event queue .
public string choose server alias ( string key type , principal [ ] issuers , socket sock ) { return sun x509 key manager . choose server alias ( key type , issuers , sock ) ; }	choose an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
private void process bmp image ( buffered image image ) { if ( ! is error ) { file output file = new file ( path , prefix + ( num page + num ) + str ) ; try { io . write ( image , str , output file ) ; add temp file ( output file ) ; add scan file ( output file ) ; num page ++ ; } catch ( io e ) { e . print stack trace ( ) ; end process ( bool , bool ) ; } } }	procesa el escaneo de una imagen en modo nativo.
public path handler ( string path ) { this ( paths . get ( path ) ) ; }	convenience method to create a path.
public boolean load lines ( ) { boolean result = bool ; try { m parser . parse ( new input source ( m reader ) , this ) ; result = bool ; m success = bool ; } catch ( sax e ) { m error message = str ; m error description = e . get message ( ) ; } catch ( io e ) { m error message = str ; m error description = e . get message ( ) ; } return result ; }	read statementlines from inputstream .
private void load ignore file ( final string src folder ) { ignore file = ignore file . load ( src folder ) ; if ( ignore file == null ) { load default exclude pattern ( src folder ) ; } }	load ignore file using.
public boolean remove arg ( final b arg ) { if ( arg == null ) throw new illegal argument exception ( ) ; if ( arg == this ) throw new illegal argument exception ( ) ; if ( args . remove ( arg ) ) { mutation ( ) ; return bool ; } return bool ; }	remove the 1st occurrence of the argument ( core mutation method ) .
public static boolean looks like a ( string val ) { return list types . index of ( val ) >= num ; }	description of the method.
public pkc ( pkc attr ) { this . attribute id = attr . get oid ( ) ; this . attribute value = attr . get value ( ) ; }	constructs an attribute from pkcs9 attribute .
public void create note ( note note ) { sq db = get writable database ( ) ; string spannable as html = html . to html ( note . get spannable ( ) ) ; string date = dt . format ( new date ( ) ) ; content values values = new content values ( ) ; values . put ( key spannable note , spannable as html ) ; values . put ( key note title , note . get title ( ) ) ; values . put ( key image , bitmap converter . get bytes ( note . get image ( ) ) ) ; values . put ( key date updated , date ) ; db . insert ( table notes , null , values ) ; db . close ( ) ; }	method used to put note object into database.
void verify unique xids ( list < of > msgs ) { if ( seen xids == null ) seen xids = new hash set < long > ( ) ; for ( of m : msgs ) { long xid = m . get xid ( ) ; assert true ( str , xid != num ) ; assert false ( str + xid + str , seen xids . contains ( xid ) ) ; seen xids . add ( xid ) ; } }	make sure that the transaction ids in the given messages are not 0 and differ between each other.
void add next ( node < t > n ) { next nodes . add ( n ) ; collections . sort ( next nodes , is vertical ? vertical comparator : horizontal comparator ) ; }	adds a " next " node ( node to the right or bottom ) to this divider ' s list of next nodes .
protected void config dialog property change ( property change event event ) { log . debug ( str ) ; fire property change ( id . config change , event . get old value ( ) , event . get new value ( ) ) ; }	callback for the config dialog.
public final string read utf ( ) throws io { return decode utf ( read unsigned short ( ) ) ; }	see the general contract of the readutf method of datainput.
private void my add ( linked list < integer > l , int i ) { l . add ( i ) ; }	for debugging purposes , it ' s useful to insert print statements here .
private void reset state for grid top ( ) { final int col count = m col count ; if ( m item tops == null || m item tops . length != col count ) { m item tops = new int [ col count ] ; m item bottoms = new int [ col count ] ; } final int top = get padding top ( ) ; arrays . fill ( m item tops , top ) ; arrays . fill ( m item bottoms , top ) ; m first position = num ; if ( m restore offsets != null ) arrays . fill ( m restore offsets , num ) ; }	reset all internal state to be at the top of the grid .
public string test next token ( ) throws io { token t = super . next token ( ) ; return integer . to string ( t . type ) + str + t . content + str ; }	calls super . nexttoken ( ) and prints out a string representation of token type and content .
public static repaint manager current manager ( component c ) { return current manager ( app context . get app context ( ) ) ; }	return the repaintmanager for the calling thread given a component .
private boolean is recover point initiator ( string port wwn ) { return port wwn . contains ( recoverpoint initiator prefix ) ; }	determines if the given port wwn is a recoverpoint initiator .
protected boolean is wfxml ( string chardata , character ref invalid char ) { if ( chardata == null || ( chardata . length ( ) == num ) ) { return bool ; } char [ ] dataarray = chardata . to char array ( ) ; int datalength = dataarray . length ; if ( f is xml ) { int i = num ; while ( i < datalength ) { if ( xm . is xm ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - num ] ; if ( xml . is high surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xml . is low surrogate ( ch2 ) && xml . is supplemental ( xml . supplemental ( ch , ch2 ) ) ) { continue ; } } ref invalid char = new character ( ch ) ; return bool ; } } } else { int i = num ; while ( i < datalength ) { if ( xml . is invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - num ] ; if ( xml . is high surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xml . is low surrogate ( ch2 ) && xml . is supplemental ( xml . supplemental ( ch , ch2 ) ) ) { continue ; } } ref invalid char = new character ( ch ) ; return bool ; } } } return bool ; }	checks if a xml character is well - formed.
@ override public void send ( buffer buffer ) { out proxy . write ( out writer , buffer , bool ) ; }	initialization when the websocket completes .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case eip package . route owned endpoints : return owned endpoints != null && ! owned endpoints . is empty ( ) ; case eip package . route owned channels : return owned channels != null && ! owned channels . is empty ( ) ; case eip package . route name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case eip package . route exchange type : return exchange type != exchange type edefault ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void remove clicking listener ( on wheel clicked listener listener ) { clicking listeners . remove ( listener ) ; }	removes wheel clicking listener.
public void add section ( final section section ) { if ( null == section ) return ; sections . add ( section ) ; collections . sort ( sections , new section comparator ( ) ) ; fire update event ( section event ) ; }	adds the given section to the list of sections.
private int calculate preferred wrap position ( @ not null editor editor , @ not null char sequence text , int tab size , int space size , int start line offset , int end line offset , int target range end offset ) { boolean has tabs = bool ; boolean can optimize = bool ; boolean has non space symbols = bool ; loop : for ( int i = start line offset ; i < math . min ( end line offset , target range end offset ) ; i ++ ) { char c = text . char at ( i ) ; switch ( c ) { case str : { has tabs = bool ; if ( has non space symbols ) { can optimize = bool ; break loop ; } } case str : break ; default : has non space symbols = bool ; } } if ( ! has tabs ) { return wrap position for text without tabs ( start line offset , end line offset , target range end offset ) ; } else if ( can optimize ) { return wrap position for tabbed text with optimization ( text , tab size , start line offset , end line offset , target range end offset ) ; } else { return wrap position for tabbed text without optimization ( editor , text , space size , start line offset , end line offset , target range end offset ) ; } }	checks if it ' s worth to try to wrap target line ( it ' s long enough ) and tries to calculate preferred wrap position .
public void add all ( o v ) { expand for ( size + v . size - num , null ) ; system . arraycopy ( v . vector , num , vector , size - v . size , v . size ) ; }	adds all the values in the given vector to the end of this vector , expanding its capacity as necessary .
public static void pipe all ( input stream in str , output stream out str ) throws io { byte [ ] bs = new byte [ buffer size ] ; int num read ; while ( ( num read = in str . read ( bs , num , bs . length ) ) >= num ) { out str . write ( bs , num , num read ) ; } }	write the full contents of instr to the destination stream outstr .
public void add rule ( string rule expression , t result if matched ) { m rule map . add ( new mime matcher rule ( rule expression , result if matched ) ) ; }	add a matching rule in the canonical mime t form such as " image / * " or a mime t literal such as " text / html " .
protected abstract boolean validate number ( conversation context context , number input ) ;	validates a number , for use cases where you may need the number to be within a range.
public void send message until stop count ( int stop count ) { for ( int i = processed worker count ; i < workers . size ( ) ; ++ i ) { actor ref worker = workers . get ( i ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { logger . error ( str + e + str , e ) ; } worker . tell ( operation worker msg type . process request , original manager ) ; processed worker count ++ ; if ( processed worker count > stop count ) { return ; } logger . debug ( str , processed worker count , request total count , task id trim ) ; } }	note that if there is sleep in this method .
public static array list < string > string to array list ( string string ) { return new array list < > ( arrays . as list ( string . split ( str ) ) ) ; }	make arraylist from " , " separated string.
private string pick charset ( ) { if ( charset != null ) { return charset ; } else if ( utf8 supported ) { return str ; } else { return system . get property ( str ) ; } }	returns the name of the charset that should be used in textual transmissions .
public void test to engineering string pos ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; string result = str ; assert equals ( str , result , a number . to engineering string ( ) ) ; }	convert a positive bigdecimal to an engineering string representation.
@ override public void clear ( ) { if ( element count > num ) { element count = num ; arrays . fill ( element data , null ) ; mod count ++ ; } }	removes all mappings from this hash map , leaving it empty .
public void add layer ( final layer definition layer ) { layer . set map ( this ) ; layers . add ( layer ) ; }	adds a new layer to the map .
private list < rule > read rules ( reader reader ) throws io , illegal argument exception { buffered reader in = new buffered reader ( reader ) ; list < rule > rules = new array list < rule > ( ) ; string line ; while ( ( line = in . read line ( ) ) != null ) { if ( line . length ( ) == num ) { continue ; } line = line . trim ( ) ; char first = line . char at ( num ) ; boolean sign = bool ; switch ( first ) { case str : sign = bool ; break ; case str : sign = bool ; break ; case str : case str : case str : continue ; default : throw new io ( str + line ) ; } string regex = line . substring ( num ) ; if ( log . is trace enabled ( ) ) { log . trace ( str + regex + str ) ; } rule rule = create rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }	read the specified file of rules .
@ suppress warnings ( str ) @ override protected object apply updates to managed data ( object updates ) { boolean made changes = bool ; list < string > words = ( list < string > ) updates ; log . info ( str + words ) ; boolean ignore case = get ignore case ( ) ; for ( string word : words ) { if ( ignore case ) word = word . to lower case ( locale . root ) ; if ( managed words . add ( word ) ) { made changes = bool ; log . info ( str , word ) ; } } return made changes ? managed words : null ; }	applies updates to the word set being managed by this resource .
@ override public void write ( char c [ ] , int off , int len ) { if ( ( off < num ) || ( off > c . length ) || ( len < num ) || ( ( off + len ) > c . length ) || ( ( off + len ) < num ) ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = arrays . copy of ( buf , math . max ( buf . length << num , newcount ) ) ; } system . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }	writes characters to the buffer .
@ deprecated public static episode matching result detect episode from filename ( file file ) { logger . debug ( str + file . get name ( ) ) ; episode matching result result = new episode matching result ( ) ; string file name = file . get name ( ) ; result = parse string ( file name ) ; collections . sort ( result . episodes ) ; matcher matcher = stacking marker pattern . matcher ( result . name ) ; result . stacking marker found = matcher . matches ( ) ; logger . debug ( str + result ) ; return result ; }	detect episode from filename .
public static typed operation create array creation ( array type array type ) { list < type > type list = new array list < > ( ) ; type list . add ( java types . int type ) ; type tuple input types = new type tuple ( type list ) ; return new typed term operation ( new array creation ( array type ) , input types , array type ) ; }	creates a simple array creation operation for the given type .
public void fire event ( final sparql e ) { if ( is read only ( ) ) throw new unsupported operation exception ( ) ; if ( e == null ) throw new illegal argument exception ( ) ; if ( listeners . is empty ( ) ) { return ; } final isparql [ ] a = listeners . to array ( new isparql [ num ] ) ; for ( isparql l : a ) { final isparql listener = l ; try { listener . update event ( e ) ; } catch ( throwable t ) { if ( inner cause . is inner cause ( t , interrupted exception . class ) ) { throw new runtime exception ( t ) ; } log . error ( t , t ) ; } } }	send an event to all registered listeners .
public preference builder < preference class > pref type ( class < preference class > pref type ) { if ( ! valid types . contains ( pref type ) ) { throw new illegal argument exception ( str + pref type + str ) ; } this . pref type = pref type ; return this ; }	the type of preference to retrieve.
private void expunge stale entries ( ) { for ( object x ; ( x = queue . poll ( ) ) != null ; ) { synchronized ( queue ) { @ suppress warnings ( str ) entry < k , v > e = ( entry < k , v > ) x ; int i = index for ( e . hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > p = prev ; while ( p != null ) { entry < k , v > next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . value = null ; size -- ; break ; } prev = p ; p = next ; } } } }	expunges stale entries from the table .
protected boolean is numeric ( string text ) { text = text . trim ( ) ; int tlen = text . length ( ) ; for ( int i = num ; i < tlen ; i ++ ) { if ( character . is digit ( text . char at ( i ) ) == bool ) { return bool ; } } return bool ; }	utility method for subclasses to determine if an entire string is digits.
public static boolean is char ( string desc ) { return desc . ends with ( str ) ; }	tells whether a given type is a char.
public rsa ( byte [ ] encoded ) throws invalid key exception { decode ( encoded ) ; rsa . check rsa ( n . bit length ( ) , e ) ; }	construct a key from its encoding.
date to date ( calendar calendar ) { return calendar . get time ( ) ; }	convert a calendar to a java.
public boolean is client authentication ( ) { return client authentication ; }	returns a boolean flag to determine if this message will be sent to a server that requires client authentication .
private j create image file panel ( ) { j panel = new j ( ) ; panel . set layout ( new box layout ( panel , box layout . x axis ) ) ; panel . add ( image file name ) ; panel . add ( box . create horizontal strut ( num ) ) ; panel . add ( new j ( open image file ) ) ; return panel ; }	create and return the image file panel .
void write line ( buffered writer writer , string line ) throws io { writer . write ( line ) ; writer . new line ( ) ; }	writes the given line with the given writer , followed by a new line .
public layer child at ( int index ) { return children . get ( index ) ; }	returns the layer at the specified index.
private static void check permission ( ) { security manager security = system . get security manager ( ) ; if ( security != null ) security . check permission ( modify thread permission ) ; }	if there is a security manager , makes sure caller has permission to modify threads .
public static function < value , value > of value ( ) { return value ; }	the identity function for value conversion - returns the value untouched .
public static string remove quotes ( string s ) { if ( s == null ) { return null ; } string trimmed = s . trim ( ) ; if ( trimmed . length ( ) == num ) { return trimmed ; } int i = next non quote index ( trimmed , num , bool ) ; int j = next non quote index ( trimmed , trimmed . length ( ) - num , bool ) ; return trimmed . substring ( i , j + num ) ; }	trims white spaces and remove quotes from the string .
public static boolean is defined ns ( serialization handler serializer , int attr , dtm dtm ) { if ( dtm . namespace node == dtm . get node type ( attr ) ) { string prefix = dtm . get node name x ( attr ) ; string uri = serializer . get namespace uri ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . get string value ( attr ) ) ) return bool ; } return bool ; }	returns whether a namespace is defined.
public void test user data handler notified of shallow clones ( ) { recording handler handler = new recording handler ( ) ; name . set user data ( str , str , handler ) ; name . set user data ( str , str , handler ) ; standard . set user data ( str , str , handler ) ; waffles . set user data ( str , str , handler ) ; element cloned name = ( element ) name . clone node ( bool ) ; attr cloned standard = cloned name . get attribute node ( str ) ; set < string > expected = new hash set < string > ( ) ; expected . add ( notification ( node cloned , str , str , name , cloned name ) ) ; expected . add ( notification ( node cloned , str , str , name , cloned name ) ) ; expected . add ( notification ( node cloned , str , str , standard , cloned standard ) ) ; assert equals ( expected , handler . calls ) ; }	a shallow clone requires cloning the attributes but not the child nodes .
public d ( j parent , byte [ ] value ) throws io { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; prepopulate with value ( value ) ; }	creates a new dbasicconstraints dialog .
private static int last index of ( object o , object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= num ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= num ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - num ; }	static version of lastindexof .
public float column ( int nrows , int capacity , float default value ) { super ( float . class , new float ( default value ) ) ; if ( capacity < nrows ) { throw new illegal argument exception ( str ) ; } m values = new float [ capacity ] ; arrays . fill ( m values , default value ) ; m size = nrows ; }	create a new floatcolumn .
void read prj ( ) throws io { while ( bool ) { string s = isr . read line ( ) ; if ( s == null ) return ; if ( s . starts with ( str ) ) return ; } }	read prj records ( in fact does nothing ).
private void purge one ( ) { synchronized ( queue ) { weak key key = ( weak key ) queue . poll ( ) ; if ( key != null ) { super . remove ( key . get referenced ( ) ) ; } } }	purges one entry whose wrapped key has been garbage collected .
private void check alter period converters ( ) throws security exception { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check permission ( new joda time permission ( str ) ) ; } }	checks whether the user has permission ' convertermanager.
public boolean equals ( final artifact coordinates obj ) { return this == obj || obj != null && group id . equals ( obj . group id ) && artifact id . equals ( obj . artifact id ) && version . equals ( obj . version ) && classifier . equals ( obj . classifier ) ; }	determine whether this coordinates object equals the target object .
private void check matrix dimensions ( matrix b ) { if ( b . m != m || b . n != n ) { throw new illegal argument exception ( str ) ; } }	check if size ( a ) = = size ( b ).
public void import from change ( change source change ) { if ( source change . revision ( ) > num ) { this . revision id = new numeric literal impl ( source change . revision ( ) ) ; } if ( source change . timestamp ( ) != null ) { date date = source change . timestamp ( ) ; calendar c = calendar . get instance ( time zone . get time zone ( str ) , locale . root ) ; c . set time ( date ) ; this . last modified = new literal impl ( datatype converter . print date ( c ) , xml . datetime ) ; } }	import revision data from change object .
protected print writer line file out ( document doc ) { return line file out ; }	selects output line file by written doc.
@ override public query new fuzzy query ( string text , int fuzziness ) { if ( settings . lowercase expanded terms ( ) ) { text = text . to lower case ( settings . locale ( ) ) ; } boolean query . builder bq = new boolean query . builder ( ) ; bq . set disable coord ( bool ) ; for ( map . entry < string , float > entry : weights . entry set ( ) ) { try { query q = new fuzzy query ( new term ( entry . get key ( ) , text ) , fuzziness ) ; q . set boost ( entry . get value ( ) ) ; bq . add ( q , boolean clause . occur . should ) ; } catch ( runtime exception e ) { rethrow unless lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }	dispatches to lucene ' s simplequeryparser ' s newfuzzyquery , optionally lowercasing the term first.
public call chain info ( soot method m , stmt s , string type ) { this . type = type ; this . link = str ; this . method = m ; this . stmt = s ; calls = num ; if ( type . equals ( str ) ) syscalls = num ; }	creates a call from stmt s to sootmethod m.
public void start playback ( ) { log . d ( tag , str ) ; if ( null == m record file ) { log . e ( tag , str ) ; return ; } m player = new media player ( ) ; try { m player . set data source ( m record file . get absolute path ( ) ) ; log . d ( tag , str + m record file . get absolute path ( ) + str ) ; m player . set on completion listener ( this ) ; m player . set on error listener ( this ) ; m player . prepare ( ) ; log . d ( tag , str ) ; m player . start ( ) ; } catch ( io e ) { log . e ( tag , str + e ) ; set error ( error player internal ) ; return ; } catch ( illegal argument exception e ) { log . e ( tag , str + e ) ; set error ( error player internal ) ; return ; } catch ( security exception e ) { log . e ( tag , str + e ) ; set error ( error player internal ) ; return ; } catch ( illegal state exception e ) { log . e ( tag , str + e ) ; set error ( error player internal ) ; return ; } set state ( state playback ) ; log . d ( tag , str ) ; }	play current recorded file , if failed notify error message to caller , if success update fm recorder state.
public static void not empty ( string string , string msg ) { if ( string == null || string . length ( ) == num ) throw new illegal argument exception ( msg ) ; }	validates that the string is not empty.
public static void reset context ( ) { contexts . set ( null ) ; }	resets the current context.
public static object convert to parameter values ( object object ) { collection < object > collection ; if ( object instanceof object [ ] ) { collection = arrays . as list ( ( object [ ] ) object ) ; } else if ( object instanceof collection ) { collection = ( collection < object > ) object ; } else { logger . warn ( str ) ; return new object [ ] { } ; } list < object > s = new linked list < object > ( ) ; for ( object o : collection ) { object converted = convert to parameter value ( o ) ; if ( converted instanceof object [ ] ) { s . add all ( arrays . as list ( ( object [ ] ) converted ) ) ; } else { s . add ( converted ) ; } } return s . to array ( new object [ s . size ( ) ] ) ; }	converts an array / collection of values ( the object ) to a parameter values array.
public boolean logout user ( string username , http servlet request req ) { return logout user ( username , req , bool , bool ) ; }	basic internal api call to authsvc to logout a user .
public static operation create operation to update or create network interface ( compute state existing compute state , network interface state network interface , list < string > tenant links , stateless service service , boolean is public ) { string existing interface link = get existing network interface link ( existing compute state , is public ) ; operation network interface operation = null ; if ( existing interface link == null ) { network interface operation = create post operation ( service , network interface , network interface service . factory link ) ; } else { network interface operation = create patch operation ( service , network interface , existing interface link ) ; } return network interface operation ; }	compares the ip addresses of the instance on aws and maps those to the network interfaces in the system.
public code source facade ( final code source code source ) { this . location = code source . get location ( ) ; final certificate [ ] certificates = code source . get certificates ( ) ; if ( null == certificates || num == certificates . length ) { logger . warning ( string . format ( str , code source ) ) ; this . first certificate = null ; return ; } this . first certificate = ( x509 certificate ) certificates [ num ] ; }	creates a new code source .
public jdp broadcaster ( inet address address , inet address src address , int port , int ttl ) throws io , jdp exception { this . addr = address ; this . port = port ; protocol family family = ( address instanceof inet6 address ) ? standard protocol family . ine : standard protocol family . inet ; channel = datagram channel . open ( family ) ; channel . set option ( standard socket options . so reuseaddr , bool ) ; channel . set option ( standard socket options . ip multicast ttl , ttl ) ; if ( src address != null ) { network interface interf = network interface . get by inet address ( src address ) ; try { channel . bind ( new inet socket address ( src address , num ) ) ; } catch ( unsupported address type exception ex ) { throw new jdp exception ( str ) ; } channel . set option ( standard socket options . ip multicast if , interf ) ; } }	create a new broadcaster.
public void close ( ) throws io { rrd file . close ( ) ; }	closes this database stream and releases any associated system resources .
public vector rotate in degree ( double degree ) { return rotate in radian ( math . to radians ( degree ) ) ; }	return a new instance of vector rotated from the given number of degrees .
public static string to string ( final uri uri , final charset encoding ) throws io { return io . to string ( uri . to url ( ) , charsets . to charset ( encoding ) ) ; }	gets the contents at the given uri .
public void put ( int field number , field data data ) { int i = binary search ( field number ) ; if ( i >= num ) { m data [ i ] = data ; } else { i = ~ i ; if ( i < m size && m data [ i ] == deleted ) { m field numbers [ i ] = field number ; m data [ i ] = data ; return ; } if ( m garbage && m size >= m field numbers . length ) { gc ( ) ; i = ~ binary search ( field number ) ; } if ( m size >= m field numbers . length ) { int n = ideal int array size ( m size + num ) ; int [ ] nkeys = new int [ n ] ; field data [ ] nvalues = new field data [ n ] ; system . arraycopy ( m field numbers , num , nkeys , num , m field numbers . length ) ; system . arraycopy ( m data , num , nvalues , num , m data . length ) ; m field numbers = nkeys ; m data = nvalues ; } if ( m size - i != num ) { system . arraycopy ( m field numbers , i , m field numbers , i + num , m size - i ) ; system . arraycopy ( m data , i , m data , i + num , m size - i ) ; } m field numbers [ i ] = field number ; m data [ i ] = data ; m size ++ ; } }	adds a mapping from the specified fieldnumber to the specified data , replacing the previous mapping if there was one .
void hide border ( ) { insets insets = get insets ( ) ; set border ( border factory . create empty border ( insets . top , insets . left , insets . bottom , insets . right ) ) ; }	hide the special border of the title bar .
public void remove ( string btxn ) { synchronized ( filter map ) { filter processor oldfp = filter map . get ( btxn ) ; if ( oldfp != null ) { global exclusion filters . remove ( oldfp ) ; btxn filters . remove ( oldfp ) ; } } }	this method removes the business transaction .
public void add ( double weight , double x , double y ) { observations . add ( new weighted observed point ( weight , x , y ) ) ; }	adds a point to the sample .
public boolean add tag id ( final long tag id ) { if ( tag id != null && tag id > num ) { return tag ids . add ( tag id ) ; } return bool ; }	adds the given tag id to this request .
public void support tls intolerant server ( ssl socket ) { socket . set enabled protocols ( new string [ ] { str } ) ; }	attempt a secure connection with basic functionality to maximize compatibility.
public static list < execution entity > order from root to leaf ( collection < execution entity > executions ) { list < execution entity > ordered list = new array list < execution entity > ( executions . size ( ) ) ; hash set < string > previous ids = new hash set < string > ( ) ; for ( execution entity execution : executions ) { if ( execution . get parent id ( ) == null ) { ordered list . add ( execution ) ; previous ids . add ( execution . get id ( ) ) ; } } while ( ordered list . size ( ) < executions . size ( ) ) { for ( execution entity execution : executions ) { if ( ! previous ids . contains ( execution . get id ( ) ) && previous ids . contains ( execution . get parent id ( ) ) ) { ordered list . add ( execution ) ; previous ids . add ( execution . get id ( ) ) ; } } } return ordered list ; }	takes in a collection of executions belonging to the same process instance.
public void init tk ( ) { int i num nodes = i parent . length ; double i beta [ ] = new double [ i num nodes ] ; i b = new double [ i num nodes ] ; i e = new double [ i num nodes ] ; i h = new double [ i num nodes ] ; i n = new double [ i num nodes ] ; i initial = num ; for ( int i = num ; i < i num nodes ; i ++ ) { if ( i == i num nodes - num ) { i beta [ i ] = num / i mu ; i h [ i ] = num ; } else { i beta [ i ] = math . exp ( ( i lambda - i mu ) * i tau [ i ] ) ; i beta [ i ] = ( num - i beta [ i ] ) / ( i mu - i lambda * i beta [ i ] ) ; i h [ i ] = math . exp ( - i mu * i tau [ i ] ) * ( num - i lambda * i beta [ i ] ) ; } i b [ i ] = i lambda * i beta [ i ] ; i e [ i ] = i mu * i beta [ i ] ; i n [ i ] = ( num - i mu * i beta [ i ] ) * ( num - i b [ i ] ) - i h [ i ] ; i initial *= ( num - i b [ i ] ) ; } }	populates the ib , ie , ih and in arrays , and iinitial value.
public static string serialize expression ( node s ) { if ( s instanceof ast ) { ast a = ( ast ) s ; return ( a . is not flag ( ) ? str : str ) + str + a . get term ( ) ; } string prefix = str ; string suffix = str ; string join = str ; if ( s instanceof ast ) { ast a = ( ast ) s ; prefix = ( a . is not flag ( ) ? str : str ) + str ; suffix = str ; join = str + a . get type ( ) + str ; } list < string > children = new array list < string > ( ) ; for ( int i = num ; i < s . jjt get num children ( ) ; i ++ ) { children . add ( serialize expression ( s . jjt get child ( i ) ) ) ; } return prefix + string utils . join ( children , join ) + suffix ; }	serialize a node ( and it ' s children ) to a parsable string .
private void define internal frame menu buttons ( ui d ) { string p = str ; string c = painter prefix + str ; d . put ( p + str , new title pane menu button window not focused state ( ) ) ; d . put ( p + str , new ui ( num , num , num , num ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon enabled ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon disabled ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon mouseover ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon pressed ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon enabled windownotfocused ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon mouseover windownotfocused ) ) ; d . put ( p + str , new lazy painter ( c , title pane menu button painter . which . icon pressed windownotfocused ) ) ; d . put ( p + str , new sea glass icon ( p , str , num , num ) ) ; }	initialize the internal frame menu button settings .
public static workflow . method restore from clone method ( uri storage , list < uri > clone , boolean update op status , boolean is cg ) { return new workflow . method ( str , storage , clone , update op status , is cg ) ; }	return a workflow . method for restorevolume.
@ override public synchronized void remove data source listener ( data source listener dsl ) { m data source listeners . remove ( dsl ) ; }	remove a datasource listener.
public string right str ( string str , int length ) { return str . substring ( math . max ( num , str . length ( ) - length ) ) ; }	returns a substring of the given string , representing the ' length ' most - right characters.
public void clear name in unoccupied blocks ( ) { for ( int i = num ; i < m block entries . size ( ) ; i ++ ) { block b = m block entries . get ( i ) ; if ( b . get state ( ) == block . unoccupied ) { b . set value ( str ) ; } } }	this function clears the block values for blocks in this section .
public static object unserialize ( data data ) { try { class clazz = ( class ) class . for name ( ( string ) data . get ( str ) ) ; if ( clazz . is enum ( ) ) { return enum . value of ( clazz , data . get ( str ) ) ; } else if ( clazz == d . class ) { return new d ( data . get ( str ) , data . get ( str ) , data . get ( str ) ) ; } else if ( clazz == d . class ) { return new d ( data . get ( str ) , ( double ) data . get ( str ) ) ; } else { return unserialize ( clazz , data ) ; } } catch ( exception e ) { throw new data exception ( e ) ; } }	loads an object from its stored data , with an unknown class.
public static void on grid stop ( ) throws interrupted exception { synchronized ( mux ) { if ( grid cnt == num ) return ; -- grid cnt ; thread timer0 = timer ; if ( grid cnt == num && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }	stops clock timer if all nodes into jvm were stopped .
public void push template folder ( @ not null string folder name ) throws io { my last template folders . push ( resolve name ( folder name ) ) ; }	resolve the foldername and push the resulting folder as the last template folder .
public void print depth first ( ) { print ( new depth first enumerator ( first node ) ) ; }	print , to system.
public void add event ( sim event new event ) { double event time = new event . event time ( ) ; if ( event time >= max time ) { list . add ( new event ) ; max time = event time ; return ; } list iterator < sim event > iterator = list . list iterator ( ) ; sim event event ; while ( iterator . has next ( ) ) { event = iterator . next ( ) ; if ( event . event time ( ) > event time ) { iterator . previous ( ) ; iterator . add ( new event ) ; return ; } } list . add ( new event ) ; }	adds a new event to the queue.
public db schema ejb generator ( generated tables gen tables , schema element schema element ) { this ( gen tables , schema element , collection type . collection , bool , bool , bool ) ; }	creates a generator for a set of beans .
@ override public void initialize ( ) { board = null ; switch ( sim pane ctrl . get param value index ( param init conf ) ) { case num : board = new eight puzzle board ( new int [ ] { num , num , num , num , num , num , num , num , num } ) ; break ; case num : board = new eight puzzle board ( new int [ ] { num , num , num , num , num , num , num , num , num } ) ; break ; case num : board = new eight puzzle board ( new int [ ] { num , num , num , num , num , num , num , num , num } ) ; break ; case num : board = new eight puzzle board ( new int [ ] { num , num , num , num , num , num , num , num , num } ) ; random r = new random ( system . current time millis ( ) ) ; for ( int i = num ; i < num ; i ++ ) { switch ( r . next int ( num ) ) { case num : board . move gap up ( ) ; break ; case num : board . move gap down ( ) ; break ; case num : board . move gap left ( ) ; break ; case num : board . move gap right ( ) ; break ; } } } state view ctrl . initialize ( board ) ; }	displays the initialized board on the state view .
protected abstract void on open ( h tbl , scan scan ) throws io ;	hbase table connection callback function.
private static void add abbreviation ( string primitive , string abbreviation ) { abbreviation map . put ( primitive , abbreviation ) ; reverse abbreviation map . put ( abbreviation , primitive ) ; }	add primitive type abbreviation to maps of abbreviations .
private void init tree map ( ) { if ( entity type == null ) { entity type = str ; } if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get circle ( ) ; } if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get mouse ( ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } else if ( entity type . equals ignore case ( str ) ) { image map = rotating entity manager . get rotating tileset ( str , num ) ; } update ( ) ; }	initialize the tree map , which associates angles with images / animations .
public static file locate replicator home dir ( ) { if ( replicator home dir == null ) { string replicator home = system . get property ( home dir ) ; if ( replicator home == null ) replicator home = system . get property ( str ) ; replicator home dir = new file ( replicator home ) ; if ( ! replicator home dir . is directory ( ) ) { throw new server runtime exception ( str + replicator home dir ) ; } } return replicator home dir ; }	find and return the replicator home directory .
public string data ( string data ) { m data = data ; }	creates a transferable capable of transferring the specified string .
void write repeated sqr ( dd xdd ) { if ( xdd . ge ( dd . value of ( num ) ) ) throw new illegal argument exception ( str ) ; int count = num ; while ( xdd . double value ( ) > num ) { count ++ ; if ( count == num ) count = count ; double x = xdd . double value ( ) ; dd x sqr = xdd . sqr ( ) ; string s = x sqr . to string ( ) ; dd x sqr2 = dd . parse ( s ) ; xdd = x sqr ; } }	this routine simply tests for robustness of the tostring function .
public java . lang . string buffer append ( float f ) { internal . append ( f ) ; return this ; }	appends the string representation of the float argument to this string buffer.
public static final void open ( file file ) throws no such method exception { if ( platform . is mac osx ( ) ) { exec args ( str , file . get absolute path ( ) ) ; } else if ( platform . is windows ( ) ) { if ( file . is directory ( ) ) { exec args ( str , file . get absolute path ( ) ) ; } else { exec args ( str , file . get absolute path ( ) ) ; } } else if ( platform . is unix ( ) && has unix command ( str ) ) { exec args ( str , file . to string ( ) ) ; } else if ( platform . is unix ( ) && has unix command ( str ) ) { exec args ( str , file . to string ( ) ) ; } else if ( platform . is solaris ( ) && file . is directory ( ) ) { exec args ( str , str , file . get absolute path ( ) ) ; } else { throw new no such method exception ( str ) ; } }	opens a file with the default system action .
@ override public string test destination ( location destination , track track ) { string status = super . test destination ( destination , track ) ; if ( ! status . equals ( track . okay ) ) { return status ; } if ( track == null ) { return status ; } return track . check schedule ( this ) ; }	used to determine if a car can be set out at a destination ( location ).
public void close ( ) throws java . io . io { flush buffer ( ) ; m os . close ( ) ; }	close the stream , flushing it first.
private static string [ ] norm ( string path ) { string [ ] elements = path . split ( str ) ; array list < string > stack = new array list < string > ( ) ; for ( string e : elements ) { if ( e . is empty ( ) || e . equals ( str ) ) continue ; if ( e . equals ( str ) ) { if ( ! stack . is empty ( ) ) stack . remove ( stack . size ( ) - num ) ; else return null ; continue ; } stack . add ( e ) ; } return stack . to array ( new string [ stack . size ( ) ] ) ; }	process a path into an array of folders.
static random random ( ) { if ( null == lucene test case ) { return null ; } else { try { method random method = lucene test case . get method ( str ) ; return ( random ) random method . invoke ( null ) ; } catch ( exception e ) { throw new illegal state exception ( str , e ) ; } } }	returns a random to be used by the current thread if available , otherwise returns null .
protected string record ( string deployment ) { deployments . add ( deployment ) ; return deployment ; }	record the fact that something was deployed , resulting in the given deployment id.
protected void on before start ( bundle context ctx ) { }	this method is called before ignite initialises.
@ override public void on success ( dlsn value ) { if ( value . get log segment sequence no ( ) != current log segment seq no ) { log . error ( str , value . get log segment sequence no ( ) , current log segment seq no ) ; errors found . set ( bool ) ; } if ( verify entry id && value . get entry id ( ) != current entry id ) { log . error ( str , value . get entry id ( ) , current entry id ) ; errors found . set ( bool ) ; } sync latch . count down ( ) ; }	invoked if the computation completes successfully.
private static void shut down my sql ( class loader class loader ) { try { class < ? > mysql cleanup thread class ; try { mysql cleanup thread class = class loader . load class ( str ) ; } catch ( class not found exception e ) { log . trace ( str + str , e ) ; return ; } method shutdown method = mysql cleanup thread class . get method ( str ) ; shutdown method . invoke ( null ) ; log . debug ( str ) ; } catch ( throwable e ) { log . warn ( str , e ) ; } }	shuts down a cleanup thread com.
public void write ( byte [ ] buffer ) { if ( is final ) { log . warning ( str ) ; return ; } byte [ ] new data = new byte [ data . length + buffer . length ] ; system . arraycopy ( data , num , new data , num , data . length ) ; system . arraycopy ( buffer , num , new data , data . length , buffer . length ) ; data = new data ; }	expands the current speech data by appending a new buffer of audio data.
public string parse ( string control template , context control context ) throws exception { this . control context = control context ; fill context defaults ( this . control context ) ; fill context properties ( this . control context ) ; template template = get template ( control template , input encoding ) ; string writer sw = new string writer ( ) ; template . merge ( control context , sw ) ; return sw . to string ( ) ; }	parse the control template and merge it with the control context.
protected boolean on create custom from tag ( xml pull parser parser , t parent , final attribute set attrs ) throws xml pull parser exception { return bool ; }	before this inflater tries to create an item from the tag , this method will be called . the parser will be pointing to the start of a tag , you must stop parsing and return when you reach the end of this element !.
public static long write file ( string path , byte [ ] jpeg , exif interface exif ) throws io { if ( ! create directory if needed ( path ) ) { log . e ( tag , str + path ) ; return - num ; } if ( exif != null ) { exif . write exif ( jpeg , path ) ; file f = new file ( path ) ; return f . length ( ) ; } else { return write file ( path , jpeg ) ; } }	writes the jpeg data to a file.
private boolean check for image servers ( ) { boolean image server exists = bool ; list < uri > image server uri = db client . query by type ( compute image server . class , bool ) ; array list < uri > temp list = lists . new array list ( image server uri . iterator ( ) ) ; if ( temp list . is empty ( ) ) { image server exists = bool ; } return image server exists ; }	check if there are image servers in the system.
final long now ( ) { return system . nano time ( ) ; }	returns current nanosecond time .
public void remove extension ( string ext ) { synchronized ( exts ) { ext = ext . to lower case ( ) ; exts . remove ( ext ) ; } }	this method removes an extension to the recognizer .
protected suballocated int vector find namespace context ( int element node index ) { if ( null != m namespace decl set elements ) { int would be at = find in sorted suballocated int vector ( m namespace decl set elements , element node index ) ; if ( would be at >= num ) return ( suballocated int vector ) m namespace decl sets . element at ( would be at ) ; if ( would be at == - num ) return null ; would be at = - num - would be at ; int candidate = m namespace decl set elements . element at ( -- would be at ) ; int ancestor = parent ( element node index ) ; if ( would be at == num && candidate < ancestor ) { int root handle = get document root ( make node handle ( element node index ) ) ; int root id = make node identity ( root handle ) ; int uppermost ns id ; if ( get node type ( root handle ) == dtm . document node ) { int ch = firstch ( root id ) ; uppermost ns id = ( ch != dtm . null ) ? ch : root id ; } else { uppermost ns id = root id ; } if ( candidate == uppermost ns id ) { return ( suballocated int vector ) m namespace decl sets . element at ( would be at ) ; } } while ( would be at >= num && ancestor > num ) { if ( candidate == ancestor ) { return ( suballocated int vector ) m namespace decl sets . element at ( would be at ) ; } else if ( candidate < ancestor ) { do { ancestor = parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( would be at > num ) { candidate = m namespace decl set elements . element at ( -- would be at ) ; } else break ; } } return null ; }	retrieve list of namespace declaration locations active at this node.
public void add observer ( observer observer ) { if ( observer == null ) { throw new null pointer exception ( str ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }	adds the specified observer to the list of observers.
protected double distance ( int i , int k , int [ ] designations ) { return math . sqrt ( math . max ( self k [ i ] - num / ownes [ k ] * eval sum k ( i , k , designations ) + mean sqrd norms [ k ] * norm consts [ k ] , num ) ) ; }	computes the distance between one data point and a specified mean.
public string buffer format ( object pat , string buffer result , field position fpos ) { string pattern = process pattern ( ( string ) pat ) ; int last offset = num ; for ( int i = num ; i <= max offset ; ++ i ) { int offidx = offsets [ i ] ; result . append ( pattern . substring ( last offset , offsets [ i ] ) ) ; last offset = offidx ; string key = arguments [ i ] ; string obj ; if ( key . length ( ) > num ) { obj = format object ( process key ( key ) ) ; } else { result . append ( this . ldel ) ; result . append ( this . rdel ) ; continue ; } if ( obj == null ) { string lessgreedy = ldel + key ; int fromright = lessgreedy . last index of ( ldel ) ; if ( fromright > num ) { string newkey = lessgreedy . substring ( fromright + ldel . length ( ) ) ; string newsubst = format object ( process key ( newkey ) ) ; if ( newsubst != null ) { obj = lessgreedy . substring ( num , fromright ) + newsubst ; } } } if ( obj == null ) { if ( throwex ) { throw new illegal argument exception ( str ) ; } else { obj = ldel + key + rdel ; } } result . append ( obj ) ; } result . append ( pattern . substring ( last offset , pattern . length ( ) ) ) ; return result ; }	formats the parsed string by inserting table ' s values .
public void add ( string keyword , byte id ) { int key = get string map key ( keyword ) ; map [ key ] = new keyword ( keyword . to char array ( ) , id , map [ key ] ) ; }	adds a key - value mapping .
void release ( object owner , field field ) { map < string , integer > fields = owners . get ( owner ) ; if ( fields != null ) { release ( ) ; integer count = fields . get ( field . to generic string ( ) ) ; if ( -- count > num ) { fields . put ( field . to generic string ( ) , count ) ; } else { fields . remove ( field . to generic string ( ) ) ; } } if ( fields != null && fields . is empty ( ) ) { owners . remove ( owner ) ; } }	release an instance injected as a field of an object.
public static list < dashboard dto > transform to dto ( list < dashboard > dashboards ) { if ( dashboards == null ) { throw new web application exception ( str , status . internal server error ) ; } list < dashboard dto > result = new array list < dashboard dto > ( ) ; for ( dashboard dashboard : dashboards ) { result . add ( transform to dto ( dashboard ) ) ; } return result ; }	converts list of alert entity objects to list of alertdto objects .
static executor screen executor ( executor e ) { if ( ! use common pool && e == fork join pool . common pool ( ) ) return async pool ; if ( e == null ) throw new null pointer exception ( ) ; return e ; }	null - checks user executor argument , and translates uses of commonpool to asyncpool in case parallelism disabled .
public void add group properties listener ( group properties listener group properties listener ) { group properties listeners . add ( group properties listener ) ; }	adds a group properties listener .
public static void edit global function comment ( final sql provider , final i function , final integer comment id , final integer user id , final string new comment ) throws couldnt save data exception { sql . edit comment ( provider , comment id , user id , new comment ) ; }	edits a global function comment .
public synchronized void clear sessions ( context context , boolean clear credentials ) { synchronized ( instance ) { while ( m mx . size ( ) > num ) { clear session ( context , m mx . get ( num ) , clear credentials ) ; } } }	clear any existing session .
public boolean does entry exists ( sso token , string entry dn ) { try { persistent object po = ums . get object ( internal token , new guid ( entry dn ) ) ; } catch ( ums ue ) { if ( entry dn . index of ( str ) < num ) { if ( debug . message enabled ( ) ) { debug . message ( str + str , ue ) ; } } return bool ; } return bool ; }	checks if the entry exists in the directory .
private static char [ ] yy unpack cmap ( string packed ) { char [ ] map = new char [ num ] ; int i = num ; int j = num ; while ( i < num ) { int count = packed . char at ( i ++ ) ; char value = packed . char at ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > num ) ; } return map ; }	unpacks the compressed character translation table .
private static native void init i ( ) ;	initialize jni field and method ids .
private static int hash wrapper name ( string xn ) { if ( xn . length ( ) < num ) { return num ; } return ( num * xn . char at ( num ) + xn . char at ( num ) ) % num ; }	class name to wrapper hash , derived from wrapper . hashwrap ( ).
@ override public final void start element ( final string ns , final string l name , final string q name , final attributes list ) throws sax { string name = l name == null || l name . length ( ) == num ? q name : l name ; string buffer sb = new string buffer ( match ) ; if ( match . length ( ) > num ) { sb . append ( str ) ; } sb . append ( name ) ; match = sb . to string ( ) ; rule r = ( rule ) rules . match ( match ) ; if ( r != null ) { r . begin ( name , list ) ; } }	process notification of the start of an xml element being reached .
public boolean is string ( string key ) { object val = get ( key ) ; return val instanceof string ; }	check type of section element defined by key . return true this element is string.
private void create pr ( list vm list , int start index for region , int end index for region , int local max memory , int redundancy ) { iterator node iterator = vm list . iterator ( ) ; while ( node iterator . has next ( ) ) { vm vm = ( vm ) node iterator . next ( ) ; vm . invoke ( create multiple pr ( pr prefix , start index for region , end index for region , redundancy , local max memory , num ) ) ; } }	this function creates a partition region with total_buckets_num_property set to 11 .
public zdiagmat ( zmat a , int k ) throws jampack exception { parameters . base index not changeable = bool ; basex = parameters . base index ; if ( k >= num ) { if ( k >= a . ncol ) { throw new jampack exception ( str ) ; } order = math . min ( a . nrow , a . ncol - k ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = num ; i < order ; i ++ ) { re [ i ] = a . re [ i ] [ i + k ] ; im [ i ] = a . im [ i ] [ i + k ] ; } } else { k = - k ; if ( k >= a . nrow ) { throw new jampack exception ( str ) ; } order = math . min ( a . nrow - k , a . ncol ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = num ; i < order ; i ++ ) { re [ i ] = a . re [ i + k ] [ i ] ; im [ i ] = a . im [ i + k ] [ i ] ; } } get properties ( ) ; }	constructs a zdiagmat and initializes it to the diagonal of a zmat .
protected void check ant version ( hashtable h ) { if ( null == h ) h = new hashtable ( ) ; try { final string ant version class = str ; final string ant version method = str ; final class no args [ ] = new class [ num ] ; class clazz = object factory . find provider class ( ant version class , object factory . find class loader ( ) , bool ) ; method method = clazz . get method ( ant version method , no args ) ; object return value = method . invoke ( null , new object [ num ] ) ; h . put ( version + str , ( string ) return value ) ; } catch ( exception e ) { h . put ( version + str , class notpresent ) ; } }	report product version information from ant .
public void build network ( ) { neuron first neuron = new neuron ( network , default neuron type ) ; list < neuron > current layer = new array list < neuron > ( ) ; first neuron . set position ( initial position ) ; current layer . add ( first neuron ) ; int num neurons last layer = ( int ) math . pow ( num braches per neuron , num layers ) ; double total space = num neurons last layer * horizontal spacing ; for ( int layer index = num ; layer index <= num layers ; layer index ++ ) { list < neuron > temp list = new array list < neuron > ( ) ; double layer spacing = total space / ( int ) math . pow ( num braches per neuron , layer index ) ; double branch width = layer spacing * ( num braches per neuron - num ) ; for ( neuron base neuron : current layer ) { network . add neuron ( base neuron ) ; double initial x = branch width / num ; for ( int j = num ; j < num braches per neuron ; j ++ ) { neuron target neuron = new neuron ( network , new linear rule ( ) ) ; target neuron . set location ( base neuron . get x ( ) - initial x + ( j * layer spacing ) , initial position . y - ( layer index * vertical spacing ) ) ; temp list . add ( target neuron ) ; network . add neuron ( target neuron ) ; target neuron . set update priority ( layer index ) ; synapse synapse = new synapse ( network , base neuron , target neuron , new static synapse rule ( ) ) ; network . add synapse ( synapse ) ; } } current layer = temp list ; } }	create the cascading network .
private static boolean are equal ( int from index , char sequence left , char sequence right ) { if ( left == right ) return bool ; if ( ( left == null ) || ( right == null ) ) return bool ; int n = left . length ( ) ; if ( right . length ( ) != n ) return bool ; for ( int i = n ; i > from index ; ) { if ( character . to upper case ( left . char at ( -- i ) ) != character . to upper case ( right . char at ( i ) ) ) return bool ; } return bool ; }	check for equality of the two characters sequences starting at the specified index.
public void test case12 ( ) { byte b bytes [ ] = { num , num , - num , num , num , - num , num , - num } ; int b sign = - num ; byte r bytes [ ] = { num } ; big integer a number = big integer . zero ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . divide ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	divide zero by a negative number .
public enumeration productions ( ) { return productions . elements ( ) ; }	access to productions with this non terminal on the lhs .
public void add tight source node ( ast reference ) { f tight source range nodes . add ( reference ) ; list < structural property descriptor > properties = reference . structural properties for type ( ) ; for ( iterator < structural property descriptor > iterator = properties . iterator ( ) ; iterator . has next ( ) ; ) { structural property descriptor descriptor = iterator . next ( ) ; if ( descriptor . is child property ( ) ) { ast child = ( ast ) reference . get structural property ( descriptor ) ; if ( child != null && is extending ( child , reference ) ) { add tight source node ( child ) ; } } else if ( descriptor . is child list property ( ) ) { list < ? extends ast > children = ( list < ? extends ast > ) reference . get structural property ( descriptor ) ; for ( iterator < ? extends ast > iterator2 = children . iterator ( ) ; iterator2 . has next ( ) ; ) { ast child = iterator2 . next ( ) ; if ( is extending ( child , reference ) ) { add tight source node ( child ) ; } } } } }	add the given node to the set of " tight " nodes .
protected boolean is event disabled ( x e ) { switch ( e . get type ( ) ) { case x . configure notify : return bool ; case x . enter notify : case x . leave notify : return bool ; default : return super . is event disabled ( e ) ; } }	end of i n s e t s c o d e.
public d ( j parent ) throws io { this ( parent , res . get string ( str ) , modality type . document modal ) ; }	creates new djarinfo dialog where the parent is a frame .
protected void transform point array no touch ( float [ ] pts ) { m matrix value to px . map points ( pts ) ; m matrix offset . map points ( pts ) ; }	transform an array of points with all matrixes except the touch matrix - - > use this if the transformed values are not effected by touch gestures.
private void convert escaped function ( final string builder target , final char sequence escaped function ) throws fbsql { final string template result = fb . convert template ( escaped function . to string ( ) , mode ) ; target . append ( template result != null ? template result : escaped function ) ; }	this method converts escaped function to a server function call.
@ override public final string to string ( ) { if ( string rep == null ) { string builder buffer = new string builder ( ) ; buffer . append ( this . name ) ; buffer . append ( str ) ; buffer . append ( integer . to string ( this . default port ) ) ; string rep = buffer . to string ( ) ; } return string rep ; }	return a string representation of this object .
public void add listener ( ims session listener listener ) { m listeners . add ( listener ) ; }	add a listener for receiving events.
public static i stamp to path ( final long stamp ) { fg calendar . set time in millis ( stamp ) ; final string buffer buffer = new string buffer ( num ) ; buffer . append ( fg calendar . get ( calendar . year ) ) ; buffer . append ( i . separator ) ; buffer . append ( fg calendar . get ( calendar . month ) + num ) ; buffer . append ( i . separator ) ; buffer . append ( fg calendar . get ( calendar . week of year ) ) ; return new path ( buffer . to string ( ) ) ; }	returns a path representing the history part for the specified time stamp .
public void print user message ( user message message ) { user user = message . user ; boolean ignored = message . ignored compact ; if ( ignored ) { print compact ( str , user ) ; return ; } color color = message . color ; boolean action = message . action ; string text = message . text ; tag emotes emotes = message . emotes ; boolean highlighted = message . highlighted ; if ( message . whisper && message . action ) { color = style constants . get foreground ( styles . info ( ) ) ; highlighted = bool ; } close compact mode ( ) ; mutable attribute set style ; if ( highlighted ) { style = styles . highlight ( color ) ; } else { style = styles . standard ( ) ; } print ( get time prefix ( ) , style ) ; print user ( user , action , message . whisper , message . id ) ; if ( ! highlighted && action && styles . action colored ( ) ) { style = styles . standard ( user . get display color ( ) ) ; } print specials ( text , user , style , emotes , bool , message . bits > num ) ; print newline ( ) ; }	output a regular message from a user .
public boolean connect impl ( string address , int port ) throws io { socket timeout = num ; native fd = - num ; is closed . set ( bool ) ; synchronized ( write lock ) { boolean is connect = native connect ( socket fd , address , port ) ; return is connect ; } }	creates the new server socket .
public static boolean is access modifier ( string str ) { return str . equals ( str ) || str . equals ( str ) || str . equals ( str ) || str . equals ( str ) || str . equals ( str ) || str . equals ( str ) ; }	returns true if str is an access modifier , false otherwise .
protected void handle append request failure ( member state member , append request request , throwable error ) { fail attempt ( member , error ) ; }	handles an append failure .
private static size pair select size pair ( camera camera , int desired width , int desired height ) { list < size pair > valid preview sizes = generate valid preview size list ( camera ) ; size pair selected pair = null ; int min diff = integer . max value ; for ( size pair size pair : valid preview sizes ) { size size = size pair . preview size ( ) ; int diff = math . abs ( size . get width ( ) - desired width ) + math . abs ( size . get height ( ) - desired height ) ; if ( diff < min diff ) { selected pair = size pair ; min diff = diff ; } } return selected pair ; }	selects the most suitable preview and picture size , given the desired width and height.
public list < address item > load all deep from cursor ( cursor cursor ) { int count = cursor . get count ( ) ; list < address item > list = new array list < address item > ( count ) ; if ( cursor . move to first ( ) ) { if ( identity scope != null ) { identity scope . lock ( ) ; identity scope . reserve room ( count ) ; } try { do { list . add ( load current deep ( cursor , bool ) ) ; } while ( cursor . move to next ( ) ) ; } finally { if ( identity scope != null ) { identity scope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static string decode ( byte [ ] utf8 ) throws character coding exception { return decode ( byte buffer . wrap ( utf8 ) , bool ) ; }	converts the provided byte array to a string using the utf - 8 encoding.
private map < string , string > attributes to lower case ( ) { map < string , string > lower case attributes = new linked hash map < string , string > ( ) ; for ( string key : attributes . key set ( ) ) { lower case attributes . put ( key . to lower case ( ) , attributes . get ( key ) ) ; } return lower case attributes ; }	returns a copy of the set of attributes for this node with lowercase names.
protected final void accept annotations ( final method visitor mv ) { int n = visible type annotations == null ? num : visible type annotations . size ( ) ; for ( int i = num ; i < n ; ++ i ) { type annotation node an = visible type annotations . get ( i ) ; an . accept ( mv . visit insn annotation ( an . type ref , an . type path , an . desc , bool ) ) ; } n = invisible type annotations == null ? num : invisible type annotations . size ( ) ; for ( int i = num ; i < n ; ++ i ) { type annotation node an = invisible type annotations . get ( i ) ; an . accept ( mv . visit insn annotation ( an . type ref , an . type path , an . desc , bool ) ) ; } }	makes the given visitor visit the annotations of this instruction .
public static < t > list < t > to list ( t obj1 , t obj2 ) { list < t > list = new linked list < t > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; return list ; }	create a list from passed objx parameters.
public byte [ ] read next part ( ) throws j { if ( remaining bytes == num ) { throw new j ( str , str , str ) ; } try { file input stream in = new file input stream ( file ) ; in . skip ( filesize - remaining bytes ) ; int partsize = remaining bytes ; if ( partsize > num ) partsize = num ; byte [ ] data = new byte [ partsize ] ; in . read ( data ) ; in . close ( ) ; remaining bytes -= partsize ; return data ; } catch ( io e ) { e . print stack trace ( ) ; throw new j ( str , str + str , str ) ; } }	reads the next part of the related file.
public boolean is multi line tabbed ( ) { return multi line tab ; }	whether using the tab key indents the selected lines of code.
protected void compute parameters ( ) { if ( m > num ) { m = m / m ; double std dev = math . sqrt ( math . abs ( m - m * m ) / m ) ; if ( std dev > num ) { m = math . max ( m / ( num * num ) , std dev ) ; } } }	compute the parameters of the distribution.
public string translate data type ( string source vendor name , string target vendor name , string data type , int size , int scale ) { return get data type ( target vendor name , get data type id ( source vendor name , data type ) , size , scale ) ; }	translate data type from source to target database.
public static int find global valley location ( double [ ] data ) { double min = double . n ; int imin = - num ; for ( int i = num ; i < data . length ; i ++ ) { if ( double . is na n ( data [ i ] ) ) continue ; if ( double . is na n ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }	find the minimum of all elements in the array , ignoring elements that are nan .
protected void move down selected ( ) { int selected index = table . get selected row ( ) ; if ( selected index > - num ) { int index = data . move down ( index to model ( selected index ) ) ; set row selected ( index to view ( index ) ) ; } }	moves the selected item down in the model ( and table ).
jar with file ( path impl backing ) { super ( backing ) ; }	creates a new jar .
public list < runnable > shutdown now ( ) { logger . info ( str ) ; return executor . shutdown now ( ) ; }	shut down the scanner , interrupting running tasks and cancelling waiting ones .
public static list < string > to relative paths ( @ not null virtual file root , @ not null final collection < file path > file paths ) { array list < string > rc = new array list < string > ( file paths . size ( ) ) ; for ( file path path : file paths ) { rc . add ( relative path ( root , path ) ) ; } return rc ; }	covert list of files to relative paths.
private void handle unlock or install ( ) { if ( is finishing ( ) ) { return ; } switch ( m key store . state ( ) ) { case uninitialized : { ensure key guard ( ) ; return ; } case locked : { new unlock dialog ( ) ; return ; } case unlocked : { if ( ! check key guard quality ( ) ) { new configure key guard dialog ( ) ; return ; } install if available ( ) ; finish ( ) ; return ; } } }	based on the current state of the keystore and key guard , try to make progress on unlocking or installing to the keystore .
private void offset start time if necessary ( time start time , time end time , string rrule , calendar event model model ) { if ( rrule == null || rrule . is empty ( ) ) { return ; } m event recurrence . parse ( rrule ) ; if ( m event recurrence . freq != event recurrence . weekly ) { return ; } if ( m event recurrence . byday . length > m event recurrence . byday count ) { return ; } int closest weekday = integer . max value ; int weekstart = event recurrence . day2 time day ( m event recurrence . wkst ) ; int start day = start time . week day ; for ( int i = num ; i < m event recurrence . byday count ; i ++ ) { int day = event recurrence . day2 time day ( m event recurrence . byday [ i ] ) ; if ( day == start day ) { return ; } if ( day < weekstart ) { day += num ; } if ( day > start day && ( day < closest weekday || closest weekday < start day ) ) { closest weekday = day ; } if ( closest weekday == integer . max value || closest weekday < start day ) { if ( day < closest weekday ) { closest weekday = day ; } } } if ( closest weekday < start day ) { closest weekday += num ; } int days offset = closest weekday - start day ; start time . month day += days offset ; end time . month day += days offset ; long new start time = start time . normalize ( bool ) ; long new end time = end time . normalize ( bool ) ; model . m start = new start time ; model . m end = new end time ; }	if the recurrence rule is such that the event start date doesn ' t actually fall in one of the recurrences , then push the start date up to the first actual instance of the event .
public vector3 ceil ( ) { return new vector3 ( math . ceil ( x ) , math . ceil ( y ) , math . ceil ( z ) ) ; }	rounds the x , y , and z values of this vector3 up to the nearest integer value .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang fill in stack trace ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
private void clean up frontier ( ) { while ( ! frontier . is empty ( ) && is explored ( frontier . element ( ) ) ) frontier . remove ( ) ; }	helper method which removes nodes of already explored states from the head of the frontier .
private void parse attributes ( typed array a ) { bar width = ( int ) a . get dimension ( r . styleable . pw bar width , bar width ) ; rim width = ( int ) a . get dimension ( r . styleable . pw rim width , rim width ) ; spin speed = ( int ) a . get dimension ( r . styleable . pw spin speed , spin speed ) ; bar length = ( int ) a . get dimension ( r . styleable . pw bar length , bar length ) ; delay millis = a . get integer ( r . styleable . pw delay millis , delay millis ) ; if ( delay millis < num ) { delay millis = num ; } if ( a . has value ( r . styleable . pw text ) ) { set text ( a . get string ( r . styleable . pw text ) ) ; } bar color = a . get color ( r . styleable . pw bar color , bar color ) ; text color = a . get color ( r . styleable . pw text color , text color ) ; rim color = a . get color ( r . styleable . pw rim color , rim color ) ; circle color = a . get color ( r . styleable . pw circle color , circle color ) ; contour color = a . get color ( r . styleable . pw contour color , contour color ) ; text size = ( int ) a . get dimension ( r . styleable . pw text size , text size ) ; contour size = a . get dimension ( r . styleable . pw contour size , contour size ) ; a . recycle ( ) ; }	parse the attributes passed to the view from the xml.
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { byte [ ] output = new byte [ a . length + b . length ] ; system . arraycopy ( a , num , output , num , a . length ) ; system . arraycopy ( b , num , output , a . length , b . length ) ; return output ; }	concatenates two byte arrays .
public final assert subscriber < t > assert terminated ( ) { if ( cdl . get count ( ) != num ) { throw new assertion error ( str , null ) ; } return this ; }	assert either complete successfully or error signal has been received .
protected static void assert argument ( final boolean valid arg , final string message , final object ... args ) { if ( ! valid arg ) { throw new illegal argument exception ( string . format ( message , args ) ) ; } }	asserts the argument is valid , as determined by the caller passing the result of an evaluated expression to this assertion .
public static boolean is before today ( calendar calendar ) { return calendar . before ( calendar . get instance ( ) ) ; }	allows to know if a given calendar instance is set before today.
public static view item group build login ui ( model application model app , activity activity ) { view item group view items = new view item group ( activity ) ; text view username text = new text view ( activity ) ; username text . set text ( r . string . username ) ; view items . add view ( username text ) ; view item factory view item factory = view item factory . instance ( ) ; view item username item = view item factory . create ( id . username , view item factory . text datatype db id , activity ) ; view items . add view item ( username item , new omni text ( model app . get username ( ) ) ) ; text view password text = new text view ( activity ) ; password text . set text ( r . string . password ) ; view items . add view ( password text ) ; view item password item = view item factory . create ( id . password , view item factory . password input datatype db id , activity ) ; view items . add view item ( password item , new omni password input ( model app . get password ( ) ) ) ; return view items ; }	build a standard login ui with username and password fields.
public void un map volume from scsi ( string volume id , string initiator id ) throws exception { string uri = io . get unmap volume to scsi initiator uri ( volume id ) ; io unmap parm = new io ( ) ; unmap parm . set scsi initiator id ( initiator id ) ; post ( uri . create ( uri ) , get json for entity ( unmap parm ) ) ; }	unmap the volume from scsi initiator.
public collection < t > as collection ( ) { return this . list ; }	returns the underlying collection .
private static void add quarter arc ( d . float path , float x1 , float y1 , float x2 , float y2 , float curvature , boolean vertical start ) { boolean down = y1 < y2 ; boolean left = x1 > x2 ; float cx1 = num ; float cy1 = num ; float cx2 = num ; float cy2 = num ; if ( vertical start ) { cx1 = x1 ; cy2 = y2 ; if ( left ) { cx2 = x1 - curvature ; } else { cx2 = x1 + curvature ; } if ( down ) { cy1 = y2 - curvature ; } else { cy1 = y2 + curvature ; } } else { cx2 = x2 ; cy1 = y1 ; if ( left ) { cx1 = x2 + curvature ; } else { cx1 = x2 - curvature ; } if ( down ) { cy2 = y1 + curvature ; } else { cy2 = y1 - curvature ; } } path . curve to ( cx1 , cy1 , cx2 , cy2 , x2 , y2 ) ; }	add a quarter circular path to a given path object , starting from ( x1 , y1 ) to ( x2 , y2 ) .
@ override public void parse ( string content , node block ) { this . block = block ; this . input = content . trim ( ) ; this . index = num ; this . last delimiter = null ; this . last bracket = null ; boolean more to parse ; do { more to parse = parse inline ( ) ; } while ( more to parse ) ; process delimiters ( null ) ; merge text nodes ( block . get first child ( ) , block . get last child ( ) ) ; }	parse content in block into inline children , using reference map to resolve references .
public static void random ( byte [ ] b , int offset , int length ) { check position index ( offset , b . length , str ) ; check argument ( length > num , str ) ; check position index ( offset + length , b . length , str ) ; byte [ ] buf = new byte [ length ] ; rng . next bytes ( buf ) ; system . arraycopy ( buf , num , b , offset , length ) ; }	fill given array with random bytes at the specified position .
public void remove all scanning callbacks ( ) { scanning callbacks . clear ( ) ; }	removes all scanning callbacks .
public int read ( byte [ ] buf , int off , int len ) throws t { if ( input stream == null ) { throw new t ( t . not open , str ) ; } int bytes read ; try { bytes read = input stream . read ( buf , off , len ) ; } catch ( io iox ) { throw new t ( t . unknown , iox ) ; } if ( bytes read < num ) { throw new t ( t . end of file ) ; } return bytes read ; }	reads from the underlying input stream if not null .
public void handle manager creation ( ) throws management exception { if ( ! is service initialised ( str ) ) { return ; } object name manager m = m jmx . get manager name ( ) ; m bridge = new m ( service ) ; mx bean = new m ( bridge ) ; service . register internal m ( bean , manager m ) ; }	assumption is always cache and membermbean has been will be created first.
@ suppress warnings ( str ) private boolean check set shape ( shape old shape , shape new shape ) { shape current shape = get shape ( ) ; assert old shape != new shape : str ; assert new shape != current shape : str + current shape ; assert old shape == current shape || old shape . get parent ( ) == current shape : str + str + current shape + str + old shape + str + new shape ; return bool ; }	check whether fast transition is valid .
protected boolean is file visible ( file file ) { if ( file == null || ! file . exists ( ) || ! file . can read ( ) || file . is hidden ( ) ) { return bool ; } return bool ; }	returns true if the given file is visible.
public static string [ ] append ( final string [ ] a , final string ... b ) { final int alen = a . length ; final int blen = b . length ; final string [ ] res = arrays . copy of ( a , alen + blen ) ; system . arraycopy ( b , num , res , alen , blen ) ; return res ; }	append strings to an array creating a new array for the result .
public void delete ( ) throws am , sso { delete ( bool ) ; }	removes and destroys the object .
public string ( byte [ ] bytes , int off , int len , java . lang . string enc ) throws java . io . unsupported encoding exception { this ( bytes to chars ( bytes , off , len , enc ) ) ; }	construct a new string by converting the specified subarray of bytes using the specified character encoding.
private boolean initialize search itemset ( bit vector bv , int [ ] scratchi , int [ ] iters ) { for ( int i = num ; i < scratchi . length ; i ++ ) { iters [ i ] = ( i == num ) ? bv . iter ( ) : bv . iter advance ( iters [ i - num ] ) ; if ( iters [ i ] < num ) { return bool ; } scratchi [ i ] = bv . iter dim ( iters [ i ] ) ; } return bool ; }	initialize the scratch itemset .
private rectangle compute editor bounds ( ) { if ( row == - num || column == - num ) return new rectangle ( num , num , num , num ) ; rectangle cell = grid . get cell bounds ( column , row ) ; rectangle area = grid . get client area ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . x + area . width - cell . x ; } } rectangle editor rect = new rectangle ( cell . x , cell . y , minimum width , minimum height ) ; if ( grab horizontal ) { editor rect . width = math . max ( cell . width , minimum width ) ; } if ( grab vertical ) { editor rect . height = math . max ( cell . height , minimum height ) ; } if ( horizontal alignment == swt . right ) { editor rect . x += cell . width - editor rect . width ; } else if ( horizontal alignment == swt . left ) { } else { editor rect . x += ( cell . width - editor rect . width ) / num ; } if ( vertical alignment == swt . bottom ) { editor rect . y += cell . height - editor rect . height ; } else if ( vertical alignment == swt . top ) { } else { editor rect . y += ( cell . height - editor rect . height ) / num ; } return editor rect ; }	returns the bounds of the editor .
public int read ( byte [ ] buffer , int offset , int length ) throws io { throw new unsupported operation exception ( string . value of ( this ) ) ; }	reads the next chunk from the stream .
public cuboid ( world world , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world name = world . get name ( ) ; this . x1 = math . min ( x1 , x2 ) ; this . x2 = math . max ( x1 , x2 ) ; this . y1 = math . min ( y1 , y2 ) ; this . y2 = math . max ( y1 , y2 ) ; this . z1 = math . min ( z1 , z2 ) ; this . z2 = math . max ( z1 , z2 ) ; }	construct a cuboid in the given world and xyz co - ordinates.
@ suppress warnings ( { str } ) public double log marginal likelihood smoothed ( list < double > v , double delta , double pdata ) { final double log delta = strict math . log ( delta ) ; final double log inv delta = strict math . log ( num - delta ) ; final int n = v . size ( ) ; final double log n = strict math . log ( n ) ; final double offset = log inv delta - pdata ; double bottom = log n + log delta - log inv delta ; double top = bottom + pdata ; for ( int i = num ; i < n ; i ++ ) { double weight = - log tricks . log sum ( log delta , offset + v . get ( i ) ) ; top = log tricks . log sum ( top , weight + v . get ( i ) ) ; bottom = log tricks . log sum ( bottom , weight ) ; } return top - bottom ; }	calculates the log marginal likelihood of a model using newton and raftery ' s smoothed estimator.
public boolean is new message ( ) { if ( message == null ) { throw new illegal state exception ( str ) ; } return message . starts with ( str ) || message . equals ( str ) ; }	returns true if the message starts with & quot ; new ( & quot ; or if it equals & quot ; new & quot ;.
private void install properties ( ) { system . set property ( str , user agent generator . get user agent ( ) ) ; if ( os . is mac osx ( ) ) { system . set property ( str , str ) ; } }	installs any system properties .
public double buffer put ( double [ ] src , int src offset , int double count ) { arrays . check offset and count ( src . length , src offset , double count ) ; if ( double count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + double count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes doubles from the given double array , starting from the specified offset , to the current position and increases the position by the number of doubles written .
private void load recipients ( int address type , hash set < string > recipients , hash map < integer , encoded string value [ ] > address map , boolean exclude my number ) { encoded string value [ ] array = address map . get ( address type ) ; if ( array == null ) { return ; } if ( exclude my number && array . length == num ) { return ; } string my number = exclude my number ? m telephony manager . get line1 number ( ) : null ; for ( encoded string value v : array ) { if ( v != null ) { string number = v . get string ( ) ; if ( ( my number == null || ! phone number utils . compare ( number , my number ) ) && ! recipients . contains ( number ) ) { recipients . add ( number ) ; } } } }	for a given address type , extract the recipients from the headers .
public static boolean is extension ( string filename , string extension ) { if ( filename == null ) { return bool ; } if ( extension == null || extension . length ( ) == num ) { return index of extension ( filename ) == - num ; } string file ext = get extension ( filename ) ; return file ext . equals ( extension ) ; }	checks whether the extension of the filename is that specified.
@ pre persist public void pre persist ( ) { lock time = system . current time millis ( ) ; }	used to automatically update the timestamp of locks .
public lib padstack add ( string p name , shape convex [ ] p shapes , boolean p attach allowed , boolean p placed absolute ) { int pad no = count ( ) + num ; lib padstack new padstack = new lib padstack ( p name , pad no , p shapes , p attach allowed , p placed absolute ) ; padstack list . add ( new padstack ) ; return new padstack ; }	appends a new padstack with the input shapes to this padstacks.
protected args base ( ) { argv = null ; env = null ; }	for the commandmanager init .
@ override public void start content model ( string element name , augmentations augs ) throws xni { if ( f validation ) { f dtd = element name ; f mixed element types . clear ( ) ; } if ( f dtd != null ) f dtd . start content model ( element name , augs ) ; if ( f dtd != null ) { f dtd . start content model ( element name , augs ) ; } }	the start of a content model.
public om ( lat lon point center , double radius , length units , int nverts ) { super ( center , radius , units , nverts ) ; center point = create center point ( ) ; form . set maximum fraction digits ( num ) ; }	create an omrangerings with a lat / lon center and a physical distance radius.
public static input source create input source ( string s ) { try { return new input source ( new byte array input stream ( s . get bytes ( str ) ) ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } }	create an inputsource form a string .
public static preferences user root ( ) { return factory . user root ( ) ; }	returns the root node of the user preference hierarchy .
public static string to debug string ( final long socket identifier ) { final int ip bits = ( int ) socket identifier ; final int port = extract port number ( socket identifier ) ; final int inode = ( int ) ( socket identifier > > num ) ; return integer . to hex string ( ip bits ) + str + port + str + inode ; }	generates a vaguely human - readable format for a given socket identifier .
public final void push ( string s ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; string new map [ ] = new string [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } m map [ m first free ] = s ; m first free ++ ; }	tell if the table contains the given string .
public static string read from file ( final file path ) throws io { file input stream fis = null ; try { fis = new file input stream ( path ) ; return read from file ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } }	read contents of a file .
public static int x x ( int x , int tile grid x , int tile width ) { x -= tile grid x ; if ( x < num ) { x += num - tile width ; } return x / tile width ; }	converts a pixel ' s x coordinate into a horizontal tile index relative to a given tile grid layout specified by its x offset and tile width .
public input ( string name , @ input type int type , @ alignment int align , connection connection ) { m name = name ; m type = type ; m align = align ; m connection = connection ; if ( m connection != null ) { m connection . set input ( this ) ; } }	creates a new input that can be added to a block .
public static bsh class manager create class manager ( interpreter interpreter ) { bsh class manager manager ; if ( capabilities . class exists ( str ) && capabilities . class exists ( str ) && capabilities . class exists ( str ) ) try { class clas = class . for name ( str ) ; manager = ( bsh class manager ) clas . new instance ( ) ; } catch ( exception e ) { throw new interpreter error ( str + e ) ; } else manager = new bsh class manager ( ) ; if ( interpreter == null ) interpreter = new interpreter ( ) ; manager . declaring interpreter = interpreter ; return manager ; }	create a new instance of the class manager.
public int swap ( ) { if ( ! m egl . egl swap buffers ( m egl display , m egl surface ) ) { return m egl . egl get error ( ) ; } return eg . egl success ; }	display the current render surface .
public void request last login time ( ) { operations . add ( password policy state operation type . get last login time ) ; }	returns the last login time .
public static stream < string > words of ( string text ) { require non null ( text ) ; return words . split as stream ( text ) ; }	creates and returns a stream of the words in the given text.
public void add ( app info info ) { if ( m app filter != null && ! m app filter . should show app ( info . component name ) ) { return ; } if ( find activity ( data , info . component name , info . user ) ) { return ; } data . add ( info ) ; added . add ( info ) ; }	add the supplied applicationinfo objects to the list , and enqueue it into the list to broadcast when notify ( ) is called.
public joiner match ( string field , object ... value ) { return match ( field , arrays . as list ( value ) ) ; }	filter the matching objects for the one ( s ) whoose named field is equal to value.
private string remove you tube markup ( string plot ) { if ( plot == null ) return null ; return plot . replace all ( str , str ) ; }	removes some markup that appears on the plot for youtube videos.
private string create dash array string ( list < float > dashes array ) { string builder sb = new string builder ( ) ; if ( dashes array != null ) { int index = num ; for ( float value : dashes array ) { string str = float . to string ( value ) ; if ( str . ends with ( str ) ) { sb . append ( value . int value ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashes array . size ( ) - num ) { sb . append ( str ) ; } index ++ ; } } return sb . to string ( ) ; }	creates the dash array string .
public long position ( java . sql . blob pattern , long start ) throws sql { return position ( pattern . get bytes ( num , ( int ) pattern . length ( ) ) , start ) ; }	finds the position of the given pattern in this blob .
protected synchronized t load ( ) throws io { long gen loaded = - num ; io ioe = null ; list < string > gen files = new array list < string > ( ) ; string [ ] files ; try { files = dir . list all ( ) ; } catch ( io ioe2 ) { return null ; } t loaded = null ; for ( string file : files ) { if ( file . starts with ( prefix ) ) { long gen = long . parse long ( file . substring ( prefix . length ( ) ) ) ; if ( gen loaded == - num || gen > gen loaded ) { gen files . add ( file ) ; index input in = dir . open input ( file , io . default ) ; try { loaded = load one ( in ) ; } catch ( io ioe2 ) { if ( ioe == null ) { ioe = ioe2 ; } } finally { in . close ( ) ; } gen loaded = gen ; } } } if ( gen loaded == - num ) { if ( ioe != null ) { throw ioe ; } } else { if ( gen files . size ( ) > num ) { string cur file name = prefix + gen loaded ; for ( string file : gen files ) { long gen = long . parse long ( file . substring ( prefix . length ( ) ) ) ; if ( can delete ( gen ) && ! cur file name . equals ( file ) ) { dir . delete file ( file ) ; } } } next write gen = num + gen loaded ; } return loaded ; }	loads the most recent generation file .
public static string read line ( input stream in , string charset ) throws io { byte array output stream baos = new byte array output stream ( ) ; while ( bool ) { int b = in . read ( ) ; if ( b == - num ) { if ( baos . size ( ) == num ) { return null ; } else { break ; } } if ( b == str ) { break ; } if ( b != str ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - num ) { baos . write ( b ) ; break ; } if ( b2 == str ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . to string ( charset ) ; }	read a line from the given stream .
public boolean check table exists ( table definition table ) { string column = null ; for ( field definition field : table . get fields ( ) ) { if ( column == null ) { column = field . get name ( ) ; } else if ( field . is primary key ( ) ) { column = field . get name ( ) ; break ; } } string sql = str + column + str + table . get full name ( ) + str + column + str + column ; data read query query = new data read query ( sql ) ; query . set max rows ( num ) ; try { session . execute query ( query ) ; return bool ; } catch ( exception not found ) { return bool ; } finally { } }	check if the table exists by issuing a select .
private int process colon ( int length ) { if ( has scheme ) { if ( ! read user pass ( length ) && buffer . length ( ) > num ) { reader . go back ( ) ; buffer . delete ( buffer . length ( ) - num , buffer . length ( ) ) ; int backtrack on fail = reader . get position ( ) - buffer . length ( ) + length ; if ( ! read domain name ( buffer . substring ( length ) ) ) { reader . seek ( backtrack on fail ) ; read end ( read end state . invalid url ) ; } length = num ; } } else if ( read scheme ( ) && buffer . length ( ) > num ) { has scheme = bool ; length = buffer . length ( ) ; } else if ( buffer . length ( ) > num && options . has flag ( url detector options . allow single level domain ) && reader . can read chars ( num ) ) { reader . go back ( ) ; buffer . delete ( buffer . length ( ) - num , buffer . length ( ) ) ; read domain name ( buffer . to string ( ) ) ; } else { read end ( read end state . invalid url ) ; length = num ; } return length ; }	we found a " : " and is now trying to read either scheme , username / password.
public static boolean contains sql script delimiters ( string script , string delim ) { boolean in literal = bool ; char [ ] content = script . to char array ( ) ; for ( int i = num ; i < script . length ( ) ; i ++ ) { if ( content [ i ] == str ) { in literal = ! in literal ; } if ( ! in literal && script . starts with ( delim , i ) ) { return bool ; } } return bool ; }	does the provided sql script contain the specified delimiter ?.
public void compress ( byte [ ] bytes , int off , int len , output stream os ) { try { os . write ( bytes , off , len ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	writes the bytes on the output stream .
public void assert not joined ( final uuid service id ) { m triggers . add ( new quorum event invariant ( quorum event enum . service join , service id ) ) ; if ( is member ( m quorum . get joined ( ) , service id ) ) broken ( ) ; }	establish an invariant that the specified service is a not joined with the met quorum .
public int encrypt block ( byte [ ] in , int in off , byte [ ] out , int out off ) throws data length exception , illegal state exception { if ( ( in off + block size ) > in . length ) { throw new data length exception ( str ) ; } if ( ( out off + block size ) > out . length ) { throw new data length exception ( str ) ; } cipher . process block ( cfb v , num , cfb out v , num ) ; for ( int i = num ; i < block size ; i ++ ) { out [ out off + i ] = ( byte ) ( cfb out v [ i ] ^ in [ in off + i ] ) ; } system . arraycopy ( cfb v , block size , cfb v , num , cfb v . length - block size ) ; system . arraycopy ( out , out off , cfb v , cfb v . length - block size , block size ) ; return block size ; }	do the appropriate processing for cfb mode encryption .
public final void print ( string value ) { try { element root element = work doc . get default root element ( ) ; int delete lines = root element . get element count ( ) - lines max ; for ( int index = num ; index < delete lines ; index ++ ) { element elem = root element . get element ( num ) ; work doc . remove ( elem . get start offset ( ) , elem . get end offset ( ) ) ; } work doc . insert string ( work doc . get length ( ) , value , null ) ; text area . set caret position ( work doc . get length ( ) ) ; } catch ( exception exc ) { exc . print stack trace ( ) ; } }	prints a string without adding a / n at the end .
private void add connection groups ( collection < connection group > connection groups ) { for ( connection group connection group : connection groups ) { api parent = retrieved groups . get ( connection group . get parent identifier ( ) ) ; if ( parent != null ) { collection < api > children = parent . get child connection groups ( ) ; if ( children == null ) { children = new array list < api > ( ) ; parent . set child connection groups ( children ) ; } api api connection group = new api ( connection group ) ; retrieved groups . put ( connection group . get identifier ( ) , api connection group ) ; children . add ( api connection group ) ; } else logger . debug ( str , connection group . get identifier ( ) , connection group . get parent identifier ( ) ) ; } }	adds each of the provided connection groups to the current tree as children of their respective parents.
public void load map ( input stream input , string group id ) throws exception { shapes = parser . parse ( input , group id ) ; boundaries = new array list < d > ( shapes . size ( ) ) ; for ( i d shape : shapes ) { boundaries . add ( shape . get bounds ( ) ) ; } }	loads a map input into this cartesian plot .
public void add decoration ( line decoration decoration ) { if ( decoration != null ) { decorations . add ( decoration ) ; } }	add another line decoration into the composite line decoration.
private string parse link title ( ) { string title = match ( link title ) ; if ( title != null ) { return escaping . unescape string ( title . substring ( num , title . length ( ) - num ) ) ; } else { return null ; } }	attempt to parse link title ( sans quotes ) , returning the string or null if no match .
@ override public void put ( double val ) { final double nn = this . n + num ; final double delta = val - m1 ; final double delta nn = delta / nn ; final double delta nn2 = delta nn * delta nn ; final double inc = delta * delta nn * this . n ; m4 += inc * delta nn2 * ( nn * nn - num * nn + num ) + num * delta nn2 * m2 - num * delta nn * m3 ; m3 += inc * delta nn * ( nn - num ) - num * delta nn * m2 ; m2 += inc ; m1 += delta nn ; n = nn ; min = math . min ( min , val ) ; max = math . max ( max , val ) ; }	add a single value with weight 1 . 0.
public void close ( ) { this . closed = bool ; }	closes the command processor , canceling the current work if not finish.
public int size ( ) { return m . size ( ) ; }	returns the number of recent items currently stored .
public jc warning ( lint category lc , string key , object ... args ) { return create ( warning , lc , enum set . none of ( diagnostic flag . class ) , null , null , key , args ) ; }	create a warning diagnostic .
public destructurer ( final tree . pattern that , final generate js visitor gen , final set < declaration > direct access , final string expvar , boolean first , final boolean for assert ) { this . gen = gen ; jsw = gen == null ? null : gen . out ; names = gen == null ? null : gen . get names ( ) ; this . direct access = direct access ; this . expvar = expvar ; this . first = first ; this . for assert = for assert ; that . visit ( this ) ; if ( jsw != null && ! attribs . is empty ( ) ) { for ( value attr : attribs ) { jsw . write ( str , names . self ( ( type declaration ) attr . get container ( ) ) , str , names . name ( attr ) , str , names . name ( attr ) ) ; } } }	generate the code for the specified pattern.
@ suppress warnings ( str ) public void handle tbl sub config button delete request ( request invocation event event ) throws model control exception { submit cycle = bool ; cc tbl = ( cc ) get child ( tbl sub config ) ; tbl . restore state data ( ) ; cc tbl model = ( cc ) tbl . get model ( ) ; integer [ ] selected = tbl model . get selected rows ( ) ; serialized field sz cache = ( serialized field ) get child ( sz cache ) ; list list = sz cache . get serialized obj ( ) ; set < string > names = new hash set < > ( selected . length * num ) ; for ( integer index : selected ) { sm sc = ( sm ) list . get ( index ) ; names . add ( sc . get name ( ) ) ; } try { abstract audit model model = ( abstract audit model ) get model ( ) ; model . delete event handles ( names ) ; if ( selected . length == num ) { set inline alert message ( type info , information message , str ) ; } else { set inline alert message ( type info , information message , str ) ; } } catch ( am e ) { set inline alert message ( type error , error message , e . get message ( ) ) ; } submit cycle = bool ; forward to ( ) ; }	called on request from the ui to delete an event handler .
public boolean is healthy ( boolean do extensive checks ) { if ( socket . is closed ( ) || socket . is input shutdown ( ) || socket . is output shutdown ( ) ) { return bool ; } if ( framed connection != null ) { return bool ; } if ( do extensive checks ) { try { int read timeout = socket . get so timeout ( ) ; try { socket . set so timeout ( num ) ; if ( source . exhausted ( ) ) { return bool ; } return bool ; } finally { socket . set so timeout ( read timeout ) ; } } catch ( socket timeout exception ignored ) { } catch ( io e ) { return bool ; } } return bool ; }	returns true if this connection is ready to host new streams .
public void add column ( int index , column column ) { validate column ( column ) ; column list . add ( index , column ) ; }	adds the given column to this table at the given position in the column list.
private void init ( ) { set title ( str ) ; hop properties panel = new hopfield properties panel ( network panel ) ; hop properties panel . fill field values ( ) ; tab logic . set layout ( new flow layout ( ) ) ; tab logic . add ( hop properties panel ) ; tab layout . add ( layout panel ) ; layout panel = new main layout panel ( bool , this ) ; tabbed pane . add tab ( str , tab logic ) ; tabbed pane . add tab ( str , layout panel ) ; set content pane ( tabbed pane ) ; action help action = new show help action ( hop properties panel . get help path ( ) ) ; add button ( new j ( help action ) ) ; }	initializes all components used in dialog .
private double norm vector ( double [ ] z ) { double sum = num ; for ( int i = num ; i < problem . get number of objectives ( ) ; i ++ ) { sum += z [ i ] * z [ i ] ; } return math . sqrt ( sum ) ; }	computes the norm of a vector .
public string force get value as string ( ) { if ( m value == null ) { return str ; } else if ( m value instanceof byte [ ] ) { if ( m data type == type ascii ) { return new string ( ( byte [ ] ) m value , us ascii ) ; } else { return arrays . to string ( ( byte [ ] ) m value ) ; } } else if ( m value instanceof long [ ] ) { if ( ( ( long [ ] ) m value ) . length == num ) { return string . value of ( ( ( long [ ] ) m value ) [ num ] ) ; } else { return arrays . to string ( ( long [ ] ) m value ) ; } } else if ( m value instanceof object [ ] ) { if ( ( ( object [ ] ) m value ) . length == num ) { object val = ( ( object [ ] ) m value ) [ num ] ; if ( val == null ) { return str ; } else { return val . to string ( ) ; } } else { return arrays . to string ( ( object [ ] ) m value ) ; } } else { return m value . to string ( ) ; } }	gets a string representation of the value .
public int hash code ( ) { return num * factor . hash code ( ) + lag ; }	probably should recheck this later .
private void convert maximal to minimal edge rings ( list ring edges ) { for ( iterator i = ring edges . iterator ( ) ; i . has next ( ) ; ) { polygonize directed edge de = ( polygonize directed edge ) i . next ( ) ; long label = de . get label ( ) ; list int nodes = find intersection nodes ( de , label ) ; if ( int nodes == null ) continue ; for ( iterator i node = int nodes . iterator ( ) ; i node . has next ( ) ; ) { node node = ( node ) i node . next ( ) ; compute next ccw ( node , label ) ; } } }	convert the maximal edge rings found by the initial graph traversal into the minimal edge rings required by jts polygon topology rules .
public void remove event listener ( image sharing listener listener ) throws rcs service not available exception , rcs generic exception { if ( m api == null ) { throw new rcs service not available exception ( ) ; } try { weak reference < i > weak ref = m image sharing listeners . remove ( listener ) ; if ( weak ref == null ) { return ; } i rcs listener = weak ref . get ( ) ; if ( rcs listener != null ) { m api . remove event listener2 ( rcs listener ) ; } } catch ( exception e ) { rcs illegal argument exception . assert exception ( e ) ; throw new rcs generic exception ( e ) ; } }	removes a listener on image sharing events.
private void update wave file size ( ) throws io { byte buffer buffer = get unsigned integer buffer ( m file channel . size ( ) - num ) ; m file channel . write ( buffer , num ) ; byte buffer buffer2 = get unsigned integer buffer ( m file channel . size ( ) - num ) ; m file channel . write ( buffer2 , num ) ; }	updates the overall and the chunk2 sizes.
private void write journal ( parcel file descriptor new state , journal journal ) { try { file output stream out stream = new file output stream ( new state . get file descriptor ( ) ) ; final byte [ ] journal bytes = write checked bytes ( journal ) ; out stream . write ( journal bytes ) ; if ( verbose ) log . v ( tag , str + journal bytes . length + str ) ; } catch ( io e ) { log . w ( tag , str , e ) ; } }	write the new journal to the output file.
public boolean matches ( string sa ) { if ( length != sa . length ( ) ) return bool ; char [ ] buffer = buffer ; int offset = offset ; for ( int i = length - num ; i >= num ; i -- ) if ( buffer [ offset + i ] != sa . char at ( i ) ) return bool ; return bool ; }	returns true if the charsegment matches the string .
@ override public void mouse released ( mouse event event ) { if ( event . get source ( ) == get component decrease spinner button ( ) ) { decrease timer . stop ( ) ; } else { increase timer . stop ( ) ; } }	mousereleased , this will be called when the spinner button is released .
public double compute max class value using percent factor per series ( default chart data chart data , string [ ] series , double [ ] percent factor per series ) { double max value = num ; for ( string class name : chart data . get class names including disabled ( ) ) { double total = num ; for ( int i = num ; i < series . length ; i ++ ) { string series name = series [ i ] ; if ( transposed heights additive ) total += percent factor per series [ i ] * chart data . get value as double ( series name , class name ) ; else total = math . max ( total , percent factor per series [ i ] * chart data . get value as double ( series name , class name ) ) ; } if ( total > max value ) { max value = total ; } } return num * max value ; }	gets the max value for a given class in a transposed chart when using percentages.
public int add channel ( channel channel ) { int index = - num ; switch ( channel . get channel type ( ) ) { case standard : m channels . add ( channel ) ; index = m channels . size ( ) - num ; fire table rows inserted ( index , index ) ; break ; case traffic : m traffic channels . add ( channel ) ; index = m channels . size ( ) - num ; break ; default : break ; } broadcast ( new channel event ( channel , event . notification add ) ) ; if ( channel . get enabled ( ) ) { broadcast ( new channel event ( channel , event . request enable ) ) ; } return index ; }	adds the channel to the model and broadcasts a channel add event.
public static string join ( object ... array ) { if ( array == null ) { return null ; } if ( array . length == num ) { return string pool . empty ; } if ( array . length == num ) { return string . value of ( array [ num ] ) ; } final string builder sb = new string builder ( array . length * num ) ; for ( int i = num ; i < array . length ; i ++ ) { sb . append ( array [ i ] ) ; } return sb . to string ( ) ; }	joins an array of objects into one string without separators .
public boolean has trait ( final store trait store trait ) { final set < store trait > traits = get traits ( ) ; return null != traits && traits . contains ( store trait ) ; }	returns true if the store can handle the provided trait and false if it cannot .
public void create supply ( mwm boundline , big decimal qty supply ) { m product = m . get ( boundline . get ctx ( ) , boundline . get m id ( ) ) ; if ( product . is bom ( ) ) { create mo ( boundline , product , qty supply ) ; } else if ( product . is purchased ( ) ) { create requisition ( boundline , product , qty supply ) ; } }	create supply based in out bound line.
public int size ( ) { return parameters . size ( ) ; }	returns the number of parameters in this parameter file .
@ override public void load xml ( node stepnode , list < database meta > databases , map < string , counter > counters ) throws xml { try { schema name = xml . get tag value ( stepnode , str ) ; tabel name = xml . get tag value ( stepnode , str ) ; mdkey size = xml . get tag value ( stepnode , str ) ; measure count = xml . get tag value ( stepnode , str ) ; heir and key size = xml . get tag value ( stepnode , str ) ; cube name = xml . get tag value ( stepnode , str ) ; group by enabled = xml . get tag value ( stepnode , str ) ; aggregator class string = xml . get tag value ( stepnode , str ) ; aggregator string = xml . get tag value ( stepnode , str ) ; fact dim lens string = xml . get tag value ( stepnode , str ) ; level anddata type string = xml . get tag value ( stepnode , str ) ; current restruct number = integer . parse int ( xml . get tag value ( stepnode , str ) ) ; partition id = xml . get tag value ( stepnode , str ) ; segment id = xml . get tag value ( stepnode , str ) ; task no = xml . get tag value ( stepnode , str ) ; } catch ( exception e ) { throw new xml ( str , e ) ; } }	load the values for this step from an xml node.
public void put ( int key , e value ) { int i = binary search ( m keys , num , m size , key ) ; if ( i >= num ) { m values [ i ] = value ; } else { i = ~ i ; if ( i < m size && m values [ i ] == deleted ) { m keys [ i ] = key ; m values [ i ] = value ; return ; } if ( m garbage && m size >= m keys . length ) { gc ( ) ; i = ~ binary search ( m keys , num , m size , key ) ; } if ( m size >= m keys . length ) { int n = math . max ( m size + num , m keys . length * num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } if ( m size - i != num ) { system . arraycopy ( m keys , i , m keys , i + num , m size - i ) ; system . arraycopy ( m values , i , m values , i + num , m size - i ) ; } m keys [ i ] = key ; m values [ i ] = value ; m size ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
public void read data ( data input din ) throws io { reference = din . read unsigned short ( ) ; }	readdata - - read the reference word .
public float dot product ( dense vector df ) { float res = num ; for ( int i = num ; i < math . min ( size , df . get length ( ) ) ; i ++ ) { res += u [ i ] * df . u [ i ] ; } return res ; }	return the dot product to a dense feature vector.
private void emit code ( ) { linked list < instantiation > worklist = new linked list < instantiation > ( ) ; worklist . add ( new instantiation ( null , main subroutine ) ) ; insn list new instructions = new insn list ( ) ; list < try catch block node > new try catch blocks = new array list < try catch block node > ( ) ; list < local variable node > new local variables = new array list < local variable node > ( ) ; while ( ! worklist . is empty ( ) ) { instantiation inst = worklist . remove first ( ) ; emit subroutine ( inst , worklist , new instructions , new try catch blocks , new local variables ) ; } instructions = new instructions ; try catch blocks = new try catch blocks ; local variables = new local variables ; }	creates the new instructions , inlining each instantiation of each subroutine until the code is fully elaborated .
public static double st dev ( final list < double > list ) { return math . sqrt ( variance ( list ) ) ; }	gets the standard deviation from a list of numbers .
public void trim to size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; system . arraycopy ( olddata , num , array , num , size ) ; } }	trims the capacity of this instance to be the list ' s current size.
public void test set bit zero outside1 ( ) { byte a bytes [ ] = { num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	setbit ( int n ) outside zero.
public static int compare ( date left , boolean right ) { return compare ( left , right ? num : num ) ; }	compares a date with a boolean.
private i [ ] decode next chunk ( ) throws io { if ( nsolutions == solution set count ) { if ( log . is debug enabled ( ) ) log . debug ( str + name + str + nsolutions ) ; return null ; } in . read int ( ) ; final int chunk size = in . read int ( ) ; final int byte length = in . read int ( ) ; final byte [ ] a = new byte [ byte length ] ; in . read fully ( a ) ; final data input buffer buf = new data input buffer ( a ) ; final i [ ] t = new i [ chunk size ] ; for ( int i = num ; i < chunk size ; i ++ ) { t [ i ] = decoder . decode solution ( buf , bool ) ; if ( log . is trace enabled ( ) ) log . trace ( str + name + str + t [ i ] ) ; } nsolutions += chunk size ; if ( log . is trace enabled ( ) ) log . trace ( str + name + str + chunk size + str + ( solution set stream encoder . chunk header size + byte length ) + str + nsolutions ) ; return t ; }	read ahead and decode the next chunk of solutions .
public udp ( logger logger ) { this . logger = logger ; try { socket = new datagram socket ( ) ; socket . set broadcast ( bool ) ; socket . set send buffer size ( num * num * num ) ; socket . set receive buffer size ( num * num * num ) ; socket . set so timeout ( num ) ; } catch ( socket exception e ) { logger . severe ( str ) ; logger . severe ( str + e . get message ( ) ) ; system . exit ( num ) ; } }	create a new udp client socket with the specified logger .
public void multiply all values by ( final double multiply by , final int round type ) { for ( final t t : key set ( ) ) { double val = map values . get ( t ) ; switch ( round type ) { case num : val = math . floor ( val * multiply by ) ; break ; case num : val = math . round ( val * multiply by ) ; break ; case num : val = math . ceil ( val * multiply by ) ; break ; default : val = val * multiply by ; break ; } put ( t , ( int ) val ) ; } }	will multiply all values by a given double.
public static boolean is level ( level level ) { if ( level == null ) return bool ; return level . int value ( ) >= s current level . int value ( ) ; }	is logging level logged.
protected void compute folder children ( file folder , boolean is included , string [ ] pkg name , array list v children , char [ ] [ ] inclusion patterns , char [ ] [ ] exclusion patterns ) throws java model exception { if ( is included ) { i pkg = get package fragment ( pkg name ) ; v children . add ( pkg ) ; } try { file [ ] members = folder . list files ( ) ; boolean has included = is included ; int length = members . length ; if ( length > num ) { java project java project = ( java project ) get java project ( ) ; string source level = java project . get option ( java core . compiler source , bool ) ; string compliance level = java project . get option ( java core . compiler compliance , bool ) ; for ( int i = num ; i < length ; i ++ ) { file member = members [ i ] ; string member name = member . get name ( ) ; if ( member . is directory ( ) ) { if ( util . is valid folder name for package ( member name , source level , compliance level ) ) { string [ ] new names = util . array concat ( pkg name , manager . intern ( member name ) ) ; boolean is member included = bool ; compute folder children ( member , is member included , new names , v children , inclusion patterns , exclusion patterns ) ; } } else { if ( ! has included && util . is valid compilation unit name ( member name , source level , compliance level ) ) { has included = bool ; i pkg = get package fragment ( pkg name ) ; v children . add ( pkg ) ; } } } } } catch ( illegal argument exception e ) { throw new java model exception ( e , i . element does not exist ) ; } catch ( core exception e ) { throw new java model exception ( e ) ; } }	starting at this folder , create package fragments and add the fragments that are not exclused to the collection of children .
public static string quote ( file input ) { return quote ( input . get absolute path ( ) ) ; }	quotes the absolute path of the given file iff it contains whitespace .
private void read from net ( ) throws ignite checked exception { try { in net buf . clear ( ) ; int read = ch . read ( in net buf ) ; if ( read == - num ) throw new ignite checked exception ( str ) ; } catch ( io e ) { throw new ignite checked exception ( str , e ) ; } }	read data from net buffer .
synchronized void clear ( ) { maps = new maps ( ) ; tombstones . clear ( ) ; ram bytes used current . set ( num ) ; if ( mgr != null ) { mgr . remove listener ( this ) ; mgr = null ; } }	called when this index is closed .
public synchronized void remove consumer ( image consumer ic ) { ics . remove element ( ic ) ; }	remove an imageconsumer from the list of consumers interested in data for this image .
public boolean is navigation at bottom ( ) { return ( m smallest width dp >= num || m in portrait ) ; }	should a navigation bar appear at the bottom of the screen in the current device configuration ? a navigation bar may appear on the right side of the screen in certain configurations .
private void update aperture ( int new value , long now ) { int previous = target aperture ; target aperture = new value ; target aperture = math . max ( min aperture , target aperture ) ; int max aperture = math . min ( this . max aperture , active sockets . size ( ) + active factories . size ( ) ) ; target aperture = math . min ( max aperture , target aperture ) ; last aperture refresh = now ; pendings . reset ( ( min pendings + max pendings ) / num ) ; if ( target aperture != previous ) { logger . debug ( str , pendings . value ( ) , target aperture , previous ) ; } }	update the aperture value and ensure its value stays in the right range .
public i build invocation ( object protocol key , i invocation ) throws config exception { objects . require non null ( invocation ) ; invocation = build invocation ( invocation ) ; lru cache < object , i > invocation cache = invocation cache ; if ( invocation cache != null ) { i old invocation ; old invocation = invocation cache . get ( protocol key ) ; if ( old invocation != null && ! old invocation . is modified ( ) ) { return old invocation ; } if ( invocation . get url ( ) < max url ) { invocation cache . put ( protocol key , invocation ) ; } } return invocation ; }	builds the invocation , saving its value keyed by the protocol key .
public web resource statistics compute mark ( web resource statistics wr statistics ) { float passed = wr statistics . get nb of passed ( ) ; if ( passed == - num ) { wr statistics . set raw mark ( float . value of ( - num ) ) ; return wr statistics ; } float failed = wr statistics . get nb of failed ( ) ; float need more info = wr statistics . get nb of nmi ( ) ; if ( failed == num && passed == num ) { wr statistics . set mark ( float . value of ( num ) ) ; return wr statistics ; } float ratio nmi = need more info / ( passed + failed + need more info ) ; float result = ( ( num - ratio nmi ) * passed / ( passed + failed ) + ratio nmi * need more info / ( passed + failed + need more info ) ) * num ; wr statistics . set mark ( result ) ; return wr statistics ; }	this method compute the mark of the audit . here is the algorithm formula : ( ( 1 - rationmi ) * passed / ( passed + failed ) + rationmi needmoreinfo / ( passed + failed + needmoreinfo ) ) * 100f where rationmi = needmoreinfo / ( passed + failed + needmoreinfo ).
public void test gcd first zero ( ) { byte a bytes [ ] = { num } ; byte b bytes [ ] = { num , num , num , num , - num , num , num , num , - num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , num , - num , num , num , num , - num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . gcd ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	gcd : the first number is zero.
public void test king capture ( ) throws chess parse error { position pos = io . read fen ( str ) ; pos . set white move ( bool ) ; list < string > str moves = get move list ( pos , bool ) ; assert equals ( num , str moves . size ( ) ) ; assert equals ( str , str moves . get ( num ) ) ; pos . set piece ( position . get square ( num , num ) , piece . wbishop ) ; pos . set piece ( position . get square ( num , num ) , piece . wpawn ) ; str moves = get move list ( pos , bool ) ; assert equals ( num , str moves . size ( ) ) ; assert equals ( str , str moves . get ( num ) ) ; pos . set piece ( position . get square ( num , num ) , piece . wpawn ) ; pos . set piece ( position . get square ( num , num ) , piece . wpawn ) ; str moves = get move list ( pos , bool ) ; assert equals ( num , str moves . size ( ) ) ; assert equals ( str , str moves . get ( num ) ) ; }	test that if king capture is possible , only a king capture move is returned in the move list .
public static list < object > validate and evaluate ( string view name , statement context statement context , list < expr node > expressions ) throws view parameter exception { list < object > results = new array list < object > ( ) ; int expression number = num ; stream type service stream type service = new stream type service impl ( statement context . get engine uri ( ) , bool ) ; for ( expr node expr : expressions ) { object result = validate and evaluate expr ( view name , statement context , expr , stream type service , expression number ) ; results . add ( result ) ; expression number ++ ; } return results ; }	validate the view parameter expressions and evaluate the expressions returning the result object .
@ not null public static string parse relative directory ( @ not null string s ) throws svn bind exception { s = s . trim ( ) ; int length = s . length ( ) ; string result ; if ( is unescaped quote ( s , length - num ) ) { int index = last unescaped index of ( s , length - num , str ) ; assert index ( s , index , str ) ; result = s . substring ( index + num , length - num ) ; } else { int index = last unescaped index of ( s , length , str ) ; assert index ( s , index , str ) ; result = s . substring ( index + num ) ; } return unescape ( result ) ; }	parses relative directory from externals definition ( in format starting from svn 1.
private string pick encoding ( input source input source ) { reader reader = input source . get character stream ( ) ; if ( reader != null ) { return character encoding ; } string encoding = input source . get encoding ( ) ; return encoding == null ? default encoding : encoding ; }	picks an encoding for an external entity.
@ override public string generate url ( category dataset dataset , int series , int category ) { string url = this . prefix ; comparable series key = dataset . get row key ( series ) ; comparable category key = dataset . get column key ( category ) ; boolean first parameter = ! url . contains ( str ) ; url += first parameter ? str : str ; try { url += this . series parameter name + str + url . encode ( series key . to string ( ) , str ) ; url += str + this . category parameter name + str + url . encode ( category key . to string ( ) , str ) ; } catch ( unsupported encoding exception ex ) { throw new runtime exception ( ex ) ; } return url ; }	generates a url for a particular item within a series .
public boolean is idle expire ( ) { if ( ! lifecycle . is active ( ) ) return bool ; long now = current time actual ( ) ; long idle expire = thread idle expire time . get ( ) ; int idle count = idle count . get ( ) ; if ( idle min < idle count ) { long next idle expire = now + idle timeout ; if ( idle max < idle count && idle min < idle max ) { thread idle expire time . compare and set ( idle expire , next idle expire ) ; return bool ; } else if ( idle expire < now && thread idle expire time . compare and set ( idle expire , next idle expire ) ) { return bool ; } } return bool ; }	returns true if the thread should expire instead of going to the idle state .
public void begin display ( display event event ) throws model control exception { identity subject model subject model = get subject model ( ) ; policy model model = ( policy model ) get model ( ) ; super . begin display ( event ) ; cc menu = ( cc ) get child ( filter type ) ; map supported entity types = model . get supported entity types ( realm name ) ; option list entity types = create option list ( supported entity types ) ; entity types . add ( num , str , str ) ; menu . set options ( entity types ) ; menu . set value ( str ) ; cc child = ( cc ) get child ( values multiple choice value ) ; child . restore state data ( ) ; option list selected = add remove model . get selected option list ( ) ; option list possible = helper . create option list ( model . get user sso ( ) , model . get user locale ( ) , this , get possible values ( subject model , realm name ) ) ; child . reset state data ( ) ; add remove model . set available option list ( possible ) ; }	sets the values to ui model .
private void decode64 ( byte buffer infile , long array pointer a ) { byte [ ] nbitplanes = new byte [ n03 ] ; byte [ ] tmagic = new byte [ num ] ; infile . get ( tmagic ) ; if ( tmagic [ num ] != code magic [ num ] || tmagic [ num ] != code magic [ num ] ) { throw new runtime exception ( str ) ; } this . nx = infile . get int ( ) ; this . ny = infile . get int ( ) ; this . scale = infile . get int ( ) ; long sumall = infile . get long ( ) ; infile . get ( nbitplanes ) ; dodecode64 ( infile , a , nbitplanes ) ; a . set ( num , sumall ) ; }	char * infile ; input file long * a ; address of output tiledimageoperation [ nx ] [ ny ] int * nx , * ny ; size of output tiledimageoperation int * scale ; scale factor for digitization.
private static void create script ( ) throws exception { class . for name ( str ) ; connection conn = driver manager . get connection ( str ) ; statement stat = conn . create statement ( ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . close ( ) ; conn . close ( ) ; }	create a script from a new database .
public static double cauchy ( ) { return math . tan ( math . pi * ( uniform ( ) - num ) ) ; }	returns a random real number from the cauchy distribution .
public void add job group to never delete ( string group ) { if ( group != null ) job groups to never delete . add ( group ) ; }	add the given group to the list of job groups that will never be deleted by this processor , even if a pre - processing - command to delete the group is encountered .
private web doc create layout ( web doc doc , m wf , int active node , mwf [ ] nodes , array list nodes id , int [ ] [ ] image map ) { body b = doc . get body ( ) ; b . add element ( print workflow ( active node , wf , nodes , nodes id , image map ) ) ; b . add element ( new hr ( ) ) ; b . add element ( print description ( active node , wf , nodes , nodes id ) ) ; b . add element ( new br ( ) ) ; b . add element ( print control panel ( active node , wf , nodes , nodes id ) ) ; return doc ; }	print the entire layout .
@ override public void request poll read ( ) { try { request loop ( ) ; } catch ( exception e ) { log . log ( level . warning , e . to string ( ) , e ) ; } }	wake a connection from a select / poll keepalive .
public multi match query builder field ( string field ) { fields . add ( field ) ; return this ; }	adds a field to run the multi match against .
void encode ( output stream os , boolean include h ) throws io { int q = params . q ; os . write ( get encoded ( f ) ) ; if ( params . basis type == ntru . basis type standard ) { integer polynomial f prime int = f prime . to integer polynomial ( ) ; for ( int i = num ; i < f prime int . coeffs . length ; i ++ ) { f prime int . coeffs [ i ] += q / num ; } os . write ( f prime int . to binary ( q ) ) ; } else { os . write ( get encoded ( f prime ) ) ; } if ( include h ) { os . write ( h . to binary ( q ) ) ; } }	writes the basis to an output stream.
private void signal no acks ( ) { lock . lock ( ) ; try { all acks rcv cond . signal all ( ) ; } finally { lock . unlock ( ) ; } }	signal that currenlty there are no more pending acks .
private static string array to string ( int [ ] array ) { string builder sb = new string builder ( ) ; boolean first = bool ; for ( int i : array ) { if ( first ) { first = bool ; } else { sb . append ( str ) ; } sb . append ( i ) ; } return sb . to string ( ) ; }	converts an array into a string.
public static byte [ ] copy ( byte [ ] source , byte [ ] target ) { int len = source . length ; if ( len > target . length ) { target = new byte [ len ] ; } system . arraycopy ( source , num , target , num , len ) ; return target ; }	copy the contents of the source array to the target array.
public double great circle distance ( location location ) { if ( location == null ) { throw new illegal argument exception ( logger . log message ( logger . error , str , str , str ) ) ; } double lat1 radians = math . to radians ( this . latitude ) ; double lon1 radians = math . to radians ( this . longitude ) ; double lat2 radians = math . to radians ( location . latitude ) ; double lon2 radians = math . to radians ( location . longitude ) ; if ( lat1 radians == lat2 radians && lon1 radians == lon2 radians ) { return num ; } double a = math . sin ( ( lat2 radians - lat1 radians ) / num ) ; double b = math . sin ( ( lon2 radians - lon1 radians ) / num ) ; double c = a * a + math . cos ( lat1 radians ) * math . cos ( lat2 radians ) * b * b ; double distance radians = num * math . asin ( math . sqrt ( c ) ) ; return double . is na n ( distance radians ) ? num : distance radians ; }	computes the angular distance of the great circle path between this location and a specified location.
private list < input split > parse manifest ( file system fs , path manifest path , job conf job ) throws io { list < input split > splits = null ; fs fp = fs . open ( manifest path ) ; json reader reader = new json reader ( new input stream reader ( fp , charsets . utf 8 ) ) ; reader . begin object ( ) ; while ( reader . has next ( ) ) { string name = reader . next name ( ) ; switch ( name ) { case version json key : job . set ( db . export format version , string . value of ( reader . next int ( ) ) ) ; break ; case entries json key : splits = read entries ( reader , job ) ; break ; default : log . info ( str + name ) ; reader . skip value ( ) ; break ; } } reader . end object ( ) ; if ( splits == null ) { return collections . empty list ( ) ; } return splits ; }	an example manifest file looks like { " name " : " dynamodb - export " , " version " : 3 , " entries " : [ { " url " : " s3 : / / path / to / object / 92dd1414 - a049 - 4c68 - 88fb - a23acd44907e " , " mandatory " : true } , { " url " : " s3 : / / path / to / object / ba3f3535 - 7aa1 - 4f97 - a530 - e72938bf4b76 " , " mandatory " : true } ] }.
@ override public final void read fully ( byte ba [ ] , int off , int len ) throws io { dis . read fully ( ba , off , len ) ; }	read bytes until the count is satisfied .
public void fire operator moved ( operator operator ) { list < operator > list = new linked list < > ( ) ; list . add ( operator ) ; fire operators moved ( list ) ; }	fire when an operator has been moved .
public void remove ( int i ) { individuals . remove ( i ) ; }	removes a single individual .
@ override public void modify variable id ( string old id , string new id ) { if ( base var . equals ( old id ) ) { base var = new id . replace ( str , str ) ; } }	replaces occurrences of the old variable identifier oldid with the new identifier newid .
public static string repeat ( string str , int count ) { final string builder result = new string builder ( str . length ( ) * count ) ; for ( int i = num ; i < count ; i ++ ) { result . append ( str ) ; } return result . to string ( ) ; }	repeats the specified substring a number of times .
private void wait for state change ( int max ttw ) throws mqtt exception { synchronized ( waiter ) { if ( ! donext ) { try { waiter . wait ( max ttw ) ; } catch ( interrupted exception e ) { log ( str ) ; e . print stack trace ( ) ; } if ( ex != null ) { throw ( mqtt exception ) ex ; } } donext = bool ; } }	wait for a maximum amount of time for a state change event to occur.
@ override public node pick node ( final inference graph g ) { tree cache . clear ( ) ; pair < list < node > , integer > best path = no path ; for ( node n : g . nodes ) { if ( ! collections . disjoint ( n . data , vars to solve ) ) { pair < list < node > , integer > path = compute tree to leafs ( n ) ; if ( path . snd < best path . snd ) { best path = path ; } } } if ( best path == no path ) { throw new node not found exception ( g ) ; } return best path . fst . head ; }	pick the leaf that minimize cost.
public add user fields ( ) { m attribute specs = new array list < attribute spec > ( ) ; }	constructs a new adduserfields.
private integer parse int ( string s , int flags ) { if ( convert color names ( flags ) ) { string c = descriptor . convert color name ( s ) ; if ( c != null ) { s = c ; } } try { if ( has leading zeros ( s ) ) { return null ; } else { return integer . decode ( s ) ; } } catch ( number format exception e ) { return null ; } }	we accept 0x and # prefixes .
private rectangle find bounds ( int ad wf id ) { for ( int i = num ; i < m nodes . size ( ) ; i ++ ) { wf node = ( wf ) m nodes . get ( i ) ; if ( node . get ad wf id ( ) == ad wf id ) return node . get bounds ( ) ; } return null ; }	get bounds of wf node icon.
protected void stop workers ( collection < worker thread > workers ) { if ( workers == null ) { workers = this . workers ; } final iterator < worker thread > iter = workers . iterator ( ) ; while ( iter . has next ( ) ) { final worker thread worker = iter . next ( ) ; if ( ( worker . get status ( ) & ( worker thread . s ended | worker thread . s ending ) ) == num ) { worker . signal shutdown ( ) ; running workers -- ; } } }	signals the given workers to end.
public array list < mapping > clone frame ( ) { if ( stack [ top ] == null ) return null ; array list < mapping > clone = new array list < mapping > ( ) ; for ( mapping map = top of frame ( ) ; map != null ; map = next ( ) ) { clone . add ( map ) ; } return clone ; }	return a copy of the current frame.
protected float calculate state transition percentage ( string name , boolean flapping ) { int flap interval = get flap interval ( name ) ; linked list < boolean > list = get flaps ( name ) ; float low weight = get flap low weight ( name ) ; float high weight = get flap high weight ( name ) ; float weight range = high weight - low weight ; float result = num ; for ( int i = list . size ( ) - num ; i >= num ; i -- ) { boolean this flap = list . get ( i ) ; if ( flapping != this flap ) { float weight = low weight + ( weight range * i / ( flap interval - num ) ) ; result += weight ; } } return result / flap interval ; }	calculate state transition percentage .
public static string mangle name ( method method , boolean is full ) { string buffer sb = new string buffer ( ) ; sb . append ( method . get name ( ) ) ; class [ ] params = method . get parameter types ( ) ; for ( int i = num ; i < params . length ; i ++ ) { sb . append ( str ) ; sb . append ( mangle class ( params [ i ] , is full ) ) ; } return sb . to string ( ) ; }	creates a unique mangled method name based on the method name and the method parameters .
private void save state ( ) { saved start offset = offset attribute . start offset ( ) ; saved end offset = offset attribute . end offset ( ) ; has illegal offsets = ( saved end offset - saved start offset != term attribute . length ( ) ) ; saved type = type attribute . type ( ) ; if ( saved buffer . length < term attribute . length ( ) ) { saved buffer = new char [ array util . oversize ( term attribute . length ( ) , character . bytes ) ] ; } system . arraycopy ( term attribute . buffer ( ) , num , saved buffer , num , term attribute . length ( ) ) ; iterator . text = saved buffer ; has saved state = bool ; }	saves the existing attribute states.
public string consume to ( string seq ) { int offset = queue . index of ( seq , pos ) ; if ( offset != - num ) { string consumed = queue . substring ( pos , offset ) ; pos += consumed . length ( ) ; return consumed ; } else { return remainder ( ) ; } }	pulls a string off the queue , up to but exclusive of the match sequence , or to the queue running out .
private void print out defined i ( list < string > defined i ) { list < string > ip list = new array list < > ( ) ; for ( string ip : defined i ) { if ( ip . index of ( str ) != - num ) { ip list . add ( str + ip ) ; } else { ip list . add ( str + ip ) ; } } collections . sort ( ip list ) ; for ( string ip : ip list ) { log . info ( ip ) ; } }	prints out the given list of defined ip addresses.
private void dispose codec ( io session session ) { dispose encoder ( session ) ; dispose decoder ( session ) ; dispose decoder out ( session ) ; }	dispose the encoder , decoder , and the callback for the decoded messages .
private static int transpositions ( final char sequence first , final char sequence second ) { int transpositions = num ; for ( int i = num ; i < first . length ( ) ; i ++ ) { if ( first . char at ( i ) != second . char at ( i ) ) { transpositions ++ ; } } return transpositions / num ; }	calculates the number of transposition between two strings .
@ override public object parse object ( final string source , final parse position pos ) { return parser . parse object ( source , pos ) ; }	uses the parser format instance .
@ override public default stream < time series collection > stream ( ) { return stream support . stream ( spliterator ( ) , bool ) ; }	stream the tsdata contents.
private manifest mod info register mod ( file file , manifest manifest ) { manifest mod info mod = load mod ( file , manifest ) ; if ( mod != null ) { if ( id map . contains key ( mod . get mod id ( ) ) ) { mod info mod2 = id map . get ( mod . get mod id ( ) ) ; duplicates . put ( mod . get mod id ( ) , mod ) ; duplicates . put ( mod . get mod id ( ) , mod2 ) ; log . error ( str , mod . get mod file ( ) , mod2 . get mod file ( ) ) ; } else { mod list . add ( mod ) ; id map . put ( mod . get mod id ( ) , mod ) ; } } return mod ; }	constructs and registers a mod .
protected d arrange nn ( block container container , d g2 ) { list blocks = container . get blocks ( ) ; block b = ( block ) blocks . get ( num ) ; d s = b . arrange ( g2 , rectangle constraint . none ) ; b . set bounds ( new d . double ( num , num , s . width , s . height ) ) ; return new d ( s . width , s . height ) ; }	arranges the blocks without any constraints.
public static boolean is content type ( string content type , message message ) { if ( content type == null ) { return message . get content type ( ) == null ; } else { return content type . equals ( message . get content type ( ) ) ; } }	check whether the content - type field of the properties section ( if present ) in the given message matches the provided string ( where null matches if there is no content type present .
private static x509 certificate generate certificate ( string dn , int days , string application uri , key pair keys , org . opcfoundation . ua . transport . security . key pair issuer keys , string ... host names ) throws general security exception , io { private key privkey = keys . get private ( ) ; public key public key = keys . get public ( ) ; return generate certificate ( dn , days , application uri , public key , privkey , issuer keys , host names ) ; }	create a x . 509 v3 certificate .
@ suppress warnings ( str ) public void handle button1 request ( request invocation event event ) throws model control exception { submit cycle = bool ; abstract audit model model = ( abstract audit model ) get model ( ) ; am ps = ( am ) get child ( property attribute ) ; string sub config name = ( string ) get page session attribute ( audit handler name ) ; try { map orig = model . get event handler attribute values ( sub config name ) ; map values = ps . get attribute values ( orig , bool , bool , model ) ; model . set event handler attribute values ( sub config name , values ) ; back to profile view bean ( ) ; } catch ( am e ) { set inline alert message ( type error , error message , e . get message ( ) ) ; forward to ( ) ; } }	handles next button request .
private string check all dependencies ( hash map < string , module descriptor > modlist ) { for ( module descriptor md : modlist . values ( ) ) { string res = check dependencies ( md , modlist ) ; if ( ! res . is empty ( ) ) { return res ; } } return str ; }	check that all dependencies are satisfied.
public void children removed ( bean context membership event bcme ) { for ( iterator it = bcme . iterator ( ) ; it . has next ( ) ; ) { find and undo ( it . next ( ) ) ; } }	beancontextmembership interface method . called by beancontext when children are being removed . unhooks itself from the objects that are being removed if they are contained within the frame .
public static void check directory is writeable ( @ not null file directory ) throws io { while ( ! directory . exists ( ) || ! directory . is directory ( ) ) { directory = directory . get parent file ( ) ; } if ( ! directory . can write ( ) ) { throw new io ( str + directory . get absolute path ( ) ) ; } }	find the first parent directory that exists and check if this directory is writeable .
public string to string ( ) { string builder s = new string builder ( ) ; boolean appended = bool ; if ( this . weeks != num || appended ) { appended = bool ; s . append ( this . weeks + str ) ; } if ( this . days != num || appended ) { appended = bool ; s . append ( this . days + str ) ; } if ( this . hours != num || appended ) { appended = bool ; s . append ( this . hours + str ) ; } if ( this . minutes != num || appended ) { appended = bool ; s . append ( this . minutes + str ) ; } if ( this . seconds != num || appended ) { appended = bool ; s . append ( this . seconds + str ) ; } if ( this . milliseconds != num || appended ) { appended = bool ; s . append ( this . milliseconds + str ) ; } return s . to string ( ) ; }	returns the textual description of the time value .
private synchronized void write object ( java . io . object output stream s ) throws io { s . default write object ( ) ; }	writeobject is called to save the state of the url to an objectoutputstream.
public void start entity ( string name ) throws org . xml . sax . sax { }	report the beginning of an entity.
public static boolean is java keyword ( string name ) { return tokens . contains ( name ) ; }	determines whether the given name is a java keyword.
protected string extract import url ( final matcher matcher ) { return matcher . group ( index url ) ; }	override this method to provide a custom way of extracting the imported resource url .
@ override public boolean equals ( object that ) { if ( this == that ) { return bool ; } if ( that == null ) { return bool ; } if ( get class ( ) != that . get class ( ) ) { return bool ; } collator other = ( collator ) that ; return ( ( strength == other . strength ) && ( decmp == other . decmp ) ) ; }	compares the equality of two collators .
public void run test ( ) throws throwable { document doc ; node list em list ; node em node ; character data em text ; node null child ; doc = ( document ) load ( str , bool ) ; em list = doc . get elements by tag name ( str ) ; em node = em list . item ( num ) ; em text = ( character data ) em node . get first child ( ) ; null child = em text . get first child ( ) ; assert null ( str , null child ) ; }	runs the test case .
type rename type as type ( type type ) { if ( type == null ) { return null ; } if ( type . get sort ( ) == type . object ) { string in = type . get internal name ( ) ; string new in = rename internal type ( in ) ; if ( new in != in ) { return type . get type ( str + new in + str ) ; } } else if ( type . get sort ( ) == type . array ) { string builder sb = new string builder ( ) ; for ( int n = type . get dimensions ( ) ; n > num ; n -- ) { sb . append ( str ) ; } sb . append ( rename type ( type . get element type ( ) ) ) ; return type . get type ( sb . to string ( ) ) ; } return type ; }	renames an object type , e.
public static void write file list ( xml xml output , string tag name , iterable < file > list values ) throws io { if ( list values != null ) { write file list ( xml output , tag name , list values . iterator ( ) ) ; } }	write a list of strings to document as elements with given tag name .
public d ( j parent ) { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dpolicyconstraints dialog .
@ pre authorize ( spring eval expressions . has auth system admin ) @ override public response entity < collection < string > > invalidate caches ( ) { final collection < string > cache names = cache manager . get cache names ( ) ; logger . info ( str , cache names ) ; cache names . for each ( null ) ; return response entity . ok ( cache names ) ; }	invalidates all caches for all tenants .
public static final void write byte array xml ( byte [ ] val , string name , xml serializer out ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; string builder sb = new string builder ( val . length * num ) ; for ( int i = num ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > num ; sb . append ( h >= num ? ( str + h - num ) : ( str + h ) ) ; h = b & num ; sb . append ( h >= num ? ( str + h - num ) : ( str + h ) ) ; } out . text ( sb . to string ( ) ) ; out . end tag ( null , str ) ; }	flatten a byte [ ] into an xmlserializer.
public static void write file ( final file destination , final list < string > contents ) throws io { final buffered writer bw = new buffered writer ( new file writer ( destination ) ) ; try { for ( string line : contents ) { bw . write ( line ) ; bw . new line ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }	write the strings to the file , one per line .
public void cancel requests by tag ( object tag , boolean may interrupt if running ) { if ( tag == null ) { return ; } for ( list < request handle > request list : request map . values ( ) ) { if ( request list != null ) { for ( request handle request handle : request list ) { if ( tag . equals ( request handle . get tag ( ) ) ) request handle . cancel ( may interrupt if running ) ; } } } }	allows you to cancel all requests currently in queue or running , by set tag , if passed tag is null , will not attempt to cancel any requests , if tag is null on requesthandle , it cannot be canceled by this call.
public static void draw snap horizontal margin ( view transform transform , d g , int x1 , int x2 , int y1 , string text , boolean text over ) { canvas c = new canvas ( ) ; font metrics fm = c . get font metrics ( s font ) ; g . set font ( s font ) ; int padding = transform . get swing dimension ( num ) ; d bounds = fm . get string bounds ( text , g ) ; int tw = ( int ) bounds . get width ( ) ; int offset = num * connection arrow size ; if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } int w = ( ( x2 - x1 ) - ( tw + num * padding ) ) / num ; if ( w <= padding ) { g . draw line ( x1 , y1 , x2 , y1 ) ; if ( text over ) { offset = - num * offset / num ; } g . draw string ( text , x1 + w + padding , y1 + offset ) ; } else { g . draw line ( x1 , y1 , x1 + w , y1 ) ; g . draw line ( x2 - w , y1 , x2 , y1 ) ; g . draw string ( text , x1 + w + padding , ( int ) ( y1 + ( bounds . get height ( ) / num ) ) ) ; } g . draw line ( x1 , y1 - connection arrow size , x1 , y1 + connection arrow size ) ; g . draw line ( x2 , y1 - connection arrow size , x2 , y1 + connection arrow size ) ; }	draw a snap horizontal margin indicator.
public static generic record subset record ( generic record record , schema subset schema ) { return subset record ( record , subset schema , null ) ; }	the subset of the original record that contains the values for the given subset schema .
static public void queue operation ( context context , operation info args ) { args . calculate scheduled time ( ) ; synchronized ( s work queue ) { s work queue . add ( args ) ; s work queue . notify ( ) ; } context . start service ( new intent ( context , async query service helper . class ) ) ; }	queues the operation for execution.
private static cell [ ] interpret ( string string ) { cell [ ] cells = new cell [ num ] ; for ( int i = num ; i < string . length ( ) ; i ++ ) { int dig = string . char at ( i ) - str ; int col = dig % num ; int row = dig / num ; cells [ i ] = new cell ( col , row ) ; } return cells ; }	interpret string of digits into cells .
public shape transform ( shape shape ) { d bounds = shape . get bounds2 d ( ) ; d center = new d . double ( bounds . get center x ( ) , bounds . get center y ( ) ) ; d new center = transform ( center ) ; double dx = new center . get x ( ) - center . get x ( ) ; double dy = new center . get y ( ) - center . get y ( ) ; affine transform at = affine transform . get translate instance ( dx , dy ) ; return at . create transformed shape ( shape ) ; }	return the supplied shape , translated to the coordinates that result from calling transform on its center.
public void list ( print writer out , int indent ) { for ( int i = num ; i < indent ; i ++ ) { out . print ( str ) ; } out . println ( this ) ; }	prints out a list , starting at the specified indentation , to the specified print writer .
private void init ( ) { set title ( str ) ; comp properties panel = competitive properties panel . create competitive properties panel ( network panel , competitive props panel type . create group ) ; tab logic . add ( comp properties panel ) ; layout panel = new main layout panel ( bool , this ) ; layout panel . set current layout ( competitive group . default layout ) ; tab layout . add ( layout panel ) ; tabbed pane . add tab ( str , tab logic ) ; tabbed pane . add tab ( str , layout panel ) ; set content pane ( tabbed pane ) ; action help action = new show help action ( comp properties panel . get help path ( ) ) ; add button ( new j ( help action ) ) ; }	initializes all components used in dialog .
public static revocation status check ( x509 certificate cert , x509 certificate issuer cert ) throws io , cert path validator exception { cert id cert id = null ; uri responder uri = null ; try { x509 cert impl cert impl = x509 cert impl . to impl ( cert ) ; responder uri = get responder uri ( cert impl ) ; if ( responder uri == null ) { throw new cert path validator exception ( str ) ; } cert id = new cert id ( issuer cert , cert impl . get serial number object ( ) ) ; } catch ( certificate exception | io e ) { throw new cert path validator exception ( str , e ) ; } ocsp ocsp response = check ( collections . singleton list ( cert id ) , responder uri , issuer cert , null , null , collections . < extension > empty list ( ) ) ; return ( revocation status ) ocsp response . get single response ( cert id ) ; }	obtains the revocation status of a certificate using ocsp using the most common defaults.
public static composite type for alpha composite ( alpha composite ac ) { switch ( ac . get rule ( ) ) { case alpha composite . clear : return clear ; case alpha composite . src : if ( ac . get alpha ( ) >= num ) { return src no ea ; } else { return src ; } case alpha composite . dst : return dst ; case alpha composite . src over : if ( ac . get alpha ( ) >= num ) { return src over no ea ; } else { return src over ; } case alpha composite . dst over : return dst over ; case alpha composite . src in : return src in ; case alpha composite . dst in : return dst in ; case alpha composite . src out : return src out ; case alpha composite . dst out : return dst out ; case alpha composite . src atop : return src atop ; case alpha composite . dst atop : return dst atop ; case alpha composite . xor : return alpha xor ; default : throw new internal error ( str ) ; } }	return a compositetype object for the specified alphacomposite rule .
public void remove tracking icon ( object tag ) { if ( tracking icons != null && tracking icons . remove ( tag ) ) { repaint ( ) ; } }	removes the specified tracking icon .
private list find phonemes ( ) { set set = new hash set ( ) ; for ( int i = num ; i < state machine . length ; i ++ ) { if ( state machine [ i ] instanceof final state ) { final state fstate = ( final state ) state machine [ i ] ; if ( fstate . phone list != null ) { for ( int j = num ; j < fstate . phone list . length ; j ++ ) { set . add ( fstate . phone list [ j ] ) ; } } } } return new array list ( set ) ; }	returns a list of all the phonemes used by the lts rules .
public static file remove parent ( file parent , file file ) { string absolute path = file . get absolute path ( ) ; string parent absolute path = parent . get absolute path ( ) ; string new path = absolute path . replace ( parent absolute path + str , str ) ; return new file ( new path ) ; }	convert a file into a relative path from a given parent.
public static boolean almost equal ( double a , double b , double delta ) { return math . abs ( a - b ) <= delta ; }	check whether two floating point values match with a given precision .
public void end element ( ) { nss . pop context ( ) ; }	ends the current element context and gets back to the parent context.
public void test fill biib ( ) { byte val = byte . max value ; byte d [ ] = new byte [ num ] ; arrays . fill ( d , num , d . length , val ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == val ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == val ) ; int result ; try { arrays . fill ( new byte [ num ] , num , num , ( byte ) num ) ; result = num ; } catch ( array index out of bounds exception e ) { result = num ; } catch ( illegal argument exception e ) { result = num ; } assert equals ( str , num , result ) ; try { arrays . fill ( new byte [ num ] , - num , num , ( byte ) num ) ; result = num ; } catch ( array index out of bounds exception e ) { result = num ; } catch ( illegal argument exception e ) { result = num ; } assert equals ( str , num , result ) ; try { arrays . fill ( new byte [ num ] , num , num , ( byte ) num ) ; result = num ; } catch ( array index out of bounds exception e ) { result = num ; } catch ( illegal argument exception e ) { result = num ; } assert equals ( str , num , result ) ; }	java . util . arrays # fill ( byte [ ] , int , int , byte ).
private json writer open ( int empty , string open bracket ) throws io { before value ( ) ; push ( empty ) ; out . write ( open bracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
private double calculate log ( double value ) { return math . log ( value ) / this . base log ; }	calculates the log of a given value .
@ override public boolean upload file ( string source , string dest ) { file input stream fis ; try { file file = new file ( source ) ; fis = new file input stream ( file ) ; m db . put file overwrite ( dest , fis , file . length ( ) , null ) ; fis . close ( ) ; return bool ; } catch ( dropbox unlinked exception e ) { log . d ( string . value of ( r . string . app name ) , str , e ) ; return bool ; } catch ( dropbox exception e ) { log . d ( string . value of ( r . string . app name ) , str , e ) ; return bool ; } catch ( file not found exception e ) { log . d ( string . value of ( r . string . app name ) , str , e ) ; return bool ; } catch ( io e ) { e . print stack trace ( ) ; return bool ; } }	uploads a file from source to the dropbox.
private file create zip file handle ( ) throws io { file zip file = file . create temp file ( str , str , tmp output folder . get root ( ) ) ; assert true ( zip file . delete ( ) ) ; return zip file ; }	create a file object to which we can safely zip a file .
public boolean remove handler ( string column name ) { if ( m overrides == null ) return bool ; else return m overrides . remove ( column name ) != null ; }	remove a custom data handler for a given column name.
public boolean is empty ( ) { return ( tag == null || tag . is empty ( ) ) && images . size ( ) == num ; }	determines whether the tag has no fields specified . < br > < p > if there are no images we return empty if either there is no vorbistag or if there is a vorbistag but it is empty.
@ suppress warnings ( str ) private void restore badges ( ) { bundle restored bundle = saved instance state ; if ( restored bundle != null ) { if ( restored bundle . contains key ( badge full text key ) ) { should show badge with nine plus = restored bundle . get boolean ( badge full text key ) ; } if ( restored bundle . contains key ( budges item bundle key ) ) { badge save instance hash map = ( hash map < integer , object > ) saved instance state . get serializable ( budges item bundle key ) ; if ( badge save instance hash map != null ) { for ( integer integer : badge save instance hash map . key set ( ) ) { badge helper . force show badge ( badge list . get ( integer ) , ( badge item ) badge save instance hash map . get ( integer ) , should show badge with nine plus ) ; } } } } }	restore available badges from saveinstance.
public void touch ( ) { touch = system . current time millis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }	touch the worker if you have a http connection that needs to wait .
public catalog entry ( string name , vector args ) throws catalog exception { integer i type = ( integer ) entry types . get ( name ) ; if ( i type == null ) { throw new catalog exception ( catalog exception . invalid entry type ) ; } int type = i type . int value ( ) ; try { integer i args = ( integer ) entry args . get ( type ) ; if ( i args . int value ( ) != args . size ( ) ) { throw new catalog exception ( catalog exception . invalid entry ) ; } } catch ( array index out of bounds exception e ) { throw new catalog exception ( catalog exception . invalid entry type ) ; } entry type = type ; this . args = args ; }	construct a catalog entry of the specified type .
public void add msg waiting ( mwi type type , int count , mwi profile profile , boolean store message ) { if ( count > num ) { count = num ; } messages . add ( new msg waiting ( type , count , profile , store message ) ) ; }	adds a message waiting .
private void push stack ( int new top ) { if ( stack size == stack . length ) { int [ ] new stack = new int [ stack size * num ] ; int [ ] new path indices = new int [ stack size * num ] ; string [ ] new path names = new string [ stack size * num ] ; system . arraycopy ( stack , num , new stack , num , stack size ) ; system . arraycopy ( path indices , num , new path indices , num , stack size ) ; system . arraycopy ( path names , num , new path names , num , stack size ) ; stack = new stack ; path indices = new path indices ; path names = new path names ; } stack [ stack size ++ ] = new top ; }	push a new scope on top of the scope stack.
private static void log hierarchy ( string prefix , class loader class loader ) { if ( ! is diagnostics enabled ( ) ) { return ; } class loader system class loader ; if ( class loader != null ) { final string class loader string = class loader . to string ( ) ; log diagnostic ( prefix + object id ( class loader ) + str + class loader string + str ) ; } try { system class loader = class loader . get system class loader ( ) ; } catch ( security exception ex ) { log diagnostic ( prefix + str ) ; return ; } if ( class loader != null ) { string buffer buf = new string buffer ( prefix + str ) ; for ( ; ; ) { buf . append ( object id ( class loader ) ) ; if ( class loader == system class loader ) { buf . append ( str ) ; } try { class loader = class loader . get parent ( ) ; } catch ( security exception ex ) { buf . append ( str ) ; break ; } buf . append ( str ) ; if ( class loader == null ) { buf . append ( str ) ; break ; } } log diagnostic ( buf . to string ( ) ) ; } }	logs diagnostic messages about the given classloader and it ' s hierarchy.
public void add gossip member ( gossip member member ) { gossip members . add ( member ) ; }	add a gossip member to the list of members to start with .
public static collection < string > log files ( ) { collection < string > res = new array list < > ( file appenders . size ( ) ) ; for ( file appender a : file appenders ) res . add ( a . get file ( ) ) ; return res ; }	gets files for all registered file appenders .
public boolean is case sensitive ( ) { return m case sensitive box . is selected ( ) ; }	returns the case sensitive search switch .
public boolean is namespace node ( node n ) { if ( node . attribute node == n . get node type ( ) ) { string attr name = n . get node name ( ) ; return ( attr name . starts with ( str ) || attr name . equals ( str ) ) ; } return bool ; }	test whether the given node is a namespace decl node.
@ override public int hash code ( ) { int hash = type . hash code ( ) ; if ( name != null ) hash ^= name . hash code ( ) ; if ( actions != null ) hash ^= actions . hash code ( ) ; return hash ; }	returns the hash code value for this object .
public sub config model impl ( http servlet request req , string service name , string parent id , map map ) throws am { super ( req , map ) ; this . service name = service name ; this . parent id = parent id ; sub config meta = new sub config meta ( service name , this ) ; sub config meta . set parent id ( parent id ) ; display name = sub config meta . get parent display name ( ) ; }	creates a simple model using default resource bundle .
@ override public boolean equals ( object obj ) { if ( ! ( obj instanceof d ) ) { return bool ; } d that = ( d ) obj ; return arrays . equals ( this . coefficients , that . coefficients ) ; }	tests this function for equality with an arbitrary object .
public static int convert to color int ( string a , string r , string g , string b , boolean use alpha ) { int alpha = use alpha ? integer . parse int ( a , num ) : num ; int red = integer . parse int ( r , num ) ; int green = integer . parse int ( g , num ) ; int blue = integer . parse int ( b , num ) ; return color . argb ( use alpha ? alpha : - num , red , green , blue ) ; }	concerts a string color ( # ff882465 ) to an int color.
@ override public void on action ( ) { on action ( action type . pick ) ; }	perform the default action .
public abstract binary traversal ( i < t > node ) { if ( node == null ) { throw new null pointer exception ( str ) ; } stack . add ( new moment ( node , initial phase ( ) ) ) ; advance ( ) ; }	start the traversal at the given node .
@ override public void end element ( string uri , string local name , string q name ) throws sax { if ( q name . equals ( tag root ) ) { } else if ( q name . equals ( tag group ) || q name . equals ( tag property ) ) { settings item item = item stack . remove ( item stack . size ( ) - num ) ; settings items . put ( item . get key ( ) , item ) ; } else { throw new sax ( str + local name ) ; } }	xml parser : closing xml tag .
public void cancel all ( ) { endpoint . cancel all ( ) ; }	cancel all observer relations that this server has established with this ' realtion ' s endpoint .
@ override public double value ( int att index ) { int index = locate index ( att index ) ; if ( ( index >= num ) && ( m [ index ] == att index ) ) { return m [ index ] ; } else { return num ; } }	returns an instance ' s attribute value in internal format .
public synchronized string find value ( string k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= num ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= num ; ) { if ( k . equals ignore case ( keys [ i ] ) ) return values [ i ] ; } return null ; }	find the value that corresponds to this key.
public static byte [ ] decode ( string input ) throws parse exception { if ( input . length ( ) == num ) { return new byte [ num ] ; } byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = num ; i < input . length ( ) ; ++ i ) { char c = input . char at ( i ) ; int digit = c < num ? indexes [ c ] : - num ; if ( digit < num ) { throw new parse exception ( str + c + str + i , i ) ; } input58 [ i ] = ( byte ) digit ; } int zeros = num ; while ( zeros < input58 . length && input58 [ zeros ] == num ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int output start = decoded . length ; for ( int input start = zeros ; input start < input58 . length ; ) { decoded [ -- output start ] = divmod ( input58 , input start , num , num ) ; if ( input58 [ input start ] == num ) { ++ input start ; } } while ( output start < decoded . length && decoded [ output start ] == num ) { ++ output start ; } return arrays . copy of range ( decoded , output start - zeros , decoded . length ) ; }	decodes the given base58 string into the original data bytes .
template sub pattern association ( elem template template , step pattern pattern , string pat ) { m pattern = pat ; m template = template ; m step pattern = pattern ; m target string = m step pattern . get target string ( ) ; m wild = m target string . equals ( str ) ; }	construct a match pattern from a pattern and template .
public boolean delete ( ) throws io { if ( closed . compare and set ( bool , bool ) ) { close ( bool ) ; boolean success = allocated nodes list . delete ( ) ; success &= nio file . delete ( ) ; return success ; } return bool ; }	closes the btree and then deletes its data files .
public static boolean has no prefix ( final annotated type mirror anno type ) { if ( anno type == null ) { return bool ; } for ( annotation mirror mirror : anno type . get annotations ( ) ) { if ( ! has no prefix ( mirror ) ) { return bool ; } } return bool ; }	checks to see if an annotated type has no prefix.
public static void try format satisfiability ( string format ) throws illegal format exception { @ suppress warnings ( str ) string unused = string . format ( format , ( object [ ] ) null ) ; }	throws an exception if the format is not syntactically valid .
public static ignite logger logger ( grid kernal context ctx , atomic reference < ignite logger > log ref , class < ? > cls ) { ignite logger log = log ref . get ( ) ; if ( log == null ) { log ref . compare and set ( null , ctx . log ( cls ) ) ; log = log ref . get ( ) ; } return log ; }	initializes logger into / from log reference passed in .
public byte receive one byte ( ) { log . d ( tag , str ) ; try { acquire lock ( ) ; m server socket . receive ( m receive packet ) ; log . d ( tag , str + ( num + m receive packet . get data ( ) [ num ] ) ) ; return m receive packet . get data ( ) [ num ] ; } catch ( io e ) { e . print stack trace ( ) ; } return byte . min value ; }	receive one byte from the port and convert it into string.
public static list < constraint violation > check ( resource resource , progress monitor monitor ) { return check ( resource , spin . constraint , null , monitor ) ; }	checks all spin : constraints for a given resource .
public static boolean is valid imdb id ( string imdb id ) { if ( string utils . is empty ( imdb id ) ) { return bool ; } return imdb id . matches ( str ) ; }	checks if is valid imdb id .
protected void show recorded video ( ) { string abs path = m current video file . get absolute path ( ) ; intent intent = new intent ( this , player activity . class ) ; intent . put extra ( player activity . extra video path , abs path ) ; start activity ( intent ) ; m current video file = null ; }	move to the activity where we show the recorded video.
private void write ( coordinate [ ] coords , int level , string buffer buf ) { start line ( str , level , buf ) ; boolean is new line = bool ; for ( int i = num ; i < coords . length ; i ++ ) { if ( i > num ) { buf . append ( tuple separator ) ; } if ( is new line ) { start line ( str , level , buf ) ; is new line = bool ; } write ( coords [ i ] , buf ) ; if ( ( i + num ) % max coordinates per line == num && i < coords . length - num ) { buf . append ( str ) ; is new line = bool ; } } buf . append ( str ) ; }	takes a list of coordinates and converts it to kml.
protected static boolean is intended exception ( exception e , class < ? > clazz ) { final string message = e . get message ( ) ; return ( ! text utils . is empty ( message ) && message . starts with ( clazz . get name ( ) ) ) ; }	checks if the exception is one of the intended server side exception that has been thrown over the aidl layer .
public static void swap pivot ( d source , long diag , d s , d t ) { long swap row = diag ; long swap col = diag ; double max value = math . abs ( source . get double ( diag , diag ) ) ; long rows = source . get row count ( ) ; long cols = source . get column count ( ) ; double abs = num ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs = math . abs ( source . get double ( row , col ) ) ; if ( abs > max value ) { max value = abs ; swap row = row ; swap col = col ; } } } if ( swap row != diag ) { swap rows ( source , swap row , diag ) ; swap rows ( t , swap row , diag ) ; } if ( swap col != diag ) { swap cols ( source , swap col , diag ) ; swap cols ( s , swap col , diag ) ; } }	swap the matrices so that the largest value is on the pivot.
public boolean can popup overlap task bar ( ) { boolean result = bool ; try { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check permission ( security constants . awt . set window always on top permission ) ; } } catch ( security exception se ) { result = bool ; } return result ; }	returns whether popup is allowed to be shown above the task bar.
public job create job for create cluster ( string activiti xml classpath resource name , list < parameter > parameters ) throws exception { return create job for create cluster ( activiti xml classpath resource name , parameters , null ) ; }	creates a job based on the specified activiti xml classpath resource location and defines a emr cluster definition .
public static list < string > find main classes ( file root dir ) throws io { list < string > ret = new array list < > ( ) ; if ( ! root dir . exists ( ) ) { return ret ; } if ( ! root dir . is directory ( ) ) { throw new illegal argument exception ( string . format ( str , root dir . get path ( ) ) ) ; } find classes ( ret , root dir , root dir . get absolute path ( ) + str ) ; return ret ; }	find all classes below a certain directory which contain main ( ) classes.
private static string validate xml ( string string ) throws io { for ( int i = num ; i < string . length ( ) ; i ++ ) { char ch = string . char at ( i ) ; if ( ! ( ch == num || ch == num || ch == num || ch >= num ) ) throw new io ( str + integer . to string ( ch ) + str ) ; } return string ; }	validates whether the given string only contains valid xml characters .
public void read values ( ) { read values ( bool ) ; }	read values from settings.
protected static boolean is access compatible with instant run ( int access ) { return ( ( access & opcodes . acc abstract ) == num ) && ( ( access & opcodes . acc bridge ) == num ) ; }	defines when a method access flags are compatible with instantrun technology.
protected as ( as [ ] array ) { for ( int i = num ; i != array . length ; i ++ ) { seq . add element ( array [ i ] ) ; } }	create a sequence containing a vector of objects .
public threaded listener manager ( executor service pool ) { manager number = manager count . get and increment ( ) ; this . pool = pool ; }	configures with specified thread pool.
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; if ( choice limits . length != choice formats . length ) { throw new invalid object exception ( str ) ; } }	after reading an object from the input stream , do a simple verification to maintain class invariants .
private void compute offset segment ( line segment seg , int side , double distance , line segment offset ) { int side sign = side == position . left ? num : - num ; double dx = seg . p1 . x - seg . p0 . x ; double dy = seg . p1 . y - seg . p0 . y ; double len = math . sqrt ( dx * dx + dy * dy ) ; double ux = side sign * distance * dx / len ; double uy = side sign * distance * dy / len ; offset . p0 . x = seg . p0 . x - uy ; offset . p0 . y = seg . p0 . y + ux ; offset . p1 . x = seg . p1 . x - uy ; offset . p1 . y = seg . p1 . y + ux ; }	compute an offset segment for an input segment on a given side and at a given distance.
@ suppress warnings ( str ) public synchronized e element at ( int location ) { if ( location < element count ) { return ( e ) element data [ location ] ; } throw array index out of bounds exception ( location , element count ) ; }	returns the element at the specified location in this vector .
private list < s > create qo s ( json object qos settings ) { list < s > rules = new array list < > ( ) ; if ( qos settings . contains key ( json field rules ) ) { json object json rules = qos settings . get json object ( json field rules ) ; for ( string url pattern reg exp : json rules . field names ( ) ) { log . debug ( str + url pattern reg exp ) ; json object json rule = json rules . get json object ( url pattern reg exp ) ; pattern url pattern = pattern . compile ( url pattern reg exp ) ; s rule = new s ( url pattern ) ; boolean add rule = bool ; if ( json rule . contains key ( str ) ) { add rule = bool ; rule . set reject ( json rule . get double ( str ) ) ; } if ( json rule . contains key ( str ) ) { add rule = bool ; rule . set warn ( json rule . get double ( str ) ) ; } if ( add rule ) { rules . add ( rule ) ; } else { log . warn ( str , url pattern reg exp ) ; } } } return rules ; }	creates the qos rule objects from the given jsonobject and returns them in a list .
private static final byte [ ] to octets ( int identifier , string text ) { byte [ ] s = text . get bytes ( standard charsets . utf 8 ) ; byte [ ] base = octet utils . to octets ( attribute type . vendor specific , identifier ) ; int max text space = attribute . max attribute length - base . length ; byte [ ] octets ; if ( s . length > max text space ) { octets = new byte [ attribute . max attribute length ] ; system . arraycopy ( s , num , octets , base . length , attribute . max attribute length - base . length ) ; } else { octets = new byte [ base . length + s . length ] ; system . arraycopy ( s , num , octets , base . length , s . length ) ; } system . arraycopy ( base , num , octets , num , base . length ) ; octets [ num ] = ( byte ) octets . length ; return octets ; }	custom implementation of tooctets to ensure a string value too long will be truncated properly in view of the space needed by the type , length , and identifier .
private double format double value ( double value , int places ) { big decimal bd = new big decimal ( value ) ; bd = bd . set scale ( places , rounding mode . half up ) ; return bd . double value ( ) ; }	this function returns decimals value for a double.
@ override public void flush ( ) throws io { out . flush ( ) ; }	flush all buffered data to the underlying output stream .
static boolean is c ( string value , int max length ) { if ( value == null ) return bool ; if ( value . length ( ) >= max length ) return bool ; return bool ; }	validate the c - octet string .
public d create proper bounds ( double x1 , double y1 , double x2 , double y2 ) { double x = math . min ( x1 , x2 ) ; double y = math . min ( y1 , y2 ) ; double w = math . abs ( x1 - x2 ) ; double h = math . abs ( y1 - y2 ) ; return new d . double ( x , y , w , h ) ; }	create a bounding rectangle given the four coordinates , where the upper left corner of the rectangle is the minimum x , y values and the width and height are the difference between xs and ys .
public void add clear graph data button ( ) { j clear button = new j ( str ) ; clear button . set action ( raster plot actions . get clear graph action ( this ) ) ; button panel . add ( clear button ) ; }	add button for clearing graph data .
public static float normalized levenshtein distance ( string s , string t ) { float d = levenshtein distance ( s , t ) ; int max = math . max ( s . length ( ) , t . length ( ) ) ; return d / ( float ) max ; }	from https : / / en.
private void create file ( int number , string extention ) { for ( int i = num ; i < number ; i ++ ) { try { buffered writer output = new buffered writer ( new file writer ( new file ( text input folder + str + string . value of ( i ) + extention ) ) ) ; try { output . write ( str ) ; output . write ( string . value of ( i ) ) ; } finally { output . close ( ) ; } } catch ( io e ) { e . print stack trace ( ) ; } } }	this private method just creates a number of files with a specific extension .
public boolean is animal ( ) { return type string . contains ( suffix animal ) ; }	determine if the expression is an animal .
public static string unify line separators ( string s , string ls ) { if ( s == null ) { return null ; } if ( ls == null ) { ls = system . get property ( str ) ; } if ( ! ( ls . equals ( str ) || ls . equals ( str ) || ls . equals ( str ) ) ) { throw new illegal argument exception ( str ) ; } int length = s . length ( ) ; string builder buffer = new string builder ( length ) ; for ( int i = num ; i < length ; i ++ ) { if ( s . char at ( i ) == str ) { if ( ( i + num ) < length && s . char at ( i + num ) == str ) { i ++ ; } buffer . append ( ls ) ; } else if ( s . char at ( i ) == str ) { buffer . append ( ls ) ; } else { buffer . append ( s . char at ( i ) ) ; } } return buffer . to string ( ) ; }	parses the given string and replaces all occurrences of ' \ n ' , ' \ r ' and ' \ r \ n ' with the given line separator .
public void add notification ( ping notification notification ) { notifications . add ( notification ) ; }	adds a ping notification to the current list .
public list < datastore > create nfs datastore ( cluster compute resource cluster , file share rest rep file system , file system export param export , uri datacenter id , string datastore name ) { add nfs datastore tag ( file system , export , datacenter id , datastore name ) ; list < datastore > datastores = lists . new array list ( ) ; string file server = string utils . substring before ( export . get mount point ( ) , str ) ; string mount path = string utils . substring after ( export . get mount point ( ) , str ) ; for ( host system host : cluster . get hosts ( ) ) { datastores . add ( execute ( new create nfs datastore ( host , file server , mount path , datastore name ) ) ) ; add affected resource ( file system ) ; execution utils . clear rollback ( ) ; } return datastores ; }	creates an nfs datastore for the hosts in the cluster.
private void check size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + num ; } final string [ ] temp = items ; items = new string [ max size ] ; system . arraycopy ( temp , num , items , num , old size ) ; increment size = increment size ( increment size ) ; } }	check the size of the array and increase if needed.
public album ( context context , uri media uri ) { super ( ) ; media . add ( num , new media ( context , media uri ) ) ; set current photo index ( num ) ; }	used for open an image from an unknown content storage.
static void check internal name ( final string name , final int start , final int end , final string msg ) { int max = end == - num ? name . length ( ) : end ; try { int begin = start ; int slash ; do { slash = name . index of ( str , begin + num ) ; if ( slash == - num || slash > max ) { slash = max ; } check identifier ( name , begin , slash , null ) ; begin = slash + num ; } while ( slash != max ) ; } catch ( illegal argument exception unused ) { throw new illegal argument exception ( str + msg + str + name ) ; } }	checks that the given substring is a valid internal class name .
protected void initialize task done ( set < task image container > tasks , optional < runnable > runnable when done ) { set < capture session > session set = new hash set < > ( ) ; map < capture session , integer > session task count = new hash map < > ( ) ; for ( task image container task : tasks ) { session set . add ( task . m session ) ; integer current count = session task count . get ( task . m session ) ; if ( current count == null ) { session task count . put ( task . m session , num ) ; } else { session task count . put ( task . m session , current count + num ) ; } } synchronized ( m shadow task map ) { for ( capture session capture session : session set ) { block signal protocol protocol = new block signal protocol ( ) ; protocol . set count ( session task count . get ( capture session ) ) ; final image shadow task shadow task ; shadow task = new image shadow task ( protocol , capture session , runnable when done ) ; m shadow task map . put ( capture session , shadow task ) ; m processing task consumer . enqueue task ( shadow task ) ; } } }	for a given set of starting tasks , initialize the associated sessions with a proper blocking semaphore and value of number of tasks to be run.
public static string unquote ( string name ) { return is quoted ( name ) ? name . substring ( num , name . length ( ) - num ) : name ; }	return the unquoted version of name ( stripping the start and end ' ` ' characters if present ) .
public boolean has leader ( string player name ) { return ( leader != null ) && leader . equals ( player name ) ; }	is the specified player the leader of this group ?.
synchronized void redo ( rt editor ) { stack < operation > redo stack = get redo stack ( editor ) ; if ( ! redo stack . empty ( ) ) { stack < operation > undo stack = get undo stack ( editor ) ; operation op = redo stack . pop ( ) ; push ( op , undo stack ) ; op . redo ( editor ) ; while ( ! redo stack . empty ( ) && op . can merge ( redo stack . peek ( ) ) ) { op = redo stack . pop ( ) ; push ( op , undo stack ) ; op . redo ( editor ) ; } } }	re - do the last undone operation for a specific rich text editor.
private static < t > t report join ( object r ) { if ( r instanceof alt result ) { throwable x ; if ( ( x = ( ( alt result ) r ) . ex ) == null ) return null ; if ( x instanceof cancellation exception ) throw ( cancellation exception ) x ; if ( x instanceof completion exception ) throw ( completion exception ) x ; throw new completion exception ( x ) ; } @ suppress warnings ( str ) t t = ( t ) r ; return t ; }	decodes outcome to return result or throw unchecked exception .
public int write ( final protein protein ) throws io { check entry hierarchy ( ) ; if ( entry hierarchy != null ) { for ( protein xref xref : protein . get cross references ( ) ) { final simple protein simple protein = simple protein . value of ( protein , xref , entry hierarchy ) ; if ( simple protein != null ) { final simple hash model = build model map ( simple protein , entry hierarchy ) ; writer writer = null ; try { final template temp = free marker config . get template ( free marker template ) ; check temp directory ( temp directory ) ; if ( ! temp directory . ends with ( file . separator ) ) { temp directory = temp directory + file . separator ; } url friendly id generator gen = url friendly id generator . get instance ( ) ; string url friendly id = gen . generate ( xref . get identifier ( ) ) ; final path new result file = paths . get ( temp directory + url friendly id + str ) ; result files . add ( new result file ) ; writer = files . new buffered writer ( new result file , character set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( template exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return num ; }	writes out protein view to an zipped and compressed html file .
public void test casts ( ) { string sql begin = str ; string [ ] [ ] sql tests = new string [ ] [ ] { { str , str } , { str , str } , { str , str } , { str , str } , { str , str } , { str , str } , { str , str } } ; string sql end = str ; string buffer sql = new string buffer ( sql begin ) ; string buffer sqle = new string buffer ( sql begin ) ; for ( int i = num ; i < sql tests . length ; i ++ ) { if ( i > num ) { sql . append ( str ) ; sqle . append ( str ) ; } sql . append ( sql tests [ i ] [ num ] ) ; sqle . append ( sql tests [ i ] [ num ] ) ; } sql . append ( sql end ) ; sqle . append ( sql end ) ; string [ ] r = convert . convert ( sql . to string ( ) ) ; assert equals ( sqle . to string ( ) , r [ num ] ) ; }	test bf [ 1824256 ] convert sql casts.
public void write into sptkl ( string sptk file name ) throws io { le lf0 data = new le ( new buffered output stream ( new file output stream ( sptk file name ) ) ) ; for ( int i = num ; i < this . contour . length ; i ++ ) { double f0 val = contour [ i ] ; if ( contour [ i ] == num ) { lf0 data . write float ( negative maximum ) ; } else { lf0 data . write float ( ( float ) math . log ( contour [ i ] ) ) ; } } lf0 data . flush ( ) ; lf0 data . close ( ) ; }	write contour into a lf0 file in sptk format.
public static thread start ( long timeout ) { return start ( thread . current thread ( ) , timeout ) ; }	start monitoring the current thread .
public static element find ( node parent , string name ) { node list list = parent . get child nodes ( ) ; for ( int i = num ; i < list . get length ( ) ; i ++ ) { node n = list . item ( i ) ; if ( n instanceof element ) { element e = ( element ) n ; if ( name . equals ( e . get attribute ( str ) ) ) { return e ; } } element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }	find an element by its " id " attribute ; null if no element is found .
public static re mk star ( re x ) { if ( x . equals ( epsilon ) || x . equals ( empty ) ) { return epsilon ; } re res = new re ( re op . star ) ; res . unary arg = x ; return res ; }	construct a regular expression matching the kleene closure of the language matched by the argument regular expression .
public void remove ( final object element ) { set old selection = new hash set ( selection ) ; boolean rv = selection . remove ( element ) ; if ( rv ) { fire selection changed ( old selection , selection ) ; } old selection = null ; }	remove the specified element from the selection .
@ override public void mouse clicked ( mouse event evt ) { delegate . mouse moved ( evt ) ; }	pass mouseevent straight through to delegate.
public void printf ( locale locale , string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	prints a formatted string to this output stream , using the specified locale , format string , and arguments , and then flushes this output stream .
public void transform ( source xml source , result output target ) throws transformer exception { transform ( xml source , output target , bool ) ; }	process the source tree to the output result .
public void test sorts attributes before elements ( ) throws exception { xpp dom dom1 = xpp factory . build dom ( str ) ; xpp dom dom2 = xpp factory . build dom ( str ) ; assert equals ( - num , comparator . compare ( dom1 , dom2 ) ) ; assert equals ( str , xpath . get ( ) ) ; assert equals ( num , comparator . compare ( dom2 , dom1 ) ) ; assert equals ( str , xpath . get ( ) ) ; }	tests comparison sorts attributes before elements .
public void add suffix ( dalv insn insn ) { suffix . add ( insn ) ; }	adds an instruction to the output suffix .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options.
private void close selector ( ) { if ( selector . is open ( ) ) { if ( log . is debug enabled ( ) ) log . debug ( str ) ; for ( selection key key : selector . keys ( ) ) u . close ( key . channel ( ) , log ) ; if ( log . is debug enabled ( ) ) log . debug ( str ) ; u . close ( selector , log ) ; } }	close selector if needed .
public static number sub ( number a , number b ) { if ( is floating point ( a ) || is floating point ( b ) ) { return a . double value ( ) - b . double value ( ) ; } else { return a . long value ( ) - b . long value ( ) ; } }	returns the value of subtracting the first from the second number .
public builder required attributes ( final string ... name or oi ) { return required attributes ( arrays . as list ( name or oi ) ) ; }	adds the provided required attributes .
private void show history dialog ( ) { jb commands list = new jb ( history utils . get commands from history ( ) ) ; commands list . set cell renderer ( new history list cell renderer ( ) ) ; commands list . set empty text ( str ) ; commands list . set selection mode ( list selection model . single selection ) ; string [ ] buttons = { str , str } ; int result = j . show option dialog ( tool window content , commands list , str , j . yes no cancel option , j . plain message , null , buttons , buttons [ num ] ) ; if ( result == num ) { update ui from command ( ( command ) commands list . get selected value ( ) ) ; } }	shows up history dialog.
public int size ( ) { return count . get ( ) ; }	returns the number of elements in this queue .
protected static byte [ ] read ( input stream is ) throws io { final boolean close = bool ; byte array output stream baos = new byte array output stream ( ) ; try { int i ; while ( ( i = is . read ( ) ) != - num ) { baos . write ( i ) ; } } finally { try { if ( close ) { is . close ( ) ; } baos . close ( ) ; } catch ( exception ex ) { log . warn ( str + ex , ex ) ; } } return baos . to byte array ( ) ; }	read a stream into a byte [ ].
public static < t > streamable < t > from publisher ( final publisher < ? extends t > publisher ) { objects . require non null ( publisher ) ; final seq subscriber < t > sub = seq subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return from stream ( sub . stream ( ) ) ; }	construct a lazyfuturestream from an publisher.
public protobuf connection ( listener < message type > handler , message type prototype , int max message size , int timeout millis ) { this . handler = handler ; this . prototype = prototype ; this . max message size = math . min ( max message size , integer . max value - num ) ; set timeout enabled ( bool ) ; set socket timeout ( timeout millis ) ; }	creates a new protobuf handler .
private response < bitmap > do parse ( network response response ) { byte [ ] data = response . data ; bitmap factory . options decode options = new bitmap factory . options ( ) ; bitmap bitmap = null ; if ( m max width == num && m max height == num ) { decode options . in preferred config = m decode config ; bitmap = bitmap factory . decode byte array ( data , num , data . length , decode options ) ; } else { decode options . in just decode bounds = bool ; bitmap factory . decode byte array ( data , num , data . length , decode options ) ; int actual width = decode options . out width ; int actual height = decode options . out height ; int desired width = get resized dimension ( m max width , m max height , actual width , actual height , m scale type ) ; int desired height = get resized dimension ( m max height , m max width , actual height , actual width , m scale type ) ; decode options . in just decode bounds = bool ; decode options . in sample size = find best sample size ( actual width , actual height , desired width , desired height ) ; bitmap temp bitmap = bitmap factory . decode byte array ( data , num , data . length , decode options ) ; if ( temp bitmap != null && ( temp bitmap . get width ( ) > desired width || temp bitmap . get height ( ) > desired height ) ) { bitmap = bitmap . create scaled bitmap ( temp bitmap , desired width , desired height , bool ) ; temp bitmap . recycle ( ) ; } else { bitmap = temp bitmap ; } } if ( bitmap == null ) { return response . error ( new parse error ( response ) ) ; } else { return response . success ( bitmap , http header parser . parse cache headers ( response ) ) ; } }	the real guts of parsenetworkresponse.
public notification find ( integer notification id ) { notification notification = new notification ( context , notification id , null ) ; if ( notification . get attributes ( ) == null ) notification . load attributes from preferences ( ) ; return notification ; }	get a notification by its id .
public green gradient ( int max count ) { this . max count = max count ; factor = max count / math . log ( max count ) ; }	setup the green gradient.
public static void write histogram ( t distr , string filename ) throws file not found exception , io { buffered writer a writer = io . get buffered writer ( filename ) ; a writer . write ( str ) ; a writer . new line ( ) ; double [ ] keys = distr . keys ( ) ; arrays . sort ( keys ) ; for ( double key : keys ) { a writer . write ( string . value of ( key ) ) ; a writer . write ( str ) ; a writer . write ( string . value of ( distr . get ( key ) ) ) ; a writer . new line ( ) ; } a writer . close ( ) ; }	writes a histogram as a tab - separated file with two columns : the first column indicates the bin key ( e.
public static < t > completion stage < t > dereference ( completion stage < ? extends completion stage < t > > stage ) { return stage . then compose ( identity . instance ) ; }	this takes a stage of a stage of a value and returns a plain stage of a value .
public static number plus ( character left , number right ) { return number number plus . plus ( integer . value of ( left ) , right ) ; }	add a character and a number.
public static string clip string if necessary ( j c , font metrics fm , string string , int avail text width ) { if ( ( string == null ) || ( string . equals ( str ) ) ) { return str ; } int text width = swing utilities2 . string width ( c , fm , string ) ; if ( text width > avail text width ) { return swing utilities2 . clip string ( c , fm , string , avail text width ) ; } return string ; }	clips the passed in string to the space provided .
public boolean remove element ( object obj ) { synchronized ( actions ) { if ( allow to change ) { boolean result = actions . remove ( obj ) ; if ( actions . is empty ( ) ) { if ( head task != null ) { cancel ( ) ; } } return result ; } } return bool ; }	removes an element from this instantrunnable .
public void add slide ( @ non null fragment fragment ) { fragments . add ( fragment ) ; add background color ( color . transparent ) ; pager adapter . notify data set changed ( ) ; }	add a slide to the intro.
public static string [ ] wrap string ( @ nonnull string str , int max width , @ nullable string [ ] output ) { if ( output == null ) { output = new string [ ( int ) ( ( str . length ( ) / max width ) * num + num ) ] ; } int line start = num ; int array index = num ; int i ; for ( i = num ; i < str . length ( ) ; i ++ ) { char c = str . char at ( i ) ; if ( c == str ) { output = add string ( output , str . substring ( line start , i ) , array index ++ ) ; line start = i + num ; } else if ( i - line start == max width ) { output = add string ( output , str . substring ( line start , i ) , array index ++ ) ; line start = i ; } } if ( line start != i || i == num ) { output = add string ( output , str . substring ( line start ) , array index ++ , output . length + num ) ; } if ( array index < output . length ) { output [ array index ] = null ; } return output ; }	splits the given string into lines using on any embedded newlines , and wrapping the text as needed to conform to the given maximum line width . < p / > this uses and assumes unix - style newlines.
private static float buffer create vertex array ( float [ ] coords ) { byte buffer bb = byte buffer . allocate direct ( coords . length * num ) ; bb . order ( byte order . native order ( ) ) ; float buffer fb = bb . as float buffer ( ) ; fb . put ( coords ) ; fb . position ( num ) ; return fb ; }	allocates a direct float buffer , and populates it with the vertex data .
protected void publish ( ) throws mqtt exception , io { sample client pub = new sample async wait ( url , client id pub , clean session , quiet mode , user name , password ) ; if ( sample client pub != null ) { string topic = str ; int qos = num ; string message = str ; try { sample client pub . publish ( topic , qos , message . get bytes ( ) ) ; } catch ( throwable e ) { e . print stack trace ( ) ; } } }	publish / send a message to an mqtt server.
public static void clean directory ( file directory ) throws io { if ( ! directory . exists ( ) ) { string message = directory + str ; throw new illegal argument exception ( message ) ; } if ( ! directory . is directory ( ) ) { string message = directory + str ; throw new illegal argument exception ( message ) ; } file [ ] files = directory . list files ( ) ; if ( files == null ) { throw new io ( str + directory ) ; } io exception = null ; for ( file file : files ) { try { force delete ( file ) ; } catch ( io ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }	cleans a directory without deleting it .
private object [ ] inv wm sub band ( image img , double [ ] wm , int n , double threshold ) { int m = num ; double z = num ; double v = num ; for ( int i = num ; i < img . get width ( ) * img . get height ( ) ; i ++ ) { if ( img . get data ( ) [ i ] > threshold ) { z += ( img . get data ( ) [ i ] * wm [ i % n ] ) ; v += math . abs ( img . get data ( ) [ i ] ) ; m ++ ; } } return new object [ ] { m , z , v } ; }	extracts the watermark data from subband.
public static void move to directory ( file src , file dest dir , boolean create dest dir ) throws io { if ( src == null ) { throw new null pointer exception ( str ) ; } if ( dest dir == null ) { throw new null pointer exception ( str ) ; } if ( ! src . exists ( ) ) { throw new file not found exception ( str + src + str ) ; } if ( src . is directory ( ) ) { move directory to directory ( src , dest dir , create dest dir ) ; } else { move file to directory ( src , dest dir , create dest dir ) ; } }	moves a file or directory to the destination directory.
private static tungsten properties load security properties from file ( string properties file location ) throws configuration exception { tungsten properties security props = null ; file input stream security configuration file input stream = null ; if ( properties file location == null && cluster configuration . get cluster home ( ) == null ) { throw new configuration exception ( str ) ; } file security properties file ; if ( properties file location == null ) { file cluster conf directory = cluster configuration . get dir ( cluster configuration . get global config dir name ( cluster configuration . get cluster home ( ) ) ) ; security properties file = new file ( cluster conf directory . get path ( ) , security conf . security properties file name ) ; } else { security properties file = new file ( properties file location ) ; } try { security props = new tungsten properties ( ) ; security configuration file input stream = new file input stream ( security properties file ) ; security props . load ( security configuration file input stream , bool ) ; close security configuration file input stream ( security configuration file input stream ) ; } catch ( file not found exception e ) { string msg = message format . format ( str , security properties file . get path ( ) ) ; logger . debug ( msg , e ) ; throw new configuration exception ( msg ) ; } catch ( io e ) { string msg = message format . format ( str , security properties file . get path ( ) , e . get message ( ) ) ; logger . debug ( msg , e ) ; throw new configuration exception ( msg ) ; } finally { close security configuration file input stream ( security configuration file input stream ) ; } if ( logger . is debug enabled ( ) ) { logger . debug ( message format . format ( str , security properties file . get path ( ) ) ) ; } security props . put ( security conf . security properties parent file location , security properties file . get absolute path ( ) ) ; return security props ; }	loads security related properties from a file.
public static void close ( input stream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( io io e ) { } }	closes an input stream .
private synchronized void clear scan files ( ) { if ( ( all files != null ) && ( all files . size ( ) > num ) ) { iterator it = all files . iterator ( ) ; file file = null ; while ( it . has next ( ) ) { file = ( file ) it . next ( ) ; file . delete ( ) ; } all files . clear ( ) ; } }	limpia la lista de ficheros del escaneo.
public static void exec and check output ( process builder builder , string expected out , string expected err ) throws exception { process process = builder . start ( ) ; executor service executor service = executors . new fixed thread pool ( num ) ; try { future < string > err future = executor service . submit ( stream to string callable ( process . get error stream ( ) ) ) ; future < string > out future = executor service . submit ( stream to string callable ( process . get input stream ( ) ) ) ; assert equals ( expected out , out future . get ( num , time unit . seconds ) ) ; assert equals ( expected err , err future . get ( num , time unit . seconds ) ) ; } finally { executor service . shutdown ( ) ; process . wait for ( ) ; } }	starts the process described by ' builder ' , and asserts that it sees ' expectedout ' on stdout and ' expectederr ' on stderr.
private void start file based merge ( ) throws carbon sort key and group by exception { try { executor service . shutdown ( ) ; executor service . await termination ( num , time unit . days ) ; data sorter and writer executor service . shutdown ( ) ; data sorter and writer executor service . await termination ( num , time unit . days ) ; } catch ( interrupted exception e ) { throw new carbon sort key and group by exception ( str , e ) ; } }	below method will be used to start file based merge.
public void insert update ( document event e ) { if ( ! dirty ) { set dirty ( bool ) ; } }	callback for when text is inserted into the document .
public date time parse exception ( string message , char sequence parsed data , int error index ) { super ( message ) ; this . parsed string = parsed data . to string ( ) ; this . error index = error index ; }	constructs a new exception with the specified message .
private boolean are parallel siblings ( component source , component target , int axis ) { component info source info = get component info ( source ) ; component info target info = get component info ( target ) ; spring source spring ; spring target spring ; if ( axis == horizontal ) { source spring = source info . horizontal spring ; target spring = target info . horizontal spring ; } else { source spring = source info . vertical spring ; target spring = target info . vertical spring ; } array list source path = tmp parallel set ; source path . clear ( ) ; spring spring = source spring . get parent ( ) ; while ( spring != null ) { source path . add ( spring ) ; spring = spring . get parent ( ) ; } spring = target spring . get parent ( ) ; while ( spring != null ) { if ( source path . contains ( spring ) ) { source path . clear ( ) ; while ( spring != null ) { if ( spring instanceof parallel group ) { return bool ; } spring = spring . get parent ( ) ; } return bool ; } spring = spring . get parent ( ) ; } source path . clear ( ) ; return bool ; }	returns true if the two components have a common parallelgroup ancestor along the particular axis .
protected object read object impl ( class cl ) throws io { try { object obj = cl . new instance ( ) ; if ( refs == null ) refs = new array list ( ) ; refs . add ( obj ) ; hash map field map = get field map ( cl ) ; int code = read ( ) ; for ( ; code >= num && code != str ; code = read ( ) ) { unread ( ) ; object key = read object ( ) ; field field = ( field ) field map . get ( key ) ; if ( field != null ) { object value = read object ( field . get type ( ) ) ; field . set ( obj , value ) ; } else { object value = read object ( ) ; } } if ( code != str ) throw expect ( str , code ) ; try { method method = cl . get method ( str , new class [ num ] ) ; return method . invoke ( obj , new object [ num ] ) ; } catch ( exception e ) { } return obj ; } catch ( io e ) { throw e ; } catch ( exception e ) { throw new io ( e ) ; } }	reads an object from the input stream.
public void test case18 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; byte b bytes [ ] = { num } ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num } ; int a sign = num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract zero from a number.
public static plain text plain ( int text ) { return plain ( integer . to string ( text ) ) ; }	creates a new plaintext component with the given int.
public static boolean is today ( calendar calendar ) { calendar now = calendar . get instance ( ) ; if ( now . get ( calendar . day of month ) == calendar . get ( calendar . day of month ) ) { if ( now . get ( calendar . month ) == calendar . get ( calendar . month ) ) { if ( now . get ( calendar . year ) == calendar . get ( calendar . year ) ) { return bool ; } } } return bool ; }	allows to know if a given calendar instance is set today.
public void start ( ) { managed pairs . add ( create port ( ) ) ; fix names ( ) ; single ports . add observer ( observer , bool ) ; for ( ports < m > ports : multi ports list ) { ports . add observer ( observer , bool ) ; } }	creates an initial port and starts to listen .
protected void sprint ( double double field ) { sprint ( string . value of ( double field ) ) ; }	pretty printing accumulator function for doubles.
public static bitmap convert yuv image to bitmap ( @ non null final yuv image yuv image ) { byte array output stream out = new byte array output stream ( ) ; yuv image . compress to jpeg ( new rect ( num , num , yuv image . get width ( ) , yuv image . get height ( ) ) , num , out ) ; byte [ ] image bytes = out . to byte array ( ) ; try { out . close ( ) ; } catch ( io e ) { log . e ( log tag , str , e ) ; } return bitmap factory . decode byte array ( image bytes , num , image bytes . length ) ; }	note : this conversion procedure is sloppy and may result in jpeg compression artifacts.
public double read ( string value ) { return double . value of ( value ) ; }	this method is used to convert the string value given to an appropriate representation.
public boolean has feature ( string feature , string version ) { if ( feature . equals ( str ) ) { return version == null || version . equals ( str ) || version . equals ( str ) ; } return bool ; }	test if the dom implementation implements a specific feature .
private storage port assign port based on usage ( list < storage port > matching target ports , map < storage port , integer > port usage ) { storage port found port = null ; for ( storage port matched port : matching target ports ) { if ( port usage . get ( matched port ) == null ) { port usage . put ( matched port , num ) ; } if ( found port == null ) { found port = matched port ; } else { if ( port usage . get ( matched port ) < port usage . get ( found port ) ) { found port = matched port ; } } } if ( found port != null ) { port usage . put ( found port , port usage . get ( found port ) + num ) ; } return found port ; }	doing the best possible assignment.
public external event next event ( ) { if ( queue . size ( ) == num ) { return new external event ( double . max value ) ; } external event ee = queue . get ( next event index ) ; next event index ++ ; if ( next event index >= queue . size ( ) ) { queue = read events ( nrof preload ) ; next event index = num ; } return ee ; }	returns the next event in the queue or externalevent with time of double . max_value if there are no events left.
public void append to buffer ( string builder buf ) { iterator < double [ ] > iter = points . iterator ( ) ; while ( iter . has next ( ) ) { double [ ] data = iter . next ( ) ; for ( int i = num ; i < data . length ; i ++ ) { if ( i > num ) { buf . append ( str ) ; } buf . append ( data [ i ] ) ; } if ( iter . has next ( ) ) { buf . append ( str ) ; } } }	append the polygon to the buffer .
public void update combo box ( j < track > box ) { box . remove all items ( ) ; box . add item ( null ) ; list < track > tracks = get track by name list ( null ) ; for ( track track : tracks ) { box . add item ( track ) ; } }	updates a jcombobox with all of the track locations for this location .
public refactoring session transformer ( final boolean projects ) { f projects = projects ; }	creates a new refactoring session transformer .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public compare result open ( ) { final content comparator [ ] comparator array = comparators . to array ( new content comparator [ comparators . size ( ) ] ) ; final custom compare editor input input = new custom compare editor input ( modified , original , ancestor , comparator array , compare configuration , external compare handler ) ; if ( compare configuration . is left editable ( ) || compare configuration . is right editable ( ) ) { compare configuration . set property ( str , boolean . false ) ; input . set always dirty ( always dirty ) ; } input . add save listener ( new proxy compare save listener ( ) ) ; log . info ( message format . format ( str , get label noloc ( modified ) , get label noloc ( original ) ) ) ; compare ui . open compare ui ( input ) ; final boolean contents identical = ( input . get compare result ( ) == null ) ; final boolean contents saved = ( input . get saved contents ( ) . length > num ) ; return new compare result ( contents identical , input . was ok ( ) , contents saved ) ; }	opens this compare operation , showing the compare ui , returning the result details of the comparison.
protected void add resource ( string resource ) { if ( ! string utils . is empty ( resource ) ) { resources . add ( resource ) ; } }	import a resources into view.
public static boolean is numeric ( string maybe numeric ) { return maybe numeric != null && maybe numeric . matches ( str ) ; }	checks whether a string contains only number or not using a regex . i like this approach since it doesn ' t need to parse it into a numerical variable which may not fit into any particularly type.
public static string encode ( string string ) { byte [ ] bytes ; try { bytes = string . get bytes ( preferred encoding ) ; } catch ( unsupported encoding exception e ) { bytes = string . get bytes ( ) ; } return encode bytes ( bytes ) ; }	encode string as a byte array in base64 annotation .
public final long add and get ( long delta ) { for ( ; ; ) { long current = get ( ) ; long next = current + delta ; if ( compare and set ( current , next ) ) return next ; } }	atomically adds the given value to the current value .
default long now ( time unit unit ) { return unit . convert ( system . current time millis ( ) , time unit . milliseconds ) ; }	returns the " current time " notion of this scheduler .
private final void append ( list < ? super name value pair > l , final string k , final string v ) { if ( v != null ) l . add ( new name value pair ( k , v ) ) ; }	appends a namevaluepair of k / v to l if v is non - null .
protected properties create properties ( url location ) throws io { input stream is = null ; if ( location != null ) { is = location . open stream ( ) ; } properties tmp properties = new properties ( ) ; if ( is != null ) { tmp properties . load ( is ) ; } return tmp properties ; }	reads the file at the given location and creates a properties file from the contents .
protected double calc plan weight ( final t plan , final double max score ) { if ( plan . get score ( ) == null ) { return double . n ; } double weight = math . exp ( this . beta * ( plan . get score ( ) - max score ) ) ; if ( weight < min weight ) weight = min weight ; return weight ; }	calculates the weight of a single plan .
public static boolean is extension ( string filename , collection < string > extensions ) { if ( filename == null ) { return bool ; } if ( extensions == null || extensions . is empty ( ) ) { return index of extension ( filename ) == - num ; } string file ext = get extension ( filename ) ; for ( string extension : extensions ) { if ( file ext . equals ( extension ) ) { return bool ; } } return bool ; }	checks whether the extension of the filename is one of those specified.
void find value ( ) { if ( log . is debug enabled ( ) ) { log . debug ( str + label ( ) ) ; } for ( int i = num ; i < value . get item count ( ) ; i ++ ) { string choice = value . get item at ( i ) ; setting list sl = choice hash . get ( choice ) ; if ( sl . match ( ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + i ) ; } value . set selected item ( choice ) ; return ; } } if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } }	suspect underlying variables have changed value ; check.
public void mkdir ( string key ) throws io { key = key . replace ( str , str ) ; if ( key . ends with ( str ) && ! key . equals ( str ) ) { throw new invalid parameter exception ( str ) ; } string [ ] split = key . split ( str ) ; string builder builder = new string builder ( ) ; for ( string s : split ) { builder . append ( s ) ; if ( ! s . is empty ( ) && ! exists ( builder . to string ( ) ) ) { zk state . set ( builder . to string ( ) , null ) ; } builder . append ( str ) ; } }	creates the znode if it does not exist.
public double calculate log ( double value ) { return math . log ( value ) / this . base log ; }	calculates the log of the given value , using the current base .
public static vector3 pow ( vector3 o , double power ) { return new vector3 ( math . pow ( o . x , power ) , math . pow ( o . y , power ) , math . pow ( o . z , power ) ) ; }	raises the x , y , and z values of a vector3 to the given power .
public datagram packet response receive ( ) throws io { byte [ ] buf = new byte [ num ] ; datagram packet dp = new datagram packet ( buf , buf . length ) ; datagram socket . receive ( dp ) ; return dp ; }	used to receive ssdp response packet.
public static float [ ] temperature to rgb ( int degrees k ) { int k = math utils . constrain ( degrees k , num , num ) ; float a = ( k % num ) / num ; int i = ( ( k - num ) / num ) * num ; return new float [ ] { interp ( i , a ) , interp ( i + num , a ) , interp ( i + num , a ) } ; }	convert a color temperature value ( in kelvin ) to a rgb units as floats.
public advanced state map . builder with name ( function < properties map , string > mapper ) { this . name mapper = mapper ; return this ; }	sets the state mapper to set the name to the value returned by the specified mapper.
public void test fill ziiz ( ) { boolean val = bool ; boolean d [ ] = new boolean [ num ] ; arrays . fill ( d , num , d . length , val ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == val ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == val ) ; try { arrays . fill ( d , num , num , val ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } try { arrays . fill ( d , - num , num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } try { arrays . fill ( d , num , d . length + num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } }	java . util . arrays # fill ( boolean [ ] , int , int , boolean ).
@ override public synchronized boolean add all ( collection < ? extends e > collection ) { return add all ( element count , collection ) ; }	adds the objects in the specified collection to the end of this vector .
public string sprintf ( ) { final iterator < conversion specification > e = v fmt . iterator ( ) ; conversion specification cs ; char c ; final string builder sb = new string builder ( ) ; while ( e . has next ( ) ) { cs = e . next ( ) ; c = cs . get conversion character ( ) ; if ( c == str ) { sb . append ( cs . get literal ( ) ) ; } else if ( c == str ) { sb . append ( str ) ; } } return sb . to string ( ) ; }	format nothing . just use the control string .
default string resource name ( string table name , string type ) { return string . format ( resource name , table name , type ) ; }	get the name of a relation between an object and a resource.
protected void update combo boxes load change ( ) { if ( auto track check box . is selected ( ) ) { update location track combo box ( ) ; } if ( auto destination track check box . is selected ( ) ) { update destination track combo box ( ) ; } if ( auto final dest track check box . is selected ( ) ) { update final destination ( ) ; } }	update locations if load changes.
public string remove class column tip text ( ) { return str ; }	returns the tip text for this property.
public static string join ( named value [ ] values , string separator ) { string builder buff = new string builder ( ) ; for ( int i = num ; i < values . length ; i ++ ) { buff . append ( values [ i ] ) ; if ( i < values . length - num ) buff . append ( separator ) ; } return buff . to string ( ) ; }	joins multiple namedvalues into a single string.
protected string source class ( attribute c , double [ ] dist ) { if ( c . is nominal ( ) ) { return integer . to string ( utils . max index ( dist ) ) ; } else { return double . to string ( dist [ num ] ) ; } }	returns the value as string out of the given distribution.
public void done ( ) throws io { printer . flush ( ) ; }	description of the method.
int request group data ( char group num ) { set curr data group ( group num ) ; curr grp items = known grp items . get ( integer . value of ( get curr data group ( ) ) ) ; char [ ] pay load = { group num } ; return ( write telegram ( pay load , cmd group read , null ) ) ; }	send request to read group data.
protected string encode cookie ( serializable http cookie cookie ) { if ( cookie == null ) return null ; byte array output stream os = new byte array output stream ( ) ; try { object output stream output stream = new object output stream ( os ) ; output stream . write object ( cookie ) ; } catch ( io e ) { log . d ( log tag , str , e ) ; return null ; } return byte array to hex string ( os . to byte array ( ) ) ; }	serializes cookie object into string.
public long skip ( long bytes ) throws io { if ( closed ) { throw new io ( str ) ; } int av = available ( ) ; if ( av == num ) { av = make available ( ) ; if ( av == num ) { return num ; } } long res = math . min ( av , bytes ) ; head += res ; return res ; }	skips the given number of bytes .
public void resume ( ) { m paused = bool ; m last frame time = system . current time millis ( ) ; invalidate ( ) ; }	resumes the ken burns effect animation .
public void test subtract diff scale neg pos ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . subtract ( b number ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	subtract two numbers of different scales ; the first is negative.
void add to prototype callback ( ) ;	generates a function that adds members to a prototype , then calls it .
public all to all panel ( all to all connector , network panel network panel ) { super ( ) ; this . connection = connector ; allow self connect panel = new j ( new flow layout ( flow layout . left ) ) ; allow self connect panel . add ( new j ( str ) ) ; allow self connect panel . add ( allow self connect chk bx ) ; fill field values ( ) ; add ( allow self connect panel ) ; }	construct a new all to all panel .
public boolean function available ( string ns , string func name ) throws javax . xml . transform . transformer exception { try { if ( func name == null ) { string fmsg = xsl . create xpath ( xpath . er arg cannot be null , new object [ ] { str } ) ; throw new null pointer exception ( fmsg ) ; } javax . xml . namespace . q my q = new q ( ns , func name ) ; javax . xml . xpath . x xpath function = resolver . resolve function ( my q , num ) ; if ( xpath function == null ) { return bool ; } return bool ; } catch ( exception e ) { return bool ; } }	is the extension function available ?.
private void allocate sections ( int p section count ) { section list . ensure capacity ( p section count ) ; while ( section list . size ( ) < p section count ) { section list . add ( new maze search element ( ) ) ; } }	allocates and initializes p_section_count sections.
public boolean refresh needed ( ) { return this . soft ttl < system . current time millis ( ) ; }	true if a refresh is needed from the original data source .
public static byte [ ] random bytes ( int length ) { byte [ ] bytes = new byte [ length ] ; seeded random . next bytes ( bytes ) ; return bytes ; }	generate an array of random bytes.
public weight distribution ( column example table column table , int [ ] selection , int attribute number ) { calculate label weights ( column table , selection , attribute number ) ; left label weights = new double [ total label weights . length ] ; left weight = num ; total weight = get total weight ( total label weights ) ; if ( has missings ) { missings weight = get total weight ( missings label weights ) ; right weight = total weight - missings weight ; right label weights = array difference ( total label weights , missings label weights ) ; } else { missings weight = num ; right weight = total weight ; right label weights = new double [ total label weights . length ] ; system . arraycopy ( total label weights , num , right label weights , num , total label weights . length ) ; } }	initializes the counting arrays with the start distribution .
public static string remove extension ( string file name ) { int index = file name . last index of ( str ) ; if ( index == - num ) { return file name ; } else { return file name . substring ( num , index ) ; } }	removes the extensions of the given file name .
public void delete ( string name ) throws io { if ( name . equals ignore case ( key id ) ) { id = null ; } else { throw new io ( str + str ) ; } encode this ( ) ; }	delete the attribute value .
public static data frame normalize ( data frame data frame , double min , double max ) { return normalize ( data frame , min , max , collections . < string > empty list ( ) ) ; }	scale based on min , max.
boolean is socket scheme ( string scheme ) { for ( string p : uri . socket schemes ) { if ( p . equals ( scheme ) ) { return bool ; } } return bool ; }	internal utility method to determine if the given scheme should use semicolons ( ; ) for query separator instead of ampersand ( & ).
private static void add leaf with non existing parents ( spatial root , spatial leaf ) { if ( ! ( root instanceof node ) ) { logger . log ( level . warning , str , new object [ ] { leaf . get name ( ) , root . get name ( ) } ) ; return ; } for ( spatial s = leaf ; s . get parent ( ) != null ; s = s . get parent ( ) ) { spatial parent = s . get parent ( ) ; spatial other = find tagged spatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof node ) { logger . log ( level . info , str , new object [ ] { s , other , root , leaf } ) ; for ( spatial spt = leaf ; spt != parent ; spt = spt . get parent ( ) ) { spt . set user data ( original name , spt . get name ( ) ) ; spt . set user data ( original path , get spatial path ( spt ) ) ; spt = spt . get parent ( ) ; } node other node = ( node ) other ; other node . attach child ( s ) ; logger . log ( log level . userinfo , str , new object [ ] { other . get name ( ) , leaf . get name ( ) } ) ; return ; } else { logger . log ( level . warning , str , new object [ ] { leaf , other , root } ) ; } } logger . log ( level . warning , str , leaf . get name ( ) ) ; }	adds a leaf to a spatial , including all nonexisting parents .
private void adjust block listeners ( list < o > old range , list < o > new range , tracker tracker ) { iterator < o > iter = new range . iterator ( ) ; while ( iter . has next ( ) ) { o b = iter . next ( ) ; if ( old range . contains ( b ) ) { old range . remove ( b ) ; continue ; } add block listener ( b , tracker ) ; } iter = old range . iterator ( ) ; while ( iter . has next ( ) ) { remove block listener ( iter . next ( ) , tracker ) ; } }	do venn diagram between the two sets.
static public string hex encode ( byte [ ] a input ) { string buffer result = new string buffer ( ) ; final char [ ] digits = { str , str , str , str , str , str , str , str , str , str , str , str , str , str , str , str } ; for ( int idx = num ; idx < a input . length ; ++ idx ) { byte b = a input [ idx ] ; result . append ( digits [ ( b & num ) > > num ] ) ; result . append ( digits [ b & num ] ) ; } return result . to string ( ) ; }	the byte [ ] returned by messagedigest does not have a nice textual representation , so some form of encoding is usually performed.
private static size clamp size ( size original , double max area , size max size ) { if ( original . get width ( ) * original . get height ( ) < max area && original . get width ( ) < max size . get width ( ) && original . get height ( ) < max size . get height ( ) ) { return original ; } double ratio = math . min ( math . sqrt ( max area / original . area ( ) ) , num ) ; int width = ( int ) math . round ( original . width ( ) * ratio ) ; int height = ( int ) math . round ( original . height ( ) * ratio ) ; if ( width > max size . width ( ) || height > max size . height ( ) ) { return compute fit within size ( original , max size ) ; } return new size ( width , height ) ; }	given a size , compute a value such that it will downscale the original size to fit within the maxsize bounding box and to be less than the provided area.
tcp ( tcp tr , tcp ep ) { this . tr = tr ; this . ep = ep ; }	create channel for endpoint .
@ override public final string to string ( ) { string builder buffer = new string builder ( ) ; buffer . append ( str ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { indexable field field = fields . get ( i ) ; buffer . append ( field . to string ( ) ) ; if ( i != fields . size ( ) - num ) { buffer . append ( str ) ; } } buffer . append ( str ) ; return buffer . to string ( ) ; }	prints the fields of a document for human consumption .
public static byte [ ] encode ( byte [ ] data ) { byte array output stream b out = new byte array output stream ( ) ; try { encoder . encode ( data , num , data . length , b out ) ; } catch ( io e ) { throw new runtime exception ( str + e ) ; } return b out . to byte array ( ) ; }	encode the input data producing a base 64 encoded byte array .
public static face draw dir ( direction dir , mesh model model , double min x , double min y , double min z , double max x , double max y , double max z , cube texture coordinates texture coordinates ) { switch ( dir ) { case down : return draw down ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; case up : return draw up ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; case north : return draw north ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; case south : return draw south ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; case east : return draw east ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; case west : return draw west ( model , min x , min y , min z , max x , max y , max z , texture coordinates ) ; } throw new render exception ( str ) ; }	creates a face of the model in a specified direction.
public void add observer ( final file alteration observer observer ) { if ( observer != null ) { observers . add ( observer ) ; } }	add a file system observer to this monitor .
public static double log1p ( final double x ) { if ( x == - num ) { return double . negative infinity ; } if ( x == double . positive infinity ) { return double . positive infinity ; } if ( x > num || x < - num ) { final double xpa = num + x ; final double xpb = - ( xpa - num - x ) ; final double [ ] hi prec = new double [ num ] ; final double lores = log ( xpa , hi prec ) ; if ( double . is infinite ( lores ) ) { return lores ; } final double fx1 = xpb / xpa ; final double epsilon = num * fx1 + num ; return epsilon * fx1 + hi prec [ num ] + hi prec [ num ] ; } else { final double y = ( x * f 1 3 - f 1 2 ) * x + num ; return y * x ; } }	computes log ( 1 + x ) .
protected script builder big num ( long num ) { return big num ( chunks . size ( ) , num ) ; }	adds the given number as a push data chunk.
static object new instance ( string class name , class loader cl , boolean do fallback ) throws configuration error { try { class provider class = find provider class ( class name , cl , do fallback ) ; object instance = provider class . new instance ( ) ; if ( debug ) debug println ( str + provider class + str + cl ) ; return instance ; } catch ( class not found exception x ) { throw new configuration error ( str + class name + str , x ) ; } catch ( exception x ) { throw new configuration error ( str + class name + str + x , x ) ; } }	create an instance of a class using the specified classloader.
public void add action ( entity action ea ) { actions . add element ( ea ) ; process game event ( new game new action event ( this , ea ) ) ; }	adds the specified action to the actions list for this phase .
public polygon ( polygon point p1 , polygon point p2 , polygon point p3 ) { p1 . next = p2 ; p2 . next = p3 ; p3 . next = p1 ; p1 . previous = p3 ; p2 . previous = p1 ; p3 . previous = p2 ; points . add ( p1 ) ; points . add ( p2 ) ; points . add ( p3 ) ; }	to create a polygon we need atleast 3 separate points.
public static json read json ( final json json array , final int index , final boolean required , final boolean not null ) throws json { if ( required ) { return json array . get json ( index ) ; } if ( not null && json array . is null ( index ) ) { throw new json ( string . format ( locale . us , null value format array , index ) ) ; } json value = null ; if ( ! json array . is null ( index ) ) { value = json array . get json ( index ) ; } return value ; }	reads the json object value from the json array for specified index .
public static void wait element to not be present ( search context parent , by by , int wait in seconds ) { preconditions . check not null ( parent ) ; preconditions . check not null ( by ) ; try { web element wait wait = new web element wait ( parent , wait in seconds ) ; wait . until ( null ) ; } catch ( timeout exception e ) { throw new timeout exception ( string . format ( str , by , wait in seconds ) , e ) ; } }	will wait until no element identified by the by is present .
public final test subscriber assert terminated ( ) { if ( done . get count ( ) != num ) { fail ( str , str , errors ) ; } long c = completions ; if ( c > num ) { fail ( str , str + c , errors ) ; } int s = errors . size ( ) ; if ( s > num ) { fail ( str , str + s , errors ) ; } if ( c != num && s != num ) { fail ( str , str + c , errors ) ; } return this ; }	assert that the testsubscriber terminated ( i.
public boolean is vimeo url ( ) { string video id = get extracted identifier ( ) ; return video id . length ( ) > num && text utils . is digits only ( video id ) ; }	check if a vimeo url has a valid identifier.
public boolean is cancelled ( ) { return m state . get ( ) == state cancelled ; }	check whether this work is canceled .
public final void push sub context list ( sub context list iter ) { m axes iterator stack . push ( iter ) ; }	push a treewalker on the stack .
private void update downloaded files ( sq db , string new account name , string old account name ) { string where clause = provider table meta . file account owner + str + provider table meta . file storage path + str ; cursor c = db . query ( provider table meta . file table name , null , where clause , new string [ ] { new account name } , null , null , null ) ; try { if ( c . move to first ( ) ) { string old account path = file storage utils . get save path ( old account name ) ; string new account path = file storage utils . get save path ( new account name ) ; file old account folder = new file ( old account path ) ; file new account folder = new file ( new account path ) ; old account folder . rename to ( new account folder ) ; do { string old path = c . get string ( c . get column index ( provider table meta . file storage path ) ) ; oc file = new oc ( c . get string ( c . get column index ( provider table meta . file path ) ) ) ; string new path = file storage utils . get default save path for ( new account name , file ) ; content values cv = new content values ( ) ; cv . put ( provider table meta . file storage path , new path ) ; db . update ( provider table meta . file table name , cv , provider table meta . file storage path + str , new string [ ] { old path } ) ; oc . v ( str , str + old path + str + new path ) ; } while ( c . move to next ( ) ) ; } } finally { c . close ( ) ; } }	rename the local owncloud folder of one account to match the a rename of the account itself.
public void dump options ( ) { logger . info ( str ) ; for ( method getter : get configuration interface . class . get methods ( ) ) { string getter name = getter . get name ( ) ; try { object result = getter . invoke ( configuration manager . get current profile ( ) ) ; if ( result instanceof boolean ) { result = localization helper . get yes or no ( ( boolean ) result ) ; } if ( result instanceof list ) { for ( int i = num ; i < ( ( list ) result ) . size ( ) ; i ++ ) { assert ( ( list ) result ) . get ( i ) instanceof custom catalog entry ; custom catalog entry c = ( ( list < custom catalog entry > ) result ) . get ( i ) ; string option name = helper . pad ( localization . main . get text ( str ) + str + ( i + num ) + str + c . get at top ( ) . to string ( ) , str , num ) + str ; logger . info ( option name + c . get label ( ) + str + c . get value ( ) . to string ( ) + str + c . get at top ( ) . to string ( ) ) ; } } else { string option name = getter name . substring ( num ) ; dump option ( option name , result ) ; } } catch ( illegal access exception e ) { logger . warn ( str , e ) ; } catch ( invocation target exception e ) { logger . warn ( str , e ) ; } } logger . info ( str ) ; }	dump all the configuration options listed as get methods in the configuration interface .
private json node parse language resource ( resource resource ) throws io { input stream stream = resource . as stream ( ) ; if ( stream == null ) return null ; try { json node tree = mapper . read tree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }	parses the given language resource , returning the resulting jsonnode.
public collection < tuple2 < transition state , double > > start states ( ) { list < tuple2 < transition state , double > > result = new array list < tuple2 < transition state , double > > ( ) ; { double score = math . log ( line mrgn prob ) ; add no sub glyph start state ( result , new int [ num ] , transition state type . lmrgn , - num , score ) ; } for ( int dest language = num ; dest language < num languages ; ++ dest language ) { single language model dest lm = lm . get ( dest language ) ; double dest language prior = lm . language prior ( dest language ) ; for ( int c : dest lm . get active characters ( ) ) { if ( c != space char index ) { double score = math . log ( num - line mrgn prob ) + math . log ( get ngram prob ( dest lm , new int [ num ] , c ) ) + math . log ( dest language prior ) ; add glyph start states ( result , c , new int [ ] { c } , transition state type . tmpl , dest language , score ) ; } } } { double total space prob = num ; for ( int language = num ; language < num languages ; ++ language ) total space prob += get ngram prob ( lm . get ( language ) , new int [ num ] , space char index ) * lm . language prior ( language ) ; double score = math . log ( num - line mrgn prob ) + math . log ( total space prob ) ; add no sub glyph start state ( result , new int [ ] { space char index } , transition state type . tmpl , - num , score ) ; } return result ; }	make a collection of states that can be the start of a line.
public boolean remove container and cancel if necessary ( image container container ) { m containers . remove ( container ) ; if ( m containers . is empty ( ) ) { m request . cancel ( ) ; return bool ; } return bool ; }	detatches the bitmap container from the request and cancels the request if no one is left listening .
public kernel density function ( collection < double [ ] > points ) { this ( points . to array ( new double [ points . size ( ) ] [ ] ) ) ; }	creates a new kernel density function with the given points.
private static object clone serializable object ( object o ) throws io , class not found exception { byte array output stream b = new byte array output stream ( ) ; object output stream out = new object output stream ( b ) ; out . write object ( o ) ; out . flush ( ) ; out . close ( ) ; byte array input stream bi = new byte array input stream ( b . to byte array ( ) ) ; object input stream in = new object input stream ( bi ) ; return in . read object ( ) ; }	this methods provide cloning for serializable objects . mail attributes are serializable but not clonable so we need a deep copy.
public boolean has three ( ) { return points . size ( ) > num ; }	determine if there are more than 2 points currently in the partial hull .
public zip entry ( string name ) { objects . require non null ( name , str ) ; if ( name . length ( ) > num ) { throw new illegal argument exception ( str ) ; } this . name = name ; }	creates a new zip entry with the specified name .
public void test statements ( ) throws exception { connection connection = get connection via driver manager ( ) ; connection . set auto commit ( bool ) ; try { statement stmt = connection . create statement ( ) ; result set rs = stmt . execute query ( str ) ; rs . close ( ) ; random selector selector1 = new random selector ( stmt , select table 1 , record count ) ; random selector selector2 = new random selector ( stmt , select table 2 , record count ) ; thread thread1 = new thread ( selector1 , str ) ; thread thread2 = new thread ( selector2 , str ) ; thread1 . start ( ) ; thread2 . start ( ) ; thread . sleep ( test time seconds * num ) ; selector1 . stop ( ) ; selector2 . stop ( ) ; thread1 . join ( ) ; thread2 . join ( ) ; stmt . close ( ) ; } finally { connection . close ( ) ; } }	test if single statement can be safely used in multiple transactions.
void read dictionary ( string filename , string suffix , input stream res ) throws io { dictionary names nms = new dictionary names ( filename , suffix ) ; buffered reader in = new buffered reader ( new input stream reader ( res ) ) ; string line ; while ( ( line = in . read line ( ) ) != null ) { string [ ] terms = splitter . split ( line ) ; if ( terms . length > max phrase length ) continue ; if ( terms . length == num ) continue ; gaz entry ge = gaz . get ( terms [ num ] ) ; if ( ge == null ) { gaz . put ( terms [ num ] , new gaz entry ( terms , num , nms ) ) ; } else { ge . add child ( terms , num , nms ) ; } } in . close ( ) ; }	read the given dictionary file from the input stream .
public void add vertex ( value graph vertex v ) { if ( vertices . add ( v ) ) { if ( v . represents parameter ( ) ) { n parameter ++ ; } if ( representative v == null ) { representative v = v ; } } }	add a vertex to this congruence class .
private void create view to model ( int row count ) { int recreate from = num ; if ( view to model != null ) { recreate from = math . min ( row count , view to model . length ) ; if ( view to model . length != row count ) { row [ ] old view to model = view to model ; view to model = new row [ row count ] ; system . arraycopy ( old view to model , num , view to model , num , recreate from ) ; } } else { view to model = new row [ row count ] ; } int i ; for ( i = num ; i < recreate from ; i ++ ) { view to model [ i ] . model index = i ; } for ( i = recreate from ; i < row count ; i ++ ) { view to model [ i ] = new row ( this , i ) ; } }	resets the viewtomodel array to be of size rowcount .
public set < string > files ( ) { if ( set files == null ) { throw new illegal state exception ( str ) ; } return collections . unmodifiable set ( set files ) ; }	return all files referenced by this segmentinfo .
public static boolean is mac ( ) { string os name = system . get property ( str ) ; os name = os name . to lower case ( ) ; return os name . index of ( str ) != - num ; }	do we run on apple.
private boolean is assignable from ( throwable concrete throwable , set < class < ? extends throwable > > throwable classes ) { for ( class < ? extends throwable > t : throwable classes ) { if ( t . is assignable from ( concrete throwable . get class ( ) ) ) { return bool ; } } return bool ; }	tests if concretethrowable . getclass is assignable to any of the classes in throwableclasses.
public string pop and encode ( boolean from online event ) { synchronized ( this ) { if ( active bridge mode == null ) { return null ; } active bridge mode . notify of flush ( this , from online event ) ; if ( queue . is empty ( ) ) { return null ; } int total payload len = num ; int num messages to send = num ; for ( js message message : queue ) { int message size = calculate packed message length ( message ) ; if ( num messages to send > num && total payload len + message size > max payload size && max payload size > num ) { break ; } total payload len += message size ; num messages to send += num ; } string builder sb = new string builder ( total payload len ) ; for ( int i = num ; i < num messages to send ; ++ i ) { js message message = queue . remove first ( ) ; pack message ( message , sb ) ; } if ( ! queue . is empty ( ) ) { sb . append ( str ) ; } string ret = sb . to string ( ) ; return ret ; } }	combines and returns queued messages combined into a single string.
protected void print ( int v ) throws io { print ( string . value of ( v ) ) ; }	prints an integer to the stream .
public object2 double open hash map < rb > confidence map ( ) { list < item set > item sets = learn ( ) ; object2 double open hash map < rb > confidence map = new object2 double open hash map < > ( item sets . size ( ) ) ; for ( item set item set : item sets ) { rb item set copy = new rb ( item set . items ) ; confidence map . put ( item set copy , item set . support / ( double ) set count ) ; } return confidence map ; }	returns a map of associations and their confidence , where confidence is support for the itemset ( that is , the number of times it appears in the input data ) divided by the total number of sets ( i.
public static boolean is all alpha ( string str ) { if ( str == null ) return bool ; for ( int i = str . length ( ) - num ; i >= num ; i -- ) { if ( ! character . is letter ( str . char at ( i ) ) ) return bool ; } return bool ; }	returns true if all characters in the string are letters.
protected static int to digit ( char ch , int index ) throws dss { int digit = character . digit ( ch , num ) ; if ( digit == - num ) { throw new dss ( str + ch + str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
static void load library with path ( string lib name , class loader loader , string library path ) { throw new error ( str ) ; }	this method must be provided by the vm vendor , as it is called by java.
public enumeration list options ( ) { vector new vector = new vector ( ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void test constructor sign bytes positive7 ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , - num } ; int a sign = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void save ( file key store , string type , char [ ] password , char [ ] key password , string ca alias ) throws general security exception , io { key store store = key store . get instance ( type ) ; store . load ( null , password ) ; store . set key entry ( ca alias , ca key , key password , ca certs ) ; output stream out = new file output stream ( key store ) ; try { store . store ( out , password ) ; } catch ( io ioe ) { ioe . print stack trace ( ) ; } finally { out . close ( ) ; } }	saves the ca key and the certificate chain to the specified keystore.
public or query builder add ( query builder filter builder ) { filters . add ( filter builder ) ; return this ; }	adds a filter to the list of filters to " or " .
public static void d ( string tag , string msg , object ... args ) { if ( s level > level debug ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . d ( tag , msg ) ; }	send a debug log message.
void update ( long time nanos , int rows ) { count ++ ; execution time min nanos = math . min ( time nanos , execution time min nanos ) ; execution time max nanos = math . max ( time nanos , execution time max nanos ) ; row count min = math . min ( rows , row count min ) ; row count max = math . max ( rows , row count max ) ; double row delta = rows - row count mean ; row count mean += row delta / count ; row count m2 += row delta * ( rows - row count mean ) ; double time delta = time nanos - execution time mean nanos ; execution time mean nanos += time delta / count ; execution time m2 nanos += time delta * ( time nanos - execution time mean nanos ) ; execution time cumulative nanos += time nanos ; row count cumulative += rows ; last update time = system . current time millis ( ) ; }	update the statistics entry .
public void test ctor 2 ( ) throws sail exception { final file file = new file ( get name ( ) + options . jnl ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { fail ( str + file ) ; } } final properties properties = new properties ( ) ; properties . set property ( options . file , file . to string ( ) ) ; final bigdata sail sail = new bigdata sail ( properties ) ; try { sail . initialize ( ) ; sail . shut down ( ) ; } finally { if ( ! file . exists ( ) ) { fail ( str + file ) ; if ( ! file . delete ( ) ) { fail ( str + file ) ; } } } }	test create and shutdown of a named store .
@ override public string to string ( ) { string result ; result = null ; if ( is object ( ) ) { if ( is root ( ) ) { result = str ; } else if ( m == null ) { result = str ; } else { result = escape ( m ) + str ; } } else if ( is array ( ) ) { if ( m == null ) { result = str ; } else { result = escape ( m ) + str ; } } else { if ( m != null ) { result = escape ( m ) + str + escape ( m ) ; } else { result = str + m ; } } return result ; }	returns a string representation of the node .
public final boolean split traces keep point ( ) { if ( keep point == null ) return bool ; item selection filter filter = new item selection filter ( item selection choice . traces ) ; collection < brd item > picked items = r board . pick items ( keep point . keep point , keep point . on layer , filter ) ; for ( brd item curr item : picked items ) { brd tracep a trace = ( brd tracep ) curr item ; int line idx = a trace . polyline find line idx ( keep point . keep point ) ; if ( line idx < num ) continue ; array list < brd tracep > clean list = a trace . split with end point ( line idx , keep point . keep point ) ; return clean list . size ( ) > num ; } return bool ; }	splits the traces containing this.
public static byte [ ] flip all bits in place ( byte [ ] bytes , int index , int length ) { int end index = math . min ( bytes . length , index + length ) ; for ( int i = index ; i < end index ; i ++ ) { bytes [ i ] = ( byte ) ( bytes [ i ] ^ num ) ; } return bytes ; }	this flips the bits in the range [ index , index + length ) and returns the same byte [ ] .
public create index request source ( string source ) { return source ( source . get bytes ( charsets . utf 8 ) ) ; }	sets the settings and mappings as a single source .
private void add users ( user [ ] users , local configuration configuration ) { for ( user user : users ) { configuration . add user ( user . create user ( ) ) ; } }	add users to the configuration .
void try to drain buffers ( ) { if ( eviction lock . try lock ( ) ) { try { drain status . lazy set ( processing ) ; drain buffers ( ) ; } finally { drain status . compare and set ( processing , idle ) ; eviction lock . unlock ( ) ; } } }	attempts to acquire the eviction lock and apply the pending operations , up to the amortized threshold , to the page replacement policy .
public static boolean copy file ( file source , file dest ) { file parent dest = dest . get parent file ( ) ; if ( ! parent dest . exists ( ) ) { if ( ! create directory ( parent dest . get absolute path ( ) ) ) { return bool ; } } try { files . copy ( source . to path ( ) , dest . to path ( ) ) ; return bool ; } catch ( io e ) { e . print stack trace ( ) ; return bool ; } }	copy source file to destination file . create directory if destination directory does not exist.
public static string properties encode ( properties pp ) { byte array output stream bos = new byte array output stream ( ) ; try { pp . store ( bos , str ) ; } catch ( io e ) { log . log ( level . severe , str , e ) ; } string result = new string ( bos . to byte array ( ) ) ; try { result = url . encode ( result , mobile env . encoding ) ; } catch ( unsupported encoding exception e ) { log . log ( level . severe , str + mobile env . encoding , e ) ; string enc = system . get property ( str ) ; try { result = url . encode ( result , enc ) ; log . info ( str + enc ) ; } catch ( exception ex ) { log . log ( level . severe , str , ex ) ; } } return result ; }	decode properties into string ( url encoded ).
@ override public void generate rss ( xml writer w , extension profile ext profile ) throws io { array list < xml writer . attribute > attrs = new array list < xml writer . attribute > ( num ) ; if ( mime type != null ) { attrs . add ( new xml writer . attribute ( str , mime type . get media type ( ) ) ) ; } if ( uri != null ) { attrs . add ( new xml writer . attribute ( str , uri ) ) ; } if ( length != - num ) { attrs . add ( new xml writer . attribute ( str , long . to string ( length ) ) ) ; } w . simple element ( namespaces . rss ns , str , attrs , null ) ; }	generates xml in the rss format .
public void test sorts elements by name ( ) throws exception { xpp dom dom1 = xpp factory . build dom ( str ) ; xpp dom dom2 = xpp factory . build dom ( str ) ; assert equals ( - num , comparator . compare ( dom1 , dom2 ) ) ; assert equals ( str , xpath . get ( ) ) ; assert equals ( num , comparator . compare ( dom2 , dom1 ) ) ; assert equals ( str , xpath . get ( ) ) ; }	tests comparison of different elements .
public static boolean delete directory ( final file path ) { if ( path . exists ( ) ) { file [ ] files = path . list files ( ) ; for ( file file : files ) { if ( file . is directory ( ) ) { delete directory ( file ) ; } else { file . delete ( ) ; } } } return path . delete ( ) ; }	deletes directory with files .
public static timestamp string to time stamp ( string date time string , string date time format , time zone tz , locale locale ) throws parse exception { date format date format = to date time format ( date time format , tz , locale ) ; date parsed date = date format . parse ( date time string ) ; return new timestamp ( parsed date . get time ( ) ) ; }	localized string to timestamp conversion.
private boolean starts new hunk ( string string ) { if ( string . length ( ) == num ) return bool ; return is legal char ( string . char at ( num ) ) ; }	true if the string is the beginning of a new camel case hunk.
public void clear values ( ) { value map . clear ( ) ; }	removes all placeholder - value mappings .
private hash map < string , byte [ ] > read chars ( byte [ ] d ) { hash map < string , byte [ ] > hm = new hash map < string , byte [ ] > ( ) ; int i = find slash name ( d , str ) ; if ( i < num ) { return hm ; } ps psp = new ps ( d , i ) ; while ( bool ) { string s = psp . read thing ( ) ; char c = s . char at ( num ) ; if ( c == str ) { int len = integer . parse int ( psp . read thing ( ) ) ; string go = psp . read thing ( ) ; if ( go . equals ( str ) || go . equals ( str ) ) { psp . set loc ( psp . get loc ( ) + num ) ; byte [ ] line = psp . get n ( len , password , len iv ) ; hm . put ( s . substring ( num ) , line ) ; } } else if ( s . equals ( str ) ) { break ; } } return hm ; }	get the character definitions of the font .
public static byte [ ] string to byte array ( string input ) { char chars [ ] = input . to char array ( ) ; byte bytes [ ] = new byte [ chars . length ] ; for ( int i = num ; i < chars . length ; i ++ ) { bytes [ i ] = ( byte ) chars [ i ] ; } return bytes ; }	converts a string to a byte array .
public void play file for user ( string file name , string user name ) throws sound playback exception { if ( user name == null || user name . is empty ( ) ) { user name = app properties . get property ( str ) ; } try { guild guild = get users guild ( user name ) ; join users current channel ( user name ) ; play file ( file name , guild ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	joins the channel of the user provided and then plays a file .
@ deprecated public static void run finalizers on exit ( boolean run ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) { sm . check exit ( num ) ; } synchronized ( hooks list ) { finalize on exit = run ; } }	ensure that , when the virtual machine is about to exit , all objects are finalized.
public double [ ] [ ] predict intervals ( double conf ) { update mean and variance ( ) ; double val = statistics . normal inverse ( num - ( num - conf ) / num ) ; double [ ] [ ] arr = new double [ num ] [ num ] ; arr [ num ] [ num ] = m + val * math . sqrt ( m ) ; arr [ num ] [ num ] = m - val * math . sqrt ( m ) ; return arr ; }	returns the interval for the given confidence value .
public static < t > t min ( collection < ? extends t > collection , comparator < ? super t > comparator ) { if ( comparator == null ) { @ suppress warnings ( str ) t result = ( t ) min ( ( collection < java . lang . comparable > ) collection ) ; return result ; } iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . has next ( ) ) { t next = it . next ( ) ; if ( comparator . compare ( min , next ) > num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element using the specified comparator .
public static boolean check sha ( final string sha hash , final file file ) { if ( text utils . is empty ( sha hash ) || file == null || ! file utils . is readable ( file ) ) { log . e ( str ) ; return bool ; } final string hash = get sha ( file ) ; if ( hash == null ) { log . e ( str ) ; return bool ; } return hash . equals ignore case ( sha hash ) ; }	checks if given hash is the same for given file - helps to detect file changes.
public void add value key name ( string key ) { value key names . add ( key ) ; }	add the key that should be treated as one of the value fields . the key must be in the input map.
public assignment update ( border border ) { arrays . sort ( cs ) ; int j = num ; boolean found = ( cs [ num ] . core == border . core ) ; for ( int i = num ; i < cs . length ; i ++ ) { if ( cs [ i ] . core != cs [ i - num ] . core ) { cs [ j ++ ] = cs [ i ] ; } found |= ( cs [ i ] . core == border . core ) ; } if ( found ) { if ( j == num ) { border r = cs [ num ] ; cs = null ; return r ; } if ( j < cs . length ) { cs = arrays . copy of ( cs , j ) ; } return this ; } if ( j + num != cs . length ) { cs = arrays . copy of ( cs , j + num ) ; } cs [ j ] = border ; return this ; }	add a new border to the existing borders .
public static string from char ( int value ) { if ( value > num ) return null ; string name ; initialize ( ) ; name = ( string ) by char . get ( new integer ( value ) ) ; return name ; }	returns the name of an html character reference based on its character value.
public static list < string > split lines ( final string content ) { if ( content == null || content . length ( ) == num ) return collections . empty list ( ) ; string [ ] lines = content . split ( str ) ; return arrays . as list ( lines ) ; }	split the supplied content into lines , returning each line as an element in the returned list .
@ override public void draw ( d g2 , d area , d anchor , plot state state , plot rendering info info ) { boolean b1 = ( area . get width ( ) <= minimum width to draw ) ; boolean b2 = ( area . get height ( ) <= minimum height to draw ) ; if ( b1 || b2 ) { return ; } if ( info != null ) { info . set plot area ( area ) ; } rectangle insets insets = get insets ( ) ; insets . trim ( area ) ; draw chip grid ( g2 , area ) ; draw wafer edge ( g2 , area ) ; }	draws the wafermap view .
public void add hole ( edge ring hole er ) { hole er . set shell ( this ) ; linear ring hole = hole er . get ring ( ) ; if ( holes == null ) holes = new array list ( ) ; holes . add ( hole ) ; }	adds a hole to the polygon formed by this ring .
private static void register components ( ) { register component ( bar chart component . class , bar chart gui . class ) ; register component ( doc viewer component . class , doc viewer desktop component . class ) ; register component ( console component . class , console desktop component . class ) ; register component ( display component . class , display component desktop gui . class ) ; register component ( data world component . class , data world desktop component . class ) ; register component ( histogram component . class , histogram gui . class ) ; register component ( network component . class , network desktop component . class ) ; register component ( odor world component . class , odor world desktop component . class ) ; register component ( pie chart component . class , pie chart gui . class ) ; register component ( projection component . class , projection gui . class ) ; register component ( reader component . class , reader component desktop gui . class ) ; register component ( scatter plot component . class , scatter plot gui . class ) ; register component ( time series plot component . class , time series plot gui . class ) ; register component ( raster plot component . class , raster plot gui . class ) ; register component ( vision world component . class , vision world desktop component . class ) ; register component ( game component . class , game desktop component . class ) ; register component ( device interaction component . class , device interaction desktop component . class ) ; }	create mappings from guicomponents to their gui wrappers .
private void initialize ( class < ops type > ops type , interface instance ) throws instantiation exception , illegal access exception { m ops instance = ops type . new instance ( ) ; m retained fragment manager . put ( ops type . get simple name ( ) , m ops instance ) ; m ops instance . on configuration ( instance , bool ) ; }	initialize the genericactivity fields .
private long skip input bytes ( long n ) throws io { cb lock . lock ( ) ; try { return iis . skip bytes ( n ) ; } finally { cb lock . unlock ( ) ; } }	this method is called from the native code in order to skip requested number of bytes in the input stream .
public byte [ ] generate64 bit hash id ( ) throws crypto exception { try { der public key bit string = encode public key as bit string ( public key ) ; byte [ ] hash = digest util . get message digest ( public key bit string . get bytes ( ) , digest type . sh ) ; byte [ ] sub hash = arrays . copy of range ( hash , num , num ) ; sub hash [ num ] &= num ; sub hash [ num ] |= num ; return sub hash ; } catch ( io ex ) { throw new crypto exception ( res . get string ( str ) , ex ) ; } }	generate 64 bit hash key identifier .
public static < c extends configuration client , s extends configuration > create sub command handler < c , s > create ( sub command argument parser parser , managed object path < ? , ? > p , optional relation definition < c , s > r ) throws argument exception { return new create sub command handler < > ( parser , p , r , null , p . child ( r ) ) ; }	creates a new create - xxx sub - command for an optional relation .
public d ( j parent , byte [ ] value ) throws io { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; prepopulate with value ( value ) ; }	creates a new dsubjectinformationaccess dialog .
private figure read line element ( ixml elem ) throws io { hash map < attribute key , object > a = new hash map < attribute key , object > ( ) ; read core attributes ( elem , a ) ; read transform attribute ( elem , a ) ; read opacity attribute ( elem , a ) ; read line attributes ( elem , a ) ; if ( fill color . get ( a ) != null && stroke color . get ( a ) == null ) { stroke color . put ( a , fill color . get ( a ) ) ; } if ( fill gradient . get ( a ) != null && stroke gradient . get ( a ) == null ) { stroke gradient . put ( a , fill gradient . get ( a ) ) ; } fill color . put ( a , null ) ; fill gradient . put ( a , null ) ; double x1 = to number ( elem , read attribute ( elem , str , str ) ) ; double y1 = to number ( elem , read attribute ( elem , str , str ) ) ; double x2 = to number ( elem , read attribute ( elem , str , str ) ) ; double y2 = to number ( elem , read attribute ( elem , str , str ) ) ; figure figure = factory . create line ( x1 , y1 , x2 , y2 , a ) ; element objects . put ( elem , figure ) ; return figure ; }	reads an svg " line " element .
public list model ( final object [ ] items ) { for ( int i = num ; i < items . length ; ++ i ) m items . add ( items [ i ] ) ; }	create a listmodel with the provided items .
public boolean is set call type ( ) { return isset bit vector . get ( calltype isset id ) ; }	returns true if field calltype is set ( has been assigned a value ) and false otherwise.
private i map source ( source mapper mapper , i info , i buffer owner ) { char [ ] contents = mapper . find source ( get type ( ) , info ) ; if ( contents != null ) { i buffer = buffer manager . create buffer ( buffer owner ) ; if ( buffer == null ) return null ; buffer manager buf manager = get buffer manager ( ) ; buf manager . add buffer ( buffer ) ; if ( buffer . get characters ( ) == null ) { buffer . set contents ( contents ) ; } buffer . add buffer changed listener ( this ) ; mapper . map source ( get outer most enclosing type ( ) , contents , info ) ; return buffer ; } else { i buffer = buffer manager . create null buffer ( buffer owner ) ; if ( buffer == null ) return null ; buffer manager buf manager = get buffer manager ( ) ; buf manager . add buffer ( buffer ) ; buffer . add buffer changed listener ( this ) ; return buffer ; } }	loads the buffer via sourcemapper , and maps it in sourcemapper.
public j ( shell parent , int style , final list < string > extensions ) { this ( parent , style , associations ( extensions ) ) ; }	create a dialog that filters for files with the specified extensions .
private void compute static load metrics ( access profile access profile ) throws base collection exception { uri storage system id = access profile . get system id ( ) ; storage system storage system = null ; try { storage system = db client . query object ( storage system . class , storage system id ) ; logger . info ( str , storage system . get label ( ) ) ; vn client = get vnx unity client ( access profile ) ; list < vn > nas servers = client . get nas servers ( ) ; for ( vn nas server : nas servers ) { if ( ( nas server . get mode ( ) == vn . nas server mode enum . destination ) || nas server . get is replication destination ( ) ) { logger . debug ( str ) ; continue ; } if ( nas server . get is system ( ) ) { continue ; } nas virtual nas = findv nas by native id ( storage system , nas server . get id ( ) ) ; if ( virtual nas != null ) { logger . info ( str , nas server . get name ( ) ) ; string map db metrics = virtual nas . get metrics ( ) ; if ( db metrics == null ) { db metrics = new string map ( ) ; } string map tmp db metrics = populate db metrics ( nas server , client ) ; db metrics . put all ( tmp db metrics ) ; virtual nas . set metrics ( db metrics ) ; db client . update object ( virtual nas ) ; } } } catch ( exception e ) { logger . error ( str , storage system id , e ) ; } }	compute static load metrics .
public final short read short ( ) throws java . io . io { read fully ( scratch , num , num ) ; return ( short ) ( ( scratch [ num ] << num ) | ( scratch [ num ] & num ) ) ; }	see the general contract of the readshort method of datainput.
public replication job create job for copy partition ( long audit log id , long audit log entry create time , hive object spec spec ) throws state update exception { map < string , string > extras = new hash map < > ( ) ; extras . put ( persisted job info . audit log id extras key , long . to string ( audit log id ) ) ; extras . put ( persisted job info . audit log entry create time key , long . to string ( audit log entry create time ) ) ; list < string > partition names = new array list < > ( ) ; partition names . add ( spec . get partition name ( ) ) ; replication operation replication operation = replication operation . copy partition ; persisted job info persisted job info = job info store . resilient create ( replication operation , replication status . pending , optional . empty ( ) , src cluster . get name ( ) , spec , partition names , optional . empty ( ) , optional . empty ( ) , optional . empty ( ) , extras ) ; replication task replication task = new copy partition task ( conf , destination object factory , object conflict handler , src cluster , dest cluster , spec , optional . < path > empty ( ) , optional . < path > empty ( ) , directory copier , bool ) ; return new replication job ( conf , replication task , on state change handler , persisted job info ) ; }	create a replication job to copy a partition .
public static void main ( string ... args ) throws exception { string [ ] pages = { str , str , str , str , str , str , str , str , str , str , str , str } ; string builder buff = new string builder ( ) ; for ( string file name : pages ) { string text = get content ( file name ) ; for ( string page : pages ) { text = string utils . replace all ( text , page + str , str ) ; } text = disable railroads ( text ) ; text = remove header footer ( file name , text ) ; buff . append ( text ) ; } string final text = buff . to string ( ) ; file output = new file ( base dir , str ) ; print writer writer = new print writer ( new file writer ( output ) ) ; writer . println ( str + str ) ; writer . println ( str ) ; writer . println ( str + str ) ; writer . println ( str ) ; writer . println ( str + constants . get full version ( ) + str ) ; writer . println ( final text ) ; writer . println ( str ) ; writer . close ( ) ; }	this method is called when executing this application from the command line .
public static map < string , object > find orders ( dispatch context dctx , map < string , ? extends object > context ) { return find orders ( dctx , context , bool ) ; }	scipio : stock findorders service .
public static boolean is file exist ( string file path ) { if ( string utils . is blank ( file path ) ) { return bool ; } file file = new file ( file path ) ; return ( file . exists ( ) && file . is file ( ) ) ; }	indicates if this file represents a file on the underlying file system .
public static pronghorn stage find stage by path ( graph manager m , int ... path ) { int ordinal = path [ num ] ; int i = num ; int limit = m . stage id to stage . length ; while ( i < limit ) { if ( null != m . stage id to stage [ i ] ) { if ( - num == m . mult input ids [ m . stage id to inputs begin idx [ m . stage id to stage [ i ] . stage id ] ] ) { if ( -- ordinal <= num ) { return find stage by path ( m , m . stage id to stage [ i ] , num , path ) ; } } } i ++ ; } throw new unsupported operation exception ( str + path [ num ] ) ; }	start with ordinal selection of input stages then ordinal selection of each output ring there after . todo : do generic return that extends pronghornstage.
public static double [ ] calculate t ( double [ ] coef , double [ ] stderror , int k ) { double [ ] result = new double [ k ] ; for ( int i = num ; i < k ; i ++ ) { result [ i ] = coef [ i ] / stderror [ i ] ; } return result ; }	returns an array of the t - statistic of each coefficient in a multiple linear regression model .
static void run bootstrappers ( final core early component early , final list < heroic bootstrap > bootstrappers ) throws exception { for ( final heroic bootstrap bootstrap : bootstrappers ) { try { bootstrap . run ( early ) ; } catch ( exception e ) { throw new exception ( str + bootstrap , e ) ; } } }	this method basically goes through the list of bootstrappers registered by modules and runs them .
public static byte [ ] check index header id ( data input in , byte [ ] expected id ) throws io { byte id [ ] = new byte [ string helper . id length ] ; in . read bytes ( id , num , id . length ) ; if ( ! arrays . equals ( id , expected id ) ) { throw new corrupt index exception ( str + string helper . id to string ( expected id ) + str + string helper . id to string ( id ) , in ) ; } return id ; }	expert : just reads and verifies the object id of an index header.
public byte [ ] to byte array ( ) { byte [ ] b = output . to byte array ( ) ; byte array . write16bit ( num of entries , b , num ) ; return b ; }	returns the stack map table written out .
protected void save buffer ( string name ) { string buffer sb = m . get named buffer ( name ) ; if ( sb != null ) { if ( m . save ( sb ) ) { m . log message ( str ) ; } } }	save the currently selected clusterer output to a file .
public list < recommendation > schedule storage ( virtual array src varray , set < uri > requested v , uri src storage system , virtual pool src vpool , boolean is ha , virtual array requested ha varray , virtual pool ha vpool , virtual pool capability values wrapper capabilities , project project , vpool use vpool use , map < vpool use , list < recommendation > > current recommendations ) { log . info ( str ) ; if ( ! is ha ) { return schedule storage for local vplex ( src varray , requested v , src storage system , src vpool , capabilities , project , vpool use , current recommendations ) ; } else { return schedule storage for distributed vplex ( src varray , requested v , src storage system , src vpool , requested ha varray , ha vpool , capabilities , project , vpool use , current recommendations ) ; } }	get recommendations for resource placement based on the passed parameters .
@ not null public static list < string > complete relative path ( @ not null string base dir , @ not null string shown base dir , @ not null string relative path ) { list < string > result = lists . new linked list ( ) ; string bash base dir = os . to bash compatible ( base dir ) ; for ( string path : complete absolute path ( base dir + file . separator + relative path , predicates . < file > always true ( ) ) ) { if ( path . starts with ( bash base dir ) ) { result . add ( shown base dir + path . substring ( bash base dir . length ( ) ) ) ; } } return result ; }	collect a list of relative paths.
protected boolean is file specifying module specifier ( string specifier ) { return specifier . length ( ) > num && specifier . char at ( specifier . length ( ) - num ) != i . separator ; }	returns true if the given module specifier is specifying a file.
private void insert expected pool settings per tier ( cim capabilities path , map < string , object > key map ) { list < string > expected pool settings tier = ( list < string > ) key map . get ( constants . vnxpoolcapabilities tier ) ; expected pool settings tier . add ( capabilities path . to string ( ) + constants . hyphen + constants . no data movement ) ; expected pool settings tier . add ( capabilities path . to string ( ) + constants . hyphen + constants . auto tier ) ; expected pool settings tier . add ( capabilities path . to string ( ) + constants . hyphen + constants . high available tier ) ; expected pool settings tier . add ( capabilities path . to string ( ) + constants . hyphen + constants . low available tier ) ; expected pool settings tier . add ( capabilities path . to string ( ) + constants . hyphen + constants . start high then auto tier ) ; }	in vnx , 4 default policies are present , and this method creates expected settings per poolcapability .
private static final void transfer streams ( input stream source , output stream destination , string path , i monitor ) throws core exception { monitor = policy . monitor for ( monitor ) ; try { synchronized ( buffer ) { while ( bool ) { int bytes read = - num ; try { bytes read = source . read ( buffer ) ; } catch ( io e ) { string msg = nls . bind ( messages . failed read during write , path ) ; policy . error ( efs . error read , msg , e ) ; } try { if ( bytes read == - num ) { destination . close ( ) ; break ; } destination . write ( buffer , num , bytes read ) ; } catch ( io e ) { string msg = nls . bind ( messages . could not write , path ) ; policy . error ( efs . error write , msg , e ) ; } monitor . worked ( num ) ; } } } finally { policy . safe close ( source ) ; policy . safe close ( destination ) ; } }	transfers the contents of an input stream to an output stream , using a large buffer .
private int path position at level ( int org unit level ) { return ( org unit level - num ) * num + num ; }	returns the position within an orgunit path at which the orgunit uid will be found for a given orgunitlevel .
private int make available ( ) { if ( pos != - num ) { return num ; } total += tail - head - pad ; system . arraycopy ( buffer , tail - pad , buffer , num , pad ) ; head = num ; tail = pad ; for ( ; ; ) { int bytes read = num ; try { bytes read = input . read ( buffer , tail , buf size - tail ) ; } catch ( io e ) { throw new runtime exception ( str ) ; } if ( bytes read == - num ) { final string msg = str ; throw new malformed stream exception ( msg ) ; } tail += bytes read ; find separator ( ) ; int av = available ( ) ; if ( av > num || pos != - num ) { return av ; } } }	attempts to read more data .
protected void add numeric train class ( double class value , double weight ) { if ( class value > m ) { m = class value ; } if ( class value < m ) { m = class value ; } if ( m == null ) { m = new double [ num ] ; m = new double [ num ] ; } if ( m == m . length ) { double [ ] temp = new double [ m . length * num ] ; system . arraycopy ( m , num , temp , num , m . length ) ; m = temp ; temp = new double [ m . length * num ] ; system . arraycopy ( m , num , temp , num , m . length ) ; m = temp ; } m [ m ] = class value ; m [ m ] = weight ; m ++ ; }	adds a numeric ( non - missing ) training class value and weight to the buffer of stored values.
private list < group > parse groups ( json groups , string group type ) throws json , ade usage exception { if ( groups . length ( ) == num ) throw new ade usage exception ( str + group type ) ; list < group > current groups = new array list < group > ( ) ; for ( int i = num ; i < groups . length ( ) ; i ++ ) { json group = groups . get json ( i ) ; string name = group . get string ( str ) ; string data type = group . get string ( str ) ; short eval order = group . get short ( str ) ; string rule name = group . get string ( str ) ; if ( ! verify string param ( name , num , str ) || name . equals ignore case ( str ) || ! validate data type ( data type ) || eval order < num || ! verify string param ( rule name , num , str ) ) { throw new ade usage exception ( str + group type + str ) ; } current groups . add ( new group ( name , group type . value of ( group type ) , data type . value of ( data type . to upper case ( ) ) , eval order , rule name ) ) ; } validate evaluation order and name ( current groups ) ; return current groups ; }	main logic for parsing the groups from the json file.
@ override public void drag gesture recognized ( drag gesture event evt ) { drag entry drag entry = kse frame . drag selected entry ( ) ; if ( drag entry == null ) { return ; } image icon icon = drag entry . get image ( ) ; toolkit toolkit = toolkit . get default toolkit ( ) ; dimension dim = toolkit . get best cursor size ( icon . get icon width ( ) , icon . get icon height ( ) ) ; buffered image buff image = new buffered image ( dim . width , dim . height , buffered image . type int argb pre ) ; icon . paint icon ( evt . get component ( ) , buff image . get graphics ( ) , num , num ) ; cursor = toolkit . create custom cursor ( buff image , new point ( num , num ) , str ) ; evt . start drag ( cursor , new key store entry transferable ( drag entry ) , this ) ; }	drag gesture recognized . start the drag off if valid .
public static boolean is identifier helper char ( char ch ) { return str == ch || str == ch || str == ch || str == ch ; }	checks if specified character can be part of xml identifier ( tag name of attribute name ) and is not standard identifier character .
public void add header ( string line ) { header . add ( line ) ; }	add a header line to this result .
public static i load address ( final result set result set , final string column name ) throws sql { preconditions . check not null ( result set , str ) ; preconditions . check not null ( column name , str ) ; final string address string = read string ( result set , column name ) ; return result set . was null ( ) ? null : new c ( new big integer ( address string ) ) ; }	loads an address value from the database .
private static string encode ( string string to encode ) { string encoded ; try { encoded = url . encode ( string to encode , utf 8 ) ; } catch ( unsupported encoding exception e ) { throw new mc ( e ) ; } encoded = encoded . replace ( str , str ) ; encoded = encoded . replace ( str , str ) ; encoded = encoded . replace ( str , str ) ; return encoded ; }	formats the input string for inclusion in a url.
public static string to get url ( string url , bundle params ) { if ( params != null ) { if ( ! url . ends with ( str ) ) { url = url + str ; } for ( string key : params . key set ( ) ) { url = url + key + str + params . get string ( key ) + str ; } } return url ; }	returns get url with appended parameters .
public void namespace after start element ( string prefix , string uri ) throws sax { if ( m first tag not emitted && m first element uri == null && m first element name != null ) { string prefix1 = get prefix part ( m first element name ) ; if ( prefix1 == null && emptystring . equals ( prefix ) ) { m first element uri = uri ; } } start prefix mapping ( prefix , uri , bool ) ; }	this method is used when a prefix / uri namespace mapping is indicated after the element was started with a startelement ( ) and before and endelement ( ).
protected static string guess type ( file file ) { string name = file . get name ( ) ; string suffix = name . substring ( name . last index of ( str ) + num ) ; return mime map . get ( suffix . to lower case ( locale . root ) ) ; }	guesses the type of a file , based on file name suffix.
public void test advance all terms ( ) throws exception { list < string > terms list = new array list < > ( ) ; terms list . add all ( arrays . as list ( common terms ) ) ; terms list . add all ( arrays . as list ( medium terms ) ) ; terms list . add all ( arrays . as list ( rare terms ) ) ; string terms [ ] = terms list . to array ( new string [ num ] ) ; for ( int amount = num ; amount < num ; amount += num ) { for ( int min nr should match = num ; min nr should match <= terms . length ; min nr should match ++ ) { scorer expected = scorer ( terms , min nr should match , mode . doc values ) ; scorer actual = scorer ( terms , min nr should match , mode . scorer ) ; assert advance ( expected , actual , amount ) ; expected = scorer ( terms , min nr should match , mode . doc values ) ; actual = scorer ( terms , min nr should match , mode . bulk scorer ) ; assert advance ( expected , actual , amount ) ; } } }	test advance with giant bq of all terms with varying minshouldmatch.
public boolean is public ( ) { return modifier . is public ( get access flags ( ) ) ; }	returns true for a public class .
public boolean release encumbrance budget ( final map < string , object > details map ) { if ( details map == null ) throw new validation exception ( arrays . as list ( new validation error ( str , str ) ) ) ; details map . put ( constants . consumeorrelease , bool ) ; final big decimal bd = get details ( details map ) ; return bd . int value ( ) == num ; }	this api will be called for releasing the budget that was already allocated to some estimate or purchase order.
protected transferable create locale transferable ( long [ ] formats ) throws io { return null ; }	the clipboard must be opened .
public void put length ( int len ) throws io { if ( len < num ) { write ( ( byte ) len ) ; } else if ( len < ( num << num ) ) { write ( ( byte ) num ) ; write ( ( byte ) len ) ; } else if ( len < ( num << num ) ) { write ( ( byte ) num ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) len ) ; } else if ( len < ( num << num ) ) { write ( ( byte ) num ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) len ) ; } else { write ( ( byte ) num ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) ( len > > num ) ) ; write ( ( byte ) len ) ; } }	put the encoding of the length in the stream .
public void put generic font family ( string family name , font font ) { generic font families . put ( family name . to lower case ( ) , font ) ; }	adds a generic font family .
private boolean write reference ( object value , node map node ) { string name = get ( value ) ; int size = size ( ) ; if ( name != null ) { node . put ( refer , name ) ; return bool ; } string unique = string . value of ( size ) ; node . put ( mark , unique ) ; put ( value , unique ) ; return bool ; }	this is used to write the xml element attributes representing the serialized object instance.
private ns parse data ( ) throws parse exception { ns obj = null ; skip ( ) ; if ( accept ( data gsobject begin token ) ) { skip ( ) ; expect ( data gsbool begin token , data gsdate begin token , data gsint begin token , data gsreal begin token ) ; if ( accept ( data gsbool begin token ) ) { skip ( ) ; expect ( data gsbool true token , data gsbool false token ) ; if ( accept ( data gsbool true token ) ) { obj = new ns ( bool ) ; } else { obj = new ns ( bool ) ; } skip ( ) ; } else if ( accept ( data gsdate begin token ) ) { skip ( ) ; string date string = read input until ( data end token ) ; obj = new ns ( date string ) ; } else if ( accept ( data gsint begin token , data gsreal begin token ) ) { skip ( ) ; string number string = read input until ( data end token ) ; obj = new ns ( number string ) ; } read ( data end token ) ; } else { string data string = read input until ( data end token ) ; data string = data string . replace all ( str , str ) ; int num bytes = data string . length ( ) / num ; byte [ ] bytes = new byte [ num bytes ] ; for ( int i = num ; i < bytes . length ; i ++ ) { string byte string = data string . substring ( i * num , i * num + num ) ; int byte value = integer . parse int ( byte string , num ) ; bytes [ i ] = ( byte ) byte value ; } obj = new ns ( bytes ) ; skip ( ) ; } return obj ; }	parses a data object from the current parsing position.
public boolean empty ( ) { return individuals . size ( ) == num ; }	returns true is the population contains no individuals .
@ override public string format ( date time formatter formatter ) { objects . require non null ( formatter , str ) ; return formatter . format ( this ) ; }	formats this date - time using the specified formatter.
public @ dotted class name string to dotted class name ( ) { return class name . to dotted class name ( class name ) ; }	get the name of the class in dotted format .
public d ( j parent , string title , x509 extension set extensions , public key authority public key , x500 name authority cert name , big integer authority cert serial number , public key subject public key ) { super ( parent , dialog . modality type . document modal ) ; set title ( res . get string ( str ) ) ; this . extensions = extensions ; this . authority public key = authority public key ; this . authority cert name = authority cert name ; this . authority cert serial number = authority cert serial number ; this . subject public key = subject public key ; init components ( ) ; }	creates a new daddextensions dialog .
private void play next ( ) { if ( media type == config . youtube media type video ) { seek video ( num ) ; restart video ( ) ; return ; } if ( previous was called ) { previous was called = bool ; iterator . next ( ) ; } if ( ! iterator . has next ( ) ) { iterator = you tube videos . list iterator ( ) ; } video item = iterator . next ( ) ; next was called = bool ; play video ( ) ; }	plays next video in playlist.
public static < t > t invoke method ( object obj , string name , object ... params ) throws no such method exception { class [ ] param types = get param types ( params ) ; final class < ? > a class = obj . get class ( ) ; method method ; try { method = a class . get declared method ( name , param types ) ; } catch ( no such method exception e ) { method = a class . get method ( name , param types ) ; } method . set accessible ( bool ) ; try { return ( t ) method . invoke ( obj , params ) ; } catch ( illegal access exception | invocation target exception e ) { throw new runtime exception ( e ) ; } }	invokes a method by reflection .
public void add nodes ( node iterator iterator ) { if ( ! m mutable ) throw new runtime exception ( xsl . create xpath ( xpath . er nodeset not mutable , null ) ) ; if ( null != iterator ) { node obj ; while ( null != ( obj = iterator . next node ( ) ) ) { add element ( obj ) ; } } }	copy nodelist members into this nodelist , adding in document order.
public static rotate stream create ( path path ) { synchronized ( streams ) { weak reference < rotate stream > ref = streams . get ( path ) ; rotate stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new rotate stream ( path ) ; streams . put ( path , new weak reference < > ( stream ) ) ; } return stream ; } }	returns the rotate stream corresponding to this path.
private void clean up history ( ) { if ( ! m history of numbers . is empty ( ) && m history of numbers . size ( ) >= max history size ) { for ( int i = num ; i < math . max ( num , max history size / num ) ; i ++ ) { m previous numbers . remove ( m history of numbers . remove first ( ) ) ; } } }	removes old tracks and cleans up the history preparing for new tracks to be added to the mapping.
@ suppress warnings ( str ) protected void process styled attributes ( @ non null typed array a ) { float target aspect ratio x = math . abs ( a . get float ( r . styleable . ucrop u ucrop aspect ratio x , default aspect ratio ) ) ; float target aspect ratio y = math . abs ( a . get float ( r . styleable . ucrop u ucrop aspect ratio y , default aspect ratio ) ) ; if ( target aspect ratio x == source image aspect ratio || target aspect ratio y == source image aspect ratio ) { m target aspect ratio = source image aspect ratio ; } else { m target aspect ratio = target aspect ratio x / target aspect ratio y ; } }	this method extracts all needed values from the styled attributes.
public log message ( string template , int code ) { this ( template , null , empty string array , code , optional . empty ( ) ) ; }	construct a log message that does not involve any templating .
protected string action translate ( string act string , int act pos , hashtable label map , hashtable label types ) { int id start ; int pos ; int len ; string id str ; boolean in id ; string buffer result ; char buffer [ ] ; if ( act string == null || act string . length ( ) == num ) return act string ; len = act string . length ( ) ; result = new string buffer ( len + num ) ; buffer = new char [ len + num ] ; act string . get chars ( num , len , buffer , num ) ; buffer [ len ] = str ; in id = bool ; for ( pos = id start = num ; pos <= len ; pos ++ ) { if ( in id ) { if ( ! is id char ( buffer [ pos ] ) ) { id str = new string ( buffer , id start , pos - id start ) ; result . append ( label translate ( id str , act pos , label map , label types ) ) ; if ( buffer [ pos ] != str ) result . append ( buffer , pos , num ) ; in id = bool ; } else { } } else { if ( is id start ( buffer [ pos ] ) ) { in id = bool ; id start = pos ; } else { if ( buffer [ pos ] != str ) result . append ( buffer , pos , num ) ; } } } return result . to string ( ) ; }	translate all the label names within an action string to appropriate code .
public boolean can load ( ) { return bool ; }	the command will only load if this condition is true.
public boolean bool ( ) { return ( double . is na n ( m val ) || ( m val == num ) ) ? bool : bool ; }	cast result object to a boolean .
protected boolean strict parse boolean ( string s ) { if ( s == null || s . is empty ( ) ) { throw new illegal argument exception ( str ) ; } if ( s . equals ignore case ( str ) ) { return bool ; } if ( s . equals ignore case ( str ) ) { return bool ; } throw new illegal argument exception ( str + s ) ; }	we need this strict function because boolean . parseboolean silently ignores malformed strings.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case functionblock package . event name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case functionblock package . event properties : return properties != null && ! properties . is empty ( ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public string format ( date time formatter formatter ) { objects . require non null ( formatter , str ) ; return formatter . format ( this ) ; }	formats this time using the specified formatter.
private void initialize source code map ( string adapted content ) { source code with line = new linked hash map < > ( ) ; int line number = num ; string reader sr = new string reader ( adapted content ) ; buffered reader br = new buffered reader ( sr ) ; string line ; try { while ( ( line = br . read line ( ) ) != null ) { source code with line . put ( line number , line ) ; line number ++ ; } } catch ( io ex ) { logger . error ( str + ex . get message ( ) ) ; } }	initialisation of a local map that handles each source code line , keyed by the line number.
public matrix u ( ) { return u . clone ( ) ; }	return the left singular vectors.
protected set < string > allowed duplicate error codes ( ) { return collections . empty set ( ) ; }	override this if the should_not_contain_same_error_codes_for_different_instances_that_are_not_wrappers test is failing and you * really * want to allow one or more of your error codes to have duplicate apierrors that are not wrappers.
private boolean is field visited ( object object , field object field , field field ) { map < string , set < string > > bag = visited fields . get ( object ) ; if ( bag == null ) { return bool ; } string object filed key = object field == null ? str : object field . to generic string ( ) ; set < string > fields = bag . get ( object filed key ) ; return fields != null && fields . contains ( field ) ; }	indicates whether the field of a target object is visited.
public void remove from completed list ( download info runnable download info runnable ) { m completed list . remove ( download info runnable ) ; }	removes a download from the completed list .
protected void add shingled phrase queries ( final boolean query main query , final list < clause > clauses , final collection < field params > fields , int shingle size , final float tiebreaker , final int slop ) throws syntax error { if ( null == fields || fields . is empty ( ) || null == clauses || clauses . size ( ) < shingle size ) return ; if ( num == shingle size ) shingle size = clauses . size ( ) ; final int last clause index = shingle size - num ; string builder user phrase query = new string builder ( ) ; for ( int i = num ; i < clauses . size ( ) - last clause index ; i ++ ) { user phrase query . append ( str ) ; for ( int j = num ; j <= last clause index ; j ++ ) { user phrase query . append ( clauses . get ( i + j ) . val ) ; user phrase query . append ( str ) ; } user phrase query . append ( str ) ; user phrase query . append ( str ) ; } extended solr query parser pp = create edismax query parser ( this , impossible field name ) ; pp . add alias ( impossible field name , tiebreaker , get field boosts ( fields ) ) ; pp . set phrase slop ( slop ) ; pp . set remove stop filter ( bool ) ; pp . make dismax = bool ; pp . min clause size = num ; query phrase = pp . parse ( user phrase query . to string ( ) ) ; if ( phrase != null ) { main query . add ( phrase , boolean clause . occur . should ) ; } }	modifies the main query by adding a new optional query consisting of shingled phrase queries across the specified clauses using the specified field = & gt ; boost mappings .
public string as xml id ( ) { return datatype converter . print hex binary ( token digest . get value ( ) ) ; }	return an id conformant to xml id.
public void create snapshot ( ) throws backup exception { logger . debug ( str + this . snapshot name ) ; process helper . exec ( str , lvcreate cmd ) ; }	creates a new snapshot , which is assumed not to exist already .
public final uri store log file ( final log file log file , final int session id ) { final content values values = new content values ( ) ; values . put ( schema . col manufacturer , log file . get manufacturer ( ) ) ; values . put ( schema . col model , log file . get model ( ) ) ; values . put ( schema . col revision , log file . get revision ( ) ) ; values . put ( schema . col swid , log file . get swid ( ) ) ; values . put ( schema . col swver , log file . get sw version ( ) ) ; values . put ( schema . col timestamp , system . current time millis ( ) ) ; values . put ( schema . col session id , session id ) ; return content resolver . insert ( content provider . content uri logfile , values ) ; }	persists logfile in database .
public map < string , string > merge ( map < string , string > cur props , map < string , string > new props ) throws io { map < string , string > props = new hash map < > ( new props ) ; for ( map . entry < string , string > e : cur props . entry set ( ) ) { string name = e . get key ( ) ; string cur value = e . get value ( ) ; if ( props . contains key ( name ) ) { props . put ( name , cur value ) ; } } return props ; }	merges two bunches of the properties from current and new configurations .
public builder delete preferred language ( ) { delete fields . add ( str ) ; return this ; }	delete the preferred language of a existing user.
public void on prepared ( media player player ) { m state = state . playing ; update notification ( string . format ( get string ( r . string . media state playing ) , m file . get file name ( ) ) ) ; if ( m media controller != null ) { m media controller . set enabled ( bool ) ; } player . seek to ( m start position ) ; config and start media player ( ) ; if ( ! m play on prepared ) { process pause request ( ) ; } if ( m media controller != null ) { m media controller . update pause play ( ) ; } }	called when media player is done preparing.
private void parse parameter ( string token , string value ) { if ( token != null && value != null ) { if ( token . equals ignore case ( nonce token ) ) { m nonce = value ; return ; } if ( token . equals ignore case ( stale token ) ) { parse stale ( value ) ; return ; } if ( token . equals ignore case ( opaque token ) ) { m opaque = value ; return ; } if ( token . equals ignore case ( qop token ) ) { m qop = value . to lower case ( ) ; return ; } if ( token . equals ignore case ( algorithm token ) ) { m algorithm = value . to lower case ( ) ; return ; } } }	if the token is a known parameter name , parses and initializes the token value .
public void skip ( int n ) throws io { dis . skip ( n ) ; }	skip a set amount of bytes .
public void to all in radius ( world server world , vec3d pos , double radius ) { double max distance = radius * radius + radius * radius + radius * radius ; to all ( world . get players ( mp . class , null ) ) ; }	sends this packet to all the players in the world within the radius.
public static ecdhe from named curve id ( int supported group id ) { supported group group = supported group . from id ( supported group id ) ; if ( group == null ) { return null ; } else { try { return new ecdhe ( group . name ( ) ) ; } catch ( general security exception e ) { logger . log ( level . warning , str , new object [ ] { group . name ( ) , e . get message ( ) } ) ; return null ; } } }	creates an ephemeral ecdh key pair for a supported group ( named curve ) .
private static void add header ( message message , string name , string value ) { map < string , list < string > > protocol headers = cast utils . cast ( ( map < ? , ? > ) message . get ( message . protocol headers ) ) ; if ( protocol headers == null ) { protocol headers = new tree map < string , list < string > > ( string . case insensitive order ) ; message . put ( message . protocol headers , protocol headers ) ; } list < string > header = cast utils . cast ( ( list < ? > ) protocol headers . get ( name ) ) ; if ( header == null ) { header = new array list < string > ( ) ; protocol headers . put ( name , header ) ; } if ( header . size ( ) == num ) { header . add ( value ) ; } else { header . set ( num , header . get ( num ) + str + value ) ; } }	adds a value to a header.
public string as string ( ) { string builder buff = new string builder ( ) ; for ( int i = num ; i < array level ; i ++ ) { if ( ref count ) { buff . append ( str ) ; } buff . append ( str ) ; } if ( ref count ) { if ( ! class obj . is primitive ) { buff . append ( str ) ; } } buff . append ( class obj . to string ( ) ) ; if ( ref count ) { if ( ! class obj . is primitive ) { buff . append ( str ) ; } } for ( int i = num ; i < array level ; i ++ ) { if ( ref count ) { buff . append ( str ) ; } else { if ( ! class obj . is primitive ) { buff . append ( str ) ; } } buff . append ( str ) ; } if ( ! ref count ) { if ( is object ( ) ) { buff . append ( str ) ; } } return buff . to string ( ) ; }	get the c + + code .
public boolean recreate workspace table ( sq db ) { db . begin transaction ( ) ; try { cursor c = db . query ( table workspace screens , new string [ ] { launcher settings . workspace screens . id } , null , null , null , null , launcher settings . workspace screens . screen rank ) ; array list < long > sorted i = new array list < long > ( ) ; long max id = num ; try { while ( c . move to next ( ) ) { long id = c . get long ( num ) ; if ( ! sorted i . contains ( id ) ) { sorted i . add ( id ) ; max id = math . max ( max id , id ) ; } } } finally { c . close ( ) ; } db . exec sql ( str + table workspace screens ) ; add workspaces table ( db , bool ) ; int total = sorted i . size ( ) ; for ( int i = num ; i < total ; i ++ ) { content values values = new content values ( ) ; values . put ( launcher settings . workspace screens . id , sorted i . get ( i ) ) ; values . put ( launcher settings . workspace screens . screen rank , i ) ; add modified time ( values ) ; db . insert or throw ( table workspace screens , null , values ) ; } db . set transaction successful ( ) ; m max screen id = max id ; } catch ( sql ex ) { log . e ( tag , ex . get message ( ) , ex ) ; return bool ; } finally { db . end transaction ( ) ; } return bool ; }	recreates workspace table and migrates data to the new table .
public list < json object > execute parametrized statement ( string statement , list < string > parameter names , list < object > parameter values ) { json object named params = json object . create ( ) ; for ( int param = num ; param < parameter names . size ( ) ; param ++ ) { named params . put ( parameter names . get ( param ) , parameter values . get ( param ) ) ; } parameterized n1ql query query = n1ql query . parameterized ( statement , named params ) ; return execute query ( query ) ; }	executes a n1ql statement with named parameters .
public final t end all ( ) { while ( ! tag stack . is empty ( ) ) { end ( ) ; } return get self ( ) ; }	closes all open tags .
public void entity reference ( string name ) throws org . xml . sax . sax { append ( m doc . create entity reference ( name ) ) ; }	receive notivication of a entityreference .
private boolean link last ( node < e > node ) { if ( count >= capacity ) return bool ; node < e > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; not empty . signal ( ) ; return bool ; }	links node as last element , or returns false if full .
void draw divider ( canvas canvas , rect bounds , int child index ) { final drawable divider = m divider ; final boolean clip divider = m clip divider ; if ( ! clip divider ) { divider . set bounds ( bounds ) ; } else { canvas . save ( ) ; canvas . clip rect ( bounds ) ; } divider . draw ( canvas ) ; if ( clip divider ) { canvas . restore ( ) ; } }	draws a divider for the given child in the given bounds .
protected form spec ( default alignment default alignment , string encoded description ) { this ( default alignment , sizes . default , no grow ) ; parse and init values ( encoded description . to lower case ( locale . english ) ) ; }	constructs a formspec from the specified encoded description.
public static < t > list < t > decode ( input stream data , parser < t > parser ) throws io { coded input stream stream = coded input stream . new instance ( data ) ; list < t > list = new array list < > ( ) ; while ( ! stream . is at end ( ) ) { int size = stream . read raw varint32 ( ) ; byte [ ] element = stream . read raw bytes ( size ) ; t decoded = parser . parse from ( element ) ; list . add ( decoded ) ; } return list ; }	decode custom protobuf variable length array .
public static void write int ( data output out , int v ) throws io { out . write byte ( num & v ) ; out . write byte ( num & ( v > > > num ) ) ; out . write byte ( num & ( v > > > num ) ) ; out . write byte ( num & ( v > > > num ) ) ; }	writes a little - endian int .
public void write field ( final string name , final double value ) throws java . io . io { write field ( name , double . to string ( value ) ) ; }	writes an double field value .
public creature calculate next creature ( final int quest level ) { final list < creature > possible creatures to spawn = new array list < creature > ( ) ; int last level = num ; for ( final creature creature : sorted creatures ) { if ( creature . get level ( ) > quest level ) { break ; } if ( creature . get level ( ) > last level ) { possible creatures to spawn . clear ( ) ; last level = creature . get level ( ) ; } possible creatures to spawn . add ( creature ) ; } creature creature to spawn = null ; if ( possible creatures to spawn . size ( ) == num ) { creature to spawn = sorted creatures . get ( sorted creatures . size ( ) - num ) ; } else { collections . shuffle ( possible creatures to spawn ) ; creature to spawn = possible creatures to spawn . get ( num ) ; } return creature to spawn ; }	calculates which type of creature should be spawned next .
@ override public void before ( property info rest rep old props , property info rest rep new props ) { string new interval str = new props . get property ( backup constants . schedule interval ) ; string new start time str = new props . get property ( backup constants . schedule time ) ; if ( ( new interval str == null || new interval str . is empty ( ) ) && ( new start time str == null || new start time str . is empty ( ) ) ) { log . info ( str ) ; return ; } string interval str = ( new interval str == null || new interval str . is empty ( ) ) ? old props . get property ( backup constants . schedule interval ) : new interval str ; string start time str = ( new start time str == null || new start time str . is empty ( ) ) ? old props . get property ( backup constants . schedule time ) : new start time str ; log . info ( str , interval str , start time str ) ; validate backup interval and start time ( interval str , start time str ) ; }	check if backup related configurations conformed to rules , if not fail the property update .
@ override public void delete trait ( string guid , string trait name to be deleted ) throws atlas exception { guid = param checker . not empty ( guid , str ) ; trait name to be deleted = param checker . not empty ( trait name to be deleted , str ) ; if ( ! type system . is registered ( trait name to be deleted ) ) { final string msg = string . format ( str , trait name to be deleted ) ; log . error ( msg ) ; throw new type not found exception ( msg ) ; } repository . delete trait ( guid , trait name to be deleted ) ; on trait deleted from entity ( repository . get entity definition ( guid ) , trait name to be deleted ) ; }	deletes a given trait from an existing entity represented by a guid .
public void add tables ( collection < table > tables ) { for ( iterator < table > it = tables . iterator ( ) ; it . has next ( ) ; ) { add table ( ( table ) it . next ( ) ) ; } }	adds the given tables .
protected void write file ( string template , writer writer ) { if ( template == null ) { throw new illegal argument exception ( str ) ; } buffered writer buffered writer = new buffered writer ( writer ) ; string output = replace ( template , null ) ; try { buffered writer . append ( output ) ; } catch ( io e ) { logger . log ( diagnostic . kind . error , str ) ; e . print stack trace ( ) ; } finally { try { buffered writer . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } }	replace placeholder in template.
public synchronized boolean clear ( ) { if ( is loading ( ) ) { return bool ; } loader = new thread ( null ) ; loader . start ( ) ; return bool ; }	will clear the current classes and reload in another thread .
public int index of ( final rounded tool item item ) { check widget ( ) ; return items . index of ( item ) ; }	searches the receiver ' s list starting at the first item ( index 0 ) until an item is found that is equal to the argument , and returns the index of that item.
public void add attribute ( string alias , string type uri , boolean required , int count ) throws message exception { if ( alias . index of ( str ) > - num || alias . index of ( str ) > - num || alias . index of ( str ) > - num || alias . index of ( str ) > - num ) throw new message exception ( str + alias ) ; parameters . set ( new parameter ( str + alias , type uri ) ) ; string level = required ? str : str ; parameter level param = parameters . get parameter ( level ) ; parameter new param ; if ( level param == null ) { new param = new parameter ( level , alias ) ; } else { new param = new parameter ( level , level param . get value ( ) + str + alias ) ; parameters . remove parameters ( level ) ; } parameters . set ( new param ) ; set count ( alias , count ) ; if ( debug ) log . debug ( str + type uri + str + alias + str + count + str + required ) ; }	adds an attribute to the fetch request .
public void call ( ) throws exception { final list < future < void > > tasks = new linked list < future < void > > ( ) ; try { for ( iv < ? , ? > term id : graphs ) { final future task < void > ft = new future task < void > ( new drain iterator task ( term id ) ) ; tasks . add ( ft ) ; executor . execute ( ft ) ; } for ( future < void > f : tasks ) { f . get ( ) ; } } catch ( throwable ex ) { for ( future < void > f : tasks ) f . cancel ( bool ) ; throw new runtime exception ( ex ) ; } finally { buffer . close ( ) ; } return null ; }	outer callable submits tasks for execution .
protected void run full import ( string data config , map < string , string > extra params ) throws exception { hash map < string , string > params = new hash map < > ( ) ; params . put ( str , str ) ; params . put ( str , str ) ; params . put ( str , data config ) ; params . put ( str , str ) ; params . put ( str , str ) ; params . put all ( extra params ) ; named list l = new named list ( ) ; for ( map . entry < string , string > e : params . entry set ( ) ) { l . add ( e . get key ( ) , e . get value ( ) ) ; } local solr query request request = new local solr query request ( h . get core ( ) , l ) ; h . query ( str , request ) ; }	runs a full - import using the given dataconfig and the provided request parameters.
public string user id from range ( object omin id , object omax id ) { int min id = function handler . get int ( omin id ) ; int max id = function handler . get int ( omax id ) ; stack < integer > stack = get stack ( min id , max id ) ; if ( stack . size ( ) > num ) { return integer . to string ( stack . pop ( ) ) ; } throw new illegal argument exception ( str ) ; }	generate a random user id in the range provided.
public void start ( ) { if ( is started ) { log . info ( str ) ; return ; } log . info ( str ) ; system consumer . start ( ) ; is started = bool ; }	starts the underlying systemconsumer .
public static void generate binary operation flags ( final i environment , final long next offset , final string result , final operand size result size , final list < reil instruction > instructions ) throws illegal argument exception { preconditions . check not null ( environment , str ) ; preconditions . check not null ( result , str ) ; preconditions . check not null ( result size , str ) ; preconditions . check not null ( instructions , str ) ; final long base offset = next offset - instructions . size ( ) ; long offset = next offset ; generate sign flag code ( environment , offset , result , result size , instructions ) ; offset = ( base offset + instructions . size ( ) ) - num ; instructions . add ( reil helpers . create bisz ( offset + num , result size , result , operand size . byte , helpers . zero flag ) ) ; instructions . add ( reil helpers . create str ( offset + num , operand size . byte , str , operand size . byte , helpers . carry flag ) ) ; instructions . add ( reil helpers . create str ( offset + num , operand size . byte , str , operand size . byte , helpers . overflow flag ) ) ; }	sets the flags according to the result of a binary and / or / xor operation .
public boolean is label movable ( ) { mx graph graph = graph component . get graph ( ) ; string label = graph . get label ( state . get cell ( ) ) ; return graph . is label movable ( state . get cell ( ) ) && label != null && label . length ( ) > num ; }	returns true if the label is movable .
public int write type list ( type list type list ) { int off = data . position ( ) ; short [ ] types = type list . types ; write int ( types . length ) ; for ( short type : types ) { write short ( type ) ; } return off ; }	write typelist item into current section .
public static void load config resource ( string resource name ) throws io { config . clear ( ) ; config . put all ( load properties from resource ( resource name ) ) ; }	load configuration from resource in current class loader .
public static void safe close stream ( input stream in ) { if ( in != null ) { try { in . close ( ) ; } catch ( exception e ) { log . error ( e . get message ( ) , e ) ; } } }	close streams without pain.
private transaction create transaction ( ) throws lease denied exception , remote exception , transaction exception { i transaction manager provider = get transaction manager provider ( ) ; return ( transaction factory . create ( transaction manager provider . get transaction manager ( ) , config . get transaction timeout ( ) ) ) . transaction ; }	create new transaction using the local transaction manager.
public void skip while ( string skip ) throws io { char ch ; do { ch = read ( ) ; } while ( skip . index of ( ch ) > - num ) ; unread character ( ch ) ; }	skips char any contiguous characters in skip.
public static string package to path ( string package name ) { return package name . replace ( str , file . separator char ) ; }	converts a package name to a path by replacing all '.
@ override public boolean contains key ( object key ) { if ( key == null ) { return entry for null key != null ; } int hash = key . hash code ( ) ; hash ^= ( hash > > > num ) ^ ( hash > > > num ) ; hash ^= ( hash > > > num ) ^ ( hash > > > num ) ; hash map entry < k , v > [ ] tab = table ; for ( hash map entry < k , v > e = tab [ hash & ( tab . length - num ) ] ; e != null ; e = e . next ) { k e key = e . key ; if ( e key == key || ( e . hash == hash && key . equals ( e key ) ) ) { return bool ; } } return bool ; }	returns whether this map contains the specified key .
protected boolean is valid fragment ( string fragment ) { if ( fragment == null ) { return bool ; } return is off ( no fragments ) ; }	returns true if the given fragment is null or fragments are allowed .
private void rehash ( ) { int old capacity = m capacity ; hash entry [ ] old table = m table ; int new capacity = num * old capacity + num ; m capacity = new capacity ; m threshold = ( int ) ( new capacity * m load factor ) ; m table = new hash entry [ new capacity ] ; for ( int i = old capacity - num ; i >= num ; i -- ) { for ( hash entry old = old table [ i ] ; old != null ; ) { hash entry e = old ; old = old . next ; int new index = e . hash % new capacity ; if ( new index < num ) new index = - new index ; e . next = m table [ new index ] ; m table [ new index ] = e ; } } }	increases the capacity of and internally reorganizes the hashtable , in order to accommodate and access its entries more efficiently.
public void save pois from assets ( ) { list < poi > pois = poi asset loader . load pois from assets ( ) ; timber . d ( str , pois . size ( ) ) ; for ( poi poi : pois ) { timber . d ( str , poi ) ; save poi ( poi ) ; timber . d ( str ) ; } }	load pois from assets and save them in the database .
private void create element ( document doc , element parent element , string element name , color value ) { element element = doc . create element ( element name ) ; element . append child ( doc . create text node ( colour utils . from colour ( value ) ) ) ; parent element . append child ( element ) ; }	creates the xml element for a colour value .
public static boolean been done ( @ scope int scope , string tag , count checker number of times ) { list < long > tag seen dates = tag last seen map . get ( tag ) ; if ( tag seen dates . is empty ( ) ) { return bool ; } if ( scope == this app install ) { return number of times . check ( tag seen dates . size ( ) ) ; } else if ( scope == this app session ) { int counter = num ; for ( string tag from list : session list ) { if ( tag from list . equals ( tag ) ) { counter ++ ; } } return number of times . check ( counter ) ; } else { int counter = num ; for ( long seen date : tag seen dates ) { if ( seen date > last app updated time ) { counter ++ ; } } return number of times . check ( counter ) ; } }	checks if a tag has been marked done within a given scope a specific number of times .
void variable operator changed ( int row , string oper ) { conditional variable variable = variable list . get ( row ) ; int old oper = variable . get opern ( ) ; if ( row > num ) { if ( oper . equals ( bundle . get message ( str ) ) ) { variable . set opern ( conditional . operator or ) ; } else { variable . set opern ( conditional . operator and ) ; } } else { variable . set opern ( conditional . operator none ) ; } if ( variable . get opern ( ) != old oper ) { make antecedent ( ) ; } }	responds to the operator column in the edit conditional window.
public void add header ( string name , string val ) { m msg header = m msg header + name + str + val + m line delimiter ; add internal header fields ( name , val ) ; }	add a header with the name and value given.
public static void check duplicate request ( redis client redis client , string uri , buffer buffer , string ttl , handler < boolean > callback ) { integer time to live = parse time to live ( ttl ) ; string redis key = get redis key ( uri , hash code generator . create hash code ( uri , buffer . to string ( ) ) ) ; handle storage ( redis client , redis key , time to live , callback ) ; }	this method checks if an entry for the provided information ( uri and buffer ) is stored in the redis database.
boolean is hidden ( view view ) { return m hidden views . contains ( view ) ; }	returns whether a view is visible to layoutmanager or not .
public static void delete recursive ( @ non null file file or directory ) { delete recursive ( file or directory , collections . empty list ) ; }	deletes a file or directory and all its content recursively .
static boolean does menu bar border tool bar ( j c ) { j tb = ( j ) ui . find registered component of type ( c , j . class ) ; if ( tb != null && tb . get orientation ( ) == j . horizontal ) { j rp = swing utilities . get root pane ( c ) ; point point = new point ( num , num ) ; point = swing utilities . convert point ( c , point , rp ) ; int menu x = point . x ; int menu y = point . y ; point . x = point . y = num ; point = swing utilities . convert point ( tb , point , rp ) ; return ( point . x == menu x && menu y + c . get height ( ) == point . y && c . get width ( ) == tb . get width ( ) ) ; } return bool ; }	returns true if the passed in jmenubar is above a horizontal jtoolbar .
void construct node ( string node name , string prefix , string node namespace , transformer impl transformer ) throws transformer exception { boolean should add attrs ; try { serialization handler rhandler = transformer . get result tree handler ( ) ; if ( null == node name ) { should add attrs = bool ; } else { if ( null != prefix ) { rhandler . start prefix mapping ( prefix , node namespace , bool ) ; } rhandler . start element ( node namespace , q . get local part ( node name ) , node name ) ; super . execute ( transformer ) ; should add attrs = bool ; } transformer . execute child templates ( this , should add attrs ) ; if ( null != node name ) { rhandler . end element ( node namespace , q . get local part ( node name ) , node name ) ; if ( null != prefix ) { rhandler . end prefix mapping ( prefix ) ; } } } catch ( sax se ) { throw new transformer exception ( se ) ; } }	construct a node in the result tree.
private priority queue < us > create queue ( string field name , map < string , flt > words ) throws io { int num docs = ir . num docs ( ) ; q res = new q ( words . size ( ) ) ; for ( string word : words . key set ( ) ) { float tf = words . get ( word ) . x ; if ( min term freq > num && tf < min term freq ) { continue ; } int doc freq = ir . doc freq ( new term ( field name , word ) ) ; if ( min doc freq > num && doc freq < min doc freq ) { continue ; } if ( doc freq == num || doc freq > max doc freq ) { continue ; } float idf = similarity . idf ( doc freq , num docs ) ; float score = num ; if ( is log tf ( ) ) { score = ( float ) ( math . log ( tf + num ) * idf ) ; } else { score = tf * idf ; } us mlt field ; if ( is payload field ( field name ) ) { mlt field = new us ( word , field name , score , tf , idf , doc freq , num ) ; } else { mlt field = new us ( word , field name , score , tf , idf , doc freq ) ; } res . insert with overflow ( mlt field ) ; } return res ; }	create a priorityqueue from a word - > tf map .
public static void each object ( object input stream ois , closure closure ) throws io , class not found exception { try { while ( bool ) { try { object obj = ois . read object ( ) ; closure . call ( obj ) ; } catch ( eof e ) { break ; } } input stream temp = ois ; ois = null ; temp . close ( ) ; } finally { close with warning ( ois ) ; } }	iterates through the given object stream object by object.
private static int exit with status ( int status ) { if ( io . get mode ( ) == io . system ) { system . exit ( status ) ; } return status ; }	if run in the system mode , exits the program , in tool mode returns the status.
public static double distance in meters ( final double lat p1 , final double lat p2 , final double lon p1 , final double lon p2 ) { double dist rad = math . acos ( math . sin ( to radians ( lat p1 ) ) * math . sin ( to radians ( lat p2 ) ) + math . cos ( to radians ( lat p1 ) ) * math . cos ( to radians ( lat p2 ) ) * math . cos ( to radians ( lon p1 - lon p2 ) ) ) ; final double dist as degree = to degrees ( dist rad ) ; return dist as degree * num * num * num ; }	computes the distance between two coordinates in meters .
public void process challenge ( final string challenge ) throws malformed challenge exception { string s = auth challenge parser . extract scheme ( challenge ) ; if ( ! s . equals ignore case ( get scheme name ( ) ) ) { throw new malformed challenge exception ( str + challenge ) ; } int i = challenge . index of ( str ) ; if ( i != - num ) { s = challenge . substring ( i , challenge . length ( ) ) ; this . ntlmchallenge = s . trim ( ) ; this . state = typ msg received ; } else { this . ntlmchallenge = str ; if ( this . state == uninitiated ) { this . state = initiated ; } else { this . state = failed ; } } }	processes the ntlm challenge .
public static big integer calculate a ( big integer p , big integer q , big integer g a , big integer x2s ) { return g a . mod pow ( x2s , p ) ; }	calculate a as done in round 2 .
public static m add ( m product , int m id , m as , int ad id , int m id , big decimal amt , big decimal qty , int precision , m cd , string trx name ) { if ( c . is level fine ( ) ) s log . fine ( str + ad id + str + product . get id ( ) + str + m id + str + amt + str + qty + str + precision ) ; m cq = new m ( product , m id , as , ad id , m id , trx name ) ; cq . set costs ( amt , qty , precision ) ; cq . set date acct ( cd . get date acct ( ) ) ; cq . save ex ( ) ; if ( c . is level fine ( ) ) s log . fine ( str + cq ) ; return cq ; }	push to queue record . costinglevel is not validated.
public void add undo event ( undo interface event ) { if ( should process undo redo action ( ) ) { boolean at end of list = ( current index >= undo list . size ( ) ) ; if ( ! at end of list ) { while ( undo list . size ( ) > current index ) { int last index = undo list . size ( ) - num ; undo list . remove ( last index ) ; } } undo list . add ( event ) ; current index = undo list . size ( ) ; update menu items ( ) ; logger . debug ( event . get string representation ( ) ) ; } }	adds the undo event .
public static exception establish cache if needed ( print stream ... progress ) { if ( m offline ) { return null ; } if ( rep mirror == null ) { establish mirror ( ) ; } exception problem = null ; if ( initial cache build needed ) { for ( print stream p : progress ) { p . println ( str ) ; } problem = refresh cache ( progress ) ; initial cache build needed = bool ; } return problem ; }	establish the local copy of the package meta data if needed.
public spanny append ( char sequence text , image span image span ) { text = str + text ; append ( text ) ; set span ( image span , length ( ) - text . length ( ) , length ( ) - text . length ( ) + num ) ; return this ; }	add the imagespan to the start of the text .
public static boolean validate password ( string password , string correct hash ) throws no such algorithm exception , invalid key spec exception { return validate password ( password . to char array ( ) , correct hash ) ; }	validates a password using a hash .
public list < snapshot > current snapshots ( string repository name ) { list < snapshot > snapshot list = new array list < > ( ) ; list < snapshots in progress . entry > entries = current snapshots ( repository name , null ) ; for ( snapshots in progress . entry entry : entries ) { snapshot list . add ( in progress snapshot ( entry ) ) ; } collection util . tim sort ( snapshot list ) ; return collections . unmodifiable list ( snapshot list ) ; }	returns a list of currently running snapshots from repository sorted by snapshot creation date.
public void add certificate ( x509 certificate holder certificate ) throws cms { certs . add ( certificate . to as ( ) ) ; }	add a certificate to the certificate set to be included with the generated signeddata message .
public void test case8 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = big integer . zero ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	multiply a number by zero .
private void clean static ( method node method ) { }	finds the begining of the zkm blurb , the end , then removed everything in between !.
@ override protected void paint tab background ( graphics g , int tab placement , int tab index , int x , int y , int w , int h , boolean is selected ) { if ( is selected ) { if ( tab placement == top ) { g . set color ( color . white ) ; g . fill round rect ( x , y , w , h + r + r , r , r ) ; } } else { } }	give selected tab blue color with a gradient ! ! . fixme : with plastic l & f the unselected background is too dark.
private automaton build automaton ( bytes ref hash term bytes hash ) { final tree set < bytes ref > terms = new tree set < bytes ref > ( ) ; for ( int i = num ; i < term bytes hash . size ( ) ; i ++ ) { bytes ref ref = new bytes ref ( ) ; term bytes hash . get ( i , ref ) ; terms . add ( ref ) ; } final automaton a = daciuk mihov automaton builder . build ( terms ) ; return a ; }	build an automaton to represent the frontier query.
protected range find range bounds ( category dataset dataset , boolean include interval ) { if ( dataset == null ) { return null ; } if ( get data bounds includes visible series only ( ) ) { list visible series keys = new array list ( ) ; int series count = dataset . get row count ( ) ; for ( int s = num ; s < series count ; s ++ ) { if ( is series visible ( s ) ) { visible series keys . add ( dataset . get row key ( s ) ) ; } } return dataset utilities . find range bounds ( dataset , visible series keys , include interval ) ; } else { return dataset utilities . find range bounds ( dataset , include interval ) ; } }	returns the range of values the renderer requires to display all the items from the specified dataset .
protected string admin shutdown ( ) { server . shutdown ( ) ; return str ; }	stop the application and the server .
public long num threads ( ) { return long . parse long ( fields [ num ] ) ; }	number of threads in this process ( since linux 2.
public void assign role ( am role ) throws am , sso { assign role ( role . get dn ( ) ) ; }	assigns a role to the user .
public ordered thread pool executor ( int core pool size , int maximum pool size ) { this ( core pool size , maximum pool size , default keep alive , time unit . seconds , executors . default thread factory ( ) , null ) ; }	creates a default threadpool , with default values : - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
protected void write initial styles ( ) throws io { out . flush bits ( ) ; fill bits = out stream . determine unsigned bit size ( fill styles . size ( ) ) ; line bits = out stream . determine unsigned bit size ( line styles . size ( ) ) ; if ( ! has style ) { fill bits = num ; } else { write styles ( fill styles ) ; write styles ( line styles ) ; out . flush bits ( ) ; } out . write u ( num , fill bits ) ; out . write u ( num , line bits ) ; }	description of the method.
public static < t extends map . entry < string , string > > string form encode ( collection < t > parameters ) throws io { byte array output stream b = new byte array output stream ( ) ; form encode ( parameters , b ) ; return new string ( b . to byte array ( ) ) ; }	construct a x - www - form - urlencoded document containing the given sequence of name / value pairs.
public void test single resource locking serialized low concurrency2 ( ) throws exception { properties properties = new properties ( ) ; properties . set property ( test options . nthreads , str ) ; properties . set property ( test options . ntasks , str ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; do comparison test ( properties ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized .
public void run next pending command ( ) { runnable runnable = delta queue . pop ( ) ; runnable . run ( ) ; }	runs the next command scheduled to be executed immediately .
public void stop ( int timeout ) throws interrupted exception { if ( ! isclosed . compare and set ( bool , bool ) ) { return ; } list < web socket > sockets to close = null ; synchronized ( connections ) { sockets to close = new array list < web socket > ( connections ) ; } for ( web socket ws : sockets to close ) { ws . close ( close frame . going away ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread != thread . current thread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }	closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads.
private static document load document ( resource xml file ) throws sax , io { dom parser = new dom ( ) ; input stream is = null ; try { is = io . to buffered input stream ( xml file . get input stream ( ) ) ; input source source = new input source ( is ) ; parser . parse ( source ) ; } finally { io . close el ( is ) ; } return parser . get document ( ) ; }	load xml document from xml file.
public void test down ( ) { string a = str ; string b = str ; rounding mode rm = rounding mode . down ; string c = str ; big decimal a number = new big decimal ( new big integer ( a ) ) ; big decimal b number = new big decimal ( new big integer ( b ) ) ; big decimal result = a number . divide ( b number , rm ) ; assert equals ( str , c , result . to string ( ) ) ; }	java . math . bigdecimal # divide ( java . math . bigdecimal , java . math . roundingmode ) divide ( bigdecimal , roundingmode ).
public void remove annotation ( int index ) { m annotations . remove ( index ) ; m string xy . remove by index ( index ) ; }	remove an string at index.
public string replace ( char old char , char new char ) { char [ ] buffer = value ; int offset = offset ; int count = count ; int idx = offset ; int last = offset + count ; boolean copied = bool ; while ( idx < last ) { if ( buffer [ idx ] == old char ) { if ( ! copied ) { char [ ] new buffer = new char [ count ] ; system . arraycopy ( buffer , offset , new buffer , num , count ) ; buffer = new buffer ; idx -= offset ; last -= offset ; copied = bool ; } buffer [ idx ] = new char ; } idx ++ ; } return copied ? new string ( num , count , buffer ) : this ; }	copies this string replacing occurrences of the specified character with another character .
public static void touch ( file file ) throws io { if ( ! file . exists ( ) ) { output stream out = open output stream ( file ) ; io . close quietly ( out ) ; } boolean success = file . set last modified ( system . current time millis ( ) ) ; if ( ! success ) { throw new io ( str + file ) ; } }	implements the same behaviour as the " touch " utility on unix.
private < type extends message > rpc callback < type > wraps callback ( mock callback < ? > callback ) { easy mock . report matcher ( new wraps callback ( callback ) ) ; return null ; }	wrapscallback ( ) is an easymock argument predicate.
public boolean should select cell ( event object e ) { log . finest ( m m field . get column name ( ) ) ; return bool ; }	the editing cell should be selected or not.
public void test case18 ( ) { byte a bytes [ ] = { num } ; byte b bytes [ ] = { num } ; byte r bytes [ ] = { num } ; int a sign = num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add zero to zero.
@ nonnull public bug instance add class ( class node class node ) { string dotted class name = class name . to dotted class name ( class node . name ) ; class annotation class annotation = new class annotation ( dotted class name ) ; add ( class annotation ) ; return this ; }	add a class annotation for the classnode .
public static void try format satisfiability ( string format ) throws illegal format exception { message format . format ( format , ( object [ ] ) null ) ; }	throws an exception if the format is not syntactically valid .
public static int parse upper map ( string s ) throws number format exception { int upper case = map undefined ; int length = s . length ( ) ; if ( length >= num && length <= num ) { upper case = integer . parse int ( s , num ) ; } else if ( s . length ( ) != num ) { throw new number format exception ( ) ; } return upper case ; }	parse the uppercase mapping attribute for a unicode character.
@ override public void run ( ) { while ( ! is interrupted ( ) ) { try { reference ref = queue . remove ( ) ; entry infos . remove ( ref ) ; } catch ( interrupted exception e ) { interrupt ( ) ; break ; } } }	block on the queue until an entry is been cleaned by the gc.
private file create zip file ( int entry count , int entry size ) throws io { file result = create temporary zip file ( ) ; byte [ ] write buffer = new byte [ num ] ; random random = new random ( ) ; zip output stream out = new zip output stream ( new buffered output stream ( new file output stream ( result ) ) ) ; for ( int entry = num ; entry < entry count ; ++ entry ) { zip entry ze = new zip entry ( integer . to hex string ( entry ) ) ; out . put next entry ( ze ) ; for ( int i = num ; i < entry size ; i += write buffer . length ) { random . next bytes ( write buffer ) ; int byte count = math . min ( write buffer . length , entry size - i ) ; out . write ( write buffer , num , byte count ) ; } out . close entry ( ) ; } out . close ( ) ; return result ; }	compresses the given number of files , each of the given size , into a.
private boolean is valid playlist name ( string new name ) { playlist blank playlist = new playlist ( new name , bool ) ; return ! new name . is empty ( ) && ! music library . contains playlist ( blank playlist ) ; }	ensures that a string for a playlist is valid , checking if it is empty , or another playlist has the same name .
public string import xml ( string file name , properties ctx , string trx name ) throws exception { log . info ( str + file name ) ; file in = new file ( file name ) ; if ( ! in . exists ( ) ) { string msg = str + file name ; log . info ( str + msg ) ; return msg ; } try { log . info ( str ) ; system . set property ( str , str ) ; pack in handler handler = new pack in handler ( ) ; handler . set ( trx name ) ; handler . set ctx ( ctx ) ; handler . set process ( this ) ; sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; string msg = str ; log . info ( msg ) ; parser . parse ( in , handler ) ; msg = str ; log . info ( msg ) ; return str ; } catch ( exception e ) { log . log ( level . severe , str , e ) ; throw e ; } }	uses packinhandler to update ad .
public synchronized void log add or remove row ( session session , int table id , row row , boolean add ) { if ( log mode != log mode off ) { if ( ! recovery running ) { log . log add or remove row ( session , table id , row , add ) ; } } }	a record is added to a table , or removed from a table .
public org . smpte ra . schemas . st2067 2 2016 . digest method type build default digest method type ( ) { org . smpte ra . schemas . st2067 2 2016 . digest method type digest method type = new org . smpte ra . schemas . st2067 2 2016 . digest method type ( ) ; digest method type . set algorithm ( 2016 . default hash algorithm ) ; return digest method type ; }	a method to construct a default digest method type with a default hashalgorithm.
public static < v extends sampled vertex > set < v > create sampled partition ( collection < v > vertices ) { set < v > partition = new hash set < v > ( ) ; for ( v vertex : vertices ) { if ( vertex . is sampled ( ) ) partition . add ( vertex ) ; } return partition ; }	creates a subset of sampled vertices .
public gremlin transaction manager ( gremlin graph factory graph factory ) { super ( ) ; this . graph factory = graph factory ; }	instantiates a new gremlintransactionmanager with the given gremlingraphfactory .
public void shift beans ( bean instance to shift to , boolean save ) { if ( save ) { m original coords = new vector < point > ( ) ; } int target x = to shift to . get x ( ) ; int target y = to shift to . get y ( ) ; for ( int i = num ; i < m sub flow . size ( ) ; i ++ ) { bean instance temp = ( bean instance ) m sub flow . element at ( i ) ; if ( save ) { point p = new point ( temp . get x ( ) - target x , temp . get y ( ) - target y ) ; m original coords . add ( p ) ; } temp . set x ( target x ) ; temp . set y ( target y ) ; } }	move coords of all inputs and outputs of this meta bean to the coords of the supplied beaninstance.
@ override protected final list < lat long > do in background ( final object ... args ) { list < lat long > points = new array list < > ( ) ; data helper db helper = new data helper ( m context ) ; final array list < position record > positions = db helper . load positions ( ( integer ) args [ session id ] , ( double ) args [ min lat col ] , ( double ) args [ max lat col ] , ( double ) args [ min lon col ] , ( double ) args [ max lon col ] ) ; for ( position record position : positions ) { points . add ( new lat long ( position . get latitude ( ) , position . get longitude ( ) ) ) ; } return points ; }	queries reference database for all wifis in specified range around map centre .
public void make ( ) throws exception { for ( int i = num ; i < make list . size ( ) ; i ++ ) { make make = make list . get ( i ) ; make . make ( ) ; } }	returns true if the underlying dependencies have changed .
@ override void deleted text ( character data impl node , int offset , int count ) { if ( ranges != null ) { notify ranges deleted text ( node , offset , count ) ; } }	a method to be called when some text was deleted from a text node , so that live objects can be notified .
private application environment ( ) { try { if ( system . get property ( bootstrap properties . is uberjar ) != null ) { this . mode = mode . uberjar ; if ( ! load wild fly swarm application manifest from classpath ( ) ) { load wild fly swarm application manifest from tccl ( ) ; } } else { this . mode = mode . classpath ; load fraction manifests from classpath ( ) ; } } catch ( io e ) { throw new runtime exception ( e ) ; } }	do not construct directly .
public producer worker ( string topic , string message ) { this . topic = topic ; this . message = message ; }	creates a new producer object .
private void tab created in foreground ( int id , int source id , boolean new is incognito , float origin x , float origin y ) { layout tab new layout tab = create layout tab ( id , new is incognito , no close button , no title ) ; if ( m layout tabs == null || m layout tabs . length == num ) { m layout tabs = new layout tab [ ] { new layout tab } ; } else { m layout tabs = new layout tab [ ] { m layout tabs [ num ] , new layout tab } ; } update cache visible ids ( new linked list < integer > ( arrays . as list ( id , source id ) ) ) ; new layout tab . set border alpha ( num ) ; new layout tab . set static to view blend ( num ) ; force animation to finish ( ) ; interpolator interpolator = baked bezier interpolator . transform curve ; add to animation ( new layout tab , layout tab . property . scale , num , num , foreground animation duration , num , bool , interpolator ) ; add to animation ( new layout tab , layout tab . property . alpha , num , num , foreground animation duration , num , bool , interpolator ) ; add to animation ( new layout tab , layout tab . property . x , origin x , num , foreground animation duration , num , bool , interpolator ) ; add to animation ( new layout tab , layout tab . property . y , origin y , num , foreground animation duration , num , bool , interpolator ) ; m tab model selector . select model ( new is incognito ) ; start hiding ( id , bool ) ; }	animate opening a tab in the foreground .
private static boolean functions are allowed ( boolean is add all function , boolean is put all function , class < ? > class d , class < ? > class s ) { if ( is add all function ) return collection is assignable from ( class d ) && collection is assignable from ( class s ) ; if ( is put all function ) return map is assignable from ( class d ) && map is assignable from ( class s ) ; return is assignable from ( class d , class s ) ; }	returns true if the function to check is allowed .
private void load org access user ( array list < org access > list ) { prepared statement pstmt = null ; result set rs = null ; string sql = str + str ; try { pstmt = db . prepare statement ( sql , get ( ) ) ; pstmt . set int ( num , get ad id ( ) ) ; rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { m oa = new m ( get ctx ( ) , rs , get ( ) ) ; load org access add ( list , new org access ( oa . get ad id ( ) , oa . get ad id ( ) , oa . is read only ( ) ) ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } finally { db . close ( rs , pstmt ) ; } }	load org access user.
public void close ( ) { synchronized ( m disk cache lock ) { if ( m disk lru cache != null ) { try { if ( ! m disk lru cache . is closed ( ) ) { m disk lru cache . close ( ) ; } } catch ( throwable e ) { log utils . e ( e . get message ( ) , e ) ; } m disk lru cache = null ; } } }	closes the disk cache associated with this imagecache object.
private map < uri , integer > create volume map for export mask ( export mask export mask ) { map < uri , integer > map = new hash map < > ( ) ; for ( uri uri : export mask utils . get volume ur ( export mask ) ) { map . put ( uri , export group . lun unassigned ) ; } return map ; }	using the exportmask object , create a volume uri to hlu map . for scaleio , there isn ' t any hlu required.
@ override public void close ( ) throws io { socket channel s = channel ; channel = null ; ssl ssl socket = ssl socket ; ssl socket = null ; if ( ssl socket != null ) { try { ssl socket . close ( ) ; } catch ( exception e ) { } } if ( s != null ) { try { s . close ( ) ; } catch ( exception e ) { } } }	closes the underlying socket .
public static d max ( d a , d b ) { return new d ( fast math . max ( a . get x ( ) , b . get x ( ) ) , fast math . max ( a . get y ( ) , b . get y ( ) ) , fast math . max ( a . get z ( ) , b . get z ( ) ) ) ; }	calculates maximum of each coordinate .
public static void wait for process output ( process self , output stream output , output stream error ) { thread tout = consume process output stream ( self , output ) ; thread terr = consume process error stream ( self , error ) ; try { tout . join ( ) ; } catch ( interrupted exception ignore ) { } try { terr . join ( ) ; } catch ( interrupted exception ignore ) { } try { self . wait for ( ) ; } catch ( interrupted exception ignore ) { } close streams ( self ) ; }	gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer.
public command line add ( string ... args ) { if ( args != null && args . length > num ) { collections . add all ( line , args ) ; } return this ; }	adds list of arguments in command line .
@ override final node < v > find ( int h , long k ) { for ( node < v > e = first ; e != null ; ) { int s ; if ( ( ( s = lock state ) & ( waiter | writer ) ) != num ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( u . compare and swap int ( this , lockstate , s , s + reader ) ) { tree node < v > r ; tree node < v > p ; try { p = ( ( r = root ) == null ? null : r . find tree node ( h , k ) ) ; } finally { thread w ; if ( get and add int ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) { lock support . unpark ( w ) ; } } return p ; } } return null ; }	returns matching node or null if none.
@ override public axis state draw ( d g2 , double cursor , d plot area , d data area , rectangle edge edge , plot rendering info plot state ) { axis state axis state = new axis state ( cursor ) ; if ( is axis line visible ( ) ) { draw axis line ( g2 , cursor , data area , edge ) ; } if ( is tick marks visible ( ) ) { draw tick marks ( g2 , axis state , data area , edge ) ; } if ( is tick labels visible ( ) ) { for ( int band = num ; band < this . label info . length ; band ++ ) { axis state = draw tick labels ( band , g2 , axis state , data area , edge ) ; } } if ( get attributed label ( ) != null ) { axis state = draw attributed label ( get attributed label ( ) , g2 , plot area , data area , edge , axis state ) ; } else { axis state = draw label ( get label ( ) , g2 , plot area , data area , edge , axis state ) ; } return axis state ; }	draws the axis on a java 2d graphics device ( such as the screen or a printer ) .
private array list < url > read contents ( path fetchlist ) throws io { sequence file . reader reader = new sequence file . reader ( fs , fetchlist , conf ) ; array list < url > l = new array list < url > ( ) ; read : do { text key = new text ( ) ; crawl datum value = new crawl datum ( ) ; if ( ! reader . next ( key , value ) ) { break read ; } l . add ( new url ( key , value ) ) ; } while ( bool ) ; reader . close ( ) ; return l ; }	read contents of fetchlist .
public static color create random colour ( ) { float r = rand . next float ( ) ; float g = rand . next float ( ) ; float b = rand . next float ( ) ; color random color = new color ( r , g , b ) ; return random color ; }	creates a random colour .
private static pair < diagnostic kind , boolean > parse category string ( string category ) { final string fixable = str ; final boolean is fixable = category . starts with ( fixable ) ; if ( is fixable ) { category = category . substring ( fixable . length ( ) ) ; } diagnostic kind category enum = diagnostic kind . from parse string ( category ) ; return pair . of ( category enum , is fixable ) ; }	given a category string that may be prepended with " fixable - " , return the category enum that corresponds with the category and whether or not it is a isfixable error.
public void legacy process ( class clazz , method m , method appearance decision decision ) { if ( m . get declaring class ( ) != object . class && m . get return type ( ) != void . class && m . get parameter types ( ) . length == num ) { string m name = m . get name ( ) ; if ( ! looks like property read method ( m name ) ) { decision . set expose method as ( null ) ; try { decision . set expose as property ( new property descriptor ( m name , clazz , m name , null ) ) ; } catch ( introspection exception e ) { throw new runtime exception ( e ) ; } } } }	this only exists as the tests need to call this through the deprecated method too .
public sptk ( string lf0 sptk , float window size in seconds , float skip size in seconds , int sampling rate ) { contour = null ; header = new pitch file header ( ) ; header . window size in seconds = window size in seconds ; header . skip size in seconds = skip size in seconds ; header . fs = sampling rate ; try { contour = read sptk ( lf0 sptk ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	read a sptk lf0 file with external settings.
public void abort ( ) { clean up ( ) ; if ( m future != null ) { m future . cancel ( bool ) ; m future = null ; } if ( m executor service != null ) { m executor service . shutdown now ( ) ; m executor service = null ; } m listener = null ; }	aborts the call . this method will cleanup the resources and removes the listener , if one was registered ,.
public void add csp ( csp listener ) { listeners . add ( listener ) ; }	adds a csp state listener to the solution strategy .
public static void print wrapped text ( final print stream stream , final string message ) { if ( stream != null && message != null && ! message . is empty ( ) ) { stream . println ( wrap text ( message , max line width ) ) ; } }	prints the provided string on the provided stream .
public void remove at range ( int index , int size ) { final int end = math . min ( m size , index + size ) ; for ( int i = index ; i < end ; i ++ ) { remove at ( i ) ; } }	remove a range of mappings as a batch .
public static void assert nullability ( result set rs , boolean [ ] nullability ) throws sql { result set meta data rsmd = rs . get meta data ( ) ; int actual cols = rsmd . get column count ( ) ; assert equals ( str , nullability . length , rsmd . get column count ( ) ) ; for ( int i = num ; i < actual cols ; i ++ ) { int expected = nullability [ i ] ? result set meta data . column nullable : result set meta data . column no nulls ; assert equals ( str + ( i + num ) , expected , rsmd . is nullable ( i + num ) ) ; } }	check the nullability of the column definitions for the resultset matches the expected values .
private synchronized rect [ ] compute bounding boxes ( ) { if ( ! bounding boxes . is present ( ) ) { rect [ ] bb = new rect [ ( int ) contours . size ( ) ] ; for ( int i = num ; i < contours . size ( ) ; i ++ ) { bb [ i ] = bounding rect ( contours . get ( i ) ) ; } bounding boxes = optional . of ( bb ) ; } return bounding boxes . get ( ) ; }	compute the bounding boxes of all contours ( if they haven ' t already been computed ).
public void add timeline ( final json timeline ) { timeline channel . notify timeline ( timeline ) ; timelines . add first ( timeline ) ; final int max cnt = symphonys . get int ( str ) ; if ( timelines . size ( ) > max cnt ) { timelines . remove ( max cnt ) ; } }	adds the specified timeline .
private boolean load lob ( ) { if ( is store attachments on file system ) { return load lob ( ) ; } return load lob db ( ) ; }	load data into local m_data.
protected void paint component ( graphics g ) { background painter . paint ( g , get visible rect ( ) ) ; ui ui = get ui ( ) ; if ( ui != null ) { graphics scratch graphics = g . create ( ) ; try { ui . update ( scratch graphics , this ) ; } finally { scratch graphics . dispose ( ) ; } } }	paints the text area .
public static < t > list < t > copy to array list with extra capacity ( t [ ] elements , int extra capacity ) { list < t > as list ; if ( elements != null ) { as list = new array list < t > ( elements . length + extra capacity ) ; as list . add all ( arrays . as list ( elements ) ) ; } else { as list = new array list < t > ( extra capacity ) ; } return as list ; }	produces an arraylist for an array of elements where the list is pre - sized with extra capacity.
private boolean send event to listeners ( cluster event event ) { boolean success = bool ; for ( string listener id : collections . unmodifiable set ( listeners . key set ( ) ) ) { logger . debug ( str , listener id , event . get type ( ) , instance id ) ; cluster event listener listener = listeners . get ( listener id ) ; if ( listener != null && ! listener . handle event ( event ) ) { success = bool ; } } return success ; }	sends a clusterevent to all registered listeners.
@ request mapping ( method = request method . put , value = str , consumes = { media type . application json value } , produces = { media type . application json value } ) @ api operation ( value = str , notes = str + str + str , response = void . class ) @ api responses ( { @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) } ) @ pre authorize ( str ) public response entity < ? > update ( @ path variable ( str ) string region , @ path variable ( str ) final string [ ] keys , @ request param ( value = str , default value = str ) final string op value , @ request body final string json ) { logger . debug ( str , region ) ; region = decode ( region ) ; if ( keys . length > num ) { return update multiple keys ( region , keys , json ) ; } else { return update single key ( region , keys [ num ] , json , op value ) ; } }	update data for a key or set of keys.
public void load ( x509 extension extensions ) { set < string > crit exts = extensions . get critical extension oi ( ) ; set < string > non crit exts = extensions . get non critical extension oi ( ) ; list < x509 ext > sorted exts = new array list < x509 ext > ( ) ; for ( iterator < string > itr = crit exts . iterator ( ) ; itr . has next ( ) ; ) { string ext oid = itr . next ( ) ; byte [ ] value = extensions . get extension value ( ext oid ) ; x509 ext ext = new x509 ext ( new as ( ext oid ) , value , bool ) ; sorted exts . add ( ext ) ; } for ( iterator < string > itr = non crit exts . iterator ( ) ; itr . has next ( ) ; ) { string ext oid = itr . next ( ) ; byte [ ] value = extensions . get extension value ( ext oid ) ; x509 ext ext = new x509 ext ( new as ( ext oid ) , value , bool ) ; sorted exts . add ( ext ) ; } collections . sort ( sorted exts , new extension name comparator ( ) ) ; data = new object [ sorted exts . size ( ) ] [ num ] ; int i = num ; for ( iterator < x509 ext > itr sorted exts = sorted exts . iterator ( ) ; itr sorted exts . has next ( ) ; ) { x509 ext ext = itr sorted exts . next ( ) ; load row ( ext , i ) ; i ++ ; } fire table data changed ( ) ; }	load the extensionstablemodel with x.
public builder delete addresses ( ) { delete fields . add ( str ) ; return this ; }	deletes all existing addresses of the a existing user.
public query limit ( int limit ) { return limit ( limit < num ? no limit : field . < integer > field ( integer . to string ( limit ) ) ) ; }	set the limit of this statement.
public static boolean file exists ( string f name ) { boolean result = bool ; file file = new file ( f name ) ; if ( file != null ) { result = file . exists ( ) && file . is file ( ) ; } return result ; }	test if a file exists or not.
public long skip ( long n ) { if ( position + n <= document . get length ( ) ) { position += n ; return n ; } long temp = position ; position = document . get length ( ) ; return document . get length ( ) - temp ; }	skips characters . this will not ' skip ' past the end of the document .
private static void init ( ) { add method ( str , new com . earth2me . essentials . register . payment . methods . i co6 ( ) ) ; add method ( str , new com . earth2me . essentials . register . payment . methods . i co5 ( ) ) ; add method ( str , new com . earth2me . essentials . register . payment . methods . bos ( ) ) ; add method ( str , new com . earth2me . essentials . register . payment . methods . mcur ( ) ) ; dependencies . add ( str ) ; add method ( str , new com . earth2me . essentials . register . payment . methods . vault eco ( ) ) ; }	implement all methods along with their respective name & class .
public static string convert file name ( string name , int max bytes ) { try { return convert file name ( name , max bytes , charset . default charset ( ) ) ; } catch ( character coding exception cce ) { try { return convert file name ( name , max bytes , charset . for name ( str ) ) ; } catch ( character coding exception e ) { throw new runtime exception ( str + name , e ) ; } } }	cleans up the filename from illegal characters and truncates it to the length of bytes specified .
public static void copy ( url url , file file ) throws io { input stream is = url . open stream ( ) ; try { output stream os = new file output stream ( file ) ; try { byte [ ] buffer = new byte [ num ] ; int read ; while ( ( read = is . read ( buffer ) ) > num ) { os . write ( buffer , num , read ) ; } } finally { os . close ( ) ; } } finally { is . close ( ) ; } }	copy a url to a file .
public void update deltas ( int delta x , int delta y ) { if ( m left border active ) { m delta x = math . max ( - m baseline x , delta x ) ; m delta x = math . min ( m baseline width - num * m touch target width , m delta x ) ; } else if ( m right border active ) { m delta x = math . min ( m drag layer . get width ( ) - ( m baseline x + m baseline width ) , delta x ) ; m delta x = math . max ( - m baseline width + num * m touch target width , m delta x ) ; } if ( m top border active ) { m delta y = math . max ( - m baseline y , delta y ) ; m delta y = math . min ( m baseline height - num * m touch target width , m delta y ) ; } else if ( m bottom border active ) { m delta y = math . min ( m drag layer . get height ( ) - ( m baseline y + m baseline height ) , delta y ) ; m delta y = math . max ( - m baseline height + num * m touch target width , m delta y ) ; } }	here we bound the deltas such that the frame cannot be stretched beyond the extents of the celllayout , and such that the frame ' s borders can ' t cross .
public void create auth configuration ( string name ) throws am { if ( ( name == null ) || ( name . length ( ) == num ) ) { throw new am ( get localized string ( str ) ) ; } string [ ] params = { current realm , name } ; log event ( str , params ) ; string error msg = null ; try { am . create named config ( name , num , new hash map ( ) , current realm , get user sso ( ) ) ; log event ( str , params ) ; } catch ( sms e ) { error msg = get error string ( e ) ; string [ ] params ex = { current realm , name , error msg } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; } catch ( sso e ) { error msg = get error string ( e ) ; string [ ] params ex = { current realm , name , error msg } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; } catch ( am e ) { error msg = get error string ( e ) ; string [ ] params ex = { current realm , name , error msg } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; } if ( error msg != null ) { throw new am ( error msg ) ; } }	creates a new named authentication configuration object.
public void trim ( string a text , int [ ] a span ) { int begin = a span [ num ] ; int end = a span [ num ] - num ; string data = a text ; while ( ( begin < ( data . length ( ) - num ) ) && trim char ( data . char at ( begin ) ) ) { begin ++ ; } while ( ( end > num ) && trim char ( data . char at ( end ) ) ) { end -- ; } end ++ ; a span [ num ] = begin ; a span [ num ] = end ; }	remove trailing or leading whitespace from the annotation .
public string classifier tip text ( ) { return str ; }	returns the tip text for this property.
public writable raster create writable child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band list ) { if ( x < this . min x ) { throw new raster format exception ( str ) ; } if ( y < this . min y ) { throw new raster format exception ( str ) ; } if ( ( x + width < x ) || ( x + width > this . min x + this . width ) ) { throw new raster format exception ( str ) ; } if ( ( y + height < y ) || ( y + height > this . min y + this . height ) ) { throw new raster format exception ( str ) ; } sample model sm ; if ( band list != null ) { sm = sample model . create subset sample model ( band list ) ; } else { sm = sample model ; } int delta x = x0 - x ; int delta y = y0 - y ; return new byte packed raster ( sm , data buffer , new rectangle ( x0 , y0 , width , height ) , new point ( sample model translate x + delta x , sample model translate y + delta y ) , this ) ; }	creates a writable subraster given a region of the raster.
private void send buffer ( ) throws io { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }	send all local - buffered data to server .
public void call event ( event event ) { if ( event . is asynchronous ( ) ) { if ( thread . holds lock ( this ) ) { throw new illegal state exception ( event . get event name ( ) + str ) ; } if ( server . is primary thread ( ) ) { throw new illegal state exception ( event . get event name ( ) + str ) ; } fire event ( event ) ; } else { synchronized ( this ) { fire event ( event ) ; } } }	calls an event with the given details.
@ nullable private static psi file find file to open ( @ not null list < psi file > files ) { psi file best file = null ; folder configuration best config = null ; for ( psi file file : files ) { psi directory qualified directory = file . get parent ( ) ; assert qualified directory != null : str ; folder configuration config = folder configuration . get config for folder ( qualified directory . get name ( ) ) ; if ( best config == null || config == null || config . compare to ( best config ) < num ) { best config = config ; best file = file ; } } return best file ; }	returns the best configuration of a particular resource given a set of multiple configurations of the same resource .
protected boolean are equal ( string string1 , string string2 , boolean case matters ) { return ( case matters && string1 . equals ( string2 ) ) || ( ! case matters && string1 . equals ignore case ( string2 ) ) ; }	compares the two strings .
public static command result exec command ( list < string > commands , boolean is root ) { return exec command ( commands == null ? null : commands . to array ( new string [ ] { } ) , is root , bool ) ; }	execute shell commands , default return result msg.
protected void populate blob ( int id , byte [ ] base content , int required size ) throws sql { connection con = get connection via driver manager ( ) ; callable statement cstmt = null ; try { cstmt = con . prepare call ( execute fill binary blob ) ; cstmt . set int ( num , id ) ; cstmt . set bytes ( num , base content ) ; cstmt . set int ( num , required size ) ; cstmt . execute ( ) ; } finally { close quietly ( cstmt ) ; close quietly ( con ) ; } }	populates a ( segmented ) blob using the fill_binary_blob stored procedure.
private void remove observed file ( string local path ) { file file = new file ( local path ) ; string parent path = file . get parent ( ) ; folder observer observer = m folder observers map . get ( parent path ) ; if ( observer != null ) { observer . stop watching ( file . get name ( ) ) ; if ( observer . is empty ( ) ) { m folder observers map . remove ( parent path ) ; oc . d ( tag , str + parent path + str ) ; } } else { oc . d ( tag , str + local path ) ; } }	unregisters a local file from being observed for changes .
public void make immutable ( ) { if ( mutable ) { if ( results != null ) { int length = results . size ( ) ; for ( int i = num ; i < length ; i ++ ) { result result = ( result ) results . get ( i ) ; result . make immutable ( ) ; } results = collections . unmodifiable list ( results ) ; } mutable = bool ; } }	makes the object immutable.
public statement is null ( ) { statement . append ( str ) ; return this ; }	appending the is null operator clause .
public void clear ( ) { process queue ( ) ; hash . clear ( ) ; }	remove all mappings from this cache .
private void update favorite station ( ) { string show string = null ; if ( fm radio station . is favorite station ( m context , m current station ) ) { string station name = fm radio station . get station name ( m context , m current station , fm radio station . station type favorite ) ; fm radio station . update station to db ( m context , station name , fm radio station . station type searched , m current station ) ; m button add to favorite . set image resource ( r . drawable . btn fm favorite off selector ) ; m text station name . set text ( str ) ; show string = m project string ext . get project string ( m context , r . string . toast channel deleted , r . string . toast channel deleted1 ) ; } else { string station name = fm radio station . get station name ( m context , m current station , fm radio station . station type searched ) ; if ( fm radio station . is station exist ( m context , m current station , fm radio station . station type searched ) ) { fm radio station . update station to db ( m context , station name , fm radio station . station type favorite , m current station ) ; } else { fm radio station . insert station to db ( m context , station name , m current station , fm radio station . station type favorite ) ; } m button add to favorite . set image resource ( r . drawable . btn fm favorite on selector ) ; m text station name . set text ( station name ) ; show string = m project string ext . get project string ( m context , r . string . toast channel added , r . string . toast channel added1 ) ; } show toast ( show string ) ; }	update the favorite ui state.
public int add all absent ( collection < ? extends e > c ) { object [ ] cs = c . to array ( ) ; if ( cs . length == num ) return num ; final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = get array ( ) ; int len = elements . length ; int added = num ; for ( int i = num ; i < cs . length ; ++ i ) { object e = cs [ i ] ; if ( index of ( e , elements , num , len ) < num && index of ( e , cs , num , added ) < num ) cs [ added ++ ] = e ; } if ( added > num ) { object [ ] new elements = arrays . copy of ( elements , len + added ) ; system . arraycopy ( cs , num , new elements , len , added ) ; set array ( new elements ) ; } return added ; } finally { lock . unlock ( ) ; } }	appends all of the elements in the specified collection that are not already contained in this list , to the end of this list , in the order that they are returned by the specified collection ' s iterator .
public analyzer save analysis ( file file ) throws io { print stream ps = null ; try { ps = new print stream ( new buffered output stream ( new file output stream ( file ) ) ) ; print analysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }	saves the analysis of all data recorded in this analyzer to the specified file .
public iterator < capability > dependencies ( ) { return m . iterator ( ) ; }	returns an iterator over the stored dependencies.
public final static int parse int ( string str ) { char c = str . char at ( num ) ; int length = str . length ( ) ; boolean negative = ( c == str ) ; int offset = num ; if ( negative ) { if ( length == num || length > num ) { return integer . parse int ( str ) ; } c = str . char at ( offset ++ ) ; } else { if ( length > num ) { return integer . parse int ( str ) ; } } if ( c > str || c < str ) { return integer . parse int ( str ) ; } int num = c - str ; if ( offset < length ) { c = str . char at ( offset ++ ) ; if ( c > str || c < str ) { return integer . parse int ( str ) ; } num = ( num * num ) + ( c - str ) ; if ( offset < length ) { c = str . char at ( offset ++ ) ; if ( c > str || c < str ) { return integer . parse int ( str ) ; } num = ( num * num ) + ( c - str ) ; if ( offset < length ) { do { c = str . char at ( offset ++ ) ; if ( c > str || c < str ) { return integer . parse int ( str ) ; } num = ( num * num ) + ( c - str ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }	helper method to ( more ) efficiently parse integer numbers from string values .
public buffered header ( final char array buffer buffer ) throws parse exception { super ( ) ; if ( buffer == null ) { throw new illegal argument exception ( str ) ; } int colon = buffer . index of ( str ) ; if ( colon == - num ) { throw new parse exception ( str + buffer . to string ( ) ) ; } string s = buffer . substring trimmed ( num , colon ) ; if ( s . length ( ) == num ) { throw new parse exception ( str + buffer . to string ( ) ) ; } this . buffer = buffer ; this . name = s ; this . value pos = colon + num ; }	creates a new header from a buffer.
public static string to date string ( java . util . date date , string format ) { if ( date == null ) return str ; simple date format date format = null ; if ( format != null ) { date format = new simple date format ( format ) ; } else { date format = new simple date format ( ) ; } calendar calendar = calendar . get instance ( ) ; calendar . set time ( date ) ; return date format . format ( date ) ; }	makes a date string in the given from a date.
@ deprecated public static < t > t execute with back off ( abstract google client request < t > client , string error , object ... error args ) throws io , interrupted exception { return execute with back off ( client , string . format ( error , error args ) ) ; }	execute a bq request with exponential backoff and return the result .
private void check server response code ( url url connection ) throws request failure exception { try { if ( url connection . get response code ( ) != num ) { throw new request failure exception ( str + url connection . get response code ( ) + str ) ; } } catch ( io e ) { throw new request failure exception ( str , e ) ; } }	confirms that the omaha server sent back an " ok " code .
public static void add resource source ( resource source source ) { all resource sources . add ( source ) ; }	adds a new resource source.
private void commit changes ( ) { hopfield props panel . commit changes ( ) ; input panel . commit changes ( ) ; }	commit all changes made in the dialog to the model .
private boolean connect to target ( pla point int p from point ) { if ( nearest target item != null && target set != null && ! target set . contains ( nearest target item ) ) { nearest target item = null ; } if ( nearest target item == null || ! nearest target item . shares net no ( net nos ) ) { return bool ; } boolean route completed = bool ; pla point int connection point = null ; if ( nearest target item instanceof brd abit ) { brd abit target = ( brd abit ) nearest target item ; connection point = target . center get ( ) ; } else if ( nearest target item instanceof brd tracep ) { return r board . connect to trace ( p from point , ( brd tracep ) nearest target item , pen half width arr [ layer active no ] , clearance class ) ; } else if ( nearest target item instanceof brd area conduction ) { connection point = p from point ; } if ( connection point != null ) { route completed = itera connect ( p from point , connection point ) ; } return route completed ; }	if p_from_point is already on a target item , a connection to the target is made and true returned .
public boolean on generic motion event ( motion event ev ) { if ( ( ev . get source ( ) & input device . source class pointer ) == input device . source class pointer ) { int action = ev . get action ( ) ; switch ( action & motion event . action mask ) { case motion event . action scroll : float v scroll = ev . get axis value ( motion event . axis vscroll ) ; if ( v scroll > num ) { if ( m deck view . ensure focused task ( ) ) { m deck view . focus next task ( bool , bool ) ; } } else { if ( m deck view . ensure focused task ( ) ) { m deck view . focus next task ( bool , bool ) ; } } return bool ; } } return bool ; }	handles generic motion events.
public boolean add class ( owl class target class ) { target class . add qc ( this ) ; return qc classes . add ( target class ) ; }	add " onclass c " information , and tell c to point back here .
public void edit element ( final object element , final string column property name ) { final int column index = table viewer utils . column property name to column index ( column property name , bool , viewer ) ; viewer . edit element ( element , column index ) ; }	initiates cell editing on the specified element.
public fp ( ec curve , ec x , ec y ) { this ( curve , x , y , bool ) ; }	create a point which encodes with point compression .
private static string serialize document int ( document doc ) throws transformer exception , io { byte array output stream s = new byte array output stream ( ) ; transformer factory factory = transformer factory . new instance ( ) ; transformer transformer = factory . new transformer ( ) ; transformer . set output property ( output keys . method , str ) ; transformer . set output property ( output keys . indent , str ) ; dom source = new dom ( doc ) ; stream result output target = new stream result ( s ) ; transformer . transform ( source , output target ) ; return s . to string ( str ) ; }	serializes a xml document into a string - encoded in utf8 format , with platform line separators .
static double area ( s2 point a , s2 point b , s2 point c ) { final double sa = b . angle ( c ) ; final double sb = c . angle ( a ) ; final double sc = a . angle ( b ) ; final double s = num * ( sa + sb + sc ) ; if ( s >= num ) { double s2 = s * s ; double dmin = s - math . max ( sa , math . max ( sb , sc ) ) ; if ( dmin < num * s * s2 * s2 ) { double area = girard area ( a , b , c ) ; if ( dmin < s * ( num * area ) ) { return area ; } } } return num * math . atan ( math . sqrt ( math . max ( num , math . tan ( num * s ) * math . tan ( num * ( s - sa ) ) * math . tan ( num * ( s - sb ) ) * math . tan ( num * ( s - sc ) ) ) ) ) ; }	return the area of triangle abc.
private void serializable ( final isolation levels level ) throws exception { clear ( store ) ; final value factory vf = store . get value factory ( ) ; final iri subj = vf . create iri ( str ) ; final iri pred = vf . create iri ( str ) ; repository connection prep = store . get connection ( ) ; try { prep . begin ( level ) ; prep . add ( subj , pred , vf . create literal ( num ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final count down latch start = new count down latch ( num ) ; final count down latch observed = new count down latch ( num ) ; thread t1 = increment by ( start , observed , level , vf , subj , pred , num ) ; thread t2 = increment by ( start , observed , level , vf , subj , pred , num ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assert not failed ( ) ; repository connection check = store . get connection ( ) ; try { check . begin ( level ) ; literal lit = read literal ( check , subj , pred ) ; int val = lit . int value ( ) ; if ( val != num && val != num ) { assert equals ( num , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }	two transactions read a value and replace it.
public static array list to array remove empty ( string list , char delimiter ) { int len = list . length ( ) ; array impl array = new array impl ( ) ; if ( len == num ) return array ; int last = num ; for ( int i = num ; i < len ; i ++ ) { if ( list . char at ( i ) == delimiter ) { if ( last < i ) array . append ( list . substring ( last , i ) ) ; last = i + num ; } } if ( last < len ) array . append ( list . substring ( last ) ) ; return array ; }	casts a list to array object remove empty elements.
public static < t extends object & java . lang . comparable < ? super t > > t min ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . has next ( ) ) { t next = it . next ( ) ; if ( min . compare to ( next ) > num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element .
@ override public server heartbeat server ( string address , int port , boolean is ssl , string cluster id , string display name , boolean is dynamic ) { objects . require non null ( address ) ; objects . require non null ( cluster id ) ; if ( address . is empty ( ) ) { address = str ; } cluster heartbeat cluster = create cluster ( cluster id ) ; server heartbeat server ; if ( is dynamic ) { server = cluster . create dynamic server ( address , port , is ssl ) ; } else { server = cluster . create server ( address , port , is ssl ) ; } if ( display name != null ) { server . set display name ( display name ) ; } if ( ! is dynamic ) { cluster . add seed server ( server ) ; } return server ; }	create an external / configured server.
public void test to string ( ) { linked blocking queue q = populated queue ( size ) ; string s = q . to string ( ) ; for ( int i = num ; i < size ; ++ i ) { assert true ( s . index of ( string . value of ( i ) ) >= num ) ; } }	tostring contains tostrings of elements.
private void find club ( ) { if ( ce ( ) == null ) { return ; } string title = messages . get string ( str ) ; string body = messages . get string ( str ) ; if ( ! clientgui . do yes no dialog ( title , body ) ) { return ; } attacks . remove all elements ( ) ; attacks . add element ( new find club action ( cen ) ) ; ready ( ) ; }	the entity spends the rest of its turn finding a club.
public pdf ( byte [ ] line ) { if ( line == null ) { id = - num ; generation = - num ; } else { id = integer . parse int ( new string ( line , num , num ) ) ; generation = integer . parse int ( new string ( line , num , num ) ) ; } compressed = bool ; }	create a new pdfxref , given a sequence of bytes representing the fixed - width cross reference table line.
public static string [ ] make strings ( collection < inet address > addrs ) { string [ ] result = new string [ addrs . size ( ) ] ; int i = num ; for ( inet address addr : addrs ) { result [ i ++ ] = addr . get host address ( ) ; } return result ; }	create a string array of host addresses from a collection of inetaddresses.
public static void show profile ( activity activity , string pilot id , @ nullable hash map < string , string > extras ) { if ( ( pilot id == null || pilot id . is empty ( ) ) && air map . has valid authenticated user ( ) ) { pilot id = air map . get user id ( ) ; } intent intent = new intent ( activity , profile activity . class ) ; intent . put extra ( profile activity . arg pilot id , pilot id ) ; if ( extras != null ) { intent . put extra ( create flight activity . key value extras , extras ) ; } activity . start activity ( intent ) ; }	display the authenticated pilot ' s profile.
public smooth moves ( ) { cycle start = system . nano time ( ) / num ; start timer ( current resolution ) ; }	creates a new instance of smoothanimation.
public static void update price lists ( properties ctx , product bean product bean , string trx name ) throws operation exception { array list < product bean > list = product bean . get product bean list ( ) ; if ( list != null ) { int product id = product bean . get product id ( ) ; iterator < product bean > iter = list . iterator ( ) ; while ( iter . has next ( ) ) { product bean bean = iter . next ( ) ; int price list id = bean . get price list id ( ) ; big decimal std price = bean . get std price ( ) ; big decimal list price = bean . get list price ( ) ; big decimal limit price = bean . get limit price ( ) ; m price list = m . get ( ctx , price list id , trx name ) ; if ( price list . is tax included ( ) ) { std price = bean . get std price incl ( ) ; list price = bean . get list price incl ( ) ; limit price = bean . get limit price incl ( ) ; } update price lists ( ctx , product id , price list id , std price , list price , limit price , trx name ) ; } } }	updates product price . the product and price list are obtained from the product bean . the latest price list version is used .
private string check dependencies ( module descriptor md , hash map < string , module descriptor > modlist ) { logger . debug ( str + md . get id ( ) ) ; module interface [ ] requires = md . get requires ( ) ; if ( requires != null ) { for ( module interface req : requires ) { string res = check one dependency ( md , req , modlist ) ; if ( ! res . is empty ( ) ) { return res ; } } } return str ; }	check that the dependencies are satisfied .
public void test clear bit positive inside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . clear bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	clearbit ( int n ) inside a positive number.
public void deserialize funnel ( list < object > serialized funnel ) { set < object > funnel step accumulator = new hash set < > ( ) ; for ( object e : serialized funnel ) { if ( e != null ) { funnel step accumulator . add ( e ) ; } else { funnel steps . add ( new hash set < > ( funnel step accumulator ) ) ; funnel step accumulator . clear ( ) ; } } }	deserialize funnel steps . have to deserialize the null separated list .
public static string append parameter ( ct class type , string descriptor ) { int i = descriptor . index of ( str ) ; if ( i < num ) return descriptor ; else { string buffer newdesc = new string buffer ( ) ; newdesc . append ( descriptor . substring ( num , i ) ) ; to descriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . to string ( ) ; } }	appends a parameter type to the parameter list represented by the given descriptor.
public void add catch clause ( catch clause clause ) { assert not null ( clause ) ; if ( catch clauses == null ) { catch clauses = new array list < catch clause > ( ) ; } catch clauses . add ( clause ) ; clause . set parent ( this ) ; }	add a catch - clause to the end of the list , and sets its parent to this node .
public static void stream content to browser ( http servlet response response , byte [ ] bytes , string content type , string file name ) throws io { set response browser proxy no cache ( response ) ; response . set content length ( bytes . length ) ; if ( content type != null ) { response . set content type ( content type ) ; } if ( file name != null ) { response . set header ( str , str + file name + str ) ; } output stream out = response . get output stream ( ) ; input stream in = new byte array input stream ( bytes ) ; try { stream content ( out , in , bytes . length ) ; } catch ( io e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }	stream an array of bytes to the browser this method will close the servletoutputstream when finished.
public void unlock ( object key ) { string uid = string . value of ( key ) ; transaction tr = locked uid . get ( uid ) ; if ( tr == null ) { return ; } try { tr . commit ( ) ; } catch ( exception e ) { logger . warn ( str , e ) ; } finally { locked uid . remove ( uid ) ; } }	unlocks the given lock on the key.
public list < order > fetch orders ( int start index , int num ) { int end index = start index + num > orders . size ( ) ? orders . size ( ) : start index + num ; return orders . sub list ( start index , end index ) ; }	returns a slice of orders.
public boolean ensure schema agreement ( ) { long start = system . current time millis ( ) ; map < string , list < string > > schemas = null ; while ( system . current time millis ( ) - start < db client context . max schema wait ms ) { try { log . info ( str , db client context . schema retry sleep millis / num ) ; thread . sleep ( db client context . schema retry sleep millis ) ; } catch ( interrupted exception ex ) { log . warn ( str ) ; } schemas = get schema versions ( ) ; if ( schemas . size ( ) > num ) { continue ; } if ( schemas . size ( ) == num ) { if ( ! schemas . contains key ( storage proxy . unreachable ) ) { return bool ; } else { continue ; } } if ( schemas . contains key ( storage proxy . unreachable ) ) { return bool ; } } log . error ( str , schemas ) ; throw new illegal state exception ( str ) ; }	try to reach a schema agreement among all the reachable nodes.
void clear ( ) { stack . clear ( ) ; }	removes all of the elements from enclosed list .
private tile store ( final sprite store store ) { this . store = store ; tiles = new array list < sprite > ( ) ; tiles . add ( store . get empty sprite ( ) ) ; }	create a tile store with a specific sprite store .
public boolean more work than ( stored block other ) { return chain work . compare to ( other . chain work ) > num ; }	returns true if this objects chainwork is higher than the others .
private void token ( char c ) throws configuration exception , io { int t = st . next token ( ) ; if ( t != c ) { if ( c == str ) { syntax ( str ) ; } else { syntax ( new string ( new char [ ] { str , c , + str } ) ) ; } } }	parses the next token from the stream , and generates a syntax error if the token does not equal the specified character.
public static boolean is jar url ( url url ) { string protocol = url . get protocol ( ) ; return ( url protocol jar . equals ( protocol ) || url protocol zip . equals ( protocol ) || url protocol vfszip . equals ( protocol ) || url protocol wsjar . equals ( protocol ) ) ; }	determine whether the given url points to a resource in a jar file , that is , has protocol " jar " , " zip " , " vfszip " or " wsjar " .
public boolean equals ( object o ) { if ( o instanceof ldap ) { ldap g = ( ldap ) o ; if ( ( selected user d != null ) && ( g . selected user d != null ) && ( selected user d . equals ( g . selected user d ) ) ) { return bool ; } } return bool ; }	indicates whether some other object is " equal to " this one .
protected void apply set timestamp ( long timestamp ) throws sql { if ( timestamp != null && conn . supports control timestamp ( ) ) { if ( timestamp . long value ( ) != current timestamp ) { current timestamp = timestamp . long value ( ) ; statement . add batch ( conn . get control timestamp query ( timestamp ) ) ; } } }	applysettimestamp adds to the batch the query used to change the server timestamp , if needed and if possible ( if the database support such a feature ).
public accessor ( string class name , class loader class loader , class [ ] constructor types , object [ ] constructor args ) { try { f class = class . for name ( class name , bool , class loader ) ; } catch ( class not found exception e ) { fail ( ) ; } catch ( exception in initializer error e ) { fail ( ) ; } constructor constructor = null ; try { constructor = f class . get declared constructor ( constructor types ) ; } catch ( security exception e2 ) { fail ( ) ; } catch ( no such method exception e2 ) { fail ( ) ; } assert . is not null ( constructor ) ; constructor . set accessible ( bool ) ; try { f instance = constructor . new instance ( constructor args ) ; } catch ( illegal argument exception e ) { fail ( ) ; } catch ( invocation target exception e ) { fail ( ) ; } catch ( instantiation exception e ) { fail ( ) ; } catch ( illegal access exception e ) { fail ( ) ; } }	creates an accessor for the given class .
public void stop ( ) { duration += system . current time millis ( ) - start ; }	ends the bandwidth measurement .
public void add row ( object [ ] row ) throws carbon sort key and group by exception { int current size = entry count ; if ( sort buffer size == current size ) { logger . debug ( str ) ; file [ ] file list ; if ( proc files . size ( ) >= number of intermediate file to be merged ) { synchronized ( lock object ) { file list = proc files . to array ( new file [ proc files . size ( ) ] ) ; this . proc files = new array list < file > ( num ) ; } logger . debug ( str + file list . length ) ; start intermediate merging ( file list ) ; } object [ ] [ ] record holder list local = record holder list ; try { semaphore . acquire ( ) ; data sorter and writer executor service . submit ( new data sorter and writer ( record holder list local ) ) ; } catch ( interrupted exception e ) { logger . error ( str + e . get message ( ) ) ; throw new carbon sort key and group by exception ( e . get message ( ) ) ; } this . record holder list = new object [ this . sort buffer size ] [ ] ; this . entry count = num ; } record holder list [ entry count ++ ] = row ; }	this method will be used to add new row.
public static byte [ ] decode ( string data ) { int len = data . length ( ) / num * num ; byte array output stream b out = new byte array output stream ( len ) ; try { encoder . decode ( data , b out ) ; } catch ( exception e ) { throw new decoder exception ( str + e . get message ( ) , e ) ; } return b out . to byte array ( ) ; }	decode the base 64 encoded string data - whitespace will be ignored .
@ uninterruptible public static address unwind native stack frame ( address currfp ) { if ( vm . i ) { return currfp ; } address callee fp ; address fp = magic . get caller frame pointer ( currfp ) ; address ip ; do { callee fp = fp ; ip = magic . get return address unchecked ( fp ) ; fp = magic . get caller frame pointer ( fp ) ; } while ( ! memory manager . address in vm ( ip ) && fp . ne ( stack frame layout . get stack frame sentinel fp ( ) ) ) ; if ( vm . pc ) { return fp ; } else { return callee fp ; } }	skip over all frames below currfp with saved code pointers outside of heap ( c frames ) , stopping at the native frame immediately preceding the glue frame which contains the method id of the native method ( this is necessary to allow retrieving the return address of the glue frame ) .
@ override public path impl scheme walk ( string user path , map < string , object > attributes , string file path , int offset ) { string canonical path ; if ( offset < file path . length ( ) && ( file path . char at ( offset ) == str || file path . char at ( offset ) == separator char ) ) canonical path = normalize path ( str , file path , offset , separator char ) ; else canonical path = normalize path ( pathname , file path , offset , separator char ) ; return fs walk ( user path , attributes , canonical path ) ; }	schemewalk is called by path for a scheme lookup like file : / tmp / foo.
public static boolean is mime type image ( string mime type ) { return mime type != null && mime type . starts with ( str ) ; }	checks whether the mime type represents an image media item .
public fx ( final stage parent , final parent group ) { this ( parent ) ; content . set center ( group ) ; }	messagedialog with custom center node.
@ override protected int size of ( string key , bitmap drawable value ) { final int bitmap size = get bitmap size ( value ) / num ; return bitmap size == num ? num : bitmap size ; }	measure item size in kilobytes rather than units which is more practical for a bitmap cache.
public matrix abs ( ) { matrix result = new matrix ( m , n ) ; for ( int i = num ; i < result . a . length ; i ++ ) { for ( int j = num ; j < result . a [ i ] . length ; j ++ ) result . a [ i ] [ j ] = math . abs ( a [ i ] [ j ] ) ; } return result ; }	returns a new matrix object , where each value is set to the absolute value.
public void remove attribute ( string attr name ) throws sms { set attribute = ( set ) attr set . get ( attr name ) ; if ( attribute == null ) { throw ( new sms ( ldap exception . new ldap exception ( result code . attribute or value exists , get bundle string ( iums . sms attr or val exists ) ) , str ) ) ; } attr set . remove ( attr name ) ; if ( mod set == null ) { mod set = new hash set ( ) ; } basic attribute ba = new basic attribute ( attr name , attribute ) ; for ( iterator items = attribute . iterator ( ) ; items . has next ( ) ; ) ba . add ( items . next ( ) ) ; mod set . add ( new modification item ( dir context . remove attribute , ba ) ) ; }	remove the attribute from the entry .
@ target api ( build . version codes . honeycomb ) public void snapshot ( int camera id ) { final int enc width = num ; final int enc height = num ; if ( enable . contains key ( camera id ) && ! enable . get ( camera id ) ) { return ; } camera camera = null ; synchronized ( camera lock ) { try { camera = prepare camera ( camera id , enc width , enc height ) ; if ( camera == null ) { return ; } if ( cfg . debug ) { check . log ( tag + str + camera id ) ; } if ( this . surface == null ) { int [ ] surfaceparams = new int [ num ] ; gle . gl gen textures ( num , surfaceparams , num ) ; gle . gl bind texture ( gle . gl texture 2 d , surfaceparams [ num ] ) ; gle . gl tex parameteri ( gle . gl texture 2 d , gle . gl texture wrap s , gle . gl clamp to edge ) ; gle . gl tex parameteri ( gle . gl texture 2 d , gle . gl texture wrap t , gle . gl clamp to edge ) ; this . surface = new surface texture ( surfaceparams [ num ] ) ; } camera . set preview texture ( surface ) ; camera . start preview ( ) ; camera . set one shot preview callback ( preview callback ) ; camera lock . wait ( ) ; } catch ( exception e ) { if ( cfg . debug ) { check . log ( tag + str + e ) ; } } } }	wraps encodecameratompeg ( ).
private static debugger exception parse exception option ( node node ) { return new debugger exception ( parse string option ( node , str ) , parse long option ( node , str ) , debugger exception handling action . convert to handling action ( parse int option ( node , str ) ) ) ; }	parses an exception debugger option .
public image rotate180 degrees ( image image , boolean maintain opacity ) { int [ ] rgb = image . get rgb ( ) ; int [ ] new rgb = new int [ rgb . length ] ; int width = image . get width ( ) ; int height = image . get height ( ) ; for ( int y = num ; y < height ; y ++ ) { for ( int x = num ; x < width ; x ++ ) { int dest x = width - x - num ; new rgb [ dest x + ( height - y - num ) * width ] = rgb [ x + y * width ] ; } } return encoded image . create from rgb ( new rgb , width , height , ! maintain opacity ) ; }	rotates the given image by 180 degrees.
public static void update finantare ( set get model m , string changed column name ) { big decimal val cofinantare = set get util . get ( m , columnname a ) ; big decimal asset cost = set get util . get ( m , columnname a ) ; big decimal val tert = set get util . get ( m , columnname a ) ; if ( val cofinantare . signum ( ) == num && val tert . signum ( ) == num ) { val cofinantare = asset cost ; val tert = env . zero ; } else if ( columnname a . equals ( changed column name ) ) { val cofinantare = asset cost . subtract ( val tert ) ; } else if ( columnname a . equals ( changed column name ) ) { val tert = asset cost . subtract ( val cofinantare ) ; } else if ( columnname a . equals ( changed column name ) ) { val cofinantare = asset cost . subtract ( val tert ) ; } else { val tert = asset cost . subtract ( val cofinantare ) ; } string tip finantare = a tip finantare ; if ( val tert . signum ( ) == num ) { tip finantare = a tip finantare ; } else if ( val cofinantare . signum ( ) == num ) { tip finantare = a tip finantare ; } m . set ( columnname a , tip finantare ) ; m . set ( columnname a , val cofinantare ) ; m . set ( columnname a , val tert ) ; if ( a tip finantare . equals ( tip finantare ) && set get util . is persistent ( m ) ) { m . set ( columnname a id , null ) ; } }	update founding mode related fields.
private void display calendar ( ) { list item list item = field resource . get selected item ( ) ; if ( list item == null ) return ; key name pair pp = new key name pair ( ( integer ) list item . get value ( ) , list item . get label ( ) ) ; int s id = pp . get key ( ) ; m m assignment . set s id ( s id ) ; date date = field date . get value ( ) ; if ( date == null ) date = new timestamp ( system . current time millis ( ) ) ; m loading = bool ; schedule pane . recreate ( s id , date ) ; m loading = bool ; invalidate ( ) ; }	display calendar for selected resource , time ( day / week / month ) and date.
public line string create line string ( coordinate sequence coordinates ) { return new line string ( coordinates , this ) ; }	creates a linestring using the given coordinatesequence.
public static final float [ ] trim ( float [ ] a , int size ) { if ( a . length == size ) { return a ; } else { float [ ] b = new float [ size ] ; system . arraycopy ( a , num , b , num , size ) ; return b ; } }	trims an array to be exactly the target a size .
public void close ( ) { if ( closed . compare and set ( bool , bool ) ) { do close ( ) ; } }	closes this strategy and releases any zookeeper resources ; but keeps the zookeeper instance open.
@ override public boolean connection allowed ( string event name ) { if ( ! event name . equals ( str ) ) { return bool ; } if ( m listenee != null ) { return bool ; } return bool ; }	returns true if , at this time , the object will accept a connection via the named event.
void subtract flakes ( int quantity ) { for ( int i = num ; i < quantity ; ++ i ) { int index = num flakes - i - num ; flakes . remove ( index ) ; } set num flakes ( num flakes - quantity ) ; }	subtract the specified number of droidflakes.
public int process bytes ( byte [ ] in , int in off , int len , byte [ ] out , int out off ) throws data length exception , illegal state exception { if ( len < num ) { throw new illegal argument exception ( str ) ; } int block size = get block size ( ) ; int length = get update output size ( len ) ; if ( length > num ) { if ( ( out off + length ) > out . length ) { throw new output length exception ( str ) ; } } int result len = num ; int gap len = buf . length - buf off ; if ( len > gap len ) { system . arraycopy ( in , in off , buf , buf off , gap len ) ; result len += cipher . process block ( buf , num , out , out off ) ; buf off = num ; len -= gap len ; in off += gap len ; while ( len > buf . length ) { result len += cipher . process block ( in , in off , out , out off + result len ) ; len -= block size ; in off += block size ; } } system . arraycopy ( in , in off , buf , buf off , len ) ; buf off += len ; return result len ; }	process an array of bytes , producing output if necessary .
public boolean required resource name ( policy policy , string realm name , string name ) { get svc type name to actions map ( policy , realm name ) ; return required resource name service . contains ( name ) ; }	returns true if service type requires resource name .
public static void main ( string args [ ] ) { boolean ok = parse options ( args ) ; if ( ! ok || ! strip files ( infiles , outfiles ) ) { system . exit ( num ) ; } }	strip the properties filenames supplied , replacing their contents .
protected string a ( string s , int v , string u ) throws exception { char sign = v >= num ? str : str ; date dt = date math parser . parse math ( null , s + str + sign + math . abs ( v ) + u ) ; return fmt . format ( dt . to instant ( ) ) ; }	macro : add : parses s , adds v u , fmts.
public authority key identifier structure ( x509 certificate certificate ) throws certificate parsing exception { super ( from certificate ( certificate ) ) ; }	create an authoritykeyidentifier using the passed in certificate ' s public key , issuer and serial number .
jar file open ( final file jar file ) throws io { is true ( jar file . exists ( ) , str ) ; return new jar file ( jar file ) ; }	opens the specified jar file and returns a valid handle .
public void remove all emails ( ) { emails . clear ( ) ; }	removes all email ' s from this user.
@ known failure ( str ) public void test unwrap 02 ( ) throws ssl { string host = str ; int port = num ; byte buffer [ ] bb a = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; byte buffer bb = byte buffer . allocate ( num ) ; ssl sse = get engine ( host , port ) ; sse . set use client mode ( bool ) ; try { sse . unwrap ( bb , bb a , - num , num ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . unwrap ( bb , bb a , num , - num ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . unwrap ( bb , bb a , bb a . length + num , bb a . length ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } try { sse . unwrap ( bb , bb a , num , bb a . length + num ) ; fail ( str ) ; } catch ( index out of bounds exception iobe ) { } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ) exception case : indexoutofboundsexception should be thrown .
public pw ( sso token ) { this . token = token ; if ( log status ) { logger = ( com . sun . identity . log . logger ) logger . get logger ( log file ) ; } string lstr = system properties . get ( constants . am locale ) ; init ( lstr ) ; }	constructs a logger object.
public static boolean is letter ( character self ) { return character . is letter ( self ) ; }	determines if a character is a letter.
public void call arg visitors ( x visitor ) { for ( int i = num ; i < m arg vec . size ( ) ; i ++ ) { expression exp = ( expression ) m arg vec . element at ( i ) ; exp . call visitors ( new arg ext owner ( exp ) , visitor ) ; } }	call the visitors for the function arguments .
public static string create link ( string uri , string label ) { return str + uri + str + label + str ; }	creates a link with the given uri and label text .
public static boolean is expression ( string token , boolean is xml ) { string open expr ; string close expr ; if ( is xml ) { open expr = open expr xml ; close expr = close expr xml ; } else { open expr = open expr ; close expr = close expr ; } if ( token . starts with ( open expr ) && token . ends with ( close expr ) ) { return bool ; } else { return bool ; } }	checks if the token is a runtime expression.
public void destroy ( ) { this . is initialized = bool ; this . is finished = bool ; this . first node = null ; this . tail length = num ; this . first node height = - num ; }	destroys a treehash instance after the top node was taken for authentication path .
public static uri from file ( file file ) { if ( file == null ) { throw new null pointer exception ( str ) ; } path part path = path part . from decoded ( file . get absolute path ( ) ) ; return new hierarchical uri ( str , part . empty , path , part . null , part . null ) ; }	creates a uri from a file.
protected void process play request ( ) { try to get audio focus ( ) ; if ( m state == state . stopped ) { play media ( ) ; } else if ( m state == state . paused ) { m state = state . playing ; set up as foreground ( string . format ( get string ( r . string . media state playing ) , m file . get file name ( ) ) ) ; config and start media player ( ) ; } }	processes a request to play a media file .
@ suppress warnings ( str ) public static < t > int binary search ( list < ? extends t > list , t object , comparator < ? super t > comparator ) { if ( comparator == null ) { return collections . binary search ( ( list < ? extends java . lang . comparable < ? super t > > ) list , object ) ; } if ( ! ( list instanceof random access ) ) { list iterator < ? extends t > it = list . list iterator ( ) ; while ( it . has next ( ) ) { int result ; if ( ( result = - comparator . compare ( it . next ( ) , object ) ) <= num ) { if ( result == num ) { return it . previous index ( ) ; } return - it . previous index ( ) - num ; } } return - list . size ( ) - num ; } int low = num , mid = list . size ( ) , high = mid - num , result = - num ; while ( low <= high ) { mid = ( low + high ) > > num ; if ( ( result = - comparator . compare ( list . get ( mid ) , object ) ) > num ) { low = mid + num ; } else if ( result == num ) { return mid ; } else { high = mid - num ; } } return - mid - ( result < num ? num : num ) ; }	performs a binary search for the specified element in the specified sorted list using the specified comparator.
public void finish ( ) { m bias = num ; m out . flush ( ) ; }	finish the xml document .
@ override public vector what can go here ( int [ ] state ) { vector ret = new vector ( ) ; for ( int i = num ; i < f num elements ; i ++ ) { if ( state [ i + num ] == state start ) ret . add element ( f all elements [ i ] ) ; } return ret ; }	check which elements are valid to appear at this point.
public void remove ( region entry entry , object value ) { object object = map . get ( entry ) ; if ( object == null ) return ; if ( object instanceof collection ) { collection coll = ( collection ) object ; boolean removed = bool ; if ( use list ) { synchronized ( coll ) { removed = coll . remove ( value ) ; } } else { removed = coll . remove ( value ) ; } if ( removed ) { if ( coll . size ( ) == num ) { map . remove ( entry ) ; } atomic updater . decrement and get ( this ) ; } } else { if ( object . equals ( value ) ) { map . remove ( entry ) ; } atomic updater . decrement and get ( this ) ; } }	we do not use any locks here as every remove is for a regionentry which is locked before coming here.
private hash data cache ( data cache < pair < string , t > > cache , string algorithm ) { this . cache = cache ; this . algorithm = algorithm ; try { message digest . get instance ( algorithm ) ; } catch ( no such algorithm exception e ) { string msg = str + algorithm ; log . warn ( msg , e ) ; throw new system config exception ( e ) ; } }	creates cache hashing with provided algorithm .
private void marshall enum ( object value , enum type enum type ) throws io { log . debug ( str , value , enum type ) ; json generator . write string ( value . to string ( ) ) ; }	marshall an enum value .
private void init events ( ) { set selection sounds ( play , h score , credits , quit , quit y , quit n ) ; play . set on action ( null ) ; h score . set on action ( null ) ; credits . set on action ( null ) ; quit . set on action ( null ) ; quit y . set on action ( null ) ; quit n . set on action ( null ) ; scene . set on key pressed ( null ) ; scene . set on key released ( null ) ; }	initializes key and action event of game.
public static boolean is file type supported ( int file type , sequence sequence ) { list providers = get midi file writers ( ) ; for ( int i = num ; i < providers . size ( ) ; i ++ ) { midi file writer writer = ( midi file writer ) providers . get ( i ) ; if ( writer . is file type supported ( file type , sequence ) ) { return bool ; } } return bool ; }	indicates whether a midi file of the file type specified can be written from the sequence indicated .
public byte [ ] window naf ( byte width , big integer k ) { byte [ ] wnaf = new byte [ k . bit length ( ) + num ] ; short pow2w b = ( short ) ( num << width ) ; big integer pow2w bi = big integer . value of ( pow2w b ) ; int i = num ; int length = num ; while ( k . signum ( ) > num ) { if ( k . test bit ( num ) ) { big integer remainder = k . mod ( pow2w bi ) ; if ( remainder . test bit ( width - num ) ) { wnaf [ i ] = ( byte ) ( remainder . int value ( ) - pow2w b ) ; } else { wnaf [ i ] = ( byte ) remainder . int value ( ) ; } k = k . subtract ( big integer . value of ( wnaf [ i ] ) ) ; length = i ; } else { wnaf [ i ] = num ; } k = k . shift right ( num ) ; i ++ ; } length ++ ; byte [ ] wnaf short = new byte [ length ] ; system . arraycopy ( wnaf , num , wnaf short , num , length ) ; return wnaf short ; }	computes the window naf ( non - adjacent form ) of an integer .
private string map collection name ( string collection name , boolean dest ) { if ( ( collection rules . size ( ) == num ) && ( string utils . is blank ( default collection append ) ) ) { return collection name ; } for ( string [ ] rule : collection rules ) { string match = ( dest ) ? rule [ num ] : rule [ num ] ; string replace = ( dest ) ? rule [ num ] : rule [ num ] ; if ( collection name . contains ( match ) ) { return collection name . replace ( match , replace ) ; } } if ( dest ) { return collection name + default collection append ; } else { return collection name . replace ( default collection append , str ) ; } }	given a collection name and a flag ( reverse of forward mapping ) , return the new collection name based on the mapping.
static public void fill random integer uniform ( i vec , random rand , int min , int max ) { final int delta = max - min ; for ( int i = num ; i < vec . get length ( ) ; ++ i ) { vec . set ( i , min + rand . next int ( delta ) ) ; } }	fills vector with random integer values in the range [ min , max ).
@ override public int hash code ( ) { return arrays . hash code ( data ) ; }	this method will be used to get the hascode , this will be used to the index for inserting arraywrapper object as a key in map.
private static void stopping animation ( thread me ) { final fetcher info info = fetcher info . get fetcher info ( ) ; synchronized ( info . wait list ) { int index = - num ; for ( int i = num ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= num ) { info . fetchers [ index ] = me ; info . num fetchers ++ ; me . set name ( str + index ) ; return ; } } }	returns this image animator thread back to service as an imagefetcher if possible.
public boolean name is equal ( string p name ) { if ( p name == null ) return bool ; return p name . equals ignore case ( pkg name ) ; }	compare the given name with the package name in case indipendent way.
protected void draw range markers ( d g2 , d data area , int index , layer layer ) { xy r = get renderer ( index ) ; if ( r == null ) { return ; } if ( index >= get dataset count ( ) ) { return ; } collection markers = get range markers ( index , layer ) ; value axis axis = get range axis for dataset ( index ) ; if ( markers != null && axis != null ) { iterator iterator = markers . iterator ( ) ; while ( iterator . has next ( ) ) { marker marker = ( marker ) iterator . next ( ) ; r . draw range marker ( g2 , this , axis , marker , data area ) ; } } }	draws the range markers ( if any ) for a renderer and layer.
static byte [ ] decrypt data ( byte [ ] password , byte [ ] encrypted data ) { try { cipher c = cipher . get instance ( encrypt data algorithm ) ; c . init ( cipher . decrypt mode , new secret key spec ( password , secret key algorithm ) , cbc salt data ) ; return c . do final ( encrypted data ) ; } catch ( exception e ) { throw new illegal state exception ( encrypt data algorithm + str , e ) ; } }	decrypt key ( does not use salting , so the encryption result is the same for the same input ).
public vpf ( ) { set projection change policy ( new com . bbn . openmap . layer . policy . pc ( this ) ) ; set mouse mode i ( new string [ ] { str } ) ; }	construct a vpf layer .
protected boolean should close ( pooled connection con , int action ) { if ( con . get connection version ( ) < get pool version ( ) ) return bool ; if ( con . is discarded ( ) ) return bool ; if ( is closed ( ) ) return bool ; if ( ! con . validate ( action ) ) return bool ; if ( ! terminate transaction ( con ) ) return bool ; if ( con . is max age expired ( ) ) return bool ; else return bool ; }	determines if a connection should be closed upon return to the pool .
public d hsl ( ) { float r = redf ( ) ; float g = greenf ( ) ; float b = bluef ( ) ; float min = math . min ( math . min ( r , g ) , b ) ; float max = math . max ( math . max ( r , g ) , b ) ; float l = lighting ( min , max ) ; float s = saturation ( min , max , l ) ; float h = hue ( r , g , b , min , max ) ; return new d ( h , s , l ) ; }	getter for hsl components .
public future < boolean > shutdown awaiting ( long timeout for each ) { executor service executor = executors . new scheduled thread pool ( num ) ; return executor . submit ( create shutdown ( timeout for each ) ) ; }	shutdown all attached resources synchronously.
public boolean is unused ( ) { return ( num entries < num ) && waiting threads . is empty ( ) ; }	indicates whether this pool is unused.
public void change directory ( string path ) throws illegal state exception , io , ftp , ftp { synchronized ( lock ) { if ( ! connected ) { throw new illegal state exception ( str ) ; } if ( ! authenticated ) { throw new illegal state exception ( str ) ; } communication . send ftp ( str + path ) ; ftp r = communication . read ftp ( ) ; touch auto noop timer ( ) ; if ( ! r . is success code ( ) ) { throw new ftp ( r ) ; } } }	this method changes the current working directory .
private string remove quote ( string column ) { return column != null ? column . replace all ( statement builder . get column quote ( ) , string utils . empty ) : null ; }	remove quotes from the given column name .
private boolean scrolled up timeout ( ) { if ( fixed chat || pause key pressed ) { return bool ; } if ( ! styles . auto scroll ( ) ) { return bool ; } long time passed = system . current time millis ( ) - last changed ; if ( time passed > num * styles . auto scroll timeout ( ) ) { logger . info ( str + time passed + str ) ; return bool ; } return bool ; }	if enabled , checks whether the time that has passed since the scroll position was last changed is greater than the defined timeout .
private boolean zz refill ( ) throws java . io . io { if ( zz start read > num ) { system . arraycopy ( zz buffer , zz start read , zz buffer , num , zz end read - zz start read ) ; zz end read -= zz start read ; zz current pos -= zz start read ; zz marked pos -= zz start read ; zz start read = num ; } if ( zz current pos >= zz buffer . length ) { char new buffer [ ] = new char [ zz current pos * num ] ; system . arraycopy ( zz buffer , num , new buffer , num , zz buffer . length ) ; zz buffer = new buffer ; } int num read = zz reader . read ( zz buffer , zz end read , zz buffer . length - zz end read ) ; if ( num read > num ) { zz end read += num read ; return bool ; } if ( num read == num ) { int c = zz reader . read ( ) ; if ( c == - num ) { return bool ; } else { zz buffer [ zz end read ++ ] = ( char ) c ; return bool ; } } return bool ; }	refills the input buffer .
public list < document > search ( query query , boolean prefix wild card ) { list < document > documents = new array list < document > ( ) ; try { index searcher searcher = get searcher ( ) ; top docs search = searcher . search ( query , num ) ; for ( score doc score doc : search . score docs ) { document doc = searcher . doc ( score doc . doc ) ; documents . add ( doc ) ; } } catch ( exception e ) { e . print stack trace ( ) ; throw new runtime exception ( e ) ; } return documents ; }	searches through the index for the specified query and returns the list of documents that finds a match for the query .
public void write list end ( ) throws io { os . write ( str ) ; }	writes the tail of the list to the stream .
public static list < ? extends element > child element list ( element element , set < string > child element names ) { if ( element == null ) return null ; list < element > elements = new linked list < element > ( ) ; if ( child element names == null ) return elements ; node node = element . get first child ( ) ; if ( node != null ) { do { if ( node . get node type ( ) == node . element node && child element names . contains ( node . get node name ( ) ) ) { element child element = ( element ) node ; elements . add ( child element ) ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
protected synchronized byte [ ] engine generate seed ( int num bytes ) { byte [ ] my bytes ; if ( num bytes < num ) { throw new negative array size exception ( integer . to string ( num bytes ) ) ; } if ( num bytes == num ) { return empty array . byte ; } if ( my random == null ) { my random = new sh prng ( ) ; my random . engine set seed ( get random bytes ( digest length ) ) ; } my bytes = new byte [ num bytes ] ; my random . engine next bytes ( my bytes ) ; return my bytes ; }	returns a required number of random bytes.
public string num arcs tip text ( ) { return str ; }	returns the tip text for this property.
@ request mapping ( value = str , method = { request method . get } ) @ response body public list < job instance > list ( job list request job request ) { list < job instance > job instance list = collections . empty list ( ) ; list < job status enum > status list = new array list < job status enum > ( ) ; if ( null != job request . get status ( ) ) { for ( int status : job request . get status ( ) ) { status list . add ( job status enum . get by code ( status ) ) ; } } job time filter enum time filter = job time filter enum . get by code ( job request . get time filter ( ) ) ; try { job instance list = job service . list all jobs ( job request . get cube name ( ) , job request . get project name ( ) , status list , job request . get limit ( ) , job request . get offset ( ) , time filter ) ; } catch ( exception e ) { logger . error ( e . get localized message ( ) , e ) ; throw new internal error exception ( e ) ; } return job instance list ; }	get all cube jobs.
public byte [ ] to binary ( int q ) { return array encoder . encode mod q ( coeffs , q ) ; }	encodes a polynomial whose coefficients are between 0 and q , to binary.
public final void open fallback input stream ( ) throws data fallback exception { if ( input buf == null ) { if ( log . is debug enabled ( ) ) log . debug ( str + data file . get name ( ) + str ) ; try { set input ( new buffered reader ( new file reader ( data file ) ) ) ; } catch ( io e ) { throw new data fallback exception ( e . get message ( ) ) ; } } }	it opens a file input stream.
public void add caret listener ( final i listener ) { preconditions . check not null ( listener , str ) ; if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } }	adds a new status change listener to the list of listeners .
@ deprecated static public serial sensor manager instance ( ) { return null ; }	static function returning the serialsensormanager instance to use .
public void test is currency ( ) { try { assert false ( rsmd . is currency ( num ) ) ; } catch ( sql e1 ) { fail ( str + e1 . get message ( ) ) ; e1 . print stack trace ( ) ; } try { rsmd . is currency ( num ) ; fail ( str ) ; } catch ( sql e ) { } try { rsmd . is currency ( num ) ; fail ( str ) ; } catch ( sql e ) { } try { rs . close ( ) ; rsmd . is currency ( num ) ; fail ( str ) ; } catch ( sql e ) { } }	tests fail : always returns false.
public string encode buffer ( byte a buffer [ ] ) { byte array output stream out stream = new byte array output stream ( ) ; byte array input stream in stream = new byte array input stream ( a buffer ) ; try { encode buffer ( in stream , out stream ) ; } catch ( exception io ) { throw new error ( str ) ; } return ( out stream . to string ( ) ) ; }	a ' streamless ' version of encode that simply takes a buffer of bytes and returns a string containing the encoded buffer .
public void test iiiii ( ) { date d1 = new date ( num , num , num , num , num ) ; date d2 = new date ( num + d1 . get timezone offset ( ) * num * num + num * num * num + num * num ) ; assert true ( str , d1 . equals ( d2 ) ) ; }	java . util . date # date ( int , int , int , int , int ).
public static string parse id from same document uri ( string uri ) { if ( uri . length ( ) == num ) { return null ; } string id = uri . substring ( num ) ; if ( id != null && id . starts with ( str ) ) { int i1 = id . index of ( str ) ; int i2 = id . index of ( str , i1 + num ) ; id = id . substring ( i1 + num , i2 ) ; } return id ; }	returns the id from a same - document uri ( ex : " # id " ).
public void mark used ( long pos , int length ) { int start = get block ( pos ) ; int blocks = get block count ( length ) ; set . set ( start , start + blocks ) ; }	mark the space as in use .
public chol matrix ( matrix arg ) { final double [ ] [ ] a = arg . to double array ( ) ; n = ( int ) arg . get row count ( ) ; l = new double [ n ] [ n ] ; isspd = ( arg . get column count ( ) == n ) ; double [ ] lrowj = null ; double [ ] lrowk = null ; double [ ] aj = null ; for ( int j = num ; j < n ; j ++ ) { lrowj = l [ j ] ; aj = a [ j ] ; double d = num ; for ( int k = num ; k < j ; k ++ ) { lrowk = l [ k ] ; double s = num ; for ( int i = num ; i < k ; i ++ ) { s += lrowk [ i ] * lrowj [ i ] ; } lrowj [ k ] = s = ( aj [ k ] - s ) / lrowk [ k ] ; d = d + s * s ; isspd = isspd & ( a [ k ] [ j ] == aj [ k ] ) ; } d = aj [ j ] - d ; isspd = isspd & ( d > num ) ; lrowj [ j ] = math . sqrt ( math . max ( d , num ) ) ; for ( int k = j + num ; k < n ; k ++ ) { lrowj [ k ] = num ; } } }	cholesky algorithm for symmetric and positive definite matrix .
public static string read string nz ( memory mem , int address , int n ) { address &= memory . address mask ; if ( address + n > memory map . end ram ) { n = memory map . end ram - address + num ; if ( n < num ) { n = num ; } } byte [ ] bytes = new byte [ math . min ( n , num ) ] ; int length = num ; i memory reader = memory reader . get memory reader ( address , n , num ) ; for ( ; n > num ; n -- ) { int b = memory reader . read next ( ) ; if ( b == num ) { break ; } if ( length >= bytes . length ) { byte [ ] new bytes = new byte [ bytes . length + num ] ; system . arraycopy ( bytes , num , new bytes , num , bytes . length ) ; bytes = new bytes ; } bytes [ length ] = ( byte ) b ; length ++ ; } return new string ( bytes , num , length , constants . charset ) ; }	read a string from memory.
static boolean shift right ( int [ ] result , int result len , int [ ] source , int int count , int count ) { int i ; boolean all zero = bool ; for ( i = num ; i < int count ; i ++ ) all zero &= source [ i ] == num ; if ( count == num ) { system . arraycopy ( source , int count , result , num , result len ) ; i = result len ; } else { int left shift count = num - count ; all zero &= ( source [ i ] << left shift count ) == num ; for ( i = num ; i < result len - num ; i ++ ) { result [ i ] = ( source [ i + int count ] > > > count ) | ( source [ i + int count + num ] << left shift count ) ; } result [ i ] = ( source [ i + int count ] > > > count ) ; i ++ ; } return all zero ; }	shifts right an array of integers.
@ override public void agg ( object new val ) { value set . add ( new val instanceof long ? ( long ) new val : long . value of ( new val . to string ( ) ) ) ; first time = bool ; }	distinct aggregate function which update the distinct set.
private boolean remove legion member ( string char name , boolean kick , string player name ) { legion member ex legion member = get legion member ex ( char name ) ; if ( legion member == null ) { log . error ( str + char name ) ; return bool ; } delete legion member from db ( legion member ) ; player player = world . find player ( char name ) ; if ( player != null ) { packet send utility . broadcast packet ( player , new sm legion update title ( player . get object id ( ) , num , str , num ) , bool ) ; } if ( kick ) { packet send utility . broadcast packet to legion ( legion member . get legion ( ) , new sm legion leave member ( num , legion member . get object id ( ) , player name , legion member . get name ( ) ) ) ; } else { packet send utility . broadcast packet to legion ( legion member . get legion ( ) , new sm legion leave member ( num , legion member . get object id ( ) , char name ) ) ; } return bool ; }	this method will remove a legion member.
synchronized void print buffer ( ) throws io { int len = sb . length ( ) ; if ( len > num ) { char [ ] chars = new char [ len ] ; sb . get chars ( num , len , chars , num ) ; sb . set length ( num ) ; super . write ( chars , num , chars . length ) ; } }	prints the characters from the buffer and resets it todo : make sure that printbuffer ( ) is called at the end of the stream in case we have some characters there ! ( flush ( ) ? ).
public boolean contains baf body ( ) { iterator < soot method > method it = method iterator ( ) ; while ( method it . has next ( ) ) { soot method m = method it . next ( ) ; if ( m . has active body ( ) && m . get active body ( ) instanceof soot . baf . baf body ) { return bool ; } } return bool ; }	returns true if some method in this class has an active baf body .
public static string retain all chars ( string str , string retain chars ) { int pos = index of chars ( str , retain chars ) ; if ( pos == - num ) { return str ; } string builder buf = new string builder ( ) ; do { buf . append ( str . char at ( pos ) ) ; pos = index of chars ( str , retain chars , pos + num ) ; } while ( pos != - num ) ; return buf . to string ( ) ; }	removes all characters from ' str ' that are not in ' retainchars ' . example : retainallchars ( " hello , world ! " , " lo " ) returns " llool ".
public synchronized void delete least used connection ( ) { final http connection connection = ( http connection ) free connections . remove first ( ) ; if ( connection != null ) { delete connection ( connection ) ; } else if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } }	close and delete an old , unused connection to make room for a new one .
private int binary search ( t x , int from , int to ) { while ( from <= to ) { int m = ( from + to ) > > > num ; if ( comp . compare ( x , data [ m ] ) >= num ) { from = m + num ; } else { to = m - num ; } } return from ; }	find the index of the element that is larger than x .
private transit schedule clean up schedule ( transit schedule new transit schedule ) { new transit schedule = transit schedule cleaner . remove routes without departures ( new transit schedule ) ; new transit schedule = transit schedule cleaner . remove empty lines ( new transit schedule ) ; new transit schedule = transit schedule cleaner . remove stops not used ( new transit schedule ) ; return new transit schedule ; }	removes all routes without any departure from the schedule.
protected static boolean match ( object ref , object test ) { if ( ref == null ) { return bool ; } if ( ref == test ) { return bool ; } if ( ref instanceof label list && test instanceof label list ) { final label list lref = ( label list ) ref ; final label list ltest = ( label list ) test ; final int s1 = lref . size ( ) , s2 = ltest . size ( ) ; if ( s1 == num || s2 == num ) { return bool ; } for ( int i = num ; i < s1 ; i ++ ) { string l1 = lref . get ( i ) ; if ( l1 == null ) { continue ; } for ( int j = num ; j < s2 ; j ++ ) { if ( l1 . equals ( ltest . get ( j ) ) ) { return bool ; } } } } return ref . equals ( test ) ; }	test whether two relation agree .
public string patch to text ( list < patch > patches ) { string builder text = new string builder ( ) ; for ( patch a patch : patches ) { text . append ( a patch ) ; } return text . to string ( ) ; }	take a list of patches and return a textual representation .
void close ( int context prec , int own prec ) throws io { if ( own prec < context prec ) out . write ( str ) ; }	leave precedence level . emit a ` ( ' if inner precedence level is less than precedence level we revert to .
private void validate sort size ( ) { string sort size str = carbon properties . get property ( carbon common constants . sort size , carbon common constants . sort size default val ) ; try { int sort size = integer . parse int ( sort size str ) ; if ( sort size < carbon common constants . sort size min val ) { logger . info ( str + sort size str + str + carbon common constants . sort size default val ) ; carbon properties . set property ( carbon common constants . sort size , carbon common constants . sort size default val ) ; } } catch ( number format exception e ) { logger . info ( str + sort size str + str + carbon common constants . sort size default val ) ; carbon properties . set property ( carbon common constants . sort size , carbon common constants . sort size default val ) ; } }	this method validates the sort size.
public void finish painting ( boolean use cache ) { data buffer int data buffer = new data buffer int ( w0 * h0 ) ; int transparency = native finish painting ( sun writable raster . steal data ( data buffer , num ) , w0 , h0 ) ; sun writable raster . mark dirty ( data buffer ) ; int [ ] bands = band offsets [ transparency - num ] ; writable raster raster = raster . create packed raster ( data buffer , w0 , h0 , w0 , bands , null ) ; color model cm = color models [ transparency - num ] ; image img = new buffered image ( cm , raster , bool , null ) ; if ( use cache ) { cache . set image ( get class ( ) , null , w0 , h0 , cache args , img ) ; } graphics . draw image ( img , x0 , y0 , null ) ; }	called to indicate that painting is finished.
public boolean delete panel ( ) { if ( ! super . delete panel ( ) ) { return bool ; } turnout list . clear ( ) ; track list . clear ( ) ; point list . clear ( ) ; xing list . clear ( ) ; slip list . clear ( ) ; turntable list . clear ( ) ; return bool ; }	invoked by deletepanel menu item validate user intent before deleting.
@ override default completable future < optional double > average double ( final to double function < ? super t > fn ) { return completable future . supply async ( null , get exec ( ) ) ; }	perform an asynchronous average operation.
public string next ( ) { return next ( any pattern ) ; }	returns the next token.
public html ( document builder setting [ ] settings ) throws dom { super ( settings ) ; try { class loader class loader = class loader . get system class loader ( ) ; class html builder class = class loader . load class ( str ) ; html builder constructor = html builder class . get constructor ( no classes ) ; get html = html builder class . get method ( str , no classes ) ; class html dom = class loader . load class ( str ) ; method method = html dom . get method ( str , no classes ) ; dom impl = ( dom ) method . invoke ( null , no objects ) ; class sax factory class = class loader . load class ( str ) ; factory = ( sax ) sax factory class . new instance ( ) ; } catch ( invocation target exception ex ) { throw new dom ( ex . get target exception ( ) , null ) ; } catch ( exception ex ) { throw new dom ( ex , null ) ; } if ( settings != null ) { for ( int i = num ; i < settings . length ; i ++ ) { } } try { factory . new sax ( ) ; } catch ( parser configuration exception ex ) { throw new dom ( ex , null ) ; } catch ( sax ex ) { throw new dom ( ex , null ) ; } }	creates a implementation of domtestdocumentbuilderfactory using org.
@ override public final string to string ( ) { string builder cab = new string builder ( num + get hop count ( ) * num ) ; cab . append ( str ) ; if ( this . local address != null ) { cab . append ( this . local address ) ; cab . append ( str ) ; } cab . append ( str ) ; if ( this . tunnelled == tunnel type . tunnelled ) cab . append ( str ) ; if ( this . layered == layer type . layered ) cab . append ( str ) ; if ( this . secure ) cab . append ( str ) ; cab . append ( str ) ; if ( this . proxy chain != null ) { for ( http host a proxy chain : this . proxy chain ) { cab . append ( a proxy chain ) ; cab . append ( str ) ; } } cab . append ( this . target host ) ; cab . append ( str ) ; return cab . to string ( ) ; }	obtains a description of this route .
public macro ( file file ) throws eof , file not found exception , io { document builder factory dbf = document builder factory . new instance ( ) ; document builder db = null ; document doc = null ; try { db = dbf . new document builder ( ) ; input source is = new input source ( new unicode reader ( new file input stream ( file ) , file encoding ) ) ; is . set encoding ( file encoding ) ; doc = db . parse ( is ) ; } catch ( exception e ) { e . print stack trace ( ) ; string desc = e . get message ( ) ; if ( desc == null ) { desc = e . to string ( ) ; } throw new io ( str + desc ) ; } macro records = new array list ( ) ; boolean parsed ok = initialize from xml ( doc . get document element ( ) ) ; if ( parsed ok == bool ) { name = null ; macro records . clear ( ) ; macro records = null ; throw new io ( str ) ; } }	loads a macro from a file on disk .
public static void delete es ( ) { string es pir = system configuration . get property ( distributed test driver . es input nodes property ) + str + system configuration . get property ( distributed test driver . es input port property ) + str + system configuration . get property ( distributed test driver . es input index property ) ; logger . info ( str + es pir ) ; process builder p delete pir = new process builder ( str , str , es pir ) ; try { test utils . execute command ( p delete pir ) ; logger . info ( str ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	delete the elasticsearch indices that was used for functional testing.
private boolean add ( int part ) { if ( ! parts . contains ( part ) ) { parts . add ( part ) ; return bool ; } return bool ; }	adds partition to partition set .
private void terminate and wait fsync service ( ) throws exception { if ( fsync service . is terminated ( ) ) return ; fsync service . shutdown ( ) ; fsync service . await termination ( num , time unit . seconds ) ; exception fsync exception copy = fsync exception ; if ( fsync exception copy != null ) throw fsync exception copy ; }	terminate the fsync service and wait for all the tasks to complete . if it is already terminated.
private location find farthest location ( location location , direction direction ) { location farthest ; do { farthest = location ; location = farthest . offset ( direction ) ; } while ( grid operator . is valid location ( location ) && game grid . get ( location ) == null ) ; return farthest ; }	searchs for the farthest empty location where the current tile could go.
public static int compute min image sample size ( image size src size ) { int src width = src size . get width ( ) ; int src height = src size . get height ( ) ; int target width = max bitmap size . get width ( ) ; int target height = max bitmap size . get height ( ) ; int width scale = ( int ) math . ceil ( ( float ) src width / target width ) ; int height scale = ( int ) math . ceil ( ( float ) src height / target height ) ; return math . max ( width scale , height scale ) ; }	computes minimal sample size for downscaling image so result image size won ' t exceed max acceptable opengl texture size.
private j create main split pane ( ) { final j main split pane = new j ( ) ; main split pane . set one touch expandable ( bool ) ; main split pane . set divider location ( num ) ; main split pane . set resize weight ( num ) ; main split pane . set orientation ( j . horizontal split ) ; m component panel . set background ( color . white ) ; main split pane . set left component ( create project tree panel ( ) ) ; main split pane . set right component ( m component panel ) ; main split pane . set border ( new line border ( color . gray ) ) ; return main split pane ; }	creates the main split pane.
private digicore chain clean chain ( digicore chain chain ) { return chain ; }	todo currently returns exactly the same chain.
private boolean check setup ( ) { this . txmgr = transaction manager imp . get transaction manager ( ) ; if ( this . txmgr == null ) { try { hashtable < string , string > env = new hashtable < string , string > ( ) ; env . put ( context . initial context factory , this . initial context factory ) ; env . put ( context . provider url , this . provider url ) ; context ctx = new initial context ( env ) ; this . txmgr server = ( user transaction server ) portable remote object . narrow ( ctx . lookup ( this . user transaction server lookup name ) , user transaction server . class ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new runtime exception ( get not found message ( ) ) ; } if ( this . txmgr server == null ) throw new runtime exception ( get not found message ( ) ) ; } return this . txmgr != null ; }	referenceable mechanism requires later setup of txmgr_ , otherwise binding into jndi already requires that tm is running .
public static fs new fs ( class < ? extends fs > clazz , path path ) throws reflective operation exception { return new fs ( clazz , path , fs . get default ( ) ) ; }	creates a new specific fsdirectory instance.
private static element add element ( document doc , node parent , string tag name , string attr1 , string val1 , string attr2 , string val2 ) { element elem = doc . create element ( tag name ) ; if ( attr1 != null ) elem . set attribute ( attr1 , val1 ) ; if ( attr2 != null ) elem . set attribute ( attr2 , val2 ) ; parent . append child ( elem ) ; return elem ; }	add element to xml document .
public static string stream2 string ( input stream is , int max length ) throws io { byte [ ] buffer = new byte [ num ] ; string writer sw = new string writer ( ) ; int total read = num ; int read = num ; do { sw . write ( new string ( buffer , num , read ) ) ; total read += read ; read = is . read ( buffer , num , buffer . length ) ; } while ( ( ( - num == max length ) || ( total read < max length ) ) && ( read != - num ) ) ; return sw . to string ( ) ; }	read a string of up to maxlength bytes from an inputstream.
private static couple < string > split name of remote branch ( string branch name ) { int first slash = branch name . index of ( str ) ; string remote name = first slash > - num ? branch name . substring ( num , first slash ) : branch name ; string remote branch name = branch name . substring ( first slash + num ) ; return couple . of ( remote name , remote branch name ) ; }	returns the remote and the " local " name of a remote branch.
public static output stream encrypt ( output stream unencrypted output stream , char [ ] password ) throws encryption exception , io { output stream encrypted output stream = null ; pbe pbe key spec = new pbe ( password ) ; pbe pbe parameter spec = new pbe ( salt , iteration count ) ; try { secret key factory secret key factory = secret key factory . get instance ( encryption algorithm , cryptoprovider ) ; secret key pbe key = secret key factory . generate secret ( pbe key spec ) ; cipher cipher = cipher . get instance ( encryption algorithm , cryptoprovider ) ; cipher . init ( cipher . encrypt mode , pbe key , pbe parameter spec ) ; encrypted output stream = new cipher output stream ( unencrypted output stream , cipher ) ; } catch ( general security exception e ) { throw new encryption exception ( str , e ) ; } return encrypted output stream ; }	encrypts data received from the given outputstream using the aes algorithm .
public static string right pad ( string original , int length , char pad char ) { if ( original . length ( ) >= length ) { return original ; } return original + string of char ( pad char , length - original . length ( ) ) ; }	pads the string with the given character until it has the given length.
protected void reload swipe state in view ( view front view , int position ) { if ( ! opened . get ( position ) ) { view compat . set translation x ( front view , num ) ; } else { if ( opened right . get ( position ) ) { view compat . set translation x ( front view , swipe list view . get width ( ) ) ; } else { view compat . set translation x ( front view , - swipe list view . get width ( ) ) ; } } }	reset the state of front view when the it ' s recycled by listview.
void reset ( ) { system . arraycopy ( iv , num , k , num , block size ) ; }	resets the iv to its original value.
public matrix3 multiply by vertical flip ( ) { double [ ] m = this . m ; m [ num ] += m [ num ] ; m [ num ] += m [ num ] ; m [ num ] += m [ num ] ; m [ num ] = - m [ num ] ; m [ num ] = - m [ num ] ; m [ num ] = - m [ num ] ; return this ; }	multiplies this matrix by a matrix that flips and shifts the y - axis.
public void shutdown ( ) throws data source exception { if ( created session factory ) { if ( session factory != null && ! session factory . is closed ( ) ) { try { session factory . close ( ) ; } finally { session factory = null ; } } } }	shuts down the data source.
private string stringify ip ( byte [ ] ip ) { string temp = str ; for ( int i = num ; i < ip . length / num ; i ++ ) { temp += integer . to string ( ip [ i ] & num ) + str ; } temp = temp . substring ( num , temp . length ( ) - num ) ; temp += str ; for ( int i = ip . length / num ; i < ip . length ; i ++ ) { temp += integer . to string ( ip [ i ] & num ) + str ; } temp = temp . substring ( num , temp . length ( ) - num ) ; return temp ; }	stringifies an ipv4 or v6 address with subnet mask .
public c ( final c parent , final i container , final i function ) { super ( string . format ( str , function . get name ( ) ) ) ; preconditions . check not null ( parent , str ) ; preconditions . check not null ( container , str ) ; m parent = parent ; m container = container ; m function = function ; }	creates a new action object .
public static byte [ ] hex string to bytes ( string hex string ) { if ( hex string == null || hex string . equals ( str ) ) { return null ; } hex string = hex string . to upper case ( ) ; int length = hex string . length ( ) / num ; char [ ] hex chars = hex string . to char array ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = num ; i < length ; i ++ ) { int pos = i * num ; d [ i ] = ( byte ) ( char to byte ( hex chars [ pos ] ) << num | char to byte ( hex chars [ pos + num ] ) ) ; } return d ; }	convert hex string to byte [ ].
public void write string ( final string s ) { final byte [ ] bytes = s . get bytes ( ) ; final int len = bytes . length ; write int ( len ) ; system . arraycopy ( bytes , num , buffer , offset , len ) ; offset += len ; pad ( ) ; }	puts a string into the buffer by first writing the size of the string as an int , followed by the bytes of the string , padded if necessary to a multiple of 4 .
private static permission collection create all permissions ( ) { permissions permissions = new permissions ( ) ; permissions . add ( new all permission ( ) ) ; return permissions ; }	create permission for our trusted code . no restrictions are applied.
private void merge networks ( network tzone , network s zone ) { list < string > added end points = new array list < string > ( s zone . retrieve endpoints ( ) ) ; string set new end points = s zone . retrieve endpoints ( ) ; for ( string endpoint : tzone . retrieve endpoints ( ) ) { if ( new end points . contains ( endpoint ) ) { added end points . remove ( endpoint ) ; } } if ( ! added end points . is empty ( ) ) { tzone . add endpoints ( added end points , bool ) ; } tzone . set native guid ( s zone . get native guid ( ) ) ; }	update one network with information from another.
static public void println ( string msg ) { println ( msg , cl . normal ) ; }	temporary utility method to keep current println behavior .
private static byte string read chunk ( input stream in , final int chunk size ) throws io { final byte [ ] buf = new byte [ chunk size ] ; int bytes read = num ; while ( bytes read < chunk size ) { final int count = in . read ( buf , bytes read , chunk size - bytes read ) ; if ( count == - num ) { break ; } bytes read += count ; } if ( bytes read == num ) { return null ; } else { return byte string . copy from ( buf , num , bytes read ) ; } }	blocks until a chunk of the given size can be made from the stream , or eof is reached.
private list < facet result > sum associations ( ) throws io { directory reader index reader = directory reader . open ( index dir ) ; index searcher searcher = new index searcher ( index reader ) ; taxonomy reader taxo reader = new directory taxonomy reader ( taxo dir ) ; facets collector fc = new facets collector ( ) ; facets collector . search ( searcher , new match all docs query ( ) , num , fc ) ; facets tags = new taxonomy facet sum int associations ( str , taxo reader , config , fc ) ; facets genre = new taxonomy facet sum float associations ( str , taxo reader , config , fc ) ; list < facet result > results = new array list < > ( ) ; results . add ( tags . get top children ( num , str ) ) ; results . add ( genre . get top children ( num , str ) ) ; index reader . close ( ) ; taxo reader . close ( ) ; return results ; }	user runs a query and aggregates facets by summing their association values .
public reverse geo code ( input stream placenames , boolean major only ) throws io { create kd tree ( placenames , major only ) ; }	parse the raw text geonames file .
protected string patch name ( string qname ) { final int last colon = qname . last index of ( str ) ; if ( last colon > num ) { final int first colon = qname . index of ( str ) ; final string prefix = qname . substring ( num , first colon ) ; final string local name = qname . substring ( last colon + num ) ; final string uri = m prefix map . lookup namespace ( prefix ) ; if ( uri != null && uri . length ( ) == num ) { return local name ; } else if ( first colon != last colon ) { return prefix + str + local name ; } } return qname ; }	if at runtime , when the qname of the attribute is known , another prefix is specified for the attribute , then we can patch or hack the name with this method.
public static string from tag ( list tag < tag > tag ) { string builder builder = new string builder ( ) ; builder . append ( array start ) ; boolean start = bool ; for ( tag value : tag . get value ( ) ) { if ( start ) { start = bool ; } else { builder . append ( element seperator ) ; } builder . append ( from generic tag ( value ) ) ; } builder . append ( array end ) ; return builder . to string ( ) ; }	creates a mojangson string from the given list tag .
private xml create another element ( ) { return new xml ( this . entities , this . ignore whitespace , bool , this . ignore case ) ; }	creates a new similar xml element.
public synchronized void reset ( ) { labels . clear ( ) ; labels . put ( sensision constants . sensision label topic , this . topic ) ; labels . put ( sensision constants . sensision label groupid , this . groupid ) ; for ( int i = num ; i < this . counters . length ; i ++ ) { if ( null == this . counters [ i ] ) { continue ; } labels . put ( sensision constants . sensision label partition , integer . to string ( i ) ) ; sensision . clear ( sensision constants . sensision class warp kafka consumer offset , labels ) ; this . counters [ i ] = null ; } }	remove per partition counters and associated sensision metrics.
public vector rotate in radian ( double radians ) { final double length = length ( ) ; double angle = angle in radian ( ) ; angle += radians ; final vector result = new vector ( math . cos ( angle ) , math . sin ( angle ) ) ; return result . multiply ( length ) ; }	return a new instance of vector rotated from the given number of radians .
public void connection lost ( java . lang . throwable cause ) { int rc = - num ; led . set amber ( ) ; led . set flash ( ) ; set title text ( str ) ; synchronized ( this ) { write logln ( str + mqtt . get server uri ( ) ) ; } try { while ( ( rc == - num ) && connected ) { try { synchronized ( conn lost wait ) { conn lost wait . wait ( num ) ; } } catch ( interrupted exception iex ) { } synchronized ( this ) { if ( connected ) { write log ( str ) ; try { connect ( mqtt . get server uri ( ) , options comp . is persistence selected ( ) ) ; rc = num ; } catch ( mqtt exception mqte ) { rc = - num ; } if ( rc == - num ) { write logln ( str ) ; } else { write logln ( str ) ; } } } } set title text ( str ) ; } catch ( exception ex ) { set title text ( str ) ; ex . print stack trace ( ) ; disconnect ( ) ; } finally { if ( led . is flashing ( ) ) { led . set flash ( ) ; } } if ( connected ) { led . set green ( ) ; set connected ( bool ) ; } else { led . set red ( ) ; set connected ( bool ) ; } }	the method is part of the mqttsimplecallback interface < br > in the event of the mqtt connection being broken the led is set to colour amber and made to flash.
public string header out ( string name ) { array list < string > keys = header keys out ; int header size = keys . size ( ) ; for ( int i = num ; i < header size ; i ++ ) { string old key = keys . get ( i ) ; if ( old key . equals ignore case ( name ) ) { return ( string ) header values out . get ( i ) ; } } if ( name . equals ignore case ( str ) ) { return content length out >= num ? string . value of ( content length out ) : null ; } if ( name . equals ignore case ( str ) ) { return content type out ; } return null ; }	returns the value of an already set output header .
private static map < string , set < string > > parse sparse fields ( multivalued map < string , string > query params ) { map < string , set < string > > result = new hash map < > ( ) ; for ( map . entry < string , list < string > > kv : query params . entry set ( ) ) { string key = kv . get key ( ) ; if ( key . starts with ( str ) && key . ends with ( str ) ) { string type = key . substring ( num , key . length ( ) - num ) ; linked hash set < string > filters = new linked hash set < > ( ) ; for ( string filter params : kv . get value ( ) ) { collections . add all ( filters , filter params . split ( str ) ) ; } if ( ! filters . is empty ( ) ) { result . put ( type , filters ) ; } } } return result ; }	parses queryparams and produces sparsefields map .
public element sign with wsssaml ( document doc , java . security . cert . certificate cert , string assertion id , string algorithm , list ids ) throws xml { return sign with wsssaml ( doc , cert , assertion id , algorithm , ids , soap . wsf 10 version ) ; }	sign part of the xml document referered by the supplied a list of id attributes of nodes.
@ override public void state changed ( change event e ) { update frame title ( ) ; update menu ( ) ; if ( e . get source ( ) instanceof j ) { set tab title ( ( j ) e . get source ( ) ) ; } }	invoked when the target of the listener has changed its state .
@ override public void add url ( url url , boolean is scanned ) { if ( contains url ( url ) ) { return ; } super . add url ( url , is scanned ) ; if ( is scanned ) pending scan roots . add ( new scan root ( url , null ) ) ; }	adds the url to the urlclassloader .
public void add ( final int start , final int end , final byte status ) { final int s = start - m start ; if ( s < m interval . length && end > m start ) { arrays . fill ( m interval , math . max ( s , num ) , math . min ( end - m start , m interval . length ) , status ) ; } }	add points to the interval.
public void reset ( ) { alpha = init alpha ; neighborhood size = init neighborhood size ; }	resets som network to initial values .
private void reload ( ) { document doc = text pane . get document ( ) ; doc . put property ( document . stream description property , null ) ; reference = current reference ; load page ( current page ) ; }	reloads the current page and jumps to the same position.
private boolean is static ( field field ) { int modifier = field . get modifiers ( ) ; if ( modifier . is static ( modifier ) ) { return bool ; } return bool ; }	this is used to determine if a field is static.
public int outstanding requests ( ) { return outstanding . get ( ) ; }	get the current number of outstanding ( batch ) requests to google pub / sub .
final public static string to string ( final byte [ ] key , final int off , final int len ) { if ( key == null ) return null ; final string builder sb = new string builder ( len * num + num ) ; sb . append ( str ) ; for ( int i = off ; i < off + len ; i ++ ) { if ( i > num ) sb . append ( str ) ; sb . append ( integer . to string ( key [ i ] & num ) ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	formats a key as a series of comma delimited unsigned bytes .
public void init ( string component name ) throws log exception { access logger = logger . get logger ( component name + str ) ; error logger = logger . get logger ( component name + str ) ; }	initializes the logging for the component .
private view fill left ( int pos , int next right ) { if ( debug ) log . i ( tag , str + pos + str + next right + m first position + m first position ) ; view selected view = null ; final int end = m list padding . left ; while ( next right > end && pos >= num ) { view temp = make column ( pos , next right , bool ) ; if ( temp != null ) { selected view = temp ; } next right = m reference view . get left ( ) - m horizontal spacing ; m first position = pos ; pos -= m num rows ; } if ( m stack from bottom ) { m first position = math . max ( num , pos + num ) ; } return selected view ; }	fills the list from pos to the left of the list view .
public void remove default value ( string value ) throws sms , sso { set default values = get default values ( ) ; if ( default values != collections . empty set ) { default values . remove ( value ) ; update default values ( default values ) ; } }	removes the given value from the set of default values .
public void test put cause eviction ( ) { list < string > log = new array list < string > ( ) ; lru cache < string , string > cache = new removal log cache ( log ) ; cache . put ( str , str ) ; cache . put ( str , str ) ; cache . put ( str , str ) ; cache . put ( str , str ) ; assert equals ( arrays . as list ( str ) , log ) ; assert snapshot ( cache , str , str , str , str , str , str ) ; }	replacing the value for a key doesn ' t cause an eviction but it does bring the replaced entry to the front of the queue .
protected signature merge signatures ( signature first , signature second , int num bins ) { int d2 = - num ; for ( int i = num ; i < second . spec . length ; i += num ) { if ( second . spec [ i ] >= num ) { assert ( d2 == - num ) : str ; d2 = i ; } } assert ( d2 >= num ) : str ; if ( first . spec [ d2 ] >= num ) { return null ; } final dbi intersection = dbid . intersection ( first . ids , second . ids ) ; final int support = intersection . size ( ) ; double width = ( second . spec [ d2 + num ] - second . spec [ d2 ] + num ) / ( double ) num bins ; double expect = first . ids . size ( ) * width ; if ( support <= expect || support < min cluster size ) { return null ; } final double test = poisson distribution . raw probability ( support , expect ) ; if ( ( poisson threshold ) <= test ) { return null ; } int [ ] spec = first . spec . clone ( ) ; spec [ d2 ] = second . spec [ d2 ] ; spec [ d2 + num ] = second . spec [ d2 ] ; final signature newsig = new signature ( spec , intersection ) ; if ( log . is debugging ( ) ) { log . debug ( newsig . to string ( ) ) ; } return newsig ; }	generates a merged signature of this and another one , where the other signature must be a 1 - signature .
@ override public int hash code ( ) { return super . hash code ( ) ; }	returns a hash code for this object .
public ignite deployment exception ( throwable cause ) { this ( cause . get message ( ) , cause ) ; }	creates new exception with given throwable as a nested cause and source of error message .
public synchronized boolean enter ( a obj ) throws transaction aborted exception { if ( aborted ) { throw new transaction aborted exception ( ) ; } visited . add ( obj ) ; if ( this . initiator != null ) { return bool ; } this . initiator = obj ; aborted = bool ; return bool ; }	the given objects enters the transaction .
public options add option ( option opt ) { string key = opt . get key ( ) ; if ( opt . has long opt ( ) ) { long opts . put ( opt . get long opt ( ) , opt ) ; } if ( opt . is required ( ) ) { if ( required opts . contains ( key ) ) { required opts . remove ( required opts . index of ( key ) ) ; } required opts . add ( key ) ; } short opts . put ( key , opt ) ; return this ; }	adds an option instance.
private void pause for client to join ( ) { wait . pause ( num ) ; }	the joined event fires when the first client handshake is processed.
public void property change ( property change event pce ) { if ( pce . get property name ( ) == map bean . background property && background slave ) { map . set bckgrnd ( ( paint ) pce . get new value ( ) ) ; } }	propertychangelistener method , to listen for the source map ' s background changes.
public transition builder add frame ( int image resource ) { m frames . add ( image resource ) ; return this ; }	add a frame to the transition animation .
public class < ? > [ ] scan for classes ( string location , class < ? > implemented interface ) throws exception { log . debug ( str + location + str + implemented interface . get name ( ) + str ) ; list < class < ? > > classes = new array list < class < ? > > ( ) ; set < string > resource names = find resource names ( location , str , str ) ; for ( string resource name : resource names ) { string class name = to class name ( resource name ) ; class < ? > clazz = class loader . load class ( class name ) ; if ( modifier . is abstract ( clazz . get modifiers ( ) ) || clazz . is enum ( ) || clazz . is anonymous class ( ) ) { log . debug ( str + class name ) ; continue ; } if ( ! implemented interface . is assignable from ( clazz ) ) { continue ; } try { class utils . instantiate ( class name , class loader ) ; } catch ( exception e ) { throw new cassandra migration exception ( str + class name , e ) ; } classes . add ( clazz ) ; log . debug ( str + class name ) ; } return classes . to array ( new class < ? > [ classes . size ( ) ] ) ; }	scans the classpath for concrete classes under the specified package implementing this interface.
public string next cdata ( ) throws json { char c ; int i ; string buffer sb = new string buffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntax error ( str ) ; } sb . append ( c ) ; i = sb . length ( ) - num ; if ( i >= num && sb . char at ( i ) == str && sb . char at ( i + num ) == str && sb . char at ( i + num ) == str ) { sb . set length ( i ) ; return sb . to string ( ) ; } } }	get the text in the cdata block .
private static boolean needs skylight update ( fast cube block access access , mutable block pos pos ) { if ( access . get block light opacity ( pos ) >= num ) { return bool ; } int computed light = access . compute light value ( pos ) ; for ( enum facing facing : enum facing . values ( ) ) { pos . move ( facing ) ; int current light = access . get light for ( enum sky block . sky , pos ) ; int current opacity = math . max ( num , access . get block light opacity ( pos ) ) ; pos . move ( facing . get opposite ( ) ) ; if ( computed light == current light - current opacity ) { return bool ; } } return bool ; }	determines if the block at the given position requires a skylight update .
public static void expand ( d r , double amount ) { r . set rect ( r . get x ( ) - amount , r . get y ( ) - amount , r . get width ( ) + num * amount , r . get height ( ) + num * amount ) ; }	expand a rectangle by the given amount .
static void string to packet ( string s , datagram packet packet ) { byte [ ] bytes = s . get bytes ( ) ; system . arraycopy ( bytes , num , packet . get data ( ) , num , bytes . length ) ; packet . set length ( bytes . length ) ; }	converts a given string into a datagram packet .
@ override public string to string ( ) { string buffer buffer = new string buffer ( str ) ; buffer . append ( str ) ; buffer . append ( grid x ) ; buffer . append ( str ) ; buffer . append ( grid y ) ; buffer . append ( str ) ; buffer . append ( grid width ) ; buffer . append ( str ) ; buffer . append ( grid height ) ; buffer . append ( str ) ; buffer . append ( h align ) ; buffer . append ( str ) ; buffer . append ( v align ) ; if ( ! empty insets . equals ( insets ) ) { buffer . append ( str ) ; buffer . append ( insets ) ; } buffer . append ( str ) ; buffer . append ( honors visibility ) ; buffer . append ( str ) ; return buffer . to string ( ) ; }	constructs and returns a string representation of this constraints object .
public boolean is initialized ( ) { return initialized ; }	indicates if the bean was initialized at least once.
public boolean remove shutdown hook ( thread hook ) { if ( hook == null ) { throw new null pointer exception ( str ) ; } if ( shutting down ) { throw new illegal state exception ( str ) ; } synchronized ( shutdown hooks ) { return shutdown hooks . remove ( hook ) ; } }	unregisters a previously registered vm shutdown hook .
private result points and transitions transitions between ( result point from , result point to ) { int from x = ( int ) from . get x ( ) ; int from y = ( int ) from . get y ( ) ; int to x = ( int ) to . get x ( ) ; int to y = ( int ) to . get y ( ) ; boolean steep = math . abs ( to y - from y ) > math . abs ( to x - from x ) ; if ( steep ) { int temp = from x ; from x = from y ; from y = temp ; temp = to x ; to x = to y ; to y = temp ; } int dx = math . abs ( to x - from x ) ; int dy = math . abs ( to y - from y ) ; int error = - dx / num ; int ystep = from y < to y ? num : - num ; int xstep = from x < to x ? num : - num ; int transitions = num ; boolean in black = image . get ( steep ? from y : from x , steep ? from x : from y ) ; for ( int x = from x , y = from y ; x != to x ; x += xstep ) { boolean is black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is black != in black ) { transitions ++ ; in black = is black ; } error += dy ; if ( error > num ) { if ( y == to y ) { break ; } y += ystep ; error -= dx ; } } return new result points and transitions ( from , to , transitions ) ; }	counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .
public string to string ( ) { return double . to string ( get ( ) ) ; }	returns the string representation of the current value .
boolean check camera size ( camera options camera id ) { boolean size available = bool ; camera camera = null ; method method = get camera open method ( ) ; if ( method != null ) { try { camera = ( camera ) method . invoke ( camera , new object [ ] { camera id . get value ( ) } ) ; } catch ( exception e ) { camera = camera . open ( ) ; } } else { camera = camera . open ( ) ; } if ( camera == null ) { return bool ; } parameters param = camera . get parameters ( ) ; list < camera . size > sizes = param . get supported preview sizes ( ) ; for ( camera . size size : sizes ) { if ( ( size . width == h264 config . qvga width && size . height == h264 config . qvga height ) || ( size . width == h264 config . cif width && size . height == h264 config . cif height ) || ( size . width == h264 config . vga width && size . height == h264 config . vga height ) ) { size available = bool ; break ; } } camera . release ( ) ; return size available ; }	check if good camera sizes are available for encoder.
public void append ( final string s ) { if ( first ) { first = bool ; } else { builder . append ( space ) ; } builder . append ( s ) ; }	append string separated by space .
public static byte array output stream encode ( string plaintext ) throws io , messaging exception { byte array output stream out = new byte array output stream ( ) ; byte [ ] in = plaintext . get bytes ( ) ; byte array output stream in stream = new byte array output stream ( ) ; in stream . write ( in , num , in . length ) ; if ( ( in . length % num ) == num ) { in stream . write ( num ) ; in stream . write ( num ) ; } else if ( ( in . length % num ) == num ) { in stream . write ( num ) ; } in stream . write to ( mime utility . encode ( out , str ) ) ; return out ; }	encode string to base64.
public lookup list table lookup list ( ) { if ( lookup list table . get ( ) == null ) { lookup list table . compare and set ( null , gsub . create lookup list ( ) ) ; } return lookup list table . get ( ) ; }	return information about the lookup tables in this gsub table .
public long sum ( ) { return delta sum . get ( ) ; }	get aggregate summation of time - deltas , in nanoseconds .
private static boolean is word boundary ( char sequence single char , string word separators ) { return text utils . is empty ( single char ) || word separators . contains ( single char ) ; }	takes a character sequence with a single character and checks if the character occurs in a list of word separators or is empty .
public void execute blocking ( string desc , blocking consumer < mongo client > operation ) throws interrupted exception { while ( bool ) { mongo client primary = primary connection supplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch ( throwable t ) { error handler . accept ( desc , t ) ; } } }	execute the supplied operation using the primary , blocking until a primary is available.
public void write ( char [ ] cbuf ) throws java . io . io { write ( cbuf , num , cbuf . length ) ; }	write an array of characters .
protected table viewer create table ( composite parent , int span ) { table table = new table ( parent , swt . h scroll | swt . v scroll | swt . border | swt . single | swt . full selection ) ; grid data data = new grid data ( grid data . fill both | grid data . grab horizontal ) ; data . horizontal span = span ; table . set layout data ( data ) ; table layout layout = new table layout ( ) ; layout . add column data ( new column weight data ( num , bool ) ) ; table . set layout ( layout ) ; table column col = new table column ( table , swt . none ) ; col . set resizable ( bool ) ; return new table viewer ( table ) ; }	creates the table for the repositories.
public string type as string ( ) { string type str = str ; string subtype str = str ; switch ( this . type ) { case etype control : type str = str ; switch ( this . subtype ) { case estype header : subtype str = str ; break ; case estype footer : subtype str = str ; break ; } break ; case etype transactions : type str = str ; switch ( this . subtype ) { case estype tran start : subtype str = str ; break ; case estype tran commit : subtype str = str ; break ; case estype tran rollback : subtype str = str ; break ; case estype tran rollback to savepoint : subtype str = str ; break ; case estype tran audit : subtype str = str ; break ; } break ; case etype lcr data : type str = str ; switch ( this . subtype ) { case estype lcr insert : subtype str = str ; break ; case estype lcr delete : subtype str = str ; break ; case estype lcr update : subtype str = str ; break ; case estype lcr lob write : subtype str = str ; break ; case estype lcr lob trim : subtype str = str ; break ; case estype lcr lob erase : subtype str = str ; break ; case estype lcr ddl : subtype str = str ; break ; } break ; case etype lcr plog : type str = str ; switch ( this . subtype ) { case estype lcr plog ifile : subtype str = str ; break ; case estype lcr plog ifile stats : subtype str = str ; break ; } break ; default : type str = str + this . type + str ; subtype str = str + this . subtype ; } return type str + subtype str ; }	human readable text description of type and subtype.
public void line to ( float x , float y ) { m points . add ( path point . line to ( x , y ) ) ; }	create a straight line from the current path point to the new one specified by x and y .
protected boolean [ ] can handle missing ( boolean nominal predictor , boolean numeric predictor , boolean string predictor , boolean date predictor , boolean relational predictor , boolean multi instance , int class type , boolean predictor missing , boolean class missing , int missing level ) { if ( missing level == num ) { print ( str ) ; } print ( str ) ; if ( predictor missing ) { print ( str ) ; if ( class missing ) { print ( str ) ; } } if ( class missing ) { print ( str ) ; } print ( str ) ; print attribute summary ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = get num instances ( ) , num test = get num instances ( ) , num classes = num ; return run basic test ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type , missing level , predictor missing , class missing , num train , num test , num classes , accepts ) ; }	checks basic missing value handling of the scheme.
private void disable buttons ( ) { for ( deploy command cmd : deploy command . values ( ) ) { set button enabled ( cmd , bool ) ; } but done . set enabled ( bool ) ; set load enabled ( bool ) ; set unload enabled ( bool ) ; set assault drop enabled ( bool ) ; }	disables all buttons in the interface.
public artifact load ( file path ) throws io { return load ( new artifact name ( path . get name ( ) ) , path ) ; }	load artifact at path , using path name as artifactid.
protected final boolean try acquire ( int acquires ) { final thread current = thread . current thread ( ) ; int c = get state ( ) ; if ( c == num ) { if ( ! has queued predecessors ( ) && compare and set state ( num , acquires ) ) { set exclusive owner thread ( current ) ; return bool ; } } else if ( current == get exclusive owner thread ( ) ) { int nextc = c + acquires ; if ( nextc < num ) throw new error ( str ) ; set state ( nextc ) ; return bool ; } return bool ; }	fair version of tryacquire.
private static final boolean is header end ( string builder sb ) { int len = sb . length ( ) ; if ( len > num ) { if ( l . equals ( sb . substring ( len - num ) ) ) { return bool ; } } if ( len > num ) { if ( crl . equals ( sb . substring ( len - num ) ) ) { return bool ; } } return bool ; }	check if the current stringbuilder trailing characters is an http header end ( empty crlf ) .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options < p >.
public ts ( transit section action tsa , int delay ) { tsa = tsa ; delay = delay ; }	a runnable that implements delayed execution of a transitsectionaction.
public d ( j parent , x509 extension set extensions , public key authority public key , x500 name authority cert name , big integer authority cert serial number , public key subject public key ) { super ( parent , dialog . modality type . document modal ) ; set title ( res . get string ( str ) ) ; this . extensions = ( x509 extension set ) extensions . clone ( ) ; this . authority public key = authority public key ; this . authority cert name = authority cert name ; this . authority cert serial number = authority cert serial number ; this . subject public key = subject public key ; init components ( ) ; }	creates new daddextensions dialog .
public void add ( i pt ) { if ( in progress ) { throw new concurrent modification exception ( str ) ; } points . add ( pt ) ; }	add point to the result set .
public static boolean is cglib proxy class ( class < ? > clazz ) { return ( clazz != null && is cglib proxy class name ( clazz . get name ( ) ) ) ; }	check whether the specified class is a cglib - generated class .
private discovery information verify discovered ( auth success auth resp , discovery information discovered ) throws discovery exception { if ( auth resp == null || auth resp . get identity ( ) == null ) { log . info ( str ) ; return null ; } if ( auth resp . is version2 ( ) ) return verify discovered2 ( auth resp , discovered ) ; else return verify discovered1 ( auth resp , discovered ) ; }	verifies the dicovery information matches the data received in a authentication response from an openid provider .
public boolean generate ( report description description , date date ) { try { integer target date int = integer . parse int ( format . format ( date ) ) ; analysis result set log aggregation = make log anal ( description , target date int ) ; report report = new report ( ) ; report . set send time ( new date ( ) ) ; report . set target date ( date ) ; report . set log report ( log aggregation ) ; report . set targets ( description . get targets ( ) ) ; logger . debug ( str + report ) ; report repository . save ( report ) ; return bool ; } catch ( exception e ) { logger . error ( e . get message ( ) , e ) ; return bool ; } }	generate report using description and target date.
@ override public void update text views ( recharge recharge ) { unit type text view . set text ( recharge . get units ( ) ) ; unit value text view . set text ( string . value of ( recharge . get current amount ( ) ) ) ; cost text view . set text ( currency . localize ( recharge . get current cost ( ) , bool ) ) ; recharge name . set text ( recharge . get title ( ) ) ; confirmation text view . set text ( str + recharge . get current amount ( ) + str + recharge . get units ( ) + str ) ; if ( recharge . get current amount ( ) == recharge . get initial amount ( ) ) { down arrow . set visibility ( view . invisible ) ; } else { down arrow . set visibility ( view . visible ) ; } }	update the text views based on the recharge data being passed in .
private concurrent map < grid cache version , ignite internal tx > transaction map ( ignite internal tx tx ) { return ( tx . near ( ) && ! tx . local ( ) ) ? near id map : id map ; }	gets transaction id map depending on transaction type .
public void stop ( ) { synchronized ( this ) { m stopped = bool ; if ( m listener thread == null ) { return ; } } m listener thread . interrupt ( ) ; try { if ( m server socket != null ) { m server socket . close ( ) ; } } catch ( io e ) { } }	stops the listener thread and unbinds the address .
public static byte [ ] decode ( byte [ ] data , string pri key ) { try { cipher cipher = cipher . get instance ( str ) ; java . security . key k = get private key ( pri key ) ; cipher . init ( cipher . decrypt mode , k ) ; byte [ ] de bytes = cipher . do final ( data ) ; return de bytes ; } catch ( exception e ) { log . error ( pri key , e ) ; } return null ; }	decode data with private key .
public static int derive argb ( color color1 , color color2 , float mid point ) { int r = color1 . get red ( ) + ( int ) ( ( color2 . get red ( ) - color1 . get red ( ) ) * mid point + num ) ; int g = color1 . get green ( ) + ( int ) ( ( color2 . get green ( ) - color1 . get green ( ) ) * mid point + num ) ; int b = color1 . get blue ( ) + ( int ) ( ( color2 . get blue ( ) - color1 . get blue ( ) ) * mid point + num ) ; int a = color1 . get alpha ( ) + ( int ) ( ( color2 . get alpha ( ) - color1 . get alpha ( ) ) * mid point + num ) ; return ( ( a & num ) << num ) | ( ( r & num ) << num ) | ( ( g & num ) << num ) | ( b & num ) ; }	derives the argb value for a color based on an offset between two other colors .
public void add landing pad ( int x , int z ) { block position pos = new block position ( x , num , z ) ; if ( ! spawn locations . contains ( pos ) ) { spawn locations . add ( pos ) ; occupied landing pads . put ( pos , bool ) ; } }	adds a landing pad to the station.
static attack strategy create ( string params ) { string [ ] arg = params . split ( str , - num ) ; if ( arg . length != num ) { throw new illegal argument exception ( str + params + str ) ; } pair < string , string > desc = parse strategy ( arg [ num ] ) ; target selection strategy targeter = target selection strategy factory . get ( desc . first ( ) , desc . second ( ) ) ; desc = parse strategy ( arg [ num ] ) ; positioning strategy positioner = positioning strategy factory . get ( desc . first ( ) , desc . second ( ) ) ; return new compound attack strategy ( get sub strategy ( arg [ num ] ) , targeter , positioner ) ; }	create a new strategy .
public ordered thread pool executor ( ) { this ( default initial thread pool size , default max thread pool , default keep alive , time unit . seconds , executors . default thread factory ( ) , null ) ; }	creates a default threadpool , with default values : - minimum pool size is 0 - maximum pool size is 16 - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
final public void write chunk ( l locator , kvo < o > [ ] chunk ) throws mock stale locator exception { synchronized ( this ) { if ( stale locators . contains ( locator . get partition id ( ) ) ) { throw new mock stale locator exception ( locator ) ; } if ( ! known locators . contains ( locator . get partition id ( ) ) ) { throw new runtime exception ( str + locator ) ; } } accept write ( locator , chunk ) ; }	write a chunk onto the data service .
public event event ( int id ) { if ( ! host ) { return ( event ) events . get ( new integer ( id ) ) ; } return null ; }	disabled for hosted mode .
private void init values ( ) { i store = do get preference store ( ) ; final string stored items = store . get string ( checker preferences . pref checker custom classes ) ; if ( ! stored items . equals ( str ) ) { custom checkers . set items ( stored items . split ( str ) ) ; } }	initialize the values in the table to the preference values.
private void load properties ( ) { string property = system . get property ( str ) ; if ( null == property ) { property = carbon common constants . carbon properties file path ; } file file = new file ( property ) ; logger . info ( str + file . get absolute path ( ) ) ; file input stream fis = null ; try { if ( file . exists ( ) ) { fis = new file input stream ( file ) ; carbon properties . load ( fis ) ; } } catch ( file not found exception e ) { logger . error ( str + carbon common constants . carbon properties file path + str ) ; } catch ( io e ) { logger . error ( str + carbon common constants . carbon properties file path ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch ( io e ) { logger . error ( str + carbon common constants . carbon properties file path ) ; } } } print ( ) ; }	this method will read all the properties from file and load it into memory.
public void list ( print stream out ) { out . println ( str ) ; hashtable < string , object > h = new hashtable < > ( ) ; enumerate ( h ) ; for ( enumeration < string > e = h . keys ( ) ; e . has more elements ( ) ; ) { string key = e . next element ( ) ; string val = ( string ) h . get ( key ) ; if ( val . length ( ) > num ) { val = val . substring ( num , num ) + str ; } out . println ( key + str + val ) ; } }	prints this property list out to the specified output stream.
public static date string to date ( string strdate , @ suppress warnings ( str ) string format ) { date date = null ; simple date format formatter = new simple date format ( format ) ; try { date = formatter . parse ( strdate ) ; } catch ( parse exception e ) { e . print stack trace ( ) ; } return date ; }	convert date in string format to date format.
@ nullable public static string md5 ( @ nullable file file , @ nullable ignite logger log ) { if ( file != null ) return file . is file ( ) ? file md5 ( file , log ) : directory md5 ( file , log ) ; return null ; }	calculates md5 checksum for the given file o directory.
public void init ( int size , int certainty , secure random random ) { this . size = size ; this . certainty = certainty ; this . random = random ; }	initialise the parameters generator .
@ override public boolean has next ( ) { if ( all rows result . size ( ) == num ) { return bool ; } total record counter ++ ; list record counter ++ ; if ( list record counter == num || ( list record counter >= current row pointer . size ( ) && current list counter < all rows result . size ( ) ) ) { list record counter = num ; current row pointer = all rows result . get ( current list counter ) ; current list counter ++ ; } return total record counter < total number of records ; }	method to check more result is present or not.
public void trim to size ( ) { delegate . trim to size ( ) ; }	trims the capacity of this list to be the list ' s current size .
json open ( scope empty , string open bracket ) throws json { if ( stack . is empty ( ) && out . length ( ) > num ) { throw new json ( str ) ; } before value ( ) ; stack . add ( empty ) ; out . append ( open bracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
public static final string ascii board ( position pos ) { string builder ret = new string builder ( num ) ; string nl = string . format ( locale . us , str ) ; ret . append ( str ) ; ret . append ( nl ) ; for ( int y = num ; y >= num ; y -- ) { ret . append ( str ) ; for ( int x = num ; x < num ; x ++ ) { ret . append ( str ) ; int p = pos . get piece ( position . get square ( x , y ) ) ; if ( p == piece . empty ) { boolean dark = position . dark square ( x , y ) ; ret . append ( dark ? str : str ) ; } else { ret . append ( piece . is white ( p ) ? str : str ) ; string piece name = piece to char ( p ) ; if ( piece name . length ( ) == num ) piece name = str ; ret . append ( piece name ) ; ret . append ( str ) ; } } ret . append ( nl ) ; ret . append ( str ) ; ret . append ( nl ) ; } return ret . to string ( ) ; }	create an ascii representation of a position .
public final void clear ( ) { caches . clear ( ) ; sections . clear ( ) ; }	clears the caches and sections data set.
static set < node > to node set ( iterator < node > i ) { set < node > node set = new hash set < node > ( ) ; while ( i . has next ( ) ) { node n = i . next ( ) ; node set . add ( n ) ; if ( n . get node type ( ) == node . element node ) { named node map nnm = n . get attributes ( ) ; for ( int j = num , length = nnm . get length ( ) ; j < length ; j ++ ) { node set . add ( nnm . item ( j ) ) ; } } } return node set ; }	converts an iterator to a set of nodes , according to the xpath data model .
public static void run concurrently ( final callable < void > task , final int times ) throws exception { final executor service service = executors . new fixed thread pool ( num ) ; final list < future < ? > > futures = new array list < future < ? > > ( ) ; for ( int i = num ; i < times ; i ++ ) { futures . add ( service . submit ( task ) ) ; } for ( final future < ? > future : futures ) { future . get ( ) ; } }	runs a task concurrently.
private static array list < container vm > create vm list ( int broker id , int container vms number ) { array list < container vm > container vms = new array list < container vm > ( ) ; for ( int i = num ; i < container vms number ; ++ i ) { array list < container pe > pe list = new array list < container pe > ( ) ; int vm type = i / ( int ) math . ceil ( ( double ) container vms number / num ) ; for ( int j = num ; j < constants examples . vm pes [ vm type ] ; ++ j ) { pe list . add ( new container pe ( j , new cotainer pe provisioner simple ( ( double ) constants examples . vm mips [ vm type ] ) ) ) ; } container vms . add ( new power container vm ( i . poll id ( container vm . class ) , broker id , ( double ) constants examples . vm mips [ vm type ] , ( float ) constants examples . vm ram [ vm type ] , constants examples . vm bw , constants examples . vm size , str , new container scheduler time shared over subscription ( pe list ) , new container ram provisioner simple ( constants examples . vm ram [ vm type ] ) , new container bw provisioner simple ( constants examples . vm bw ) , pe list , constants examples . scheduling interval ) ) ; } return container vms ; }	create the virtual machines and add them to the list.
public static void add port use ( map < storage port , integer > port use counts , storage port port ) { if ( ! port use counts . contains key ( port ) ) { port use counts . put ( port , num ) ; } else { integer new count = port use counts . get ( port ) + num ; port use counts . put ( port , new count ) ; } }	adds a use count to a port , which indicates one initiator is using the port this is public static because the storageportsassignertest uses it .
public void pop elem attribute set ( ) { m attr set stack . pop ( ) ; }	pop the current executing attribute set .
@ override public synchronized cache object < v > put ( k key , cache object < v > value ) { if ( cache . size ( ) >= max size ) { if ( remove expired ( ) <= num ) { if ( cache full remove type instanceof remove type not remove ) { return null ; } if ( full remove one ( ) == null ) { return null ; } } } value . set enter time ( system . current time millis ( ) ) ; cache . put ( key , value ) ; return value ; }	put element , key and value both not allowed to be null.
public void remove model change ( string table name , model validator listener ) { if ( table name == null || listener == null ) return ; string property name = m global validators . contains ( listener ) ? table name + str : table name + listener . get ad id ( ) ; array list < model validator > list = m model change listeners . get ( property name ) ; if ( list == null ) return ; list . remove ( listener ) ; if ( list . size ( ) == num ) m model change listeners . remove ( property name ) ; }	remove model change listener.
protected void fire change event ( ) { iterator iter = m listeners . iterator ( ) ; change event evt = new change event ( this ) ; while ( iter . has next ( ) ) { change listener cl = ( change listener ) iter . next ( ) ; cl . state changed ( evt ) ; } }	fire a change event to listeners .
private string create connection name ( ) { string builder name buffer = new string builder ( ) ; name buffer . append ( get connection type ( ) ) ; name buffer . append ( str ) ; name buffer . append ( host ) ; name buffer . append ( str ) ; name buffer . append ( port ) ; return name buffer . to string ( ) ; }	constructs a name for the connection using the connection type , host , and port .
@ post @ produces ( { media type . application xml , media type . application json } ) @ path ( str ) @ check permission ( roles = { role . tenant admin } ) public task resource rep discover host ( @ path param ( str ) uri id ) { arg validator . check field uri type ( id , host . class , str ) ; host host = query object ( host . class , id , bool ) ; return do discover host ( host ) ; }	discovers ( refreshes ) a host.
public static final void read fully ( input stream i , byte b [ ] , int off , int len ) throws io { if ( len < num ) { throw new index out of bounds exception ( ) ; } int n = num ; while ( n < len ) { int count = i . read ( b , off + n , len - n ) ; if ( count < num ) { throw new eof ( ) ; } n += count ; } }	the read fully method from data input stream is very useful for all types of streams.
private void draw lines ( canvas canvas ) { for ( int i = num ; i < connection order . size ( ) - num ; i ++ ) { draw line ( canvas , circles [ connection order . get ( i ) ] , circles [ connection order . get ( i + num ) ] ) ; } }	draw lines between the connectors.
private void add or update node ( a new node ) { boolean found = bool ; for ( a to update : closed nodes ) { if ( new node . equals ( to update ) ) { to update . update distance ( new node . get g ( ) , new node . parent ) ; found = bool ; break ; } } if ( ! found ) { open queue . offer ( new node ) ; } }	adds a new astarnode to the queue unless it is already among the closed nodes , in which case it only updates the closed node with the new distance .
public static file to file ( java file object java file object ) { return new file ( java file object . get name ( ) ) ; }	gets the file from a java file object .
public writable raster create compatible writable raster ( int w , int h ) { int [ ] b offs = { num , num , num } ; return raster . create interleaved raster ( data buffer . type byte , w , h , w * num , num , b offs , null ) ; }	creates a writableraster with the specified width and height , that has a data layout ( samplemodel ) compatible with this colormodel .
public static multi segment power law bipartite graph build random multi segment bipartite graph ( int max num segments , int max num edges per segment , int left size , int right size , double edge probability , random random ) { multi segment power law bipartite graph multi segment power law bipartite graph = new multi segment power law bipartite graph ( max num segments , max num edges per segment , left size / num , ( int ) ( right size * edge probability / num ) , num , right size / num , ( int ) ( left size * edge probability / num ) , num , new identity edge type mask ( ) , new null stats receiver ( ) ) ; for ( int i = num ; i < left size ; i ++ ) { for ( int j = num ; j < right size ; j ++ ) { if ( random . next double ( ) < edge probability ) { multi segment power law bipartite graph . add edge ( i , j , ( byte ) num ) ; } } } return multi segment power law bipartite graph ; }	build a random left - regular bipartite graph of given left and right sizes .
public static string execute ( string command ) { return subprocess uttility . execute ( command ) ; }	execute a command in the environment.
public synchronized void update progress ( final int value ) { final thread t = thread . current thread ( ) ; final my integer v = m individual thread progress . get ( t ) ; if ( v == null ) { m individual thread progress . put ( t , new my integer ( value ) ) ; } else { v . set value ( value ) ; } if ( value > m last reported progress ) { int min = integer . max value ; for ( final my integer m : m individual thread progress . values ( ) ) { if ( m . get value ( ) < min ) { min = m . get value ( ) ; } } if ( min > m last reported progress ) { m last reported progress = min ; diagnostic . progress ( str + min + str + m name ) ; } } }	update progress , safe to use for multithreading .
private context handler create context handler ( string directory , boolean is in jar , file install root directory , int expires in seconds ) { final context handler context handler = new context handler ( ) ; final resource handler resource handler = new expires resource handler ( expires in seconds ) ; final string directory with slash = str + directory ; context handler . set context path ( directory with slash ) ; resource directory resource = get directory resource ( directory , is in jar , install root directory ) ; directory resource = new js minifying resource ( directory resource ) ; if ( is in jar ) { directory resource = new caching resource ( directory resource , directory with slash ) ; } resource handler . set base resource ( directory resource ) ; if ( ! is in jar ) { resource handler . set min memory mapped content length ( num ) ; } context handler . set handler ( resource handler ) ; return context handler ; }	creates a context handler for the directory .
public boolean starts with ( java . lang . char sequence prefix ) { return starts with ( prefix , num ) ; }	indicates if this text starts with the specified prefix .
private list < container initializer > jsp initializers ( ) { jetty jasper initializer sci = new jetty jasper initializer ( ) ; container initializer initializer = new container initializer ( sci , null ) ; list < container initializer > initializers = new array list < container initializer > ( ) ; initializers . add ( initializer ) ; return initializers ; }	ensure the jsp engine is initialized correctly.
public static temp path create directory ( ) throws io { return wrap ( files . create temp directory ( prefix ) ) ; }	creates a new temporary directory in the default temporary file location .
public static string to string ( int partition [ ] [ ] ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; for ( int i = num ; i < partition . length ; i ++ ) { sb . append ( str + arrays . to string ( partition [ i ] ) ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	tostring - a string representation for the super - class partition ' partition ' .
public static boolean is category child of ( servlet request request , string parent product category id , string product category id ) { return is category child of ( ( delegator ) request . get attribute ( str ) , ( local dispatcher ) request . get attribute ( str ) , parent product category id , product category id ) ; }	scipio : returns true only if the category id is child of the given parent category id . < p > note : is caching.
@ override public boolean input ( instance instance ) { if ( get input format ( ) == null ) { throw new illegal state exception ( str ) ; } if ( m ) { reset queue ( ) ; m = bool ; } push ( ( instance ) instance . copy ( ) ) ; return bool ; }	input an instance for filtering.
public collection < string > list columns ( string table ) throws database exception { collection < string > result = new array list < string > ( ) ; result set rs = null ; try { database meta data dbm = connection . get meta data ( ) ; rs = dbm . get columns ( null , null , table , null ) ; while ( rs . next ( ) ) { result . add ( rs . get string ( str ) ) ; } } catch ( sql e ) { throw new database exception ( e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } } return result ; }	get a list of all of the columns on a table .
public void add created resource ( location location , resource resource ) { resource list . add ( resource ) ; location to resource map . put ( location , resource ) ; }	add a resource created within the analyzed method .
public void signal event ( ) { collection < semaphore > semaphores = semaphores . values ( ) ; for ( semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }	signals the semaphore when the event arrives .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof keyed objects ) ) { return bool ; } keyed objects that = ( keyed objects ) obj ; int count = get item count ( ) ; if ( count != that . get item count ( ) ) { return bool ; } for ( int i = num ; i < count ; i ++ ) { comparable k1 = get key ( i ) ; comparable k2 = that . get key ( i ) ; if ( ! k1 . equals ( k2 ) ) { return bool ; } object o1 = get object ( i ) ; object o2 = that . get object ( i ) ; if ( o1 == null ) { if ( o2 != null ) { return bool ; } } else { if ( ! o1 . equals ( o2 ) ) { return bool ; } } } return bool ; }	tests this object for equality with an arbitrary object .
protected boolean is quorum maintained ( ) { if ( node count == num ) { log . info ( str ) ; return bool ; } int quorum node cnt = node count / num + num ; coordinator client coordinator client = coordinator . get coordinator client ( ) ; list < service > all active dbsvcs = coordinator client . locate all svcs all vers ( constants . dbsvc name ) ; list < string > other active dbsvc ids = new array list < > ( ) ; string my svc id = coordinator . get my svc id ( ) ; string local db svc id = str + my svc id . substring ( my svc id . last index of ( str ) ) ; for ( service active dbsvc : all active dbsvcs ) { if ( ! local db svc id . equals ( active dbsvc . get id ( ) ) ) { other active dbsvc ids . add ( active dbsvc . get id ( ) ) ; } } log . info ( str , other active dbsvc ids , quorum node cnt ) ; boolean is maintained = other active dbsvc ids . size ( ) >= quorum node cnt ; if ( ! is maintained ) { log . info ( str ) ; } return is maintained ; }	check if node_count / 2 + 1 dbsvc instances are active on other nodes in the cluster so that if the current node is powered off , a quorum will still be maintained .
public static void schedule next alarm ( context context ) { schedule next alarm ( context , alert utils . create alarm manager ( context ) , reminder query batch size , system . current time millis ( ) ) ; }	schedules the nearest upcoming alarm , to refresh notifications.
public void request stop ( ) { stop requested . set ( bool ) ; }	allows scheduling a request to stop the workload .
public void test engine create ssl 02 ( ) { int [ ] invalid port = { integer . min value , - num , - num , num , integer . max value } ; ssl ssl = new ssl ( ) ; try { ssl sleng = ssl . engine create ssl ( str , num ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } for ( int i = num ; i < invalid port . length ; i ++ ) { try { ssl sleng = ssl . engine create ssl ( str , invalid port [ i ] ) ; fail ( str ) ; } catch ( illegal argument exception iae ) { } } }	javax . net . ssl . sslcontextspi # enginecreatesslengine ( string host , int port ) verify exception when sslcontextspi object wasn ' t initialiazed .
@ safe varargs public static < t > t [ ] join ( int function < t [ ] > array function , t [ ] ... arrays ) { if ( arrays . length == num ) { return array function . apply ( num ) ; } if ( arrays . length == num ) { return arrays [ num ] ; } if ( arrays . length == num ) { return join ( array function , arrays [ num ] , arrays [ num ] ) ; } t [ ] not null = null ; int final size = num ; int null arrays = num ; list < t > list = new array list < > ( arrays . length * num ) ; for ( t [ ] array : arrays ) { if ( ( array == null ) || ( array . length == num ) ) { null arrays ++ ; } else { not null = array ; final size += array . length ; collections . add all ( list , array ) ; } } if ( null arrays == arrays . length ) { return array function . apply ( num ) ; } if ( null arrays == ( arrays . length - num ) ) { return not null ; } return list . to array ( array function . apply ( list . size ( ) ) ) ; }	joins arrays together , if only one array contains elements it will be returned without coping anything.
private static set < string > split path ( url url ) { set < string > results = new hash set < string > ( ) ; set < string > queries = normalize query ( url . get query ( ) ) ; results . add ( str ) ; for ( string q : queries ) { results . add ( str + q ) ; } set < string > paths = split path ( url . get path ( ) ) ; results . add all ( paths ) ; for ( string p : paths ) { for ( string q : queries ) { results . add ( p + str + q ) ; } } return results ; }	returns a list of sub parts of path of a resource name .
public action forward init best selling report ( action mapping mapping , action form form , http servlet request request , http servlet response response ) throws application exception , operation exception { action forward fwd = init ( mapping , form , request , response ) ; if ( fwd != null ) return fwd ; selling item form report form = ( selling item form ) form ; string time period = report date manager . today ; string date range = constants . fixed date range ; report form . set time period ( time period ) ; report form . set date range ( date range ) ; report form . set from date ( str ) ; report form . set to date ( str ) ; report form . validate ( mapping , request ) ; return mapping . find forward ( init best selling report ) ; }	initialise best selling items report.
@ override public void transaction begin ( ) { for ( bigdata graph listener listener : listeners ) { listener . transaction begin ( ) ; } }	notification of transaction beginning .
public synchronized void add ( job job ) { boolean can run immediately = dag manager . add job ( job ) ; if ( can run immediately ) { log . debug ( str + job + str ) ; jobs to run . add ( job ) ; } increment submitted job count ( ) ; }	add the given job to run.
public void reset ( string latex ) { parse string = new string buffer ( latex ) ; len = parse string . length ( ) ; formula . root = null ; pos = num ; spos = num ; line = num ; col = num ; group = num ; insertion = bool ; at is letter = num ; array mode = bool ; ignore white space = bool ; firstpass ( ) ; }	reset the parser with a new latex expression.
public void add constant ( constant pool entry entry ) { if ( entry instanceof utf8 constant ) { utf8 constant utf8 = ( utf8 constant ) entry ; utf8 map . put ( utf8 . get value ( ) , utf8 ) ; } entries . add ( entry ) ; }	adds a new constant .
public void add data ( array list < chart set > data ) { this . data = data ; }	add full chart data .
public final double info gain ( ) { return m info gain ; }	returns ( c4 . 5 - type ) information gain for the generated split .
boolean cancel ( int property constant ) { if ( ( m property mask & property constant ) != num && m name values holder != null ) { int count = m name values holder . size ( ) ; for ( int i = num ; i < count ; ++ i ) { name values holder name values holder = m name values holder . get ( i ) ; if ( name values holder . m name constant == property constant ) { m name values holder . remove ( i ) ; m property mask &= ~ property constant ; return bool ; } } } return bool ; }	removes the given property from being animated as a part of this propertybundle.
@ suppress warnings ( str ) public static < t > type serializer < t > deserialize ( byte [ ] bytes ) throws io { byte array input stream bis = new byte array input stream ( bytes ) ; object input in = null ; try { in = new object input stream ( bis ) ; return ( type serializer < t > ) in . read object ( ) ; } catch ( class not found exception e ) { throw new io ( str ) ; } finally { try { bis . close ( ) ; } catch ( io ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch ( io ex ) { } } }	deserializes a serialized typeserializer.
public void test remainder knuth multi digits by one digit ( ) { byte a bytes [ ] = { num , - num , num , - num , num , - num , num , num , - num } ; byte b bytes [ ] = { num , - num , - num , - num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , - num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . remainder ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	divide the number of multi digits by the number of one digit.
public void show selected neuron properties ( ) { neuron dialog dialog = neuron dialog . create neuron dialog ( get selected neurons ( ) ) ; dialog . set modality type ( dialog . modality type . modeless ) ; dialog . pack ( ) ; dialog . set location relative to ( null ) ; dialog . set visible ( bool ) ; }	creates and displays the neuron properties dialog .
public void encrypt ( byte [ ] in , int length ) { int pos = num ; while ( pos < in . length && pos < length ) { encrypt block ( in , pos , length ) ; pos += block size ; } }	perform pseudo " in - place " encryption.
private static boolean has changes of children ( long last , page context pc , class clazz ) { java . lang . reflect . method [ ] methods = clazz . get methods ( ) ; java . lang . reflect . method method ; class [ ] params ; for ( int i = num ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get declaring class ( ) == clazz ) { if ( has changes of children ( pc , last , method . get return type ( ) ) ) return bool ; params = method . get parameter types ( ) ; for ( int y = num ; y < params . length ; y ++ ) { if ( has changes of children ( pc , last , params [ y ] ) ) return bool ; } } } return bool ; }	check if one of the children is changed.
private window stuff helper ( ) { }	prevent initializing this class .
public static string remove special char ( string temp str ) { if ( temp str != null ) { temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; temp str = replace ( temp str , str , str , bool , bool ) ; while ( temp str . index of ( str ) > num ) { temp str = replace ( temp str , str , str , bool , bool ) ; } temp str = replace ( temp str , str , str , bool , bool ) ; } return temp str ; }	for some save scnearios and analysis we should remove special characters , i.
public run script action ( network panel network panel ) { super ( str ) ; put value ( small icon , resource manager . get image icon ( str ) ) ; put value ( short description , str ) ; this . network panel = network panel ; }	create a new script action for the workspace .
public t web image ( string url ) { return web image ( url , bool , bool , num ) ; }	load the webview with an image with a url.
private map < installment , list < receipt > > consolidate tuples installment wise ( final list < installment receipt tuple > tuples ) { final map < installment , list < receipt > > consolidated = new hash map < installment , list < receipt > > ( ) ; for ( final installment receipt tuple t : tuples ) { list < receipt > receipts for installment = consolidated . get ( t . installment ) ; if ( receipts for installment == null ) { receipts for installment = new array list < receipt > ( ) ; consolidated . put ( t . installment , receipts for installment ) ; } if ( ! receipts for installment . contains ( t . receipt ) ) receipts for installment . add ( t . receipt ) ; } logger . info ( str + consolidated ) ; return consolidated ; }	constructs a list of receipts for each installment .
public static boolean is valid email ( string email ) { final string email pattern = str ; matcher matcher ; pattern pattern = pattern . compile ( email pattern ) ; matcher = pattern . matcher ( email ) ; if ( matcher != null ) return matcher . matches ( ) ; else return bool ; }	checks if the input parameter is a valid email .
public void add ( line merge directed edge directed edge ) { directed edges . add ( directed edge ) ; }	adds a directed edge which is known to form part of this line .
public static application xml parse application xml from file ( file file , entity resolver entity resolver ) throws io , jdom { input stream in = null ; try { in = new file input stream ( file ) ; return parse application xml ( in , entity resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( io ioe ) { } } } }	parses a deployment descriptor stored in a regular file .
public channel entry new connection ( read selector thread read handler , selection key key ) { socket channel channel = ( socket channel ) key . channel ( ) ; write selector thread write handler = selector manager . get write handler ( key . channel ( ) ) ; socket socket = channel . socket ( ) ; inet socket address socket address = ( inet socket address ) ( socket == null ? null : socket . get remote socket address ( ) ) ; channel entry channel entry = new channel entry ( write handler , read handler , key , socket address , this ) ; m . put ( channel , channel entry ) ; if ( socket address != null ) { client to channel . put ( socket address , channel entry ) ; } if ( logger . is loggable ( level . fine ) ) logger . log ( level . fine , str + channel entry . get client end point address ( ) + str ) ; return channel entry ; }	called by the connmgr thread when a new connection is created .
public string report ( ) { string buffer report = new string buffer ( ) ; int hash table = new int [ table . table size ] ; calculate slot usage ( ) ; int max = max collisions ( ) ; int [ ] slot usage count = new int [ max + num ] ; for ( int i : int hash table ) { slot usage count [ i ] ++ ; } report . append ( str + num entries + str ) ; report . append ( str + ( num entries / ( num * table . table size ) + str ) ) ; float weighted avg = num ; int num non empty = num ; report . append ( str ) ; for ( int j = num ; j <= max ; j ++ ) { if ( slot usage count [ j ] != num ) { report . append ( j + str + slot usage count [ j ] + str ) ; if ( j != num ) { weighted avg += slot usage count [ j ] * j ; num non empty += slot usage count [ j ] ; } } } weighted avg /= num non empty ; report . append ( str + min collisions ( ) + str + max + str + weighted avg ) ; return report . to string ( ) ; }	generate and return the collision report .
public void add subscription to store ( final string topic , final string client id ) { final client topic couple subscription = new client topic couple ( client id , topic ) ; if ( ! topics . contains ( subscription ) ) { logger . debug ( str + topic + str + client id + str ) ; subscriptions store . add ( subscription ) ; topics . add ( topic ) ; } }	adds the given topic to the subscription store - used for topic to subscription matching .
public boolean zip ( string zip location , string to be zipped name ) { boolean ret = bool ; if ( verbose ) debug . put ( str ) ; file to be zipped = new file ( to be zipped name ) ; if ( to be zipped . exists ( ) ) { try { file utils . save zip file ( zip location , to be zipped ) ; ret = bool ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } return ret ; }	store the contents of the tobezippedname directory into a zip file with the provided name.
private hash map < integer , boolean > generate expanded state map ( ) { hash map < integer , boolean > parent list item hash map = new hash map < > ( ) ; int child count = num ; object list item ; parent wrapper parent wrapper ; int list item count = m item list . size ( ) ; for ( int i = num ; i < list item count ; i ++ ) { if ( m item list . get ( i ) != null ) { list item = get list item ( i ) ; if ( list item instanceof parent wrapper ) { parent wrapper = ( parent wrapper ) list item ; parent list item hash map . put ( i - child count , parent wrapper . is expanded ( ) ) ; } else { child count ++ ; } } } return parent list item hash map ; }	generates a hashmap used to store expanded state for items in the list on configuration change or whenever onresume is called .
public void add audio packet listener ( listener < audio packet > listener ) { m audio packet broadcaster . add listener ( listener ) ; }	adds the listener to receive audio packets from all modules .
public crl ( boolean critical , object value ) throws io { super ( pkix . crl , critical . boolean value ( ) , value , name , label ) ; }	creates the extension from the passed der encoded value of the same .
public java environment ( file java path ) { objects . require non null ( java path ) ; this . java path = java path ; }	creates a javaenvironment with the given ' java ' path .
void add callback ( js source , string method , js callback , boolean async ) { string key = source . to js ( ) + str + method ; callbacks . put ( key , callback ) ; string id = js . id key ; string self = source . to js ( ) ; string js = self + str + method + str + str + self + str + method + str + str + str + str + str + id + str + str + js lookup table + str + js lookup table + str + id + str + js lookup table + str + js lookup table + str + id + str + str + str + js lookup table + str + str + str + str + str + str ; exec ( js , async ) ; }	adds a jsfunction to handle calls to the specified javascript object.
public void remove all blocks from section ( ) { for ( int i = m block entries . size ( ) ; i > num ; i -- ) { block b = m block entries . get ( i - num ) ; if ( b != null ) { b . remove property change listener ( m block listeners . get ( i - num ) ) ; } m block listeners . remove ( i - num ) ; m block entries . remove ( i - num ) ; } for ( int i = m forward entry points . size ( ) ; i > num ; i -- ) { m forward entry points . remove ( i - num ) ; } for ( int i = m reverse entry points . size ( ) ; i > num ; i -- ) { m reverse entry points . remove ( i - num ) ; } initialization needed = bool ; }	remove all blocks , block listeners , and entry points.
public static void write string to file ( path file , string text ) throws io { byte [ ] buf = text . get bytes ( standard charsets . utf 8 ) ; files . write ( file , buf ) ; }	java nio replacement of commons - io.
private static boolean is operator variable access ( final i node ) { final list < i > children = node . get children ( ) ; if ( children . size ( ) == num ) { final i child0 = children . get ( num ) ; final i child1 = children . get ( num ) ; return is variable ( child0 ) ^ is variable ( child1 ) ; } else { return bool ; } }	determines whether a given node is a variable access node that can be simplified .
@ override public void on value selected ( int picker index , int new value , boolean auto advance ) { if ( picker index == hour index ) { set hour ( new value , bool ) ; string announcement = string . format ( str , new value ) ; if ( m allow auto advance && auto advance ) { set current item showing ( minute index , bool , bool , bool ) ; announcement += str + m select minutes ; } else { m time picker . set content description ( m hour picker description + str + new value ) ; } utils . try accessibility announce ( m time picker , announcement ) ; } else if ( picker index == minute index ) { set minute ( new value ) ; m time picker . set content description ( m minute picker description + str + new value ) ; } else if ( picker index == half day index ) { update half day ( new value ) ; } else if ( picker index == enable picker index ) { if ( ! is typed time fully legal ( ) ) { m typed times . clear ( ) ; } finish kb mode ( bool ) ; } }	called by the picker for updating the header display .
public static final list < geo > segment near poly ( geo s1 , geo s2 , geo array r , double near ) { int rlen = r . get size ( ) ; geo pl0 = r . get ( rlen - num , new geo ( ) ) ; geo pl1 = new geo ( ) ; list < geo > list = null ; geo check = new geo ( ) ; for ( int j = num ; j < rlen ; j ++ ) { r . get ( j , pl1 ) ; geo ret = segments intersect or near ( s1 , s2 , pl0 , pl1 , near , check ) ; if ( ret != null ) { if ( list == null ) { list = new linked list < geo > ( ) ; } list . add ( ret ) ; check = new geo ( ) ; } pl0 . initialize ( pl1 ) ; } return list ; }	where is a segment , represented by endpoints ' s1 ' and ' s2 ' , withing a range ' near ' of region ' r ' ?.
public void add action ( update action action ) { action list . add ( action ) ; for ( update manager listener listener : listeners ) { listener . action added ( action ) ; } }	add an action to the list .
public void load ( data input raf in ) throws io , mary configuration exception { int num idx = raf in . read int ( ) ; idx interval = raf in . read int ( ) ; if ( idx interval <= num ) { throw new mary configuration exception ( str ) ; } byte ptrs = new long [ num idx ] ; time ptrs = new long [ num idx ] ; int num bytes to read = num * num idx + num ; byte [ ] data = new byte [ num bytes to read ] ; raf in . read fully ( data ) ; data input buf in = new data input stream ( new byte array input stream ( data ) ) ; for ( int i = num ; i < num idx ; i ++ ) { byte ptrs [ i ] = buf in . read long ( ) ; time ptrs [ i ] = buf in . read long ( ) ; if ( i > num ) { if ( byte ptrs [ i ] < byte ptrs [ i - num ] || time ptrs [ i ] < time ptrs [ i - num ] ) { throw new mary configuration exception ( str ) ; } } } buf in . read long ( ) ; buf in . read long ( ) ; }	method which loads an index from a data input ( random access file or data input stream ) .
public url find ( string classname ) { string jarname = str + classname . replace ( str , str ) + str ; return this class . get resource ( jarname ) ; }	obtains the url of the specified class file .
public void signoff ( string unique id ) { debug . message ( str , str + unique id + str ) ; caches . remove ( unique id ) ; view attribute lists . remove ( unique id ) ; timestamps . remove ( unique id ) ; }	the signoff function lets the server know that a client is checking out .
private string create non cg ( list < volume descriptor > source descriptors , list < volume descriptor > target descriptors , remote director group group , map < uri , volume > uri volume map , string wait for , workflow workflow ) { storage system system = db client . query object ( storage system . class , group . get source storage system uri ( ) ) ; uri vpool change uri = get virtual pool change volume ( source descriptors ) ; log . info ( str , vpool change uri ) ; list < uri > source ur = volume descriptor . get volume ur ( source descriptors ) ; list < uri > target ur = new array list < > ( ) ; for ( uri source uri : source ur ) { volume source = uri volume map . get ( source uri ) ; string set srdf targets = source . get srdf targets ( ) ; for ( string target str : srdf targets ) { uri target uri = uri . create ( target str ) ; target ur . add ( target uri ) ; } } method create list method = create list replicas method ( system . get id ( ) , source ur , target ur , vpool change uri , bool ) ; method rollback method = rollback srdf ( system . get id ( ) , source ur , target ur , bool ) ; string step id = workflow . create step ( create srdf active volume pair step group , create srdf active volume pair step desc , wait for , system . get id ( ) , system . get system type ( ) , get class ( ) , create list method , rollback method , null ) ; return step id ; }	this method creates steps to create srdf pairs in an empty srdf group .
public static long downsampler timestamp ( long millitimestamp , long window size ) { return millitimestamp - ( millitimestamp % window size ) ; }	creating timestamp for downsampling in order to be consistent with tsdb downsampling func on hour / minute level.
@ override public string to string ( ) { if ( points == null || points . length ( ) == num ) { return idx + str ; } string buffer bf = new string buffer ( ) ; try { bf . append ( idx + str ) ; list node temp ; for ( int i = num ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == num ) { bf . append ( str + temp . idx ) ; } else { bf . append ( str + temp . idx ) ; } } } catch ( exception ex ) { ex . print stack trace ( ) ; } return bf . to string ( ) ; }	returns a string represention of the node .
public void error ( org . xml . sax . sax e ) throws org . xml . sax . sax { string formatted msg = e . get message ( ) ; sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; try { handler . error ( new transformer exception ( formatted msg , locator ) ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	receive notification of a recoverable xslt processing error .
private void put head ( string key , template sub pattern association assoc ) { if ( key . equals ( psuedo names . pseudoname text ) ) m text patterns = assoc ; else if ( key . equals ( psuedo names . pseudoname root ) ) m doc patterns = assoc ; else if ( key . equals ( psuedo names . pseudoname comment ) ) m comment patterns = assoc ; m pattern table . put ( key , assoc ) ; }	get the head of the assocation list that is keyed by target .
public union path iterator ( compiler compiler , int op pos ) throws javax . xml . transform . transformer exception { super ( ) ; op pos = op map . get first child pos ( op pos ) ; load location paths ( compiler , op pos , num ) ; }	create a unionpathiterator object , including creation of location path iterators from the opcode list , and call back into the compiler to create predicate expressions .
public int read ( string table , string key , set < string > fields , hash map < string , byte iterator > result ) { long st = system . nano time ( ) ; int res = db . read ( table , key , fields , result ) ; long en = system . nano time ( ) ; measurements . measure ( str , ( int ) ( ( en - st ) / num ) ) ; measurements . report return code ( str , res ) ; return res ; }	read a record from the database.
protected void error message ( string msg ) throws io { string str = msg + str + m . to string ( ) ; if ( m > num ) { int line = integer . parse int ( str . replace all ( str , str ) ) ; str = str . replace all ( str , str + ( m + line - num ) ) ; } throw new io ( str ) ; }	throws error message with line number and last token read .
public boolean has next ( ) { if ( deal > num ) { sc . close ( ) ; } return ( deal <= num ) ; }	if the deal has more deals , this returns true ; false otherwise .
public void add issuer ( x500 principal issuer ) { if ( issuer == null ) { throw new null pointer exception ( str ) ; } if ( issuer names == null ) { issuer names = new array list < string > ( ) ; } string name = issuer . get name ( x500 principal . canonical ) ; if ( ! issuer names . contains ( name ) ) { issuer names . add ( name ) ; } if ( issuer principals == null ) { issuer principals = new array list < x500 principal > ( issuer names . size ( ) ) ; } int size = issuer names . size ( ) - num ; for ( int i = issuer principals . size ( ) ; i < size ; i ++ ) { issuer principals . add ( new x500 principal ( issuer names . get ( i ) ) ) ; } issuer principals . add ( issuer ) ; }	adds an issuer to the criterion for the issuer distinguished names.
static string build key selection ( int selection count ) { string [ ] list = new string [ selection count ] ; arrays . fill ( list , str ) ; return key column + str + text utils . join ( str , list ) + str ; }	build the string required for an sql select statement : where key in ( ? , ? ,.
private void filter node map ( concurrent map < string , collection < cluster node > > map , final cluster node excl node ) { for ( string cache name : registered caches . key set ( ) ) { string masked name = mask null ( cache name ) ; while ( bool ) { collection < cluster node > old nodes = map . get ( masked name ) ; if ( old nodes == null || old nodes . is empty ( ) ) break ; collection < cluster node > new nodes = new array list < > ( old nodes ) ; if ( ! new nodes . remove ( excl node ) ) break ; if ( map . replace ( masked name , old nodes , new nodes ) ) break ; } } }	creates a copy of nodes map without the given node .
public void store device ( device d ) { if ( ! is master ) return ; if ( d == null ) return ; long now = system . nano time ( ) ; write updated device to storage ( d ) ; last write times . put ( d . get device key ( ) , now ) ; }	write the given device to storage if we are master.
public void test create element n ( ) throws throwable { string namespace uri = str ; string malformed name = str ; document doc ; doc = ( document ) load ( str , builder ) ; { boolean success = bool ; try { doc . create element ns ( namespace uri , malformed name ) ; } catch ( dom ex ) { success = ( ex . code == dom . namespace err ) ; } assert true ( str , success ) ; } }	runs the test case .
private static void adjust abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * num ; while ( k <= upper ) { if ( ( k < upper ) && ( math . abs ( array [ k - num ] ) < math . abs ( array [ k ] ) ) ) { k += num ; } if ( math . abs ( array [ j - num ] ) < math . abs ( array [ k - num ] ) ) { temp = array [ j - num ] ; array [ j - num ] = array [ k - num ] ; array [ k - num ] = temp ; } j = k ; k *= num ; } }	helps sort an array of doubles.
public synchronized i remove ( int index ) { i processor = processors . remove ( index ) ; build final processor ( ) ; return processor ; }	removes the processor from the internal processor queue at the provided index .
linked list < trie node < t > > make suffix chain ( trie node < t > root , string suffix , t value ) { linked list < trie node < t > > result = new linked list < > ( ) ; string root prefix = root . get prefix ( ) ; for ( int i = num , suffix size = suffix . length ( ) ; i <= suffix size ; i ++ ) { string new prefix = root prefix + suffix . substring ( num , i ) ; trie node < t > new node = trie node . make node ( new prefix ) ; result . add ( new node ) ; root . add child ( new node ) ; root = new node ; } root . set value ( value ) ; return result ; }	inserts a chain of children into the given node .
private static by by from locator ( string locator ) { if ( locator . starts with ( str ) ) { return by . xpath ( locator ) ; } if ( locator . starts with ( str ) ) { return by . id ( locator . replace first ( str , str ) ) ; } if ( locator . starts with ( str ) ) { return by . css selector ( locator . replace first ( str , str ) ) ; } if ( locator . starts with ( str ) ) { return by . xpath ( locator . replace first ( str , str ) ) ; } if ( locator . starts with ( str ) ) { return by . name ( locator . replace first ( str , str ) ) ; } if ( locator . starts with ( str ) ) { return by . link text ( locator . replace first ( str , str ) ) ; } if ( locator . starts with ( str ) ) { return by . partial link text ( locator . replace first ( str , str ) ) ; } throw new illegal argument exception ( str + locator ) ; }	converts a locator string with a known prefix to a by object.
private static void task started ( progress thread task ) { for ( progress thread state listener l : listener . get listeners ( progress thread state listener . class ) ) { l . progress thread started ( task ) ; } }	notify listeners that a task was started .
private void throw exception if destroyed ( string method ) throws deepstream record destroyed exception { if ( this . is destroyed ) { throw new deepstream record destroyed exception ( method ) ; } }	throw an exception if the record has been destroyed.
public void upload ( final input stream in , string artifact , string version , string file name , properties props ) throws io { props . put ( file name property , file name ) ; props . put ( version property , version ) ; props . put ( artifact property , artifact ) ; store properties ( artifact , version , props ) ; try ( output stream out = new output stream ( get artifact ( artifact , version , file name ) ) ) { io . copy large ( in , out ) ; } finally { in . close ( ) ; } }	uploads artifact into the repository .
static string escape bytes ( final byte string input ) { final string builder builder = new string builder ( input . size ( ) ) ; for ( int i = num ; i < input . size ( ) ; i ++ ) { final byte b = input . byte at ( i ) ; switch ( b ) { case num : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case num : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; case str : builder . append ( str ) ; break ; default : if ( b >= num ) { builder . append ( ( char ) b ) ; } else { builder . append ( str ) ; builder . append ( ( char ) ( str + ( ( b > > > num ) & num ) ) ) ; builder . append ( ( char ) ( str + ( ( b > > > num ) & num ) ) ) ; builder . append ( ( char ) ( str + ( b & num ) ) ) ; } break ; } } return builder . to string ( ) ; }	escapes bytes in the format used in protocol buffer text format , which is the same as the format used for c string literals.
private static class < ? > [ ] types ( object ... values ) { if ( values == null ) { return new class [ num ] ; } class < ? > [ ] result = new class [ values . length ] ; for ( int i = num ; i < values . length ; i ++ ) { object value = values [ i ] ; result [ i ] = value == null ? null . class : value . get class ( ) ; } return result ; }	get an array of types for an array of objects.
public void add to parent ( element header e ) throws exception { document doc = header e . get owner document ( ) ; element security e = doc . create element ns ( wsse ns , wsse . tag wsse + str + wsse . tag securityt ) ; security e . set attribute ns ( soap . ns xml , wsse . tag xml wsse , wsse ns ) ; header e . append child ( security e ) ; document binary token d = xml . to dom ( to string ( ) , debug ) ; element binary token e = binary token d . get document element ( ) ; security e . append child ( doc . import node ( binary token e , bool ) ) ; }	adds th binary security token to the header element .
public final static int skip spaces ( final string in , final int start ) { int pos = start ; while ( pos < in . length ( ) && ( in . char at ( pos ) == str || in . char at ( pos ) == str ) ) { pos ++ ; } return pos < in . length ( ) ? pos : - num ; }	skips spaces in the given string .
public void update ( ) { if ( amplitude > num ) { long elapsed = system . current time millis ( ) - timestamp ; double delta = amplitude * math . exp ( - elapsed / time constant ) ; if ( math . abs ( delta ) > num ) { viewpoint node . drag ( last dx * delta , last dy * delta ) ; } else { amplitude = num ; update look at ( ) ; } } }	update the kinetic scrolling.
@ override public assignment sample ( ) { if ( ! samples . is empty ( ) ) { int selection = sampler . next int ( samples . size ( ) ) ; assignment selected = samples . get ( selection ) ; return selected ; } else { log . warning ( str ) ; return new assignment ( ) ; } }	samples from the distribution . in this case , simply selects one arbitrary sample out of the set defining the distribution.
@ sneaky throws public static x509 certificate read certificate ( input stream is ) { return ( x509 certificate ) cert factory . generate certificate ( is ) ; }	reads x509certificate object from given input stream .
public http ( ) { executor . schedule at fixed rate ( new tunnel timeout task ( tunnel timeout * num ) , tunnel timeout , tunnel timeout , time unit . seconds ) ; }	creates a new guacamolehttptunnelmap which automatically closes and removes http tunnels which are no longer in use .
default b with ( string key , class < ? > value ) { return with ( key , value != null ? value . get name ( ) : null ) ; }	associate the given class name value with the specified key .
private void rename ( table table ) { if ( rename definitions != null ) { for ( column col : table . get all columns ( ) ) { string new col name = rename definitions . get new column name ( table . get schema ( ) , table . get name ( ) , col . get name ( ) ) ; if ( new col name != null ) col . set name ( new col name ) ; } string new table name = rename definitions . get new table name ( table . get schema ( ) , table . get name ( ) ) ; string new schema name = rename definitions . get new schema name ( table . get schema ( ) , table . get name ( ) ) ; if ( new table name != null ) table . set table ( new table name ) ; if ( new schema name != null ) table . set schema ( new schema name ) ; } }	if renamedefinitions object is prepared , does the lookup and renaming of schema , table and columns.
private void handle read last confirmed error ( int rc ) { if ( bk . code . no such ledger exists exception == rc ) { if ( bkc no ledger exceptions on read lac . increment and get ( ) > no ledger exception on read lac ) { log . info ( str , new object [ ] { fully qualified name , current lh , conf . get read ahead no such ledger exception on read lac ( ) } ) ; bkc no ledger exceptions on read lac . set ( num ) ; if ( close current ledger handle ( ) ) { next . process ( bk . code . ok ) ; } return ; } else { if ( log . is trace enabled ( ) ) { log . info ( str , new object [ ] { fully qualified name , current lh , conf . get read ahead wait time ( ) } ) ; } schedule ( read ahead worker . this , conf . get read ahead wait time ( ) ) ; return ; } } else if ( bk . code . ok != rc ) { handle exception ( read ahead phase . read last confirmed , rc ) ; return ; } }	handle the result of reading last add confirmed .
public synchronized boolean put ( long fp ) { int index = ( int ) ( fp & this . mask ) ; long [ ] list = this . table [ index ] ; if ( list != null ) { int listlen = list . length ; for ( int i = num ; i < listlen ; i ++ ) { if ( list [ i ] == fp ) return bool ; } } if ( count >= threshold ) { rehash ( ) ; index = ( int ) ( fp & this . mask ) ; list = this . table [ index ] ; } int len = ( list == null ? num : list . length ) ; long [ ] new list = new long [ len + num ] ; if ( list != null ) system . arraycopy ( list , num , new list , num , len ) ; new list [ len ] = fp ; this . table [ index ] = new list ; this . count ++ ; return bool ; }	tests if the specified fingerprint is in this set.
public void apply layout ( ) { layout . set initial location ( get position ( ) ) ; layout . layout neurons ( get neuron list ( ) ) ; }	apply this group ' s layout to its neurons .
public int nice ( ) { return integer . parse int ( fields [ num ] ) ; }	the nice value ( see setpriority ( 2 ) ) , a value in the range 19 ( low priority ) to - 20 ( high priority ) .
float layer size ( int p 76490 1 ) { if ( ( float ) p 76490 1 < ( float ) this . height limit * num ) { return - num ; } else { float f = ( float ) this . height limit / num ; float f1 = f - ( float ) p 76490 1 ; float f2 = math helper . sqrt float ( f * f - f1 * f1 ) ; if ( f1 == num ) { f2 = f ; } else if ( math . abs ( f1 ) >= f ) { return num ; } return f2 * num ; } }	gets the rough size of a layer of the tree .
public static method find static method ( class < ? > type , string name , class < ? > ... args ) throws no such method exception { method method = find method ( type , name , args ) ; if ( ! modifier . is static ( method . get modifiers ( ) ) ) { throw new no such method exception ( str + name + str ) ; } return method ; }	finds public static method that is accessible from public class .
private void fetch search service cards from server ( string keyword , string category id ) { final map < string , string > params = new hash map < string , string > ( num ) ; params . put ( http constants . latitude , shared preference helper . get string ( r . string . pref latitude ) ) ; params . put ( http constants . longitude , shared preference helper . get string ( r . string . pref longitude ) ) ; params . put ( http constants . type , http constants . search type . service card ) ; params . put ( http constants . group id , category id ) ; params . put ( http constants . per , str ) ; params . put ( http constants . radius , str ) ; params . put ( http constants . title , keyword ) ; retro callback retro callback ; retro callback = new retro callback ( this ) ; retro callback . set request id ( http constants . api response codes . search services ) ; retro callback list . add ( retro callback ) ; params . put ( http constants . page , str ) ; m yelo api . get service cards ( params , retro callback ) ; m swipe refresh layout . set refreshing ( bool ) ; }	helper http function to get list of my service cards based on keyword and category.
public void add phonenumber ( string a phonenumber ) { if ( m phone numbers . index of ( a phonenumber ) < num ) { m phone numbers . add ( a phonenumber ) ; } }	add a phone number address to the list .
public static final string digits and plus only ( matcher matcher ) { string builder buffer = new string builder ( ) ; string matching region = matcher . group ( ) ; for ( int i = num , size = matching region . length ( ) ; i < size ; i ++ ) { char character = matching region . char at ( i ) ; if ( character == str || character . is digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to string ( ) ; }	convenience method to return only the digits and plus signs in the matching string .
boolean compare methods ( method a , method b ) { if ( ( a == null ) != ( b == null ) ) { return bool ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return bool ; } } return bool ; }	package private helper method for descriptor.
marker segment find marker segment ( int tag ) { iterator iter = marker sequence . iterator ( ) ; while ( iter . has next ( ) ) { marker segment seg = ( marker segment ) iter . next ( ) ; if ( seg . tag == tag ) { return seg ; } } return null ; }	returns the first markersegment object in the list with the given tag , or null if none is found .
private static reader open input ( string from ) { try { return cli utils . reader ( from ) ; } catch ( io e ) { log . error ( str , e ) ; system . exit ( num ) ; return null ; } }	open the input using the " from " parameter , exiting on failure .
public publisher concat array < t > concat additional source first ( publisher < ? extends t > source ) { int n = array . length ; @ suppress warnings ( str ) publisher < ? extends t > [ ] new array = new publisher [ n + num ] ; system . arraycopy ( array , num , new array , num , n ) ; new array [ num ] = source ; return new publisher concat array < > ( delay error , new array ) ; }	returns a new instance which has the additional first source to be concatenated together with the current array of sources.
protected void do publish ( string tenant id , list < t > items , string subscriber , int retry count , long delay ) throws exception { string data = mapper . write value as string ( items ) ; text message tm = session . create text message ( data ) ; if ( tenant id != null ) { tm . set string property ( str , tenant id ) ; } if ( subscriber != null ) { tm . set string property ( str , subscriber ) ; } tm . set int property ( str , retry count ) ; if ( delay > num ) { tm . set long property ( str , system . current time millis ( ) + delay ) ; } if ( log . is loggable ( level . finest ) ) { log . finest ( str + tm ) ; } producer . send ( tm ) ; }	this method publishes the supplied items .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case mapping package . attribute name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case mapping package . attribute value : return value edefault == null ? value != null : ! value edefault . equals ( value ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected void check valid ( ) throws uri { if ( ! ( equals ( scheme , default scheme ) || scheme == null ) ) { throw new uri ( uri . parsing , str ) ; } }	verify the valid class use for construction .
public private key usage extension ( boolean critical , object value ) throws certificate exception , io { this . extension id = pkix . private key usage id ; this . critical = critical . boolean value ( ) ; this . extension value = ( byte [ ] ) value ; der input stream str = new der input stream ( this . extension value ) ; der value [ ] seq = str . get sequence ( num ) ; for ( int i = num ; i < seq . length ; i ++ ) { der value opt = seq [ i ] ; if ( opt . is context specific ( tag before ) && ! opt . is constructed ( ) ) { if ( not before != null ) { throw new certificate parsing exception ( str ) ; } opt . reset tag ( der value . tag ) ; str = new der input stream ( opt . to byte array ( ) ) ; not before = str . get generalized time ( ) ; } else if ( opt . is context specific ( tag after ) && ! opt . is constructed ( ) ) { if ( not after != null ) { throw new certificate parsing exception ( str ) ; } opt . reset tag ( der value . tag ) ; str = new der input stream ( opt . to byte array ( ) ) ; not after = str . get generalized time ( ) ; } else throw new io ( str + str ) ; } }	create the extension from the passed der encoded value .
@ override public list < period > generate periods ( date time unit date time unit ) { calendar cal = get calendar ( ) ; date time unit . set month ( num ) ; date time unit . set day ( num ) ; list < period > periods = lists . new array list ( ) ; int year = date time unit . get year ( ) ; while ( date time unit . get year ( ) == year ) { periods . add ( create period ( date time unit , cal ) ) ; date time unit = cal . plus months ( date time unit , num ) ; } return periods ; }	generates bimonthly periods for the whole year in which the start date of the given period exists .
public static secret key create aes ( ) { try { final key generator kgen = key generator . get instance ( str ) ; final int key size = num ; kgen . init ( key size ) ; return kgen . generate key ( ) ; } catch ( final no such algorithm exception e ) { e . print stack trace ( ) ; } return null ; }	generates a random aes key for encrypting / decrypting the turnover value attention : in a real cash box this key would be generated during the init process and stored in a secure area.
@ override public void value change ( value change event e ) { string name = e . get property name ( ) ; object value = e . get new value ( ) ; log . config ( name + str + value ) ; if ( value == null ) return ; }	vetoable change listener . - business partner - currency - date.
@ deprecated public static json parse json ( string response ) throws json , facebook error { if ( response . equals ( str ) ) { throw new facebook error ( str ) ; } if ( response . equals ( str ) ) { response = str ; } json json = new json ( response ) ; if ( json . has ( str ) ) { json error = json . get json ( str ) ; throw new facebook error ( error . get string ( str ) , error . get string ( str ) , num ) ; } if ( json . has ( str ) && json . has ( str ) ) { throw new facebook error ( json . get string ( str ) , str , integer . parse int ( json . get string ( str ) ) ) ; } if ( json . has ( str ) ) { throw new facebook error ( str , str , integer . parse int ( json . get string ( str ) ) ) ; } if ( json . has ( str ) ) { throw new facebook error ( json . get string ( str ) ) ; } if ( json . has ( str ) ) { throw new facebook error ( json . get string ( str ) ) ; } return json ; }	parse a server response into a json object.
public spy versions load versions ( ) throws xml { set loading ( bool ) ; final string url string = property loader . get property ( base property names . version info url ) + str + current release ; try { final url url = new url ( url string ) ; final string xml = io . to string ( url . open stream ( ) ) ; versions = ( spy versions ) load from string ( xml ) ; } catch ( io | null pointer exception e ) { throw new xml ( str + url string , e ) ; } set loading ( bool ) ; return versions ; }	loads version information from the url .
@ request mapping ( value = str , method = post , produces = application json value ) public response entity < page response < dto > > find all ( @ request body page request by example < dto > prbe ) throws uri { page response < dto > page response = user dto . find all ( prbe ) ; return new response entity < > ( page response , new http headers ( ) , http status . ok ) ; }	find a page of user using query by example .
public void add footer view ( view view ) { m footer views . add ( view ) ; notify data set changed ( ) ; }	add a static view to appear at the end of the recyclerview.
public void add first ( string seq ) { queue = seq + queue . substring ( pos ) ; pos = num ; }	add a string to the start of the queue .
public boolean is read only ( boolean use session status ) throws sql { if ( use session status && ! this . is closed && version meets minimum ( num , num , num ) && ! get use local session state ( ) && get read only propagates to server ( ) ) { java . sql . statement stmt = null ; java . sql . result set rs = null ; try { try { stmt = get metadata safe statement ( ) ; rs = stmt . execute query ( str ) ; if ( rs . next ( ) ) { return rs . get int ( num ) != num ; } } catch ( sql ex1 ) { if ( ex1 . get error code ( ) != mysql error numbers . er must change password || get disconnect on expired passwords ( ) ) { throw sql . create sql ( str , sql . sql state general error , ex1 , get exception interceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( exception ex ) { } stmt = null ; } } } return this . read only ; }	tests to see if the connection is in read only mode.
public void test consume ( ) { atomic integer sum = new atomic integer ( ) ; submission publisher < integer > p = basic publisher ( ) ; completable future < void > f = p . consume ( null ) ; int n = num ; for ( int i = num ; i <= n ; ++ i ) p . submit ( i ) ; p . close ( ) ; f . join ( ) ; assert equals ( ( n * ( n + num ) ) / num , sum . get ( ) ) ; }	consume returns a completablefuture that is done when publisher completes.
public void expr set parent ( expression node n ) { super . expr set parent ( n ) ; int n args = m arg vec . size ( ) ; for ( int i = num ; i < n args ; i ++ ) { expression arg = ( expression ) m arg vec . element at ( i ) ; arg . expr set parent ( n ) ; } }	set the parent node.
public final boolean is registered ( ) { return ! canonical name . starts with ( str ) && ! canonical name . starts with ( str ) ; }	returns true if this charset is known to be registered in the iana charset registry .
private static downscale quality add constant ( string type ) { init ( ) ; if ( const list . contains key ( type ) ) { throw new runtime exception ( str + type + str ) ; } downscale quality q = new downscale quality ( type ) ; const list . put ( type , q ) ; return q ; }	create and add constant instance.
public void bail ( string message , boolean print usage statement ) { debug . output ( message ) ; if ( print usage statement ) print usage ( ) ; system . exit ( num ) ; }	called if something is messed up.
private void assert timestamps equal with epsilon ( long expected , long actual , int epsilon , string desc ) { assert true ( str + desc + str + epsilon + str + expected + str + actual , math . abs ( actual - expected ) < epsilon ) ; }	kinda like the junit asserts for doubles , which allows an " epsilon " but this is for integers , and with a specific description in the assert just for timestamps . all times are expected in milliseconds.
public xml ( spider param params ) { super ( ) ; if ( params == null ) { throw new illegal argument exception ( str ) ; } this . params = params ; }	instantiates a new sitemap.
public boolean flush ( boolean deaccelerated ) ;	flush all cached resources.
public void add hop ( int id ) { if ( entities == null ) { return ; } hops number ++ ; entities . add ( integer . value of ( id ) ) ; }	add an entity where the infopacket traverses.
public boolean is empty ( ) { return m event queue . is empty ( ) ; }	determines if the event queue is empty .
public static void test primitive instantiation ( ) { test primitive instantiation ( bool ) ; }	test that all of the graphicsprimitiveproxy objects actually resolve to something.
public void read entries ( table kelp table , in segment reader , segment entry callback cb ) { temp buffer t buf = temp buffer . create large ( ) ; byte [ ] buffer = t buf . buffer ( ) ; in store s in = reader . get store read ( ) ; byte [ ] table key = new byte [ table kelp . table key size ] ; for ( int ptr = length ( ) - block size ; ptr > num ; ptr -= block size ) { s in . read ( get address ( ) + ptr , buffer , num , buffer . length ) ; int index = num ; long seq = bits util . read long ( buffer , index ) ; index += num ; if ( seq != get sequence ( ) ) { log . warning ( l . l ( str , seq , get sequence ( ) , long . to hex string ( get address ( ) + ptr ) ) ) ; break ; } system . arraycopy ( buffer , index , table key , num , table key . length ) ; index += table key . length ; if ( ! arrays . equals ( table key , table key ) ) { log . warning ( l . l ( str , hex . to short hex ( table key ) , hex . to short hex ( table key ) , long . to hex string ( get address ( ) + ptr ) ) ) ; break ; } int head = index ; while ( head < block size && buffer [ head ] != num ) { head = read entry ( table , buffer , head , cb , get address ( ) ) ; } boolean is cont = buffer [ head + num ] != num ; if ( ! is cont ) { break ; } } t buf . free ( ) ; }	reads index entries from the segment.
static int number of hosts ( map < uri , list < initiator > > net2 initiators map ) { set < uri > host set = new hash set < uri > ( ) ; for ( list < initiator > initiators : net2 initiators map . values ( ) ) { for ( initiator init : initiators ) { host set . add ( init . get host ( ) ) ; } } return host set . size ( ) ; }	returns number of hosts in the net2initiatorsmap.
public void add certificates ( store cert store ) throws cms { certs . add all ( cms . get certificates from store ( cert store ) ) ; }	add the certificates in certstore to the certificate set to be included with the generated signeddata message .
protected void process lob ( lob metadata lob , database mapping mapping , metadata class reference class , boolean is for map key ) { lob . process ( mapping , this , reference class , is for map key ) ; }	internal : process a lob specification.
protected attributes impl start prefix mapping ( element element , namespace stack namespace stack ) throws sax { attributes impl namespace attributes = null ; namespace element namespace = element . get namespace ( ) ; if ( ( element namespace != null ) && ! is ignoreable namespace ( element namespace , namespace stack ) ) { namespace stack . push ( element namespace ) ; content handler . start prefix mapping ( element namespace . get prefix ( ) , element namespace . get uri ( ) ) ; namespace attributes = add namespace attribute ( namespace attributes , element namespace ) ; } list < namespace > declared namespaces = element . declared namespaces ( ) ; for ( namespace namespace : declared namespaces ) { if ( ! is ignoreable namespace ( namespace , namespace stack ) ) { namespace stack . push ( namespace ) ; content handler . start prefix mapping ( namespace . get prefix ( ) , namespace . get uri ( ) ) ; namespace attributes = add namespace attribute ( namespace attributes , namespace ) ; } } return namespace attributes ; }	fires a sax startprefixmapping event for all the namespacestack which have just come into scope.
public void print stack trace ( java . io . print writer pw ) { if ( root cause != null ) { string super string = super . to string ( ) ; synchronized ( pw ) { pw . print ( super string + ( super string . ends with ( str ) ? str : str ) + str ) ; root cause . print stack trace ( pw ) ; } } else { super . print stack trace ( pw ) ; } }	prints this exception ' s stack trace to a print writer.
private static data flavor [ ] convert to array ( list < data flavor > data flavour list ) { data flavor [ ] array = new data flavor [ data flavour list . size ( ) ] ; data flavour list . to array ( array ) ; return array ; }	convert dataflavor list to array .
public void test choice empty icon error handling ( ) { string xml = str ; xml += create start mission xml ( str , str ) ; xml += create start choice moment xml ( str , num , str , str ) ; xml += create choice xml ( str , str , str , bool , bool , str ) ; xml += create choice xml ( str , str , str , bool , bool , str ) ; xml += create end choice moment xml ( ) ; xml += create end choice moment xml ( ) ; xml += create end mission xml ( ) ; utils . log debug ( tag , xml ) ; input stream moment input stream = new byte array input stream ( xml . get bytes ( ) ) ; m mission = new mission ( m mission data ) ; boolean did mission parse fail = bool ; try { m mission . read moments ( moment input stream ) ; } catch ( mission parse exception e ) { e . print stack trace ( ) ; did mission parse fail = bool ; } assert . assert equals ( bool , did mission parse fail ) ; }	test for correct error handling for a choice that has an empty icon element .
public static string translate attribute ( string attributes ) throws io { short [ ] flags = str attr to boolean flags ( attributes ) ; string builder sb = new string builder ( ) ; if ( flags [ read only ] == yes ) sb . append ( str ) ; else if ( flags [ read only ] == no ) sb . append ( str ) ; if ( flags [ hidden ] == yes ) sb . append ( str ) ; else if ( flags [ hidden ] == no ) sb . append ( str ) ; if ( flags [ system ] == yes ) sb . append ( str ) ; else if ( flags [ system ] == no ) sb . append ( str ) ; if ( flags [ archive ] == yes ) sb . append ( str ) ; else if ( flags [ archive ] == no ) sb . append ( str ) ; return sb . to string ( ) ; }	sets attributes of a file on windows system.
public static int next index id ( ) { return msg idx . get and increment ( ) ; }	gets next id for indexed message id .
private void fill field values ( ) { if ( is creation panel ) { phrase . set text ( str + hearing . default phrase ) ; output amount . set text ( str + hearing . default output amount ) ; } else { phrase . set text ( str + hearing sensor . get phrase ( ) ) ; output amount . set text ( str + hearing sensor . get output amount ( ) ) ; } }	set the current values of all fields .
public static boolean check security infos ( string endpoint , identity client identity , list < security info > security infos ) { if ( client identity . is secure ( ) ) { if ( security infos == null || security infos . is empty ( ) ) { log . warn ( str , endpoint ) ; return bool ; } else { for ( security info security info : security infos ) { if ( check security info ( endpoint , client identity , security info ) ) { return bool ; } } return bool ; } } else if ( security infos != null && ! security infos . is empty ( ) ) { log . warn ( str , endpoint ) ; return bool ; } return bool ; }	return true if any of the securityinfos is valid for the given endpoint and client identity .
public boolean retain all ( abstract int list other ) { if ( other . size ( ) == num ) { if ( size == num ) return bool ; set size ( num ) ; return bool ; } int limit = other . size ( ) - num ; int j = num ; for ( int i = num ; i < size ; i ++ ) { if ( other . index of from to ( get quick ( i ) , num , limit ) >= num ) set quick ( j ++ , get quick ( i ) ) ; } boolean modified = ( j != size ) ; set size ( j ) ; return modified ; }	retains ( keeps ) only the elements in the receiver that are contained in the specified other list.
public static array list < byte string > byte arrays to strings ( array list < byte [ ] > byte arrays ) { if ( byte arrays == null ) { return null ; } array list < byte string > byte strings = new array list < byte string > ( ) ; for ( byte [ ] bytes : byte arrays ) { byte strings . add ( byte string . of ( bytes ) ) ; } return byte strings ; }	converts an arraylist < byte [ ] > to an arraylist < bytestring >.
void add index ( index type type , list < string > column names ) { index definition index = new index definition ( ) ; index . index name = table name + str + indexes . size ( ) ; index . column names = new . array list ( column names ) ; index . type = type ; indexes . add ( index ) ; }	defines an index with the specified column names .
public builder with key store key password ( string key store key password ) { properties . set property ( netty options . ssl key store key password , assert . not null ( key store key password , str ) ) ; return this ; }	sets the ssl key store key password .
public zookeeper state machine ensemble ( curator framework curator client , string base path ) { this ( curator client , base path , bool , default logsize ) ; }	instantiates a new zookeeper state machine ensemble .
public static custom shortcut set create shortcut ( char ch ) { character mnemonic = character . value of ( ch ) ; string shortcut = system info . is mac && system info . is java version at least ( str ) ? str + mnemonic : str + mnemonic ; return custom shortcut set . from string ( shortcut ) ; }	creates shortcut for mnemonic replacing standard alt + letter to ctrl + alt + letter on mac with jdk version newer than 6.
private node delete min ( node x ) { if ( x . left == null ) return x . right ; x . left = delete min ( x . left ) ; x . size = num + size ( x . left ) + size ( x . right ) ; x . height = num + math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }	removes the smallest key and associated value from the given subtree .
public static void reset counters ( ) { errors = num ; warnings = num ; }	reset error and warning counters.
public void write ( ceylon config config , file source , output stream out ) throws io { if ( source . is file ( ) ) { input stream in = null ; try { in = new file input stream ( source ) ; write ( config , in , out ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( io e ) { } } } } else { throw new file not found exception ( str ) ; } }	reads config from the given source file , updating it using the given configuration and writing in to the given output .
protected map < target class , list < attribute . type compound > > sift ( final iterable < attribute . type compound > type compounds ) { final map < target class , list < attribute . type compound > > target class to compound = new enum map < > ( target class . class ) ; for ( target class target class : target class . values ( ) ) { target class to compound . put ( target class , new array list < type compound > ( ) ) ; } for ( final attribute . type compound type compound : type compounds ) { final target type type compound target = type compound . position . type ; final list < attribute . type compound > dest list ; if ( element annotation util . contains ( type compound target , annotated targets ( ) ) ) { dest list = target class to compound . get ( target class . targeted ) ; } else if ( element annotation util . contains ( type compound target , valid targets ( ) ) ) { dest list = target class to compound . get ( target class . valid ) ; } else { dest list = target class to compound . get ( target class . invalid ) ; } dest list . add ( type compound ) ; } return target class to compound ; }	separate the input annotations into a map of targetclass ( targeted , valid , invalid ) to the annotations that fall into each of those categories .
protected synchronized void update location ( point new locn ) { prev = locn ; locn = new locn ; if ( math . abs ( locn . x - prev . x ) > hysteresis || math . abs ( locn . y - prev . y ) > hysteresis ) { if ( timer . is running ( ) ) timer . stop ( ) ; } else { if ( ! timer . is running ( ) ) timer . start ( ) ; } }	cause autoscroll to occur < p >.
@ override public int compare to ( value o ) { if ( o instanceof string val ) { return str . compare to ( ( ( string val ) o ) . str ) ; } else { return num ; } }	compares the string value to another value.
public void bind ( integer property property , int value ) { if ( is achieved ( ) ) return ; bind ( property . greater than or equal to ( value ) ) ; boolean binding bb = property . greater than or equal to ( value / num ) ; progress listener = null ; bb . add listener ( progress listener ) ; }	bind achievement condition to given property .
public void remove column ( column c ) { int idx = m columns . index of ( c ) ; if ( idx < num ) { throw new illegal argument exception ( str ) ; } remove column ( idx ) ; }	remove a column from this table.
public synchronized void write ( string log data ) { if ( log enabled ) { hist data . append ( log data ) ; hist data . revalidate ( ) ; synchronized ( hist data ) { hist data . notify ( ) ; } } }	append text to the log , repaint the window and notify the autoscroll thread to scroll to the end of the text area .
public void close connection ( ) { try { if ( m connection != null ) { m connection . close ( ) ; } } catch ( final sql exception ) { navi logger . severe ( str , exception ) ; } m connection = null ; }	closes the connection to the database .
public struct em bayes search editor ( struct em bayes search runner sem bayes est wrapper ) { this ( sem bayes est wrapper . get estimated bayes im ( ) , sem bayes est wrapper . get data set ( ) ) ; }	constructs a new bayes im editor from a bayes estimator wrapper .
public void remove action listener ( action listener listener ) { forward projection button . add action listener ( listener ) ; back projection button . add action listener ( listener ) ; }	removes the listener for events that shift the projection stack .
boolean is literal ( int index ) { if ( is valid mask ( ) && index < string . length ( ) ) { return literal mask . get ( index ) ; } return bool ; }	returns true if the character at index is a literal , that is not editable .
protected granularity generate granularity ( string granularity , granularity parser granularity parser ) throws bad api request exception { try { return granularity parser . parse granularity ( granularity ) ; } catch ( granularity parse exception e ) { log . error ( unknown granularity . log format ( granularity ) , granularity ) ; throw new bad api request exception ( e . get message ( ) ) ; } }	generate a granularity instance based on a path element .
public word iterator ( ) { this ( locale . get default ( ) ) ; }	constructs a worditerator using the default locale .
@ override public void close ( ) { if ( leaf != null ) { leaf . close ( ) ; leaf = null ; } cc mgr . release index locks ( ) ; dirs may be updated = null ; }	closes the index by closing its open leaf page , if necessary .
public void push file ( string local , string remote , i monitor ) throws sync exception , io , timeout exception { file f = new file ( local ) ; if ( ! f . exists ( ) ) { throw new sync exception ( sync error . no local file ) ; } if ( f . is directory ( ) ) { throw new sync exception ( sync error . local is directory ) ; } monitor . start ( ( int ) f . length ( ) ) ; do push file ( local , remote , monitor ) ; monitor . stop ( ) ; }	push a single file .
public string process ( item seg ) throws process exception { return seg coda ctype ( seg , str ) ; }	performs some processing on the given item .
public void resize ( int size ) { if ( buffer != null ) { if ( size >= num && size < buffer . size ( ) ) { int old last index = buffer . size ( ) - num ; int new last index = size - num ; for ( int i = old last index ; i > new last index ; i -- ) { buffer . remove ( i ) ; } } } else { if ( size >= num && size < offsets . size ( ) ) { long offset = offsets . get ( size ) ; byte cache . resize ( key , offset ) ; array list < long > new offsets = new array list < long > ( size ) ; for ( int i = num ; i < size ; i ++ ) { new offsets . add ( offsets . get ( i ) ) ; } offsets = new offsets ; } } }	resizes the array to contain a smaller number of elements.
public static byte [ ] split uint8 to2bytes ( char uint8 ) { if ( uint8 < num || uint8 > num ) { throw new runtime exception ( str ) ; } string hex string = integer . to hex string ( uint8 ) ; byte low ; byte high ; if ( hex string . length ( ) > num ) { high = ( byte ) integer . parse int ( hex string . substring ( num , num ) , num ) ; low = ( byte ) integer . parse int ( hex string . substring ( num , num ) , num ) ; } else { high = num ; low = ( byte ) integer . parse int ( hex string . substring ( num , num ) , num ) ; } byte [ ] result = new byte [ ] { high , low } ; return result ; }	split uint8 to 2 bytes of high byte and low byte.
protected void sprint ( short short field ) { sprint ( string . value of ( short field ) ) ; }	pretty printing accumulator function for shorts.
protected void init from dir ( string prefix , file dir ) { file [ ] files ; files = dir . list files ( new class file filter ( ) ) ; for ( file file : files ) { if ( prefix == null ) { add ( file . get name ( ) ) ; } else { add ( prefix + str + file . get name ( ) ) ; } } files = dir . list files ( new directory filter ( ) ) ; for ( file file : files ) { if ( prefix == null ) { init from dir ( file . get name ( ) , file ) ; } else { init from dir ( prefix + str + file . get name ( ) , file ) ; } } }	fills the class cache with classes in the specified directory .
public void remove bandwidth ( string name ) { if ( name != null ) if ( bandwidth list != null ) { for ( int i = num ; i < bandwidth list . size ( ) ; i ++ ) { object o = bandwidth list . element at ( i ) ; if ( o instanceof bandwidth field ) { bandwidth field b = ( bandwidth field ) o ; try { string type = b . get type ( ) ; if ( type != null ) { if ( name . equals ( type ) ) { bandwidth list . remove ( b ) ; } } } catch ( sdp parse exception e ) { } } } } }	removes the specified bandwidth type .
protected static void succeed ( ) { system . exit ( num ) ; }	exit with a process success code .
public static long now ( ) { return system . current time millis ( ) ; }	get the current time .
public static string collapse newlines ( string arg str ) { char last = arg str . char at ( num ) ; string buffer arg buf = new string buffer ( ) ; for ( int c idx = num ; c idx < arg str . length ( ) ; c idx ++ ) { char ch = arg str . char at ( c idx ) ; if ( ch != str || last != str ) { arg buf . append ( ch ) ; last = ch ; } } return arg buf . to string ( ) ; }	remove / collapse multiple newline characters .
@ override protected string generate javadoc ( int index ) throws exception { throw new exception ( str ) ; }	generates and returns the javadoc for the specified start / end tag pair .
public properties extract properties ( iterable < map . entry < string , string > > prop src ) { properties result = new properties ( ) ; for ( map . entry < string , string > entry : prop src ) { string name = entry . get key ( ) ; if ( is namespaced property ( name ) ) { string val = entry . get value ( ) ; result . set property ( name , val ) ; } } return result ; }	extract all properties in this namespace that can be found in the provided property source.
public t remove last ( ) { if ( rows . size ( ) != num ) rows . remove ( rows . size ( ) - num ) ; return instance ( ) ; }	remove the last row .
public static void ensure visible ( string component name ) { if ( verbose ) { log ( str + component name + str ) ; } ensure visible ( find by name ( component name ) ) ; }	scrolls to show the component in case it is invisible currently.
public void end representation ( ) { if ( ! representation protections set ) { if ( current representation protections != null ) { collections . sort ( current representation protections , this ) ; } representation protections = current representation protections ; representation protections set = bool ; } else { if ( current representation protections == null ) { assertions . check state ( representation protections == null ) ; } else { collections . sort ( current representation protections , this ) ; assertions . check state ( current representation protections . equals ( representation protections ) ) ; } } current representation protections = null ; }	should be invoked after processing each child representation element , in order to apply consistency checks .
public standard pie section label generator ( string label format ) { this ( label format , number format . get number instance ( ) , number format . get percent instance ( ) ) ; }	creates a new section label generator using the specified label format string , and platform default number and percentage formatters .
public static char sequence [ ] split ( char sequence line , int delimiter ) { char sequence [ ] tokens0 = split ( line , delimiter , n ) ; if ( tokens0 . length < n ) { return tokens0 ; } else { char sequence [ ] tokens1 = split ( tokens0 [ n - num ] , delimiter ) ; char sequence [ ] tokens2 = new char sequence [ tokens0 . length + tokens1 . length - num ] ; system . arraycopy ( tokens0 , num , tokens2 , num , tokens0 . length - num ) ; system . arraycopy ( tokens1 , num , tokens2 , tokens0 . length - num , tokens1 . length ) ; return tokens2 ; } }	splits a charsequence according to the delimiter character .
public cc ( object t , string s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - num ; try { class < ? > cls = target . get class ( ) ; invocation = cls . get method ( s , float . type ) ; } catch ( no such method exception e ) { e . print stack trace ( ) ; } }	initializes a timer with a target , a selector and an interval in seconds .
public tuple read ( ) throws io { try { map fields = json tuple stream . next ( ) ; if ( fields == null ) { map m = new hash map ( ) ; m . put ( str , bool ) ; return new tuple ( m ) ; } else { string msg = ( string ) fields . get ( str ) ; if ( msg != null ) { handled exception io exception = new handled exception ( msg ) ; throw io exception ; } if ( trace ) { fields . put ( str , this . base url ) ; if ( slice != null ) { fields . put ( str , slice ) ; } } if ( field mappings != null ) { fields = map fields ( fields , field mappings ) ; } return new tuple ( fields ) ; } } catch ( handled exception e ) { throw new io ( str + this . base url + str + e . get message ( ) ) ; } catch ( exception e ) { throw new io ( str + this . base url + str , e ) ; } }	reads a tuple from the stream.
private string compute ( string left , double right , boolean is integer ) { if ( left == null && double . is na n ( right ) ) { return null ; } if ( is integer && right == ( int ) right ) { return ( left == null ? str : left ) + ( int ) right ; } else if ( double . is infinite ( right ) ) { return ( left == null ? str : left ) + tools . format number ( right ) ; } else { return ( left == null ? str : left ) + ( double . is na n ( right ) ? str : right ) ; } }	adds a string and a double.
public void remove property change listener ( final property change listener listener ) { property change support . remove property change listener ( listener ) ; }	remove the specified property change listener .
public void load xml ( node stepnode , list < database meta > databases , map < string , counter > counters ) throws xml { try { this . tabel name = xml . get tag value ( stepnode , str ) ; this . output row size = xml . get tag value ( stepnode , str ) ; this . fact dim lens string = xml . get tag value ( stepnode , str ) ; this . table name = xml . get tag value ( stepnode , str ) ; this . database name = xml . get tag value ( stepnode , str ) ; this . dimension count = xml . get tag value ( stepnode , str ) ; this . no dictionary dims = xml . get tag value ( stepnode , str ) ; this . no dictionary dims mapping = xml . get tag value ( stepnode , str ) ; this . complex dimension count = xml . get tag value ( stepnode , str ) ; this . measure count = xml . get tag value ( stepnode , str ) ; this . update member request = xml . get tag value ( stepnode , str ) ; this . measure data type = xml . get tag value ( stepnode , str ) ; this . partition id = xml . get tag value ( stepnode , str ) ; this . segment id = xml . get tag value ( stepnode , str ) ; this . task no = xml . get tag value ( stepnode , str ) ; } catch ( exception e ) { throw new xml ( str , e ) ; } }	load the values for this step from an xml node.
public final int [ ] hash signature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = num ; i < signature . length ; i ++ ) { int stage = math . min ( i / rows , stages - num ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] * large prime ) % buckets ) ; } return hash ; }	hash a signature . the signature is divided in s stages ( or bands ) . each stage is hashed to one of the b buckets .
private void add trigger group name ( string group name ) throws job persistence exception , resource exception { add repo list name ( group name , trigger group names resource path , str ) ; }	adds a trigger group name to the list of trigger group names.
public string read string ( ) throws io { int first byte = read byte ( ) ; int length = read int ( first byte , prefix 8 bits ) ; byte [ ] encoded = new byte [ length ] ; bytes left -= length ; in . read fully ( encoded ) ; return new string ( encoded , str ) ; }	reads a utf - 8 encoded string.
private synchronized void clear temp files ( ) { if ( ( temp files != null ) && ( temp files . size ( ) > num ) ) { iterator it = temp files . iterator ( ) ; file file = null ; while ( it . has next ( ) ) { file = ( file ) it . next ( ) ; file . delete ( ) ; } temp files . clear ( ) ; } }	limpia la lista de ficheros temporales del escaneo.
private bitmap read and decompress thumbnail ( file file ) { try { if ( file . length ( ) > num ) { file input stream instream = new file input stream ( file ) ; readable byte channel bytechan = channels . new channel ( instream ) ; byte buffer buff = byte buffer . allocate direct ( ( int ) file . length ( ) ) ; if ( buff != null ) { bytechan . read ( buff ) ; instream . close ( ) ; buff . rewind ( ) ; pdq pthumb = decompression service . decompress thumbnail image ( buff ) ; if ( pthumb != null ) { bitmap bm = conversion service . convert pdq ( pthumb , bool ) ; pthumb . close ( ) ; return bm ; } } } } catch ( io ex ) { ex . print stack trace ( ) ; } return null ; }	read and extract a thumbnail - sized image from a file .
public void test submit runnable ( ) throws throwable { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; future < ? > future = e . submit ( new no op runnable ( ) ) ; assert null ( future . get ( ) ) ; assert true ( future . is done ( ) ) ; assert false ( future . is cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	completed submit ( runnable ) returns successfully.
public d shrink ( d area , d result ) { if ( result == null ) { result = new d . double ( ) ; } result . set rect ( area . get x ( ) + this . left , area . get y ( ) + this . top , area . get width ( ) - this . left - this . right , area . get height ( ) - this . top - this . bottom ) ; return result ; }	shrinks an area by the space attributes .
public static string assert jq ( solr query request req , string ... tests ) throws exception { return assert jq ( req , json . default delta , tests ) ; }	validates a query matches some json test expressions using the default double delta tolerance .
protected void build absolute stats ( string name , long value , long time ) throws interrupted exception { list < xy > stats = stats collection . get stats ( name ) ; if ( stats == null ) { stats = stats collection . new stats ( name , max series ) ; } else { xy data = new xy ( time , value ) ; stats collection . lock for update ( ) ; try { stats . add ( data ) ; house keep stats ( stats ) ; } finally { stats collection . release lock ( ) ; } if ( listeners != null ) { stats collection event event = new stats collection event ( name , data ) ; for ( stats collection listener listener : listeners ) { if ( listener . is enabled ( ) ) { listener . stats collected ( event ) ; } } } } }	builds the absolute stats .
protected void serialize ( string filename ) { classifier . serialize classifier ( filename ) ; }	serialize a model to file .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return begin in both ; case num : return newint ; case num : return newbyte ; case num : return newshort ; case num : return newlong ; case num : return newdouble ; case num : return newstruct ; case num : return newlist ; case num : return newset ; case num : return newmap ; case num : return newstring ; case num : return end in both ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public boolean is partition tag ( string field ) { if ( partitions == null || ( ! is tag ( field ) ) ) { return bool ; } for ( string partition : partitions ) { if ( partition . equals ( field ) ) { return bool ; } } return bool ; }	check if the specified field is a partition tag field.
protected d arrange fn ( block container container , d g2 , rectangle constraint constraint ) { list blocks = container . get blocks ( ) ; block b = ( block ) blocks . get ( num ) ; d s = b . arrange ( g2 , rectangle constraint . none ) ; double width = constraint . get width ( ) ; d bounds = new d . double ( ( width - s . width ) / num , num , s . width , s . height ) ; b . set bounds ( bounds ) ; return new d ( ( width - s . width ) / num , s . height ) ; }	arranges the blocks in the container with a fixed width and no height constraint .
private object process execute ( statement proxy , method method , object [ ] args ) throws throwable { long start time = log slow query ? system . current time millis ( ) : num ; try { if ( method . get name ( ) == str ) return new proxied result set ( proxy , method , args ) ; return target invoke ( method , args ) ; } finally { if ( log slow query ) log query ( proxy , args , start time ) ; } }	mainly exists to provide statement.
int bounded index of ( string string , char search , int start , int end ) { int ret value = string . index of ( search , start ) ; if ( ret value >= end ) { return - num ; } return ret value ; }	similar to string . indexof , but allows an upper bound ( this is slower in that it will still check string starting at start .
public int incr ( t k , int delta ) { integer i = counts . get ( k ) ; if ( i == null ) { i = num ; } int next = i . int value ( ) + delta ; if ( next < num ) { throw new java . lang . arithmetic exception ( ) ; } if ( next == num ) { counts . remove ( k ) ; } else { counts . put ( k , i + delta ) ; } return i ; }	adds delta to the count for k and returns the count prior to addition .
public void send ( final osc packet the packet , final tcp client the client ) { the client . send ( the packet . get bytes ( ) ) ; }	send to tcp client.
@ override @ suppress warnings ( str ) public void key typed ( key event evt ) { int modifiers = evt . get modifiers ( ) ; char c = evt . get key char ( ) ; if ( c != key event . char undefined && ( modifiers & input event . alt mask ) == num ) { if ( c >= num && c != num ) { key stroke key stroke = key stroke . get key stroke ( character . to upper case ( c ) ) ; object o = current bindings . get ( key stroke ) ; if ( o instanceof hashtable ) { current bindings = ( hashtable ) o ; return ; } else if ( o instanceof action listener ) { current bindings = bindings ; execute action ( ( action listener ) o , evt . get source ( ) , string . value of ( c ) ) ; return ; } current bindings = bindings ; if ( grab action != null ) { handle grab action ( evt ) ; return ; } if ( repeat && character . is digit ( c ) ) { repeat count *= num ; repeat count += ( c - str ) ; return ; } execute action ( insert char , evt . get source ( ) , string . value of ( evt . get key char ( ) ) ) ; repeat count = num ; repeat = bool ; } } }	handle a key typed event.
public static map < string , mapped class > fill in the gaps ( map < string , mapped class > mapped classes , mapping mode mode ) { for ( string original name : mapped classes . key set ( ) ) { mapped classes = fill gap ( mapped classes . get ( original name ) , mapped classes , mode ) ; } return mapped classes ; }	given a map of already renamed classes , fill in the gaps for classes that were not reached , but have parents that can be pulled from .
private void read object ( object input stream s ) throws io , class not found exception { s . default read object ( ) ; if ( name == null ) { if ( types != null ) { throw new invalid object exception ( str ) ; } } else { try { check ( ) ; } catch ( runtime exception e ) { rethrow ( e ) ; } } if ( constraints != null && constraints . is empty ( ) ) { throw new invalid object exception ( str ) ; } }	verifies that the method name , parameter types , and constraints are valid .
public static script create multi sig input script bytes ( list < byte [ ] > signatures ) { check argument ( signatures . size ( ) <= num ) ; script builder builder = new script builder ( ) ; builder . small num ( num ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; return builder . build ( ) ; }	create a program that satisfies an op_checkmultisig program , using pre - encoded signatures .
public void delete instances ( int [ ] row indices ) { int i ; arrays . sort ( row indices ) ; add undo point ( ) ; m = bool ; for ( i = row indices . length - num ; i >= num ; i -- ) { delete instance at ( row indices [ i ] , bool ) ; } m = bool ; notify listener ( new table model event ( this , row indices [ num ] , row indices [ row indices . length - num ] , table model event . all columns , table model event . delete ) ) ; }	deletes the instances at the given positions.
public synchronized < t extends event listener > void add ( class < t > t , t l ) { if ( l == null ) { return ; } if ( ! t . is instance ( l ) ) { throw new illegal argument exception ( str + l + str + t ) ; } if ( listener list == null array ) { listener list = new object [ ] { t , l } ; } else { int i = listener list . length ; object [ ] tmp = new object [ i + num ] ; system . arraycopy ( listener list , num , tmp , num , i ) ; tmp [ i ] = t ; tmp [ i + num ] = l ; listener list = tmp ; } }	adds the listener as a listener of the specified type .
public static void gc2gc ( double c1 [ ] , int m1 , double g1 , double c2 [ ] , int m2 , double g2 ) { double [ ] gc2gc buff = arrays . copy of ( c1 , m1 + num ) ; c2 [ num ] = gc2gc buff [ num ] ; for ( int i = num ; i <= m2 ; i ++ ) { double ss1 = num ; double ss2 = num ; int min = m1 < i ? m1 : i - num ; for ( int k = num ; k <= min ; k ++ ) { int mk = i - k ; double cc = gc2gc buff [ k ] * c2 [ mk ] ; ss2 += k * cc ; ss1 += mk * cc ; } if ( i <= m1 ) c2 [ i ] = gc2gc buff [ i ] + ( g2 * ss2 - g1 * ss1 ) / i ; else c2 [ i ] = ( g2 * ss2 - g1 * ss1 ) / i ; } }	gc2gc : generalized cepstral transformation.
public static boolean between ( date base date , date start date , date end date ) { if ( start date . equals ( end date ) || end date . before ( start date ) ) { return bool ; } if ( ( start date . before ( base date ) || start date . equals ( base date ) ) && ( end date . after ( base date ) || end date . equals ( base date ) ) ) { return bool ; } return bool ; }	tests if the given base date is between the given start date and end date , including the dates themselves .
public void add listener ( final timeout event listener listener ) { final long timeout = listener . get timeout ( ) ; if ( timeout > num ) { listeners . add ( listener ) ; synchronized ( state lock ) { pending listener min delay = math . min ( pending listener min delay , timeout ) ; state lock . notify all ( ) ; } } }	registers a timeout event listener for timeout notification .
public static string [ ] convert strings ( list < string > strings ) { string [ ] ret = new string [ strings . size ( ) ] ; for ( int i = num ; i < ret . length ; i ++ ) { ret [ i ] = strings . get ( i ) ; } return ret ; }	converts the provided string list to a string array .
public static string transform tool tip text ( final string description , final boolean add html , final int line length , final boolean escape slashes , final boolean escape html ) { string complete text = description . trim ( ) ; if ( escape html ) { complete text = tools . escape html ( complete text ) ; } if ( escape slashes ) { complete text = complete text . replace all ( str , str ) ; } string buffer result = new string buffer ( ) ; if ( add html ) { result . append ( str ) ; } complete text = tools . transform all line separators ( complete text ) ; string [ ] lines = complete text . split ( str ) ; for ( string text : lines ) { boolean first = bool ; while ( text . length ( ) > line length ) { int space index = text . index of ( str , line length ) ; if ( ! first ) { result . append ( str ) ; } first = bool ; if ( space index >= num ) { result . append ( text . substring ( num , space index ) ) ; text = text . substring ( space index + num ) ; } else { result . append ( text ) ; text = str ; } } if ( ! first && text . length ( ) > num ) { result . append ( str ) ; } result . append ( text ) ; result . append ( str ) ; } if ( add html ) { result . append ( str ) ; } return result . to string ( ) ; }	this method transforms the given tool tip text into html.
@ override public void write ( byte [ ] buffer , int offset , int length ) { if ( is closed ( ) || is head ( ) ) { return ; } int byte length = offset ; while ( bool ) { int sublen = math . min ( length , size - byte length ) ; system . arraycopy ( buffer , offset , buffer , byte length , sublen ) ; offset += sublen ; length -= sublen ; byte length += sublen ; if ( length <= num ) { break ; } offset = byte length ; flush byte buffer ( ) ; byte length = offset ; } offset = byte length ; }	writes a chunk of bytes to the stream .
public client http request ( url connection ) throws io { this . connection = connection ; connection . set do output ( bool ) ; connection . set do input ( bool ) ; connection . set request property ( str , str + boundary ) ; }	creates a new multipart post http request on a freshly opened urlconnection.
public void characters ( string characters ) throws sax { final int len = characters . length ( ) ; if ( len > m chars buff . length ) { m chars buff = new char [ len * num + num ] ; } characters . get chars ( num , len , m chars buff , num ) ; characters ( m chars buff , num , len ) ; }	receive notification of character data .
private void append tag ( string tag name , string value ) { xml . append ( str ) ; xml . append ( tag name ) ; xml . append ( str ) ; xml . append ( value ) ; xml . append ( str ) ; xml . append ( tag name ) ; xml . append ( str ) ; }	helper method for printing a tag in toplevel . xml.
@ override public certificate token validation extra info extra info ( ) { return extra info ; }	returns the object managing the validation extra info .
public void add top level contents ( collection < content element > contents ) { top level contents . add all ( contents ) ; }	add top level contents to the document .
public static void with instance ( map < string , object > args , closure c ) throws sql , class not found exception { sql sql = null ; try { sql = new instance ( args ) ; c . call ( sql ) ; } finally { if ( sql != null ) sql . close ( ) ; } }	invokes a closure passing it a new sql instance created from the given map of arguments.
public void write ( byte [ ] buffer , int offset , int length , boolean is end ) throws io { throw new unsupported operation exception ( string . value of ( this ) ) ; }	writes a buffer to the underlying stream .
private boolean add index entry ( service type resource type , string resource name , string policy name ) throws policy exception { resource index resource index = ( resource index ) resource indices . get ( resource type . get name ( ) ) ; if ( resource index == null ) { resource index = refresh resource index from data store ( resource type ) ; } return resource index . add index entry ( resource name , policy name ) ; }	adds a new index entry or updates an existing index entry.
public void dd solve ( set < node > qry nodes ) { long solve time = num , prepare time = num ; if ( has executed == bool ) solve ( ) ; if ( dd prepared == bool || offline processor == null ) { offline processor = new offline processor ( this ) ; i . clean cache ( ) ; dd prepared = bool ; ps . println ( ) ; ps . println ( str ) ; } int init size = qry nodes . size ( ) ; if ( init size == num ) { ps . println ( str ) ; return ; } date prepare begin = new date ( ) ; offline processor . init ( ) ; offline processor . add user def pts ( qry nodes ) ; offline processor . run optimizations ( ) ; date prepare end = new date ( ) ; prepare time += prepare end . get time ( ) - prepare begin . get time ( ) ; date begin = new date ( ) ; prepare next run ( ) ; node generator . init flow graph ( this ) ; solve constraints ( ) ; date end = new date ( ) ; solve time += end . get time ( ) - begin . get time ( ) ; ps . println ( ) ; ps . printf ( str , ( double ) prepare time / num ) ; ps . printf ( str , ( double ) solve time / num ) ; }	the demand - driven mode for precisely computing points - to information for given pointers.
private static void delete from ( int delete at , int [ ] starts , int num starts ) { while ( starts [ -- num starts ] > delete at ) { starts [ num starts ] -= num ; } }	adjust indices in starts to reflect a deletion after deleteat.
public static event type metadata create bean type ( string name , class clazz , boolean is pre configured static , boolean is pre configured , boolean is configured , type class type class ) { set < string > secondary names = null ; if ( name == null ) { name = clazz . get name ( ) ; } else { if ( ! name . equals ( clazz . get name ( ) ) ) { secondary names = new linked hash set < string > ( ) ; secondary names . add ( clazz . get name ( ) ) ; } } return new event type metadata ( name , secondary names , type class , is pre configured static , is pre configured , is configured , application type . class , bool ) ; }	factory for a bean type .
private boolean reverse it ( ) { if ( ! is active ( ) ) throw new illegal state exception ( str ) ; m . test period open ( get ctx ( ) , get date trx ( ) , m . docbasetype , get ad id ( ) ) ; set is active ( bool ) ; if ( ! is posted ( ) ) set posted ( bool ) ; set document no ( get document no ( ) + str ) ; set doc status ( docstatus ) ; if ( ! save ( ) || is active ( ) ) throw new illegal state exception ( str ) ; m . delete ex ( m . id , get c id ( ) , get ( ) ) ; get lines ( bool ) ; hash set < integer > bps = new hash set < integer > ( ) ; for ( int i = num ; i < m lines . length ; i ++ ) { m line = m lines [ i ] ; line . set is active ( bool ) ; line . save ex ( ) ; bps . add ( new integer ( line . process it ( bool ) ) ) ; } update bp ( bps ) ; return bool ; }	reverse allocation . period needs to be open.
public static boolean use subject creds only ( gss caller ) { if ( caller instanceof http caller ) { return bool ; } string prop value = access controller . do privileged ( new get property action ( str , str ) ) ; return ( ! prop value . equals ignore case ( str ) ) ; }	determines if the application doesn ' t mind if the mechanism obtains the required credentials from outside of the current subject.
public void add ( string field name , string value ) { if ( field name == null ) throw new illegal argument exception ( str ) ; if ( value == null ) throw new illegal argument exception ( str ) ; if ( field name . length ( ) == num || field name . index of ( str ) != - num || value . index of ( str ) != - num ) { throw new illegal argument exception ( str + field name + str + value ) ; } add lenient ( field name , value ) ; }	add a field with the specified value .
public void delete storage ( storage data storage data ) throws business exception , io { storage data local = get local storage data object ( storage data ) ; synchronized ( local ) { if ( ( storage recorder . is recording on ( ) || storage recorder . is recording scheduled ( ) ) && objects . equals ( local , recorder storage data ) ) { throw new business exception ( str + local + str , storage error code enum . storage already closed ) ; } if ( local . is storage opened ( ) ) { storage writer writer = opened storages map . get ( local ) ; if ( writer != null ) { writer . cancel ( ) ; } opened storages map . remove ( local ) ; } delete complete storage data from disk ( local ) ; existing storages set . remove ( local ) ; } }	deletes a storage information and files from disk .
public coap response advanced ( request request ) { assign client uri if empty ( request ) ; return synchronous ( request ) ; }	sends an advanced synchronous request that has to be configured by the developer .
@ override public boolean condition ok ( example example ) { boolean is ok = bool ; for ( attribute attribute : checked attributes ) { is ok &= ! double . is na n ( example . get value ( attribute ) ) ; } return is ok ; }	returns true if the example does not contain missing values within regarded attributes .
private void load binary ( input stream is ) throws io { if ( use new io && is instanceof file input stream ) { file input stream fis = ( file input stream ) is ; if ( use indexing ) { load binary index ( new url ( index name ) ) ; map database ( fis ) ; } else { load mapped binary ( fis ) ; } } else { data input stream dis = new data input stream ( new buffered input stream ( is ) ) ; load binary ( dis ) ; } }	loads a binary file from the input stream.
public vn delete luns from lun group ( string lun group id , list < string > luns ) { lun group modify param param = new lun group modify param ( ) ; list < lun add param > lun delete = new array list < lun add param > ( ) ; for ( string lun id : luns ) { vn lun = new vn ( lun id ) ; lun add param lun add = new lun add param ( ) ; lun add . set lun ( lun ) ; lun delete . add ( lun add ) ; } param . set lun delete ( lun delete ) ; lun group requests req = new lun group requests ( kh client ) ; return req . modify lun group async ( lun group id , param ) ; }	delete luns from lun group.
public void remove locators ( lookup locator [ ] locators ) { test set for null ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new illegal state exception ( str ) ; } hash map groups map = new hash map ( num ) ; for ( int i = num ; i < locators . length ; i ++ ) { locator reg reg = remove discovered locator ( locators [ i ] ) ; if ( reg != null ) { groups map . put ( reg . proxy , reg . member groups ) ; continue ; } reg = find reg ( locators [ i ] ) ; if ( reg != null ) { undiscovered locators . remove ( reg ) ; } } if ( ! groups map . is empty ( ) && ! listeners . is empty ( ) ) { add notify ( ( array list ) listeners . clone ( ) , groups map , bool ) ; } } }	deletes a set of locators from the managed set of locators , and discards any already - discovered lookup service that corresponds to a deleted locator.
public boolean is selected ( item selection choice p choice ) { return sel array [ p choice . ordinal ( ) ] ; }	looks , if the input item type is selected .
private void add ( final i operation ) { final grid bag constraints constraints = new grid bag constraints ( ) ; constraints . fill = grid bag constraints . horizontal ; constraints . gridy = counter ++ ; constraints . gridx = num ; constraints . weightx = num ; constraints . weighty = num ; m progress panel . add ( operation . get progress panel ( ) , constraints ) ; }	updates the dialog with a new operation .
public key store builder with provider ( final string provider name ) { provider provider = security . get provider ( provider name ) ; if ( provider == null ) { throw new illegal argument exception ( str + provider name ) ; } return with provider ( provider ) ; }	specifies the security provider to use for the keystore .
private boolean compare and decrement worker count ( int expect ) { return ctl . compare and set ( expect , expect - num ) ; }	attempts to cas - decrement the workercount field of ctl .
public static url to http connection ( request ... requests ) { return to http connection ( arrays . as list ( requests ) ) ; }	serializes one or more requests but does not execute them.
public tcp ( string host , int port ) { this ( host , port , null , null ) ; }	create an endpoint for a specified host and port.
public void test bug22613 ( ) throws exception { create table ( str , str ) ; check metadata for bug22613 ( this . conn ) ; if ( version meets minimum ( num , num ) ) { connection info schem conn = null ; try { properties props = new properties ( ) ; props . set property ( str , str ) ; info schem conn = get connection with props ( props ) ; check metadata for bug22613 ( info schem conn ) ; } finally { if ( info schem conn != null ) { info schem conn . close ( ) ; } } } }	tests fix for bug # 22613 - dbmd . getcolumns ( ) does not return expected column_size for the set type ( fixed to be consistent with the odbc driver ).
public long stime ( ) { return long . parse long ( fields [ num ] ) ; }	amount of time that this process has been scheduled in kernel mode , measured in clock ticks ( divide by sysconf ( _sc_clk_tck ) ) .
public program rewriter ( array list < hop rewrite rule > h rewrites , array list < statement block rewrite rule > sb rewrites ) { dag rule set = new array list < hop rewrite rule > ( ) ; dag rule set . add all ( h rewrites ) ; sb rule set = new array list < statement block rewrite rule > ( ) ; sb rule set . add all ( sb rewrites ) ; }	construct a program rewriter for the given rewrite sets which are passed from outside .
private j create settings menu ( ) { final j menu = new j ( str ) ; menu . set mnemonic ( str ) ; menu . add ( new c ( get parent ( ) ) ) ; menu . add ( new j ( ) ) ; menu . add ( new c ( get parent ( ) ) ) ; menu . add ( new c ( get parent ( ) ) ) ; return menu ; }	creates the settings menu .
public static void write string ( data output stream os , string s ) throws io { if ( s == null ) { os . write int ( - num ) ; } else { byte array [ ] = s . get bytes ( ) ; os . write int ( array . length ) ; os . write ( array ) ; } }	write string to dataoutputstream motivation : datainputstream . readutf can ' t print lines larger than ushortmax.
public static boolean is java valid name ( string str ) { if ( str . is empty ( ) ) return bool ; if ( java keys . contains ( str ) ) return bool ; char first = str . char at ( num ) ; if ( is valid name start char ( first ) ) { for ( int i = num ; i < str . length ( ) ; ++ i ) { char c = str . char at ( i ) ; if ( ! is valid name char ( c ) ) return bool ; } return bool ; } else { return bool ; } }	check whether the given string can be a valid java name.
private list < string > create commands ( ) { list < string > commands = create node commands ( nodejs file , ts file ) ; list < string > args = create node args ( ) ; if ( args != null ) { commands . add all ( args ) ; } return commands ; }	create process commands to start tern with node . js.
private void parse packages ( sensor context sensor context ) { for ( directory directory : package list ) { sensor context . save measure ( directory , core metrics . directories , num ) ; sensor context . save measure ( directory , core metrics . files , ( double ) files count . get ( directory ) ) ; } }	count the metrics for packages.
public static thread consume process error stream ( process self , appendable error ) { thread thread = new thread ( new text dumper ( self . get error stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }	gets the error stream from a process and reads it to keep the process from blocking due to a full buffer.
public str builder delete first ( final string str ) { final int len = ( str == null ? num : str . length ( ) ) ; if ( len > num ) { final int index = index of ( str , num ) ; if ( index >= num ) { delete impl ( index , index + len , len ) ; } } return this ; }	deletes the string wherever it occurs in the builder .
private static class < ? > [ ] classes for params ( list < string > params ) { class < ? > [ ] result = new class < ? > [ params . size ( ) ] ; for ( int i = num ; i < params . size ( ) ; i ++ ) { result [ i ] = class for param ( params . get ( i ) ) ; } return result ; }	turn an array of strings ( class names ) into an array of class objects.
final public void trim to size ( ) { for ( gaz entry ge : gaz . values ( ) ) { ge . trim to size ( ) ; } }	trim off excess size dead space .
public boolean contains select account ( ) { return prompts . contains ( prompt select account ) ; }	determines if the prompt contains ' select_account ' .
protected static void quick sort ( instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quick sort ( insts , indices , attidx , left , middle ) ; quick sort ( insts , indices , attidx , middle + num , right ) ; } }	sorts the instances according to the given attribute / dimension.
public image flip image horizontally ( image image , boolean maintain opacity ) { int [ ] rgb = image . get rgb ( ) ; int [ ] new rgb = new int [ rgb . length ] ; int width = image . get width ( ) ; int height = image . get height ( ) ; for ( int y = num ; y < height ; y ++ ) { for ( int x = num ; x < width ; x ++ ) { new rgb [ ( width - x - num ) + y * width ] = rgb [ x + y * width ] ; } } return encoded image . create from rgb ( new rgb , width , height , ! maintain opacity ) ; }	flips the given image on the horizontal axis.
public static boolean audit ( ) { return audit . get ( ) == null ? bool : audit . get ( ) ; }	whether audit is enable ? defaults to true .
public static boolean is terms request ( sip request request ) { string content type = request . get content type ( ) ; return ( content type != null && content type . starts with ( str ) ) ; }	is a terms & conditions request.
private void read segments ( ) throws io { for ( segment extent10 extent : segment extents ) { try ( read stream is = open read ( extent . address ( ) , extent . length ( ) ) ) { is . skip ( extent . length ( ) - block size ) ; long sequence = bits util . read long ( is ) ; byte [ ] table key = new byte [ table key size ] ; is . read all ( table key , num , table key . length ) ; if ( sequence > num ) { segment10 segment = new segment10 ( sequence , table key , extent ) ; segments . add ( segment ) ; } } } }	reads the segment metadata , the sequence and table key .
public static double project time within24 hours ( double time ) { double seconds in one day = num * num * num ; if ( time == double . negative infinity || time == double . positive infinity ) { debug lib . stop system and report inconsistency ( str ) ; } while ( time < num ) { time += seconds in one day ; } if ( time < seconds in one day ) { return time ; } else { return ( ( time / seconds in one day ) - ( math . floor ( time / seconds in one day ) ) ) * seconds in one day ; } }	if time is > 60 * 60 * 24 [ seconds ] , it will be projected into next day , e.
private byte [ ] update min max for no dictionary ( byte [ ] value with length ) { byte buffer buffer = byte buffer . wrap ( value with length ) ; byte [ ] actual value = new byte [ buffer . get short ( ) ] ; buffer . get ( actual value ) ; return actual value ; }	below method will be used to update the min or max value by removing the length from it.
private object deserialize struct ( element el struct ) throws converter exception { string type = el struct . get attribute ( str ) ; struct struct = new struct impl ( ) ; node list list = el struct . get child nodes ( ) ; int len = list . get length ( ) ; for ( int i = num ; i < len ; i ++ ) { node node = list . item ( i ) ; if ( node instanceof element ) { element var = ( element ) node ; element value = get child element ( ( element ) node ) ; if ( value != null ) { struct . set el ( var . get attribute ( str ) , deserialize ( value ) ) ; } } } if ( struct . size ( ) == num && type != null && type . length ( ) > num ) { return str ; } return struct ; }	desirialize a struct object.
public cli ( string [ ] args ) { cli options = create options ( ) ; try { command line parser parser = new gnu parser ( ) ; command line = parser . parse ( cli options , args , bool ) ; if ( has option ( str ) ) { print help ( ) ; system . exit ( num ) ; } if ( ! parse options ( ) ) { logger . info ( str ) ; print help ( ) ; system . exit ( num ) ; } } catch ( exception e ) { e . print stack trace ( ) ; system . exit ( num ) ; } }	create and parse allowable options.
private static byte [ ] concat bytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] c bytes = new byte [ array1 . length + array2 . length ] ; try { system . arraycopy ( array1 , num , c bytes , num , array1 . length ) ; system . arraycopy ( array2 , num , c bytes , array1 . length , array2 . length ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } return c bytes ; }	this method concatenates two byte arrays.
public in ( file file ) { if ( file == null ) throw new null pointer exception ( str ) ; try { file input stream fis = new file input stream ( file ) ; scanner = new scanner ( new buffered input stream ( fis ) , charset name ) ; scanner . use locale ( locale ) ; } catch ( io ioe ) { throw new illegal argument exception ( str + file ) ; } }	initializes an input stream from a file .
protected extended dismax configuration create configuration ( string qstr , solr params local params , solr params params , solr query request req ) { return new extended dismax configuration ( local params , params , req ) ; }	creates an instance of extendeddismaxconfiguration . it will contain all the necessary parameters to parse the query.
void write value properties ( string full id , long db id , string local id , json value value , connection connection ) throws sql { if ( cfg . has possible searchable properties ( ) ) { integer batching count = num ; prepared statement prop create statement = get prepared statement ( connection , query definition . propcreatequerystr ) ; try { batching count = write value properties ( full id , db id , local id , value , connection , prop create statement , batching count ) ; if ( enable batching && batching count > num ) { int [ ] num updates = prop create statement . execute batch ( ) ; logger . debug ( str , num updates ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str , arrays . as list ( num updates ) ) ; } prop create statement . clear batch ( ) ; } } finally { cleanup helper . logged close ( prop create statement ) ; } } }	writes all properties of a given resource to the properties table and links them to the main table record .
protected double compute max y ( double max value ) { double v = num ; int mantisse = num ; int exponent = num ; while ( v < max value ) { if ( mantisse < num ) mantisse ++ ; else { mantisse = num ; exponent ++ ; } v = mantisse * math . pow ( num , exponent ) ; } return math . log10 ( v ) ; }	compute the maximum value on a log scale.
public void add focus cleared listener ( focus cleared listener focus cleared listener ) { m focus cleared listeners . add ( focus cleared listener ) ; }	register a listener to be notified when focus is cleared.
public void add item listener ( item listener a listener ) { listener list . add ( item listener . class , a listener ) ; }	add a listener for mode changes.
@ override public enumeration < option > list options ( ) { vector < option > result ; result = new vector < option > ( ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str + get default num decimals ( ) + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration of all the available options.
public static mosaic levy create mosaic levy ( final mosaic id mosaic id ) { return new mosaic levy ( mosaic transfer fee type . absolute , generate random account ( ) , mosaic id , quantity . from value ( num ) ) ; }	creates a xem mosaic levy .
public int rank of ( double value ) { int ret = num ; if ( ! has capacity ( ) ) { ret = arrays . binary search ( data , value ) ; if ( ret < num ) { return - ret - num ; } else { return ret ; } } else { for ( int i = num ; i < next ; i ++ ) { if ( data [ i ] < value ) { ret ++ ; } } return ret ; } }	returns the ordinal rank of value among the sampled values in this buffer .
public static < t > predicate < t > not ( predicate < t > predicate ) { return predicate . negate ( ) ; }	negate the given predicate .
private static void add margin top to content child ( view m content child , int status bar height ) { if ( m content child == null ) { return ; } if ( ! tag margin added . equals ( m content child . get tag ( ) ) ) { frame layout . layout params lp = ( frame layout . layout params ) m content child . get layout params ( ) ; lp . top margin += status bar height ; m content child . set layout params ( lp ) ; m content child . set tag ( tag margin added ) ; } }	add margintop to simulate set fitssystemwindow true.
static byte [ ] hex string to byte array ( string hex string ) { string s = hex string ; int len = s . length ( ) ; if ( len % num == num ) { s = str + s ; len ++ ; } byte [ ] data = new byte [ len / num ] ; for ( int i = num ; i < len ; i += num ) { data [ i / num ] = ( byte ) ( ( character . digit ( s . char at ( i ) , num ) << num ) + character . digit ( s . char at ( i + num ) , num ) ) ; } return data ; }	converts a hexadecimal string into an byte array.
public int send ( byte [ ] buffer , int offset , int count ) { check array bounds ( buffer , offset , count ) ; if ( count == num ) { return num ; } byte [ ] data = buffer ; if ( offset > num ) { data = new byte [ count ] ; system . arraycopy ( buffer , offset , data , num , count ) ; } int out bytes sent out = new int out ( ) ; try { i . check result ( i . idevice connection send ( get ref ( ) , data , count , bytes sent out ) ) ; return bytes sent out . get value ( ) ; } finally { bytes sent out . delete ( ) ; } }	sends data to the device on this connection .
private void fetch schema ( ) throws execution exception , rpc exception , timeout exception { message schema = rpc . get ( my client . get schema ( ) , fetch schema timeout ms , time unit . milliseconds ) ; log . info ( str + schema . entities . length + str + schema . constants . length + str ) ; int atoms = num ; for ( entity type : schema . entities ) { if ( atom metadata . find ( type ) != null ) { atoms ++ ; } dynamic . register ( type ) ; } log . info ( str + atoms + str ) ; for ( constant set set : schema . constants ) { constant set . register ( set ) ; } }	requests and blocks for the schema from the server .
private void append ( string builder buffer , double [ ] data , string prefix , string separator , string suffix ) { buffer . append ( prefix ) ; for ( int i = num ; i < data . length ; ++ i ) { if ( i > num ) { buffer . append ( separator ) ; } buffer . append ( data [ i ] ) ; } buffer . append ( suffix ) ; }	append a text representation of an array to a buffer .
public t to real array ( ) { return output array type . cast ( array multidimensionalizer . multidimensionalize ( real , dimensions ) ) ; }	returns an array that holds the real values from the matlab array.
private array list < writable comparable > read partitions ( file system fs , path p , job conf job ) throws io { sequence file . reader reader = new sequence file . reader ( fs , p , job ) ; array list < writable comparable > parts = new array list < writable comparable > ( ) ; try { double writable key = new double writable ( ) ; null writable value = null writable . get ( ) ; while ( reader . next ( key , value ) ) { parts . add ( key ) ; key = new double writable ( ) ; } } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { io . close silently ( reader ) ; } reader . close ( ) ; return parts ; }	read the cut points from the given sequence file .
public boolean poll seqno ( long seqno ) { return seqno <= disk log . get max seqno ( ) ; }	returns true if the indicated sequence number is available .
private static void draw line ( int x0 , int y0 , int x1 , int y1 , boolean [ ] [ ] pic ) { final int xres = pic . length , yres = pic [ num ] . length ; y0 = ( y0 < num ) ? num : ( y0 >= yres ) ? ( yres - num ) : y0 ; y1 = ( y1 < num ) ? num : ( y1 >= yres ) ? ( yres - num ) : y1 ; x0 = ( x0 < num ) ? num : ( x0 >= xres ) ? ( xres - num ) : x0 ; x1 = ( x1 < num ) ? num : ( x1 >= xres ) ? ( xres - num ) : x1 ; final int dx = + math . abs ( x1 - x0 ) , sx = x0 < x1 ? num : - num ; final int dy = - math . abs ( y1 - y0 ) , sy = y0 < y1 ? num : - num ; int err = dx + dy ; for ( ; ; ) { pic [ x0 ] [ y0 ] = bool ; if ( x0 == x1 && y0 == y1 ) { break ; } final int e2 = err << num ; if ( e2 > dy ) { err += dy ; x0 += sx ; } if ( e2 < dx ) { err += dx ; y0 += sy ; } } }	draw a line onto the array , using the classic bresenham algorithm .
public string process ( item item ) throws process exception { int count = num ; item in phrase = sub phrase path . find item ( item ) ; for ( item p = in phrase ; p != null ; p = p . get previous ( ) ) { count ++ ; } return integer . to string ( rail ( count ) ) ; }	performs some processing on the given item .
public e push ( e value ) { elements . add ( value ) ; return value ; }	push to the top of the stack.
public long cardinality ( final int tail index ) { return range count ( tail index ) ; }	return the cardinality of a particular tail , which is the range count if not optional and infinite if optional .
public static void create response ( http servlet request request , http servlet response response , http servlet servlet , properties cookie properties , web doc doc , boolean debug ) throws io { response . set header ( str , str ) ; response . set content type ( str ) ; if ( cookie properties != null ) { cookie cookie = new cookie ( web env . cookie info , properties encode ( cookie properties ) ) ; cookie . set comment ( str ) ; cookie . set secure ( bool ) ; cookie . set path ( str ) ; if ( cookie properties . size ( ) == num ) cookie . set max age ( num ) ; else cookie . set max age ( num ) ; response . add cookie ( cookie ) ; } if ( debug && web env . debug ) { web env . add footer ( request , response , servlet , doc . get body ( ) ) ; } print writer out = response . get writer ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . check error ( ) ) log . log ( level . severe , str ) ; out . close ( ) ; }	create standard response header with optional cookie and print document.
public static long to long ( object o ) throws page exception { if ( o instanceof long ) return ( long ) o ; return long . value of ( to long value ( o ) ) ; }	cast a object to a long object ( reference type ).
protected void finish grid row ( ) { grid bag constraints constraints = new grid bag constraints ( ) ; constraints . gridwidth = grid bag constraints . remainder ; constraints . weightx = num ; final j icon ; if ( param . is optional ( ) ) { if ( param . is defined ( ) && param . took default value ( ) && ! ( param instanceof flag ) ) { icon = new j ( stock icon . get stock icon ( stock icon . dialog information ) ) ; icon . set tool tip text ( str + param . get default value as string ( ) ) ; } else { icon = new j ( ) ; icon . set minimum size ( new dimension ( num , num ) ) ; } } else { if ( ! param . is defined ( ) ) { icon = new j ( stock icon . get stock icon ( stock icon . dialog error ) ) ; icon . set tool tip text ( str ) ; } else { icon = new j ( ) ; icon . set minimum size ( new dimension ( num , num ) ) ; } } parent . add ( icon , constraints ) ; }	complete the current grid row , adding the icon at the end.
public final void test is state preserved1 ( ) { byte [ ] encoded key = new byte [ ] { ( byte ) num , ( byte ) num , ( byte ) num , ( byte ) num } ; byte [ ] encoded key copy = encoded key . clone ( ) ; x509 encoded key spec meks = new x509 encoded key spec ( encoded key copy ) ; encoded key copy [ num ] = ( byte ) num ; byte [ ] ek = meks . get encoded ( ) ; assert true ( arrays . equals ( encoded key , ek ) ) ; }	tests that internal state of the object can not be changed by modifying initial array value.
@ override public void shutdown ( ) { if ( ! should keep adb alive ) { android debug bridge . disconnect bridge ( ) ; android debug bridge . terminate ( ) ; } logger . info ( str ) ; }	shutdown the androiddebugbridge and clean up all connected devices .
public void ping received ( ping pong ) { long now = system . current time millis ( ) ; long previous received = ( int ) ( last ping sent . get ( ) & num ) ; log . debug ( str , new object [ ] { get id ( ) , now , pong . get value2 ( ) , previous received } ) ; if ( pong . get value2 ( ) == previous received ) { last ping time . set ( ( int ) ( now & num ) - pong . get value2 ( ) ) ; } last pong received . set ( now ) ; }	marks that ping back was received .
public static int find object literal ( object literal ) { synchronized ( object literals ) { integer result = object literals . get ( literal ) ; return result == null ? num : result . int value ( ) ; } }	find a slot in the jtoc with this object literal in else return 0.
@ override public void reset viewable area ( ) { throw new runtime exception ( str ) ; }	not part of api turns off the viewable area , scaling the page back to original scaling.
private void test transfer rate ( ) { assert . assert not null ( m expected transfer rate ops ) ; assert . assert not null ( m expected transfer rate bps ) ; assert . assert true ( m expected transfer rate bps . int value ( ) > num ) ; assert . assert true ( m expected transfer rate ops . int value ( ) > num ) ; }	compare transfer rate calculated to expected value .
public void add ( x509 trust manager mgr ) { if ( mgr instanceof x509 extensions ) { managers . add ( ( x509 extensions ) mgr ) ; } else { managers . add ( new x509 extensions wrapper ( mgr ) ) ; } }	add an x509trustmanager to the ones being governed by this composite.
public iterator < tree node > find children ( ) { list < tree node > nodes ; if ( children == null ) nodes = collections . empty list ( ) ; else nodes = children ; return nodes . iterator ( ) ; }	return an iterator of all children of this node.
private int create folder ( ) { if ( m new directory name != null && m selected dir != null && m selected dir . can write ( ) ) { file new dir = new file ( m selected dir , m new directory name ) ; if ( ! new dir . exists ( ) ) { boolean result = new dir . mkdir ( ) ; if ( result ) { change directory ( new dir ) ; return r . string . create folder success ; } else { return r . string . create folder error ; } } else { return r . string . create folder error already exists ; } } else if ( m selected dir != null && ! m selected dir . can write ( ) ) { return r . string . create folder error no write access ; } else { return r . string . create folder error ; } }	creates a new folder in the current directory with the name create_directory_name .
public static double i ( double p [ ] [ ] , int j , int k ) { double i = num ; double p x = p [ j ] [ j ] ; double p y = p [ k ] [ k ] ; double p xy = p [ j ] [ k ] ; i += p xy * math . log ( p xy / ( p x * p y ) ) ; i += ( num - p xy ) * math . log ( ( num - p xy ) / ( ( num - p x ) * ( num - p y ) ) ) ; return i ; }	i - mutual information . < br > note binary only.
public result do comparison test ( properties properties ) throws exception { final long timeout = long . parse long ( properties . get property ( test options . timeout ) ) ; final int nclients = integer . parse int ( properties . get property ( test options . nclients ) ) ; final int ntrials = integer . parse int ( properties . get property ( test options . ntrials ) ) ; final int key len = integer . parse int ( properties . get property ( test options . keylen ) ) ; final int nops = integer . parse int ( properties . get property ( test options . nops ) ) ; final double insert rate = integer . parse int ( properties . get property ( test options . insert rate ) ) ; final int nindices = integer . parse int ( properties . get property ( test options . nindices ) ) ; final boolean test correctness = boolean . parse boolean ( properties . get property ( test options . test correctness ) ) ; result result = do concurrent client test ( client , nclients , timeout , ntrials , key len , nops , insert rate , nindices , test correctness ) ; return result ; }	setup and run a test .
public void test get scale ( ) throws sql { try { int scale = num ; string create table = str + str + scale + str ; string insert = str ; string select = str ; statement st = conn . create statement ( ) ; st . execute update ( create table ) ; st . execute update ( insert ) ; rs = st . execute query ( select ) ; result set meta data rsmd2 = rs . get meta data ( ) ; assert not null ( rsmd2 ) ; assert equals ( scale , rsmd2 . get scale ( num ) ) ; assert true ( rsmd2 . get scale ( num ) > num ) ; assert true ( rsmd2 . get scale ( num ) > num ) ; try { rsmd . get scale ( num ) ; fail ( str ) ; } catch ( sql e ) { } try { rsmd . get scale ( num ) ; fail ( str ) ; } catch ( sql e ) { } try { conn . close ( ) ; rsmd . get scale ( num ) ; fail ( str ) ; } catch ( sql e ) { } } finally { st . cancel ( ) ; } }	always returns 0 , exception tests fail no positive test case for black - box test possible : no default value indicated . not supported.
static string value to string ( object value , int indent factor , int indent ) { if ( value == null || value . equals ( null ) ) { return str ; } try { if ( value instanceof string ) { return quote ( ( string ) value ) ; } } catch ( exception e ) { } if ( value instanceof float || value instanceof double || value instanceof byte || value instanceof short || value instanceof integer || value instanceof long ) { return number to string ( value ) ; } if ( value instanceof boolean ) { return value . to string ( ) ; } if ( value instanceof map ) { return print ( ( map ) value , indent factor , indent ) ; } if ( value instanceof list ) { return print ( ( list ) value , indent factor , indent ) ; } return quote ( value . to string ( ) ) ; }	make a prettyprinted json text of an object value.
public static boolean is retained at runtime ( class < ? extends annotation > annotation type ) { retention retention = annotation type . get annotation ( retention . class ) ; return retention != null && retention . value ( ) == retention policy . runtime ; }	returns true if the given annotation is retained at runtime .
public void test process msg5 ( ) { byte [ ] pdu = create pdu ( num ) ; int header len = pdu . length - ( m gsm header . length + m user data header . length + m message body . length ) ; int pdu type = num ; int tran id = num ; string original package name = m package name ; string original class name = m class name ; try { m class name = str ; i iwapman = get interface ( ) ; iwapman . add package ( integer . to string ( m app id value ) , integer . to string ( m content type value ) , m package name , m class name , wap push manager params . app type activity , bool , bool ) ; assert true ( ( iwapman . process message ( integer . to string ( m app id value ) , integer . to string ( m content type value ) , create intent ( pdu type , tran id ) ) & wap push manager params . message handled ) == wap push manager params . message handled ) ; iwapman . delete package ( integer . to string ( m app id value ) , integer . to string ( m content type value ) , m package name , m class name ) ; } catch ( remote exception e ) { assert true ( bool ) ; } m package name = original package name ; m class name = original class name ; }	message processing test , send invalid sms data.
public void add class path ( string classpath ) { char sep = caucho util . get path separator char ( ) ; int head = num ; int tail = num ; while ( head < classpath . length ( ) ) { tail = classpath . index of ( sep , head ) ; string segment = null ; if ( tail < num ) { segment = classpath . substring ( head ) ; head = classpath . length ( ) ; } else { segment = classpath . substring ( head , tail ) ; head = tail + num ; } if ( segment . equals ( str ) ) continue ; else if ( segment . ends with ( str ) || segment . ends with ( str ) ) add merge path ( jar path . create ( vfs old . lookup ( segment ) ) ) ; else add merge path ( vfs old . lookup ( segment ) ) ; } }	adds the classpath for the loader as paths in the mergepath .
@ singleton public static synchronized void load directories ( string first option ) throws invalid config exception { if ( user id directories == null ) { user id directories = new tree map < string , string > ( ) ; user id directories . put ( str , ( first option == null ) ? str : first option ) ; properties properties = directories properties ( ) ; for ( map . entry < object , object > entry : properties . entry set ( ) ) { string key = string utils . trim ( ( string ) entry . get key ( ) ) ; string value = string utils . trim ( ( string ) entry . get value ( ) ) ; if ( key != null && value != null ) { user id directories . put ( key , value ) ; } else { string error = directories propfile path + str ; log . error ( error ) ; throw new invalid config exception ( invalid config exception . type . invalid properties file , error ) ; } } if ( ( user id directories . size ( ) - num ) == num ) { string error = str + directories propfile path + str ; log . error ( error ) ; throw new invalid config exception ( invalid config exception . type . invalid properties file , error ) ; } } }	load directories map used to populate select on basic metadata page.
public static individuum null individuum ( int dim ) { short [ ] gene = new short [ dim ] ; arrays . fill ( gene , dont care ) ; return new individuum ( num , gene ) ; }	create a " null " individuum ( full space ) .
public list < class < ? > > find all classes ( string uri ) throws io , class not found exception { list < class < ? > > classes = new array list < > ( ) ; list < string > strings = find all strings ( uri ) ; for ( string class name : strings ) { class < ? > clazz = class loader . load class ( class name ) ; classes . add ( clazz ) ; } return classes ; }	executes findallstrings assuming the strings are the names of a classes that should be loaded and returned.
private boolean is slavo germanic ( string value ) { return value . index of ( str ) > - num || value . index of ( str ) > - num || value . index of ( str ) > - num || value . index of ( str ) > - num ; }	determines whether or not a value is of slavo - germanic orgin.
public void shuffle inventory ( @ nonnull i inv , @ nonnull random random ) { final list < item stack > list = get inventory list ( inv ) ; collections . shuffle ( list , random ) ; for ( int i = num ; i < inv . get size inventory ( ) ; ++ i ) { inv . set inventory slot contents ( i , list . get ( i ) ) ; } }	shuffles all items in the inventory.
@ override public string format ( double value , int format number ) { if ( format number % num == num ) { return format . format ( value ) ; } else { return null ; } }	returns the formatted value.
public static string to lower case ( string string ) { boolean changed = bool ; char [ ] chars = string . to char array ( ) ; for ( int i = num ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( str <= ch && str >= ch ) { changed = bool ; chars [ i ] = ( char ) ( ch - str + str ) ; } } if ( changed ) { return new string ( chars ) ; } return string ; }	a locale independent version of tolowercase .
public void run asserts ( list < step > list , int size , boolean need assignee ) { assert equals ( size , list . size ( ) ) ; for ( int i = num ; i < size ; i ++ ) { run asserts ( list . get ( i ) , i , need assignee ) ; } }	assert a step - list with getalistofsamplesteps ( size ).
public static boolean register transform ( final string transform uri ) { final boolean added = transforms . add ( transform uri ) ; return added ; }	this method allows to register a transformation .
public synchronized void co exit ( int this coroutine ) { m active i . clear ( this coroutine ) ; m next coroutine = nobody ; notify ( ) ; }	terminate this entire set of coroutines.
public void shrink ( ) { if ( c . length == length ) { return ; } char [ ] newc = new char [ length ] ; system . arraycopy ( c , num , newc , num , length ) ; c = newc ; }	shrinks the capacity of the buffer to the current length if necessary . this method involves copying the data once !.
public and ( condition ... conditions ) { reject . if null ( conditions ) ; this . conditions = arrays . as list ( conditions ) ; }	creates a new logical and condition with the provided sub - conditions .
private void drop downstream to ( long absolute position ) { int relative position = ( int ) ( absolute position - total bytes dropped ) ; int allocation index = relative position / allocation length ; for ( int i = num ; i < allocation index ; i ++ ) { allocator . release ( data queue . remove ( ) ) ; total bytes dropped += allocation length ; } }	discard any allocations that hold data prior to the specified absolute position , returning them to the allocator .
public hop impl ( string host name , int port number , string trans ) { host = host name ; if ( host . index of ( str ) >= num ) if ( host . index of ( str ) < num ) host = str + host + str ; port = port number ; transport = trans ; }	create new hop given host , port and transport .
private void update controls ( ) { spinner difficulty = ( spinner ) find view by id ( r . id . spinner difficulty level ) ; difficulty . set selection ( game activity . get difficulty index ( ) ) ; button resume = ( button ) find view by id ( r . id . button resume game ) ; resume . set enabled ( game activity . can resume from save ( ) ) ; check box never lose ball = ( check box ) find view by id ( r . id . checkbox never lose ball ) ; never lose ball . set checked ( game activity . get never lose ball ( ) ) ; check box sound effects enabled = ( check box ) find view by id ( r . id . checkbox sound effects enabled ) ; sound effects enabled . set checked ( game activity . get sound effects enabled ( ) ) ; text view high score = ( text view ) find view by id ( r . id . text high score ) ; high score . set text ( string . value of ( m high score ) ) ; }	sets the state of the ui controls to match our internal state .
public static void write ( output stream out , int c ) { if ( out == null ) { throw new illegal argument exception ( str ) ; } try { out . write ( c ) ; } catch ( io e ) { throw new runtime exception ( e . get message ( ) , e ) ; } }	write a ascii code to the output stream.
public void message ( loco net message m ) { if ( m . get num data elements ( ) != num ) { return ; } int b1 = m . get element ( num ) & num ; int b2 = m . get element ( num ) & num ; int b3 = m . get element ( num ) & num ; int b4 = m . get element ( num ) & num ; if ( ( b1 == num ) && ( ( b2 == num ) || ( b2 == num ) || ( b2 == num ) ) && ( b3 == num ) ) { id box . set selected index ( b4 + num ) ; } }	process the incoming message , see if it is a panel response , and if so parse the loconet id.
public void call ( ) throws exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next double ( ) <= insert rate ) { for ( int i = num ; i < nops ; i ++ ) { keys [ i ] = next key ( ) ; vals [ i ] = new byte [ num ] ; r . next bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( num , nops , keys , vals , batch insert constructor . return no values , null ) ; if ( ground truth != null ) { ground truth . submit ( num , nops , keys , vals , batch insert constructor . return no values , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = num ; i < nops ; i ++ ) { keys [ i ] = next key ( ) ; } lock . lock ( ) ; try { ndx . submit ( num , nops , keys , null , batch remove constructor . return mutation count , null ) ; if ( ground truth != null ) { ground truth . submit ( num , nops , keys , null , batch remove constructor . return mutation count , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }	executes a random batch operation with keys presented in sorted order.
public boolean allow multiple additions ( string system name ) { return bool ; }	a method that determines if it is possible to add a range of lights in numerical order eg 11 thru 18 , primarily used to show / not show the add range box in the add light window.
protected static boolean is object class present ( set object classes , string object class ) { if ( object classes != null && ! object classes . is empty ( ) ) { iterator itr = object classes . iterator ( ) ; while ( itr . has next ( ) ) { string service oc = ( string ) itr . next ( ) ; if ( service oc . equals ignore case ( object class ) ) { return bool ; } } } return bool ; }	method to compare all the object classes in the set with the specfied object class.
public void write field ( final string name , final int value ) throws java . io . io { write field ( name , integer . to string ( value ) ) ; }	writes an int field value .
public static double ln factorial ( int x ) { if ( x < num ) throw new illegal argument exception ( str + x ) ; else if ( x > num ) return ln gamma ( x + num ) ; else { int l = factorials buffer . size ( ) ; for ( int i = l ; i <= x ; i ++ ) { factorials buffer . add ( log ( i ) + factorials buffer . get ( i - num ) ) ; } return factorials buffer . get ( x ) ; } }	get the log of the factorial of a number.
public void sync ( ) throws io { try { latch . await ( ) ; } catch ( interrupted exception e ) { thread . interrupted ( ) ; throw io . create ( e ) ; } fail on error ( ) ; }	waits for a response to some pending operation .
public int add and get ( t obj , int delta ) { for ( ; ; ) { int current = get ( obj ) ; int next = current + delta ; if ( compare and set ( obj , current , next ) ) return next ; } }	atomically adds the given value to the current value of the field of the given object managed by this updater .
public static void close silently ( closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( runtime exception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } }	closes a specified closeable , suppressing any checked exceptions.
public synchronized boolean append ( final byte [ ] data ) { if ( data == null ) { if ( cfg . debug ) { check . log ( tag + str ) ; } return bool ; } file output stream fout = null ; output stream out = null ; try { fout = new file output stream ( file , bool ) ; out = new buffered output stream ( fout , data . length ) ; out . write ( data ) ; out . flush ( ) ; } catch ( final exception ex ) { return bool ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( final io e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + str + e . to string ( ) ) ; } } } if ( out != null ) { try { out . close ( ) ; } catch ( final io e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + str + e . to string ( ) ) ; } } } } return bool ; }	append some data to the file .
@ suppress warnings ( { str , str } ) private void notify list listeners ( ) { if ( ! list listeners . is empty ( ) ) { list temp = new array list ( sensor data objects . values ( ) ) ; temp . add all ( object storages . values ( ) ) ; for ( list listener < ? > list listener : list listeners ) { list listener . content changed ( temp ) ; } } }	notify all registered listeners that a change occurred in the lists .
public static inet address int to inet address ( int host address ) { if ( host address == num ) return null ; byte [ ] address bytes = { ( byte ) ( num & host address ) , ( byte ) ( num & ( host address > > num ) ) , ( byte ) ( num & ( host address > > num ) ) , ( byte ) ( num & ( host address > > num ) ) } ; try { return inet address . get by address ( address bytes ) ; } catch ( unknown host exception e ) { throw new assertion error ( ) ; } }	convert a ipv4 address from an integer to an inetaddress .
private aftp action open ( ) throws io , page exception { required ( str , server ) ; required ( str , username ) ; required ( str , password ) ; aftp client = get client ( ) ; write cfftp ( client ) ; return client ; }	opens a ftp connection.
private static char [ ] zz unpack c ( string packed ) { int size = num ; for ( int i = num , length = packed . length ( ) ; i < length ; i += num ) { size += packed . char at ( i ) ; } char [ ] map = new char [ size ] ; int i = num ; int j = num ; while ( i < packed . length ( ) ) { int count = packed . char at ( i ++ ) ; char value = packed . char at ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > num ) ; } return map ; }	unpacks the compressed character translation table .
public v put if absent ( final k k , final v v ) { final weak reference < v > ref = new weak ref ( k , v , reference queue ) ; final weak reference < v > old ref = map . put if absent ( k , ref ) ; final v old val = old ref == null ? null : old ref . get ( ) ; if ( old ref != null && old val == null ) { if ( map . replace ( k , old ref , ref ) ) { if ( queue . add ( v ) && debug ) { log . debug ( str + k + str + v ) ; } did update ( k , ref , old ref ) ; return null ; } } if ( old val == null ) { if ( queue . add ( v ) && debug ) { log . debug ( str + k + str + v ) ; } did update ( k , ref , null ) ; return null ; } return old val ; }	adds the key - value mapping to the cache iff there is no entry for that key.
public int diff common suffix ( string text1 , string text2 ) { int text1 length = text1 . length ( ) ; int text2 length = text2 . length ( ) ; int n = math . min ( text1 length , text2 length ) ; for ( int i = num ; i <= n ; i ++ ) { if ( text1 . char at ( text1 length - i ) != text2 . char at ( text2 length - i ) ) { return i - num ; } } return n ; }	determine the common suffix of two strings.
public void close ( ) { if ( element layers != null ) { element layers . clear ( ) ; element layers = null ; } input source = null ; cur listener = null ; }	closes parser and frees all resources .
public void start ( ) { if ( monitor thread != null ) { if ( ! monitor thread . is alive ( ) ) { start monitor thread ( ) ; } else { log . error ( str ) ; } } else { start monitor thread ( ) ; } }	starts the publishing monitor once and only once .
@ hle @ hle ( nid = num , version = num ) public int sce usb cam poll read video frame end ( ) { if ( jpeg buffer == null || jpeg buffer . is null ( ) ) { return sce kernel errors . error usbcam no read on video frame ; } if ( current video frame count <= last video frame count ) { if ( log . is debug enabled ( ) ) { log . debug ( string . format ( str , current video frame count , last video frame count ) ) ; } return sce kernel errors . error usbcam no video frame available ; } return write current video image ( jpeg buffer , jpeg buffer size ) ; }	polls the status of video frame read completion .
public void scale ( int factor ) { if ( m icon != null ) { remove all ( ) ; image pic = m icon . get image ( ) ; int width = m icon . get icon width ( ) ; int height = m icon . get icon height ( ) ; int reduction = width / factor ; width -= reduction ; height -= reduction ; pic = pic . get scaled instance ( width , height , image . scale smooth ) ; m icon = new image icon ( pic ) ; m visual label = new j ( m icon ) ; add ( m visual label , border layout . center ) ; dimension d = m visual label . get preferred size ( ) ; dimension d2 = new dimension ( ( int ) d . get width ( ) + num , ( int ) d . get height ( ) + num ) ; set minimum size ( d2 ) ; set preferred size ( d2 ) ; set maximum size ( d2 ) ; } }	reduce this beanvisual ' s icon size by the given factor.
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; try { init from name ( get name ( ) ) ; } catch ( runtime exception e ) { if ( e instanceof null pointer exception || e instanceof illegal argument exception ) { invalid object exception ee = new invalid object exception ( e . get message ( ) ) ; ee . init cause ( e ) ; throw ee ; } throw e ; } }	reconstitutes contained permissions based on the information in the target name .
public string to lower camel ( ) { return to camel ( case format . lower camel ) ; }	returns the identifier in lower - camel format .
public e poll ( ) { if ( is empty ( ) ) { return null ; } e result = elements [ num ] ; remove at ( num ) ; return result ; }	gets and removes the head of the queue .
public movie set add action ( boolean with title ) { if ( with title ) { put value ( name , bundle . get string ( str ) ) ; } put value ( large icon key , icon manager . list add ) ; put value ( small icon , icon manager . list add ) ; put value ( short description , bundle . get string ( str ) ) ; }	instantiates a new adds the movie set action .
protected void create registry ( int port ) { if ( rmi registry == null ) { try { if ( logger . is debug enabled ( ) ) { logger . debug ( str + port ) ; } rmi registry = locate registry . create registry ( port ) ; } catch ( throwable e ) { throw new server runtime exception ( str + port , e ) ; } } }	starts the rmi registry .
public void poll ( final udp socket statistics handler handler ) { this . statistics handler = handler ; try { file loader . load ( ) ; final byte buffer buffer = file loader . get buffer ( ) ; line parser . reset ( ) ; line parser . handle token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics handler = null ; } monitored sockets . purge entries older than ( update count ) ; update count ++ ; }	read from monitored file , report any changed values for monitored socket statistics.
private void reset internal ( ) { m transition state = transition none ; arrays . fill ( m start alphas , num ) ; m start alphas [ num ] = num ; arrays . fill ( m alphas , num ) ; m alphas [ num ] = num ; arrays . fill ( m is layer on , bool ) ; m is layer on [ num ] = bool ; }	resets internal state to the initial state .
void fix white space ( ) { final int index = m output builder . length ( ) - num ; if ( index >= num ) { final char last character = m output builder . char at ( index ) ; if ( ! character . is whitespace ( last character ) ) { m output builder . append ( str ) ; } } }	ensure the output string has a character of whitespace before adding another word .
public void handle tbl request handler list href dup action request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; scsoap vb = ( scsoap ) get view bean ( scsoap . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; int idx = integer . parse int ( ( string ) get display field value ( tbl request handler list href dup action ) ) ; vb . set dup index ( idx ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles duplicate request handler request .
public boolean expired ( long expire ) { long mod = time . get time ( ) ; long now = system . current time millis ( ) ; long diff = now - mod ; if ( diff > expire && get source ( ) != network ) { return bool ; } return bool ; }	test if the response is expired against current time , given the expire duration in milliseconds.
@ override public void accept ( final method visitor mv ) { switch ( type ) { case opcodes . f new : case opcodes . f full : mv . visit frame ( type , local . size ( ) , as array ( local ) , stack . size ( ) , as array ( stack ) ) ; break ; case opcodes . f append : mv . visit frame ( type , local . size ( ) , as array ( local ) , num , null ) ; break ; case opcodes . f chop : mv . visit frame ( type , local . size ( ) , null , num , null ) ; break ; case opcodes . f same : mv . visit frame ( type , num , null , num , null ) ; break ; case opcodes . f sam : mv . visit frame ( type , num , null , num , as array ( stack ) ) ; break ; } }	makes the given visitor visit this stack map frame .
private static native string [ ] special properties ( ) ;	returns an array of " key = value " strings containing information not otherwise easily available , such as # defined library versions .
private void handle done query ( final uuid query id , final future < void > done query future ) { try { done query future . get ( ) ; throw new interrupted exception ( ) ; } catch ( interrupted exception e ) { throw new runtime exception ( e ) ; } catch ( execution exception e ) { throw new runtime exception ( e ) ; } }	handle a recently halted query by throwing an appropriate exception .
synchronized public static list < string > former identities ( ) { if ( instance == null ) { instance = new node identity ( ) ; log . info ( str , instance . get identity ( ) ) ; } return instance . get former identities ( ) ; }	if network hardware on a node was replaced , the identity will change .
public final double do operation ( ) { final int dim = parameter . get dimension ( ) ; double sum = num ; if ( uses prior on sum ) { for ( int i = num ; i < dim ; i ++ ) { sum += math . abs ( parameter . get parameter value ( i ) ) ; } } final int pos = math utils . next int ( dim ) ; final int value = ( int ) parameter . get parameter value ( pos ) ; double logq = num ; if ( value == num ) { logq = bit flip helper . flip zero ( pos , dim , sum ) ; } else if ( value == num ) { logq = bit flip helper . flip one ( pos , dim , sum ) ; } else if ( value == - num ) { logq = bit flip helper . flip neg one ( pos , dim , sum ) ; } else { throw new runtime exception ( str ) ; } if ( ! uses prior on sum ) { logq = num ; } return logq ; }	change the parameter and return the hastings ratio.
@ override public void chart progress ( chart progress event event ) { }	receives notification of a chart progress event .
@ override public japanese date date epoch day ( long epoch day ) { return new japanese date ( local date . of epoch day ( epoch day ) ) ; }	obtains a local date in the japanese calendar system from the epoch - day .
private void check empty ( ) { for ( int i = num ; i < grid count ( ) ; i ++ ) { ignite cache < integer , string > cache = jcache ( i ) ; assert equals ( num , cache . local size ( ) ) ; assert equals ( num , cache . size ( ) ) ; for ( cache peek mode peek mode : cache peek mode . values ( ) ) { assert equals ( num , cache . local size ( peek mode ) ) ; assert equals ( num , cache . size ( peek mode ) ) ; } } check primary size ( num ) ; }	checks size is zero .
node < k , v > find ( int h , object k ) { node < k , v > e = this ; if ( k != null ) { do { k ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ek != null && my hashing strategy . equals ( ( k ) k , ek ) ) ) { return e ; } } while ( ( e = e . next ) != null ) ; } return null ; }	virtualized support for map.
public static void add language ( language language ) { if ( language == null ) return ; array list < language > list = new array list < language > ( arrays . as list ( s languages ) ) ; list . add ( language ) ; s languages = new language [ list . size ( ) ] ; list . to array ( s languages ) ; }	add language to supported languages.
public static int binary search ceil ( long [ ] a , long key , boolean inclusive , boolean stay in bounds ) { int index = arrays . binary search ( a , key ) ; index = index < num ? ~ index : ( inclusive ? index : ( index + num ) ) ; return stay in bounds ? math . min ( a . length - num , index ) : index ; }	returns the index of the smallest value in an array that is greater than ( or optionally equal to ) a specified key.
protected void do add user ( user user ) throws users repository exception { connection conn = null ; prepared statement add user statement = null ; try { conn = open connection ( ) ; add user statement = conn . prepare statement ( m insert user sql ) ; set user for insert statement ( user , add user statement ) ; add user statement . execute ( ) ; } catch ( sql sql exc ) { sql exc . print stack trace ( ) ; throw new users repository exception ( str , sql exc ) ; } finally { the jdbc . close jdbc ( add user statement ) ; the jdbc . close jdbc ( conn ) ; } }	adds a user to the underlying repository.
void block mix128 ( long k1 , long k2 ) { h1 ^= mix k1 ( k1 ) ; h1 = long . rotate left ( h1 , num ) ; h1 += h2 ; h1 = ( h1 * num ) + num ; h2 ^= mix k2 ( k2 ) ; h2 = long . rotate left ( h2 , num ) ; h2 += h1 ; h2 = ( h2 * num ) + num ; }	block mix ( 128 - bit block ) of input key to internal hash state .
private void register host ( sim event ev ) { network host hs = ( network host ) ev . get data ( ) ; hostlist . put ( hs . get id ( ) , hs ) ; }	register a host that is connected to the switch .
@ override public void reconcile flow ( of ofm rc in , event priority priority ) { if ( ofm rc in == null ) return ; of my ofm rc = new of ( ofm rc in ) ; flow queue . offer ( my ofm rc , priority ) ; ctr flow reconcile request . increment ( ) ; date curr time = new date ( ) ; long delay = num ; if ( curr time . after ( new date ( last reconcile time . get time ( ) + num ) ) ) { delay = num ; } else { delay = flow reconcile delay millisec ; } flow reconcile task . reschedule ( delay , time unit . milliseconds ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str , my ofm rc . to string ( ) , flow queue . size ( ) ) ; } }	add to - be - reconciled flow to the queue .
void create jar ( file output stream out stream , map < string , byte [ ] > all ) throws io { jar output stream jar = new jar output stream ( out stream ) ; for ( entry < string , byte [ ] > entry : all . entry set ( ) ) { string name = entry . get key ( ) ; jar entry jar entry = new jar entry ( name ) ; jar . put next entry ( jar entry ) ; jar . write ( entry . get value ( ) ) ; jar . close entry ( ) ; } jar . flush ( ) ; jar . close ( ) ; }	writes the jar file .
public void append cell ( int value ) { append cell ( string . value of ( value ) ) ; }	appends a new cell to the current row containing the provided integer value .
public void expect server proxy failed ( ) { expected api calls . add ( new api call ( server proxy failed ) ) ; }	expect a server proxy failure .
public object remove ( final object key ) { return parameters . remove ( key ) ; }	remove a key from the parameter set .
@ override public void recalculate attribute statistics ( attribute attribute ) { list < attribute > all attributes = new array list < attribute > ( ) ; all attributes . add ( attribute ) ; recalculate attribute statistics ( all attributes ) ; }	recalculate the attribute statistics of the given attribute .
public boolean is empty ( ) { return children . is empty ( ) ; }	returns whether this group has any child layers .
public void insert column ( int column index , column spec column spec ) { if ( column index < num || column index > get column count ( ) ) { throw new index out of bounds exception ( str + column index + str + get column count ( ) + str ) ; } col specs . add ( column index - num , column spec ) ; shift components horizontally ( column index , bool ) ; adjust group indices ( col group indices , column index , bool ) ; }	inserts the specified column at the specified position.
public int match ( string s ) { string rep = new string ( data chars , num , n data chars ) ; return rep . index of ( s ) ; }	returns the index of string s in the reply.
private int calc rhs size ( production production ) { int result = production . get rhs ( ) ; if ( production . get lhs ( ) instanceof lh ) { final lh aux action = ( lh ) production . get lhs ( ) ; result += aux action . num preceding symbols not epsilon ; } return result ; }	todo relevant for ll - parser ? ? ?.
private bsh method load scripted command ( input stream in , string name , class [ ] arg types , string resource path , interpreter interpreter ) throws util eval error { try { interpreter . eval ( new input stream reader ( in ) , this , resource path ) ; } catch ( eval error e ) { interpreter . debug ( e . to string ( ) ) ; throw new util eval error ( str + e . get message ( ) ) ; } bsh method meth = get method ( name , arg types ) ; return meth ; }	load a command script from the input stream and find the bshmethod in the target namespace .
public static object invoke compiled command ( class command class , object [ ] args , interpreter interpreter , call stack callstack ) throws util eval error { object [ ] invoke args = new object [ args . length + num ] ; invoke args [ num ] = interpreter ; invoke args [ num ] = callstack ; system . arraycopy ( args , num , invoke args , num , args . length ) ; bsh class manager bcm = interpreter . get class manager ( ) ; try { return reflect . invoke static method ( bcm , command class , str , invoke args ) ; } catch ( invocation target exception e ) { throw new util eval error ( str + e . get target exception ( ) ) ; } catch ( reflect error e ) { throw new util eval error ( str + e ) ; } }	a command may be implemented as a compiled java class containing one or more static invoke ( ) methods of the correct signature.
private static void compute probabilities multinomial logistic ( double [ ] responses ) { double [ ] r = responses . clone ( ) ; for ( int j = num ; j < r . length ; j ++ ) { double sum = num ; boolean overflow = bool ; for ( int k = num ; k < r . length ; k ++ ) { if ( r [ k ] - r [ j ] > num ) { overflow = bool ; break ; } sum += math . exp ( r [ k ] - r [ j ] ) ; } if ( overflow ) { responses [ j ] = num ; } else { responses [ j ] = num / sum ; } } }	computes probabilities for the multinomial logistic model type .
public int add client external ( sso token , map props ) throws am { synchronized ( external client data ) { ext cap instance . add client ( token , props ) ; string ct = get client type ( props ) ; map e map = merge with parent ( props ) ; external client data . put ( ct , e map ) ; add to indexes ( ct , e map ) ; } return num ; }	wrapper methods for add / modify / remove apis in amclientcapdata.
public static void delete ( file resource to delete ) throws io { if ( resource to delete . exists ( ) ) { delete ( resource to delete . to path ( ) ) ; } }	deletes a single file or recursively a folder with its content .
private void add export remove volume steps ( workflow workflow , protection system rp system , uri export group id , list < uri > bo i ) throws internal exception { export group export group = db client . query object ( export group . class , export group id ) ; string export step = workflow . create step id ( ) ; init task status ( export group , export step , operation . status . pending , str ) ; map < uri , list < uri > > device to block objects = new hash map < uri , list < uri > > ( ) ; for ( uri snapshot id : bo i ) { block snapshot snapshot = db client . query object ( block snapshot . class , snapshot id ) ; list < block object > objects to remove = get export objects for bookmark ( snapshot ) ; for ( block object block object : objects to remove ) { list < uri > block objects = device to block objects . get ( block object . get storage controller ( ) ) ; if ( block objects == null ) { block objects = new array list < uri > ( ) ; device to block objects . put ( block object . get storage controller ( ) , block objects ) ; } block objects . add ( block object . get id ( ) ) ; } } for ( map . entry < uri , list < uri > > device entry : device to block objects . entry set ( ) ) { log . info ( string . format ( str , export group . get id ( ) , device entry . get key ( ) , device entry . get value ( ) ) ) ; export wf utils . generate export group remove volumes ( workflow , step export remove snapshot , step export group disable , device entry . get key ( ) , export group id , device entry . get value ( ) ) ; } log . info ( string . format ( str , export group . get id ( ) ) ) ; }	add the export remove volume step to the workflow.
public double inference by gibbs sampling ( document d , double [ ] pzd , int num burn in , int num sampling ) { arrays . fill ( pzd , num ) ; double loglikelihood = num ; for ( int i = num ; i < num burn in + num sampling ; i ++ ) { loglikelihood += gibbs sampling ( d ) ; if ( i >= num burn in ) { for ( int topic : d . topics ) { if ( topic != no topic ) pzd [ topic ] ++ ; } } else { loglikelihood = num ; } } normalize ( pzd , alpha ) ; return loglikelihood / num sampling ; }	inference by gibbs sampling .
public static void remove ( string dbg token ) { dbg table . remove ( dbg token ) ; }	rremoves a debug token.
private void adjust min pref for spanning comps ( dim constraint [ ] specs , float [ ] def push , flow size spec fss , array list < linked dim group > [ ] groups lists ) { for ( int r = groups lists . length - num ; r >= num ; r -- ) { array list < linked dim group > groups = groups lists [ r ] ; for ( linked dim group group : groups ) { if ( group . span == num ) { continue ; } int [ ] sizes = group . get min pref max ( ) ; for ( int s = layout util . min ; s <= layout util . pref ; s ++ ) { int c size = sizes [ s ] ; if ( c size == layout util . not set ) { continue ; } int row size = num ; int s ix = ( r << num ) + num ; int len = math . min ( ( group . span << num ) , fss . sizes . length - s ix ) - num ; for ( int j = s ix ; j < s ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != layout util . not set ) { row size += sz ; } } if ( row size < c size && len > num ) { for ( int eagerness = num , new row size = num ; eagerness < num && new row size < c size ; eagerness ++ ) { new row size = fss . expand sizes ( specs , def push , c size , s ix , len , s , eagerness ) ; } } } } } }	adjust min / pref size for columns ( or rows ) that has components that spans multiple columns ( or rows ) .
public void parse file ( chat event parse listener listener ) { synchronized ( this ) { @ suppress warnings ( str ) long start time = system . current time millis ( ) ; buffered reader reader = null ; try { reader = new buffered reader ( new file reader ( path to file ) ) ; string current line = reader . read line ( ) ; while ( current line != null ) { try { chat event event = chat event utils . deserialize chat event ( current line ) ; if ( ! listener . on new event parsed ( event ) ) { break ; } } catch ( throwable t ) { log . warn ( str + current line + str , t ) ; } current line = reader . read line ( ) ; } listener . on parse completed ( ) ; } catch ( io ioe ) { throw new runtime exception ( ioe ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( throwable t ) { } } } } }	parses the chatlogger and invokes the listener on each chat event encountered .
private coder result escape sequence other ( short new byte ) { if ( new byte >= num && new byte <= num ) { state = escape sequence other ; version sequence allowed = bool ; queue . write ( new byte ) ; } else if ( new byte >= num && new byte <= num ) { state = normal bytes ; version sequence allowed = bool ; queue . reset ( ) ; } else { return malformed input ( err escbyte ) ; } return coder result . underflow ; }	test for unknown , but valid , escape sequences .
@ nullable public static network parameters from id ( string id ) { if ( id . equals ( id mainnet ) ) { return main net params . get ( ) ; } else if ( id . equals ( id testnet ) ) { return test net3 params . get ( ) ; } else if ( id . equals ( id unittestnet ) ) { return unit test params . get ( ) ; } else if ( id . equals ( id regtest ) ) { return reg test params . get ( ) ; } else if ( id . equals ( id alphanet ) ) { return alpha net params . get ( ) ; } else { return null ; } }	returns the network parameters for the given string id or null if not recognized .
public void add certificates and cr ( cert store cert store ) throws cert store exception , cms { certs . add all ( cms . get certificates from store ( cert store ) ) ; crls . add all ( cms . get cr ( cert store ) ) ; }	add the certificates and crls contained in the given certstore to the pool that will be included in the encoded signature block.
protected abstract void store body ( data output stream dos ) throws io ;	writes the body of this attribute in an attribute - type dependent way ; see jvms7 4.
private double find angle ( point origin point , point target point ) { int x1 = origin point . x ; int y1 = origin point . y ; int x2 = target point . x ; int y2 = target point . y ; double angle = num ; double offset = num ; double side a = x2 - x1 ; double side b = num ; if ( y1 >= y2 ) { side b = y1 - y2 ; offset = math . to radians ( - num ) ; } else { side b = - ( y2 - y1 ) ; offset = math . to radians ( num ) ; } if ( side b == num ) { return angle ; } angle = math . atan ( side a / side b ) ; return angle + offset ; }	uses trig to find angle of the arrow.
public void append whitespace ( appendable writer ) throws io { writer . append ( white space ) ; }	helper method used to append whitespace characters to the end of each rendered element .
void clear resource index ( string resource type name ) { set resource types = new hash set ( ) ; resource types . add all ( resource indices . key set ( ) ) ; iterator iter = resource types . iterator ( ) ; while ( iter . has next ( ) ) { string resource type = ( string ) iter . next ( ) ; if ( resource type . equals ignore case ( resource type name ) ) { resource indices . remove ( resource type ) ; break ; } } }	clears resourceindex of the given resource type name from the local cache.
@ override public byte [ ] bitcoin serialize ( ) { if ( header bytes valid && transaction bytes valid ) { preconditions . check not null ( payload , str ) ; if ( length == payload . length ) { return payload ; } else { byte [ ] buf = new byte [ length ] ; system . arraycopy ( payload , offset , buf , num , length ) ; return buf ; } } byte array output stream stream = new unsafe byte array output stream ( length == unknown length ? header size + guess transactions length ( ) : length ) ; try { write header ( stream ) ; write transactions ( stream ) ; } catch ( io e ) { } return stream . to byte array ( ) ; }	special handling to check if we have a valid byte array for both header and transactions.
@ override public list < period > generate rolling periods ( date time unit date time unit ) { calendar calendar = get calendar ( ) ; list < period > periods = lists . new array list ( ) ; date time unit = calendar . minus days ( date time unit , calendar . weekday ( date time unit ) - num ) ; date time unit = calendar . minus days ( date time unit , num ) ; for ( int i = num ; i < num ; i ++ ) { periods . add ( create period ( date time unit , calendar ) ) ; date time unit = calendar . plus weeks ( date time unit , num ) ; } return periods ; }	generates the last 52 weeks where the last one is the week which the given date is inside .
@ override public set < string > vertex match pattern labels ( ) { return collections . empty set ( ) ; }	gets the set of labels required at the time of matching the vertex in a cypher match pattern.
public boolean reset unread counts ( int a section ) { boolean ret code = bool ; array list < room summary > summaries list = m summary list by group position . get ( a section ) ; if ( null != summaries list ) { for ( int summary idx = num ; summary idx < summaries list . size ( ) ; summary idx ++ ) { ret code |= reset unread count ( a section , summary idx ) ; } } else { log . w ( dbg class name , str + a section + str ) ; } return ret code ; }	reset the count of the unread messages of the section whose index is given in asection.
public static void add category ( lexicon category category ) { categories . add ( category ) ; }	adds a category to the list of registered categories to appear in the lexicon .
private static int v ( jni env , int obj jref , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , null , bool ) ; return env . push jni ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callnonvirtualobjectmethodv : invoke a virtual method that returns an object.
private tuple < message , connection > try other messages ( ) { list < tuple < message , connection > > messages = new array list < tuple < message , connection > > ( ) ; collection < message > msg collection = get message collection ( ) ; for ( connection con : get connections ( ) ) { dtn other = con . get other node ( get host ( ) ) ; prophet v2 router oth router = ( prophet v2 router ) other . get router ( ) ; if ( oth router . is transferring ( ) ) { continue ; } for ( message m : msg collection ) { if ( oth router . has message ( m . get id ( ) ) ) { continue ; } if ( ( oth router . get pred for ( m . get to ( ) ) >= get pred for ( m . get to ( ) ) ) ) { messages . add ( new tuple < message , connection > ( m , con ) ) ; } } } if ( messages . size ( ) == num ) { return null ; } collections . sort ( messages , new tuple comparator ( ) ) ; return try messages for connected ( messages ) ; }	tries to send all other messages to all connected hosts ordered by their delivery probability.
protected int make press color ( ) { int r = ( this . background color > > num ) & num ; int g = ( this . background color > > num ) & num ; int b = ( this . background color > > num ) & num ; r = ( r - num < num ) ? num : r - num ; g = ( g - num < num ) ? num : g - num ; b = ( b - num < num ) ? num : b - num ; return color . rgb ( r , g , b ) ; }	make a dark color to ripple effect.
private void test streams from values ( ) { stream < string > movie names = stream . of ( str , str , str ) ; movie names . for each ( null ) ; string [ ] movie names2 = { str , str } ; stream < string > m names2 = stream . of ( movie names2 ) ; m names2 . for each ( null ) ; list < string > movies list = new array list < > ( ) ; movies list . add ( str ) ; movies list . add ( str ) ; stream < list < string > > from list = stream . of ( movies list ) ; from list . for each ( null ) ; }	creating a stream from a set of seed values.
public static void cache client user id ( consumer bean consumer bean , long internal id , string client id ) { cache client user id ( consumer bean . get short name ( ) , internal id , client id ) ; }	cache a user ' s client item id keyed by internal user id.
@ override final node < v > find ( int h , int k ) { for ( node < v > e = first ; e != null ; ) { int s ; if ( ( ( s = lock state ) & ( waiter | writer ) ) != num ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( u . compare and swap int ( this , lockstate , s , s + reader ) ) { tree node < v > r ; tree node < v > p ; try { p = ( ( r = root ) == null ? null : r . find tree node ( h , k ) ) ; } finally { thread w ; if ( get and add int ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) { lock support . unpark ( w ) ; } } return p ; } } return null ; }	returns matching node or null if none.
public boolean is public ( ) { return modifier . is public ( flags ) ; }	utility method to query the modifier flags of this member .
@ override public boolean receive image ( image to process img , task image container task , boolean block until image release , boolean close on image release , optional < runnable > runnable when done ) throws interrupted exception { set < task image container > pass tasks = new hash set < task image container > ( num ) ; pass tasks . add ( task ) ; return receive image ( img , pass tasks , block until image release , close on image release , runnable when done ) ; }	implements that top - level image single task submission that is defined by the imageconsumer interface .
protected string do it ( ) throws exception { log . info ( str + p + str + p + str + p ad id + str + p c b id + str + p m id + str + p doc action + str + p ) ; string sql = null ; if ( p ) { sql = str + str + str + str + str ; } else { sql = str + str ; if ( p ad id != num ) sql += str ; if ( p c b id != num ) sql += str ; if ( p m id != num ) sql += str ; sql += str + str + str ; } prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql , get ( ) ) ; int index = num ; if ( p ) { pstmt . set int ( index , get ad p id ( ) ) ; } else { if ( p ad id != num ) pstmt . set int ( index ++ , p ad id ) ; if ( p c b id != num ) pstmt . set int ( index ++ , p c b id ) ; if ( p m id != num ) pstmt . set int ( index ++ , p m id ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } return generate ( pstmt ) ; }	generate invoices from shipments.
public static s2 cell id from face ij ( int face , int i , int j ) { long n [ ] = { num , face << ( pos bits - num ) } ; int bits = ( face & swap mask ) ; for ( int k = num ; k >= num ; -- k ) { bits = get bits ( n , i , j , k , bits ) ; } s2 cell id s = new s2 cell id ( ( ( ( n [ num ] << num ) + n [ num ] ) << num ) + num ) ; return s ; }	return a leaf cell given its cube face ( range 0.
private void update actions ( final i project ) { m load project action . set enabled ( ! project . is loaded ( ) ) ; if ( m add address space action != null ) { m add address space action . set enabled ( project . is loaded ( ) ) ; } m search view action . set enabled ( project . is loaded ( ) ) ; m forward action . set enabled ( project . is loaded ( ) ) ; }	updates the actions that depend on the state of a single project .
void close ( ) throws io { stream . close ( ) ; }	closes the file item .
public boolean truncate too long number ( phone number number ) { if ( is valid number ( number ) ) { return bool ; } phone number number copy = new phone number ( ) ; number copy . merge from ( number ) ; long national number = number . get national number ( ) ; do { national number /= num ; number copy . set national number ( national number ) ; if ( is possible number with reason ( number copy ) == validation result . too short || national number == num ) { return bool ; } } while ( ! is valid number ( number copy ) ) ; number . set national number ( national number ) ; return bool ; }	attempts to extract a valid number from a phone number that is too long to be valid , and resets the phonenumber object passed in to that valid version.
public static boolean is within time comparison epsilon ( long time micros ) { long now = utils . get system now micros utc ( ) ; return math . abs ( time micros - now ) < time comparison epsilon ; }	compares a time value with current time.
public optional < histogram > histogram ( ) { return optional . empty ( ) ; }	histogram getter , returns the histogram value contained in this metricvalue .
private j create weekday ( string title ) { j label = new j ( title ) ; label . set horizontal alignment ( swing constants . center ) ; label . set horizontal text position ( swing constants . center ) ; label . set request focus enabled ( bool ) ; label . set background ( plaf . get primary1 ( ) ) ; label . set foreground ( color . white ) ; label . set opaque ( bool ) ; return label ; }	create week day label.
default path append ( string rel path ) { return append ( path . parse ( rel path ) ) ; }	create a new path consisting of this path with one or more additional segments given by the relative path .
public static int index of ( string value , string substring ) { return value != null && substring != null ? value . index of ( substring ) : - num ; }	returns the index within a string of the first occurrence of a specified substring .
public void test submit null callable ( ) { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @ suppress warnings ( str ) future < string > future = e . submit ( ( callable < string > ) null ) ; should throw ( ) ; } catch ( null pointer exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	submit ( null callable ) throws nullpointerexception.
public int read s ( ) throws io { synch bits ( ) ; int b0 = in . read ( ) ; if ( b0 < num ) { throw new io ( str ) ; } int b1 = in . read ( ) ; if ( b1 < num ) { throw new io ( str ) ; } int b2 = in . read ( ) ; if ( b2 < num ) { throw new io ( str ) ; } byte [ ] a byte = new byte [ num ] ; int count = in . read ( a byte ) ; if ( count < num ) { throw new io ( str ) ; } bytes read += num ; return ( int ) ( ( a byte [ num ] * num * num * num ) + ( b2 * num * num ) + ( b1 * num ) + b0 ) ; }	read a 32 bit signed number.
public void add preprocessor directive ( string directive ) { if ( m preprocessor directives == null ) m preprocessor directives = new array list < string > ( ) ; m preprocessor directives . add ( directive ) ; }	add a preprocessor directive like # define , # extension , # version etc .
public void format ( long in date , string builder buffer ) { buffer . append ( format ( in date ) ) ; }	format to string buffer .
public profiler clear results ( ) { lapped . clear ( ) ; return this ; }	clears saved results for average computations .
@ override public graph query has ( final string key , final object value ) { criteria . add ( new has ( key , value ) ) ; return this ; }	filter out elements that do not have a property value equal to provided value.
public void add attribute value ( principal principal , guid guid , string name , string value ) throws ums { modify attribute value ( modification type . add , principal , guid , name , value ) ; }	adds value for an attribute and saves the change in the database .
public static void copy stream ( input stream input stream , output stream output stream ) { if ( input stream != null && output stream != null ) { try { int length = - num ; byte [ ] buffer = new byte [ constant . capacity . bytes per mb ] ; while ( ( length = input stream . read ( buffer , num , buffer . length ) ) != - num ) { output stream . write ( buffer , num , length ) ; output stream . flush ( ) ; } } catch ( exception e ) { throw new file util exception ( e ) ; } } }	copy stream , from input to output , it don ' t close.
private void print type members ( list < ? extends element > members , list < type element > inner class ) { for ( element element : members ) { if ( is public or protected ( element ) ) { print member ( element , inner class ) ; } } }	helper method that outputs the public or protected inner members of a class .
private void initialize basic variables ( final int start column ) { basic variables = new int [ get width ( ) - num ] ; basic rows = new int [ get height ( ) ] ; arrays . fill ( basic variables , - num ) ; for ( int i = start column ; i < get width ( ) - num ; i ++ ) { integer row = find basic row ( i ) ; if ( row != null ) { basic variables [ i ] = row ; basic rows [ row ] = i ; } } }	initializes the basic variable / row mapping .
public void mouse released ( mouse event e ) { }	if the mouse is dragging a rectangle , pick the vertices contained in that rectangle clean up settings from mousepressed.
long free space windows ( string path , long timeout ) throws io { path = filename utils . normalize ( path , bool ) ; if ( path . length ( ) > num && path . char at ( num ) != str ) { path = str + path + str ; } string [ ] cmd attribs = new string [ ] { str , str , str + path } ; list < string > lines = perform command ( cmd attribs , integer . max value , timeout ) ; for ( int i = lines . size ( ) - num ; i >= num ; i -- ) { string line = lines . get ( i ) ; if ( line . length ( ) > num ) { return parse dir ( line , path ) ; } } throw new io ( str + str + path + str ) ; }	find free space on the windows platform using the ' dir ' command .
private void attach header ( sip h ) { if ( h == null ) throw new illegal argument exception ( str ) ; try { if ( h instanceof sip ) { sip < ? > hl = ( sip < ? > ) h ; if ( hl . is empty ( ) ) { return ; } } attach header ( h , bool , bool ) ; } catch ( sip ex ) { } }	attach a header and die if you get a duplicate header exception .
public string phonemise ( string text , string pos , string builder g2p method ) { string result = userdict lookup ( text , pos ) ; if ( result != null ) { g2p method . append ( str ) ; return result ; } result = lexicon lookup ( text , pos ) ; if ( result != null ) { g2p method . append ( str ) ; return result ; } string normalised = mary utils . normalise unicode letters ( text , get locale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdict lookup ( normalised , pos ) ; if ( result != null ) { g2p method . append ( str ) ; return result ; } result = lexicon lookup ( normalised , pos ) ; if ( result != null ) { g2p method . append ( str ) ; return result ; } } string phones = lts . predict pronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2p method . append ( str ) ; return result ; } return null ; }	phonemise the word text.
public static void stop ( int exit code ) { system . exit ( exit code ) ; }	allows to exit program .
private ode < decimal64 > state ( double t ) { return new ode < > ( zero . add ( t ) , new decimal64 [ num ] , new decimal64 [ num ] ) ; }	create a state at a time .
public static int hash ( object object ) { return object == null ? num : object . hash code ( ) ; }	returns a hashcode for the specified object .
public void put all ( map < ? extends k , ? extends v > m ) { for ( map . entry < ? extends k , ? extends v > e : m . entry set ( ) ) put ( e . get key ( ) , e . get value ( ) ) ; }	copies all of the mappings from the specified map to this one.
private void assert pivot ( string field , object value , int count , pivot field actual ) { assert equals ( str + actual . to string ( ) , field , actual . get field ( ) ) ; assert equals ( str + actual . to string ( ) , value , actual . get value ( ) ) ; assert equals ( str + actual . to string ( ) , count , actual . get count ( ) ) ; }	asserts that the actual pivotfield matches the expected criteria.
public string to xml ( ) throws fs { return to xml ( bool , bool ) ; }	returns the string representation of this object .
public static final void write string array xml ( string [ ] val , string name , xml serializer out ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { if ( val [ i ] == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; } else { out . start tag ( null , str ) ; out . attribute ( null , str , val [ i ] ) ; out . end tag ( null , str ) ; } } out . end tag ( null , str ) ; }	flatten a string [ ] into an xmlserializer.
public static void walk file tree ( file directory , file tree visitor visitor ) { visitor . pre visit directory ( directory ) ; file [ ] files = directory . list files ( ) ; if ( files != null ) { for ( file file : files ) { if ( file . is directory ( ) ) { walk file tree ( file , visitor ) ; } else { visitor . visit file ( file ) ; } } } visitor . post visit directory ( directory ) ; }	iterates over the file tree of a directory.
private spannable highlight hashtags ( spannable text ) { if ( text == null ) { return null ; } final matcher matcher = pattern hashtags . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( num ) ; final int end = matcher . end ( num ) ; text . set span ( new foreground color span ( m highlight color ) , start , end , spanned . span exclusive exclusive ) ; text . set span ( new style span ( android . graphics . typeface . bold ) , start , end , spanned . span exclusive exclusive ) ; } return text ; }	highlights all the hashtag in the passed text .
public int process block ( byte [ ] in , int in off , byte [ ] out , int out off ) throws data length exception , illegal state exception { if ( ( in off + block size ) > in . length ) { throw new data length exception ( str ) ; } if ( ( out off + block size ) > out . length ) { throw new data length exception ( str ) ; } cipher . process block ( ofb v , num , ofb out v , num ) ; for ( int i = num ; i < block size ; i ++ ) { out [ out off + i ] = ( byte ) ( ofb out v [ i ] ^ in [ in off + i ] ) ; } system . arraycopy ( ofb v , block size , ofb v , num , ofb v . length - block size ) ; system . arraycopy ( ofb out v , num , ofb v , ofb v . length - block size , block size ) ; return block size ; }	process one block of input from the array in and write it to the out array .
public string command topic ( string command ) { if ( command == null ) { command = str ; } return cmd topic . replace ( str , command ) ; }	get the mqtt topic for a command .
private static void check for null element ( object [ ] arg , string arg name ) { if ( ( arg == null ) || ( arg . length == num ) ) { throw new illegal argument exception ( str + arg name + str ) ; } for ( int i = num ; i < arg . length ; i ++ ) { if ( arg [ i ] == null ) { throw new illegal argument exception ( str + arg name + str + i + str ) ; } } }	checks that object [ ] arg is neither null nor empty ( ie length = = 0 ) and that it does not contain any null element .
public input stream execute download ( string url , string cookie ) throws io { string [ ] [ ] header params = new string [ ] [ ] { { str , cookie } , { str , str } } ; http entity http entity = execute get ( url , null , header params ) ; return http entity . get content ( ) ; }	fetches url content by executing get request with provided cookie string .
public final void test set seedbyte array02 ( ) throws no such field exception , security exception , illegal access exception { byte [ ] seed = new byte [ length ] ; byte [ ] bytes1 = new byte [ length ] ; byte [ ] bytes2 = new byte [ length ] ; boolean b ; for ( int i = num ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . set seed ( seed ) ; sr . set seed ( seed ) ; sr2 . set seed ( seed ) ; sr . next bytes ( bytes1 ) ; sr2 . next bytes ( bytes2 ) ; b = bool ; for ( int j = num ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assert false ( str , b ) ; }	test against the " void setseed ( byte [ ] ) " method ; it checks out that " setseed ( byte [ ] ) " method supplements its argument to current seed rather than replaces current seed.
public image flip image vertically ( image image , boolean maintain opacity ) { int [ ] rgb = image . get rgb ( ) ; int [ ] new rgb = new int [ rgb . length ] ; int width = image . get width ( ) ; int height = image . get height ( ) ; for ( int y = num ; y < height ; y ++ ) { for ( int x = num ; x < width ; x ++ ) { new rgb [ x + ( height - y - num ) * width ] = rgb [ x + y * width ] ; } } return encoded image . create from rgb ( new rgb , width , height , ! maintain opacity ) ; }	flips the given image on the vertical axis.
public morfologik filter factory ( map < string , string > args ) { super ( args ) ; final string dictionary resource attribute = str ; string dictionary resource = get ( args , dictionary resource attribute ) ; if ( dictionary resource != null && ! dictionary resource . is empty ( ) ) { throw new illegal argument exception ( str + dictionary resource attribute + str + str + dictionary attribute + str ) ; } resource name = get ( args , dictionary attribute ) ; if ( ! args . is empty ( ) ) { throw new illegal argument exception ( str + args ) ; } }	creates a new morfologikfilterfactory.
public static < t > t wrap throw ( callable < t > callable , code finally ) { try { return callable . call ( ) ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { wrap throw ( finally ) ; } }	execute the callable wrapping checked exceptions inside a runtimeexception .
public static string pad left ( string str , int total chars ) { if ( str == null ) str = str ; string buffer sb = new string buffer ( ) ; for ( int i = num ; i < total chars - str . length ( ) ; i ++ ) { sb . append ( str ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	pads the given string to the left with spaces to ensure that it ' s at least totalchars long .
public int hash code ( ) { int myhash = num + policy identifier . hash code ( ) ; myhash = num * myhash + policy qualifiers . hash code ( ) ; return myhash ; }	returns the hash code for this policyinformation .
public unix terminal ( ) throws io { this ( system . in , system . out , charset . default charset ( ) ) ; }	creates a unixterminal with default settings , using system.
@ override public boolean is cell editable ( int row index , int column index ) { process function parameter value value = value list . get ( row index ) ; switch ( column index ) { case col optional : return value . optional ; case col value : if ( value . optional ) { return value . included ; } else { return bool ; } case col parameter : case col type : default : return bool ; } }	checks if is cell editable .
private void check streams ( ) { if ( ( system . current time millis ( ) - last checked ) / num < check delay ) { return ; } last checked = system . current time millis ( ) ; set < stream info > remove = new hash set < > ( ) ; for ( stream info info : data ) { if ( ! info . is valid ( ) || ! info . get online ( ) ) { remove . add ( info ) ; } } for ( stream info info : remove ) { data . remove ( info ) ; item removed ( info ) ; } if ( remove . is empty ( ) ) { list data changed ( ) ; } }	checks all added streams and removes invalid ones .
public void add priority package ( string pkg ) { if ( priority packages == null ) priority packages = new string [ num ] ; int old length = priority packages . length ; string [ ] new pkgs = new string [ old length + num ] ; system . arraycopy ( priority packages , num , new pkgs , num , old length ) ; if ( ! pkg . ends with ( str ) ) pkg = pkg + str ; new pkgs [ old length ] = pkg ; priority packages = new pkgs ; }	add to the list of packages that take priority over the parent.
@ override public void action performed ( action event ev ) { final megan . remote . remote service browser remote service browser = ( megan . remote . remote service browser ) get viewer ( ) ; if ( remote service browser != null ) { string url = remote service browser . get url ( ) ; string user = remote service browser . get user ( ) ; string password = remote service browser . get passwd ( ) ; string command = str + url + str ; if ( user . length ( ) > num ) command += str + user + str ; if ( password . length ( ) > num ) { synchronized ( sync object ) { open remote server command . hidden password = password ; } command += str + hidden password + str ; } command += str ; if ( url . length ( ) > num ) { execute ( command ) ; } } }	action to be performed.
public static string verify certificate ( x509 certificate cert , collection < crl > crls , calendar calendar ) { if ( sign utils . has unsupported critical extension ( cert ) ) return str ; try { cert . check validity ( calendar . get time ( ) ) ; } catch ( exception e ) { return e . get message ( ) ; } if ( crls != null ) { for ( crl crl : crls ) { if ( crl . is revoked ( cert ) ) return str ; } } return null ; }	verifies a single certificate .
public static void expand ( ) { string [ ] st = new string [ l ] ; int i ; for ( i = num ; i < r ; i ++ ) st [ i ] = str + ( char ) i ; st [ i ++ ] = str ; int codeword = binary std in . read int ( w ) ; if ( codeword == r ) return ; string val = st [ codeword ] ; while ( bool ) { binary std out . write ( val ) ; codeword = binary std in . read int ( w ) ; if ( codeword == r ) break ; string s = st [ codeword ] ; if ( i == codeword ) s = val + val . char at ( num ) ; if ( i < l ) st [ i ++ ] = val + s . char at ( num ) ; val = s ; } binary std out . close ( ) ; }	reads a sequence of bit encoded using lzw compression with 12 - bit codewords from standard input ; expands them ; and writes the results to standard output .
audio capabilities ( int [ ] supported encodings , int max channel count ) { if ( supported encodings != null ) { this . supported encodings = arrays . copy of ( supported encodings , supported encodings . length ) ; arrays . sort ( this . supported encodings ) ; } else { this . supported encodings = new int [ num ] ; } this . max channel count = max channel count ; }	constructs new audio capabilities based on a set of supported encodings and a maximum channel count .
@ override public boolean is rotate edge labels ( ) { return graph creator . is rotating edge labels ( ) ; }	let the graph model decide .
public static response code create extension ( string name ) { string buffer buffer = new string buffer ( name . length ( ) + num ) ; if ( ! name . starts with ( str ) ) { buffer . append ( str ) ; } buffer . append ( name ) ; return new response code ( buffer . to string ( ) ) ; }	creates an extension response code . names that do not begin with ' x ' will have ' x ' prepended.
@ override public double [ ] make inverse cumulative test values ( ) { double [ ] points = make cumulative test points ( ) ; double [ ] points2 = new double [ points . length - num ] ; system . arraycopy ( points , num , points2 , num , points2 . length ) ; return points2 ; }	creates the default inverse cumulative probability density test expected values .
public java . lang . string builder append ( boolean b ) { if ( b ) { return append ( str ) ; } return append ( str ) ; }	appends the string representation of the boolean argument to the string buffer.
public void delete servers ( set servers ) throws am { if ( servers . contains ( system properties . get server instance name ( ) ) ) { throw new am ( get localized string ( str ) ) ; } string server name = null ; try { if ( ( servers != null ) && ! servers . is empty ( ) ) { sso token = get user sso ( ) ; for ( iterator i = servers . iterator ( ) ; i . has next ( ) ; ) { server name = ( string ) i . next ( ) ; string [ ] param = { server name } ; log event ( str , param ) ; server configuration . delete server instance ( token , server name ) ; log event ( str , param ) ; } } } catch ( sms e ) { string [ ] params = { server name , e . get message ( ) } ; log event ( str , params ) ; throw new am ( get error string ( e ) ) ; } catch ( sso e ) { string [ ] params = { server name , e . get message ( ) } ; log event ( str , params ) ; throw new am ( get error string ( e ) ) ; } }	deletes a set of servers .
static void sort ( float [ ] a , int left , int right , float [ ] work , int work base , int work len ) { while ( left <= right && float . is na n ( a [ right ] ) ) { -- right ; } for ( int k = right ; -- k >= left ; ) { float ak = a [ k ] ; if ( ak != ak ) { a [ k ] = a [ right ] ; a [ right ] = ak ; -- right ; } } do sort ( a , left , right , work , work base , work len ) ; int hi = right ; while ( left < hi ) { int middle = ( left + hi ) > > > num ; float middle value = a [ middle ] ; if ( middle value < num ) { left = middle + num ; } else { hi = middle ; } } while ( left <= right && float . float to raw int bits ( a [ left ] ) < num ) { ++ left ; } for ( int k = left , p = left - num ; ++ k <= right ; ) { float ak = a [ k ] ; if ( ak != num ) { break ; } if ( float . float to raw int bits ( ak ) < num ) { a [ k ] = num ; a [ ++ p ] = - num ; } } }	sorts the specified range of the array using the given workspace array slice if possible for merging.
public void fatal error ( org . xml . sax . sax e ) throws org . xml . sax . sax { string formatted msg = e . get message ( ) ; sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; try { handler . fatal error ( new transformer exception ( formatted msg , locator ) ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	report a fatal xslt processing error .
public boolean add ( terminal sym ) throws internal error { boolean result ; not null ( sym ) ; result = elements . get ( sym . index ( ) ) ; if ( ! result ) elements . set ( sym . index ( ) ) ; return result ; }	add a single terminal to the set .
private void create recursivly ( string path ) throws keeper exception , interrupted exception { try { if ( zk . exists ( path , bool ) == null && path . length ( ) > num ) { string temp = path . substring ( num , path . last index of ( file . separator ) ) ; create recursivly ( temp ) ; zk . create ( path , null , ids . open acl unsafe , create mode . persistent ) ; } else { return ; } } catch ( keeper exception e ) { throw e ; } catch ( interrupted exception e ) { throw e ; } }	create zookeepr node if not exist.
public void stop recording ( ) { m handler . send message ( m handler . obtain message ( msg stop recording ) ) ; m handler . send message ( m handler . obtain message ( msg quit ) ) ; }	tells the video recorder to stop recording.
private void write tag ( string name , tag tag ) throws io { tag type type = tag . get type ( ) ; byte [ ] name bytes = name . get bytes ( standard charsets . utf 8 ) ; if ( type == tag type . end ) { throw new io ( str ) ; } os . write byte ( type . get id ( ) ) ; os . write short ( name bytes . length ) ; os . write ( name bytes ) ; write tag payload ( tag ) ; }	write a tag with a name .
public int hash code ( ) { if ( myhash == - num ) { if ( timestamp == null ) { myhash = signer cert path . hash code ( ) ; } else { myhash = signer cert path . hash code ( ) + timestamp . hash code ( ) ; } } return myhash ; }	returns the hash code value for this code signer.
public bv type variable ( ) { int id = type variable list . size ( ) ; type variable list . add ( null ) ; bv result = new bv ( id , this ) ; type variable list . set ( id , result ) ; return result ; }	get new type variable.
public static void downto ( number self , number to , @ closure params ( first param . class ) closure closure ) { int self1 = self . int value ( ) ; int to1 = to . int value ( ) ; if ( self1 >= to1 ) { for ( int i = self1 ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( str + to + str + self + str ) ; }	iterates from this number down to the given number , inclusive , decrementing by one each time .
public void add ( select clause element raw element ) { select clause elements . add ( element ) ; }	adds an select expression within the select clause .
public synchronized void remove pv change listener ( pv change listener l ) { log . debug ( str + string . value of ( this ) + str + string . value of ( l ) ) ; pv change listeners . remove ( l ) ; }	remove listener for pv changes.
public static boolean is normal ( geo time serie gts , int buckets , double pcterror , boolean bessel ) { if ( num == gts . values ) { return bool ; } if ( type . double != gts . type && type . long != gts . type ) { return bool ; } double [ ] musigma = musigma ( gts , bessel ) ; double mu = musigma [ num ] ; double sigma = musigma [ num ] ; if ( num == sigma ) { return bool ; } double [ ] bounds = sax . get bounds ( buckets ) ; int [ ] counts = new int [ bounds . length + num ] ; for ( int i = num ; i < gts . values ; i ++ ) { double v = ( ( double ) gts . value at index ( gts , i ) - mu ) / sigma ; int insertion = arrays . binary search ( bounds , v ) ; if ( insertion >= num ) { counts [ insertion ] ++ ; } else { counts [ - ( num + insertion ) ] ++ ; } } double mean = gts . values / counts . length ; for ( int i = num ; i < counts . length ; i ++ ) { if ( math . abs ( num - ( counts [ i ] / mean ) ) > pcterror ) { return bool ; } } return bool ; }	determine if a gts ' values are normally distributed . works for numerical gts only.
public show progress ( ) { start = last = system . current time millis ( ) ; }	create a new instance of this class , and start the timer .
public static repository expression parse repository expression ( string to parse ) throws parse error { stream tokenizer t = parser . tokenize ( to parse ) ; term creator = parser . parse term ( t ) ; list < operation > operations = parser . parse operation list ( t ) ; repository expression ex = new repository expression ( creator ) ; if ( ! operations . is empty ( ) ) { throw new parse error ( str ) ; } return ex ; }	parse a string under the expectation that it is a repositoryexpression , i.
@ override public synchronized void close ( ) throws io { buffer = null ; notify all ( ) ; }	closes this stream . this implementation releases the buffer used for the pipe and notifies all threads waiting to read or write .
public void add section ( source section section ) { sections . add ( section ) ; }	add a section to the document .
public static genome relationships load ( buffered reader reader ) throws io { final genome relationships ped = new genome relationships ( ) ; string line ; while ( ( line = reader . read line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts with ( str ) || line . matches ( str ) ) { continue ; } if ( line . matches ( str ) ) { parse genome line ( ped , line ) ; continue ; } if ( line . matches ( str ) ) { parse relationship line ( ped , line ) ; continue ; } throw new no talkback slim exception ( str + line + str ) ; } return ped ; }	load a genome relationships file.
private int [ ] version parts ( string version ) { string [ ] parts = version . split ( str ) ; int [ ] p = new int [ num ] ; for ( int i = num ; i < num ; i ++ ) { int pi ; if ( i < parts . length ) { p [ i ] = integer . parse int ( parts [ i ] ) ; } else { p [ i ] = - num ; } } return p ; }	return the version parts.
private fgs runner . type compute type ( ) { object model = get data model ( ) ; if ( model == null && get source graph ( ) != null ) { model = get source graph ( ) ; } if ( model == null ) { throw new runtime exception ( str + str + str + str ) ; } if ( model instanceof graph ) { type = fgs runner . type . graph ; } else if ( model instanceof data set ) { data set data set = ( data set ) model ; if ( data set . is continuous ( ) ) { type = fgs runner . type . continuous ; } else if ( data set . is discrete ( ) ) { type = fgs runner . type . discrete ; } else { throw new illegal state exception ( str ) ; } } else if ( model instanceof i ) { type = fgs runner . type . continuous ; } else if ( model instanceof data model list ) { data model list list = ( data model list ) model ; if ( all continuous ( list ) ) { type = fgs runner . type . continuous ; } else if ( all discrete ( list ) ) { type = fgs runner . type . discrete ; } else { throw new illegal argument exception ( str ) ; } } return type ; }	executes the algorithm , producing ( at least ) a result workbench.
public static boolean approx equals ( final double a , final double b , final double tolerance ) { if ( double . is na n ( a ) || double . is na n ( b ) ) { return bool ; } if ( a == b ) { return bool ; } if ( double . is infinite ( a ) || double . is infinite ( b ) ) { return bool ; } if ( a >= ( b - tolerance ) && a <= ( b + tolerance ) ) { return bool ; } return bool ; }	check if two doubles are equal to within specified tolerance .
public static map < string , object > load json model ( file js file ) { try { map < string , object > model = java script resolver . read json model ( js file ) ; if ( model == null ) { throw new compiler error exception ( str + js file . get absolute path ( ) ) ; } if ( ! model . contains key ( str ) ) { throw new ceylon run js exception ( str + js file + str ) ; } return model ; } catch ( io ex ) { throw new compiler error exception ( str + js file ) ; } }	read the metamodel declaration from a js file , check it ' s the right version and return the model as a map .
static string [ ] split line ( final string line ) { final int ix0 = line . index of ( str ) ; final int ix = ix0 == - num ? line . length ( ) : ix0 ; final string less comment = line . substring ( num , ix ) ; if ( less comment . matches ( str ) ) { return null ; } return less comment . split ( str ) ; }	check for comments , trim white space.
private list < volume > create volume data ( string name , int num volumes ) { list < volume > volumes = new array list < volume > ( ) ; uri cg uri = create block consistency group ( name + str ) ; for ( int i = num ; i <= num volumes ; i ++ ) { volume volume = new volume ( ) ; uri volume uri = uri . create id ( volume . class ) ; test volume ur . add ( volume uri ) ; volume . set id ( volume uri ) ; volume . set label ( name + i ) ; volume . set consistency group ( cg uri ) ; db client . create object ( volume ) ; } return volumes ; }	creates the blockobject volume data .
private static < t > t hash map to object ( linked hash map map , class < t > type ) { try { return string to object ( mapper . write value as string ( map ) , type ) ; } catch ( io e ) { log . warn ( str + type . get name ( ) + str + map . to string ( ) + str + e . get message ( ) ) ; return null ; } }	takes a hashmap and creates an object.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return success ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static blocks remove info is start block ( block node rem block , block node start block ) { list < insn node > rem insns = rem block . get instructions ( ) ; list < insn node > start insns = start block . get instructions ( ) ; if ( rem insns . size ( ) < start insns . size ( ) ) { return null ; } int start pos = rem insns . size ( ) - start insns . size ( ) ; int end pos = num ; if ( ! check insns ( rem insns , start insns , start pos , null ) ) { if ( check insns ( rem insns , start insns , num , null ) ) { start pos = num ; end pos = start insns . size ( ) ; } else { boolean found = bool ; for ( int i = num ; i < start pos ; i ++ ) { if ( check insns ( rem insns , start insns , i , null ) ) { start pos = i ; end pos = start insns . size ( ) + i ; found = bool ; break ; } } if ( ! found ) { return null ; } } } blocks pair start pair = new blocks pair ( rem block , start block ) ; blocks remove info remove info = new blocks remove info ( start pair ) ; remove info . set start split index ( start pos ) ; remove info . set end split index ( end pos ) ; if ( end pos != num ) { remove info . set end ( start pair ) ; } if ( ! check insns ( rem insns , start insns , start pos , remove info ) ) { return null ; } return remove info ; }	' finally ' instructions can start in the middle of the first block .
public boolean check error ( ) { return pw . check error ( ) ; }	checks to see if the there has been an error in the printstream .
public list < pdf document > split by size ( long size ) { list < page range > split ranges = new array list < > ( ) ; int current page = num ; int num of pages = pdf document . get number of pages ( ) ; while ( current page <= num of pages ) { page range next range = get next range ( current page , num of pages , size ) ; split ranges . add ( next range ) ; list < integer > all pages = next range . get all pages ( ) ; current page = ( int ) all pages . get ( all pages . size ( ) - num ) + num ; } return extract page ranges ( split ranges ) ; }	splits the document basing on the given size .
private boolean validate auth schemes ( set auth scheme set ) throws policy exception { if ( auth scheme set . is empty ( ) ) { string args [ ] = { auth scheme } ; throw new policy exception ( res bundle utils . rb name , str , args , null ) ; } iterator auth scheme set iter = auth scheme set . iterator ( ) ; auth schemes . clear ( ) ; while ( auth scheme set iter . has next ( ) ) { try { string auth scheme = ( string ) auth scheme set iter . next ( ) ; auth schemes . add ( auth scheme ) ; } catch ( class cast exception e ) { string args [ ] = { auth scheme } ; throw new policy exception ( res bundle utils . rb name , str , args , null ) ; } } return bool ; }	validates the module instance names provided to the setproperties ( ) call for the auth_scheme key.
public static uuid from uuid urn uuid ( string uui urn ) { if ( ! uui urn . starts with ( uuid . uuid as a urn prefix ) ) { imf imf error logger = new imf ( ) ; imf error logger . add error ( imf . imf . error codes . uuid error , imf . imf . error levels . fatal , string . format ( str + str , uui urn , uuid . uuid as a urn prefix ) ) ; throw new imf ( string . format ( str , uui urn , uuid . uuid as a urn prefix ) , imf error logger ) ; } return uuid . from string ( uui urn . split ( uuid . uuid as a urn prefix ) [ num ] ) ; }	a helper method to return the uuid without the " urn : uuid : " prefix.
public string read line ( ) { string line ; try { line = scanner . next line ( ) ; } catch ( no such element exception e ) { line = null ; } return line ; }	reads and returns the next line in this input stream .
public static byte [ ] decode ( final string s ) { return base64 . decode ( s , base64 . no options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
public static gradient paint make red paint ( final double width , final double height ) { return new gradient paint ( num , num , new color ( num , num , num ) , ( float ) width / num , ( float ) height / num , new color ( num , num , num ) , bool ) ; }	creates a red gradient paint .
public static list < string > match numbers ( string text ) { string pattern = str ; pattern pat = pattern . compile ( pattern ) ; matcher m = pat . matcher ( text ) ; list < string > matches = new array list < string > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }	returns a list of all numbers found in a given string .
@ override public uuid create entry node ( uuid parent node ) { uuid uuid = uuid . random uuid ( ) ; graph server . add vertex ( uuid ) ; graph server . add edge ( uuid , parent node ) ; return uuid ; }	creates a node that accepts input into the routing network can only connect to one other node.
protected void assert delivery states ( final collection < customer order delivery > deliveries , final map < string , string > expected state ) { for ( customer order delivery delivery : deliveries ) { assert equals ( str + delivery . get delivery group ( ) + str + delivery . get delivery num ( ) , expected state . get ( delivery . get delivery group ( ) ) , delivery . get delivery status ( ) ) ; } }	assert delivery state by delivery group .
@ nullable private compile scope create facets compile scope ( @ not null final compiler manager compiler manager , @ not null final virtual file [ ] files ) { final set < module > modules = new . set ( ) ; boolean facets found = bool ; for ( final virtual file file : files ) { final module module = module util core . find module for file ( file , project ) ; if ( module != null ) { modules . add ( module ) ; if ( ! facets found ) { facets found = has facets ( module ) ; } } } if ( facets found ) { return compiler manager . create modules compile scope ( modules . to array ( module . empty array ) , bool , bool ) ; } return null ; }	it seems that createfilescompilescope does not work in all environments , at least with android , see https : / / intellij - support.
@ nullable @ worker thread static file write bitmap to file ( @ non null bitmap bitmap , @ non null file file ) { file output stream file stream = null ; try { byte array output stream byte stream = new byte array output stream ( ) ; bitmap . compress ( bitmap . compress format . png , num , byte stream ) ; file stream = new file output stream ( file ) ; file stream . write ( byte stream . to byte array ( ) ) ; return file ; } catch ( io e ) { log . e ( tag , e . get message ( ) , e ) ; } finally { if ( file stream != null ) { try { file stream . close ( ) ; } catch ( io e ) { log . e ( tag , e . get message ( ) , e ) ; } } } return null ; }	writes the bitmap to disk and returns the new file .
public static sentence parse ( final string text , final conversation context ctx ) { string txt ; if ( text == null ) { txt = str ; } else { if ( ( ctx != null ) && ctx . is for matching ( ) ) { final expression matcher matcher = new expression matcher ( ) ; txt = matcher . read matching flags ( text ) ; if ( matcher . is any flag set ( ) ) { return matcher . parse sentence ( txt , ctx ) ; } } else { txt = text ; } } txt = txt . trim ( ) ; final sentence implementation sentence = new sentence implementation ( ctx , txt ) ; try { final conversation parser parser = new conversation parser ( sentence ) ; sentence . parse ( parser ) ; sentence . classify words ( parser ) ; if ( ( ctx != null ) && ctx . get merge expressions ( ) ) { sentence . evaluate sentence type ( ) ; sentence . merge words ( ) ; if ( ! ctx . is for matching ( ) ) { sentence . standardize sentence type ( ) ; sentence . performa aliasing ( ) ; } } sentence . set error ( parser . get error string ( ) ) ; } catch ( final exception e ) { logger . error ( str + text + str ) ; sentence . set error ( e . get message ( ) ) ; e . print stack trace ( ) ; } return sentence ; }	parse the given text sentence .
public elem template element replace child ( elem template element new child elem , elem template element old child elem ) { if ( old child elem == null || old child elem . get parent elem ( ) != this ) return null ; elem template element prev = old child elem . get previous sibling elem ( ) ; if ( null != prev ) prev . m next sibling = new child elem ; if ( m first child == old child elem ) m first child = new child elem ; new child elem . m parent node = this ; old child elem . m parent node = null ; new child elem . m next sibling = old child elem . m next sibling ; old child elem . m next sibling = null ; return new child elem ; }	replace the old child with a new child .
protected int hash ( object key1 , object key2 , object key3 ) { int h = num ; if ( key1 != null ) { h ^= key1 . hash code ( ) ; } if ( key2 != null ) { h ^= key2 . hash code ( ) ; } if ( key3 != null ) { h ^= key3 . hash code ( ) ; } h += ~ ( h << num ) ; h ^= ( h > > > num ) ; h += ( h << num ) ; h ^= ( h > > > num ) ; return h ; }	gets the hash code for the specified multi - key .
public void flush ( ) throws io { flush buffer ( ) ; output stream . flush ( ) ; }	flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
private void add entry to info list ( entry entry , list < entry info > entry info list ) { if ( entry info list != null ) { string type to add = entry . get type ( ) ; if ( type to add . equals ( db logic . constants . quotation ) ) { type to add = db logic . constants . note ; } entry info list . add ( new entry info ( entry . get id ( ) , entry . get note or title ( str ) , entry . get quotation ( str ) , entry . get is public ( ) , entry . has first child id ( ) , entry . has parent id ( ) , type to add ) ) ; } }	adds the entry to the entry list .
private void update sliding ( float new position normalized ) { current slide = new position normalized ; state = current slide == num ? expanded : current slide == num ? collapsed : sliding ; float slide y = math . abs ( ( current slide * max slide ) - max slide ) ; slidable view . set y ( slide y ) ; invalidate ( ) ; notify listeners ( current slide ) ; }	always use this method to update the position of the sliding view .
void flush ( vcf writer writer ) throws io { if ( m prev record != null ) { if ( ! m prev dense ) { write count ( writer , m prev record ) ; } else { m vcf filter statistics . increment ( stat . density window count ) ; } } m prev record = null ; m prev dense = bool ; }	writes any remaining snp lines.
public video stream ( string stream str ) { string [ ] args = stream str . split ( str ) ; map < string , string > arg map = new hash map < string , string > ( ) ; for ( string arg : args ) { string [ ] args values = arg . split ( str ) ; if ( args values != null ) { if ( args values . length >= num ) { arg map . put ( args values [ num ] , args values [ num ] ) ; } } } m url = arg map . get ( str ) ; }	construct a video stream from one of the strings obtained from the " url_encoded_fmt_stream_map " parameter if the video_info.
public boolean equals ( string str ) { if ( str == null ) return bool ; if ( length != str . length ( ) ) return bool ; for ( int i = length , j = offset + length ; -- i >= num ; ) { if ( array [ -- j ] != str . char at ( i ) ) return bool ; } return bool ; }	compares this character array against the specified string.
protected void flush ( ) { stream . flush ( ) ; }	flushes any buffered output .
private server starter start servers ( ) throws exception { server starter srv starter = new server starter ( ) ; thread t = new thread ( srv starter ) ; t . set daemon ( bool ) ; t . set name ( str ) ; t . start ( ) ; srv starter . wait for server start ( ) ; return srv starter ; }	starts background thread that launches servers.
public pagination evaluate ( final class entity class ) { paginate paginate = entity class != null ? ( paginate ) entity class . get annotation ( paginate . class ) : null ; int default limit = paginate != null ? paginate . default limit ( ) : default page limit ; int max limit = paginate != null ? paginate . max limit ( ) : max page limit ; evaluate ( default limit , max limit ) ; generate totals = generate totals && ( paginate == null || paginate . countable ( ) ) ; return this ; }	evaluates the pagination variables.
public runtime collector ( algorithm algorithm , int frequency , result file writer writer ) { super ( algorithm , frequency , frequency type . evaluations ) ; this . writer = writer ; start time = system . nano time ( ) ; }	constructs a new wrapper to collect runtime dynamics .
public boolean deregister service provider ( object provider ) { object oprovider = map . get ( provider . get class ( ) ) ; if ( provider == oprovider ) { map . remove ( provider . get class ( ) ) ; poset . remove ( provider ) ; if ( provider instanceof registerable service ) { registerable service rs = ( registerable service ) provider ; rs . on deregistration ( registry , category ) ; } return bool ; } return bool ; }	if the provider was not previously registered , do nothing .
public newest first comparator ( date now ) { preconditions . check not null ( now ) ; m now = new date ( now . get time ( ) + millis in day ) ; }	construct a comparator that sorts items by newest first.
protected void update ( comparable x , object y ) { int index = index of ( x ) ; if ( index < num ) { throw new series exception ( str + x ) ; } else { comparable object item item = get data item ( index ) ; item . set object ( y ) ; fire series changed ( ) ; } }	updates an item in the series .
public void write field ( string name , float value ) throws java . io . io { write field ( name , float . to string ( value ) ) ; }	writes an float field value .
public byte [ ] decode data ( byte [ ] data , int num error correction bytes ) throws reed solomon exception , data too large exception { if ( data == null || data . length == num ) { return null ; } if ( data . length > num ) { throw new data too large exception ( str ) ; } int [ ] data ints = new int [ data . length ] ; for ( int i = num ; i < data . length ; i ++ ) { data ints [ i ] = data [ i ] & num ; } int total bytes = data . length - num error correction bytes ; decoder . decode ( data ints , num error correction bytes ) ; byte array output stream bos = new byte array output stream ( ) ; for ( int i = num ; i < total bytes && i < data ints . length ; i ++ ) { bos . write ( data ints [ i ] ) ; } return bos . to byte array ( ) ; }	repairs and decodes the supplied byte array , removing the error correction codes and returning the original data.
public shape create scroll button apart ( int x , int y , int w , int h ) { path . reset ( ) ; path . move to ( x , y ) ; path . line to ( x , y + h ) ; path . line to ( x + w , y + h ) ; add scroll gap path ( x , y , w , h , bool ) ; path . close path ( ) ; return path ; }	return a path for a scroll bar button.
void remove all views from adapter ( view pager pager ) { m views . clear ( ) ; pager . remove all views ( ) ; m is view pager in intentionally inconsistent state = bool ; }	remove all the views from the adapter and de - parents them from the viewpager after calling this , it is expected that notifydatasetchanged should be called soon afterwards .
public static boolean is valid mobile ( @ non null string mobile ) { if ( ! text utils . is empty ( mobile ) && mobile . length ( ) == num ) { if ( mobile . starts with ( str ) || mobile . starts with ( str ) || mobile . starts with ( str ) ) { return bool ; } } return bool ; }	method to check valid malaysia mobile number.
public string convert error ( string filename , int line , int column , string message ) { string src filename = null ; int dest line = num ; int src line = num ; for ( int i = num ; i < lines . size ( ) ; i ++ ) { line map = lines . get ( i ) ; if ( filename != null && ! filename . ends with ( dst filename ) ) { } else if ( map . dst line <= line && line <= map . get last destination line ( ) ) { src filename = map . src filename ; src line = map . get source line ( line ) ; } } if ( src filename != null ) return src filename + str + src line + str + message ; else return filename + str + line + str + message ; }	converts an error in the generated file to a compileerror based on the source .
public static number sinh ( number a ) { return math . sinh ( a . double value ( ) ) ; }	returns the hyperbolic sine of the number .
public void add notification ( @ not null notification notification ) { notification item item = new notification item ( resources , notification , delegate , panel ) ; notification widget . add ( notification ) ; }	show notification in container .
protected boolean is attributes modified ( ) { if ( attributes != null ) { return ( attributes . is empty ( ) ) ? bool : bool ; } return bool ; }	have the attributes of this service schema been modified.
@ nullable public static ignore descriptor for method ( class cls , method mthd ) { if ( mthd . is annotation present ( ignite ignore . class ) ) { ignite ignore ignore = mthd . get annotation ( ignite ignore . class ) ; string reason = ignore . value ( ) ; if ( f . is empty ( reason ) ) throw new illegal argument exception ( str + cls . get name ( ) + str + mthd . get name ( ) + str ) ; return new ignore descriptor ( reason , ignore . force failure ( ) ) ; } else return null ; }	get descriptor for method ( if any ) .
public static dbi random sample ( dbi source , int k , random random ) { if ( k < num || k > source . size ( ) ) { throw new illegal argument exception ( str + k + str + source . size ( ) + str ) ; } if ( random == null ) { random = new fast non threadsafe random ( ) ; } if ( k < source . size ( ) > > num ) { dbi aids = dbid . ensure array ( source ) ; dbid iter = aids . iter ( ) ; dbi sample = dbid . new hash set ( k ) ; while ( sample . size ( ) < k ) { iter . seek ( random . next int ( aids . size ( ) ) ) ; sample . add ( iter ) ; } return sample ; } else { dbi sample = dbid . new array ( source ) ; random shuffle ( sample , random , k ) ; for ( int i = sample . size ( ) - num ; i >= k ; i -- ) { sample . remove ( i ) ; } return sample ; } }	produce a random sample of the given dbids .
protected int draw message size ( ) { int size diff = size range [ num ] == size range [ num ] ? num : rng . next int ( size range [ num ] - size range [ num ] ) ; return size range [ num ] + size diff ; }	generates a ( random ) message size.
public static string [ ] grab args ( string signature ) { matcher matcher = sig re . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group count ( ) != num ) logger . error ( str , signature ) ; string args = matcher . group ( num ) ; if ( args . is empty ( ) ) return new string [ num ] ; return args . split ( str ) ; }	grab the args string from the method signature.
public void test engine create ssl 01 ( ) { ssl ssl = new ssl ( ) ; try { ssl sleng = ssl . engine create ssl ( ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } }	javax . net . ssl . sslcontextspi # enginecreatesslengine ( ) verify exception when sslcontextspi object wasn ' t initialiazed .
public void process dispatch ( uniform pair < event bean [ ] > events ) { if ( ! for clause delivery ) { dispatch internal ( events ) ; return ; } if ( ( group delivery expressions == null ) || ( group delivery expressions . length == num ) ) { uniform pair < event bean [ ] > todeliver = new uniform pair < event bean [ ] > ( null , null ) ; if ( events != null ) { if ( events . get first ( ) != null ) { for ( event bean the event : events . get first ( ) ) { todeliver . set first ( new event bean [ ] { the event } ) ; dispatch internal ( todeliver ) ; } todeliver . set first ( null ) ; } if ( events . get second ( ) != null ) { for ( event bean the event : events . get second ( ) ) { todeliver . set second ( new event bean [ ] { the event } ) ; dispatch internal ( todeliver ) ; } todeliver . set second ( null ) ; } } return ; } map < object , uniform pair < event bean [ ] > > groups ; try { groups = get grouped results ( events ) ; } catch ( runtime exception ex ) { log . error ( str + ex . get message ( ) + str , ex ) ; dispatch internal ( events ) ; return ; } for ( map . entry < object , uniform pair < event bean [ ] > > group : groups . entry set ( ) ) { dispatch internal ( group . get value ( ) ) ; } }	indicate an outbound result .
protected void reset ( ) { arrays . fill ( m is candidate , bool ) ; }	reset the candidate parser settings , making each parser equally likely .
protected void redefine ( int nodetype , string namespace , string local name ) { this . nodetype = nodetype ; this . namespace = namespace ; this . local name = local name ; this . hash = nodetype + namespace . hash code ( ) + local name . hash code ( ) ; }	redefine this extendedtype object to represent a different extended type.
public void put long ( long pos , long val ) { unsafe . put long ( pos + addr , val ) ; }	writes a long to the specified position .
public boolean delete r ( uri rp system id , list < uri > volume ids , string token ) throws internal exception { list < string > replication set names = new array list < string > ( ) ; try { list < recover point volume protection info > volume protection info list = new array list < recover point volume protection info > ( ) ; protection system rp system = db client . query object ( protection system . class , rp system id ) ; recover point client rp = rp . get recover point client ( rp system ) ; for ( uri volume id : volume ids ) { volume volume = db client . query object ( volume . class , volume id ) ; recover point volume protection info volume protection info = rp . get protection info for volume ( rp . get rpw ( volume . get id ( ) , db client ) ) ; volume source volume = rp . get rp ( db client , volume ) ; virtual pool virtual pool = db client . query object ( virtual pool . class , source volume . get virtual pool ( ) ) ; volume protection info . set metro point ( virtual pool . v pool specifies metro point ( virtual pool ) ) ; volume protection info list . add ( volume protection info ) ; replication set names . add ( volume . get r ( ) ) ; } if ( ! volume protection info list . is empty ( ) ) { rp . delete replication sets ( volume protection info list ) ; } workflow step completer . step succeded ( token ) ; } catch ( exception e ) { log . error ( string . format ( str , replication set names . to string ( ) ) ) ; return step failed ( token , e , str ) ; } return bool ; }	delete the replication set.
private void move to next ( ) { check main thread ( ) ; scheduled . set ( bool ) ; bitmap next = pending . poll ( ) ; if ( next != null ) { if ( current != null && ! finished . offer ( current ) ) throw new runtime exception ( str ) ; current = next ; invalidate self ( ) ; ensure scheduled ( ) ; frame available subject . on next ( null ) ; fps counter . update ( ) ; } }	called to move to the next frame.
public final long read long ( ) throws java . io . io { read fully ( scratch , num , num ) ; int h = ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) ; int l = ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) | ( ( scratch [ num ] & num ) << num ) ; return ( ( ( long ) h ) << num ) | ( ( long ) l ) & num ; }	see the general contract of the readlong method of datainput.
public void test get columns meta data ( ) throws exception { database meta data dmd = con . get meta data ( ) ; result set rs = dmd . get columns ( null , null , str , null ) ; assert not null ( rs ) ; result set meta data rsmd = rs . get meta data ( ) ; assert not null ( rsmd . get catalog name ( num ) ) ; assert not null ( rsmd . get column class name ( num ) ) ; rsmd . get column count ( ) ; assert true ( num != rsmd . get column display size ( num ) ) ; assert not null ( rsmd . get column label ( num ) ) ; assert not null ( rsmd . get column name ( num ) ) ; rsmd . get column type ( num ) ; assert not null ( rsmd . get column type name ( num ) ) ; rsmd . get precision ( num ) ; rsmd . get scale ( num ) ; assert not null ( rsmd . get schema name ( num ) ) ; assert not null ( rsmd . get table name ( num ) ) ; rsmd . is auto increment ( num ) ; rsmd . is case sensitive ( num ) ; rsmd . is currency ( num ) ; rsmd . is definitely writable ( num ) ; rsmd . is nullable ( num ) ; rsmd . is read only ( num ) ; rsmd . is searchable ( num ) ; rsmd . is signed ( num ) ; rsmd . is writable ( num ) ; rs . close ( ) ; }	test for bug [ 1120168 ] jtds 101 - tds data type 0 invalid .
private log discover log implementation ( string log category ) throws log configuration exception { if ( is diagnostics enabled ( ) ) { log diagnostic ( str ) ; } init configuration ( ) ; log result = null ; string specified log class name = find user specified log class name ( ) ; if ( specified log class name != null ) { if ( is diagnostics enabled ( ) ) { log diagnostic ( str + specified log class name + str ) ; } result = create log from class ( specified log class name , log category , bool ) ; if ( result == null ) { string buffer message buffer = new string buffer ( str ) ; message buffer . append ( specified log class name ) ; message buffer . append ( str ) ; if ( specified log class name != null ) { inform upon similar name ( message buffer , specified log class name , logging impl lo j logger ) ; inform upon similar name ( message buffer , specified log class name , logging impl jd logger ) ; inform upon similar name ( message buffer , specified log class name , logging impl lumberjack logger ) ; inform upon similar name ( message buffer , specified log class name , logging impl simple logger ) ; } throw new log configuration exception ( message buffer . to string ( ) ) ; } return result ; } if ( is diagnostics enabled ( ) ) { log diagnostic ( str + str ) ; } for ( int i = num ; ( i < classes to discover . length ) && ( result == null ) ; ++ i ) { result = create log from class ( classes to discover [ i ] , log category , bool ) ; } if ( result == null ) { throw new log configuration exception ( str ) ; } return result ; }	attempts to create a log instance for the given category name.
public via header create via header ( string host , int port , string transport , string branch ) throws parse exception , invalid argument exception { if ( host == null || transport == null ) throw new null pointer exception ( str ) ; via via = new via ( ) ; if ( branch != null ) via . set branch ( branch ) ; if ( host . index of ( str ) >= num && host . index of ( str ) < num ) { if ( strip address scope zones ) { int zone start = host . index of ( str ) ; if ( zone start != - num ) host = host . substring ( num , zone start ) ; } host = str + host + str ; } via . set host ( host ) ; via . set port ( port ) ; via . set transport ( transport ) ; return via ; }	creates a new viaheader based on the newly supplied uri and branch values .
public string to string ( ) { return super . to string ( ) + str + record map . size ( ) + str + first offset + str + release buffer + str + prefix writes + str + use checksum + str + bytes written ( ) + str + remaining ( ) + str + m removed + str ; }	adds some debugging information .
private object [ ] resolve parameters ( executable executable , optional < object > target , object outer instance , extension context extension context , extension registry extension registry ) { preconditions . not null ( target , str ) ; parameter [ ] parameters = executable . get parameters ( ) ; object [ ] values = new object [ parameters . length ] ; int start = num ; if ( outer instance != null ) { values [ num ] = outer instance ; start = num ; } for ( int i = start ; i < parameters . length ; i ++ ) { parameter context parameter context = new default parameter context ( parameters [ i ] , i , target ) ; values [ i ] = resolve parameter ( parameter context , executable , extension context , extension registry ) ; } return values ; }	resolve the array of parameters for the supplied executable , target , and outer instance .
public static boolean is valid name char ( char c ) { return is valid name start char ( c ) || ( c >= str && c <= str ) ; }	check whether the given char can be one of a name.
protected static boolean id start char ( int ch ) { return ( ch >= str && ch <= str ) || ( ch >= str && ch <= str ) || ( ch == str ) ; }	determine if a character is ok to start an id .
public int hash code ( ) { int fhash = ( family != null ) ? family . hash code ( ) : num ; return fhash ^ style ^ size ; }	returns a hashcode for this font .
private command handler enum ( final command command1 ) { this . command = command1 ; }	enum contructor to set command .
public static boolean is float ( string desc ) { return desc . ends with ( str ) ; }	tells whether a given type is a float.
public void component resized ( component event e ) { j bar = get vertical scroll bar ( ) ; int incr = ( int ) ( get size ( ) . get height ( ) - ( bar . get unit increment ( num ) * num ) ) ; get vertical scroll bar ( ) . set block increment ( incr ) ; }	invoked when the component ' s size changes.
public arg ( string a name , string desc , int expected number of arguments , boolean expect dashed arguments ) { name = a name ; description = desc ; num expected values = expected number of arguments ; c = name . char at ( num ) ; dashed arguments = expect dashed arguments ; }	create an arg with a name and help line description , along with a number of expected arguments to follow this option.
private boolean remove ( object o , object [ ] snapshot , int index ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] current = get array ( ) ; int len = current . length ; if ( snapshot != current ) find index : { int prefix = math . min ( index , len ) ; for ( int i = num ; i < prefix ; i ++ ) { if ( current [ i ] != snapshot [ i ] && eq ( o , current [ i ] ) ) { index = i ; break find index ; } } if ( index >= len ) return bool ; if ( current [ index ] == o ) break find index ; index = index of ( o , current , index , len ) ; if ( index < num ) return bool ; } object [ ] new elements = new object [ len - num ] ; system . arraycopy ( current , num , new elements , num , index ) ; system . arraycopy ( current , index + num , new elements , index , len - index - num ) ; set array ( new elements ) ; return bool ; } finally { lock . unlock ( ) ; } }	a version of remove ( object ) using the strong hint that given recent snapshot contains o at the given index .
public void remove model ( model model ) { models . remove ( model ) ; }	removes the given model from the container .
public void read map ( int map ) { input stream map file ; try { map file = new file input stream ( str + map + str ) ; try { byte [ ] data = new byte [ map file . available ( ) ] ; map file . read ( data ) ; map file . close ( ) ; string load data = new string ( data , str ) ; make map ( load data ) ; } catch ( io e ) { e . print stack trace ( ) ; } } catch ( file not found exception e1 ) { e1 . print stack trace ( ) ; } }	read map information from stage0x . stg.
public static double hoeffding ln ( double trials , double observed , double prob ) { return - num * math . pow ( trials * prob - observed , num ) / trials ; }	get hoeffding probability number , in ln space.
@ override public void on nested pre scroll ( view target , int dx , int dy , int [ ] consumed ) { if ( ( ! m pull refresh enable && ! m pull load enable ) ) { return ; } if ( math . abs ( dy ) > num ) { return ; } if ( ! is confirm ) { if ( dy < num && ! can child scroll up ( ) ) { m current action = pull refresh ; is confirm = bool ; } else if ( dy > num && ! can child scroll down ( ) ) { m current action = load more ; is confirm = bool ; } } if ( move spinner ( - dy ) ) { consumed [ num ] += dy ; } }	with child view to processing move events.
public void test local instances deterministic ( ) { matsim random . reset ( ) ; random local1a = matsim random . get local instance ( ) ; random local1b = matsim random . get local instance ( ) ; matsim random . reset ( ) ; random local2a = matsim random . get local instance ( ) ; random local2b = matsim random . get local instance ( ) ; assert equal random number generators ( local1a , local2a ) ; assert equal random number generators ( local1b , local2b ) ; }	tests that local instances can be recreated ( = are deterministic ) if the same random seed is used to generate them .
public void add ( match match , applied region applied region ) { add ( match , applied region , bool ) ; }	adds a new applied region to the match without a priority .
public void reset ( ) { tech tree . check sub tree ( tech tree . get path for row ( num ) , bool ) ; }	resets the selection the panel by selecting all technologies .
@ suppress warnings ( str ) private static < t > void assert throws ( final consumer < void > consumer , final class < t > exception class , final consumer < t > assert exception properties , final string message ) { final string normalized message = null == message ? str : string . format ( str , message ) ; try { consumer . accept ( null ) ; } catch ( final exception ex ) { if ( exception class . is assignable from ( ex . get class ( ) ) ) { assert exception properties . accept ( ( t ) ex ) ; return ; } assert . fail ( string . format ( str , normalized message , ex . get class ( ) , ex . get message ( ) ) ) ; } assert . fail ( string . format ( str , normalized message , exception class ) ) ; }	asserts that the execution of consumer throws an exception of the specific class .
public boolean is empty ( ) { return nodes . is empty ( ) && ways . is empty ( ) && relations . is empty ( ) ; }	return true if this storage is empty.
public static void assert bool ( boolean b ) { if ( verbose ) { log ( str + b + str ) ; } if ( ! b ) { throw new runtime exception ( ) ; } }	assertions allow for simpler test code.
public tag key value map converter ( boolean null if empty , string id key ) { objects . require non null ( id key ) ; this . null if empty = null if empty ; this . add id = bool ; this . id key = id key ; }	store feature ids using idkey.
private static void post init ( ) { debug all = dbg table . contains key ( debug all token ) ; }	common inits , regardless of applet or application .
private static void attempt retry on exception ( string log prefix , request < ? > request , volley error exception ) throws volley error { retry policy retry policy = request . get retry policy ( ) ; int old timeout = request . get timeout ms ( ) ; try { retry policy . retry ( exception ) ; } catch ( volley error e ) { request . add marker ( string . format ( str , log prefix , old timeout ) ) ; throw e ; } request . add marker ( string . format ( str , log prefix , old timeout ) ) ; }	attempts to prepare the request for a retry.
public static list < file > sort in batch ( file file , comparator < string > cmp ) throws io { return sort in batch ( file , cmp , defaultmaxtempfiles ) ; }	this will simply load the file by blocks of x rows , then sort them in - memory , and write the result to temporary files that have to be merged later .
public void add directory set ( context context , string path ) { db tinydb = new db ( context ) ; array list < string > file = tinydb . get list string ( str ) ; file . add ( path ) ; tinydb . put list string ( str , file ) ; }	add directory to scan for saves avatars.
private fast concurrent skip list map . node < k , v > hi node ( ) { if ( hi == null ) return m . find last ( ) ; else if ( hi inclusive ) return m . find near ( hi , m . lt | m . eq ) ; else return m . find near ( hi , m . lt ) ; }	returns highest node . this node might not be in range , so most usages need to check bounds.
protected static void add id repo amsdk ( sso token , string org name ) throws sms , sso { service config manager scm = new service config manager ( service manager . realm service , token ) ; service config sc = scm . get organization config ( org name , null ) ; map attributes = new hash map ( ) ; set values = new hash set ( ) ; values . add ( str ) ; attributes . put ( str , values ) ; values = new hash set ( ) ; values . add ( dn . realm name to amsdk ( dn . org name to dn ( org name ) ) ) ; attributes . put ( str , values ) ; sc . add sub config ( str , str , num , attributes ) ; }	adds idrepo amsdk plugin to the given organization name.
public static string on key press ( string key ) { pin = pin . concat ( key ) ; return pin ; }	getting the value of key pressed and appending it to current pin.
public boolean is hierachic ( string string ) { int index = string . index of ( m ) ; if ( ( index == ( string . length ( ) - num ) ) || ( index == - num ) ) { return bool ; } return bool ; }	whether the given string has a hierachy structure with the seperators.
public shape paint layer ( graphics g , int offs0 , int offs1 , shape bounds , j c , view view ) { color base = get color ( ) ; color color = base != null ? new color ( base . get red ( ) , base . get green ( ) , base . get blue ( ) , num ) : null ; if ( color == null ) { g . set color ( c . get selection color ( ) ) ; } else { g . set color ( color ) ; } if ( offs0 == view . get start offset ( ) && offs1 == view . get end offset ( ) ) { rectangle alloc ; if ( bounds instanceof rectangle ) { alloc = ( rectangle ) bounds ; } else { alloc = bounds . get bounds ( ) ; } g . fill rect ( alloc . x , alloc . y , c . get width ( ) - alloc . x , alloc . height ) ; } else { try { shape shape = view . model to view ( offs0 , position . bias . forward , offs1 , position . bias . backward , bounds ) ; rectangle r = ( shape instanceof rectangle ) ? ( rectangle ) shape : shape . get bounds ( ) ; g . fill rect ( num , r . y , c . get width ( ) , r . height ) ; return r ; } catch ( bad location exception e ) { } } return null ; }	paints a portion of a highlight .
synchronized void receive ( char one char ) throws io { if ( buffer == null ) { throw new io ( str ) ; } if ( last reader != null && ! last reader . is alive ( ) ) { throw new io ( str ) ; } last writer = thread . current thread ( ) ; try { while ( buffer != null && out == in ) { notify all ( ) ; wait ( num ) ; if ( last reader != null && ! last reader . is alive ( ) ) { throw new io ( str ) ; } } } catch ( interrupted exception e ) { throw new io ( ) ; } if ( buffer == null ) { throw new io ( str ) ; } if ( in == - num ) { in = num ; } buffer [ in ++ ] = one char ; if ( in == buffer . length ) { in = num ; } }	receives a char and stores it into the pipedreader.
public static final byte buffer buffer to byte buffer ( final byte [ ] buffer , final byte order order ) { final byte buffer ret buff = byte buffer . wrap ( buffer ) ; ret buff . order ( order ) ; return ret buff ; }	converts a buffer to a bytebuffer .
public static void write single byte ( output stream out , int b ) throws io { byte [ ] buffer = new byte [ num ] ; buffer [ num ] = ( byte ) ( b & num ) ; out . write ( buffer ) ; }	implements outputstream . write ( int ) in terms of outputstream . write ( byte [ ] , int , int ) . outputstream assumes that you implement outputstream . write ( int ) and provides default implementations of the others , but often the opposite is more efficient .
private uri process local files ( uri uri ) { string uri str = uri . to string ( ) ; if ( uri str . starts with ( str ) ) { uri str = str + system . get property ( str ) + str + uri str . substring ( num ) ; url url ; try { url = new url ( uri str ) ; return url . to uri ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } } return uri ; }	convert local paths into absolute paths for links based on the local file system .
private string generate screen on or off utternace ( int feedback index ) { int resource id = ( feedback index == index screen on ) ? r . string . template screen on : r . string . template screen off ; string template = m context . get string ( resource id ) ; int current ringer volume = m audio manager . get stream volume ( audio manager . stream ring ) ; int max ringer volume = m audio manager . get stream max volume ( audio manager . stream ring ) ; int volume percent = ( num / max ringer volume ) * current ringer volume ; int adjustment = volume percent % num ; if ( adjustment < num ) { volume percent -= adjustment ; } else if ( adjustment > num ) { volume percent += ( num - adjustment ) ; } return string . format ( template , volume percent ) ; }	generates an utterance for announcing screen on and screen off .
public void reset ( ) { count = num ; start time = system . current time millis ( ) ; }	resets the rate sampling .
public int read int ( ) throws io { length += num ; int k1 = in . read ( ) ; if ( k1 < num ) return num ; int k2 = in . read ( ) << num ; int k3 = in . read ( ) << num ; return k1 + k2 + k3 + ( in . read ( ) << num ) ; }	read the next int from the inputstream .
public enumeration list options ( ) { vector new vector = new vector ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void test add issuer ljavax security auth x500 ( ) { crl selector = new crl ( ) ; x500 principal iss1 = new x500 principal ( str ) ; x500 principal iss2 = new x500 principal ( str ) ; crl crl1 = new crl ( iss1 ) ; crl crl2 = new crl ( iss2 ) ; selector . add issuer ( iss1 ) ; assert true ( str , selector . match ( crl1 ) ) ; assert false ( str , selector . match ( crl2 ) ) ; selector . add issuer ( iss2 ) ; assert true ( str , selector . match ( crl2 ) ) ; }	addissuer ( x500principal issuer ) method testing.
public void add transformation ( tag transformation tag transformation ) { if ( tag transformation != null ) { mappings . put ( tag transformation . get source tag ( ) , tag transformation ) ; } }	adds specified tag transformation to the collection .
@ override public boolean is file modified ( long file time stamp , long end offset ) { boolean is file modified = bool ; if ( get last modified time ( ) > file time stamp || get size ( ) > end offset ) { is file modified = bool ; } return is file modified ; }	this method will be used to check whether a file has been modified or not.
public string next string ( ) { next clean ( str ) ; string builder sb = new string builder ( ) ; for ( ; ; ) { char c = next ( ) ; switch ( c ) { case num : case str : case str : throw syntax error ( str ) ; case str : c = next ( ) ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( ( char ) integer . parse int ( next ( num ) , num ) ) ; break ; default : sb . append ( c ) ; } break ; case str : return sb . to string ( ) ; default : if ( c < str ) { throw syntax error ( str + ( ( int ) c ) + str ) ; } sb . append ( c ) ; break ; } } }	return the characters up to the next close quote character.
private void read lyrics3 tag ( file file , random access file new file , int load options ) throws io { }	read lyrics3 tag todo : not working.
public double evaluate ( vector instance x , vector instance y ) throws exception { double dot prod = x . dot product ( y ) ; return math . pow ( m gamma * dot prod + m coef0 , m degree ) ; }	compute the result of the kernel evaluation on the supplied vectors.
private boolean is db configuration present ( ) { return string utils . is not blank ( select column ) && string utils . is not blank ( table name ) ; }	returns whether the database configuration is present or not ( i.
public boolean is incomplete numerical run ( string pin ) { final int len = pin . length ( ) ; int consecutive = num ; char last = pin . char at ( num ) ; for ( int i = num ; i < len ; i ++ ) { final char c = pin . char at ( i ) ; if ( last == c ) { consecutive ++ ; } else { consecutive = num ; } last = c ; if ( consecutive >= num ) { return bool ; } } return bool ; }	tests the string to see if it contains a partial numeric run.
private static void generate java script log alert close window ( writer writer , string message ) throws io { writer . write ( str + message + str ) ; writer . write ( str ) ; writer . write ( str ) ; }	metodo que genera un alert con el mensaje de error y ademas cierra la ventana que se intenta abrir.
public tree < string > extract best max rule parse1 ( int start , int end , int state , list < string > sentence ) { int c state = maxc child [ start ] [ end ] [ state ] ; if ( c state == - num ) { return extract best max rule parse2 ( start , end , state , sentence ) ; } else { list < tree < string > > child = new array list < tree < string > > ( ) ; child . add ( extract best max rule parse2 ( start , end , c state , sentence ) ) ; string state str = ( string ) tag numberer . object ( state ) ; if ( state str . ends with ( str ) ) state str = state str . substring ( num , state str . length ( ) - num ) ; int intermediate node = grammar . get unary intermediate ( ( short ) state , ( short ) c state ) ; if ( intermediate node == num ) { } if ( intermediate node > num ) { list < tree < string > > restored child = new array list < tree < string > > ( ) ; string state str2 = ( string ) tag numberer . object ( intermediate node ) ; if ( state str2 . ends with ( str ) ) state str2 = state str2 . substring ( num , state str2 . length ( ) - num ) ; restored child . add ( new tree < string > ( state str2 , child ) ) ; return new tree < string > ( state str , restored child ) ; } return new tree < string > ( state str , child ) ; } }	returns the best parse for state " state " , potentially starting with a unary rule.
protected void parse dom ( element element ) throws sam { super . parse dom ( element ) ; }	parses attributes of the docuemnt element for this object .
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }	calculates the distance between two given points in the plane .
public void start ( int conditions ) throws io { print ( str , new string [ ] { integer . to binary string ( conditions ) } ) ; printer . flush ( ) ; }	description of the method.
public string pad ( string value , int places , string pad character ) { string builder sb = new string builder ( ) ; sb . append ( value ) ; while ( sb . length ( ) < places ) { sb . append ( pad character ) ; } return sb . to string ( ) ; }	pads spaces onto the end of the value to make it ' places ' long.
private static result code register error result code ( final int int value , final localizable message name , final enum result code enum ) { final result code t = new result code ( int value , name , bool , result code enum ) ; elements . put ( int value , t ) ; return t ; }	creates and registers a new error result code with the application .
public void add all ( exception set other ) { exception set . or ( other . exception set ) ; explicit set . or ( other . explicit set ) ; size = count bits ( exception set ) ; common supertype = null ; }	add all exceptions in the given set .
@ hle @ hle ( nid = num , version = num ) public int sce usb cam start video ( ) { if ( ! setup video ( ) ) { log . warn ( string . format ( str ) ) ; } return num ; }	starts video input from the camera .
protected resource loader license locator ( final charset charset , final string ... license files ) { if ( license files == null || license files . length == num ) { throw new illegal argument exception ( str ) ; } if ( charset == null ) { throw new null pointer exception ( str ) ; } this . license files = new array list < string > ( arrays . as list ( license files ) ) ; this . charset = charset ; }	constructs the license locator with the given license file names.
private static boolean is intended exception ( exception e , class < ? > clazz ) { final string message = e . get message ( ) ; return ( ! text utils . is empty ( message ) && message . starts with ( clazz . get name ( ) ) ) ; }	checks if the exception is one of the intended server side exception that has been thrown over the aidl layer .
@ inject public project type registry ( set < project type def > types ) { project types = new hash map < > ( ) ; validated data = new hash map < > ( ) ; validate ( types ) ; for ( project type def type : validated data . values ( ) ) { try { init ( type ) ; } catch ( project type constraint exception e ) { log . error ( e . get message ( ) ) ; } } }	initialises set of project type definitions.
static public void add notification listener ( jmx jmx connector , class < ? > mbean interface , string mbean name , notification listener notification listener , boolean ignored ) throws instance not found exception , exception { m mbsc = jmx connector . get m ( ) ; object name object name = generate m ( mbean interface . get name ( ) , mbean name ) ; mbsc . add notification listener ( object name , notification listener , null , null ) ; }	attach notificationlistener that can be used to listen notifications emitted by mbean server .
public void test case16 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { num , num , num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two negative numbers of different length.
private void consume ( ) { consumer . subscribe ( topics ) ; while ( running . get ( ) ) { try { consumer records records = consumer . poll ( poll interval ms ) ; if ( records == null ) { continue ; } iterator < consumer record < string , string > > iterator = records . iterator ( ) ; while ( iterator . has next ( ) ) { send message ( iterator . next ( ) ) ; } } catch ( exception ex ) { string error = str ; logger . error ( error , ex ) ; bus . send ( config constants . consumer error topic , get error string ( error , ex . get message ( ) ) ) ; } } }	handles looping and consuming.
private void delete attrs ( svc reg reg , entry rep entry , boolean check dups ) { entry class eclass = entry . eclass ; delete instance ( eclass ) ; object [ ] fields = entry . fields ; if ( fields . length == num ) { array list regs = service by empty attr . get ( eclass ) ; if ( regs == null || ( check dups && has empty attr ( reg , eclass ) ) ) return ; int idx = regs . index of ( reg ) ; if ( idx >= num ) { regs . remove ( idx ) ; if ( regs . is empty ( ) ) service by empty attr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= num ; ) { eclass = get defining class ( eclass , fldidx ) ; hash map [ ] attr maps = service by attr . get ( eclass ) ; if ( attr maps == null || attr maps [ fldidx ] == null || ( check dups && has attr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ; hash map map = attr maps [ fldidx ] ; object value = fields [ fldidx ] ; array list regs = ( array list ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . index of ( reg ) ; if ( idx < num ) continue ; regs . remove ( idx ) ; if ( ! regs . is empty ( ) ) continue ; map . remove ( value ) ; if ( ! map . is empty ( ) ) continue ; attr maps [ fldidx ] = null ; if ( all null ( attr maps ) ) service by attr . remove ( eclass ) ; } }	if checkdups is false , delete the service ( if present ) from servicebyattr under all attribute values of the given entry or from servicebyemptyattr if the entry has no attributes.
public void test dsa ( ) throws exception { algorithm parameters params = algorithm parameters . get instance ( str ) ; assert equals ( str , str , params . get algorithm ( ) ) ; big integer p = big integer . one ; big integer q = big integer . ten ; big integer g = big integer . zero ; params . init ( new dsa ( p , q , g ) ) ; byte [ ] enc = params . get encoded ( ) ; assert not null ( enc ) ; assert not null ( params . get encoded ( str ) ) ; dsa spec = params . get parameter spec ( dsa . class ) ; assert equals ( str , p , spec . get p ( ) ) ; assert equals ( str , q , spec . get q ( ) ) ; assert equals ( str , g , spec . get g ( ) ) ; params = algorithm parameters . get instance ( str ) ; params . init ( enc ) ; assert true ( str , arrays . equals ( enc , params . get encoded ( ) ) ) ; params = algorithm parameters . get instance ( str ) ; params . init ( enc , str ) ; assert true ( str , arrays . equals ( enc , params . get encoded ( ) ) ) ; params = algorithm parameters . get instance ( str ) ; try { params . init ( enc , str ) ; fail ( str ) ; } catch ( io e ) { } }	tests dsa algorithmparameters provider.
public static boolean is class literal possible ( class node class node ) { return modifier . is public ( class node . get modifiers ( ) ) ; }	tells if a class node is candidate for class literal bytecode optimization.
private properties load log file ( license license , boolean create ) { properties log = new properties ( ) ; file log file = get log file ( license ) ; try { if ( create && log file . create new file ( ) ) { logger . fine ( str + log file . get absolute path ( ) ) ; } final input stream in = new file input stream ( log file ) ; try { log . load ( in ) ; } finally { in . close ( ) ; } } catch ( file not found exception ex ) { if ( create ) { logger . log ( level . severe , str + log file . get absolute path ( ) , ex ) ; } else { logger . fine ( str ) ; } } catch ( io ex ) { logger . log ( level . warning , str + log file . get absolute path ( ) , ex ) ; } return log ; }	loads the log file for the given license and returns it .
public html ( map < string , string > args ) { super ( args ) ; escaped tags = get set ( args , str ) ; if ( ! args . is empty ( ) ) { throw new illegal argument exception ( str + args ) ; } }	creates a new htmlstripcharfilterfactory.
public static int update ( long id , v v ) { string passwd = ( string ) v . value ( str ) ; if ( ! x . is empty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( str , passwd , bool ) ; } else { v . remove ( str ) ; } return helper . update ( id , v . set ( str , system . current time millis ( ) ) , user . class ) ; }	update the user by the values , < br > if the values contains " password " field , it will auto encrypt the password field .
public double likelihood ( string [ ] doc , string tag ) { double likelihood = num ; if ( ntw . row sum ( tag ) == num ) { return likelihood ; } counter < string > nwd = new counter < string > ( ) ; for ( string w : doc ) { nwd . inc ( w , num ) ; } double norm = num ; map < string , double > prwd = new hashtable < string , double > ( ) ; for ( entry < string , long > e : nwd ) { double prw = prw ( e . get key ( ) ) ; norm += prw ; prwd . put ( e . get key ( ) , prw ) ; } for ( entry < string , double > e : prwd . entry set ( ) ) { double prw = e . get value ( ) / norm ; likelihood += ptr ( tag , e . get key ( ) ) * prw * ( num - pcm ( ) ) ; } likelihood += ptr ( tag , noise ) * pcm ( ) ; return likelihood ; }	the likelihood of a tag in given document .
@ override public string to string ( ) { string buffer text = new string buffer ( ) ; text . append ( str + attributes to string ( ) + str ) ; text . append ( str + get inst nums ( ) ) ; return text . to string ( ) ; }	make a string from the cluster features .
public boolean is safe mode ( ) { return this . safe mode ; }	check if task will be in safe mode.
public void test get put byte array with offset and length ( ) { final int size = num ; final i buf = new fixed byte array buffer ( size ) ; assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( size - num ) ) ; final int pos = num ; for ( int i = num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next int ( size - num ) ] ; final int off = ( expected . length / num == num ? num : r . next int ( expected . length / num ) ) ; final int len = ( expected . length == num ? num : r . next int ( expected . length - off ) ) ; r . next bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert equals ( num , bytes util . compare bytes with len and offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next int ( num ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert equals ( num , bytes util . compare bytes with len and offset ( off , len , expected , dstoff , len , actual ) ) ; } assert equals ( ( byte ) num , buf . get byte ( num ) ) ; assert equals ( ( byte ) num , buf . get byte ( pos + size - num ) ) ; }	test of the bulk get / put byte [ ] methods which accept a slice into the caller ' s array .
public void add last item ( m model ) { add item ( m datas . size ( ) , model ) ; }	insert data to footer.
static boolean has localized messages ( ) { return gui . is english locale ( ) || ! first message . equals ( i18n . tr ( first message ) ) ; }	determines whether or not the current locale language is english.
public static docker image from image name ( string image name ) { image name = prepare ( image name ) ; string [ ] parts = image name . split ( section separator ) ; switch ( parts . length ) { case num : return from parts ( null , null , parts [ num ] ) ; case num : if ( is valid namespace ( parts [ num ] ) ) { return from parts ( null , parts [ num ] , parts [ num ] ) ; } else { return from parts ( parts [ num ] , null , parts [ num ] ) ; } case num : return from parts ( parts [ num ] , parts [ num ] , parts [ num ] ) ; default : throw new illegal argument exception ( str + image name ) ; } }	parse a full image name ( myhost : 300 / namespace / repo : tag ) into its components.
public synchronized void listen ( final set < notification channel > channel names ) { m channels . add all ( channel names ) ; }	adds the set of channel names to the set of listened channels .
public static void delete directory ( file directory ) throws io { if ( ! directory . exists ( ) ) { return ; } if ( ! is symlink ( directory ) ) { clean directory ( directory ) ; } if ( ! directory . delete ( ) ) { string message = str + directory + str ; throw new io ( message ) ; } }	deletes a directory recursively .
public list < long > delete empty folders ( ) { array list < long > folder ids = new array list < long > ( ) ; sq db = m open helper . get writable database ( ) ; db . begin transaction ( ) ; try { string selection = launcher settings . favorites . item type + str + launcher settings . favorites . item type folder + str + launcher settings . favorites . id + str + launcher settings . favorites . container + str + table favorites + str ; cursor c = db . query ( table favorites , new string [ ] { launcher settings . favorites . id } , selection , null , null , null , null ) ; while ( c . move to next ( ) ) { folder ids . add ( c . get long ( num ) ) ; } c . close ( ) ; if ( folder ids . size ( ) > num ) { db . delete ( table favorites , utilities . create db selection query ( launcher settings . favorites . id , folder ids ) , null ) ; } db . set transaction successful ( ) ; } catch ( sql ex ) { log . e ( tag , ex . get message ( ) , ex ) ; folder ids . clear ( ) ; } finally { db . end transaction ( ) ; } return folder ids ; }	deletes any empty folder from the db .
@ override default completable future < integer > sum int ( final to int function < ? super t > fn ) { return completable future . supply async ( null , get exec ( ) ) ; }	perform an asynchronous sum operation.
public void test write3 ( ) throws exception { byte [ ] data = new byte [ ] { - num , - num , - num , - num , - num , num , num , num , num , num } ; test output stream tos = new test output stream ( ) ; cipher output stream cos = new cipher output stream ( tos , new null cipher ( ) ) ; for ( int i = num ; i < data . length ; i ++ ) { cos . write ( data , i , num ) ; } cos . flush ( ) ; byte [ ] result = tos . to byte array ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( str ) ; } }	write ( byte [ ] b , int off , int len ) method testing .
private document parse ( final string data ) { if ( doc builder == null || data == null ) { return null ; } document document = null ; try { string buf = beginpart + data + endpart ; input source input source = new input source ( new string reader ( buf ) ) ; document = doc builder . parse ( input source ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return document ; }	converts the loggingevent data in xml string format into an actual xml document class instance .
public boolean is production journal ( set < string > production copies , volume volume ) { for ( string production copy : production copies ) { if ( production copy . equals ignore case ( volume . get rp copy name ( ) ) ) { return bool ; } } return bool ; }	checks to see if the volume is a production journal.
private void test pound symbol in column name ( ) throws sql { delete db ( str ) ; connection conn = get connection ( str ) ; statement stat = conn . create statement ( ) ; stat . execute ( str ) ; stat . execute ( str ) ; assert result ( str , stat , str ) ; conn . close ( ) ; }	test the # in a column name for oracle compatibility.
public static string decode ( final string escaped ) throws uri { try { final byte [ ] rawdata = url . decode url ( encoding util . get ascii bytes ( escaped ) ) ; return encoding util . get string ( rawdata , uri . get default protocol charset ( ) ) ; } catch ( final decoder exception e ) { throw new uri ( e . get message ( ) ) ; } }	unescape and decode a given string regarded as an escaped string with the default protocol charset .
void wait before next poll ( int polling interval ) throws interrupted exception { synchronized ( this ) { wait ( polling interval ) ; } if ( ! poll outstanding ) { return ; } log . debug ( str ) ; for ( int i = num ; i < num ; i ++ ) { synchronized ( this ) { wait ( polling interval / num ) ; } log . debug ( str ) ; if ( ! poll outstanding ) { return ; } } }	wait before sending next poll.
protected dimension compute lengths ( string anno text ) { string [ ] lines = util . split lines ( anno text ) ; int line length = num ; for ( string line : lines ) { if ( line . length ( ) > line length ) line length = line . length ( ) ; } return new dimension ( line length + num , lines . length + num ) ; }	determine the number of lines in the annotation text and the length of the longest line .
public static void write image map ( print writer writer , string name , chart rendering info info , tool tip tag fragment generator tool tip tag fragment generator , url url tag fragment generator ) throws io { writer . println ( image map utilities . get image map ( name , info , tool tip tag fragment generator , url tag fragment generator ) ) ; }	writes an image map to the specified writer .
import note builder add message ( import note message . type type , string message ) { if ( ! strings . is null or empty ( message ) ) { messages . add ( new import note message ( type , message ) ) ; } return this ; }	adds a message ( if not null ) to the builder .
public string to xml ( boolean include ns , boolean declare ns ) throws fs { return to xml ( include ns , declare ns , bool ) ; }	returns a string representation of the logout response .
public static list < string > as string list ( collection < ? extends object > objects ) { list < string > list = new array list < > ( ) ; for ( object object : objects ) { list . add ( string . value of ( object ) ) ; } return list ; }	returns a list of strings , where the strings are the result of calling string.
public < e extends t > e min ( iterable < e > iterable ) { iterator < e > iterator = iterable . iterator ( ) ; e min so far = iterator . next ( ) ; while ( iterator . has next ( ) ) { min so far = min ( min so far , iterator . next ( ) ) ; } return min so far ; }	returns the smallest of the specified values according to this ordering.
public synchronized int read ( byte b [ ] , int off , int len ) throws io { if ( len <= num ) return num ; int more space ; synchronized ( lock ) { if ( pos >= present ) pos = present = num ; else if ( pos >= water mark ) { system . arraycopy ( buffer , pos , buffer , num , present - pos ) ; present -= pos ; pos = num ; } int free space = buffer . length - present ; more space = math . max ( free space - requested , num ) ; } if ( more space > num ) manager . send request ( info , more space ) ; synchronized ( lock ) { requested += more space ; while ( ( pos >= present ) && ! disconnected ) { try { lock . wait ( ) ; } catch ( interrupted exception e ) { } } if ( disconnected && pos >= present ) return - num ; int available = present - pos ; if ( len < available ) { system . arraycopy ( buffer , pos , b , off , len ) ; pos += len ; return len ; } else { system . arraycopy ( buffer , pos , b , off , available ) ; pos = present = num ; return available ; } } }	read a subarray of bytes from connection.
public final void put ( string key , int value ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; string new map [ ] = new string [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; int new values [ ] = new int [ m map size ] ; system . arraycopy ( m values , num , new values , num , m first free + num ) ; m values = new values ; } m map [ m first free ] = key ; m values [ m first free ] = value ; m first free ++ ; }	append a string onto the vector .
public static list < item stack > consolidate item stacks ( list < item stack > input stacks ) { list < item stack > output stacks = new array list < item stack > ( ) ; for ( item stack source is : input stacks ) { boolean b found = bool ; for ( item stack dest is : output stacks ) { if ( dest is != null && source is != null && item stack ingredients match ( dest is , source is ) ) { b found = bool ; dest is . stack size += source is . stack size ; } } if ( ! b found ) output stacks . add ( source is . copy ( ) ) ; } return output stacks ; }	take a list of itemstacks and amalgamate where possible . < br >.
public static int how many days old ( long time ) { return ( int ) ( ( system . current time millis ( ) - time ) / date utils . day in millis ) ; }	determines how many days ago time was ( rounded down ) .
protected character is wfxml ( string chardata ) { character ref invalid char ; if ( chardata == null || ( chardata . length ( ) == num ) ) { return null ; } char [ ] dataarray = chardata . to char array ( ) ; int datalength = dataarray . length ; if ( f is xml ) { int i = num ; while ( i < datalength ) { if ( xm . is xm ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - num ] ; if ( xml . is high surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xml . is low surrogate ( ch2 ) && xml . is supplemental ( xml . supplemental ( ch , ch2 ) ) ) { continue ; } } ref invalid char = new character ( ch ) ; return ref invalid char ; } } } else { int i = num ; while ( i < datalength ) { if ( xml . is invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - num ] ; if ( xml . is high surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xml . is low surrogate ( ch2 ) && xml . is supplemental ( xml . supplemental ( ch , ch2 ) ) ) { continue ; } } ref invalid char = new character ( ch ) ; return ref invalid char ; } } } return null ; }	checks if a xml character is well - formed.
public void test zero zero ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for zero and zero.
public final parallel flux < t > do on next ( consumer < ? super t > on next ) { objects . require non null ( on next , str ) ; return do on signal ( this , on next , null , null , null , null , null , null , null ) ; }	call the specified consumer with the current element passing through any ' rail ' .
public void test fill ciic ( ) { char val = str ; char d [ ] = new char [ num ] ; arrays . fill ( d , num , d . length , val ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == val ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == val ) ; try { arrays . fill ( d , num , num , val ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } try { arrays . fill ( d , - num , num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } try { arrays . fill ( d , num , d . length + num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } }	java . util . arrays # fill ( char [ ] , int , int , char ).
protected void add missing ( instances data , int level , boolean predictor missing , boolean class missing ) { int class index = data . class index ( ) ; random random = new random ( num ) ; for ( int i = num ; i < data . num instances ( ) ; i ++ ) { instance current = data . instance ( i ) ; for ( int j = num ; j < data . num attributes ( ) ; j ++ ) { if ( ( ( j == class index ) && class missing ) || ( ( j != class index ) && predictor missing ) ) { if ( math . abs ( random . next int ( ) ) % num < level ) current . set missing ( j ) ; } } } }	add missing values to a dataset .
public < t extends data object > void insert in batches ( list < t > records , int partition size , db client db client , string type ) { list < list < t > > volume partitions = lists . partition ( records , partition size ) ; for ( list < t > partition : volume partitions ) { try { db client . create object ( partition ) ; log . info ( str , partition . size ( ) , type ) ; } catch ( database exception e ) { log . error ( str , type , e ) ; } } }	insert discovered objects in batches.
public void remove on tab selected listener ( on tab selected listener listener ) { if ( listener != null ) { m listeners . remove ( listener ) ; } }	removes the given tab listener from this layout.
public connect uri manager ( list < string > connect uri ) throws thl { this . uri list = connect uri ; if ( connect uri . size ( ) == num ) { throw new thl ( str ) ; } }	creates a new instance with a list of uris .
private void add volumes to parking storage group ( storage system storage , string policy name , set < string > volume device ids ) throws exception { string [ ] tokens = policy name . split ( constants . smis plus regex ) ; cim group path = helper . get volume group based on slo ( storage , storage , tokens [ num ] , tokens [ num ] , tokens [ num ] ) ; if ( group path == null ) { group path = helper . create volume group based on slo ( storage , storage , tokens [ num ] , tokens [ num ] , tokens [ num ] ) ; } cim [ ] in args = helper . get add volumes to masking group input arguments ( storage , group path , volume device ids ) ; cim [ ] out args = new cim [ num ] ; smis job add volumes to sg = new smis synch sub task job ( null , storage . get id ( ) , smis constants . add members ) ; helper . invoke method synchronously ( storage , cim path . get controller config svc path ( storage ) , str , in args , out args , add volumes to sg ) ; }	this method is used for vmax3 to add volumes to parking storage group once volumes are unexported .
public static input stream to input stream ( string input , charset encoding ) { return new byte array input stream ( input . get bytes ( charsets . to charset ( encoding ) ) ) ; }	convert the specified string to an input stream , encoded as bytes using the specified character encoding .
public boolean export pkcs8 ( ) { return jrb pkcs8 . is selected ( ) ; }	has the user chosen to export to pkcs # 8 ?.
public static public key generate public key ( string encoded public key ) { try { byte [ ] decoded key = base64 . decode ( encoded public key ) ; key factory key factory = key factory . get instance ( key factory algorithm ) ; return key factory . generate public ( new x509 encoded key spec ( decoded key ) ) ; } catch ( no such algorithm exception e ) { throw new runtime exception ( e ) ; } catch ( invalid key spec exception e ) { log . e ( tag , str ) ; throw new illegal argument exception ( e ) ; } catch ( base64 decoder exception e ) { log . e ( tag , str ) ; throw new illegal argument exception ( e ) ; } }	generates a publickey instance from a string containing the base64 - encoded public key .
public number tick ( number number , string label , text anchor text anchor , text anchor rotation anchor , double angle ) { super ( number . double value ( ) , label , text anchor , rotation anchor , angle ) ; this . number = number ; }	creates a new tick .
private boolean is stoppable ( ) { return ( is running ( ) && get cache ( ) != null ) ; }	determines whether the server can be stopped in - process , such as when a server is embedded in an application and the serverlauncher api is being used .
private void log ( string message , string level , string level color , print stream ps ) { string builder builder = new string builder ( ) ; if ( ! level . equals ( str ) ) builder . append ( get prefix ( level , level color ) ) ; builder . append ( message ) ; string ts = builder . to string ( ) ; ps . println ( ts ) ; for ( log handler hand : handlers ) hand . on log ( level , message , ts , this ) ; }	log a new message on the selected printstream with the given method and level.
public static boolean is public ( int mod ) { return modifier . is public ( mod ) ; }	returns if modifier is public.
public static map < string , object > create user pref map ( generic value rec ) throws general exception { return add pref to map ( rec , new linked hash map < string , object > ( ) ) ; }	convert a userpreference genericvalue to a userprefmap .
public json append string ( object cont ) { if ( stack . empty ( ) || stack . peek ( ) != operand . array ) { throw new json ( str ) ; } add quoted string ( cont ) ; add separator ( ) ; return this ; }	append a string in quotes.
public static void delete user from authentication info ( authentication info authentication info ) throws server runtime exception { string username = authentication info . get username ( ) ; string password file location = authentication info . get password file location ( ) ; try { properties configuration props = new properties configuration ( password file location ) ; string username in file = props . get string ( username ) ; if ( username in file == null ) { throw new server runtime exception ( message format . format ( str , username ) ) ; } props . clear property ( username ) ; props . save ( ) ; } catch ( org . apache . commons . configuration . configuration exception ce ) { logger . error ( str + authentication info . get password file location ( ) , ce ) ; throw new server runtime exception ( str + ce . get message ( ) ) ; } }	delete a user and password from a file.
public void error ( level level , string message id , string data [ ] , object session ) throws log exception { error ( level , message id , data , session , null ) ; }	logs error messages to the error logs .
public synchronized void remove ( i processor ) { processors . remove ( processor ) ; build final processor ( ) ; }	removes the provided processor from the internal processor queue .
private int end recover animation ( view holder view holder , boolean override ) { final int recover anim size = m recover animations . size ( ) ; for ( int i = recover anim size - num ; i >= num ; i -- ) { final recover animation anim = m recover animations . get ( i ) ; if ( anim . m view holder == view holder ) { anim . m overridden |= override ; if ( ! anim . m ended ) { anim . cancel ( ) ; } m recover animations . remove ( i ) ; return anim . m animation type ; } } return num ; }	returns the animation type or 0 if cannot be found .
public final void add element ( string value ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; string new map [ ] = new string [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } m map [ m first free ] = value ; m first free ++ ; }	append a string onto the vector .
private boolean is method contained ( method m , list < method > wrapper methods ) { string name = m . get name ( ) ; class < ? > [ ] param types = m . get parameter types ( ) ; class < ? > return type = m . get return type ( ) ; for ( method wm : wrapper methods ) { if ( name . equals ( wm . get name ( ) ) && arrays . equals ( param types , wm . get parameter types ( ) ) && return type == wm . get return type ( ) ) { return bool ; } } return bool ; }	returns true it the passed method is contained in the also passed list of methods by also comparing matching parameters .
public void delete node ( node n ) { assert . check ( nodes . contains ( n ) ) ; nodes . remove ( n ) ; notify update ( n , null ) ; }	delete a node from the graph.
void update pressed ( action event e , boolean new route ) { string u name = user name . get text ( ) ; route g = check names ok ( ) ; if ( g == null ) { return ; } g . set user name ( u name ) ; g . clear output turnouts ( ) ; g . clear output sensors ( ) ; g . clear route sensors ( ) ; initialize included list ( ) ; set turnout information ( g ) ; set sensor information ( g ) ; g . set output script name ( script file . get text ( ) ) ; g . set output sound name ( sound file . get text ( ) ) ; set control information ( g ) ; cur route = g ; finish update ( ) ; status1 . set text ( ( new route ? bundle . get message ( str ) : bundle . get message ( str ) ) + str + u name + str + included turnout list . size ( ) + str + bundle . get message ( str ) + str + included sensor list . size ( ) + str + bundle . get message ( str ) + str ) ; }	responds to the update button - update to route table.
public string to string ( ) { return m . to string ( ) ; }	returns a string representation of this object.
private static void check for x ( ) { try { class . for name ( str ) ; m = bool ; } catch ( exception e ) { m = bool ; } }	checks whether the xstream is present in the class path.
public double evaluate ( vector instance x , double [ ] y ) throws exception { vector instance diff = x . subtract ( y ) ; double result = - m gamma * diff . dot product ( diff ) ; return math . exp ( result ) ; }	compute the result of the kernel evaluation on the supplied vectors.
@ override public int batch size ( ) { return batch size ; }	get local batch size for this sequences .
public static final byte [ ] decode url ( byte [ ] bytes ) throws decoder exception { if ( bytes == null ) { return null ; } byte array output stream buffer = new byte array output stream ( ) ; for ( int i = num ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == str ) { buffer . write ( str ) ; } else if ( b == str ) { try { int u = character . digit ( ( char ) bytes [ ++ i ] , num ) ; int l = character . digit ( ( char ) bytes [ ++ i ] , num ) ; if ( u == - num || l == - num ) { throw new decoder exception ( str ) ; } buffer . write ( ( char ) ( ( u << num ) + l ) ) ; } catch ( array index out of bounds exception e ) { throw new decoder exception ( str ) ; } } else { buffer . write ( b ) ; } } return buffer . to byte array ( ) ; }	decodes an array of url safe 7 - bit characters into an array of original bytes.
public void clear ( ) { m attached scrap . clear ( ) ; recycle and clear cached views ( ) ; }	clear scrap views out of this recycler.
public void add data set ( t d ) { if ( d == null ) return ; m y += d . get entry count ( ) ; m y += d . get y ( ) ; if ( m data sets . size ( ) <= num ) { m y = d . get y ( ) ; m y = d . get y ( ) ; if ( d . get axis dependency ( ) == axis dependency . left ) { m left axis max = d . get y ( ) ; m left axis min = d . get y ( ) ; } else { m right axis max = d . get y ( ) ; m right axis min = d . get y ( ) ; } } else { if ( m y < d . get y ( ) ) m y = d . get y ( ) ; if ( m y > d . get y ( ) ) m y = d . get y ( ) ; if ( d . get axis dependency ( ) == axis dependency . left ) { if ( m left axis max < d . get y ( ) ) m left axis max = d . get y ( ) ; if ( m left axis min > d . get y ( ) ) m left axis min = d . get y ( ) ; } else { if ( m right axis max < d . get y ( ) ) m right axis max = d . get y ( ) ; if ( m right axis min > d . get y ( ) ) m right axis min = d . get y ( ) ; } } m data sets . add ( d ) ; handle empty axis ( get first left ( ) , get first right ( ) ) ; }	adds a dataset dynamically .
public void end element ( string element name ) throws sax { if ( m first tag not emitted ) { flush ( ) ; } m handler . end element ( element name ) ; }	pass the call on to the underlying handler.
public vlc ( array list < string > options ) { boolean set aout = bool , set chroma = bool ; if ( options != null ) { for ( string option : options ) { if ( option . starts with ( str ) ) set aout = bool ; if ( option . starts with ( str ) ) set chroma = bool ; if ( ! set aout && ! set chroma ) break ; } } if ( set aout || set chroma ) { if ( options == null ) options = new array list < string > ( ) ; if ( set aout ) { final hw . audio output hw aout = hw . get audio output from device ( ) ; if ( hw aout == hw . audio output . opensles ) options . add ( str ) ; else options . add ( str ) ; } if ( set chroma ) { options . add ( str ) ; options . add ( str ) ; } } native new ( options . to array ( new string [ options . size ( ) ] ) ) ; }	create a libvlc withs options.
public fps add child at ( int location , @ non null display base display base ) { display base . set up ( m fps ) ; m display list . add ( location , display base ) ; return this ; }	adds a child to the display list at the specified index , bumping children at equal or greater indexes up one , and setting its parent to this container.
public static int min path sum ( int [ ] [ ] grid ) { if ( grid == null || grid . length == num ) return num ; int m = grid . length ; int n = grid [ num ] . length ; int [ ] row sum = new int [ n ] ; row sum [ num ] = grid [ num ] [ num ] ; for ( int col = num ; col < n ; col ++ ) row sum [ col ] = row sum [ col - num ] + grid [ num ] [ col ] ; for ( int row = num ; row < m ; row ++ ) { row sum [ num ] += grid [ row ] [ num ] ; for ( int col = num ; col < n ; col ++ ) { row sum [ col ] = math . min ( row sum [ col - num ] , row sum [ col ] ) + grid [ row ] [ col ] ; } } return row sum [ n - num ] ; }	dp . bottom - up row by row , use an array to store values.
public time ( date time ) { simple time zone tz = new simple time zone ( num , str ) ; simple date format date f = new simple date format ( str ) ; date f . set time zone ( tz ) ; string d = date f . format ( time ) + str ; int year = integer . parse int ( d . substring ( num , num ) ) ; if ( year < num || year > num ) { this . time = new der ( d ) ; } else { this . time = new derutc ( d . substring ( num ) ) ; } }	creates a time object from a given date - if the date is between 1950 and 2049 a utctime object is generated , otherwise a generalizedtime is used .
public d ( j parent ) { super ( parent , dialog . modality type . document modal ) ; init components ( ) ; }	creates a new dcheckupdate dialog .
public static automaton minimize simple ( automaton a ) { set < integer > initial set = new hash set < integer > ( ) ; a = determinize simple ( operations . reverse ( a , initial set ) , initial set ) ; initial set . clear ( ) ; a = determinize simple ( operations . reverse ( a , initial set ) , initial set ) ; return a ; }	simple , original brics implementation of brzozowski minimize ( ).
@ override public boolean equals ( object o ) { if ( this == o ) return bool ; if ( o == null || get class ( ) != o . get class ( ) ) return bool ; abstract item < ? , ? > that = ( abstract item < ? , ? > ) o ; return m identifier == that . m identifier ; }	if this item equals to the given object.
public void add column ( column column ) { if ( column != null ) { columns . add ( column ) ; } }	adds the given column .
private boolean check for na ns ( number vector vec ) { for ( int i = num , d = vec . get dimensionality ( ) ; i < d ; i ++ ) { double v = vec . double value ( i ) ; if ( v != v ) { return bool ; } } return bool ; }	check for nan values .
public static void fill ( string builder strb , int offset ) { while ( strb . length ( ) < offset ) strb . append ( str ) ; }	fills a string buffer with spaces until it has at least the given length.
public void open for write ( ) throws event exception { file f = new file ( config utils . get initial property expanded ( m address . get pathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . create new file ( ) ; } else { logger . info ( str + m address . get pathname ( ) ) ; } } catch ( io ioe ) { throw new event exception ( str + m address . get pathname ( ) + str + ioe ) ; } try { m fos = new file output stream ( f , bool ) ; } catch ( file not found exception fnfe ) { throw new event exception ( str + m address . get pathname ( ) + str + fnfe ) ; } }	open the file with appending mode.
@ override public double calculate k ( int [ ] x index , double [ ] x att , int [ ] y index , double [ ] y att ) { return ( math . exp ( gamma * norm2 ( x index , x att , y index , y att ) ) ) ; }	calculates kernel value of vectors x and y .
@ override public void close ( ) throws io { throwable thrown = null ; try { flush ( ) ; } catch ( throwable e ) { thrown = e ; } try { out . close ( ) ; } catch ( throwable e ) { if ( thrown == null ) { thrown = e ; } } }	closes this stream . this implementation closes the target stream .
public static void write fofn ( final file destination , final list < file > files ) throws io { final buffered writer bw = new buffered writer ( new file writer ( destination ) ) ; try { for ( final file file : files ) { bw . write ( wrap arg ( file . get absolute path ( ) ) ) ; bw . new line ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }	takes a list of files and writes it as a " file of file names " ( i.
void mark internal classes ( ) { for ( int i = m class defs . length - num ; i >= num ; i -- ) { m type ids [ m class defs [ i ] . class idx ] . internal = bool ; } for ( int i = num ; i < m type ids . length ; i ++ ) { string class name = m strings [ m type ids [ i ] . descriptor idx ] ; if ( class name . length ( ) == num ) { m type ids [ i ] . internal = bool ; } else if ( class name . char at ( num ) == str ) { m type ids [ i ] . internal = bool ; } } }	sets the " internal " flag on type ids which are defined in the dex file or within the vm ( e.
public final double cos ( ) { return math . cos ( this . radians ) ; }	obtains the cosine of this angle .
public static double ss error ( double [ ] predicted values , double [ ] target attribute ) { double ret = num ; for ( int i = num ; i < predicted values . length ; i ++ ) { ret += math . pow ( target attribute [ i ] - predicted values [ i ] , num ) ; } return ret ; }	how much of the variance is not explained by the regression.
public int size ( ) { return prefixes . size ( ) ; }	this returns the number of available namespaces .
@ override public writer append ( char sequence value ) { builder . append ( value ) ; return this ; }	append a character sequence to this writer .
public static string timestamp ( date time ts ) { return long . to string ( ts . get millis ( ) / num ) ; }	convert a timestamp to the string representation that wavefront will accept .
public string consume ( string name , boolean required ) throws parse exception { if ( name == null ) { if ( content == null && required ) { throw new parse exception ( core error domain . err . missing required content ) ; } content consumed = bool ; return content ; } string value = attrs . get ( name ) ; if ( value == null ) { if ( required ) { parse exception pe = new parse exception ( core error domain . err . missing attribute ) ; pe . set internal reason ( str + name + str ) ; throw pe ; } return null ; } attrs . remove ( name ) ; return value ; }	gets the value of an attribute and remove it from the list .
public int copy ( byte [ ] bytes , int at ) { system . arraycopy ( this . bytes , num , bytes , at , this . length ) ; return at + this . length ; }	copy the contents of this kim to a byte array .
public void import key ( ec key ) { lock . lock ( ) ; try { check key encryption state matches ( key ) ; if ( has key ( key ) ) return ; import key locked ( key ) ; queue on keys added ( immutable list . of ( key ) ) ; } finally { lock . unlock ( ) ; } }	imports a key to the key chain.
public connection group tree ( user context user context , connection group root , list < object permission . type > permissions ) throws guacamole exception { this . root api = new api ( root ) ; retrieved groups . put ( root . get identifier ( ) , this . root api ) ; user self = user context . self ( ) ; this . connection permissions = self . get connection permissions ( ) ; this . sharing profile permissions = self . get sharing profile permissions ( ) ; this . connection directory = user context . get connection directory ( ) ; this . connection group directory = user context . get connection group directory ( ) ; this . sharing profile directory = user context . get sharing profile directory ( ) ; add connection group descendants ( collections . singleton ( root ) , permissions ) ; }	creates a new connection group tree using the given connection group as the tree root .
private boolean contains single metric ( buffered reader reader ) throws format parse exception { try { reader . mark ( num ) ; char first char = ( char ) reader . read ( ) ; reader . reset ( ) ; return first char == str ; } catch ( io e ) { throw new format parse exception ( str , e ) ; } }	determines if the given reader contains a single or multiple metrics .
private string separe meta tags content ( string content ) { string result = utils . preg match ( content , constants . metatag content pattern , num ) ; return html decode ( result ) ; }	gets content from metatag.
@ override public void remove columns ( column ... columns ) { for ( column c : columns ) { column list . remove ( c ) ; } }	removes the given columns.
private void read service config ( ) throws sso , sms { if ( debug . message enabled ( ) ) { debug . message ( str ) ; } sso internal token = ( sso ) access controller . do privileged ( admin token action . get instance ( ) ) ; service schema manager = new service schema manager ( n settings service name , internal token ) ; service schema gsc = service schema manager . get global schema ( ) ; raw service data = gsc . get attribute defaults ( ) ; }	read g11nsettings service config data from sms.
public void refresh preferences ( context context ) { if ( m enabled res id != num ) { final shared preferences prefs = preference manager . get default shared preferences ( context ) ; if ( ! prefs . get boolean ( context . get string ( m enabled res id ) , m enabled default ) ) { set trigger keys ( collections . < long > empty set ( ) ) ; return ; } } set trigger keys ( key combo preference . get key codes for preference ( context , m assigned keys res id ) ) ; }	read key mapping from default preferences for context.
void add inherited types ( type mirror type mirror , types types utils ) { if ( ! compiler utils . type mirror in collection ( inherited types , type mirror , types utils ) ) { inherited types . add ( type mirror ) ; } }	add the types that are inherited by this class .
public static histogram multiply ( histogram x , double y ) { return x . modify event counters ( null ) ; }	multiply histogram by scalar .
public void add cache participants ( map < uuid , ignite uuid > all participants , map < uuid , ignite uuid > added participants ) { ver store . add participants ( all participants , added participants ) ; }	adds participants to all shared deployments .
public static string to json ( map map ) { final string writer writer = new string writer ( ) ; try { write json ( map , writer ) ; return writer . to string ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	convert a map to json text.
public void print context ( print stream out ) { out . println ( get message ( ) ) ; out . print ( context ) ; }	prints the message and context .
public int size ( ) { return methods . size ( ) ; }	returns the number of method invoked so far .
private void store request id ( string request id , string key ) { request ids . put ( request id , key ) ; }	helper method to associate request ids to shared preference keys.
private void savepost mni ( string mnipost location , string mnipost resp location , list manage name id list , com . sun . identity . saml2 . jaxb . metadata . object factory obj fact ) throws jaxb { if ( mnipost location != null && mnipost location . length ( ) > num ) { id sls elem post = obj fact . create manage name id ( ) ; sls elem post . set binding ( http post binding ) ; sls elem post . set location ( mnipost location ) ; sls elem post . set response location ( mnipost resp location ) ; manage name id list . add ( sls elem post ) ; } }	saves the post managenameid service .
public static boolean go to update page ( context context ) { final uri play store uri = uri . parse ( str + context . get package name ( ) ) ; fresh air log . i ( str + play store uri . to string ( ) ) ; final intent play store intent = new intent ( intent . action view , play store uri ) ; final package manager package manager = context . get package manager ( ) ; for ( resolve info resolve info : package manager . query intent activities ( play store intent , num ) ) { final activity info resolve activity = resolve info . activity info ; final string resolve package name = resolve activity . package name ; if ( resolve package name . equals ( str ) ) { fresh air log . i ( str ) ; play store intent . set component ( new component name ( resolve package name , resolve activity . name ) ) ; context . start activity ( play store intent ) ; return bool ; } } fresh air log . e ( str + play store uri . to string ( ) ) ; return bool ; }	attempts to start the play store activity for the update page of this app , and returns success or failure .
public i create element ( class scope scope , i unit , hash set existing elements , hash map known scopes ) { return create element ( scope , scope . reference context . source start , unit , existing elements , known scopes ) ; }	returns a handle denoting the class member identified by its scope .
public static list < string > to relative files ( @ not null virtual file root , @ not null final collection < virtual file > files ) { array list < string > rc = new array list < string > ( files . size ( ) ) ; for ( virtual file file : files ) { rc . add ( relative path ( root , file ) ) ; } return rc ; }	covert list of files to relative paths.
synchronized static void ensure security manager ( ) { if ( system . get security manager ( ) == null ) { system . set security manager ( new rmi ( ) ) ; } }	utility routine that sets a security manager if one isn ' t already present .
public static big decimal rate ( int p c id , int p c id , timestamp p , int p c id , int p ad id , int p ad id ) throws sql { if ( p c id == p c id ) return adempiere . one ; timestamp conversion date = p ; if ( conversion date == null ) conversion date = new timestamp ( system . current time millis ( ) ) ; conversion date = adempiere . trunc ( conversion date ) ; int c id = p c id ; if ( c id == num ) { string sql = str + str + str + str + str ; c id = adempiere . get sql ( sql , p ad id ) ; } big decimal rate = null ; string sql = str + str + str + str + str + str + str + str ; prepared statement pstmt = adempiere . prepare statement ( sql ) ; pstmt . set int ( num , p c id ) ; pstmt . set int ( num , p c id ) ; pstmt . set int ( num , c id ) ; pstmt . set timestamp ( num , conversion date ) ; pstmt . set timestamp ( num , conversion date ) ; pstmt . set int ( num , p ad id ) ; pstmt . set int ( num , p ad id ) ; result set rs = pstmt . execute query ( ) ; if ( rs . next ( ) ) { rate = rs . get big decimal ( num ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( rate == null ) return null ; return rate ; }	get conversion rate . previously : c_currency_rate - now : currencyrate.
public static socket do interaction ( final url client connection , final server socket server socket , final int response code , final boolean do authentication ) throws throwable { client connection . set do input ( bool ) ; client connection . set connect timeout ( timeout ) ; client connection . set read timeout ( timeout ) ; server work server = new server work ( server socket , response code , do authentication ) ; client connection work client = new client connection work ( client connection ) ; executor service executor service = executors . new fixed thread pool ( num ) ; try { future < void > server future = executor service . submit ( server ) ; future < void > client future = executor service . submit ( client ) ; throwable t = null ; try { server future . get ( num , time unit . seconds ) ; } catch ( execution exception e ) { t = e . get cause ( ) ; } try { client future . get ( num , time unit . seconds ) ; } catch ( execution exception e ) { if ( t != null ) { t . print stack trace ( ) ; } t = e . get cause ( ) ; } if ( t != null ) { throw t ; } } catch ( execution exception e ) { throw e . get cause ( ) ; } finally { executor service . shutdown ( ) ; } return server . peer socket ; }	performs interaction between client ' s httpsurlconnection and servers side ( serversocket ).
public static snmp engine id create engine id ( int port ) throws unknown host exception { int suniana = num ; inet address address = null ; address = inet address . get local host ( ) ; return create engine id ( address , port , suniana ) ; }	generates a unique engine id.
public static list < rule > parse referential ( string path ) { ruleset ruleset = delphi rules utils . build rule set from xml ( delphi rules utils . get configuration from file ( path ) ) ; list < rule > rules repository = new array list < rule > ( ) ; for ( delphi rule f rule : ruleset . get rules ( ) ) { rules repository . add ( create repository rule ( f rule ) ) ; } return rules repository ; }	parses rules xml file.
public org . w3c . dom . document encrypt and replace wss ( org . w3c . dom . document doc , java . util . map elm map , java . lang . string enc data enc alg , int enc data enc alg strength , string cert alias , int kek strength , java . lang . string token type , java . lang . string provider id ) throws encryption exception { return null ; }	encrypts the given wss xml element in a given xml context document .
public void add issue ( int reason , e obj , int feature id ) { issues . add ( new transformation issue ( reason , obj , feature id , null ) ) ; }	add an issue during transformation.
public void insert child ( node node , int index ) { node . detach from parent ( ) ; node . parent node = this ; try { init child nodes ( node ) ; child nodes . add ( index , node ) ; } catch ( index out of bounds exception ignore ) { throw new dom ( str + index ) ; } reindex children ( ) ; }	inserts node at given index .
private static byte [ ] ntlm hash ( final string password ) throws authentication exception { try { final byte [ ] unicode password = password . get bytes ( str ) ; final m md4 = new m ( ) ; md4 . update ( unicode password ) ; return md4 . get output ( ) ; } catch ( unsupported encoding exception e ) { throw new authentication exception ( str + e . get message ( ) , e ) ; } }	creates the ntlm hash of the user ' s password .
private boolean between zero and one ( final string param name , final double val ) { if ( ( val < num ) || ( val > num ) ) { j . show message dialog ( null , param name + str , str , j . warning message ) ; return bool ; } return bool ; }	helper method to check that a value is between 0 and 1 and display a warning if not .
public abstract string substitute macros ( string parameter value , macro handler mh ) throws undefined parameter error ;	this method operates on the internal string representation of parameter values and replaces macro expressions of the form % { macroname } .
public void pow equals ( double exp ) { for ( int i = num ; i < a . length ; i ++ ) for ( int j = num ; j < a [ i ] . length ; j ++ ) a [ i ] [ j ] = math . pow ( a [ i ] [ j ] , exp ) ; }	x . powequals ( ) calculates the power of each element of the matrix . the result is stored in this matrix object again .
private static list < string > split camel case ( string class name ) { string remaining = class name ; list < string > result = new array list < string > ( ) ; while ( ! remaining . is empty ( ) ) { boolean found = bool ; for ( int i = num ; i < remaining . length ( ) ; i ++ ) { if ( character . is upper case ( remaining . char at ( i ) ) ) { result . add ( remaining . substring ( num , i ) ) ; remaining = remaining . substring ( i ) ; found = bool ; break ; } } if ( ! found ) { result . add ( remaining ) ; remaining = str ; } } return result ; }	converts a name like " outputbyteinputtablecodingloop " to a list of words : { " output " , " byte " , " input " , " table " , " coding " , " loop " }.
public static node list select node list ( node doc , string str , namespace context nsctx ) throws x { x xpf = xpath factory cache . get instance for current thread ( ) ; x xpath = xpf . new x ( ) ; xpath . set namespace context ( nsctx ) ; x expr = xpath . compile ( str ) ; return ( node list ) expr . evaluate ( doc , x . nodeset ) ; }	use an xpath string to select a nodelist namespace prefix is resolved using the the specified context .
public result entry ( nondominated population population , typed properties properties ) { this ( population , properties == null ? null : properties . get properties ( ) ) ; }	constructs a result file entry with the specified non - dominated population and auxiliary properties .
private void generate discovery ( ) throws sax { handler . start element ( str , locators , locators , empty ) ; generate locators ( ) ; handler . end element ( str , locators , locators ) ; }	generates xml for locators in the distributed system.
protected basic type ( class < t > type , int sql type ) { super ( type , sql type ) ; check null = ! type . is primitive ( ) ; }	instantiates a new type instance .
@ override public void action performed ( action event e ) { }	close window ( or reload page if in debug mode ).
public void apply properties ( ) { for ( parameter type type : all parameter types ) { string value = all parameter values . get property ( type . get key ( ) ) ; parameter service . set parameter value ( type , value ) ; } }	applies the properties without saving them .
private void rotate left ( node < k , v > root ) { node < k , v > left = root . left ; node < k , v > pivot = root . right ; node < k , v > pivot left = pivot . left ; node < k , v > pivot right = pivot . right ; root . right = pivot left ; if ( pivot left != null ) { pivot left . parent = root ; } replace in parent ( root , pivot ) ; pivot . left = root ; root . parent = pivot ; root . height = math . max ( left != null ? left . height : num , pivot left != null ? pivot left . height : num ) + num ; pivot . height = math . max ( root . height , pivot right != null ? pivot right . height : num ) + num ; }	rotates the subtree so that its root ' s right child is the new root .
public void add ( cluster node new node ) { if ( node != null ) { nodes = new array list < > ( num ) ; nodes . add ( node ) ; node = null ; } nodes . add ( new node ) ; }	add node to the group .
public boolean check if backup set exists ( string set name ) { validate not null or empty ( set name ) ; try { file file = new file ( get backup root ( ) , set name ) ; if ( file . exists ( ) ) { return bool ; } } catch ( exception e ) { log . error ( str ) ; } return bool ; }	check to see if the given backup set already exists in the backup store .
public static string [ ] to quoted and comma separated array ( string str ) throws io { linked list < string > values = new linked list < string > ( ) ; stream tokenizer tt = new stream tokenizer ( new string reader ( str ) ) ; tt . word chars ( str , str ) ; tt . word chars ( str , str ) ; tt . word chars ( num + num , num ) ; tt . whitespace chars ( num , str ) ; tt . quote char ( str ) ; tt . quote char ( str ) ; while ( tt . next token ( ) != stream tokenizer . tt eof ) { switch ( tt . ttype ) { case stream tokenizer . tt word : case str : case str : values . add ( tt . sval ) ; break ; } } return values . to array ( new string [ values . size ( ) ] ) ; }	returns a value as a string array.
public void write string no compression ( string str ) throws io { if ( str == null ) { write int ( num ) ; } else { write int ( str . length ( ) ) ; for ( int i = num ; i < str . length ( ) ; i ++ ) io . write ( ( byte ) str . char at ( i ) ) ; } }	write a string without compression.
public smart thresholds parse ( final resource threshold file resource ) throws io { final smart thresholds holder = new smart thresholds ( ) ; buffered reader reader = null ; try { reader = new buffered reader ( new input stream reader ( threshold file resource . get input stream ( ) ) ) ; string line ; while ( ( line = reader . read line ( ) ) != null ) { if ( line . starts with ( str ) ) { string [ ] line input = line . split ( str ) ; holder . add threshold ( new smart threshold ( line input ) ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } } return holder ; }	returns a map of model accession to a threshold record .
public void shutdown ( ) { executor service executor = executors . new scheduled thread pool ( num ) ; executor . submit ( create shutdown ( num ) ) ; }	shutdown all attached resources without waiting on the thread.
@ override public point drawing to view ( d . double p ) { return new point ( ( int ) ( p . x * scale factor ) - translation . x , ( int ) ( p . y * scale factor ) - translation . y ) ; }	converts drawing coordinates to view coordinates .
protected void on connect ( ) { }	this method is called once the pircbot has successfully connected to the irc server.
public void add descriptor ( final setup descriptor desc ) { descriptors . add ( desc ) ; }	add a setup descriptor .
public static string compile progress success action ( string progress success action ) throws template model exception { environment env = common ftl util . get current environment ( ) ; return compile progress success action ( progress success action , context ftl util . get request ( env ) , context ftl util . get response ( env ) ) ; }	compiles a progress success action.
public static string join ( string separator , float ... elements ) { if ( elements == null || elements . length == num ) { return str ; } list < number > list = new array list < number > ( elements . length ) ; for ( float elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }	returns a string with all float values concatenated by a specified separator .
public static void put unsigned byte ( byte buffer bb , short v ) { bb . put ( ( byte ) ( v & num ) ) ; }	put an unsigned byte into the specified bytebuffer at the current position.
public static int num of parameters ( string desc ) { int n = num ; int i = num ; for ( ; ; ) { char c = desc . char at ( i ) ; if ( c == str ) break ; while ( c == str ) c = desc . char at ( ++ i ) ; if ( c == str ) { i = desc . index of ( str , i ) + num ; if ( i <= num ) throw new index out of bounds exception ( str ) ; } else ++ i ; ++ n ; } return n ; }	returns the number of the prameters included in the given descriptor .
@ override public trie optimize ( trie orig ) { list < char sequence > cmds = orig . cmds ; list < row > rows = new array list < > ( ) ; list < row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - num ; j >= num ; j -- ) { row now = new remap ( orows . get ( j ) , remap ) ; boolean merged = bool ; for ( int i = num ; i < rows . size ( ) ; i ++ ) { row q = merge ( now , rows . get ( i ) ) ; if ( q != null ) { rows . set ( i , q ) ; merged = bool ; remap [ j ] = i ; break ; } } if ( merged == bool ) { remap [ j ] = rows . size ( ) ; rows . add ( now ) ; } } int root = remap [ orig . root ] ; arrays . fill ( remap , - num ) ; rows = remove gaps ( root , rows , new array list < row > ( ) , remap ) ; return new trie ( orig . forward , remap [ root ] , cmds , rows ) ; }	optimize ( remove empty rows ) from the given trie and return the resulting trie .
public boolean is all denied ( ) { int count = num ; for ( int i = num ; i < m perms . size ( ) ; i ++ ) { if ( m perms . get ( m user permission . get ( i ) ) == package manager . permission denied ) count ++ ; } return count == m perms . size ( ) ; }	is all denied boolean .
public string to string key ( ) { string result ; int i ; result = str + str ; for ( i = num ; i < get col count ( ) ; i ++ ) { if ( get col hidden ( i ) ) continue ; result += str + str + ( i + num ) + str + str + remove filter name ( m [ i ] ) + str + str ; } result += str ; return result ; }	returns returns a key for all the col names , for better readability if the names got cut off .
private date time formatter to formatter ( locale locale , resolver style resolver style , chronology chrono ) { objects . require non null ( locale , str ) ; while ( active . parent != null ) { optional end ( ) ; } composite printer parser pp = new composite printer parser ( printer parsers , bool ) ; return new date time formatter ( pp , locale , decimal style . standard , resolver style , null , chrono , null ) ; }	completes this builder by creating the formatter .
protected void wait for external store mount ( ) throws exception { string ext storage state = environment . get external storage state ( ) ; int current wait time = num ; while ( ! ext storage state . equals ( environment . media mounted ) ) { log . i ( log tag , str ) ; current wait time = timeout wait ( current wait time , default wait poll time , default max wait time , str ) ; ext storage state = environment . get external storage state ( ) ; } }	synchronously waits for external store to be mounted ( eg : sd card ) .
public final void push ( node value ) { int ff = m first free ; if ( ( ff + num ) >= m map size ) { if ( null == m map ) { m map = new node [ m blocksize ] ; m map size = m blocksize ; } else { m map size += m blocksize ; node new map [ ] = new node [ m map size ] ; system . arraycopy ( m map , num , new map , num , ff + num ) ; m map = new map ; } } m map [ ff ] = value ; ff ++ ; m first free = ff ; }	append a node onto the vector .
public boolean upload and install apk ( @ not null i device , @ not null string package name , @ not null file local file , @ not null launch status launch status ) { if ( ! needs install ( device , local file , package name ) ) { return bool ; } string remote path = str + package name ; my printer . stdout ( str + local file + str + remote path ) ; try { device . push file ( local file . get path ( ) , remote path ) ; boolean installed = install app ( device , remote path , package name , launch status ) ; if ( installed ) { my installed apk cache . set installed ( device , local file , package name ) ; } return installed ; } catch ( exception e ) { my printer . stderr ( e . to string ( ) ) ; return bool ; } }	installs the given apk on the device .
public static byte array list read as bytes ( input stream is ) throws io { byte array list buf = new byte array list ( ) ; byte [ ] b = new byte [ num ] ; int nread = - num ; while ( ( nread = is . read ( b ) ) >= num ) { buf . add ( b , num , nread ) ; } return buf ; }	reads an input stream into a list of byte values .
public static int uninstall silent ( context context , string package name ) { return uninstall silent ( context , package name , bool ) ; }	uninstall package and clear data of app silent by root.
public void open ( final long [ ] list , final int position ) { launch player activity = bool ; synchronized ( this ) { if ( m shuffle mode == shuffle auto ) { m shuffle mode = shuffle normal ; } final long old id = get audio id ( ) ; final int listlength = list . length ; boolean newlist = bool ; if ( m play list len == listlength ) { newlist = bool ; for ( int i = num ; i < listlength ; i ++ ) { if ( list [ i ] != m play list [ i ] ) { newlist = bool ; break ; } } } if ( newlist ) { add to play list ( list , - num ) ; notify change ( queue changed ) ; } if ( position >= num ) { m play pos = position ; } else { m play pos = m shuffler . next int ( m play list len ) ; } m history . clear ( ) ; open current and next ( ) ; if ( old id != get audio id ( ) ) { notify change ( meta changed ) ; } } }	opens a list for playback.
public builder names ( final string ... names ) { return names ( arrays . as list ( names ) ) ; }	adds the provided user friendly names .
public void test negative reverse step by one with closure ( ) { final list call log = new array list ( ) ; final closure closure = new recording closure ( call log ) ; final range range = create range ( num , num ) ; range . step ( - num , closure ) ; assert equals ( str , num , call log . size ( ) ) ; final iterator iter = call log . iterator ( ) ; for ( int i = num ; i <= num ; i ++ ) { assert equals ( str , create value ( i ) , iter . next ( ) ) ; } }	tests stepping backwards through a reversed range with a closure .
public static big decimal normalize decimal value ( big decimal big decimal , int allowed precision ) { if ( big decimal . precision ( ) > allowed precision ) { return null ; } return big decimal ; }	this method will check the digits before dot with the max precision allowed.
protected static node deserialize string ( string doc ) { try { string reader reader = new string reader ( doc ) ; stream source source = new stream source ( reader ) ; dom result = new dom ( ) ; transformer factory tf = transformer factory . new instance ( ) ; transformer transformer = tf . new transformer ( ) ; transformer . set output property ( output keys . encoding , default encoding ) ; transformer . set output property ( output keys . indent , default indent ) ; transformer . transform ( source , result ) ; return result . get node ( ) ; } catch ( throwable e ) { log . log ( level . severe , str , e ) ; } return null ; }	this method deserializes the supplied document .
public static string append ( final char sequence url , final object ... params ) { final string base url = url . to string ( ) ; if ( params == null || params . length == num ) return base url ; if ( params . length % num != num ) throw new illegal argument exception ( str ) ; final string builder result = new string builder ( base url ) ; add path separator ( base url , result ) ; add param prefix ( base url , result ) ; object value ; result . append ( params [ num ] ) ; result . append ( str ) ; value = params [ num ] ; if ( value != null ) result . append ( value ) ; for ( int i = num ; i < params . length ; i += num ) { result . append ( str ) ; result . append ( params [ i ] ) ; result . append ( str ) ; value = params [ i + num ] ; if ( value != null ) result . append ( value ) ; } return result . to string ( ) ; }	append given name / value pairs as query parameters to the base url < p > the params argument is interpreted as a sequence of name / value pairs so the given number of params must be divisible by 2 .
public void send event to agent ( final string event ) { synchronized ( event socket ) { event writer . print ( event ) ; event writer . flush ( ) ; } }	sends a message to the testrunneragent.
private void apply jms ( hash map < string , string > filters ) { string writer writer = new string writer ( ) ; print writer print writer = new print writer ( writer ) ; print writer . println ( ) ; for ( string str : get queue list ( ) ) { print writer . println ( str + str + str ) ; } for ( string str : get topic list ( ) ) { print writer . println ( str + str + str ) ; } filters . put ( str , writer . to string ( ) ) ; }	it will create the jms configurations.
public void index ( iterator tuples , string field ) { while ( tuples . has next ( ) ) { tuple t = ( tuple ) tuples . next ( ) ; index ( t , field ) ; } }	indexes the data values for the given field name for each tuple in the provided iterator.
public final static void close el ( final output stream os ) { try { if ( os != null ) os . close ( ) ; } catch ( final throwable e ) { } }	close outputstream without a exception.
public void add search listener ( search listener l ) { m . add ( l ) ; }	adds the specified listener to the internal list of listeners .
public boolean is single attribute container ( ) { return bool ; }	returns false for the idpplegalidentity container .
public cache span touch ( ) { long now = system . current time millis ( ) ; file new cache file = get cache file name ( file . get parent file ( ) , key , position , now ) ; file . rename to ( new cache file ) ; return cache span . create cache entry ( key , position , now , new cache file ) ; }	renames the file underlying this cache span to update its last access time .
public void open ( file file ) throws io { check awt ( ) ; check exec ( ) ; check action support ( action . open ) ; check file validation ( file ) ; peer . open ( file ) ; }	launches the associated application to open the file.
@ override public void toggle selection ( t photo ) { if ( selected photos . contains ( photo ) ) { selected photos . remove ( photo ) ; } else { selected photos . add ( photo ) ; } }	toggle the selection status of the item at a given position.
protected void pre tick ( ) { }	fired when the scheduler begins to tick , before any tasks are processed .
public byte map ( byte src ) { char c = map ( ( char ) src ) ; if ( c < byte . min value || c > byte . max value ) { return num ; } return ( byte ) c ; }	cannot map from a byte.
public object produce event ( ) throws invocation target exception { if ( ! valid ) { throw new illegal state exception ( to string ( ) + str ) ; } try { return method . invoke ( target ) ; } catch ( illegal access exception e ) { throw new assertion error ( e ) ; } catch ( invocation target exception e ) { if ( e . get cause ( ) instanceof error ) { throw ( error ) e . get cause ( ) ; } throw e ; } }	invokes the wrapped producer method .
public string wrap if keyword or built in ( string name ) { if ( keyword built in set . contains ( name ) ) { return name + str ; } return name ; }	return a non - conflicting safe name if name is a ruby built - in .
public issue matcher add ( ) { issue matcher issue matcher = new issue matcher ( ) ; issue matchers . add ( issue matcher ) ; return issue matcher ; }	creates a new issue matcher and adds it to this matcher .
private < t > inject scope < t > find scope ( annotated element ann element ) { for ( annotation ann : ann element . get annotations ( ) ) { class < ? extends annotation > ann type = ann . annotation type ( ) ; if ( ann type . is annotation present ( scope . class ) ) { supplier < inject scope < t > > scope gen = ( supplier ) scope map . get ( ann type ) ; if ( scope gen != null ) { return scope gen . get ( ) ; } else { log . fine ( l . l ( str , ann type . get simple name ( ) ) ) ; } } } return new inject scope factory < > ( ) ; }	finds the scope for a bean producing declaration , either a method or a type .
private static native int [ ] reg open key ( int h key , byte [ ] sub key , int security mask ) ;	java wrapper for windows registry api regopenkey ( ).
public void remove property change listener ( i listener ) { listeners . remove ( listener ) ; }	remove the provided listener from the receiver .
@ override public int previous ( ) { character iterator text = get text ( ) ; if ( current ( ) == text . get begin index ( ) ) { return break iterator . done ; } int start = current ( ) ; int last result = cached last known break ; if ( last result >= start || last result <= break iterator . done ) { get previous ( ) ; last result = handle previous ( ) ; } else { text . set index ( last result ) ; } int result = last result ; while ( result != break iterator . done && result < start ) { last result = result ; result = handle next ( ) ; } text . set index ( last result ) ; cached last known break = last result ; return last result ; }	advances the iterator backwards , to the last boundary preceding this one .
public deferred image replaced element ( image resource image resource , repaint listener repaint listener , int w , int h ) { this . image resource = image resource ; loaded = bool ; this . repaint listener = repaint listener ; if ( w == - num && h == - num ) { do scale image = bool ; target height = num ; target width = num ; } else { do scale image = bool ; target height = math . max ( num , h ) ; target width = math . max ( num , w ) ; } image = image util . create compatible buffered image ( target width , target height ) ; }	creates a new imagereplacedelement and scales it to the size specified if either width or height has a valid value ( values are > - 1 ) , otherwise original size is preserved.
public boolean starts with ( name n ) { if ( n instanceof compound name ) { return ( impl . starts with ( n . size ( ) , n . get all ( ) ) ) ; } else { return bool ; } }	determines whether a compound name is a prefix of this compound name.
public void test invoke all5 ( ) throws throwable { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new array list < callable < string > > ( ) ; l . add ( new string task ( ) ) ; l . add ( new string task ( ) ) ; list < future < string > > futures = e . invoke all ( l ) ; assert equals ( num , futures . size ( ) ) ; for ( future < string > future : futures ) assert same ( test string , future . get ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeall ( c ) returns results of all completed tasks in c.
public internal listener ( final config manager config file ) { this . config file = config file ; }	creates a new listener object .
public byte [ ] sign ( byte [ ] hash ) { ecdsa signer = new ecdsa ( new h dsak ( new sh ( ) ) ) ; signer . init ( bool , new ec ( priv , domain ) ) ; big integer [ ] signature = signer . generate signature ( hash ) ; byte array output stream baos = new byte array output stream ( ) ; try { der seq = new der ( baos ) ; seq . add object ( new as ( signature [ num ] ) ) ; seq . add object ( new as ( to canonical s ( signature [ num ] ) ) ) ; seq . close ( ) ; return baos . to byte array ( ) ; } catch ( io e ) { } return null ; }	sign a digest with this key .
public time period ( date start time , date end time ) { if ( start time != null && end time != null && ! end time . after ( start time ) ) { throw new illegal argument exception ( str + end time + str + start time ) ; } this . start time = start time ; this . end time = end time ; }	creates time interval [ starttime , endtime ) if times are not null.
j create edit menu ( ) { j edit menu = new j ( str ) ; edit menu . add ( action manager . get cut action ( ) ) ; edit menu . add ( action manager . get copy action ( ) ) ; edit menu . add ( action manager . get paste action ( ) ) ; edit menu . add ( action manager . get delete action ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( action manager . get clear source neurons action ( ) ) ; edit menu . add ( action manager . get set source neurons action ( ) ) ; edit menu . add ( action manager . get connection menu ( ) ) ; edit menu . add ( action manager . get add synapse group action ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( action manager . get randomize objects action ( ) ) ; edit menu . add ( action manager . get show adjust synapses dialog ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( action manager . get layout menu ( ) ) ; edit menu . add ( action manager . get group menu ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( create align menu ( ) ) ; edit menu . add ( create spacing menu ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( action manager . get set neuron properties action ( ) ) ; edit menu . add ( action manager . get set synapse properties action ( ) ) ; edit menu . add separator ( ) ; edit menu . add ( create selection menu ( ) ) ; return edit menu ; }	create and return a new edit menu for this network panel .
public void remove history changed listener ( history changed listener l ) { m . remove ( l ) ; }	removes the given listener from the list of listeners .
public void current state ( long state , model current model ) { current state = state ; if ( loggers != null ) { for ( logger logger : loggers ) { logger . log ( state ) ; } } }	called to update the current model keepevery states .
public boolean is bom ( ) { return m is bom ; }	is it a bom.
public boolean is signed ( ) { return signed ; }	returns whether the object is signed or not .
public object parse text ( string text ) { if ( text == null || text . length ( ) == num ) { throw new illegal argument exception ( str ) ; } return parse ( new line column reader ( new string reader ( text ) ) ) ; }	parse a text representation of a json data structure.
public int size ( ) { return parts . size ( ) ; }	the number of parts in this multipart body .
protected < t > database make simple database ( string filename , int expected size , list parameterization params , class < ? > [ ] filters ) { try ( input stream is = open ( filename ) ) { list < object filter > filterlist = new array list < > ( ) ; filterlist . add ( new dbi ( num ) ) ; if ( filters != null ) { for ( class < ? > filtercls : filters ) { object filter filter = class generics util . parameterize or abort ( filtercls , params ) ; filterlist . add ( filter ) ; } } number vector label parser < double vector > parser = new number vector label parser < > ( double vector . factory ) ; input stream database connection dbc = new input stream database connection ( is , filterlist , parser ) ; params . add parameter ( abstract database . parameterizer . database connection id , dbc ) ; database db = class generics util . parameterize or abort ( static array database . class , params ) ; test parameterization ok ( params ) ; db . initialize ( ) ; relation < ? > rel = db . get relation ( type util . any ) ; assert equals ( str , expected size , rel . size ( ) ) ; return db ; } catch ( io e ) { fail ( str + filename + str ) ; return null ; } }	generate a simple doublevector database from a file .
protected void add chooser filters ( j chooser ) { javax . swing . filechooser . file name extension filter filter ; chooser . add choosable file filter ( filter = new javax . swing . filechooser . file name extension filter ( str , str ) ) ; chooser . set file filter ( filter ) ; }	add filter ( s ) for possible types to the input file chooser .
public void on stop ( ) { if ( null != m service ) { if ( null != m context ) { m context . unbind service ( m service connection ) ; } m service connection = null ; m service = null ; } }	unbinds the in - app billing service .
public string peek ( ) { string result = null ; if ( is empty ( ) ) { return null ; } else { int cached current index = current index ; if ( is eating blocks of delimiters ) { trim starting delimiters ( ) ; } int nearest delimeter = - num ; for ( int i = num ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index of ( delimiters . char at ( i ) , current index ) ; if ( nearest delimeter == - num || delimiter != - num && delimiter < nearest delimeter ) { nearest delimeter = delimiter ; } } if ( nearest delimeter == - num ) { result = source . substring ( current index ) ; } else { result = source . substring ( current index , nearest delimeter ) ; } current index = cached current index ; } return result ; }	returns null if there is nothing left .
private void eliminar usuarios organo ( bi organizacion bi , vo organizacion vo ) { organizacion bi . eliminar usuarios organo ( organizacion vo . get id ( ) ) ; }	metodo encargado de borrar todos los usuarios asociados a un determinado organo , siempre y cuando este organo se encuentre en estado vigente .
private static void add previous layer ( list < list < neuron > > layers , list < neuron > source layer , list < neuron > layer to check ) { final int maxlayers = num ; set < neuron > new layer temp = new hash set < neuron > ( ) ; boolean the next layer is the source layer = bool ; for ( neuron neuron : layer to check ) { for ( synapse synapse : neuron . get fan in ( ) ) { neuron source neuron = synapse . get source ( ) ; if ( source layer . contains ( source neuron ) ) { the next layer is the source layer = bool ; } if ( source neuron == neuron ) { continue ; } new layer temp . add ( synapse . get source ( ) ) ; } } if ( ( the next layer is the source layer ) || ( new layer temp . size ( ) == num ) || ( layers . size ( ) > maxlayers ) ) { layers . add ( source layer ) ; } else { list < neuron > new layer = new array list < neuron > ( new layer temp ) ; collections . sort ( new layer , orientation comparator . x order ) ; layers . add ( new layer ) ; add previous layer ( layers , source layer , new layer ) ; } }	helper method for getintermedatelayers.
public void test shift right2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = - num ; byte r bytes [ ] = { num , num , - num , num , - num , - num , - num , num , - num , num , - num , num , - num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift right ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	shiftright ( int n ) , n < 0.
public static void ignorm ( double c1 [ ] , double c2 [ ] , int m , double ng ) { if ( ng != num ) { double k = math . pow ( c1 [ num ] , ng ) ; for ( int i = m ; i >= num ; i -- ) c2 [ i ] = k * c1 [ i ] ; c2 [ num ] = ( k - num ) / ng ; } else { system . arraycopy ( c1 , num , c2 , num , m - num ) ; c2 [ num ] = math . log ( c1 [ num ] ) ; } }	ignorm : inverse gain normalization.
public static int find nonwhitespace character ( string s , int index ) { int s length = s . length ( ) ; while ( index < s length && character . is whitespace ( s . char at ( index ) ) ) { index ++ ; } return index ; }	finds the first non - whitespace character starting at index .
public void read content ( ) throws io { if ( offset + length > buffer . length ) { throw new as ( str ) ; } if ( in == null ) { offset += length ; } else { int bytes read = in . read ( buffer , offset , length ) ; if ( bytes read != length ) { int c = bytes read ; do { if ( c < num || bytes read > length ) { throw new as ( str ) ; } c = in . read ( buffer , offset + bytes read , length - bytes read ) ; bytes read += c ; } while ( bytes read != length ) ; } offset += length ; } }	reads the next encoded content from the encoded input stream.
public primitive ( object value ) { this . value = value ; type = ( value != null ) ? utilities . get primitive type ( value . get class ( ) ) : null ; if ( type == null ) { throw new illegal argument exception ( str + value ) ; } }	creates an object that represents a primitive value of the type associated with the specified primitive wrapper object .
public void create cash based journal entries and reversals for savings tax ( final office office , final string currency code , final cash accounts for savings account type to be debited , final cash accounts for savings account type to be credited , final long savings product id , final long payment type id , final long savings id , final string transaction id , final date transaction date , final big decimal amount , final boolean is reversal , final list < dto > tax details ) { for ( dto tax payment dto : tax details ) { if ( tax payment dto . get amount ( ) != null ) { if ( tax payment dto . get credit account id ( ) == null ) { create cash based credit journal entries and reversals for savings ( office , currency code , account type to be credited . get value ( ) , savings product id , payment type id , savings id , transaction id , transaction date , tax payment dto . get amount ( ) , is reversal ) ; } else { create cash based credit journal entries and reversals for savings ( office , currency code , tax payment dto . get credit account id ( ) , savings id , transaction id , transaction date , tax payment dto . get amount ( ) , is reversal ) ; } } } create cash based debit journal entries and reversals for savings ( office , currency code , account type to be debited . get value ( ) , savings product id , payment type id , savings id , transaction id , transaction date , amount , is reversal ) ; }	convenience method that creates a pair of related debits and credits for cash based accounting . the target accounts for debits and credits are switched in case of a reversal.
public int read ( byte buf dst , int dst start , int dst length ) throws io { final int remaining = ( int ) math . min ( this . length - this . position , integer . max value ) ; final int read = math . min ( remaining , dst length ) ; final int buffer position = check offset ( position , read ) ; final long src address = platform dependent . direct buffer address ( last mapped ) + buffer position ; if ( dst . has memory address ( ) ) { final long dst address = dst . memory address ( ) + dst start ; platform dependent . copy memory ( src address , dst address , read ) ; } else if ( dst . has array ( ) ) { final byte [ ] dst array = dst . array ( ) ; platform dependent . copy memory ( src address , dst array , dst start , read ) ; } else { throw new illegal argument exception ( str ) ; } position += read ; return read ; }	reads a sequence of bytes from this file into the given buffer.
public static calendar clear time ( final calendar self ) { clear time common ( self ) ; return self ; }	clears the time portion of this calendar instance ; useful utility where it makes sense to compare month / day / year only portions of a calendar .
public double pdf ( int k ) { return math . exp ( k * math . log ( this . mean ) - arithmetic . log factorial ( k ) - this . mean ) ; }	returns the probability distribution function .
public static void append unpadded integer ( string buffer buf , long value ) { int int value = ( int ) value ; if ( int value == value ) { append unpadded integer ( buf , int value ) ; } else { buf . append ( long . to string ( value ) ) ; } }	converts an integer to a string , and appends it to the given buffer.
private void draw text elements ( canvas canvas , float text size , typeface typeface , color state list text color , string [ ] texts , float [ ] text x , float [ ] text y , paint paint , int alpha , boolean show activated , int activated degrees , boolean activated only ) { paint . set text size ( text size ) ; paint . set typeface ( typeface ) ; final float activated index = activated degrees / ( num / num positions ) ; final int activated floor = ( int ) activated index ; final int activated ceil = ( ( int ) math . ceil ( activated index ) ) % num positions ; for ( int i = num ; i < num ; i ++ ) { final boolean activated = ( activated floor == i || activated ceil == i ) ; if ( activated only && ! activated ) { continue ; } final int [ ] state mask = new int [ ] { android . r . attr . state enabled , ( show activated && activated ? android . r . attr . state selected : num ) } ; final int color = text color . get color for state ( state mask , num ) ; paint . set color ( color ) ; paint . set alpha ( get multiplied alpha ( color , alpha ) ) ; canvas . draw text ( texts [ i ] , text x [ i ] , text y [ i ] , paint ) ; } }	draw the 12 text values at the positions specified by the textgrid parameters .
public void test find spring active directory with limit ( ) { ldap proxy proxy = get ldap ad ( ) ; list result = null ; int limit = num ; try { result = proxy . find ( get ldap search vo ( str , limit , str , str , null , ldap scope constants . scope subtree ) ) ; } catch ( exception e ) { } assert not null ( result ) ; if ( result != null ) { assert equals ( limit , result . size ( ) ) ; } }	test de busqueda active directory con limite.
@ override public void handle key ( int virtual key code , int transition state , char key char ) { switch control keys ( virtual key code , transition state ) ; input buffer . add ( new global key event ( this , virtual key code , transition state , key char , menu pressed , shift pressed , control pressed , extended key ) ) ; }	handle the input virtualkeycode and transitionstate , create event and add it to the inputbuffer.
public int hash code ( ) { return alignment ^ leader ^ math . round ( position ) ; }	returns the hashcode for the object.
public static string strip leading period ( string s ) { if ( null != s && s . starts with ( str ) ) return s . substring ( math . min ( num , s . length ( ) ) , s . length ( ) ) ; return s ; }	strips leading period from a string ( example : input - > " . ext " , output - > " ext " ).
public static boolean is required config directory ( final string directory ) { return required config directories . contains ( directory ) ; }	check if the passed in directory is required to be present in the configuration data set .
private void clean up labels ( ) { int id = num ; for ( iterator < label > i = labels . iterator ( ) ; i . has next ( ) ; ) { label label = i . next ( ) ; if ( label . is empty ( ) ) { i . remove ( ) ; } else { label . compact ( ) ; label . id = id ++ ; } } }	removes empty labels and assigns ids to non - empty labels .
void zrot ( double theta ) { theta *= ( pi / num ) ; double ct = math . cos ( theta ) ; double st = math . sin ( theta ) ; float nyx = ( float ) ( yx * ct + xx * st ) ; float nyy = ( float ) ( yy * ct + xy * st ) ; float nyz = ( float ) ( yz * ct + xz * st ) ; float nyo = ( float ) ( yo * ct + xo * st ) ; float nxx = ( float ) ( xx * ct - yx * st ) ; float nxy = ( float ) ( xy * ct - yy * st ) ; float nxz = ( float ) ( xz * ct - yz * st ) ; float nxo = ( float ) ( xo * ct - yo * st ) ; yo = nyo ; yx = nyx ; yy = nyy ; yz = nyz ; xo = nxo ; xx = nxx ; xy = nxy ; xz = nxz ; }	rotate theta degrees about the z axis.
public static long nanos from date ( long ms ) { calendar cal = get calendar ( ) ; cal . set time in millis ( ms ) ; return nanos from calendar ( cal ) ; }	convert a time in milliseconds in utc to the nanoseconds since midnight ( in the default timezone ) .
@ override default completable future < optional long > max long ( final to long function < ? super t > fn ) { return completable future . supply async ( null , get exec ( ) ) ; }	perform an asynchronous max operation.
protected balanced web resource create https client ( final string username , final string password , list < string > hosts ) throws no such algorithm exception { return create https client ( username , password , hosts , bool ) ; }	create the httpsclient , returns a balancedwebresource that can be used the same way a webresource is .
public static char [ ] create array signature ( char [ ] type signature , int array count ) { if ( array count == num ) return type signature ; int sig length = type signature . length ; char [ ] result = new char [ array count + sig length ] ; for ( int i = num ; i < array count ; i ++ ) { result [ i ] = c array ; } system . arraycopy ( type signature , num , result , array count , sig length ) ; return result ; }	creates a new type signature with the given amount of array nesting added to the given type signature .
public void println ( ) throws io { writer . write ( format . get line separator ( ) ) ; }	writes the new line text to the underlying writer.
protected void increase buffer size ( int min size ) { int new length = buf . length ; while ( new length < min size ) new length *= num ; double [ ] new buf = new double [ new length ] ; int avail = currently in buffer ( ) ; system . arraycopy ( buf , read pos , new buf , num , avail ) ; buf = new buf ; read pos = num ; write pos = avail ; }	increase the underlying buffer array in size , so that the new size is at least minsize.
private void handle enumerated attribute ( instances train instances ) throws exception { instance instance ; m distribution = new distribution ( m complexity index , train instances . num classes ( ) ) ; enumeration < instance > enu = train instances . enumerate instances ( ) ; while ( enu . has more elements ( ) ) { instance = enu . next element ( ) ; if ( ! instance . is missing ( m att index ) ) { m distribution . add ( ( int ) instance . value ( m att index ) , instance ) ; } } if ( m distribution . check ( m min no obj ) ) { m num subsets = m complexity index ; m info gain = info gain crit . split crit value ( m distribution , m sum of weights ) ; m gain ratio = gain ratio crit . split crit value ( m distribution , m sum of weights , m info gain ) ; } }	creates split on enumerated attribute .
private boolean is load more ( ) { return m next load enable && page size != - num && m request load more listener != null && m data . size ( ) >= page size ; }	determine whether it is loaded more.
private void add worker if necessary ( ) { if ( idle workers . get ( ) == num ) { synchronized ( workers ) { if ( workers . is empty ( ) || ( idle workers . get ( ) == num ) ) { add worker ( ) ; } } } }	add a new worker only if there are no idle worker .
@ override protected node remove from frontier ( ) { node result = frontier . remove ( ) ; frontier node lookup . remove ( result . get state ( ) ) ; explored . add ( result . get state ( ) ) ; update metrics ( frontier . size ( ) ) ; return result ; }	removes the node at the head of the frontier , adds the corresponding state to the explored set , and returns the node .
public static font create bitmap font ( string name , image bitmap , int [ ] cut offsets , int [ ] char width , string charsets ) { font f = create bitmap font ( bitmap , cut offsets , char width , charsets ) ; bitmap cache . put ( name , f ) ; return f ; }	creates a bitmap font with the given arguments and places said font in the cache.
static boolean is tenured ( mx memory pool mx ) { if ( memory pool mx . get type ( ) != memory type . heap ) { return bool ; } string name = memory pool mx . get name ( ) ; return name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || ( heap pool != null && name . equals ( heap pool ) ) ; }	determines if the name of the memory pool mxbean provided matches a list of known tenured pool names.
public string to simple string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( str + ( m label == null ? str : m label ) + str + m y . size ( ) + str ) ; return buffer . to string ( ) ; }	returns a simple string representation of the dataset with the type and the number of entries .
public static < t > t interpreter only ( callable < t > callable ) throws exception { return callable . call ( ) ; }	directive for the compiler that the given callable should only be executed in the interpreter .
private void add selector for protocol ( properties settings , string protocol , protocol dispatch selector ps ) { string proxy = settings . get property ( protocol ) ; if ( proxy != null ) { fixed proxy selector protocol selector = proxy util . parse proxy settings ( proxy ) ; ps . set selector ( protocol , protocol selector ) ; } }	creates a selector for a given protocol.
public void add header ( string name , string value ) { header . put ( name , value ) ; }	adds given line to the header .
public static void read skel ( buffered reader reader ) throws io { list < string > lines = new array list < string > ( ) ; string builder section = new string builder ( ) ; string ln ; while ( ( ln = reader . read line ( ) ) != null ) { if ( ln . starts with ( str ) ) { lines . add ( section . to string ( ) ) ; section . set length ( num ) ; } else { section . append ( ln ) ; section . append ( nl ) ; } } if ( section . length ( ) > num ) lines . add ( section . to string ( ) ) ; if ( lines . size ( ) != size ) { out . error ( error messages . wrong skeleton ) ; throw new generator exception ( ) ; } line = new string [ size ] ; for ( int i = num ; i < size ; i ++ ) line [ i ] = lines . get ( i ) ; }	reads an external skeleton file from a bufferedreader .
public static set < string > non monogamous samples ( collection < family > families ) { final linked hash set < string > ret = new linked hash set < > ( ) ; final hash set < string > parents = new hash set < > ( ) ; for ( family f : families ) { if ( ! parents . add ( f . get father ( ) ) ) { ret . add ( f . get father ( ) ) ; } if ( ! parents . add ( f . get mother ( ) ) ) { ret . add ( f . get mother ( ) ) ; } } return ret ; }	detects the presence of genetic non - monogamy within an set of families.
private void create scene vao ( ) { int vao = gl gen vertex arrays ( ) ; int vbo = gl gen buffers ( ) ; gl bind vertex array ( vao ) ; gl bind buffer ( gl array buffer , vbo ) ; byte buffer bb = buffer utils . create byte buffer ( boxes . length * num * ( num + num ) * num * num ) ; float buffer fv = bb . as float buffer ( ) ; for ( int i = num ; i < boxes . length ; i += num ) { demo utils . triangulate box ( boxes [ i ] , boxes [ i + num ] , fv ) ; } gl buffer data ( gl array buffer , bb , gl static draw ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num * ( num + num ) , num ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num * ( num + num ) , num * num ) ; gl bind buffer ( gl array buffer , num ) ; gl bind vertex array ( num ) ; this . vao scene = vao ; }	creates a vao for the scene .
public boolean contains ( file file , string file content ) { if ( exists ( file ) ) { string content = read file content ( file ) ; return content != null && content . equals ( file content ) ; } return bool ; }	returns boolean indicating whether this file contains the content value .
public static boolean [ ] [ ] load image ( file file , char off char ) throws file not found exception , runtime exception { array list < string > rows = load image pad ( file , off char ) ; string s = rows . get ( num ) ; boolean [ ] [ ] img = new boolean [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = num ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = num ; j < s . length ( ) ; j ++ ) { char c = s . char at ( j ) ; if ( c == off char ) { img [ i ] [ j ] = bool ; } else { img [ i ] [ j ] = bool ; } } } return img ; }	load up an image from the given file , where only the off character is known.
protected void update receipt status when cancelled ( final string receipt number ) { final list < egdm collected receipt > egdm collected receipts = demand generic dao . get all egdm collected receipts ( receipt number ) ; if ( egdm collected receipts != null && ! egdm collected receipts . is empty ( ) ) for ( final egdm collected receipt eg dm collected receipt : egdm collected receipts ) { eg dm collected receipt . set status ( demand constants . cancelled receipt ) ; eg dm collected receipt . set updated time ( new date ( ) ) ; egdm collected receipt dao . update ( eg dm collected receipt ) ; } }	when receipt is cancelled the status of the receipt in egdmcollectedreceipts is updated as cancelled .
public void add animation ( int id , animation ... animations ) { if ( m animations . get ( id ) == null ) { m animations . put ( id , new array list < animation > ( animations . length ) ) ; if ( id != animation . full page ) { m animated views . add ( id ) ; } } array list < animation > anims = m animations . get ( id ) ; collections . add all ( anims , animations ) ; }	add animations to the target view.
private void cleanup discovery ( storage system system ) { try { system . set reachable status ( bool ) ; db client . persist object ( system ) ; } catch ( database exception e ) { logger . error ( str , e ) ; } }	if discovery fails , then mark the system as unreachable.
@ override protected void initialize ( ) { list < string > words ; super . initialize ( ) ; m = new hash set < string > ( ) ; words = read ( ) ; for ( string word : words ) { if ( ! word . starts with ( str ) ) m . add ( word ) ; } }	performs intialization of the scheme .
protected boolean exists in range ( string x , int min length , int max length ) { x = string utils . trim to null ( x ) ; return x != null && x . length ( ) >= min length && x . length ( ) <= max length ; }	checks if string has a length in a certain range .
public synchronized void unwatch ( string path name ) throws io { unregister all ( paths . get ( path name ) ) ; }	recursively listen for file system events in the specified path name .
public criteria add property ( string name , string value , operator operator ) { properties . add ( new property criteria ( name , value , operator ) ) ; return this ; }	this method adds a new property criteria .
public void remove column ( final string column name ) { if ( column name == null ) { return ; } final list < string > cols = arrays . as list ( get info ( ) . headers ) ; final int col index = cols . index of ( column name ) ; remove column ( col index ) ; }	remove the column represented by its name.
public static un managed protection set check un managed protection set exists in db ( db client db client , string native guid ) throws io { list < un managed protection set > cgs = custom query utility . get un managed protection set by native guid ( db client , native guid ) ; iterator < un managed protection set > cgs itr = cgs . iterator ( ) ; if ( cgs itr . has next ( ) ) { return cgs itr . next ( ) ; } return null ; }	check unmanaged protection set exists in db.
public static void put string2bytes ( byte [ ] destbytes , string src string , int dest offset , int src offset , int count ) { for ( int i = num ; i < count ; i ++ ) { destbytes [ count + i ] = src string . get bytes ( ) [ i ] ; } }	put string to byte [ ].
private void check query ( string exp res , string qry ) throws exception { assert equals ( num , execute hive query ( str ) ) ; assert equals ( num , execute hive query ( str + str + str + str + qry ) ) ; igfs input stream in = igfs . open ( new igfs path ( str ) ) ; byte [ ] buf = new byte [ ( int ) in . length ( ) ] ; in . read ( buf ) ; assert equals ( exp res , new string ( buf ) ) ; }	runs query check result .
public final v update and get ( unary operator < v > update function ) { v prev , next ; do { prev = get ( ) ; next = update function . apply ( prev ) ; } while ( ! compare and set ( prev , next ) ) ; return next ; }	atomically updates the current value with the results of applying the given function , returning the updated value.
public void close ( ) { stop timers ( ) ; closed = bool ; window . dispose ( ) ; if ( listener != null ) { listener . notification removed ( this ) ; } if ( activity listener != null ) { activity tracker . remove activity listener ( activity listener ) ; } }	close the window immediately and cleanup .
protected boolean should move ( final i load balancer service ) { if ( load balancer service == null ) throw new illegal argument exception ( ) ; final boolean highly utilized service ; try { final uuid service uuid = resource manager . get data service uuid ( ) ; highly utilized service = load balancer service . is highly utilized data service ( service uuid ) ; } catch ( exception ex ) { log . warn ( str ) ; return bool ; } if ( ! highly utilized service ) { if ( log . is info enabled ( ) ) log . info ( str ) ; return bool ; } final resource scores resource scores = resource manager . get resource scores ( ) ; final boolean should move = ( resource scores . percent cpu >= resource manager . move percent cpu time threshold ) || ( resource scores . major page faults per sec > num ) || ( resource scores . data dir bytes free < bytes . gigabyte * num ) || ( resource scores . data dir bytes free < bytes . gigabyte * num ) ; return should move ; }	figure out if this data service is considered to be highly utilized , in which case the ds should shed some index partitions.
private static object [ ] convert throwable messages ( final object [ ] args ) { if ( args != null ) { for ( int i = num ; i < args . length ; i ++ ) { if ( args [ i ] instanceof throwable ) { throwable t = ( throwable ) args [ i ] ; if ( t . get message ( ) != null ) { args [ i ] = t . get message ( ) ; } } } } return args ; }	converts all throwable arguments to its message if the message is not null.
public raf ( path path , lock factory lock factory ) throws io { super ( path , lock factory ) ; path . to file ( ) ; }	create a new rafdirectory for the named location.
public static void add minutes to list ( context context , array list < integer > values , array list < string > labels , int minutes ) { int index = values . index of ( minutes ) ; if ( index != - num ) { return ; } string label = construct reminder label ( context , minutes , bool ) ; int len = values . size ( ) ; for ( int i = num ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }	if " minutes " is not currently present in " values " , we add an appropriate new entry to values and labels .
void recompose variables ( elem variable elem var ) { if ( get variable or param composed ( elem var . get name ( ) ) == null ) { elem var . set is top level ( bool ) ; elem var . set index ( m variables . size ( ) ) ; m variables . add element ( elem var ) ; } }	recompose the top level variable and parameter declarations .
public void property change ( property change event e ) { string property name = e . get property name ( ) ; if ( property name == str ) { if ( e . get old value ( ) == boolean . false && e . get new value ( ) == boolean . true ) { handle popup is visible event ( bool ) ; } else if ( e . get old value ( ) == boolean . true && e . get new value ( ) == boolean . false ) { handle popup is visible event ( bool ) ; } } }	this method gets called when a bound property is changed .
private static int [ ] maybe sort ( int [ ] values ) { if ( ! is sorted ( values , num , bool ) ) { values = values . clone ( ) ; arrays . sort ( values ) ; } return values ; }	clone and sort the array , if not already sorted .
public int execute update ( string sql ) throws generic data source exception { statement stmt = null ; try { stmt = connection . create statement ( ) ; return stmt . execute update ( sql ) ; } catch ( sql sqle ) { throw new generic data source exception ( str + sql , sqle ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( sql sqle ) { debug . log warning ( str + sqle . get message ( ) , module ) ; } } } }	execute update based on the sql statement given.
private void do text normal ( final pdf cmds , final string text ) { final f zero = new f ( ) ; final matrix scale = new matrix ( ) ; utils . set mat values ( scale , fsize , num , num , fsize * th , num , tr ) ; final matrix at = new matrix ( ) ; final list < pdf > l = ( list < pdf > ) font . get glyphs ( text ) ; for ( final pdf glyph : l ) { at . set ( cur ) ; at . pre concat ( scale ) ; final f advance = glyph . add commands ( cmds , at , tm ) ; float advance x = ( advance . x * fsize ) + tc ; if ( glyph . get char ( ) == str ) { advance x += tw ; } advance x *= th ; cur . pre translate ( advance x , advance . y ) ; } final float [ ] src = { zero . x , zero . y } ; final float [ ] dst = new float [ src . length ] ; cur . map points ( dst , src ) ; prev end . set ( dst [ num ] , dst [ num ] ) ; }	add some text to the page .
public synchronized static void initialize ( connection conn ) throws sql { if ( log hadoop id patterns != null && log lineage patterns != null ) { return ; } load lineage patterns ( conn ) ; load hadoop id patterns ( conn ) ; }	initialize , download the regex info into cache.
public void add indices ( collection < i > indices ) { for ( iterator < i > it = indices . iterator ( ) ; it . has next ( ) ; ) { add index ( ( i ) it . next ( ) ) ; } }	adds the given indices .
public static boolean is cookie secure ( ) { return secure cookie ; }	gets property value of " com.
public static list < object model > load json stream ( input stream input ) { list < object model > models = new array list < > ( ) ; reader reader = new input stream reader ( input ) ; object model [ ] object models = gson . from json ( reader , object model [ ] . class ) ; for ( object model object model : object models ) { models . add ( object model ) ; } return models ; }	load object definitions from json stream .
protected multistep expr holder create multistep expr list ( vector paths ) { multistep expr holder first = null ; int n = paths . size ( ) ; for ( int i = num ; i < n ; i ++ ) { expression owner eo = ( expression owner ) paths . element at ( i ) ; if ( null == eo ) continue ; loc path iterator lpi = ( loc path iterator ) eo . get expression ( ) ; int num paths = count steps ( lpi ) ; if ( num paths > num ) { if ( null == first ) first = new multistep expr holder ( eo , num paths , null ) ; else first = first . add in sorted order ( eo , num paths ) ; } } if ( ( null == first ) || ( first . get length ( ) <= num ) ) return null ; else return first ; }	for the reduction of location path parts , create a list of all the multistep paths with more than one step , sorted by the number of steps , with the most steps occuring earlier in the list.
private int add wordlen weights ( channel chan , int weight idx ) { int [ ] weigths tab = atrac3p wl weights [ chan . ch num * num + weight idx - num ] ; for ( int i = num ; i < ctx . num quant units ; i ++ ) { chan . qu wordlen [ i ] += weigths tab [ i ] ; if ( chan . qu wordlen [ i ] < num || chan . qu wordlen [ i ] > num ) { log . error ( string . format ( str , i , chan . qu wordlen [ i ] ) ) ; return a p error ; } } return num ; }	add weighting coefficients to the decoded word - length information .
public void test update3 ( ) throws sql { database creator . fill fk ( conn ) ; statement . execute ( str + database creator . fkstrict table + str ) ; statement . execute ( str + database creator . parent table + str ) ; }	updatefunctionalitytest2 # testupdate3 ( ) . deletes all referencing rows and then updates referenced one.
final void prune exceptional out ( ir ir ) { int n = get number of exceptional out ( ) ; if ( n > num ) { bb handlers = new bb ( n ) ; enumeration < instruction > e = forward real instr enumerator ( ) ; while ( e . has more elements ( ) ) { instruction x = e . next element ( ) ; enumeration < basic block > bbs = get applicable exceptional out ( x ) ; while ( bbs . has more elements ( ) ) { basic block bb = bbs . next element ( ) ; handlers . add possibly duplicate element ( bb ) ; } } delete exceptional out ( ) ; for ( int i = num ; handlers . has more elements ( ) ; i ++ ) { exception handler basic block b = ( exception handler basic block ) handlers . next element ( ) ; insert out ( b ) ; } } recompute normal out ( ir ) ; }	prune away exceptional out edges that are not reachable given this block ' s instructions .
public string to spaced string ( ) { final string original = to string ( ) ; final string builder builder = new string builder ( ) ; for ( int i = num ; i < original . length ( ) ; i ++ ) { if ( i > num && ( i % num ) == num ) builder . append ( str ) ; builder . append ( original . char at ( i ) ) ; } return builder . to string ( ) ; }	return a spaced fingerprint representation of this hexdigest . ex : 1e0f 5874 2268 e82f c600 d81d 9064 07c5 7cc2 c3a7.
private int parse content type ( final byte [ ] b , final int off ) throws parse exception { content type val = primitives parser . parse byte ( b , off ) ; if ( content type . deserialize ( content type val ) == null ) { throw new bad ciphertext exception ( str ) ; } return num ; }	parse the content type in the provided bytes.
@ benchmark public void non caching ( ) { run ( ) ; }	no cache for deserialized strings , each string is an own instance .
private void r line to ( float dx , float dy ) { if ( is empty ( ) ) { m path . move to ( m last x = num , m last y = num ) ; } dx += m last x ; dy += m last y ; m path . line to ( m last x = dx , m last y = dy ) ; }	same as lineto , but the coordinates are considered relative to the last point on this contour.
@ override public conflict results parse output ( final string stdout , final string stderr ) { final list < string > content conflicts = new array list < string > ( ) ; final list < string > rename conflicts = new array list < string > ( ) ; final list < string > both conflicts = new array list < string > ( ) ; final string [ ] lines = get lines ( stderr ) ; for ( final string line : lines ) { final int index = line . last index of ( str ) ; if ( index != - num ) { if ( string utils . ends with ( line , both conflicts suffix ) ) { both conflicts . add ( line . substring ( num , index ) ) ; } else if ( string utils . ends with ( line , rename conflict suffix ) ) { rename conflicts . add ( line . substring ( num , index ) ) ; } else { content conflicts . add ( line . substring ( num , index ) ) ; } } } return new conflict results ( content conflicts , rename conflicts , both conflicts ) ; }	outputs the conflicts found in the workspace in the following format : < p / > tfstest_01 / addfold / testhere2 : the item content has changed tfstest_01 / testadd . txt : the item content has changed.
protected void send start ( final output stream out ) throws io { log . trace ( str ) ; out . write ( extra bytes ) ; out . write ( get part boundary ( ) ) ; out . write ( crlf bytes ) ; }	write the start to the specified output stream.
public void add actual qty ( big decimal add ) { m actual qty = m actual qty . add ( add ) ; }	add to actual qty.
protected static boolean is vowel ( final char c ) { final char l = character . to lower case ( c ) ; return ( ( l == str ) || ( l == str ) || ( l == str ) || ( l == str ) || ( l == str ) ) ; }	is the character a vowel ?.
public static void print stack trace ( sql e , print writer pw ) { sql next = e ; while ( next != null ) { next . print stack trace ( pw ) ; next = next . get next exception ( ) ; if ( next != null ) { pw . println ( str ) ; } } }	print the stack trace for a sqlexception to a specified printwriter .
public void read data ( data input din ) throws io { byte count = din . read byte ( ) ; status = din . read unsigned short ( ) ; event count = din . read unsigned short ( ) ; message count = din . read unsigned short ( ) ; events = new byte [ byte count - num ] ; if ( events . length > num ) { din . read fully ( events , num , events . length ) ; } }	readdata - - input the modbus message from din.
public e remove ( int index ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = get array ( ) ; int len = elements . length ; e old value = get ( elements , index ) ; int num moved = len - index - num ; if ( num moved == num ) set array ( arrays . copy of ( elements , len - num ) ) ; else { object [ ] new elements = new object [ len - num ] ; system . arraycopy ( elements , num , new elements , num , index ) ; system . arraycopy ( elements , index + num , new elements , index , num moved ) ; set array ( new elements ) ; } return old value ; } finally { lock . unlock ( ) ; } }	removes the element at the specified position in this list.
private static < t extends component > t build row ( final j panel , final string label text , final string hint , final t component , final boolean is last ) { component . set preferred size ( new dimension ( colorpanel width , colorpanel height ) ) ; final j row panel = new j ( new border layout ( ) ) ; row panel . set border ( new empty border ( num , num , is last ? num : num , num ) ) ; row panel . add ( new j ( label text ) , border layout . center ) ; row panel . add ( c . create hint panel ( component , hint ) , border layout . east ) ; panel . add ( row panel ) ; return component ; }	builds a single row of components in the panel .
public builder add target elements ( element ... additional targets ) { for ( int i = num ; i < additional targets . length ; i ++ ) { target elements . add ( additional targets [ i ] ) ; } return this ; }	adds additional target elements.
public void curve to ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( size ( ) == num ) { throw new illegal path state exception ( str ) ; } node last point = get ( size ( ) - num ) ; last point . mask |= mask ; last point . x [ num ] = x1 ; last point . y [ num ] = y1 ; if ( ( last point . mask & mask ) == mask ) { last point . keep colinear = math . abs ( geom . angle ( last point . x [ num ] , last point . y [ num ] , last point . x [ num ] , last point . y [ num ] ) - geom . angle ( last point . x [ num ] , last point . y [ num ] , last point . x [ num ] , last point . y [ num ] ) ) < num ; } add ( new node ( mask , x3 , y3 , x2 , y2 , x3 , y3 ) ) ; }	adds a cubic curve to the bezier path.
public void test divide round up neg ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round up ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_up , result is negative.
private void open counter data input stream ( ) throws data fallback exception { if ( d input == null ) { if ( log . is debug enabled ( ) ) log . debug ( str + counter file . get name ( ) + str ) ; try { d input = new buffered reader ( new file reader ( counter file ) ) ; } catch ( io e ) { throw new data fallback exception ( e . get message ( ) ) ; } } }	create a stream to read from the counter file.
public composite predicate ( predicate p1 , predicate p2 ) { m clauses . add ( p1 ) ; m clauses . add ( p2 ) ; }	create a new compositepredicate .
public string read next word ( ) { if ( tokenizer . has more tokens ( ) ) { return tokenizer . next token ( ) ; } else { return null ; } }	read the next word from the parsed sentence .
public static final void to string ( string buffer output , string str ) { if ( str == null ) { output . append ( str ) ; return ; } output . append ( to string ( str ) ) ; }	provides a java string literal representing the parameter string.
public static boolean test file exists ( string name ) { boolean status ; if ( ( test save location exists ( ) ) && ( ! name . equals ( str ) ) ) { file path = environment . get external storage directory ( ) ; file new path = construct file paths ( path . to string ( ) , name ) ; status = new path . exists ( ) ; } else { status = bool ; } return status ; }	determine if a file or directory exists .
@ override public void build associations ( instances data ) throws exception { build associations ( ( object ) data ) ; return ; }	method that generates all large item sets with a minimum support , and from these all association rules with a minimum metric ( i.
public static string replace first ( string s , string sub , string with ) { int i = s . index of ( sub ) ; if ( i == - num ) { return s ; } return s . substring ( num , i ) + with + s . substring ( i + sub . length ( ) ) ; }	replaces the very first occurrence of a substring with supplied string .
private location helper ( ) { }	prevent initializing this class .
public void add object ( string s ) throws exception { inspect ( class . for name ( s ) ) ; }	add the name of the class to methodize.
public static element first child element ( element element , set < string > child element names ) { if ( element == null ) return null ; node node = element . get first child ( ) ; if ( node != null ) { do { if ( node . get node type ( ) == node . element node && child element names . contains ( node . get node name ( ) ) ) { element child element = ( element ) node ; return child element ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; } return null ; }	return the first child element returns the first element .
public static void main ( string [ ] args ) throws exception { final j frame = new html ( args ) ; frame . set default close operation ( j . exit on close ) ; frame . pack ( ) ; frame . set visible ( bool ) ; }	the main program for the htmltest class.
@ override public int hash code ( ) { return raw string . hash code ( ) ; }	returns the hashcode for the raw string .
public final void test add all helper text colors from array ( ) { int helper text color1 = color . black ; int helper text color2 = color . gray ; int [ ] helper text colors1 = new int [ num ] ; helper text colors1 [ num ] = helper text color1 ; helper text colors1 [ num ] = helper text color2 ; password edit text password edit text = new password edit text ( get context ( ) ) ; password edit text . add all helper text colors ( helper text colors1 ) ; password edit text . add all helper text colors ( helper text colors1 ) ; collection < integer > helper text colors2 = password edit text . get helper text colors ( ) ; assert equals ( helper text colors1 . length , helper text colors2 . size ( ) ) ; iterator < integer > iterator = helper text colors2 . iterator ( ) ; assert equals ( helper text color1 , ( int ) iterator . next ( ) ) ; assert equals ( helper text color2 , ( int ) iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper text colors , which are contained by an array .
private void normalize ( double [ ] in ) { double max = num ; for ( double d : in ) { max = math . max ( max , d ) ; } for ( int i = num ; i < in . length ; i ++ ) { in [ i ] = in [ i ] / max ; } }	applies max norm to the histogram .
public static boolean write to file ( string filename , string message , boolean append ) { boolean result ; buffered writer writer ; try { writer = new buffered writer ( new file writer ( filename , append ) ) ; writer . write ( message ) ; writer . new line ( ) ; writer . flush ( ) ; writer . close ( ) ; result = bool ; } catch ( exception e ) { result = bool ; } return result ; }	writes the given message to the specified file.
public int hash code ( ) { return ( num * color model . hash code ( ) ) + ( num * sample model . hash code ( ) ) ; }	returns the hash code for this imagetypespecifier .
static public final float random ( float start , float end ) { return start + random . next float ( ) * ( end - start ) ; }	returns a random number between start ( inclusive ) and end ( inclusive ) .
public void write file ( string name , string mime type , string file name , byte [ ] data ) throws io { if ( data == null ) { throw new illegal argument exception ( str ) ; } if ( file name == null || file name . is empty ( ) ) { throw new illegal argument exception ( str ) ; } out . write bytes ( prefix ) ; out . write bytes ( boundary ) ; out . write bytes ( newline ) ; out . write bytes ( str + name + str + file name + str ) ; out . write bytes ( newline ) ; if ( mime type != null ) { out . write bytes ( str + mime type ) ; out . write bytes ( newline ) ; } out . write bytes ( newline ) ; out . write ( data , num , data . length ) ; out . write bytes ( newline ) ; out . flush ( ) ; }	writes the given bytes .
@ target api ( build . version codes . ice cream sandwich m ) private void on configuration changed ( configuration new config ) { final locale new locale = new config . locale ; if ( new locale . equals ( m system locale ) ) { return ; } m system locale = new locale ; ensure supported locale ( ) ; }	handles updating the system locale.
public static keymap from key ( final string key ) { if ( key == null || key . is empty ( ) ) { return null ; } final keymap search result = instances . get ( key ) ; return search result ; }	retrieve an keymap instance by its key .
private static boolean is gm ( string name ) { if ( name . length ( ) < num ) { return bool ; } char c1 = name . char at ( num ) ; char c2 = name . char at ( num ) ; char c3 = name . char at ( num ) ; if ( ! ( ( c1 == str || c1 == str ) && ( c2 == str || c2 == str ) && ( c3 == str || c3 == str ) ) && ! ( ( c1 == str || c1 == str ) && ( c2 == str || c2 == str ) && ( c3 == str || c3 == str ) ) && ! ( ( c1 == str || c1 == str ) && ( c2 == str || c2 == str ) && ( c3 == str ) ) ) { return bool ; } if ( name . length ( ) == num ) { return bool ; } string offset = name . substring ( num ) ; if ( offset . starts with ( str ) ) { return offset . equals ( str ) || offset . equals ( str ) || offset . equals ( str ) ; } else { return offset . equals ( str ) || offset . equals ( str ) || offset . equals ( str ) ; } }	tells if a offset or time zone is gmt.
private static string massage uri ( string uri ) { uri = uri . trim ( ) ; int protocol end = uri . index of ( str ) ; if ( protocol end < num || is colon followed by port number ( uri , protocol end ) ) { uri = str + uri ; } return uri ; }	transforms a string that represents a uri into something more proper , by adding or canonicalizing the protocol .
public void delete ( int key ) { int i = binary search ( m keys , num , m size , key ) ; if ( i >= num ) { system . arraycopy ( m keys , i + num , m keys , i , m size - ( i + num ) ) ; system . arraycopy ( m values , i + num , m values , i , m size - ( i + num ) ) ; m size -- ; } }	removes the mapping from the specified key , if there was any .
protected void add whole match ( string builder sb , string surface , string analyzed ) { sb . append ( str ) ; sb . append ( surface ) ; sb . append ( str ) ; }	called while highlighting a single result , to append the whole matched token to the provided fragments list .
public void start ( ) { stop at = system . current time millis ( ) + max processing time ; }	start the timer to make sure processing doesn ' t take too long .
private object [ ] single row ( int row ) { object [ ] res = new object [ this . n fields ] ; for ( int i = num ; i < this . n fields ; i += num ) { if ( this . is null == null || ! this . is null [ row * this . n fields + i ] ) { res [ i ] = array funcs . new instance ( this . types [ i ] , num ) ; system . arraycopy ( this . data [ i ] , row , res [ i ] , num , num ) ; } } return res ; }	extract a single row from a table.
public static string remove chars ( string src , string chars ) { int i = src . length ( ) ; string builder sb = new string builder ( i ) ; for ( int j = num ; j < i ; j ++ ) { char c = src . char at ( j ) ; if ( chars . index of ( c ) == - num ) { sb . append ( c ) ; } } return sb . to string ( ) ; }	removes all characters contained in provided string .
private void add all columns ( ) throws sql { database meta data meta data = get database meta data ( ) ; list < string > columns = new array list < > ( ) ; try ( result set rs = meta data . get columns ( null , null , normalize object name ( statement model . get table name ( ) ) , null ) ) { while ( rs . next ( ) ) { columns . add ( quote object name ( rs . get string ( idx column name ) ) ) ; } } column names = columns . to array ( new string [ num ] ) ; add returning clause ( ) ; }	adds all available table columns to the query as generated keys .
static private void copy stream ( final input stream content , final output stream outstr ) throws io { final byte [ ] buf = new byte [ gzip buffer ] ; while ( bool ) { final int rdlen = content . read ( buf ) ; if ( rdlen <= num ) { break ; } outstr . write ( buf , num , rdlen ) ; } }	copy the input stream to the output stream .
public void check and setup streams drawer ( ) { setup list view adapter ( ) ; }	initiates the streams drawer if the streams in the drawer is 0 .
public void test fp type override simple ( ) throws exception { object mapper m = new object mapper ( ) ; m . enable ( deserialization config . feature . use big decimal for floats ) ; big decimal dec = new big decimal ( str ) ; number result = m . read value ( dec . to string ( ) , number . class ) ; assert equals ( big decimal . class , result . get class ( ) ) ; assert equals ( dec , result ) ; object value = m . read value ( dec . to string ( ) , object . class ) ; assert equals ( big decimal . class , result . get class ( ) ) ; assert equals ( dec , value ) ; }	test for verifying [ jackson - 72 ] .
private com . codename1 . ui . component copy component ( com . codename1 . ui . component cmp ) { com . codename1 . ui . container cnt = builder . create container ( res , copied resource name ) ; com . codename1 . ui . component dest = builder . find by name ( cmp . get name ( ) , cnt ) ; if ( dest != null && dest . get parent ( ) != null ) { remove component sync ( dest . get parent ( ) , dest ) ; } return dest ; }	creates a copy of the given component and its hierarchy.
static double zetastatic ( long st , long n , double theta , double initialsum ) { double sum = initialsum ; for ( long i = st ; i < n ; i ++ ) { sum += num / ( math . pow ( i + num , theta ) ) ; } return sum ; }	compute the zeta constant needed for the distribution.
@ override public big decimal calculate total pending advance ( final big decimal total advance paid , final date bill date , final work order estimate work order estimate , final long bill id ) { final c advance coa = contractor advance service . get contractor advance accountcode for woe ( work order estimate . get id ( ) ) ; big decimal total pending balance = big decimal . zero ; big decimal total advance adjusted = big decimal . zero ; if ( advance coa != null && total advance paid != null && total advance paid . compare to ( big decimal . zero ) > num ) { total advance adjusted = get total advance adjusted for woe ( bill date , work order estimate . get id ( ) , advance coa . get id ( ) , bill id ) ; if ( total advance adjusted != null && total advance adjusted . compare to ( big decimal . zero ) > num && total advance adjusted . compare to ( big decimal . zero ) > num ) total pending balance = total advance adjusted . subtract ( total advance adjusted ) ; else total pending balance = total advance paid ; } return total pending balance ; }	the method return bigdecimal.
private void load profile ( string user id , string name ) { final intent user profile intent = new intent ( get activity ( ) , user profile activity . class ) ; user profile intent . put extra ( app constants . keys . user id , user id ) ; user profile intent . put extra ( app constants . keys . user name , name ) ; user profile intent . put extra ( app constants . keys . service screen type , app constants . service screen type . profile ) ; start activity ( user profile intent ) ; }	loads the user profile.
private void scroll by ( final int increment ) { index += increment ; if ( index < num ) { index = num ; } if ( index >= items . size ( ) ) { index = items . size ( ) - num ; } redraw ( ) ; }	scroll the selected item.
public static boolean symbol needs quoting ( char sequence symbol , boolean quote operators ) { int length = symbol . length ( ) ; if ( length == num ) { throw new empty symbol exception ( ) ; } if ( ! is identifier keyword ( symbol ) ) { char c = symbol . char at ( num ) ; if ( ! quote operators && is operator part ( c ) ) { for ( int ii = num ; ii < length ; ii ++ ) { c = symbol . char at ( ii ) ; if ( ! is operator part ( c ) ) { return bool ; } } return bool ; } else if ( is identifier start ( c ) ) { for ( int ii = num ; ii < length ; ii ++ ) { c = symbol . char at ( ii ) ; if ( ( c == str || c < num || c > num ) || ! is identifier part ( c ) ) { return bool ; } } return bool ; } } return bool ; }	determines whether the text of a symbol requires ( single ) quotes .
public static long parse commit counter file ( final string name , final string ext ) throws number format exception { if ( name == null ) throw new illegal argument exception ( ) ; if ( ext == null ) throw new illegal argument exception ( ) ; final int len = name . length ( ) - ext . length ( ) ; final string file base name = name . substring ( num , len ) ; final long commit counter = long . parse long ( file base name ) ; return commit counter ; }	parse out the commitcounter from the file name .
public static document load document ( file file ) throws exception { document builder factory factory = document builder factory . new instance ( ) ; document builder builder = factory . new document builder ( ) ; return builder . parse ( file ) ; }	loads a xml document from a file and returns the corresponding dom document .
private node new floating comment ( ) { node c = new node ( token . empty ) ; link comment to node ( c ) ; return c ; }	returns a new comment attached to an empty node.
public boolean is hod ( final long assign id ) { final list < head of departments > hod list = employee department repository . get all hod departments ( assign id ) ; return ! hod list . is empty ( ) ; }	returns true if the given employee is an hod.
public munger single label mode ( string ... languages ) { return single label mode ( arrays . as list ( languages ) ) ; }	build a munger that will load only a single label per entity.
public stat value [ ] match spec ( stat spec spec ) { if ( spec . get combine type ( ) == stat spec . global ) { stat value [ ] all values = match spec ( new raw stat spec ( spec ) ) ; if ( all values . length == num ) { return all values ; } else { combo value cv = new combo value ( all values ) ; return new stat value [ ] { cv } ; } } else { list l = new array list ( ) ; stat archive reader . stat archive file [ ] archives = get archives ( ) ; for ( int i = num ; i < archives . length ; i ++ ) { stat archive file f = archives [ i ] ; if ( spec . archive matches ( f . get file ( ) ) ) { f . match spec ( spec , l ) ; } } stat value [ ] result = new stat value [ l . size ( ) ] ; return ( stat value [ ] ) l . to array ( result ) ; } }	returns an array of stat values that match the specified spec.
private void assign cluster nums ( int [ ] cl num ) throws exception { if ( m children != null && m children . size ( ) < num ) { throw new exception ( str ) ; } m cluster num = cl num [ num ] ; cl num [ num ] ++ ; if ( m children != null ) { for ( int i = num ; i < m children . size ( ) ; i ++ ) { c child = m children . get ( i ) ; child . assign cluster nums ( cl num ) ; } } }	recursively assigns numbers to the nodes in the tree .
protected void close subpath ( ) { m ps . println ( closepath str ) ; m pen x = m start path x ; m pen y = m start path y ; }	close the current subpath by appending a straight line from the current point to the subpath ' s starting point .
public tv show episode scrape task ( list < tv show episode > episodes , media scraper media scraper ) { super ( bundle . get string ( str ) , episodes . size ( ) , task type . background task ) ; this . episodes = episodes ; this . media scraper = media scraper ; this . scrape thumb = bool ; }	instantiates a new tv show episode scrape task .
public void save selection ( i mini table ) { log . info ( str ) ; array list < integer > results = new array list < integer > ( ) ; set selection ( null ) ; int rows = mini table . get row count ( ) ; for ( int i = num ; i < rows ; i ++ ) { id id = ( id ) mini table . get value at ( i , num ) ; if ( id != null && id . is selected ( ) ) results . add ( id . get record id ( ) ) ; } if ( results . size ( ) == num ) return ; log . config ( str + results . size ( ) ) ; set selection ( results ) ; }	save selection & return selecion query or " ".
public m ( string [ ] notif types , string name , string description ) { this ( notif types , name , description , null ) ; }	constructs a modelmbeannotificationinfo object with a default descriptor .
public void clean build task ( long id ) throws not found exception { future build task task = tasks . remove ( id ) ; if ( task == null ) { throw new not found exception ( string . format ( str , id ) ) ; } task . cancel ( bool ) ; cleanup ( task ) ; }	clean - up all resources and files allocated for the given build task .
public static file create temp dir ( file parent ) { file temp = new file ( parent , integer . to string ( math . abs ( unseeded random . next int ( ) ) % num ) ) ; temp . delete ( ) ; temp . mkdir ( ) ; temp . delete on exit ( ) ; return temp ; }	create a temporary directory that is a child of the given directory.
public void move to ( final int lon center , final int lat center ) { double m lat center = geo math . lat e7 to mercator ( lat center ) ; double m top = geo math . lat e7 to mercator ( top ) ; int new bottom = geo math . mercator to lat e7 ( m lat center - ( m top - bottom mercator ) / num ) ; try { translate ( ( lon center - left - ( int ) ( width / num ) ) , new bottom - bottom ) ; } catch ( osm exception e ) { e . print stack trace ( ) ; } }	performs a translation so the center of this bounding box will be at ( loncenter | latcenter ) .
public void send event ( final string name , final map < string , string > properties ) { final string event name = string . format ( tfs telemetry constants . plugin action event name format , name ) ; final property map builder builder = new property map builder ( properties ) ; logger . debug ( string . format ( str , name , builder . to string ( ) ) ) ; if ( telemetry client != null ) { telemetry client . track event ( event name , builder . build ( ) , null ) ; } }	call sendevent to track an occurrence of a named event .
public void handle header column pressed ( point p ) { j th = table . get table header ( ) ; int col = th . column at point ( p ) ; int c = table . convert column index to model ( col ) ; if ( c != - num ) { table . set pressed column index ( c ) ; th . repaint ( th . get header rect ( col ) ) ; } }	tell the table something is pressed .
private static list < fixed record > create fixed records ( int count ) { list < fixed record > records = new array list < > ( ) ; for ( int i = num ; i < count ; i ++ ) { records . add ( new fixed record ( i ) ) ; } return records ; }	create a list of count 16 - byte records .
public tracked entity instance query params add attributes if not exist ( list < query item > attrs ) { for ( query item attr : attrs ) { if ( attributes != null && ! attributes . contains ( attr ) ) { attributes . add ( attr ) ; } } return this ; }	add the given attributes to this params if they are not already present .
void recompose attribute sets ( elem attribute set attr set ) { array list attr set list = ( array list ) m attr sets . get ( attr set . get name ( ) ) ; if ( null == attr set list ) { attr set list = new array list ( ) ; m attr sets . put ( attr set . get name ( ) , attr set list ) ; } attr set list . add ( attr set ) ; }	recompose the attribute - set declarations .
public static list split ( string str , string regex ) { return ( arrays . as list ( str . split ( regex ) ) ) ; }	splits the given string using the given regex as delimiters.
protected final void delete dbffdc ( string directory to delete ) throws ade exception { try { final file dir to delete = new file ( directory to delete ) ; string [ ] file list = dir to delete . list ( ) ; if ( file list . length == num ) { dir to delete . delete ( ) ; } else { for ( int i = num ; i < file list . length ; i ++ ) { final file f = new file ( dir to delete , file list [ i ] ) ; if ( f . is directory ( ) ) { final string file path = f . get path ( ) ; delete dbffdc ( file path ) ; continue ; } f . delete ( ) ; } file list = dir to delete . list ( ) ; if ( file list . length == num ) { dir to delete . delete ( ) ; } } } catch ( exception e ) { throw new ade internal exception ( str , e ) ; } }	deletes the backed - up db directory . note that a directory can be deleted only if there are no files in it.
node < k , v > find last ( ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexes deleted node ( ) ) { q . unlink ( r ) ; q = head ; } else q = r ; } else if ( ( d = q . down ) != null ) { q = d ; } else { node < k , v > b = q . node ; node < k , v > n = b . next ; for ( ; ; ) { if ( n == null ) return b . is base header ( ) ? null : b ; node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . help delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; b = n ; n = f ; } q = head ; } } }	specialized version of find to get last valid node .
public void append to nal unit ( byte [ ] data , int offset , int limit ) { if ( ! is filling ) { return ; } int read length = limit - offset ; if ( nal data . length < nal length + read length ) { nal data = arrays . copy of ( nal data , ( nal length + read length ) * num ) ; } system . arraycopy ( data , offset , nal data , nal length , read length ) ; nal length += read length ; }	invoked to pass stream data.
public static long size of directory ( file directory ) { check directory ( directory ) ; final file [ ] files = directory . list files ( ) ; if ( files == null ) { return num ; } long size = num ; for ( final file file : files ) { try { if ( ! is symlink ( file ) ) { size += size of ( file ) ; if ( size < num ) { break ; } } } catch ( io ioe ) { } } return size ; }	counts the size of a directory recursively ( sum of the length of all files ) .
public synchronized void pan abs ( double dx , double dy ) { damage report ( ) ; m transform . translate ( dx , dy ) ; try { m itransform = m transform . create inverse ( ) ; } catch ( exception e ) { } }	pans the view provided by this display in absolute ( i.
public static void check serialized equality ( object object ) { object object2 = serialize and recover ( object ) ; assert . assert equals ( str , object , object2 ) ; assert . assert equals ( str , object . hash code ( ) , object2 . hash code ( ) ) ; }	verifies that serialization preserves equals and hashcode.
public string documentation reference guide url ( ) { return properties . get property ( str ) ; }	returns the url of the product wiki page .
public static double mean ( final list < double > list ) { double sum = num ; for ( double number : list ) { sum += number ; } return sum / list . size ( ) ; }	gets the average from a list of numbers .
public static string to hex ( byte [ ] data ) { try { return new string ( hex . encode ( data ) , str ) ; } catch ( unsupported encoding exception e ) { } return null ; }	convert a byte array to hexadecimal.
public in ( url url ) { if ( url == null ) throw new null pointer exception ( str ) ; try { url site = url . open connection ( ) ; input stream is = site . get input stream ( ) ; scanner = new scanner ( new buffered input stream ( is ) , charset name ) ; scanner . use locale ( locale ) ; } catch ( io ioe ) { throw new illegal argument exception ( str + url ) ; } }	initializes an input stream from a url .
@ visible for testing public void process enable fullscreen runnable for test ( ) { if ( m handler . has messages ( msg id enable fullscreen after load ) ) { m handler . remove messages ( msg id enable fullscreen after load ) ; enable fullscreen after load ( ) ; } }	removes the enable fullscreen runnable from the ui queue and runs it immediately .
private static string from html entity ( string str ) { character ch = map . get ( str ) ; return ( ch != null ) ? ch . to string ( ) : str ; }	find the html entity and convert it back to a regular character if the entity exists , otherwise return the same string .
public void write ( byte [ ] vector ) { check ( vector . length ) ; system . arraycopy ( vector , num , buffer , write pos , vector . length ) ; write pos += vector . length ; }	writes vector of opaque values.
public void unlock ui ( process info pi ) { boolean not print = pi != null && pi . get ad id ( ) != m cur tab . get ad id ( ) && pi . is reporting process ( ) == bool ; set busy ( bool , not print ) ; if ( not print ) { m cur tab . data refresh ( ) ; if ( pi . is timeout ( ) ) env . set context ( m ctx , m cur window no , str , str ) ; m cur gc . dynamic display ( num ) ; set status line ( pi . get summary ( ) , pi . is error ( ) ) ; if ( pi . is error ( ) ) a . error ( m cur window no , this , null , pi . get summary ( ) ) ; process info util . set log from db ( pi ) ; string log info = pi . get log info ( ) ; if ( log info . length ( ) > num ) a . info ( m cur window no , this , env . get header ( m ctx , m cur window no ) , pi . get title ( ) , log info ) ; } else { set status line ( pi . get summary ( ) , pi . is error ( ) ) ; if ( pi . is error ( ) ) a . error ( m cur window no , this , null , pi . get summary ( ) ) ; } }	unlock user interface . called from the worker when processing is done.
private map < uri , storage system > build array map ( storage system vplex system , list < volume descriptor > descriptors , volume descriptor . type [ ] types ) { map < uri , storage system > array map = new hash map < uri , storage system > ( ) ; if ( types != null ) { descriptors = volume descriptor . filter by type ( descriptors , types , new volume descriptor . type [ ] { } ) ; } for ( volume descriptor desc : descriptors ) { if ( array map . contains key ( desc . get device uri ( ) ) == bool ) { if ( vplex system == null ) { storage system array = get data object ( storage system . class , desc . get device uri ( ) , db client ) ; array map . put ( desc . get device uri ( ) , array ) ; } else { set < uri > connected systems = connectivity util . get storage system associations by network ( db client , vplex system . get id ( ) , storage port . port type . backend ) ; if ( connected systems . contains ( desc . get device uri ( ) ) ) { storage system array = get data object ( storage system . class , desc . get device uri ( ) , db client ) ; array map . put ( desc . get device uri ( ) , array ) ; } } } } return array map ; }	build a map of uri to cached storagesystem for the underlying arrays .
public byte [ ] encrypt ( byte [ ] plain text as bytes , char sequence password ) throws key crypter exception { try { byte [ ] salt = new byte [ salt length ] ; secure random . next bytes ( salt ) ; iv key = ( iv ) get aes ( password , salt ) ; buffered block cipher cipher = new padded buffered block cipher ( new cbc ( new aes ( ) ) ) ; cipher . init ( bool , key ) ; byte [ ] encrypted bytes = new byte [ cipher . get output size ( plain text as bytes . length ) ] ; final int process length = cipher . process bytes ( plain text as bytes , num , plain text as bytes . length , encrypted bytes , num ) ; final int do final length = cipher . do final ( encrypted bytes , process length ) ; return concat ( salt , arrays . copy of ( encrypted bytes , process length + do final length ) ) ; } catch ( exception e ) { throw new key crypter exception ( str + utils . bytes to hex string ( plain text as bytes ) + str , e ) ; } }	password based encryption using aes - cbc 256 bits .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return after id ; case num : return max jobs ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public void deinstall ( j editor ) { super . deinstall ( editor ) ; editor . remove key listener ( this ) ; }	deinstalls the editor for the kit .
public boolean is secure ( ) { return m tls cipher != null && ! m tls cipher . is empty ( ) ; }	check if sip transport uses tls.
public void sample ( record rec ) { total recs ++ ; if ( samples . size ( ) < max samples ) { samples . add ( new sample ( rec , schema ) ) ; update new value interval ( rec ) ; } else { double flip = random . next double ( ) ; if ( flip < ( double ) max samples / total recs ) { samples . set ( random . next int ( max samples ) , new sample ( rec , schema ) ) ; update new value interval ( rec ) ; } } }	keep a record as a sample , with certain probability.
public tenant create param prepare tenant param ( keystone tenant tenant ) { tenant create param param = new tenant create param ( cinder constants . tenant name prefix + str + tenant . get name ( ) , prepare user mappings ( tenant . get id ( ) ) ) ; param . set description ( get proper tenant description ( tenant . get description ( ) ) ) ; return param ; }	prepares tenantcreateparam class filled with information from given tenant .
private void force internal error ( ) { throw new internal error ( str ) ; }	not really any good way to convince java to do this , so i ' m just gonna throw it directly .
@ override public void draw highlight ( graphics g , int w , int h ) { g . set color ( color . black ) ; font metrics fm = g . get font metrics ( ) ; int l = ( int ) ( m x * w ) - fm . string width ( m id ) / num ; int t = ( int ) ( m y * h ) - fm . get height ( ) / num ; g . fill rect ( l - num , t - num , fm . string width ( m id ) + num , fm . get height ( ) + fm . get descent ( ) + num ) ; draw node ( g , w , h ) ; }	call this function to draw the node highlighted .
public static image encoder new instance ( string format ) { image encoder image encoder = null ; string class name = ( string ) encoders . get ( format ) ; if ( class name == null ) { throw new illegal argument exception ( str + format ) ; } try { class image encoder class = class . for name ( class name ) ; image encoder = ( image encoder ) image encoder class . new instance ( ) ; } catch ( exception e ) { throw new illegal argument exception ( e . to string ( ) ) ; } return image encoder ; }	used to retrieve an imageencoder for a specific image format .
public static void apply pinch zoom image ( image view m image view ) { m image view . set on touch listener ( new pinch zoom ( ) ) ; }	use for apply pinchzoom functionality to your imageview.
public static file parse ( string [ ] options , string option , file def value ) throws exception { string value = utils . get option ( option , options ) ; if ( value . is empty ( ) ) return def value ; else return new file ( value ) ; }	parses a file option , uses default if option is missing .
public boolean is acct balanced ( ) { if ( m lines . size ( ) == num ) return bool ; big decimal balance = get acct balance ( ) ; boolean ret value = balance . signum ( ) == num ; if ( ret value ) log . finer ( to string ( ) ) ; else log . warning ( str + balance + str + to string ( ) ) ; return ret value ; }	are the lines accounting balanced.
public void ensure capacity ( int min capacity ) { int old capacity = capacity ; if ( min capacity > old capacity ) { int new capacity = ( old capacity * num ) / num + num ; if ( new capacity < min capacity ) new capacity = min capacity ; bit vector vector = to bit vector ( ) ; vector . set size ( new capacity * bits per element ) ; this . bits = vector . elements ( ) ; this . capacity = new capacity ; } }	ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
private string detail base ( final method method ) { final class < ? > clazz = method . get declaring class ( ) ; final string detail base = message utils . bundle name for class ( clazz ) ; if ( is blank ( detail base ) ) { throw new illegal state exception ( str + clazz ) ; } return detail base ; }	get the name of the message bundle to use when getting the message for the specified method.
public void finished ( ) throws io { output stream . close ( ) ; }	do all required cleanup now that we ' re finished with the currently - open . zip.
public final void lock ( ) { sun toolkit . awt lock ( ) ; }	locks the queue for read / write access .
@ override public object create statement ( object proxy , method method , object [ ] args , object statement , long time ) { try { object result = null ; string name = method . get name ( ) ; string sql = null ; constructor < ? > constructor = null ; if ( compare ( create statement , name ) ) { constructor = get constructor ( create statement idx , statement . class ) ; } else if ( compare ( prepare statement , name ) ) { sql = ( string ) args [ num ] ; constructor = get constructor ( prepare statement idx , prepared statement . class ) ; if ( sql != null ) { prepare statement ( sql , time ) ; } } else if ( compare ( prepare call , name ) ) { sql = ( string ) args [ num ] ; constructor = get constructor ( prepare call idx , callable statement . class ) ; prepare call ( sql , time ) ; } else { return statement ; } result = constructor . new instance ( new object [ ] { new statement proxy ( statement , sql ) } ) ; return result ; } catch ( exception x ) { log . warn ( str , x ) ; } return statement ; }	creates a statement interceptor to monitor query response times.
public update response remove ( long id ) throws io , solr server exception { update response res = solr client . delete by id ( string . value of ( id ) ) ; solr client . commit ( bool , bool , bool ) ; return res ; }	deletes a solrdocument with the given id .
public void switch setup ( ) { int ret val ; ret val = m . show open dialog ( this ) ; if ( ret val != j . approve option ) { return ; } m . initialize ( m . get selected file ( ) ) ; m url = m . get database url ( ) ; m = m . get username ( ) ; m = m . get password ( ) ; m url . set text ( m url ) ; }	lets the user select a props file for changing the database connection parameters .
private client details entity load client object ( final oidc authorization request ) { log . debug ( str , authorization request . get client id ( ) ) ; return client service . load client by client id ( authorization request . get client id ( ) ) ; }	load client object client details entity .
public void add field property ( string name , string accessor field ) { field properties . add ( new legacy field prop desc ( name , accessor field ) ) ; }	adds the named event property backed by the named accessor field .
private void parse no wild cards ( ) { this . f segments = new string [ num ] ; this . f segments [ num ] = this . f pattern ; this . f bound = this . f length ; }	this method parses the given pattern into segments seperated by wildcard ' * ' characters.
public map < string , string > environment ( ) { string base64 = to string base64 ( ) ; if ( base64 == null || base64 . length ( ) == num ) { return collections . empty map ( ) ; } map < string , string > environment = maps . new hash map ( ) ; environment . put ( baggage utils . baggage environment variable , base64 ) ; return environment ; }	encodes the baggage to strings to set as environment variables , which will then be picked up in a child process.
@ override public void draw series ( canvas canvas , paint paint , list < float > points , list < double > values , xy series renderer , support series render support series render , float y axis value , int series index , int start index ) { int series nr = m dataset . get series count ( ) ; int length = points . size ( ) ; paint . set color ( series renderer . get color ( ) ) ; paint . set style ( style . fill ) ; float half diff x = get half diff x ( points , length , series nr ) ; for ( int i = num ; i < length ; i += num ) { float x = points . get ( i ) ; float y = points . get ( i + num ) ; draw bar ( canvas , x , y axis value , x , y , half diff x , series nr , series index , paint ) ; } paint . set color ( series renderer . get color ( ) ) ; }	the graphical representation of a series .
public void listen mod log ( string username , string token ) { if ( ! has server ( ) ) { return ; } if ( mod log listen . contains key ( username ) ) { return ; } this . token = token ; long user id = get user id ( username ) ; mod log listen . put ( username , user id ) ; logger . info ( str + username + str + user id ) ; if ( user id != - num ) { send listen mod log ( user id , bool ) ; } }	start receiving the modlog for the given channel ( username ).
public static boolean is valid class name ( string class name ) { if ( class name . index of ( str ) >= num ) { return bool ; } return bool ; }	return whether or not the given class name is valid .
@ suppress warnings ( str ) public void new minute ( ) { if ( ! in sync with internal fast clock ) { return ; } if ( correct fast clock || synchronize with internal clock ) { date now = clock . get time ( ) ; if ( now . get minutes ( ) != num ) { cur days = now . get date ( ) ; cur hours = now . get hours ( ) ; cur minutes = now . get minutes ( ) ; long millis = now . get time ( ) ; long elapsed ms = millis % msecperminute ; double frac min = elapsed ms / ( double ) msecperminute ; cur fractional minutes = ( int ) correction - ( int ) ( correction * frac min ) ; set clock ( ) ; } } else if ( set internal && ! correct fast clock && ! synchronize with internal clock ) { in sync with internal fast clock = bool ; initiate read ( ) ; } }	corrects the loconet fast clock.
private < t extends discovered system object > boolean is data collection scan job scheduling needed ( long last scan time , boolean in progress ) { long system time = system . current time millis ( ) ; long refresh interval = get refresh interval ( controller service impl . scanner ) ; if ( in progress ) { return bool ; } if ( last scan time > num && ( system time - last scan time < refresh interval * num ) ) { logger . info ( str ) ; return bool ; } return bool ; }	if the job is in progress , don ' t schedule the job.
private void remove breakpoints ( final set < breakpoint address > breakpoint address set , final breakpoint storage storage ) { if ( breakpoint address set . size ( ) != num ) { final set < breakpoint > breakpoints = storage . get break points by address ( breakpoint address set ) ; storage . remove breakpoints ( breakpoint address set ) ; for ( final breakpoint manager listener listener : listeners ) { try { listener . breakpoints removed ( breakpoints ) ; } catch ( final exception e ) { c . log exception ( e ) ; } } } }	remove the given set of breakpoints .
public void replace creation template ( guid guid , string template name , attr set attr set ) throws config manager exception { if ( guid == null ) { guid = new guid ( root dn ) ; } dn dn = dn . value of ( guid . get dn ( ) ) ; string org = str ; list < rdn > rdns = new array list < > ( ) ; for ( rdn rdn : dn ) { rdns . add ( num , rdn ) ; } for ( rdn rdn : rdns ) { org = org + str + ldap . rdn value ( rdn ) ; } string service = creationpath + str + template name ; map map = convert to map ( attr set ) ; try { replace service attributes ( org , service , map ) ; } catch ( sms e ) { string args [ ] = new string [ num ] ; args [ num ] = e . to string ( ) ; throw new config manager exception ( i18n . get string ( iums . error cm , args ) ) ; } catch ( sso se ) { string args [ ] = new string [ num ] ; args [ num ] = se . to string ( ) ; throw new config manager exception ( i18n . get string ( iums . error cm , args ) ) ; } }	replaces an existing template .
private void read object ( object input stream stream ) throws io , class not found exception { stream . default read object ( ) ; marshalled instance mi = ( marshalled instance ) stream . read object ( ) ; try { listener = ( remote event listener ) mi . get ( bool ) ; } catch ( throwable e ) { if ( e instanceof error && throwable constants . retryable ( e ) == throwable constants . bad object ) { throw ( error ) e ; } logger . log ( level . warning , str , e ) ; } }	unmarshals the event listener .
public void add ( t item ) { if ( set . add ( item ) ) { fire contents changed ( this , num , get size ( ) - num ) ; } }	adds the specified item to this list model.
private string byte array to hex string ( byte [ ] bytes ) { string builder sb = new string builder ( bytes . length * num ) ; for ( byte element : bytes ) { int v = element & num ; if ( v < num ) { sb . append ( str ) ; } sb . append ( integer . to hex string ( v ) ) ; } return sb . to string ( ) ; }	using some super basic byte array & lt ; - & gt ; hex conversions so we don ' t have to rely on any large base64 libraries . can be overridden if you like !.
public sc server create cluster server ( string ssn , string cluster name , string os id ) throws api { parameters params = new parameters ( ) ; params . add ( str , cluster name ) ; params . add ( str , ssn ) ; params . add ( str , notes string ) ; params . add ( str , os id ) ; rest result rr = rest client . post ( str , params . to json ( ) ) ; if ( ! check results ( rr ) ) { string error = string . format ( str , cluster name , rr . get error msg ( ) ) ; throw new api ( error ) ; } return gson . from json ( rr . get result ( ) , sc server . class ) ; }	creates a new cluster server definition .
public void test constructor sign bytes positive4 ( ) { byte a bytes [ ] = { num , num , num , - num } ; int a sign = num ; byte r bytes [ ] = { num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void test minimal completion stage ( ) { completable future < integer > f = new completable future < > ( ) ; completion stage < integer > g = f . minimal completion stage ( ) ; atomic integer x = new atomic integer ( num ) ; atomic reference < throwable > r = new atomic reference < throwable > ( ) ; check incomplete ( f ) ; g . when complete ( null ) ; f . complete ( num ) ; check completed normally ( f , num ) ; assert equals ( x . get ( ) , num ) ; assert null ( r . get ( ) ) ; }	minimalcompletionstage returns a completablefuture that is completed normally , with the same value , when source is .
private void write directory post resource ( element post resource el , string path ) { post resource el . set attribute ( str , dir resource set ) ; post resource el . set attribute ( str , path . replace ( str , str ) ) ; }	write directory post resource.
private static int [ ] trim array ( int [ ] array , int size ) { if ( size < num ) { throw new illegal argument exception ( ) ; } if ( size == num ) { return no errors ; } int [ ] a = new int [ size ] ; system . arraycopy ( array , num , a , num , size ) ; return a ; }	trim the array to the required size .
static potion type from name ( string name ) { for ( potion type table table : values ( ) ) { if ( name . equals ignore case ( table . name ) ) return table . type ; } return potion type . value of ( name . to upper case ( ) ) ; }	converts a vanilla potion id to an equivalent bukkit potiontype.
public synchronized void remove curl mesh ( curl mesh mesh ) { while ( m curl meshes . remove ( mesh ) ) ; }	removes curlmesh from this renderer .
private list < datum > sample nbest list ( int source id , sequence < i > source , sentence level metric < i , string > score metric , list < rich translation < i , string > > translations , list < sequence < i > > references ) { int [ ] source ids = new int [ num ] ; source ids [ num ] = source id ; list < sequence < i > > sources = new array list < > ( num ) ; sources . add ( source ) ; list < list < rich translation < i , string > > > translation list = new array list < list < rich translation < i , string > > > ( num ) ; translation list . add ( translations ) ; list < list < sequence < i > > > reference list = new array list < list < sequence < i > > > ( num ) ; reference list . add ( references ) ; return sample nbest lists ( source ids , sources , score metric , translation list , reference list ) ; }	select pro samples from a single instance .
protected void post runnable ( runnable runnable ) { if ( runnable != null ) { handler . post ( runnable ) ; } }	helper method to send runnable into local handler loop.
public boolean is closed ( ) { return map . is closed ( ) ; }	check whether this map is closed .
public void insert think time ( ) { script step think time script step = script step factory . create think time ( get min think time ( ) , get max think time ( ) ) ; steps . add ( get insert index ( ) , think time script step ) ; min think time = str ; max think time = str ; reindex script steps ( ) ; }	does something to insert think time into the script .
public void add node ( final instruction instruction ) { instructions . add ( instruction ) ; if ( prev instruction != null ) { add edge ( prev instruction , instruction ) ; } prev instruction = instruction ; }	add new node and set prev instruction pointing to this instruction.
public void ensure capacity ( int minimum capacity ) { if ( minimum capacity <= capacity ) return ; if ( minimum capacity > num ) { capacity = ( minimum capacity + num ) & ~ num ; } else { while ( capacity < minimum capacity ) { capacity += capacity ; } } byte [ ] bytes = new byte [ capacity ] ; system . arraycopy ( buffer , num , bytes , num , length ) ; buffer = bytes ; }	ensure the buffer can hold at least ' minimumcapacity ' bytes .
public builder remove name ( final string name ) { names . remove ( name ) ; return this ; }	removes the provided user friendly name .
public < t > jsonapi < list < t > > read document collection ( input stream data stream , class < t > clazz ) { try { resource cache . init ( ) ; json node root node = object mapper . read tree ( data stream ) ; validation utils . ensure not error ( object mapper , root node ) ; validation utils . ensure collection ( root node ) ; resource cache . cache ( parse included ( root node ) ) ; list < t > resource list = new array list < > ( ) ; for ( json node element : root node . get ( data ) ) { t pojo = read object ( element , clazz , bool ) ; resource list . add ( pojo ) ; } jsonapi < list < t > > result = new jsonapi < > ( resource list , object mapper ) ; if ( root node . has ( meta ) ) { result . set meta ( map meta ( root node . get ( meta ) ) ) ; } if ( root node . has ( links ) ) { result . set links ( new links ( map links ( root node . get ( links ) ) ) ) ; } return result ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { resource cache . clear ( ) ; } }	reads json api spec document and converts it into collection of target type objects .
public void add targeted by swarm ( int entity id , int weapon id ) { hit by swarms entity . add element ( new integer ( entity id ) ) ; hit by swarms weapon . add element ( new integer ( weapon id ) ) ; }	add a targeting by a swarm volley from a specified entity.
private boolean is checkpoint exists ( connection conn , string key ) throws sql { prepared statement st = null ; result set rs = null ; try { st = conn . prepare statement ( chk exists sql ) ; st . set string ( num , key ) ; rs = st . execute query ( ) ; return rs . next ( ) ; } finally { u . close ( rs , log ) ; u . close ( st , log ) ; } }	checks specified checkpoint existing .
public om ( double ullat , double ullon , double lrlat , double lrlon , image icon ii ) { this ( ullat , ullon , lrlat , lrlon , ii . get image ( ) ) ; }	create an omraster , lat / lon placement with an imageicon .
public static void copy stream ( input stream is , output stream os , byte [ ] buffer , int buffer size , string confid , double file size , context context ) throws io { double downloaded = num ; int [ ] update = new int [ num ] ; try { for ( ; ; ) { int count = is . read ( buffer , num , buffer size ) ; downloaded += count ; if ( count == - num ) { if ( context != null ) { } break ; } os . write ( buffer , num , count ) ; if ( context != null ) { update [ num ] = ( int ) downloaded ; update [ num ] = ( int ) file size ; update [ num ] = ( int ) ( ( downloaded / file size ) * num ) ; } } } catch ( io e ) { throw e ; } }	copy from one stream to another . throws ioexception in the event of error ( for example , sd card is full ).
@ override public void write header ( ) throws io { os = new pdf ( new buffered output stream ( ros ) , pdf version ) ; delay image queue = new pdf ( os ) ; delay paint queue = new pdf ( os , delay image queue ) ; font table = new pdf ( os ) ; pdf info = os . open doc info ( str ) ; info . set title ( get property ( title ) ) ; info . set author ( get property ( author ) ) ; info . set subject ( get property ( subject ) ) ; info . set keywords ( get property ( keywords ) ) ; info . set creator ( get creator ( ) ) ; info . set producer ( producer == null ? str : producer ) ; if ( ! is device independent ( ) ) { calendar now = calendar . get instance ( ) ; info . set creation date ( now ) ; info . set modification date ( now ) ; } info . set trapped ( str ) ; os . close ( info ) ; pdf catalog = os . open catalog ( str , str ) ; catalog . set outlines ( str ) ; catalog . set page mode ( str ) ; catalog . set viewer preferences ( str ) ; catalog . set open action ( new object [ ] { os . ref ( str ) , os . name ( str ) } ) ; os . close ( catalog ) ; pdf prefs = os . open viewer preferences ( str ) ; prefs . set fit window ( bool ) ; prefs . set center window ( bool ) ; os . close ( prefs ) ; alpha index = num ; ext g = new hash map < float , string > ( ) ; if ( ! is multi page ( ) ) { open page ( get size ( ) , null ) ; } }	writes the catalog , docinfo , preferences , and ( as we use only single page output the page tree .
protected string parse string ( int closing character ) throws io , rdf { string builder sb = get builder ( ) ; while ( bool ) { int c = read code point ( ) ; if ( c == closing character ) { break ; } else if ( c == - num ) { throw eof ( ) ; } append codepoint ( sb , c ) ; if ( c == str ) { c = read code point ( ) ; if ( c == - num ) { throw eof ( ) ; } append codepoint ( sb , c ) ; } } return sb . to string ( ) ; }	parses a " normal string ".
private void code unwrap return value ( class < ? > type , data output stream out ) throws io { if ( type . is primitive ( ) ) { primitive type info prim = primitive type info . get ( type ) ; out . write byte ( opc checkcast ) ; out . write short ( cp . get class ( prim . wrapper class name ) ) ; out . write byte ( opc invokevirtual ) ; out . write short ( cp . get method ref ( prim . wrapper class name , prim . unwrap method name , prim . unwrap method desc ) ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { out . write byte ( opc ireturn ) ; } else if ( type == long . class ) { out . write byte ( opc lreturn ) ; } else if ( type == float . class ) { out . write byte ( opc freturn ) ; } else if ( type == double . class ) { out . write byte ( opc dreturn ) ; } else { throw new assertion error ( ) ; } } else { out . write byte ( opc checkcast ) ; out . write short ( cp . get class ( dot to slash ( type . get name ( ) ) ) ) ; out . write byte ( opc areturn ) ; } }	generate code for unwrapping a return value of the given type from the invocation handler ' s " invoke " method ( as type object ) to its correct type.
private string format link ( string [ ] parts ) { string anchor , text ; if ( parts . length < num ) { anchor = str ; text = str ; } else { anchor = parts [ num ] ; text = parts [ num ] ; } return string . format ( str , anchor , text ) ; }	formats a link , given an array of tokens .
public json ( throwable cause ) { super ( cause . get message ( ) ) ; this . cause = cause ; }	constructs a new jsonexception with the specified cause .
public boolean fix utils ( string [ ] utils ) throws exception { for ( string util : utils ) { if ( ! check util ( util ) ) { if ( check util ( str ) ) { if ( has util ( util , str ) ) { fix util ( util , root tools . util path ) ; } } else { if ( check util ( str ) ) { if ( has util ( util , str ) ) { fix util ( util , root tools . util path ) ; } } else { return bool ; } } } } return bool ; }	this will check an array of binaries , determine if they exist and determine that it has either the permissions 755 , 775 , or 777.
@ override protected void initialize ( ) { list < string > patterns ; super . initialize ( ) ; m = new array list < pattern > ( ) ; patterns = read ( ) ; for ( string pattern : patterns ) { m . add ( pattern . compile ( pattern ) ) ; } }	performs intialization of the scheme .
public static string [ ] ls directories ( string directory ) throws exception { string [ ] tmp = ls ( directory ) ; array list < string > files = new array list < > ( ) ; for ( string s : tmp ) { if ( is directory ( directory + file . separator + s ) ) files . add ( s ) ; } return files . to array ( new string [ files . size ( ) ] ) ; }	list the directories contained within a directory .
private void to string with children ( string buffer buffer , int indent ) { internal to string ( buffer , indent ) ; if ( f children != null ) { for ( iterator < text edit > iterator = f children . iterator ( ) ; iterator . has next ( ) ; ) { text edit child = iterator . next ( ) ; buffer . append ( str ) ; child . to string with children ( buffer , indent + num ) ; } } }	adds the string representation for this text edit and its children to the given string buffer .
public static void encode ( appendable out , int value ) throws io { value = to vlq ( value ) ; do { int digit = value & vlq base mask ; value >>>= vlq base shift ; if ( value > num ) { digit |= vlq continuation bit ; } out . append ( base64 . to base64 ( digit ) ) ; } while ( value > num ) ; }	writes a vlq encoded value to the provide appendable .
public mx i remove cell overlay ( object cell , mx i overlay ) { if ( overlay == null ) { remove cell overlays ( cell ) ; } else { mx i [ ] arr = get cell overlays ( cell ) ; if ( arr != null ) { list < mx i > list = arrays . as list ( arr ) ; if ( list . remove ( overlay ) ) { remove cell overlay component ( overlay , cell ) ; } arr = ( mx i [ ] ) list . to array ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }	removes and returns the given overlay from the given cell.
public void remove foreign key ( int idx ) { foreign keys . remove ( idx ) ; }	removes the indicated foreign key .
public java . lang . string buffer insert ( int offset , int i ) { internal . insert ( offset , i ) ; return this ; }	inserts the string representation of the second int argument into this string buffer.
public void add gefaehrdungs umsetzung ( gefaehrdungs umsetzung gefaehrdung ) { if ( ! all gefaehrdungs umsetzungen . contains ( gefaehrdung ) ) { all gefaehrdungs umsetzungen . add ( gefaehrdung ) ; } }	adds a gefaehrdung to the list of all gefaehrdungen if gefaehrdung not already exits .
string normalize class path ( string class path , boolean generate relative ) { char sep = caucho util . get path separator char ( ) ; int head = num ; int tail = num ; char buffer cb = char buffer . allocate ( ) ; while ( head < class path . length ( ) ) { tail = class path . index of ( sep , head ) ; if ( tail < num ) tail = class path . length ( ) ; if ( tail > head ) { string segment = class path . substring ( head , tail ) ; segment = normalize path ( segment , generate relative ) ; if ( segment != null ) { if ( cb . length ( ) != num ) cb . append ( sep ) ; cb . append ( segment ) ; } } head = tail + num ; } return cb . close ( ) ; }	converts any relative classpath references to the full path .
protected as ( as obj ) { seq . add element ( obj ) ; }	create a sequence containing one object.
public final void push ( int value ) { int ff = m first free ; if ( ( ff + num ) >= m map size ) { if ( null == m map ) { m map = new int [ m blocksize ] ; m map size = m blocksize ; } else { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , ff + num ) ; m map = new map ; } } m map [ ff ] = value ; ff ++ ; m first free = ff ; }	append a node onto the vector .
protected node string conversion ( node node ) { type element string element = elements . get type element ( str ) ; if ( ! types utils . is string ( node . get type ( ) ) ) { node converted = new string conversion node ( node . get tree ( ) , node , string element . as type ( ) ) ; add to converted lookup map ( converted ) ; insert node after ( converted , node ) ; return converted ; } else { return node ; } }	convert the input node to string type , if it isn ' t already .
@ known failure ( str ) public void test update7 ( ) throws sql { database creator . fill fk ( conn ) ; statement . execute update ( str + database creator . fkstrict table + str + database creator . parent table + str ) ; result set r = statement . execute query ( str + database creator . fkstrict table + str ) ; r . next ( ) ; assert equals ( str , num , r . get int ( num ) ) ; r . close ( ) ; }	updatefunctionalitytest2 # testupdate7 ( ) . updates table using subquery in where clause todo foreign key functionality is not supported.
completable future < history read response > history read ( history read details history read details , timestamps to return timestamps to return , boolean release continuation points , list < history read value id > nodes to read ) ;	this service is used to read historical values or events of one or more nodes .
private void validate ( ) throws uri { string s = get scheme ( ) ; if ( ( s != null ) && ( s . compare to ( str ) == num ) ) { return ; } if ( get local vm id ( ) == - num ) { throw new uri ( uri . to string ( ) , str ) ; } }	check that the vmidentifier includes a unique numerical identifier for the target jvm .
public synchronized void finish writing ( ) { done writing = bool ; notify all ( ) ; }	stream will close after the already written bytes are read .
private long offset2 physical address ( final long offset ) { return offset + header size ; }	adjusts the offset by the headersize , such that writing to a zero offset would not corrupt the header .
@ override public void internal entity decl ( string name , xml text , xml non normalized text , augmentations augs ) throws xni { try { if ( f decl handler != null ) { f decl handler . internal entity decl ( name , text . to string ( ) ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	an internal entity declaration .
public static boolean is authorized ( string log name , string operation , object credential ) { return authorizer . is authorized ( log name , operation , credential ) ; }	returns true if a given log record should be published .
public object next ( ) { if ( pos < size ) return array . get ( array , pos ++ ) ; throw new no such element exception ( str + pos + str + size ) ; }	move to next element in the array .
public void add messages ( list < ? extends message > messages ) { if ( show logs ) logger . v ( tag , str + messages ) ; m queue lock . lock ( tag ) ; m player messages queue . add all ( messages ) ; m queue lock . notify ( tag ) ; if ( show logs ) logger . v ( tag , str + messages ) ; m queue lock . unlock ( tag ) ; }	use it if you need to add a multiple messages.
public permission request object on rational ( func3 rational func ) { m rational func = rational func ; return this ; }	called for the first denied permission if there is need to show the rational.
public generic principal ( string user name , string password , list < string > roles , map < string , list < generic principal . attribute > > write entries , map < string , list < generic principal . attribute > > read entries , map < string , list < generic principal . attribute > > execute tasks ) { this . user name = user name ; this . password = password ; this . write entries = write entries ; this . read entries = read entries ; this . execute tasks = execute tasks ; if ( roles != null ) { this . roles = new string [ roles . size ( ) ] ; this . roles = roles . to array ( this . roles ) ; if ( this . roles . length > num ) arrays . sort ( this . roles ) ; } write match objects = new hash map < string , match object > ( ) ; read match objects = new hash map < string , match object > ( ) ; execute match objects = new hash map < string , match object > ( ) ; user defined roles = new array list < string > ( ) ; }	construct a new principal for the specified username and password , with the specified role names ( as strings ) .
public boolean equals ( object other ) { if ( other == this ) { return bool ; } if ( ! ( other instanceof crl ) ) { return bool ; } crl obj = ( crl ) other ; try { return arrays . equals ( get encoded ( ) , obj . get encoded ( ) ) ; } catch ( crl e ) { return bool ; } }	returns whether the specified object equals to this instance .
public static int roll1 d6 ( ) { return rand . next int ( num ) + num ; }	simulates rolling a dice with 6 sides .
static byte [ ] septet stream2octet stream ( byte [ ] septets ) { int octet length = ( int ) math . ceil ( ( ( septets . length * num ) ) / num ) ; byte [ ] octets = new byte [ octet length ] ; for ( int i = num ; i < septets . length ; i ++ ) { for ( int j = num ; j < num ; j ++ ) { if ( ( septets [ i ] & ( num << j ) ) != num ) { int bit index = ( i * num ) + j ; octets [ bit index > > > num ] |= num << ( bit index & num ) ; } } } return octets ; }	convert a list of septet values into an octet stream , with a number of empty bits at the start .
public c ( final j parent , final zy graph graph , final i manager ) { super ( new border layout ( ) ) ; m tags tree = new c ( parent , graph , manager ) ; final j pane = new j ( m tags tree ) ; pane . set vertical scroll bar policy ( scroll pane constants . vertical scrollbar as needed ) ; pane . set horizontal scroll bar policy ( scroll pane constants . horizontal scrollbar as needed ) ; add ( pane ) ; set border ( new titled border ( new line border ( color . light gray , num , bool ) , str ) ) ; set double buffered ( bool ) ; }	creates a new panel object .
@ override public double height ( final int marker index ) { math utils . check range inclusive ( marker index , num , marker array . length - num ) ; return marker array [ marker index ] . marker height ; }	return marker height given index.
public < k , v > void consume ( string group id , string client id , offset reset strategy auto offset reset , deserializer < k > key deserializer , deserializer < v > value deserializer , boolean supplier continuation , offset commit callback offset commit callback , runnable completion , collection < string > topics , java . util . function . consumer < consumer record < k , v > > consumer function ) { properties props = get consumer properties ( group id , client id , auto offset reset ) ; thread t = new thread ( null ) ; t . set name ( client id + str ) ; t . start ( ) ; }	use the supplied function to asynchronously consume messages from the cluster .
public double distance ( instance first , instance second , performance stats stats ) { return math . sqrt ( distance ( first , second , double . positive infinity , stats ) ) ; }	calculates the distance ( or similarity ) between two instances.
public void find same as chaining ( resource subj , set < resource > current same as , resource [ ] contxts ) throws inference engine exception { try { closeable iteration < statement , query evaluation exception > subj iter = dao . query ( rya dao , subj , owl . sameas , null , conf , contxts ) ; while ( subj iter . has next ( ) ) { statement st = subj iter . next ( ) ; if ( ! current same as . contains ( st . get object ( ) ) ) { resource casted obj = ( resource ) st . get object ( ) ; current same as . add ( casted obj ) ; find same as chaining ( casted obj , current same as , contxts ) ; } } subj iter . close ( ) ; closeable iteration < statement , query evaluation exception > obj iter = dao . query ( rya dao , null , owl . sameas , subj , conf , contxts ) ; while ( obj iter . has next ( ) ) { statement st = obj iter . next ( ) ; if ( ! current same as . contains ( st . get subject ( ) ) ) { resource same as subj = st . get subject ( ) ; current same as . add ( same as subj ) ; find same as chaining ( same as subj , current same as , contxts ) ; } } obj iter . close ( ) ; } catch ( query evaluation exception e ) { throw new inference engine exception ( e ) ; } }	todo : this chaining can be slow at query execution . the other option is to perform this in the query itself , but that will be constrained to how many levels we decide to go.
public static void reindex ( connection conn ) throws sql { init ( conn ) ; remove all triggers ( conn , trigger prefix ) ; remove index files ( conn ) ; statement stat = conn . create statement ( ) ; result set rs = stat . execute query ( str + schema + str ) ; while ( rs . next ( ) ) { string schema = rs . get string ( str ) ; string table = rs . get string ( str ) ; create trigger ( conn , schema , table ) ; index existing rows ( conn , schema , table ) ; } }	re - creates the full text index for this database.
string to dot ( ) { string builder buf = new string builder ( ) ; for ( type t : inference context . undetvars ) { undet var uv = ( undet var ) t ; buf . append ( string . format ( str , uv . qtype , uv . get bounds ( inference bound . upper ) , uv . get bounds ( inference bound . lower ) , uv . get bounds ( inference bound . eq ) ) ) ; } return graph utils . to dot ( nodes , str + hash code ( ) , buf . to string ( ) ) ; }	debugging : dot representation of this graph.
private void resize tables ( ) { if ( m object data used > m object data . length - max data size ) { m object data = arrays . copy of ( m object data , m object data . length * num ) ; } if ( m object count < m types . length ) { return ; } m object offset = arrays . copy of ( m object offset , m object offset . length * num ) ; m types = arrays . copy of ( m types , m types . length * num ) ; m objects = arrays . copy of ( m objects , m objects . length * num ) ; m rect = arrays . copy of ( m rect , m rect . length * num ) ; }	resize tables as the number of objects grow.
private boolean has next inet socket address ( ) { return next inet socket address index < inet socket addresses . size ( ) ; }	returns true if there ' s another socket address to try .
protected static double convert percentile to x ( double percentile level iterated to ) { double x = num / ( num - ( percentile level iterated to / num ) ) ; return math . log10 ( x ) ; }	x = 1 / ( 1 - percentage ).
public static string queue name from db ( string db name ) { string [ ] tokens = db name . split ( str , num ) ; return tokens [ num ] ; }	extracts the queue name given a pinlater queue database name .
public string use this ( int type , string id , string context ) { int i = find sym ( type , id , context ) ; if ( i == symtab . size ( ) ) return id ; else return ( ( sym tab entry ) symtab . element at ( i ) ) . use this ; }	routines for returning disambiguated names .
private float angle ( touch state s ) { return ( float ) math . to degrees ( math . atan2 ( s . y down - s . y current , s . x down - s . x current ) ) ; }	angle between the current touch coordinates and the down coordinates.
private int uint16 from data ( int offset ) { return two bytes to int ( arrays . copy of range ( data ( ) , offset , offset + num ) , constants . c byte order ) ; }	parse a little - endian uint16 from the data at the given offset .
private static string remove quotes encolosing option ( string file name , string option ) throws exception { string option1 = remove quote characters if necessary ( file name , option , str ) ; if ( ! option1 . equals ( option ) ) { return option1 ; } return remove quote characters if necessary ( file name , option , str ) ; }	removes the surrounding quote characters as needed.
@ override public string generate label ( xy dataset , int series ) { param checks . null not permitted ( dataset , str ) ; string label = message format . format ( this . format pattern , create item array ( dataset , series ) ) ; return label ; }	generates a label for the specified series.
private boolean match strings ( string pattern , string str , map < string , string > uri template variables ) { ant path string matcher matcher = new ant path string matcher ( pattern , str , uri template variables ) ; return matcher . match strings ( ) ; }	tests whether or not a string matches against a pattern . the pattern may contain two special characters : < br > ' * ' means zero or more characters < br > ' ? ' means one and only one character.
@ nullable public dimension adjust ( @ not null dimension new preferred size , @ nullable dimension old preferred size , @ not null editor impl editor ) { if ( old preferred size == null || my skip ) { return new preferred size ; } if ( new preferred size . height != old preferred size . height ) { return new preferred size ; } strip timings ( ) ; my timings . add ( system . current time millis ( ) ) ; if ( my timings . size ( ) < frequent size changes number ) { return new preferred size ; } boolean increase width = new preferred size . width > old preferred size . width ; dimension result ; if ( increase width ) { final int space width = editor util . get space width ( font . plain , editor ) ; new preferred size . width += my reserve columns * space width ; my reserve columns += num ; result = new preferred size ; } else { result = old preferred size ; } schedule size update ( editor ) ; return result ; }	asks to adjust new preferred size appliance if necessary .
public rvm find declared field ( atom field name , atom field descriptor ) { for ( rvm field : declared fields ) { if ( field . get name ( ) == field name && field . get descriptor ( ) == field descriptor ) { return field ; } } return null ; }	find description of a field of this class .
public quarter ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }	constructs a quarter , based on a date / time and time zone .
private util ( ) { }	this class is never instantiated.
default b with default ( string key , float value ) { return with default ( key , float . to string ( value ) ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
public static boolean read boolean ( final json json array , final int index , final boolean required , final boolean not null ) throws json { if ( required ) { return json array . get boolean ( index ) ; } if ( not null && json array . is null ( index ) ) { throw new json ( string . format ( locale . us , null value format array , index ) ) ; } boolean value = bool ; if ( ! json array . is null ( index ) ) { value = json array . get boolean ( index ) ; } return value ; }	reads the boolean value from the json array for specified index.
protected static void auto boxing ( method visitor mv , type field type ) { switch ( field type . get sort ( ) ) { case type . boolean : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . byte : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . char : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . short : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . int : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . float : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . long : mv . visit method insn ( invokestatic , str , str , str ) ; break ; case type . double : mv . visit method insn ( invokestatic , str , str , str ) ; break ; } }	append the call of proper autoboxing method for the given primitif type .
public final void open pdf file ( final byte [ ] data ) throws pdf exception { final random access buffer pdf datafile ; try { if ( pdf file reader . always cache in memory == - num || data . length < pdf file reader . always cache in memory ) { pdf datafile = new random access data buffer ( data ) ; } else { try { final file file = file . create temp file ( str , str , new file ( object store . temp dir ) ) ; temp file name = file . get absolute path ( ) ; final java . io . file output stream a = new java . io . file output stream ( file ) ; a . write ( data ) ; a . flush ( ) ; a . close ( ) ; pdf datafile = new random access file buffer ( temp file name , str ) ; } catch ( final exception e ) { throw new runtime exception ( str + object store . temp dir + str + e ) ; } } object reader . init ( pdf datafile ) ; } catch ( final exception e ) { log writer . write log ( str + e + str ) ; throw new pdf exception ( str + e + str ) ; } }	open pdf file using a byte stream - by default files under 16384 bytes are cached to disk but this can be altered by setting pdffilereader . alwayscacheinmemory to a maximimum size or - 1 ( always keep in memory ).
public static void main ( string [ ] args ) { if ( args . length < num ) { logger . error ( str ) ; return ; } int last index = args . length - num ; path [ ] files = get files ( args ) ; main main = new main ( ) ; main . generate ( files [ last index ] , arrays . copy of ( files , last index ) ) ; }	generate allure report data from directories with allure report results .
@ nullable e await match ( int start ) { for ( int step = num , total spins = num ; ( step < arena length ) && ( total spins < spins ) ; step ++ ) { int index = ( start + step ) & arena mask ; atomic reference < object > slot = arena [ index ] ; object found = slot . get ( ) ; if ( found == free ) { if ( slot . compare and set ( free , waiter ) ) { int slot spins = num ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != waiter ) && slot . compare and set ( found , free ) ) { @ suppress warnings ( str ) e e = ( e ) found ; return e ; } else if ( ( slot spins >= spins per step ) && ( found == waiter ) && ( slot . compare and set ( waiter , free ) ) ) { total spins += slot spins ; break ; } slot spins ++ ; } } } else if ( ( found != waiter ) && slot . compare and set ( found , free ) ) { @ suppress warnings ( str ) e e = ( e ) found ; return e ; } } return null ; }	waits for ( by spinning ) to have an element transfered from another thread.
private array list < signature > construct one signatures ( dbi [ ] [ ] partitions , final long [ ] [ ] markers ) { final int dim = partitions . length ; array list < signature > signatures = new array list < > ( ) ; for ( int d = num ; d < dim ; d ++ ) { final dbi [ ] parts = partitions [ d ] ; if ( parts == null ) { continue ; } final long [ ] marked = markers [ d ] ; for ( int start = bits util . next set bit ( marked , num ) ; start >= num ; ) { int end = bits util . next clear bit ( marked , start + num ) ; end = ( end == - num ) ? dim : end ; int [ ] signature = new int [ dim << num ] ; arrays . fill ( signature , - num ) ; signature [ d << num ] = start ; signature [ ( d << num ) + num ] = end - num ; dbi sids = union dbi ( parts , start , end ) ; if ( log . is debugging ( ) ) { log . debug ( str + d + str + start + str + ( end - num ) ) ; } signatures . add ( new signature ( signature , sids ) ) ; start = ( end < dim ) ? bits util . next set bit ( marked , end + num ) : - num ; } } return signatures ; }	construct the 1 - signatures by merging adjacent dense bins .
public void test test bit positive1 ( ) { byte a bytes [ ] = { - num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; big integer a number = new big integer ( a sign , a bytes ) ; assert true ( ! a number . test bit ( number ) ) ; }	testbit ( int n ) of a positive number.
public static int find end trim newline chars ( char sequence s ) { for ( int i = s . length ( ) ; i > num ; ) { if ( s . char at ( i - num ) != str ) { return i ; } i -- ; if ( i > num && s . char at ( i - num ) == str ) { i -- ; } } return num ; }	finds and returns the end of the given character sequence after trimming new line characters from the right.
private void calc coordinates ( final float x , final float [ ] [ ] trm , float char spacing ) { final float [ ] [ ] trm = new float [ num ] [ num ] ; for ( int xx = num ; xx < num ; xx ++ ) { system . arraycopy ( trm [ xx ] , num , trm [ xx ] , num , num ) ; } x1 = x ; x2 = trm [ num ] [ num ] - ( char spacing * trm [ num ] [ num ] ) ; if ( glyph data . is horizontal ( ) ) { if ( trm [ num ] [ num ] < num ) { x1 = x + trm [ num ] [ num ] - ( char spacing * trm [ num ] [ num ] ) ; x2 = trm [ num ] [ num ] ; } else if ( trm [ num ] [ num ] > num ) { x1 = x ; x2 = trm [ num ] [ num ] ; } } else if ( trm [ num ] [ num ] > num ) { x1 = trm [ num ] [ num ] ; x2 = x + trm [ num ] [ num ] - ( char spacing * trm [ num ] [ num ] ) ; } else if ( trm [ num ] [ num ] < num ) { x2 = trm [ num ] [ num ] ; x1 = x + trm [ num ] [ num ] - ( char spacing * trm [ num ] [ num ] ) ; } }	calculate the x coords for text here y coords are calculated in the method processtextarray ( final byte [ ] stream , int startcommand , int datapointer ).
protected java . util . date from julian ( int julian ) { ymd ymd = new ymd ( julian ) ; gregorian calendar cal = new gregorian calendar ( ymd . year , ymd . month - num , ymd . day ) ; return cal . get time ( ) ; }	convert a julian to it ' s java date equivalent .
public synchronized boolean remove last ( k obj ) { if ( peek last ( ) != obj ) { return bool ; } array = arrays . copy of ( array , array . length - num ) ; return bool ; }	remove the last element , if it matches .
private boolean serialize compact rdf ( xmp node , int indent , boolean has rdf ) throws xmp , io { boolean has attr fields = bool ; boolean has elem fields = bool ; boolean emit end tag = bool ; for ( iterator ic = node . iterate children ( ) ; ic . has next ( ) ; ) { xmp field = ( xmp ) ic . next ( ) ; if ( can be rdf ( field ) ) { has attr fields = bool ; } else { has elem fields = bool ; } if ( has attr fields && has elem fields ) { break ; } } if ( has rdf && has elem fields ) { throw new xmp ( str , xmp . badrdf ) ; } if ( ! node . has children ( ) ) { write ( str ) ; write newline ( ) ; emit end tag = bool ; } else if ( ! has elem fields ) { serialize compact rdf ( node , indent + num ) ; write ( str ) ; write newline ( ) ; emit end tag = bool ; } else if ( ! has attr fields ) { write ( str ) ; write newline ( ) ; serialize compact rdf ( node , indent + num ) ; } else { write ( str ) ; write newline ( ) ; write indent ( indent + num ) ; write ( rdf struct start ) ; serialize compact rdf ( node , indent + num ) ; write ( str ) ; write newline ( ) ; serialize compact rdf ( node , indent + num ) ; write indent ( indent + num ) ; write ( rdf struct end ) ; write newline ( ) ; } return emit end tag ; }	serializes a struct property .
public default utility table query util ( b network , string query var , assignment evidence ) { return query util ( new query . util query ( network , arrays . as list ( query var ) , evidence ) ) ; }	computes the utility table for the query variable ( typically an action variable ) , given the provided evidence.
public static float [ ] string list to numeric ( list < string > score list ) throws number format exception { float [ ] scores = new float [ score list . size ( ) ] ; int score id = num ; for ( string score : score list ) { float float score = ( float ) double . parse double ( score ) ; if ( float . is na n ( float score ) ) { throw new number format exception ( str + score ) ; } scores [ score id ++ ] = float score ; } return scores ; }	converts a string list of scores to float .
@ override public void next ( ) { current image = optional . of ( add index and get image by offset ( + num ) ) ; event bus . post ( new source has pending update event ( this ) ) ; }	assigns the output socket to the next image . ( wraps around ).
protected void parse ( data input stream stream ) throws exception { int size = stream . read int ( ) ; int ret , read = num ; data = new byte [ size ] ; while ( size > num ) { ret = stream . read ( data , read , size ) ; size -= ret ; read += ret ; } }	loading method . ( see nbt_tag ).
private list < activity > find best insertion ( list < activity > partial route , boolean allow as major ) { int start index = num ; int end index = partial route . size ( ) - num ; if ( allow as major ) { start index = num ; end index = partial route . size ( ) ; } list < activity > new list = partial route ; double best = double . positive infinity ; list < activity > best list = null ; for ( int i = start index ; i <= end index ; i ++ ) { list < activity > tmp list = new array list < > ( new list ) ; activity tmp activity = get relocation activity ( ) ; tmp list . add ( i , tmp activity ) ; double tmp = evaluate list ( tmp list ) ; if ( tmp < best ) { if ( i == num ) { tmp activity . set type ( str ) ; tmp activity . set end time ( time . parse time ( str ) ) ; } else if ( i == partial route . size ( ) ) { tmp activity . set type ( str ) ; } else { tmp activity . set type ( str ) ; tmp activity . set maximum duration ( time . parse time ( str ) ) ; } best = tmp ; best list = tmp list ; } } return best list ; }	find the best insertion position for a relocated activity in a given list of current activities .
public void write short ( int value ) throws io { check write primitive types ( ) ; primitive types . write short ( value ) ; }	writes a short ( 16 bit ) to the target stream .
private boolean is initialized ( ) { return pool names != null && ! pool names . is empty ( ) ; }	checks if is initialized .
public void on register click ( view view ) { intent register = new intent ( intent . action view , uri . parse ( get string ( r . string . welcome link url ) ) ) ; set result ( result canceled ) ; start activity ( register ) ; }	starts and activity to open the ' new account ' page in the owncloud web site.
private void register extra valid subject ( string subject ) { extra valid subjects . add ( subject ) ; restored statements . add all ( unknown subjects . remove all ( subject ) ) ; }	register an extra valid subject.
public static string trim line ( string line ) { int idx = line . index of ( str ) ; if ( idx != - num ) { line = line . substring ( num , idx ) ; } return line . trim ( ) ; }	trims a line and removes comments.
public double distance2 ( double p1 , double p2 ) { return ( p1 - p2 ) * ( p1 - p2 ) ; }	calculates the square of the euclidean distance between two 1d points represented by real values .
public static void append instruction ( of . builder fmb , of inst ) { list < of > new il = new array list < of > ( ) ; list < of > old il = fmb . get instructions ( ) ; if ( old il != null ) { new il . add all ( fmb . get instructions ( ) ) ; } for ( of i : new il ) { if ( i . get type ( ) == inst . get type ( ) ) { new il . remove ( i ) ; } } new il . add ( inst ) ; fmb . set instructions ( new il ) ; }	adds the instructions to the list of ofinstructions in the offlowmod.
public iterator < t > iterator ( ) { return order list . iterator ( ) ; }	non - thread safe iterator.
private void verify domains is not in use ( string set domains ) { check for active tenants using domains ( domains ) ; check for vdc roles using domains ( domains ) ; check for tenant roles using domains ( domains ) ; check for user groups using domains ( domains ) ; }	check if given domains are in use or not , if any of them is in use , throw exception .
private hashtable < i , list < i > > filter ( hashtable < i , i [ ] > circle intersections ) { hashtable < i , list < i > > real = new hashtable < i , list < i > > ( ) ; for ( i pt : circle intersections . key set ( ) ) { i [ ] circs = circle intersections . get ( pt ) ; for ( int i = num ; i < circs . length - num ; i ++ ) { for ( int j = i + num ; j < circs . length ; j ++ ) { i [ ] pts = intersects ( circs [ i ] , circs [ j ] ) ; if ( pts != null ) { for ( i p : pts ) { report ( real , p , circs [ i ] , circs [ j ] ) ; } } } } } return real ; }	this method implements the algebraic intersection detection method to determine whether the circles are actually intersecting.
public void init without j ( class fixture , method method ) { this . test class = fixture ; this . test method name = method . get name ( ) ; }	initializes matsimtestutils without requiring the method of a class to be a junit test.
protected java type find serialization type ( annotated a , boolean use static typing , java type declared type ) { class < ? > ser class = annotation introspector . find serialization type ( a ) ; if ( ser class != null ) { class < ? > raw declared = declared type . get raw class ( ) ; if ( ser class . is assignable from ( raw declared ) ) { declared type = declared type . widen by ( ser class ) ; } else { if ( ! raw declared . is assignable from ( ser class ) ) { throw new illegal argument exception ( str + a . get name ( ) + str + ser class . get name ( ) + str + raw declared . get name ( ) ) ; } declared type = config . construct specialized type ( declared type , ser class ) ; } use static typing = bool ; } java type secondary = bean serializer factory . modify secondary types by annotation ( config , a , declared type ) ; if ( secondary != declared type ) { use static typing = bool ; declared type = secondary ; } if ( ! use static typing ) { json serialize . typing typing = annotation introspector . find serialization typing ( a ) ; if ( typing != null ) { use static typing = ( typing == json serialize . typing . static ) ; } } return use static typing ? declared type : null ; }	method that will try to determine statically defined type of property being serialized , based on annotations ( for overrides ) , and alternatively declared type ( if static typing for serialization is enabled ).
private static void convert ( a scene , input stream in , output stream out ) throws io , def exception , parse exception { index unit iu = java parser . parse ( in ) ; extract scene ( iu , scene ) ; try ( writer w = new buffered writer ( new output stream writer ( out ) ) ) { index file writer . write ( scene , w ) ; } }	augment given scene with information from stubfile , reading stubs from input stream and writing jaif to output stream .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }	returns map containing the given entries .
@ override public void write ( char [ ] chr ) throws io { out . write ( chr ) ; }	write the characters from an array .
public static void load ( marytts . modules . synthesis . voice mary voice ) throws no such property exception { if ( mary2freetts voices == null ) mary2freetts voices = new hash map < marytts . modules . synthesis . voice , com . sun . speech . freetts . voice > ( ) ; if ( freetts2mary voices == null ) freetts2mary voices = new hash map < com . sun . speech . freetts . voice , marytts . modules . synthesis . voice > ( ) ; if ( mary2freetts voices . contains key ( mary voice ) ) return ; load ( mary voice , create free tts ( mary voice ) ) ; }	add a freetts voice for a given mary voice.
public void append ( int key , double value ) { if ( m size != num && key <= m keys [ m size - num ] ) { put ( key , value ) ; return ; } int pos = m size ; if ( pos >= m keys . length ) { int n = array utils . ideal int array size ( pos + num ) ; int [ ] nkeys = new int [ n ] ; double [ ] nvalues = new double [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } m keys [ pos ] = key ; m values [ pos ] = value ; m size = pos + num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public synchronized void add incremental classifier listener ( incremental classifier listener cl ) { m incremental classifier listeners . add ( cl ) ; }	add an incremental classifier listener.
public float read r4 ( ) throws java . io . io { return float . int bits to float ( ( int ) read dword ( ) ) ; }	reads an r4 from the file and returns it in a float.
public collection engine generate certificates ( input stream in stream ) throws certificate exception { java . security . cert . certificate cert ; list certs = new array list ( ) ; while ( ( cert = engine generate certificate ( in stream ) ) != null ) { certs . add ( cert ) ; } return certs ; }	returns a ( possibly empty ) collection view of the certificates read from the given input stream instream .
public static boolean files exist on dest but not src ( configuration conf , path src , path dest , optional < path filter > filter ) throws io { set < file status > src file statuses = get file statuses recursive ( conf , src , filter ) ; set < file status > dest file statuses = get file statuses recursive ( conf , dest , filter ) ; map < string , long > src file sizes = null ; map < string , long > dest file sizes = null ; try { src file sizes = get rel path to sizes ( src , src file statuses ) ; dest file sizes = get rel path to sizes ( dest , dest file statuses ) ; } catch ( argument exception e ) { throw new io ( str , e ) ; } for ( string file : dest file sizes . key set ( ) ) { if ( ! src file sizes . contains key ( file ) ) { log . warn ( string . format ( str , file , dest , src ) ) ; return bool ; } } return bool ; }	checks to see if filenames exist on a destination directory that don ' t exist in the source directory.
protected void convert order ( sql select select , blackboard bb , rel collation collation , list < sql node > order expr list , sql node offset , sql node fetch ) { if ( select . get order list ( ) == null || select . get order list ( ) . get list ( ) . is empty ( ) ) { assert collation . get field collations ( ) . is empty ( ) ; if ( ( offset == null || ( ( sql literal ) offset ) . big decimal value ( ) . equals ( big decimal . zero ) ) && fetch == null ) { return ; } } bb . set root ( logical sort . create ( bb . root , collation , offset == null ? null : convert expression ( offset ) , fetch == null ? null : convert expression ( fetch ) ) , bool ) ; if ( order expr list . size ( ) > num && ! bb . top ) { final list < rex node > exprs = new array list < > ( ) ; final rel data type row type = bb . root . get row type ( ) ; final int field count = row type . get field count ( ) - order expr list . size ( ) ; for ( int i = num ; i < field count ; i ++ ) { exprs . add ( rex builder . make input ref ( bb . root , i ) ) ; } bb . set root ( logical project . create ( bb . root , exprs , row type . get field names ( ) . sub list ( num , field count ) ) , bool ) ; } }	converts a query ' s order by clause , if any .
public void tick block ( block pos pos ) { list < block pos > valid coords = new array list < > ( ) ; for ( int x offset = - tick range ; x offset <= tick range ; x offset ++ ) { for ( int z offset = - tick range ; z offset <= tick range ; z offset ++ ) { if ( x offset == num && z offset == num ) continue ; if ( is valid swap position ( pos . add ( x offset , num , z offset ) ) ) valid coords . add ( pos . add ( x offset , num , z offset ) ) ; } } if ( ! valid coords . is empty ( ) && ! world . is remote ) { block pos to swap = valid coords . get ( rand . next int ( valid coords . size ( ) ) ) ; world . set block state ( to swap , state to set , num | num ) ; } }	tick a specific block position , finding the valid blocks immediately adjacent to it and then replacing one at random .
public synchronized int update purchase ( string order id , string product id , purchase state purchase state , long purchase time , string developer payload ) { insert order ( order id , product id , purchase state , purchase time , developer payload ) ; cursor cursor = m db . query ( purchase history table name , history columns , history product id col + str , new string [ ] { product id } , null , null , null , null ) ; if ( cursor == null ) { return num ; } int quantity = num ; try { while ( cursor . move to next ( ) ) { int state index = cursor . get int ( num ) ; purchase state state = purchase state . value of ( state index ) ; if ( state == purchase state . purchased || state == purchase state . refunded ) { quantity += num ; } } update purchased item ( product id , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }	adds the given purchase information to the database and returns the total number of times that the given product has been purchased .
private void configure message label ( j label ) { color color = ( color ) default lookup . get ( option pane , this , str ) ; if ( color != null ) { label . set foreground ( color ) ; } font message font = ( font ) default lookup . get ( option pane , this , str ) ; if ( message font != null ) { label . set font ( message font ) ; } }	configures any necessary colors / fonts for the specified label used representing the message .
public void remove all limit lines ( ) { m limit lines . clear ( ) ; }	removes all limitlines from the axis .
default filterable < t > remove all ( final stream < ? extends t > stream ) { final set < t > set = stream . collect ( collectors . to set ( ) ) ; return filter not ( null ) ; }	remove all elements in the supplied stream from this filterable.
private static metering rectangle [ ] regions for normalized coord ( float nx , float ny , float fraction , final rect crop region , int sensor orientation ) { int min crop edge = math . min ( crop region . width ( ) , crop region . height ( ) ) ; int half side length = ( int ) ( num * fraction * min crop edge ) ; f nsc = camera util . normalized sensor coords for normalized display coords ( nx , ny , sensor orientation ) ; int x center sensor = ( int ) ( crop region . left + nsc . x * crop region . width ( ) ) ; int y center sensor = ( int ) ( crop region . top + nsc . y * crop region . height ( ) ) ; rect metering region = new rect ( x center sensor - half side length , y center sensor - half side length , x center sensor + half side length , y center sensor + half side length ) ; metering region . left = camera util . clamp ( metering region . left , crop region . left , crop region . right ) ; metering region . top = camera util . clamp ( metering region . top , crop region . top , crop region . bottom ) ; metering region . right = camera util . clamp ( metering region . right , crop region . left , crop region . right ) ; metering region . bottom = camera util . clamp ( metering region . bottom , crop region . top , crop region . bottom ) ; return new metering rectangle [ ] { new metering rectangle ( metering region , camer region weight ) } ; }	compute 3a regions for a sensor - referenced touch coordinate.
@ override public void flush ( ) throws io { flush buffer ( ) ; output stream . flush ( ) ; }	flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
public vector ( double comp [ ] ) throws negative array size exception { int n = comp . length ; if ( n <= num ) throw new negative array size exception ( str ) ; components = new double [ n ] ; system . arraycopy ( comp , num , components , num , n ) ; }	create a vector of given dimension.
@ override public void visit inner class ( final string aname , final string outer name , final string inner name , final int attr access ) { if ( ( name != null ) && name . equals ( aname ) ) { this . access = attr access ; } super . visit inner class ( aname , outer name , inner name , attr access ) ; }	handle a bizarre special case.
public long lon to pixel ( double lon ) { return ( long ) ( ( lon + num ) / num * math . pow ( num , zoom ) * num ) ; }	convert longitude to pixel value.
public static boolean world file values appear geographic ( av values ) { double x location ; double y location ; double x pixel size ; double y pixel size ; object o = values . get value ( world file x location ) ; if ( o != null && o instanceof double ) x location = ( double ) o ; else return bool ; o = values . get value ( world file y location ) ; if ( o != null && o instanceof double ) y location = ( double ) o ; else return bool ; o = values . get value ( world file x pixel size ) ; if ( o != null && o instanceof double ) x pixel size = ( double ) o ; else return bool ; o = values . get value ( world file y pixel size ) ; if ( o != null && o instanceof double ) y pixel size = ( double ) o ; else return bool ; return ( angle . is valid longitude ( x pixel size ) && angle . is valid latitude ( y pixel size ) && angle . is valid longitude ( x location ) && angle . is valid latitude ( y location ) ) ; }	indicates whether world file values appear to be in latitude and longitude .
public void store in register ( int register number ) throws io { print ( str , new string [ ] { integer . to string ( register number ) } ) ; }	description of the method.
public void remove ( id session id ) { remote session set . remove ( session id ) ; }	remove a remote session .
@ override public synchronized string to string ( ) { if ( element count == num ) { return str ; } int length = element count - num ; string builder buffer = new string builder ( element count * num ) ; buffer . append ( str ) ; for ( int i = num ; i < length ; i ++ ) { if ( element data [ i ] == this ) { buffer . append ( str ) ; } else { buffer . append ( element data [ i ] ) ; } buffer . append ( str ) ; } if ( element data [ length ] == this ) { buffer . append ( str ) ; } else { buffer . append ( element data [ length ] ) ; } buffer . append ( str ) ; return buffer . to string ( ) ; }	returns the string representation of this vector .
public iterator < abstract page > child iterator ( final boolean dirty nodes only ) { if ( dirty nodes only ) { return new dirty child iterator ( this ) ; } else { return new child iterator ( ) ; } }	iterator visits the direct child nodes in the external key ordering .
public void enable ( ) throws io { synchronized ( opt out lock ) { if ( is opt out ( ) ) { configuration . set ( str , bool ) ; configuration . save ( configuration file ) ; } if ( task == null ) { start ( ) ; } } }	enables metrics for the server by setting " opt - out " to false in the config file and starting the metrics task .
public hmac ( byte [ ] key ) { super ( str ) ; int length = math . min ( key . length , block length ) ; for ( int i = num ; i < length ; i ++ ) { ipad [ i ] = ( byte ) ( key [ i ] ^ ipad ) ; opad [ i ] = ( byte ) ( key [ i ] ^ opad ) ; } for ( int i = length ; i < block length ; i ++ ) { ipad [ i ] = ipad ; opad [ i ] = opad ; } try { md5 = message digest . get instance ( str ) ; } catch ( exception ex ) { throw new illegal state exception ( ex . get message ( ) ) ; } engine reset ( ) ; }	creates an hmact64 instance which uses the given secret key material .
public boolean starts with ( string string ) { if ( string == null ) return bool ; int strlen = string . length ( ) ; if ( length < strlen ) return bool ; char [ ] buffer = buffer ; int offset = offset ; while ( -- strlen >= num ) { if ( buffer [ offset + strlen ] != string . char at ( strlen ) ) return bool ; } return bool ; }	returns true if the charsegment starts with the string .
private void write raw bytes internal ( final byte buffer value ) throws io { int length = value . remaining ( ) ; if ( limit - position >= length ) { value . get ( buffer , position , length ) ; position += length ; total bytes written += length ; } else { final int bytes written = limit - position ; value . get ( buffer , position , bytes written ) ; length -= bytes written ; position = limit ; total bytes written += bytes written ; refresh buffer ( ) ; while ( length > limit ) { value . get ( buffer , num , limit ) ; output . write ( buffer , num , limit ) ; length -= limit ; total bytes written += limit ; } value . get ( buffer , num , length ) ; position = length ; total bytes written += length ; } }	write a bytebuffer that isn ' t backed by an array .
public boolean is src class ( soot class clz ) { return src classes . contains ( clz . get name ( ) ) ; }	return true if the class was loaded from the application src / directory .
private void process ldif ( connection conn , string path ) throws upgrade exception { change record reader reader = null ; try { if ( debug . message enabled ( ) ) { debug . message ( str + path ) ; } map < string , string > tags = new hash map < string , string > ( num ) ; tags . put ( str , base dn ) ; tags . put ( str , str ) ; string content = am . read file ( path ) ; string tag swapped = string utils . tag swap ( content , tags ) ; reader = new ldif ( new byte array input stream ( tag swapped . get bytes ( charset . for name ( str ) ) ) ) ; change record writer writer = new connection change record writer ( conn ) ; while ( reader . has next ( ) ) { writer . write change record ( reader . read change record ( ) ) ; } } catch ( io ioe ) { debug . error ( str + path , ioe ) ; throw new upgrade exception ( ioe ) ; } finally { io . close if not null ( reader ) ; } }	reads in the ldif file , and writes the changerecords on the ldap connection .
private void print progress ( long row , long row from , long row till ) { long rows processed = row + chunk size - row from ; if ( rows processed > ( row till - row from ) ) rows processed = ( row till - row from ) ; print ( string . format ( str , ( int ) ( ( ( double ) ( rows processed ) / ( double ) ( row till - row from ) ) * num ) ) ) ; }	render ( print ) progress bar .
void post remote release lock ( object object name ) throws interrupted exception { if ( ! acquire destroy read lock ( num ) ) { return ; } try { check destroyed ( ) ; drain permitted requests ( ) ; grant lock ( object name ) ; } catch ( lock service destroyed exception e ) { } catch ( lock grantor destroyed exception e ) { } finally { release destroy read lock ( ) ; } }	drain currently permitted requests and grant lock to next requestor.
public final array list < position record > load positions ( final int session , final double min lat , final double max lat , final double min lon , final double max lon ) { final array list < position record > positions = new array list < > ( ) ; string selection = schema . col session id + str ; cursor cursor = null ; list < string > selection args = null ; if ( min lat != null & max lat != null && min lon != null && max lon != null ) { selection args = new array list < > ( ) ; selection args . add ( string . value of ( session ) ) ; selection args . add ( string . value of ( min lat ) ) ; selection args . add ( string . value of ( max lat ) ) ; selection args . add ( string . value of ( min lon ) ) ; selection args . add ( string . value of ( max lon ) ) ; selection += str + schema . col latitude + str + schema . col latitude + str + schema . col longitude + str + schema . col longitude + str ; cursor = content resolver . query ( content provider . content uri position , null , selection , selection args . to array ( new string [ num ] ) , schema . col timestamp ) ; } else { log . v ( tag , str ) ; cursor = content resolver . query ( content provider . content uri position , null , null , null , schema . col timestamp ) ; } while ( cursor . move to next ( ) ) { positions . add ( position from cursor ( cursor ) ) ; } cursor . close ( ) ; return positions ; }	loads positions within certain arrea.
public static check box create toggle ( string text , image icon ) { check box cb = new check box ( text , icon ) ; cb . set toggle ( bool ) ; return cb ; }	shorthand for creating the check box setting the icon / text and making it into a toggle button.
public long add completed batch ( request batch request batch ) { long completed batch id = insert batch as completed ( request batch ) ; for ( request request : request batch . get requests ( ) ) { request . set batch id ( completed batch id ) ; file file = new file ( request . get destination path ( ) ) ; long length = file . exists ( ) ? file . length ( ) : num ; insert request as completed download ( request . get destination path ( ) , length , request ) ; } return completed batch id ; }	adds this batch to the downloads system .
@ target api ( build . version codes . jelly bean ) private void dequeue output buffer ( media codec codec , byte buffer [ ] output buffers , int index , media codec . buffer info info ) { if ( build . version . sdk int >= build . version codes . jelly bean ) { byte buffer buffer = output buffers [ index ] ; log . i ( str + info . size + str + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] buffer copied = new byte [ info . size ] ; buffer . get ( buffer copied ) ; codec . release output buffer ( index , bool ) ; add encoded ( buffer copied ) ; if ( log . debug ) { audio utils . show some bytes ( str , buffer copied ) ; } } else { log . e ( str ) ; codec . release output buffer ( index , bool ) ; } } }	save the encoded ( output ) buffer into the complete encoded recording . todo : copy directly ( without the intermediate byte array ).
public static default job definition retryable fixed delay job definition ( final string job type , final string job name , final string description , final duration fixed delay , final int restarts , final int retries , final optional < duration > retry delay , final optional < duration > max age ) { return new default job definition ( job type , job name , description , max age , optional . of ( fixed delay ) , optional . empty ( ) , restarts , retries , retry delay ) ; }	create a jobdefinition that is using fixed delays specify , when and how often the job should be triggered .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return message ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static void put long ( long addr , long val ) { if ( unaligned ) unsafe . put long ( addr , val ) ; else put long by byte ( addr , val , big endian ) ; }	stores given integer value.
public static file create minimal split ( string input folder , int num folds , int num available j , boolean is sequence ) throws exception { file output folder = new file ( input folder , str ) ; int split num = ( int ) math . ceil ( num folds / ( double ) num available j ) ; collection reader description create reader = collection reader factory . create reader description ( binary cas reader . class , binary cas reader . param source location , input folder , binary cas reader . param patterns , str ) ; analysis engine description multiplier = analysis engine factory . create engine description ( fold classification unit cas multiplier . class , fold classification unit cas multiplier . param requested splits , split num , fold classification unit cas multiplier . param use sequences , is sequence ) ; analysis engine description xmi writer = analysis engine factory . create engine description ( binary cas writer . class , binary cas writer . param target location , output folder . get absolute path ( ) , binary cas writer . param format , str ) ; analysis engine description both = analysis engine factory . create engine description ( multiplier , xmi writer ) ; simple pipeline . run pipeline ( create reader , both ) ; is number of cas created larger equal num folds ( output folder , num folds ) ; return output folder ; }	takes the available cas and creates more cases from them to conform to the minimal requested amount of cas objects to have sufficient for running a cross - validation.
public org . w3c . dom . element sign xml ( org . w3c . dom . document doc , java . lang . string cert alias ) throws xml { return sign xml ( doc , cert alias , null ) ; }	sign the xml document using enveloped signatures .
public boolean display popup ( ) { if ( m popup class == null ) return bool ; try { window win = swing utilities . get window ancestor ( this ) ; c popup = null ; if ( win instanceof dialog ) { constructor < ? > constructor = m popup class . get constructor ( new class < ? > [ ] { dialog . class , string . class , boolean . class } ) ; popup = ( c ) constructor . new instance ( new object [ ] { ( dialog ) win , m title , new boolean ( bool ) } ) ; } else if ( win instanceof frame ) { constructor < ? > constructor = m popup class . get constructor ( new class [ ] { frame . class , string . class , boolean . class } ) ; popup = ( c ) constructor . new instance ( new object [ ] { ( frame ) win , m title , new boolean ( bool ) } ) ; } if ( popup == null ) return bool ; popup . set value ( m editor . get item ( ) ) ; popup . set format ( m editor . get format ( ) ) ; popup . show ( ) ; m editor . set item ( popup . get value ( ) ) ; popup = null ; } catch ( exception e ) { notify user ( e ) ; } return bool ; }	display popup . called from adempierecombopopup and allows to implement alternative actions than showing the popup.
public abstract sdf writer ( final preread type preread type , final boolean has quality , boolean has names , boolean compressed , final sequence type type ) { m preread type = preread type ; m preread arm = preread arm . unknown ; m sdf id = new sdf id ( ) ; m name handler = new sequence name handler ( ) ; m sequence type = type ; m first valid = m sequence type . first valid ( ) ; m residue counts = new long [ m sequence type . number known codes ( ) + m sequence type . first valid ( ) ] ; m n = new long [ max histogram ] ; m pos histogram = new long [ max histogram ] ; m qs = new double [ max histogram ] ; m position counts = new long [ max histogram ] ; m global qs = num ; m data hash function = new preread hash function ( ) ; m quality hash function = new preread hash function ( ) ; m name hash function = new preread hash function ( ) ; m name suffix hash function = new preread hash function ( ) ; m has quality = has quality ; m has names = has names ; m compressed = compressed ; m seq data checksum = new cr ( ) ; m qual data checksum = new cr ( ) ; }	creates a writer for processing sequences from provided data source .
firing plan guess best firing plan under heat ( entity shooter , @ nullable entity state shooter state , targetable target , @ nullable entity state target state , int max heat , i game ) { if ( max heat < num ) { max heat = num ; } firing plan alpha strike = guess full firing plan ( shooter , shooter state , target , target state , game ) ; if ( alpha strike . get heat ( ) <= max heat && ! ( shooter instanceof infantry ) && ! ( shooter instanceof battle armor ) ) { return alpha strike ; } firing plan heat plans [ ] = calc firing plans under heat ( shooter , alpha strike ) ; arrays . sort ( heat plans ) ; if ( heat plans . length > num ) { return heat plans [ num ] ; } else { return new firing plan ( target ) ; } }	guesses the ' best ' firing plan under a certain heat no twisting is done.
public static volume group rest rep map ( volume group from ) { if ( from == null ) { return null ; } volume group rest rep rep = new volume group rest rep ( ) ; map data object fields ( from , rep ) ; rep . set description ( from . get description ( ) ) ; rep . set roles ( from . get roles ( ) ) ; rep . set parent ( to related resource ( resource type enum . volume group , from . get parent ( ) ) ) ; rep . set migration group by ( from . get migration group by ( ) ) ; rep . set migration type ( from . get migration type ( ) ) ; return rep ; }	map an volumegroup to volumegrouprestrep.
public int post files ( string [ ] args , int start index in args , output stream out , string type ) { reset ( ) ; int files posted = num ; for ( int j = start index in args ; j < args . length ; j ++ ) { file src file = new file ( args [ j ] ) ; if ( src file . is directory ( ) && src file . can read ( ) ) { files posted += post directory ( src file , out , type ) ; } else if ( src file . is file ( ) && src file . can read ( ) ) { files posted += post files ( new file [ ] { src file } , out , type ) ; } else { file parent = src file . get parent file ( ) ; if ( parent == null ) parent = new file ( str ) ; string file glob = src file . get name ( ) ; glob file filter ff = new glob file filter ( file glob , bool ) ; file [ ] files = parent . list files ( ff ) ; if ( files == null || files . length == num ) { warn ( str + src file ) ; continue ; } files posted += post files ( parent . list files ( ff ) , out , type ) ; } } return files posted ; }	post all filenames provided in args.
public void clear searchable ( ) { searchables . clear ( ) ; }	clear all searchable items.
public void add action listener ( action listener new listener ) { m listeners . add ( new listener ) ; }	register a listener to be notified when plotting completes.
@ deprecated public shapeless recipe add ingredient ( int count , material ingredient , int rawdata ) { validate . is true ( ingredients . size ( ) + count <= num , str ) ; if ( rawdata == - num ) { rawdata = short . max value ; } while ( count -- > num ) { ingredients . add ( new item stack ( ingredient , num , ( short ) rawdata ) ) ; } return this ; }	adds multiples of the specified ingredient .
public string order ( ) { return m order by . length ( ) > num ? m order by . to string ( ) : null ; }	returns the order string produced by this object .
static axes walker find clone ( axes walker key , vector clone list ) { if ( null != clone list ) { int n = clone list . size ( ) ; for ( int i = num ; i < n ; i += num ) { if ( key == clone list . element at ( i ) ) return ( axes walker ) clone list . element at ( i + num ) ; } } return null ; }	find a clone that corresponds to the key argument .
public static byte [ ] encoding to bytes ( final string str , final string encoding ) { if ( str == null ) { return null ; } try { return str . get bytes ( encoding ) ; } catch ( final unsupported encoding exception e ) { throw new error ( encoding + str + e ) ; } }	convert a string to a byte array using the specified encoding .
public static boolean looks like abg ( string val ) { return background repeats . index of ( val ) >= num ; }	description of the method.
public void before ( ) throws throwable { if ( build . version . sdk int >= build . version codes . m ) { process builder process builder = new process builder ( ) ; process builder . command ( str , str ) ; process builder . redirect error stream ( ) ; process process = process builder . start ( ) ; process . wait for ( ) ; if ( process . exit value ( ) != num ) { log . e ( log tag , str + process . exit value ( ) ) ; } } }	clear logcat buffer prior to test run .
public void add meta ( char meta , string replacement ) { meta character set . set ( meta ) ; replacement map . put ( new string ( new char [ ] { meta } ) , replacement ) ; }	add a metacharacter and its replacement .
private matches lookup do ( template tmpl , int max matches ) { if ( max matches < num ) throw new illegal argument exception ( str ) ; int total matches = num ; array list matches = null ; item iter iter = matching items ( tmpl ) ; if ( max matches > num || iter . dups possible ) matches = new array list ( ) ; if ( iter . dups possible ) { while ( iter . has next ( ) ) { item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } total matches = matches . size ( ) ; if ( max matches > num ) { for ( int i = matches . size ( ) ; -- i >= max matches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= num ; ) { matches . set ( i , copy item ( ( item ) matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . has next ( ) ) { item item = iter . next ( ) ; total matches ++ ; if ( -- max matches >= num ) matches . add ( copy item ( item ) ) ; } } return new matches ( matches , total matches ) ; }	the code that does the real work of lookup.
public static list < history > find history by job ( entity manager em , jpa job , big integer limit ) { require argument ( em != null , str ) ; require argument ( job != null , str ) ; typed query < history > query = em . create named query ( str , history . class ) ; if ( limit != null ) { query . set max results ( limit . int value ( ) ) ; } try { query . set parameter ( str , job ) ; return query . get result list ( ) ; } catch ( no result exception ex ) { return new array list < history > ( num ) ; } }	finds all history records for the given job .
public static string quote ( char ch ) { switch ( ch ) { case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; default : return ( is printable ascii ( ch ) ) ? string . value of ( ch ) : string . format ( str , ( int ) ch ) ; } }	escapes a character if it has an escape sequence or is non - printable ascii.
private void update pending nodes ( final int new landmark index , final router priority queue < node > pending nodes ) { final list < double > new est rem trav costs = new array list < > ( ) ; final list < node > nodes to be updated = new array list < > ( ) ; final internal landmark data landmark data = new internal landmark data ( ) ; for ( node node : pending nodes ) { final a role = get data ( node ) ; final pre process landmarks . landmarks data pp role = preprocess . get node data ( node ) ; landmark data . set delegate ( pp role ) ; final double new est rem trav cost = estimate remaining travel cost ( landmark data , new landmark index ) ; if ( new est rem trav cost > role . get expected remaining cost ( ) ) { nodes to be updated . add ( node ) ; new est rem trav costs . add ( new est rem trav cost ) ; } } for ( node node : nodes to be updated ) { pending nodes . remove ( node ) ; } for ( int i = num ; i < nodes to be updated . size ( ) ; i ++ ) { final node node = nodes to be updated . get ( i ) ; final a data = get data ( node ) ; data . set expected remaining cost ( new est rem trav costs . get ( i ) ) ; pending nodes . add ( node , get priority ( data ) ) ; } }	if a landmark has been added to the set of the active landmarks , this function re - evaluates the estimated remaining travel time based on the new set of active landmarks of the nodes contained in pendingnodes.
@ override public string to string ( ) { string buffer buff = new string buffer ( ) ; if ( m correlations == null ) { buff . append ( str ) ; } else { buff . append ( str ) ; if ( m detailed output && m detailed output buff . length ( ) > num ) { buff . append ( str ) ; buff . append ( m detailed output buff ) ; } } return buff . to string ( ) ; }	describe the attribute evaluator.
private void draw overflow indicator ( final graphics g , int max x ) { int width = num ; int height = num ; int x offset = num ; int step size = width / num ; int dot size = num ; int x = max x - width - x offset ; int y = button . get size ( ) . height - height ; g . set color ( lighter gray ) ; g . fill rect ( x , y , width , width ) ; g . set color ( color . gray ) ; g . draw round rect ( x , y , width , width , num , num ) ; g . set color ( color . black ) ; g . fill oval ( x + step size , y + num , dot size , dot size ) ; g . fill oval ( x + step size * num , y + num , dot size , dot size ) ; g . fill oval ( x + step size * num , y + num , dot size , dot size ) ; g . dispose ( ) ; }	draws indicator in case the expression text overflows on the y axis .
public void write line ( long time , float [ ] column ) { string str = long . to string ( time ) ; for ( int i = num ; i < column . length ; ++ i ) { str += str + column [ i ] ; } writer . println ( str ) ; }	write a line of values to the file with a timestamp.
public static boolean is pem ( input stream is ) { try { string start pem = str ; int header length = num ; byte [ ] preamble = new byte [ header length ] ; if ( is . read ( preamble , num , header length ) > num ) { string start array = new string ( preamble ) ; return start array . starts with ( start pem ) ; } return bool ; } catch ( exception e ) { throw new dss ( str ) ; } }	this method returns true if the inputstream contains a pem encoded item.
public close listener ( object resource ) { resource = resource ; }	creates the new close listener .
@ override public index request routing ( string routing ) { if ( routing != null && routing . length ( ) == num ) { this . routing = null ; } else { this . routing = routing ; } return this ; }	controls the shard routing of the request.
public byte [ ] receive ( ) throws network exception { try { packet . set length ( datagram connection . default datagram size ) ; connection . receive ( packet ) ; int packet length = packet . get length ( ) ; byte [ ] data = new byte [ packet length ] ; system . arraycopy ( packet . get data ( ) , num , data , num , packet length ) ; return data ; } catch ( io e ) { throw new network exception ( str , e ) ; } }	receive data with a specific buffer size.
@ override protected void force delete attribute at ( int position ) { double [ ] new values = new double [ m . length - num ] ; system . arraycopy ( m , num , new values , num , position ) ; if ( position < m . length - num ) { system . arraycopy ( m , position + num , new values , position , m . length - ( position + num ) ) ; } m = new values ; }	deletes an attribute at the given position ( 0 to numattributes ( ) - 1 ) .
public synchronized alphabetic index add labels ( locale locale ) { add labels ( peer , locale . to string ( ) ) ; return this ; }	adds the index characters from the given locale to the index.
protected byte [ ] engine wrap ( key key ) throws illegal block size exception , invalid key exception { throw new unsupported operation exception ( ) ; }	wrap a key . < p > this concrete method has been added to this previously - defined abstract class . ( for backwards compatibility , it cannot be abstract . ) it may be overridden by a provider to wrap a key . such an override is expected to throw an illegalblocksizeexception or invalidkeyexception ( under the specified circumstances ) , if the given key cannot be wrapped . if this method is not overridden , it always throws an unsupportedoperationexception .
@ deprecated public java plugin loader ( server instance ) { validate . not null ( instance , str ) ; server = instance ; }	this class was not meant to be constructed explicitly.
public void add separator ( ) { if ( log . is loggable ( platform logger . level . finer ) ) { log . finer ( str ) ; } }	addseparator routines are not used in peers . shared code invokes additem ( " - " ) for adding separators.
public static boolean test save location exists ( ) { string s d = environment . get external storage state ( ) ; boolean status ; if ( s d . equals ( environment . media mounted ) ) { status = bool ; } else { status = bool ; } return status ; }	determine if sd card exists .
public static final list < i > load raw modules ( final sql provider ) throws couldnt load data exception { preconditions . check not null ( provider , str ) ; final c connection = provider . get connection ( ) ; final list < i > modules = new array list < i > ( ) ; if ( ! sql . has table ( connection , c . raw modules table ) ) { return modules ; } final string query = str + c . raw modules table + str ; try ( result set result set = connection . execute query ( query , bool ) ) { while ( result set . next ( ) ) { final int raw module id = result set . get int ( str ) ; final string name = sql . read string ( result set , str ) ; final boolean is complete = sql . check raw modules tables ( provider . get connection ( ) , sql . get database name ( provider . get connection ( ) ) , raw module id ) ; final int function count = is complete ? sql . get raw module function count ( connection , raw module id ) : num ; final c module = new c ( raw module id , name , function count , is complete , provider ) ; modules . add ( module ) ; } } catch ( final sql e ) { throw new couldnt load data exception ( e ) ; } return modules ; }	loads the raw modules of a database .
void write ( image output stream ios ) throws io { length = num + data . length ; write tag ( ios ) ; ios . write ( data ) ; }	writes the data for this segment to the stream in valid jpeg format , directly from the data array .
public static int prob round ( double value , random rand ) { if ( value >= num ) { double lower = math . floor ( value ) ; double prob = value - lower ; if ( rand . next double ( ) < prob ) { return ( int ) lower + num ; } else { return ( int ) lower ; } } else { double lower = math . floor ( math . abs ( value ) ) ; double prob = math . abs ( value ) - lower ; if ( rand . next double ( ) < prob ) { return - ( ( int ) lower + num ) ; } else { return - ( int ) lower ; } } }	rounds a double to the next nearest integer value in a probabilistic fashion ( e.
map < string , type name > convert properties to types ( map < string , executable element > properties ) { map < string , type name > types = new linked hash map < string , type name > ( ) ; for ( map . entry < string , executable element > entry : properties . entry set ( ) ) { executable element el = entry . get value ( ) ; types . put ( entry . get key ( ) , type name . get ( el . get return type ( ) ) ) ; } return types ; }	converts the executableelement properties to typename properties.
private static list < register description > parse register information ( final node node ) throws message parser exception { final list < register description > registers = new array list < > ( ) ; final node list nodes = node . get child nodes ( ) ; for ( int i = num ; i < nodes . get length ( ) ; ++ i ) { final node child = nodes . item ( i ) ; final string register name = get attribute ( child , str ) ; final string register size = get attribute ( child , str ) ; final string register editable = get attribute ( child , str ) ; registers . add ( new register description ( register name , integer . value of ( register size ) , boolean . value of ( register editable ) ) ) ; } return registers ; }	parses register information from the target information string .
public named thread factory ( string name prefix ) { this . name prefix = objects . require non null ( name prefix ) ; group = get thread group ( ) ; daemon = bool ; }	creates a daemon thread with the specified name prefix.
public void test metric cpu num uint16 ( ) { final i decl = new ganglia metadata message ( str , str , bool , ganglia message type enum . uin , str , str , ganglia slope enum . zero , num , num , abstract metrics . get map ( i . group cpu , str , str ) ) ; assert encode decode ( null , decl ) ; final i expected = new ganglia metric message ( ganglia message type enum . uin , str , str , bool , str , integer . value of ( num ) ) ; final byte [ ] actual data = assert encode decode ( decl , expected ) ; final byte [ ] expected data = new byte [ ] { num , num , num , - num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; if ( ! arrays . equals ( expected data , actual data ) ) { fail ( str + arrays . to string ( expected data ) + str + arrays . to string ( actual data ) ) ; } }	unit test for a cpu_num message .
public void add transaction ( sip server transaction ) throws io { if ( logger . is logging enabled ( log writer . trace debug ) ) logger . log debug ( str + server transaction ) ; server transaction . map ( ) ; add transaction hash ( server transaction ) ; }	add a new server transaction to the set of existing transactions.
private void delay retry ( int multiplier ) { debug ( str ) ; try { thread . sleep ( num * multiplier ) ; } catch ( interrupted exception e ) { warn ( e , str ) ; } }	dalays the current thread.
public void test split and join semicolon nested in pipe properties ( ) { properties outer = property utils . split properties on pipe ( one then two outer a ) ; assert equals ( one semi two , outer . get property ( str ) ) ; assert equals ( num , outer . size ( ) ) ; try { assert equals ( one then two outer a , property utils . join on pipe ( property utils . to map ( outer ) ) ) ; return ; } catch ( comparison failure deviation1 ) { } try { assert equals ( two then one outer a , property utils . join on pipe ( property utils . to map ( outer ) ) ) ; return ; } catch ( comparison failure deviation2 ) { } try { assert equals ( one then two outer b , property utils . join on pipe ( property utils . to map ( outer ) ) ) ; return ; } catch ( comparison failure deviation3 ) { } try { assert equals ( two then one outer b , property utils . join on pipe ( property utils . to map ( outer ) ) ) ; return ; } catch ( comparison failure deviation4 ) { } assert equals ( two then one outer a , property utils . join on pipe ( property utils . to map ( outer ) ) ) ; }	test split and join of nested properties ( using pipe ) .
public void test int boolean map ( ) throws exception { object mapper mapper = new object mapper ( ) ; string json = str ; map < string , integer > result = mapper . read value ( json , new type reference < hash map < integer , boolean > > ( ) { } ) ; assert not null ( result ) ; assert equals ( hash map . class , result . get class ( ) ) ; assert equals ( num , result . size ( ) ) ; assert equals ( boolean . true , result . get ( integer . value of ( num ) ) ) ; assert equals ( boolean . false , result . get ( integer . value of ( - num ) ) ) ; assert null ( result . get ( str ) ) ; assert null ( result . get ( num ) ) ; }	let ' s also check that it is possible to do type conversions to allow use of non - string map keys .
@ override public boolean is busy ( ) { return bool ; }	returns true if . at this time , the bean is busy with some ( i . e . perhaps a worker thread is performing some calculation ) .
protected byte array output stream parse bytes ( byte array output stream bos ) throws io { int ch ; for ( ch = skip whitespace ( ) ; ch >= num && ch != str ; ch = skip whitespace ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != str ) { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] << num ) + ( base64 decode [ b3 ] << num ) + ( base64 decode [ b4 ] ) ) ; bos . write ( chunk > > num ) ; bos . write ( chunk > > num ) ; bos . write ( chunk ) ; } else if ( b3 != str ) { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] << num ) + ( base64 decode [ b3 ] > > num ) ) ; bos . write ( chunk > > num ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] > > num ) ) ; bos . write ( chunk ) ; } } if ( ch == str ) peek = ch ; return bos ; }	parses a byte array .
public void reset ( ) { if ( m download bandwidth != null ) { m download bandwidth . reset ( ) ; } m current bandwidth connection quality . set ( connection quality . unknown ) ; }	resets the bandwidth average for this instance of the bandwidth manager .
public void test merge security role into empty document ( ) throws exception { string src xml = str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; string merge xml = str + str + str + str + str ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( merge xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge ( merge web xml ) ; list < string > security role names = web xml utils . get security role names ( src web xml ) ; assert equals ( num , security role names . size ( ) ) ; assert equals ( str , security role names . get ( num ) ) ; }	tests whether a single security role is correctly inserted into an empty descriptor .
private diff part decode full revision ( final int block size l ) throws unsupported encoding exception , decoding exception { if ( block size l < num ) { throw new decoding exception ( str + block size l ) ; } int l = r . read ( block size l ) ; byte array output stream output = new byte array output stream ( ) ; for ( int i = num ; i < l ; i ++ ) { output . write ( r . read byte ( ) ) ; } diff part part = new diff part ( diff action . full revision uncompressed ) ; part . set text ( output . to string ( wikipedia encoding ) ) ; return part ; }	decodes a fullrevision operation .
private synchronized static void remove child character data ( node node , boolean deep ) { node list list = node . get child nodes ( ) ; for ( int i = list . get length ( ) ; i >= num ; i -- ) { node n = list . item ( i ) ; if ( n == null ) continue ; if ( n instanceof character data ) node . remove child ( xml . to raw node ( n ) ) ; else if ( deep ) remove child character data ( n , deep ) ; } }	remove children from type characterdata from a node , this includes text , comment and cdatasection nodes.
void unlink ( node < e > p , node < e > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get and decrement ( ) == capacity ) not full . signal ( ) ; }	unlinks interior node p with predecessor trail .
public static float mix friction ( float friction1 , float friction2 ) { return math utils . sqrt ( friction1 * friction2 ) ; }	friction mixing law . feel free to customize this . todo djm : add customization.
public string serialize ( object obj , string content type ) throws api exception { if ( content type . starts with ( str ) ) { return json . serialize ( obj ) ; } else { throw new api exception ( num , str + content type ) ; } }	serialize the given java object into string according the given content - type ( only json is supported for now ) .
private boolean compile s zr ( int base register , int [ ] offsets , int [ ] registers ) { for ( int i = num ; i < registers . length ; i ++ ) { if ( registers [ i ] != zr ) { return bool ; } } for ( int i = num ; i < offsets . length ; i ++ ) { if ( offsets [ i ] != offsets [ i - num ] + num ) { return bool ; } } int offset = offsets [ num ] ; int length = offsets . length ; do { int copy length = math . min ( length , fast memory . zero . length ) ; mv . visit field insn ( opcodes . getstatic , type . get internal name ( fast memory . class ) , str , str ) ; load imm ( num ) ; load memory int ( ) ; prepare mem index ( base register , offset , bool , num ) ; load imm ( copy length ) ; mv . visit method insn ( opcodes . invokestatic , type . get internal name ( system . class ) , str , arraycopy descriptor ) ; length -= copy length ; offset += copy length ; } while ( length > num ) ; return bool ; }	compile a sequence sw $ zr , n ( $ reg ) sw $ zr , n + 4 ( $ reg ) sw $ zr , n + 8 ( $ reg ).
private boolean is native volume expansion supported ( volume vplex volume , long new size ) { boolean use native volume expansion = bool ; string set assoc volume ids = vplex volume . get associated volumes ( ) ; if ( null == assoc volume ids ) { s logger . warn ( str , vplex volume . for display ( ) ) ; use native volume expansion = bool ; } else { for ( string assoc volume id : assoc volume ids ) { volume assoc volume = permissions helper . get object by id ( uri . create ( assoc volume id ) , volume . class ) ; try { super . verify volume expansion request ( assoc volume , new size ) ; } catch ( exception e ) { use native volume expansion = bool ; break ; } } } return use native volume expansion ; }	determines if the vplex volume can be expanded by natively expanding the backend volumes .
public void update gui ( roster entry r ) { road name . set text ( r . get road name ( ) ) ; road number . set text ( r . get road number ( ) ) ; mfg . set text ( r . get mfg ( ) ) ; owner . set text ( r . get owner ( ) ) ; model . set text ( r . get model ( ) ) ; comment . set text ( r . get comment ( ) ) ; decoder model . set text ( r . get decoder model ( ) ) ; decoder family . set text ( r . get decoder family ( ) ) ; decoder comment . set text ( r . get decoder comment ( ) ) ; date updated . set text ( r . get date updated ( ) ) ; max speed spinner . set value ( integer . value of ( r . get max speed pct ( ) ) ) ; }	file gui from roster contents.
public static double oizp ( number value ) { if ( value == null ) { return null ; } return ( value . double value ( ) >= num ) ? num : num ; }	function which will return one if the argument is zero or a positive number , and zero if not .
public terminal size with ( terminal size size ) { if ( equals ( size ) ) { return this ; } return size ; }	returns itself if it is equal to the supplied size , otherwise the supplied size.
private boolean is gzip allowed ( final http servlet request request ) { return ! dispatcher stream locator . is included request ( request ) && wro util . is gzip supported ( request ) ; }	checks if the request supports gzip and is not a include request ( these cannot be gzipped ).
public replay processor ( int buffer size , boolean unbounded ) { if ( unbounded ) { this . buffer = new unbounded buffer < > ( buffer size ) ; } else { this . buffer = new bounded buffer < > ( buffer size ) ; } subscribers . lazy set ( this , empty ) ; }	constructs a replayprocessor with bounded or unbounded buffering .
protected void on show conversations ( @ non null list < c > conversations ) { if ( debug ) { log . d ( tag , str + conversations . size ( ) + str ) ; } m view . show conversations ( new array list < > ( conversations ) ) ; }	by default displays the current conversations in the view , this method can be updated to modify the conversations list before it is shown , can be used to filter the list or augment it.
protected int read ( ) throws io { if ( offset == buffer . length ) { throw new as ( str ) ; } if ( in == null ) { return buffer [ offset ++ ] & num ; } else { int octet = in . read ( ) ; if ( octet == - num ) { throw new as ( str ) ; } buffer [ offset ++ ] = ( byte ) octet ; return octet ; } }	reads the next encoded byte from the encoded input stream .
public void enqueue job ( final runnable job ) { synchronized ( m sleep sync ) { if ( has job ( ) ) { throw new illegal state exception ( str ) ; } set job ( job ) ; m sleep sync . notify all ( ) ; } }	enqueue a job for this thread.
public void test test bit positive2 ( ) { byte a bytes [ ] = { - num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; big integer a number = new big integer ( a sign , a bytes ) ; assert true ( a number . test bit ( number ) ) ; }	testbit ( int n ) of a positive number.
public void start element ( string uri , string local name , string q name , attributes attributes ) throws org . xml . sax . sax { if ( q name . equals ( print data . xml tag ) ) { string name = attributes . get value ( print data . xml attribute name ) ; if ( m pd == null ) { m pd = new print data ( m ctx , name ) ; push ( m pd ) ; } else { print data temp = new print data ( m ctx , name ) ; m cur pd . add node ( temp ) ; push ( temp ) ; } } else if ( q name . equals ( print data . xml row tag ) ) { m cur pd . add row ( bool , num ) ; } else if ( q name . equals ( print data element . xml tag ) ) { m cur pd = attributes . get value ( print data element . xml attribute name ) ; m cur pd = new string buffer ( ) ; } }	receive notification of the start of an element .
public void draw string ( string str , int x , int y , int text decoration ) { if ( str . length ( ) == num || ( str . length ( ) == num && str . char at ( num ) == str ) ) { return ; } object native font = null ; if ( current != null ) { native font = current . get native font ( ) ; } if ( current instanceof custom font ) { current . draw string ( this , str , x , y ) ; } else { impl . draw string ( native graphics , native font , str , x + x translate , y + y translate , text decoration ) ; } }	draw a string using the current font and color in the x , y coordinates.
@ override public int read ( char [ ] array , int offset , int length ) { if ( idx >= char sequence . length ( ) ) { return - num ; } if ( array == null ) { throw new null pointer exception ( str ) ; } if ( length < num || offset < num || offset + length > array . length ) { throw new index out of bounds exception ( str + array . length + str + offset + str + length ) ; } int count = num ; for ( int i = num ; i < length ; i ++ ) { int c = read ( ) ; if ( c == - num ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }	read the sepcified number of characters into the array .
public void update nonce parameters ( ) { if ( m next nonce . equals ( m nonce ) ) { m cnonce counter ++ ; } else { m cnonce counter = num ; m nonce = m next nonce ; } }	update the nonce parameters.
private void match v ( uri rp system id ) { list < uri > storage pool ids = connectivity util . get rp ( db client , rp system id ) ; string buffer error message = new string buffer ( ) ; if ( storage pool ids != null && ! storage pool ids . is empty ( ) ) { list < storage pool > storage pools = db client . query object ( storage pool . class , storage pool ids ) ; implicit pool matcher . match modified storage pools with all virtual pool ( storage pools , db client , coordinator , error message ) ; } }	recalculate all virtual pools matching storage pools that have rp protection as creation of a protection system creates new relationships and constraints on the matching pools of an rp system .
public static big decimal calculate fee ( player player , int price ) { big decimal fee = big decimal . value of ( price ) ; fee = fee . multiply ( big decimal . value of ( trading fee percentage ) ) ; if ( player . is bad boy ( ) ) { fee = fee . multiply ( big decimal . value of ( num + trading fee player killer penalty ) ) ; } big decimal fee bonus = big decimal . one ; fee bonus = big decimal . value of ( math . exp ( - player . get tradescore ( ) / fee bonus constant ) ) ; fee = fee . multiply ( fee bonus ) ; return fee . max ( big decimal . one ) ; }	calculates the trading fee a player has to pay when selling for a certain price.
private void add search history ( ) { add search history ( tf search editor . get text ( ) ) ; }	adds current search pattern in the search history list.
array list < source file > trim file list ( array list < source file > files ) { hash map < string , string > names = new hash map < string , string > ( ) ; array list < source file > list = new array list < source file > ( ) ; int size = files . size ( ) ; for ( int i = num ; i < size ; i ++ ) { boolean add it = bool ; source file fi = files . get ( i ) ; string f name = fi . get raw name ( ) ; if ( m swf filter == null ) { if ( names . get ( f name ) == null ) add it = bool ; } else { add it = m swf filter . contains source ( fi ) ; } if ( add it ) { names . put ( f name , f name ) ; list . add ( fi ) ; } } return list ; }	walk the file list looking for name collisions . if we find one , then we remove it.
public static string join ( double [ ] self , string separator ) { string builder buffer = new string builder ( ) ; boolean first = bool ; if ( separator == null ) separator = str ; for ( double next : self ) { if ( first ) { first = bool ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to string ( ) ; }	concatenates the string representation of each items in this array , with the given string as a separator between each item .
protected void write short ( int value ) throws io { out . write ( value & num ) ; out . write ( ( value > > num ) & num ) ; }	write 16 - bit value to output stream , lsb first.
public entity query order by ( string ... fields ) { this . order by = arrays . as list ( fields ) ; return this ; }	the fields of the named entity to order the resultset by ; optionally add a " asc " for ascending or " desc " for descending note : each successive call to any of the orderby (.
public stemmed string ( string orig , string stemmed ) { str orig = orig ; str stemmed = stemmed ; }	create a stemmedstring from two strings.
public log network stream merger ( log request req , media type media type , log svc properties loader properties loader ) { logger . trace ( str ) ; this . request = req ; this . media type = media type ; this . properties loader = properties loader ; list < log network reader > readers = get log network streams ( ) ; int size = readers . size ( ) ; log heads = new log message [ size ] ; this . log stream list = new log network reader [ size ] ; int index = num ; for ( log network reader reader : readers ) { log stream list [ index ] = reader ; log heads [ index ] = null ; index ++ ; } }	merges all logs on each node based on time stamp.
public static string pack cipher suites ( string [ ] ciphers ) { string cipher set = null ; if ( ciphers != null ) { string buffer buf = new string buffer ( ) ; for ( int i = num ; i < ciphers . length ; i ++ ) { buf . append ( ciphers [ i ] ) ; if ( i < ciphers . length - num ) { buf . append ( str ) ; } } cipher set = buf . to string ( ) ; } return cipher set ; }	converts an array of ciphers into a single string .
public extension file filter ( string description , string extension ) { this . description = description ; this . extensions = new hash set < string > ( ) ; extensions . add ( extension . to lower case ( ) ) ; default extension = extension ; }	creates a new instance .
private void ensure tuple array ( int row ) { int nrows = math . max ( m table . get row count ( ) , row + num ) ; if ( m tuples == null ) { m tuples = new table tuple [ nrows ] ; } else if ( m tuples . length < nrows ) { int capacity = math . max ( ( num * m tuples . length ) / num + num , nrows ) ; table tuple [ ] tuples = new table tuple [ capacity ] ; system . arraycopy ( m tuples , num , tuples , num , m tuples . length ) ; m tuples = tuples ; } }	ensure the tuple array exists .
private static boolean is an argument ( final string arg ) { return ( arg . starts with ( str ) && ( arg . length ( ) > num ) && ! character . is digit ( arg . char at ( num ) ) ) ; }	given a string like " - foo " or " - 5 " or " - 123.
private synchronized static void remove children ( node node , short type , boolean deep ) { node list list = node . get child nodes ( ) ; for ( int i = list . get length ( ) ; i >= num ; i -- ) { node n = list . item ( i ) ; if ( n == null ) continue ; if ( n . get node type ( ) == type || type == undefined node ) node . remove child ( xml . to raw node ( n ) ) ; else if ( deep ) remove children ( n , type , deep ) ; } }	removes child elements from a specific type.
public final void lazy set ( v new value ) { unsafe . put ordered object ( this , value offset , new value ) ; }	eventually sets to the given value .
public boolean is valid savepoint ( savepoint sp ) { if ( is source ( ) ) return bool ; boolean result = bool ; if ( sp != null ) result = bool ; return result ; }	checks whether a savepoint is valid.
public static void columns for ( result set result set , table editor editor ) throws sql { list < column > columns = new array list < > ( ) ; columns for ( result set , null ) ; editor . set columns ( columns ) ; }	use the supplied table editor to create columns for the supplied result set .
private static void write ( collection < string > src , file out ) throws io { try ( writer writer = new buffered writer ( new file writer ( out ) ) ) { for ( string line : src ) writer . write ( line + str ) ; } }	write source code to file .
public void clear ( ) { if ( m original values != null ) { synchronized ( m lock ) { m original values . clear ( ) ; } } else { m objects . clear ( ) ; } if ( m notify on change ) notify data set changed ( ) ; }	remove all elements from the list .
private long reset uid validity ( ) throws io { long timestamp = system . current time millis ( ) ; set uid validity ( timestamp ) ; return timestamp ; }	sets and returns a new uidvalidity for this folder .
public static int write ogg page header ( byte [ ] buf , int offset , int header type , long granulepos , int stream serial number , int page count , int packet count , byte [ ] packet sizes ) { write string ( buf , offset , str ) ; buf [ offset + num ] = num ; buf [ offset + num ] = ( byte ) header type ; write long ( buf , offset + num , granulepos ) ; write int ( buf , offset + num , stream serial number ) ; write int ( buf , offset + num , page count ) ; write int ( buf , offset + num , num ) ; buf [ offset + num ] = ( byte ) packet count ; system . arraycopy ( packet sizes , num , buf , offset + num , packet count ) ; return packet count + num ; }	writes an ogg page header to the given byte array .
private void handle static site request ( static site request . point request request , transport network transport network , task statistics ts ) { static computer computer = new static computer ( request , transport network , ts ) ; if ( request . request . bucket != null ) computer . run ( ) ; else { try { piped input stream pis = new piped input stream ( ) ; piped output stream pos = new piped output stream ( pis ) ; finish priority task ( request , pis ) ; computer . write ( pos ) ; pos . close ( ) ; } catch ( io e ) { log . error ( str , e ) ; } } delete request ( request ) ; }	handle a fancy new - fangled static site request.
public synchronized void remove room ( string room ) { if ( ! helper . validate stream ( room ) ) { return ; } room = room . to lower case ( ) ; if ( rooms . remove ( room ) ) { unsub room ( room ) ; remove emotes ( room ) ; prev emotesets . remove ( room ) ; } }	remove subscription to a room.
public static double discharge ( item stack item stack , double amount ) { if ( item stack != null ) { if ( item stack . get item ( ) instanceof i ) { i energized item = ( i ) item stack . get item ( ) ; if ( energized item . can send ( item stack ) ) { double energy to use = math . min ( energized item . get max transfer ( item stack ) , math . min ( energized item . get energy ( item stack ) , amount ) ) ; energized item . set energy ( item stack , energized item . get energy ( item stack ) - energy to use ) ; return energy to use ; } } } return num ; }	discharges an ienergizeditem with the defined amount of energy .
public object [ ] to array ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] a = new object [ count ] ; int k = num ; for ( node < e > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ).
public void add all ( final collection elements ) { adjusting = bool ; set old selection = new hash set ( selection ) ; boolean rv = selection . add all ( elements ) ; adjusting = bool ; if ( rv ) { fire selection changed ( old selection , selection ) ; } old selection = null ; }	add all of the specified elements to the selection .
public boolean has feature ( int feature ) { return ( ( feature >= mode first && feature <= mode last ) || ( feature >= feature first && feature <= feature last ) ) && ( feature == mode off || m capabilities . get ( feature ) ) ; }	checks if a particular feature or mode is supported by the system .
public set < integer > backup partitions ( uuid node id ) { set < integer > set = backup . get ( node id ) ; return set == null ? collections . < integer > empty set ( ) : set ; }	get backup partitions for specified node id .
public loader load ( string image url ) { image url = image url ; return this ; }	just pass http url and then you have to call view ( imageview ).
private void build ptr ( ) { double [ ] temp row ; double [ ] [ ] ptra ; int k ; pivot transform pt ; ptr = matrix . identity ( n , n ) ; ptra = ptr . get array ( ) ; k = pivot transform queue . size ( ) ; while ( k -- > num ) { pt = pivot transform queue . remove last ( ) ; temp row = ptra [ pt . pos1 ] ; ptra [ pt . pos1 ] = ptra [ pt . pos2 ] ; ptra [ pt . pos2 ] = temp row ; } }	build the pivot - transform - reverse matrix ptr.
private static string byte to hex ( byte [ ] digest ) { string builder builder = new string builder ( ) ; for ( byte b : digest ) { string hex = integer . to hex string ( num & b ) ; if ( hex . length ( ) == num ) { builder . append ( str ) ; } builder . append ( hex ) ; } return builder . to string ( ) ; }	transform binary to hex.
public bidi create line bidi ( int line start , int line limit ) { attributed string astr = new attributed string ( str ) ; bidi new bidi = new bidi ( astr . get iterator ( ) ) ; return bidi base . set line ( this , bidi base , new bidi , new bidi . bidi base , line start , line limit ) ; }	create a bidi object representing the bidi information on a line of text within the paragraph represented by the current bidi.
public boolean is caller valid for package ( context context , int auth requirements , string package to match ) { assert ! text utils . is empty ( package to match ) ; return is caller valid ( context , auth requirements , package to match ) ; }	returns whether the callers of the current transaction contains a package that matches the give authentication requirements .
public void paint internal frame title pane background ( synth context context , graphics g , int x , int y , int w , int h ) { paint background ( context , g , x , y , w , h , null ) ; }	paints the background of an internal frame title pane .
public synchronized void add graph listener ( graph listener cl ) { m graph listeners . add element ( cl ) ; }	add a graph listener.
public void restart and install if necessary ( ) { file patches dir = new file ( my sdk handler . get location ( ) , patch installer util . patches dir name ) ; studio logger progress indicator progress = new studio logger progress indicator ( patch installer factory . class ) ; if ( patches dir . exists ( ) ) { file [ ] sub dirs = patches dir . list files ( null ) ; for ( file patch dir : sub dirs ) { process patch ( my sdk handler . get location ( ) , progress , patch dir ) ; } } }	find any pending patches under the given sdk root that require studio to be restarted , and if there are any , restart and install them.
public static double [ ] [ ] align ( int [ ] real , double [ ] pred ) { int missing = number of missing labels ( real ) ; double [ ] real = new double [ real . length - missing ] ; double [ ] pred = new double [ real . length - missing ] ; int offset = num ; for ( int i = num ; i < real . length ; i ++ ) { if ( real [ i ] == - num || pred [ i ] == - num || double . is na n ( pred [ i ] ) ) { offset ++ ; continue ; } real [ i - offset ] = real [ i ] ; pred [ i - offset ] = pred [ i ] ; } double [ ] [ ] res = new double [ num ] [ num ] ; res [ num ] = real ; res [ num ] = pred ; return res ; }	helper function for missing values in the labels and missing predictions ( i.
public static boolean is category ( int m id , int m id ) { if ( m id == num || m id == num ) return bool ; integer product = new integer ( m id ) ; integer category = ( integer ) s products . get ( product ) ; if ( category != null ) return category . int value ( ) == m id ; string sql = str ; prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql , null ) ; pstmt . set int ( num , m id ) ; result set rs = pstmt . execute query ( ) ; if ( rs . next ( ) ) category = new integer ( rs . get int ( num ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { s log . log ( level . severe , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } if ( category != null ) { s products . put ( product , category ) ; s log . fine ( str + m id + str + category + str + m id + str + ( category . int value ( ) == m id ) ) ; return category . int value ( ) == m id ; } s log . log ( level . severe , str + m id ) ; return bool ; }	is product in category.
public all stats table multi ( dataset generator dataset generator , locker locker ) { argument checking . not null ( dataset generator , str ) ; init components ( ) ; table . set default renderer ( j . class , new renderer ( ) ) ; table . set column selection allowed ( bool ) ; table . set row selection allowed ( bool ) ; table . set grid color ( grid color ) ; j header = table . get table header ( ) ; header . set reordering allowed ( bool ) ; gui . set table header ( header ) ; model = new model ( dataset generator ) ; table . set model ( model ) ; this . locker = locker ; }	it creates a new instance of this panel .
public void append ( file file , ftp listener ) throws illegal state exception , file not found exception , io , ftp , ftp , ftp , ftp { if ( ! file . exists ( ) ) { throw new file not found exception ( file . get absolute path ( ) ) ; } input stream input stream = null ; try { input stream = new file input stream ( file ) ; } catch ( io e ) { throw new ftp ( e ) ; } try { append ( file . get name ( ) , input stream , num , listener ) ; } catch ( illegal state exception e ) { throw e ; } catch ( io e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } catch ( ftp e ) { throw e ; } finally { if ( input stream != null ) { try { input stream . close ( ) ; } catch ( throwable t ) { ; } } } }	this method uploads a file to the remote server.
public list < string > provide white list ( ) { linked list < string > white list = new linked list < > ( ) ; white list . add ( str ) ; return white list ; }	provide white list , entry in white list will not be shown in ui list .
public static boolean is scoped name ( string name ) { return name . index of ( str ) != - num ; }	used to detect scoped attributes .
public input ( io buffer buf ) { super ( buf ) ; amf3 mode = num ; string references = new array list < string > ( ) ; class references = new array list < class reference > ( ) ; }	creates input object for amf3 from byte buffer.
public static properties load config file ( string path ) { properties property = null ; file file = new file ( path ) ; if ( file . exists ( ) && file . can read ( ) ) { try { property = new properties ( ) ; property . load ( new file reader ( file . get absolute path ( ) ) ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } return property ; }	searching the specified configuration file and return a properties.
protected void sprint ( boolean boolean field ) { sprint ( string . value of ( boolean field ) ) ; }	pretty printing accumulator function for booleans.
protected static void to epl ( string writer writer , list < view > views ) { if ( ( views != null ) && ( views . size ( ) != num ) ) { writer . write ( str ) ; string delimiter = str ; for ( view view : views ) { writer . write ( delimiter ) ; view . to epl ( writer ) ; delimiter = str ; } } }	renders the views onto the projected stream .
protected void remove database listeners ( ) { database listeners . clear ( ) ; }	removes all database listeners added .
private audio map type load audio map xml ( file audio map file ) throws xml parsing exception , file not found exception { if ( ! audio map file . is file ( ) ) { throw new file not found exception ( string . format ( str , audio map file . get absolute path ( ) ) ) ; } return xml parser . parse ( audio map file , new string [ ] { audiomap xml scheme } , audiomap package , audio map type . class ) ; }	loads and validates audiomap.
public void add generic attr ( generic attr g ) { generic . add element ( g ) ; }	add a generic attribute to the field . a generic attribute contains a stream of uninterpreted bytes which is ignored by the vm ( as long as its name doesn ' t conflict with other names for attributes that are understood by the vm ).
private list < fahrzeit event > add fahrt info to fahrzeit events ( list < fahrt event > fahrt events , list < fahrzeit event > fahrzeit events , boolean keep fahrzeit events without fahrt event ) { list < fahrzeit event > fahrzeit events out = new linked list < fahrzeit event > ( ) ; map < string , fahrt event > rbl date kurs date time ist2 fahrt event map = new hash map < string , fahrt event > ( ) ; set < string > search strings = new tree set < string > ( ) ; for ( fahrt event fahrt event : fahrt events ) { string search id = string . value of ( fahrt event . get rbl date ( ) ) + string . value of ( fahrt event . get kurs ( ) ) + fahrt event . get departure date ist ( ) + fahrt event . get departure time ist ( ) ; if ( search strings . contains ( search id ) ) { log . warn ( str + search id ) ; } else { search strings . add ( search id ) ; rbl date kurs date time ist2 fahrt event map . put ( search id , fahrt event ) ; } } int number of missing fahrt events = num ; for ( fahrzeit event fahrzeit event : fahrzeit events ) { string search id = string . value of ( fahrzeit event . get rbl date ( ) ) + string . value of ( fahrzeit event . get kurs ( ) ) + fahrzeit event . get departure date ist ( ) + fahrzeit event . get departure time ist ( ) ; fahrt event fahrt event = rbl date kurs date time ist2 fahrt event map . get ( search id ) ; if ( fahrt event == null ) { number of missing fahrt events ++ ; if ( keep fahrzeit events without fahrt event ) { fahrzeit events out . add ( fahrzeit event ) ; } } else { fahrzeit event . add ( fahrt event ) ; fahrzeit events out . add ( fahrzeit event ) ; } } log . info ( number of missing fahrt events + str ) ; log . info ( str + fahrzeit events out . size ( ) + str ) ; return fahrzeit events out ; }	link fahrzeit events to the corresponding fahrt event.
private static object new instance no service loader ( class < ? > provider class ) { if ( system . get security manager ( ) == null ) { return null ; } try { method creation method = provider class . get declared method ( str ) ; return creation method . invoke ( null , ( object [ ] ) null ) ; } catch ( no such method exception exc ) { return null ; } catch ( exception exc ) { return null ; } }	try to construct using newtransformerfactorynoserviceloader method if available .
private void check uuid ( string uuid , int code ) { check hash ( uuid . from string ( uuid ) , code ) ; }	check unique id and generated hash code .
@ override protected void prepare write ( writable byte channel channel ) throws exception { os = channels . new output stream ( channel ) ; }	creates the output stream that elements will be written to .
public void run ( ) { try { boolean clean remote sessions = bool ; synchronized ( this ) { collection < state info > infos = new array list < > ( ) ; infos . add all ( servers . values ( ) ) ; infos . add all ( sites . values ( ) ) ; for ( state info info : infos ) { info . is up = check server up ( info ) ; if ( ! info . is up ) { down . add ( info . id ) ; } else { if ( ! down . is empty ( ) && down . remove ( info . id ) ) { clean remote sessions = bool ; } } } } if ( clean remote sessions ) { foreign session handler . clean up remote sessions ( ) ; } } catch ( exception ex ) { session debug . error ( str + ex . get message ( ) , ex ) ; } }	monitoring logic used by background thread.
private void write object ( java . io . object output stream p stream ) throws java . io . io { p stream . default write object ( ) ; p stream . write int ( trace angle restriction . get no ( ) ) ; }	writes an instance of this class to a file.
@ suppress warnings ( str ) public iv create iv ( final value value ) { if ( value instanceof literal == bool ) throw new illegal argument exception ( ) ; final literal lit = ( literal ) value ; final iv delegate = new iv ( long . parse long ( lit . get label ( ) ) ) ; return new iv ( delegate , datatype . get iv ( ) ) ; }	convert the supplied value into an internal representation as packedlongiv .
public builder add header ( string name , string value ) { headers . add ( new header ( name , value ) ) ; return this ; }	adds the supplied request header .
public void add ( leaf atom atom ) { leaf children . add ( atom ) ; }	adds a child leaf to this container .
public static double normal cdf ( double x ) { return ( num * ( num + ( erf ( x / ( math . sqrt ( num ) ) ) ) ) ) ; }	computes an approximation to normalcdf ( x ) .
public void remove result ( string name ) { string buffer buff = m . get ( name ) ; if ( buff != null ) { m . remove ( name ) ; m . remove element ( name ) ; m . remove ( name ) ; system . gc ( ) ; } }	removes one of the result buffers from the history.
private void add entry ( ) { filter model . add new entry ( ) ; extent model . populate ( null ) ; remove ftc . set enabled ( bool ) ; add extent button . set enabled ( bool ) ; remove extent button . set enabled ( bool ) ; }	adds a new feature type constraint entry .
public void test case22 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , - num , num } ; int a sign = num ; int b sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; try { a number . mod ( b number ) ; fail ( str ) ; } catch ( arithmetic exception e ) { } }	mod when modulus is negative.
public d ( j parent , string entry alias , password quality config password quality config ) { super ( parent , dialog . modality type . document modal ) ; this . entry alias = entry alias ; this . password quality config = password quality config ; init components ( ) ; }	creates a new dexportprivatekeyopenssl dialog .
public big decimal sum ( string sql expression ) { return aggregate ( sql expression , aggregate sum ) ; }	sum sqlexpression for items that match query criteria.
@ override public int calculate offset x ( ) { return ( int ) ( math . cos ( this . angle ) * this . distance ) - this . shadow size ; }	calculates the x - offset for drawing the shadow image relative to the source .
protected void on finish ( ) { m error listener = null ; }	clear listeners when finished.
private < t > void run test write ( xml writer < t > writer , list < t > bundle , list < string > expected ) throws exception { file tmp file = tmp folder . new file ( str ) ; try ( file output stream file output stream = new file output stream ( tmp file ) ) { write bundle ( writer , bundle , file output stream . get channel ( ) ) ; } list < string > lines = new array list < > ( ) ; try ( buffered reader reader = new buffered reader ( new file reader ( tmp file ) ) ) { for ( ; ; ) { string line = reader . read line ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . length ( ) > num ) { lines . add ( line ) ; } } assert equals ( expected , lines ) ; } }	write a bundle with an xmlwriter and verify the output is expected .
public string add days ( object odays , string format ) { int days = function handler . get int ( odays ) ; calendar now = calendar . get instance ( ) ; now . add ( calendar . day of year , days ) ; date format formatter = get formatter ( format ) ; return formatter . format ( now . get time ( ) ) ; }	get the date x days from now .
private static file create temp file ( context context , @ nullable string mime type ) throws io { file external cache dir = context . get external cache dir ( ) ; file internal cache dir = context . get cache dir ( ) ; file cache dir ; if ( external cache dir == null && internal cache dir == null ) { throw new io ( str ) ; } if ( external cache dir == null ) { cache dir = internal cache dir ; } else if ( internal cache dir == null ) { cache dir = external cache dir ; } else { cache dir = external cache dir . get free space ( ) > internal cache dir . get free space ( ) ? external cache dir : internal cache dir ; } return file . create temp file ( temp file prefix , get file extension for type ( mime type ) , cache dir ) ; }	create a temporary file in the cache directory on either internal or external storage , whichever is available and has more free space .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean remove entry ( int x index , int data set index ) { if ( data set index >= m data sets . size ( ) ) return bool ; t data set = m data sets . get ( data set index ) ; entry e = data set . get entry for x ( x index ) ; return remove entry ( e , data set index ) ; }	removes the entry object at the given xindex from the dataset at the specified index.
private void run read test ( byte [ ] input , compression mode mode ) throws io { run read test ( input , mode , mode ) ; }	run a single read test , writing and reading back input with the given compression mode .
public static void close ( @ nullable context rsrc , @ nullable ignite logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( naming exception e ) { warn ( log , str + e . get message ( ) ) ; } }	closes given resource logging possible checked exception .
void remove eq ( object o ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] array = queue ; for ( int i = num , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { remove at ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }	identity - based version for use in itr . remove.
public writable raster create compatible writable raster ( int w , int h ) { if ( w <= num || h <= num ) { throw new raster format exception ( str + ( ( w <= num ) ? str : str ) ) ; } sample model sm = sample model . create compatible sample model ( w , h ) ; return new integer interleaved raster ( sm , new point ( num , num ) ) ; }	creates a raster with the same band layout but using a different width and height , and with new zeroed data arrays .
public static string [ ] scheduler command args ( config config , config runtime , list < integer > free ports ) { if ( free ports . size ( ) < ports required for scheduler ) { throw new runtime exception ( str ) ; } for ( int port : free ports ) { if ( port == - num ) { throw new runtime exception ( str ) ; } } int http port = free ports . get ( num ) ; list < string > commands = new array list < > ( ) ; commands . add ( str ) ; commands . add ( context . cluster ( config ) ) ; commands . add ( str ) ; commands . add ( context . role ( config ) ) ; commands . add ( str ) ; commands . add ( context . environ ( config ) ) ; commands . add ( str ) ; commands . add ( context . topology name ( config ) ) ; commands . add ( str ) ; commands . add ( context . topology binary file ( config ) ) ; commands . add ( str ) ; commands . add ( integer . to string ( http port ) ) ; return commands . to array ( new string [ num ] ) ; }	util method to get the arguments to the heron scheduler .
public document analysis request add document ( solr input document doc ) { documents . add ( doc ) ; return this ; }	adds a document to be analyzed .
public final key do phase ( key key , boolean last phase ) throws invalid key exception , illegal state exception { choose first provider ( ) ; return spi . engine do phase ( key , last phase ) ; }	executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement .
public simple system permission set ( ) { }	creates a new empty simplesystempermissionset .
@ override public final void add bezier curve y ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new quad curve to ( x , y , x3 , y3 ) ) ; current pos [ num ] = x3 ; current pos [ num ] = y3 ; }	add a curve to the shape.
public void read buckets from prefs ( ) { shared preferences prefs = m context . get shared preferences ( shared prefs , num ) ; set < string > buckets = prefs . get string set ( pref buckets ids , new tree set < string > ( ) ) ; m buckets . clear ( ) ; for ( string bucket id : buckets ) { auto mix bucket bucket = restore bucket from id ( bucket id ) ; m buckets . add ( bucket ) ; } }	restore the automix buckets stored in sharedpreferences.
protected int next char ( ) throws io { f read from buffer = ( f buffer . length ( ) > num ) ; if ( f read from buffer ) { char ch = f buffer . char at ( f index ++ ) ; if ( f index >= f buffer . length ( ) ) { f buffer . set length ( num ) ; f index = num ; } return ch ; } int ch = f char after white space ; if ( ch == - num ) { ch = f reader . read ( ) ; } if ( f skip white space && character . is whitespace ( ( char ) ch ) ) { do { ch = f reader . read ( ) ; } while ( character . is whitespace ( ( char ) ch ) ) ; if ( ch != - num ) { f char after white space = ch ; return str ; } } else { f char after white space = - num ; } return ch ; }	returns the next character .
@ override public void accept app offer ( offer offer ) { int index = get index ( offer , app offers ) ; if ( index != - num ) { app offers . remove ( index ) ; app offer stream . on next ( offer ) ; } index = get index ( offer , accepted offers ) ; if ( index == - num ) { accepted offers . add ( offer ) ; } }	accept app offer remove from app offers list update corresponding app usage.
public boolean verify ( public key key , string sig provider ) throws no such algorithm exception , no such provider exception , cms { return verify ( key , cms . get provider ( sig provider ) ) ; }	verify that the given public key successfully handles and confirms the signature associated with this signer .
private void inject dependencies ( ) { mvp easy mvp = ( mvp ) get application ( ) ; list < object > activity scope modules = ( get modules ( ) != null ) ? get modules ( ) : new array list < > ( ) ; activity scope modules . add ( new activity module ( this ) ) ; activity scope graph = easy mvp . build graph with aditional modules ( activity scope modules ) ; inject ( this ) ; }	generates activity scope graph using activitymodule plus additional modules provided by inheritance .
public void write request ( ) { object lock = new object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go ahead with write = writer locks . size ( ) == num && current readers == num && current writers == num ; if ( go ahead with write ) { ++ current writers ; return ; } writer locks . add last ( lock ) ; } try { lock . wait ( ) ; } catch ( interrupted exception e ) { } } }	request the write lock.
public long read local date ( ) throws io { expect start tag ( str ) ; if ( local calendar == null ) local calendar = calendar . get instance ( ) ; long value = parse date ( local calendar ) ; expect end tag ( str ) ; return value ; }	reads a date value from the input stream .
public void remove selection listener ( final selection listener listener ) { check widget ( ) ; listeners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the user changes the receiver ' s value .
private void write hex ( int i ) throws io { int cursor = num ; do { hex [ -- cursor ] = hex digits [ i & num ] ; } while ( ( i >>>= num ) != num ) ; socket out . write ( hex , cursor , hex . length - cursor ) ; }	equivalent to , but cheaper than writing integer.
private synchronized string read input stream ( input stream reader input stream reader ) throws io , bad location exception { buffered reader buffered reader = null ; try { buffered reader = new buffered reader ( input stream reader ) ; string new line = str ; string buffer sb = new string buffer ( ) ; string line ; while ( ( line = buffered reader . read line ( ) ) != null ) { sb . append ( line + new line ) ; } return sb . to string ( ) ; } finally { if ( null != buffered reader ) buffered reader . close ( ) ; if ( null != input stream reader ) input stream reader . close ( ) ; } }	read an imputstream reader.
private list < map < string , object > > type parameters ( list < type parameter > tpl , declaration from ) { if ( tpl != null && ! tpl . is empty ( ) ) { list < map < string , object > > l = new array list < > ( tpl . size ( ) ) ; for ( type parameter tp : tpl ) { l . add ( type parameter map ( tp , from ) ) ; } return l ; } return null ; }	create a list of maps from the list of type parameters .
long free space unix ( string path , boolean kb , boolean posix , long timeout ) throws io { if ( path . length ( ) == num ) { throw new illegal argument exception ( str ) ; } string flags = str ; if ( kb ) { flags += str ; } if ( posix ) { flags += str ; } string [ ] cmd attribs = flags . length ( ) > num ? new string [ ] { df , flags , path } : new string [ ] { df , path } ; list < string > lines = perform command ( cmd attribs , num , timeout ) ; if ( lines . size ( ) < num ) { throw new io ( str + df + str + str + path + str + lines ) ; } string line2 = lines . get ( num ) ; string tokenizer tok = new string tokenizer ( line2 , str ) ; if ( tok . count tokens ( ) < num ) { if ( tok . count tokens ( ) == num && lines . size ( ) >= num ) { string line3 = lines . get ( num ) ; tok = new string tokenizer ( line3 , str ) ; } else { throw new io ( str + df + str + str + path + str ) ; } } else { tok . next token ( ) ; } tok . next token ( ) ; tok . next token ( ) ; string free space = tok . next token ( ) ; return parse bytes ( free space , path ) ; }	find free space on the * nix platform using the ' df ' command .
public static void read and close stream ( input stream is ) { final byte [ ] bytes = new byte [ default buffer size ] ; try { while ( is . read ( bytes , num , default buffer size ) != - num ) ; } catch ( io ignored ) { } finally { close silently ( is ) ; } }	reads all data from stream and close it silently.
private static boolean within two ( i n , i goal ) { double linked list < i > moves = n . valid moves ( ) ; for ( iterator < i > it = moves . iterator ( ) ; it . has next ( ) ; ) { i move = it . next ( ) ; i successor = n . copy ( ) ; move . execute ( successor ) ; if ( within one ( successor , goal ) ) { return bool ; } } return bool ; }	see if within two moves of solution .
public penn treebank reader ( string treebank home , string [ ] sections , string parse view name ) throws exception { super ( corpus reader configurator . build resource manager ( penn treebank wsj , treebank home ) ) ; this . parse view name = parse view name ; combined wsj = treebank home ; if ( sections == null ) this . sections = io . ls directories ( combined wsj ) ; else { this . sections = new string [ sections . length ] ; system . arraycopy ( sections , num , this . sections , num , sections . length ) ; } update current files ( ) ; }	reads the specified sections from penn treebank.
@ override public void unwrap ss ( byte [ ] bytes ) { unexpected message ( ) ; }	processes sslv2 hello message.
@ override public void close write ( ) throws io { if ( is close write ) { return ; } is close write = bool ; output stream os = os ; os = null ; boolean is shutdown output = bool ; if ( s instanceof ssl ) { log . finer ( l . l ( str ) ) ; return ; } else if ( s != null ) { try { s . shutdown output ( ) ; is shutdown output = bool ; } catch ( unsupported operation exception e ) { log . log ( level . finest , e . to string ( ) , e ) ; } catch ( exception e ) { log . finer ( e . to string ( ) ) ; log . log ( level . finest , e . to string ( ) , e ) ; } } if ( ! is shutdown output && os != null ) { os . close ( ) ; } }	closes the write half of the stream .
protected void apply row change data ( row change data data , list < repl option > options , string source dbms type ) throws replicator exception { if ( options != null ) { try { if ( apply session variables ( null , options ) ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str ) ; } execute pending batch ( ) ; statement . execute batch ( ) ; statement . clear batch ( ) ; } } catch ( sql e ) { throw new applier exception ( str , e ) ; } } list < repl option > row options = data . get options ( ) ; if ( row options != null ) { try { if ( apply session variables ( null , row options ) ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str ) ; } execute pending batch ( ) ; statement . execute batch ( ) ; statement . clear batch ( ) ; } } catch ( sql e ) { throw new applier exception ( str , e ) ; } } for ( one row change row : data . get row changes ( ) ) { apply one row change prepared ( row , source dbms type ) ; } }	apply one or more row changes .
public named list normalize ( named list input ) { input . remove ( str ) ; for ( int i = num ; i < input . size ( ) ; i ++ ) { object v = input . get val ( i ) ; if ( v instanceof named list ) { input . set val ( i , normalize ( ( named list ) v ) ) ; } } return input ; }	the ' avgrequestspersecond ' field will make everything look like it changed.
public boolean is infinite ( ) { return is infinite ( value ) ; }	returns true if this double value is infinitely large in magnitude .
string inprogress z ( long ledger id , long first tx id , long log segment seq no ) { if ( distributed log constants . logsegment name version == conf . get log segment name version ( ) ) { return string . format ( str , distributed log constants . inprogress logsegment prefix , log segment seq no ) ; } else { return distributed log constants . inprogress logsegment prefix + str + long . to string ( first tx id , num ) ; } }	get the name of the inprogress znode .
public synchronized void add ( double value ) { add ( m categories . size ( ) + str , value ) ; }	adds a new value to the series.
public void receive redundancy ( ) { try { while ( bool ) { if ( m in . read ( m in buffer ) <= num ) return ; } } catch ( io e ) { } }	receive socket redundancy data.
void output doc type decl ( string name , boolean close decl ) throws sax { if ( m cdata tag open ) close cdata ( ) ; try { final java . io . writer writer = m writer ; writer . write ( str ) ; writer . write ( name ) ; string doctype public = get doctype public ( ) ; if ( null != doctype public ) { writer . write ( str ) ; writer . write ( doctype public ) ; writer . write ( str ) ; } string doctype system = get doctype system ( ) ; if ( null != doctype system ) { if ( null == doctype public ) writer . write ( str ) ; else writer . write ( str ) ; writer . write ( doctype system ) ; if ( close decl ) { writer . write ( str ) ; writer . write ( m line sep , num , m line sep len ) ; close decl = bool ; } else writer . write ( str ) ; } } catch ( io e ) { throw new sax ( e ) ; } }	output the doc type declaration .
public static boolean is valid vector ( vector2f vector ) { if ( vector == null ) return bool ; if ( float . is na n ( vector . x ) || float . is na n ( vector . y ) ) return bool ; if ( float . is infinite ( vector . x ) || float . is infinite ( vector . y ) ) return bool ; return bool ; }	check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .
public static url resolve url ( url base , string target ) throws url { target = target . trim ( ) ; if ( target . starts with ( str ) ) { return fix pure query targets ( base , target ) ; } return new url ( base , target ) ; }	resolve relative url - s and fix a few java.
protected int max depth ( layout . node node ) { int depth = num ; for ( int i = num ; i < node . num children ( ) ; i ++ ) { layout . node child = node . get child ( i ) ; depth = math . max ( depth , max depth ( child ) ) ; } return depth + num ; }	compute the depth of the graph .
private static url [ ] path to ur ( string path ) throws url { synchronized ( path to ur ) { object [ ] v = ( object [ ] ) path to ur . get ( path ) ; if ( v != null ) { return ( url [ ] ) v [ num ] ; } } string tokenizer st = new string tokenizer ( path ) ; url [ ] urls = new url [ st . count tokens ( ) ] ; for ( int i = num ; st . has more tokens ( ) ; i ++ ) { urls [ i ] = new url ( st . next token ( ) ) ; } synchronized ( path to ur ) { path to ur . put ( path , new object [ ] { urls , new soft reference ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid .
private void add final ( object [ ] stacks ) { object [ ] input = new object [ input size ] , output = new object [ output size ] ; for ( int i = num ; i < stacks . length ; i ++ ) { if ( i < input size ) { input [ i ] = stacks [ i ] ; } else if ( ! ( i - input size > output size ) ) { output [ i - input size ] = stacks [ i ] ; } else { throw new runtime exception ( str ) ; } } add recipe ( input , output ) ; }	separates the recipe into an input and output list.
protected void fire connection closed ( ) { connection event evt = new connection event ( this ) ; for ( connection event listener listener : connection event listeners ) { listener . connection closed ( evt ) ; } }	helper method to fire the connectionclosed event .
public static void put int volatile ( object obj , long off , int val ) { unsafe . put int volatile ( obj , off , val ) ; }	stores integer value with volatile semantic .
number strategy ( final int field ) { this . field = field ; }	construct a strategy that parses a number field.
public static uri create uri from server set ( set < inet socket address > server inet set , string path , string protocol ) throws uri { inet socket address inet socket address = service utils . select random item ( server inet set ) ; string address = inet socket address . get host string ( ) ; int port = inet socket address . get port ( ) ; uri uri = new uri ( protocol , null , address , port , path , null , null ) ; return uri ; }	returns the uri of a random server .
public plot navigator ( plot plot , string ... axes names ) { this ( plot , arrays . as list ( axes names ) ) ; }	initializes a new instance that is responsible for zooming and panning the axes with the specified names of the specified plot .
public void add column ( class class type , boolean read only , string header ) { m model header class . add ( class type ) ; set column read only ( m model header class . size ( ) - num , read only ) ; add column ( header ) ; w renderer = ( w ) get item renderer ( ) ; renderer . set column class ( ( renderer . get no columns ( ) - num ) , class type ) ; return ; }	set the attributes of the column .
point comparator ( int dimension ) { this . dimension = dimension ; }	constructs a new comparator on the given dimension.
public static void add element ( document doc , element root element , string element name , string type in , string is array in , string partitioner in ) { element element = doc . create element ( str ) ; root element . append child ( element ) ; element name = doc . create element ( str ) ; name . append child ( doc . create text node ( element name ) ) ; element . append child ( name ) ; element type = doc . create element ( str ) ; type . append child ( doc . create text node ( type in ) ) ; element . append child ( type ) ; if ( is array in . equals ( str ) ) { element . append child ( doc . create element ( str ) ) ; } if ( partitioner in != null ) { element partitioner = doc . create element ( str ) ; partitioner . append child ( doc . create text node ( partitioner in ) ) ; element . append child ( partitioner ) ; } }	helper method to add elements to the test data schema.
public void flush buffer ( ) throws io { if ( count > num ) { m os . write ( m output bytes , num , count ) ; count = num ; } }	flush the internal buffer.
public void add first ( character c ) { add first ( c . to string ( ) ) ; }	add a character to the start of the queue ( will be the next character retrieved ) .
public final void add instance of ( string class name ) { reject . if null ( class name ) ; string value = class name . trim ( ) ; if ( ! value . matches ( class re ) ) { throw new illegal argument exception ( str + value + str ) ; } instance of interfaces . add ( value ) ; }	add an class name which property values must implement .
@ override public int read ( byte [ ] b , int off , int len ) throws io { if ( b == null ) { throw new null pointer exception ( str ) ; } if ( len < num || off < num || ( off + len ) > b . length ) { throw new index out of bounds exception ( str + b . length + str + off + str + len ) ; } int read = num ; if ( len == num ) { return num ; } while ( len > num ) { if ( encoder out . has remaining ( ) ) { int c = math . min ( encoder out . remaining ( ) , len ) ; encoder out . get ( b , off , c ) ; off += c ; len -= c ; read += c ; } else { fill buffer ( ) ; if ( end of input && ! encoder out . has remaining ( ) ) { break ; } } } return read == num && end of input ? - num : read ; }	read the specified number of bytes into an array .
public boolean is displayed expecting components ( ) { boolean result = bool ; if ( conditions . is condition met ( visibility of ( window ) ) ) { if ( components . is empty ( ) ) { close button . click ( ) ; } else { result = bool ; } } return result ; }	this check contains a workaround for an issue in aem 6.
private void process run started tag ( string identifier ) { pattern num tests pattern = pattern . compile ( str ) ; matcher num tests = num tests pattern . matcher ( identifier ) ; if ( num tests . find ( ) ) { try { m num tests expected = integer . parse int ( num tests . group ( num ) ) ; } catch ( number format exception e ) { log . e ( log tag , str + num tests . group ( num ) ) ; } } if ( m num tests expected > num ) { report test run started ( ) ; m num tests run = num ; m test run in progress = bool ; } }	parses and stores the test identifier ( class and test name ) .
public styled string insert ( char ch , int offset ) throws string index out of bounds exception { if ( offset < num || offset > builder . length ( ) ) { throw new string index out of bounds exception ( str + offset + str ) ; } builder . insert ( offset , ch ) ; return this ; }	inserts the character at the given offset.
public void add root ( proto element root ) { roots . add ( root ) ; }	add a root element to the model.
public void expand to object and select ( object element or tree path , int level ) { if ( check busy ( ) ) { return ; } object parent = get parent element ( element or tree path ) ; if ( ( ( parent != null ) && get expanded state ( parent ) ) || is root element ( element or tree path ) ) { widget w = internal get widget to select ( element or tree path ) ; if ( null != w ) { list < object > selection list = new array list < > ( ) ; selection list . add ( w ) ; set selection ( selection list ) ; object to select . set ( null ) ; } else { object to select . set ( element or tree path ) ; } } else { object to select . set ( element or tree path ) ; list < object > objects to expand = create object list ( parent , new array list < > ( ) ) ; if ( ! objects to expand . is empty ( ) ) { objects to be expanded . add all ( objects to expand ) ; widget w = internal expand ( element or tree path , bool ) ; if ( w != null ) { internal expand to level ( w , level ) ; } } else { widget w = internal get widget to select ( element or tree path ) ; if ( null != w ) { list < object > selection list = new array list < > ( ) ; selection list . add ( w ) ; set selection ( selection list ) ; object to select . set ( null ) ; } } } }	expands all ancestors of the given element or tree path so that the given element becomes visible in this viewer ' s tree control , and then expands the subtree rooted at the given element to the given level.
public void append cell ( float value ) { append cell ( string . value of ( value ) ) ; }	appends a new cell to the current row containing the provided float value .
public svn ( i configuration ) { super ( configuration ) ; }	constructs a new svnchangesetcollector used to collect incoming change sets.
public void ensure max size ( int max width , int max height , boolean keep proportions ) { int width = canvas . get width ( ) ; int height = canvas . get height ( ) ; if ( keep proportions ) { if ( width > height ) { if ( width > max width ) { height = math . round ( height *= max width / ( double ) width ) ; width = max width ; } } else { if ( height > max height ) { width = math . round ( width *= max height / ( double ) height ) ; height = max height ; } } } else { width = math . min ( width , max width ) ; height = math . min ( height , max height ) ; } resize ( width , height ) ; }	ensure a max size for the image.
public static boolean is normalized ( char sequence src , java . text . normalizer . form form , int option ) { return normalizer base . is normalized ( src . to string ( ) , form , option ) ; }	determines if the given sequence of char values is normalized .
@ override public string to string ( boolean freq ) { string buffer result = new string buffer ( ) ; result . append ( m attribute . name ( ) + str ) ; switch ( m comparison ) { case equal : result . append ( str ) ; break ; case less than or equal to : result . append ( str ) ; break ; case greater than : result . append ( str ) ; break ; default : break ; } result . append ( str + utils . double to string ( m split point , num ) ) ; if ( freq ) { result . append ( str + m frequency ) ; } return result . to string ( ) ; }	a string representation of this item , ( i.
public static string unescape som ( string s ) { int idx = s . index of ( str ) ; if ( idx < num ) return s ; string builder sb = new string builder ( ) ; int last = num ; while ( idx >= num ) { sb . append ( s . substring ( last , idx ) ) ; last = idx + num ; idx = s . index of ( str , idx + num ) ; } sb . append ( s . substring ( last ) ) ; return sb . to string ( ) ; }	unescapes a som string fragment replacing " \.
void save async ( column entity entity , duration ttl , consumer < column entity > call back ) throws execute async query exception , unsupported operation exception ;	saves an entity asynchronously.
private static copy state read copy state ( data input in ) throws io { byte [ ] infos bytes = new byte [ in . read v ( ) ] ; in . read bytes ( infos bytes , num , infos bytes . length ) ; long gen = in . read v ( ) ; long version = in . read v ( ) ; map < string , file meta data > files = copy files handler . read files meta data ( in ) ; int count = in . read v ( ) ; set < string > completed merge files = new hash set < > ( ) ; for ( int i = num ; i < count ; i ++ ) { completed merge files . add ( in . read string ( ) ) ; } long primary gen = in . read v ( ) ; return new copy state ( files , version , gen , infos bytes , completed merge files , primary gen , null ) ; }	pulls copystate off the wire.
private void before name ( ) throws io { json scope context = peek ( ) ; if ( context == json scope . nonempty object ) { out . write ( str ) ; } else if ( context != json scope . empty object ) { throw new illegal state exception ( str + stack ) ; } newline ( ) ; replace top ( json scope . dangling name ) ; }	inserts any necessary separators and whitespace before a name.
@ transactional public void redeem ( final string token number , final string service ) { final token token = token repository . find by token number and service ( token number , service ) ; if ( token == null ) throw new application runtime exception ( str + token number + str ) ; redeem ( token ) ; }	checks whether a token can be redeemed and then redeems it i.
public int lighten color ( int color , float factor ) { float r = color . red ( color ) * factor ; float g = color . green ( color ) * factor ; float b = color . blue ( color ) * factor ; int ir = math . min ( num , ( int ) r ) ; int ig = math . min ( num , ( int ) g ) ; int ib = math . min ( num , ( int ) b ) ; int ia = color . alpha ( color ) ; return ( color . argb ( ia , ir , ig , ib ) ) ; }	lighten the given color by the factor.
private static string to database string ( final operand size size ) { switch ( size ) { case byte : return str ; case word : return str ; case dword : return str ; case qword : return str ; case oword : return str ; case address : return str ; default : throw new illegal argument exception ( string . format ( str , size ) ) ; } }	returns the database string of a given operand size .
static string file name of class ( final string class name , string type suffix ) { return class name . replace ( str , str ) + str + type suffix ; }	get the file name of a class .
public void write pv ( process var pv , int recursive depth ) { write pv ( pv , recursive depth , bool ) ; }	write a process variable as xml to an output stream.
private static void assert qual ns ( string qual ns ) throws xmp { if ( qual ns == null || qual ns . length ( ) == num ) { throw new xmp ( str , xmp . badschema ) ; } }	parameterasserts that a qualifier namespace is set .
public static string builder format to ( string builder buf , float [ ] d , string sep , number format nf ) { if ( d == null ) { return buf . append ( str ) ; } if ( d . length == num ) { return buf ; } buf . append ( nf . format ( d [ num ] ) ) ; for ( int i = num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }	formats the float array d with the specified number format .
public static void pack ( int [ ] n , string s ) { for ( int i = num ; i < n . length ; i ++ ) { n [ i ] = num ; } int idx = n . length - num ; for ( int i = s . length ( ) - num ; i >= num ; i -- ) { n [ idx -- ] = s . char at ( i ) - str ; } }	pack from string into array .
public int remove viewpoints ( int [ ] indices ) { for ( int i = indices . length - num ; i >= num ; -- i ) viewpoint list . remove ( indices [ i ] ) ; viewpoint index = indices [ num ] - num ; if ( viewpoint list . size ( ) == num ) { viewpoint index = - num ; } else if ( viewpoint index < num ) { viewpoint index = viewpoint list . size ( ) - num ; } return ( viewpoint index ) ; }	remove a viewpoint from the list.
public void clear on page change listeners ( ) { if ( m on page change listeners != null ) { m on page change listeners . clear ( ) ; } }	remove all listeners that are notified of any changes in scroll state or position .
private void update color ( ) { try { breakpoint condition parser . evaluate ( input field . get text ( ) ) ; input field . set background ( color . white ) ; } catch ( final invalid formula exception e ) { input field . set background ( color . red ) ; } }	updates the color of the input field depending on whether the entered formula string is valid or not .
public void remove ignored view ( view v ) { ignored views . remove ( v ) ; }	remove a view from ignored views ;.
public boolean write header ( output stream os ) { try { write int ( os , cache magic ) ; write string ( os , key ) ; write string ( os , etag == null ? str : etag ) ; write long ( os , server date ) ; write long ( os , last modified ) ; write long ( os , ttl ) ; write long ( os , soft ttl ) ; write string string map ( response headers , os ) ; os . flush ( ) ; return bool ; } catch ( io e ) { vinci log . d ( str , e . to string ( ) ) ; return bool ; } }	writes the contents of this cacheheader to the specified outputstream .
private static boolean ensure current ( leased resource resource ) { return resource . get expiration ( ) > system time . time millis ( ) ; }	utility method that check for valid resource.
public static int max fill ( final int n , final float f ) { return math . min ( ( int ) math . ceil ( n * f ) , n - num ) ; }	returns the maximum number of entries that can be filled before rehashing .
public void clear ( ) { m categories . clear ( ) ; m titles . clear ( ) ; m values . clear ( ) ; }	removes all the existing values from the series .
public void toggle section selected ( int section index ) { set section selected ( section index , ! is section selected ( section index ) ) ; }	toggle selection state of an entire section.
public string combine ( list < string > files , string out file ) throws exception { array list < string > cmd = new array list < string > ( ) ; cmd . add ( sox bin ) ; for ( string file : files ) { cmd . add ( file ) ; } cmd . add ( out file ) ; int rc = exec sox ( cmd , callback ) ; if ( rc != num ) { throw new exception ( str + rc ) ; } return out file ; }	simple combiner sox file [ 0 ] file [ 1 ].
void stop scrolling instance ( ) { if ( log . is loggable ( platform logger . level . finer ) ) { log . finer ( str + this ) ; } i scroller . stop ( ) ; }	tell the instance scroller to stop scrolling . see 6243382 for more information.
public void execute2 ( kahan object in1 , double in2 ) { if ( double . is infinite ( in1 . sum ) || double . is infinite ( in2 ) ) { in1 . set ( double . is infinite ( in2 ) ? in2 : in1 . sum , num ) ; return ; } double correction = in2 + in1 . correction ; double sum = in1 . sum + correction ; in1 . set ( sum , correction - ( sum - in1 . sum ) ) ; }	simplified version of execute ( data in1 , double in2 ) without exception handling and casts .
public static response new fixed length response ( string msg ) { return new fixed length response ( status . ok , httpd . mime html , msg ) ; }	create a text response with known length .
@ override public xml peek ( ) throws xml { log . log ( level . fine , str ) ; if ( ! has next ( ) ) { throw new xml ( str ) ; } log . log ( level . fine , str , next event ) ; return next event ; }	check the next xmlevent without reading it from the stream.
public static string replace end point ( string url , string end point ) { return end point + url . replace first ( default endpoint , str ) ; }	replace the url end point ( schema + host + port ) with the given end point .
private void make ok path ( ) { path1 . reset ( ) ; int w2 = get measured width ( ) / num ; int h2 = get measured height ( ) / num ; double a = math . cos ( math . to radians ( num ) ) * get radius ( ) ; double c = math . sin ( math . to radians ( num ) ) * get radius ( ) ; double l = math . cos ( math . to radians ( num ) ) * num * a ; double b = math . sin ( math . to radians ( num ) ) * l ; double m = math . cos ( math . to radians ( num ) ) * l ; path1 . move to ( ( float ) ( w2 - a ) , ( float ) ( h2 - c ) ) ; path1 . line to ( ( float ) ( w2 - a + m ) , ( float ) ( h2 - c + math . sin ( math . to radians ( num ) ) * l ) ) ; path1 . line to ( ( float ) ( w2 + a ) , ( float ) ( h2 - c ) ) ; path measure1 . set path ( path1 , bool ) ; m mark oklength = path measure1 . get length ( ) ; }	make the path to show.
public void add member value ( string name , member value value ) { pair p = new pair ( ) ; p . name = pool . add utf8 info ( name ) ; p . value = value ; if ( members == null ) members = new linked hash map ( ) ; members . put ( name , p ) ; }	adds a new member .
protected list < string > add whitespace ( list < string > list ) { list < string > whitespace list = new array list < > ( ) ; for ( string value : list ) { whitespace list . add ( add whitespace ( value ) ) ; } return whitespace list ; }	adds leading and trailing whitespace characters to all members in this list .
public static string compute qualified widget type name ( node widget node ) { if ( widget node . get node type ( ) != node . element node ) { return null ; } string type name = widget node . get local name ( ) ; if ( type name . length ( ) == num || character . is lower case ( type name . char at ( num ) ) ) { return null ; } string package name = ui binder utilities . get package name ( widget node . get namespace uri ( ) ) ; return package name != null ? java utilities . get qualified type name ( type name , package name ) : null ; }	computes the fully qualified name for the widget - derived type at the given node .
private static boolean process ftyp atom ( parsable byte array atom data ) { atom data . set position ( atom . header size ) ; int major brand = atom data . read int ( ) ; if ( major brand == brand quicktime ) { return bool ; } atom data . skip bytes ( num ) ; while ( atom data . bytes left ( ) > num ) { if ( atom data . read int ( ) == brand quicktime ) { return bool ; } } return bool ; }	process an ftyp atom to determine whether the media is quicktime .
public map < string , string > parse ( final string str , char separator ) { if ( str == null ) { return new hash map < string , string > ( ) ; } return parse ( str . to char array ( ) , separator ) ; }	extracts a map of name / value pairs from the given string.
public string delete ( string url , final int expected status code ) { return delete ( url , collections . < string , string > empty map ( ) , expected status code ) ; }	issue an http delete and assert the response status code .
protected void running sum ( set < map . entry < double , double > > c , double value , double [ ] sums ) { double offset = const - math . log ( m ) ; double log factor = math . log ( m ) - math . log ( num - m ) ; double log sum of weights = math . log ( m ) ; iterator < map . entry < double , double > > itr = c . iterator ( ) ; while ( itr . has next ( ) ) { map . entry < double , double > entry = itr . next ( ) ; if ( entry . get value ( ) > num ) { double diff = ( entry . get key ( ) - value ) / m ; double log density = offset - num * diff * diff ; double log weight = math . log ( entry . get value ( ) ) ; sums [ num ] = log of sum ( sums [ num ] , log weight + log density ) ; sums [ num ] = log of sum ( sums [ num ] , log weight ) ; if ( log density + log sum of weights < log of sum ( log factor + sums [ num ] , log density + sums [ num ] ) ) { break ; } } } }	compute running sum of density values and weights .
@ override public categorical table copy ( ) { map < value , double > new table = new hash map < value , double > ( ) ; for ( value v : table . key set ( ) ) { new table . put ( v , table . get ( v ) ) ; } return new categorical table ( variable , new table ) ; }	returns a copy of the probability table.
public configuration sub config ( string prefix , string key prefix ) { configuration sub = new configuration ( ) ; add to sub conf ( sub , prefix . length ( ) > num ? prefix + str + key prefix : key prefix ) ; return sub ; }	return a sub configuration from this instance that has the keys equal to either prefix.
public map < string , string > map name to display name ( set < string > names ) throws sms , sso { final map < string , string > map = new hash map < > ( names . size ( ) ) ; for ( string name : names ) { if ( sms console service config . is service visible ( name ) ) { final service schema manager service schema manager = service schema manager factory . build ( name ) ; string display name = get localized service name ( service schema manager , name ) ; string resource name = service schema manager . get resource name ( ) ; if ( ! name . equals ( display name ) && ! string utils . is blank ( resource name ) ) { map . put ( resource name , display name ) ; } } } return map ; }	maps service internal names to displayable ( localized ) names via their resource names.
public int column ( int nrows , int capacity , int default value ) { super ( int . class , new integer ( default value ) ) ; if ( capacity < nrows ) { throw new illegal argument exception ( str ) ; } m values = new int [ capacity ] ; arrays . fill ( m values , default value ) ; m size = nrows ; }	create a new intcolumn .
@ override public string to string ( ) { return str + get id ( ) ; }	returns a string representation of the object .
public static final boolean execute potential work ( final object data , final image view image view ) { final bitmap worker task bitmap worker task = get bitmap worker task ( image view ) ; if ( bitmap worker task != null ) { final object bitmap data = bitmap worker task . m key ; if ( bitmap data == null || ! bitmap data . equals ( data ) ) { bitmap worker task . cancel ( bool ) ; } else { return bool ; } } return bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
public static void queue bitmap ( string key , bitmap bmp ) { m bitmap queue . put ( key , bmp ) ; }	temporarily store a bitmap.
public void add listener ( after server start listener listener ) { after start listeners . add ( listener ) ; }	adds a new afterstart listener for post - startup cleanup.
private int make available ( ) throws io { if ( pos != - num ) { return num ; } total += tail - head - pad ; system . arraycopy ( buffer , tail - pad , buffer , num , pad ) ; head = num ; tail = pad ; for ( ; ; ) { int bytes read = input . read ( buffer , tail , buf size - tail ) ; if ( bytes read == - num ) { final string msg = str ; throw new file upload exception ( malformed stream exception , msg ) ; } tail += bytes read ; find separator ( ) ; int av = available ( ) ; if ( av > num || pos != - num ) { return av ; } } }	attempts to read more data .
public relation notification ( string notif type , object source obj , long sequence , long time stamp , string message , string id , string type name , object name object name , list < object name > unreg m ) throws illegal argument exception { super ( notif type , source obj , sequence , time stamp , message ) ; if ( ! is valid basic strict ( notif type , source obj , id , type name ) || ! is valid create ( notif type ) ) { throw new illegal argument exception ( str ) ; } relation id = id ; relation type name = type name ; relation obj name = safe get object name ( object name ) ; unregister m = safe get object name list ( unreg m ) ; }	creates a notification for either a relation creation ( relationsupport object created internally in the relation service , or an mbean added as a relation ) or for a relation removal from the relation service .
public void add data to store ( object [ ] row ) throws carbon data writer exception { data rows . add ( row ) ; this . entry count ++ ; if ( this . entry count == this . blocklet size ) { try { semaphore . acquire ( ) ; producer executor service task list . add ( producer executor service . submit ( new producer ( blocklet data holder , data rows , ++ writer task sequence counter ) ) ) ; blocklet processing count . increment and get ( ) ; processed data count += entry count ; logger . info ( str + processed data count ) ; data rows = new array list < > ( this . blocklet size ) ; this . entry count = num ; } catch ( interrupted exception e ) { logger . error ( e , e . get message ( ) ) ; throw new carbon data writer exception ( e . get message ( ) ) ; } } }	below method will be used to add row to store.
public boolean local host or domain is ( string host , string domain ) { return domain . starts with ( host ) ; }	is true if the host name matches exactly the specified host name , or if there is no domain name part in the host name , but the unqualified host name matches .
protected double entropy ( double [ ] [ ] data zs , double [ ] [ ] data ws ) { double entropy = num ; int num instances = data zs . length ; for ( int j = num ; j < m num classes ; j ++ ) { double m = num ; double sum = num ; for ( int i = num ; i < num instances ; i ++ ) { m += data zs [ i ] [ j ] * data ws [ i ] [ j ] ; sum += data ws [ i ] [ j ] ; } m /= sum ; for ( int i = num ; i < num instances ; i ++ ) { entropy += data ws [ i ] [ j ] * math . pow ( data zs [ i ] [ j ] - m , num ) ; } } return entropy ; }	helper function to compute entropy from z / w values .
public void save working instances to file q ( ) { if ( m io == null ) { m . set capabilities filter ( m . get capabilities filter ( ) ) ; m . set accept all file filter used ( bool ) ; int return val = m . show save dialog ( this ) ; if ( return val == j . approve option ) { instances inst = new instances ( m ) ; inst . set class index ( m . get coloring index ( ) ) ; save instances to file ( m . get saver ( ) , inst ) ; } file filter temp = m . get file filter ( ) ; m . set accept all file filter used ( bool ) ; m . set file filter ( temp ) ; } else { j . show message dialog ( this , str + str , str , j . warning message ) ; } }	queries the user for a file to save instances as , then saves the instances in a background process.
private void calculate color ( int coord ) { coord = coord - m bar pointer halo radius ; if ( coord < num ) { coord = num ; } else if ( coord > m bar length ) { coord = m bar length ; } m color = color . hsv ( math . round ( m pos to opac factor * coord ) , m hsv ) ; if ( color . alpha ( m color ) > num ) { m color = color . hsv ( m hsv ) ; } else if ( color . alpha ( m color ) < num ) { m color = color . transparent ; } }	calculate the color selected by the pointer on the bar .
public int read ( char cbuf [ ] , int off , int len ) throws io { if ( ( off < num ) || ( off > cbuf . length ) || ( len < num ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < num ) ) throw new index out of bounds exception ( ) ; if ( len == num ) return num ; if ( next >= length ) return - num ; int n = math . min ( length - next , len ) ; text . get chars ( next , next + n , cbuf , off ) ; next += n ; return n ; }	reads characters into a portion of an array .
private boolean adjust indent ( ) { alignment impl alignment = core formatter util . get alignment ( my current block ) ; white space white space = my current block . get white space ( ) ; if ( alignment == null || my alignments to skip . contains ( alignment ) ) { if ( white space . contains line feeds ( ) ) { adjust spacing by indent offset ( ) ; } else { white space . arrange spaces ( my current block . get space property ( ) ) ; } return bool ; } block alignment processor alignment processor = alignment processors . get ( alignment . get anchor ( ) ) ; if ( alignment processor == null ) { log . error ( string . format ( str , alignment . get anchor ( ) ) ) ; return bool ; } block alignment processor . context context = new block alignment processor . context ( my document , alignment , my current block , my alignment mappings , my backward shifted aligned blocks , get indent options to use ( my current block , my default indent option ) , my right margin ) ; block alignment processor . result result = alignment processor . apply alignment ( context ) ; final leaf block wrapper offset responsible block = alignment . get offset resp block before ( my current block ) ; switch ( result ) { case target block processed not aligned : return bool ; case target block aligned : store alignment mapping ( ) ; return bool ; case backward block aligned : if ( offset responsible block == null ) { return bool ; } set < leaf block wrapper > blocks caused realignment = new hash set < leaf block wrapper > ( ) ; my backward shifted aligned blocks . clear ( ) ; my backward shifted aligned blocks . put ( offset responsible block , blocks caused realignment ) ; blocks caused realignment . add ( my current block ) ; store alignment mapping ( my current block , offset responsible block ) ; my current block = offset responsible block . get next block ( ) ; on current line changed ( ) ; return bool ; case recursion detected : my current block = offset responsible block ; case unable to align backward block : my alignments to skip . add ( alignment ) ; return bool ; default : return bool ; } }	adjusts indent of the current block .
@ override public void append code ( type declaring type , type tuple input types , type output type , list < variable > input vars , string builder b ) { b . append ( field . to code ( declaring type , input vars ) ) ; }	adds the text for an initialization of a variable from a field to the stringbuilder .
public forward planner ( dialogue system system ) { this . system = system ; }	constructs a forward planner for the dialogue system .
private j add button ( string text , container container , float alignment ) { j button = new j ( text ) ; button . set alignment x ( alignment ) ; container . add ( button ) ; return button ; }	adds a preconfigured jbutton to the specified container using the specified alignment constraint.
private boolean no match for tag in attributes ( attribute set attr , html . tag t , object tag value ) { if ( attr != null && attr . is defined ( t ) ) { object new value = attr . get attribute ( t ) ; if ( ( tag value == null ) ? ( new value == null ) : ( new value != null && tag value . equals ( new value ) ) ) { return bool ; } } return bool ; }	searches the attribute set for a tag , both of which are passed in as a parameter.
public string business object data key to string ( business object data key business object data key ) { if ( business object data key == null ) { return null ; } return business object data key to string ( business object data key . get namespace ( ) , business object data key . get business object definition name ( ) , business object data key . get business object format usage ( ) , business object data key . get business object format file type ( ) , business object data key . get business object format version ( ) , business object data key . get partition value ( ) , business object data key . get sub partition values ( ) , business object data key . get business object data version ( ) ) ; }	returns a string representation of the business object data key .
private usage create talk usage ( context context ) { if ( talk usage != null ) { return talk usage ; } type token < list < usage > > token = new type token < list < usage > > ( ) { } ; list < usage > init talk io = json utils . parse json file ( context , str , token ) ; talk usage = init talk io . get ( num ) ; return talk usage ; }	get talk incoming / outgoing info from the json file and save in cache.
@ nullable public gr call enclosing call ( string name , gdsl members holder consumer consumer ) { final psi element place = consumer . get place ( ) ; if ( place == null ) return null ; gr call call = psi tree util . get parent of type ( place , gr call . class , bool ) ; if ( call == null ) return null ; while ( call != null && ! name . equals ( get invoked method name ( call ) ) ) { call = psi tree util . get parent of type ( call , gr call . class , bool ) ; } if ( call == null ) return null ; final gr argument list argument list = call . get argument list ( ) ; if ( argument list != null ) { for ( gr expression arg : argument list . get expression arguments ( ) ) { if ( arg instanceof gr closable block && psi tree util . find common parent ( place , arg ) == arg ) { return call ; } } } if ( call instanceof gr method call expression ) { for ( gr expression arg : call . get closure arguments ( ) ) { if ( arg instanceof gr closable block && psi tree util . find common parent ( place , arg ) == arg ) { return call ; } } } return null ; }	returns enclosing method call of a given context ' s place.
public static void gen ovfenv iso image ( string ovfenv prop kv , string iso file path ) { byte [ ] b ovfenv prop kv = ovfenv prop kv . get bytes ( ) ; string prop file path = str ; file prop file = new file ( prop file path ) ; try { file utils . write plain file ( prop file path , b ovfenv prop kv ) ; } catch ( exception e1 ) { prop file . delete ( ) ; log . error ( str , e1 . get message ( ) ) ; throw new illegal state exception ( str ) ; } try { file iso file = new file ( iso file path ) ; string [ ] gen iso = { geniso cmd , str , str , str , prop file path , str , iso file path , str , str } ; exec . result result = exec . sudo ( cmd timeout , gen iso ) ; if ( ! result . exited normally ( ) || result . get exit value ( ) != num ) { log . error ( str , result . get exit value ( ) , result . get std error ( ) ) ; throw new illegal state exception ( str ) ; } } catch ( exception e ) { throw e ; } finally { prop file . delete ( ) ; } }	generate ovfenv iso image which will be then saved to ovfenv partition.
public static void create actionable event ( db client db client , event utils . event code event code , uri tenant , string name , string description , string warning , data object resource , list < uri > affected resources , string approve method , object [ ] approve parameters ) { create actionable event ( db client , event code , tenant , name , description , warning , resource , affected resources , approve method , approve parameters , null , null ) ; }	creates an actionable event and persists to the database.
public rational ( byte provider byte provider ) throws io { mxf . populate field ( byte provider , this , str ) ; mxf . populate field ( byte provider , this , str ) ; }	instantiates a new rational .
public synchronized void remove notifications ( string type ) throws instance not found exception { vector < integer > v = get notification i ( type ) ; if ( v . is empty ( ) ) throw new instance not found exception ( str ) ; for ( integer i : v ) remove notification ( i ) ; }	removes all the timer notifications corresponding to the specified type from the list of notifications .
private void unify via atom ( atomic parent atom ) { atomic child atom = get rule conclusion atom ( ) ; query parent = parent atom . get parent query ( ) ; map < string , string > unifiers = child atom . get unifiers ( parent atom ) ; head . unify ( unifiers ) ; body . unify ( unifiers ) ; set < string > child f = body . get var set ( ) ; set < string > parent b = parent atom . get var names ( ) ; set < string > parent vars = parent . get var set ( ) ; parent b . for each ( null ) ; child f . for each ( null ) ; }	propagate variables to child via a relation atom ( atom variables are bound ).
static void add uuid ( ssf node node , uuid uuid ) { node . set ( str , uuid . get most significant bits ( ) ) ; node . set ( str , uuid . get least significant bits ( ) ) ; }	adds uuid value to given node as uuidmost and uuidleast tags .
public long object field offset ( field field ) { if ( modifier . is static ( field . get modifiers ( ) ) ) { throw new illegal argument exception ( str ) ; } return object field offset0 ( field ) ; }	gets the raw byte offset from the start of an object ' s memory to the memory used to store the indicated instance field .
abstract void to xml ( string builder xml , int level ) ;	generates the xml representation of the object ( without xml headers or enclosing plist - tags ) .
public void dispose ( ) { m run button . set selected ( bool ) ; super . dispose ( ) ; }	when the window closes , stop any sequences running.
public flux concat array < t > concat additional source first ( publisher < ? extends t > source ) { int n = array . length ; @ suppress warnings ( str ) publisher < ? extends t > [ ] new array = new publisher [ n + num ] ; system . arraycopy ( array , num , new array , num , n ) ; new array [ num ] = source ; return new flux concat array < > ( delay error , new array ) ; }	returns a new instance which has the additional first source to be concatenated together with the current array of sources.
public void shutdown ( ) { shutdown server thread ( ) ; shutdown sessions ( ) ; }	closes the server socket and all client sockets .
private boolean is local id ( string local id ) { if ( ! local id . starts with ( str ) ) { return bool ; } for ( int i = num ; i < local id . length ( ) ; ++ i ) { char c = local id . char at ( i ) ; if ( ! ( c >= str && c <= str ) && ! ( c >= str && c <= str ) ) { return bool ; } } return bool ; }	returns true if localid has the right basic format for a local id .
public server socket bar bind ( server socket bar ss ) throws config exception , io { synchronized ( ssl init lock ) { if ( std server socket != null ) throw new config exception ( l . l ( str ) ) ; try { init config ( ) ; } catch ( runtime exception e ) { e . print stack trace ( ) ; throw e ; } std server socket = ss ; init ssl ( ) ; return this ; } }	creates the server socket .
private int check interrupt while waiting ( node node ) { return thread . interrupted ( ) ? ( transfer after cancelled wait ( node ) ? throw ie : reinterrupt ) : num ; }	checks for interrupt , returning throw_ie if interrupted before signalled , reinterrupt if after signalled , or 0 if not interrupted .
private void reset output builders ( ) { ansi = ansi . ansi ( ) ; string builder = new string builder ( ) ; }	reset both output builders .
public void write ( string filename ) { logger . info ( str ) ; try { open file ( filename ) ; write xml head ( ) ; start carriers ( this . writer ) ; for ( carrier carrier : carriers ) { start carrier ( carrier , this . writer ) ; write vehicles ( carrier , this . writer ) ; write shipments ( carrier , this . writer ) ; write plans ( carrier , this . writer ) ; end carrier ( this . writer ) ; } end carriers ( this . writer ) ; close ( ) ; logger . info ( str ) ; } catch ( io e ) { e . print stack trace ( ) ; logger . error ( e ) ; system . exit ( num ) ; } }	writes carriers and their plans into a xml - file .
public void remove resource listener ( resource events listener listener ) { resource listeners . remove ( listener ) ; }	un - registers a listener to the system.
public void test has main activity ( ) throws exception { m enabled . add ( launcher activity detector . issue more than one launcher ) ; m enabled . add ( launcher activity detector . issue missing launcher ) ; m enabled . add ( launcher activity detector . issue launcher activity in library ) ; string expected = str ; string result = lint project ( xml ( fn android manifest xml , str + str + str + str + str + str + str + str + str + str + str + str + str + str + str + str + str + str ) ) ; assert equals ( expected , result ) ; }	test that a manifest with an activity with a launcher intent has no warnings .
private void inform upon similar name ( final string buffer message buffer , final string name , final string candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . region matches ( bool , num , candidate , num , pkg len + num ) ) { message buffer . append ( str ) ; message buffer . append ( candidate ) ; message buffer . append ( str ) ; } }	appends message if the given name is similar to the candidate .
protected void write header ( random access file file , int size ) throws io { string str ; int offset = num ; byte [ ] buffer = new byte [ num ] ; str = integer . to string ( get size ( ) ) ; for ( int i = num ; i < ( num - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) str ; } offset += ( num - str . length ( ) ) ; for ( int i = num ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . char at ( i ) ; } file . write ( buffer ) ; }	this is called by superclass when attempt to write data from file .
public string build java vendor ( ) { return properties . get property ( str ) ; }	returns the vendor for the java version used to generate this build .
public voice result ( string match , float confidence ) { m match = match ; m confidence = confidence ; }	creates an instance of a voiceresult .
final void treeify ( node < k , v > [ ] tab ) { tree node < k , v > root = null ; for ( tree node < k , v > x = this , next ; x != null ; x = next ) { next = ( tree node < k , v > ) x . next ; x . left = x . right = null ; if ( root == null ) { x . parent = null ; x . red = bool ; root = x ; } else { k k = x . key ; int h = x . hash ; class < ? > kc = null ; for ( tree node < k , v > p = root ; ; ) { int dir , ph ; k pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - num ; else if ( ph < h ) dir = num ; else if ( ( kc == null && ( kc = comparable class for ( k ) ) == null ) || ( dir = compare comparables ( kc , k , pk ) ) == num ) dir = tie break order ( k , pk ) ; tree node < k , v > xp = p ; if ( ( p = ( dir <= num ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= num ) xp . left = x ; else xp . right = x ; root = balance insertion ( root , x ) ; break ; } } } } move root to front ( tab , root ) ; }	forms tree of the nodes linked from this node .
private void add category to tree ( default mutable tree node node , string [ ] names ) { if ( names . length == num ) { return ; } boolean matched = bool ; for ( @ suppress warnings ( str ) enumeration < default mutable tree node > e = node . children ( ) ; e . has more elements ( ) ; ) { default mutable tree node child node = e . next element ( ) ; string node name = ( string ) child node . get user object ( ) ; if ( node name . equals ( names [ num ] ) ) { if ( names . length > num ) { add category to tree ( child node , arrays . copy of range ( names , num , names . length ) ) ; matched = bool ; } else { } } } if ( ! matched ) { default mutable tree node root = node ; for ( int i = num ; i < names . length ; i ++ ) { default mutable tree node new node = new default mutable tree node ( names [ i ] ) ; root . add ( new node ) ; root = new node ; } } }	this recursive method is a hack : directoryitems flattens the directory structure , but it provides useful functionality , so this method will reconstruct the directory structure for the jtree .
public void add drawer listener ( @ non null drawer listener listener ) { if ( listener == null ) { return ; } if ( m listeners == null ) { m listeners = new array list < drawer listener > ( ) ; } m listeners . add ( listener ) ; }	adds the specified listener to the list of listeners that will be notified of drawer events .
private void edit note ( int note id ) { hide soft keyboard ( ) ; intent intent = new intent ( main activity . this , note activity . class ) ; intent . set flags ( intent . flag activity clear task ) ; intent . put extra ( str , string . value of ( note id ) ) ; start activity ( intent ) ; }	method used to enter note edition mode.
public final entry add entry ( position input position , position output position ) { entry entry = new entry ( input position , output position ) ; entries . add ( entry ) ; return entry ; }	adds an entry to the source map ( entry must be added in order ) .
public void un hide action bar ( view view ) { if ( toolbar auto hider != null ) toolbar auto hider . show component ( ) ; }	onclick handler - unhide action bar.
public static string format time delta ( long time , char sequence sep ) { final string builder sb = new string builder ( ) ; final formatter fmt = new formatter ( sb ) ; for ( int i = time unit sizes . length - num ; i >= num ; -- i ) { if ( i == num && sb . length ( ) > num ) { continue ; } if ( sb . length ( ) > num ) { sb . append ( sep ) ; } final long ac value = time / time unit sizes [ i ] ; time = time % time unit sizes [ i ] ; if ( ! ( ac value == num && sb . length ( ) == num ) ) { fmt . format ( str + time unit digits [ i ] + str , long . value of ( ac value ) , time unit names [ i ] ) ; } } fmt . close ( ) ; return sb . to string ( ) ; }	formats a time delta in human readable format .
public static double [ ] deconvolve ( final double [ ] p , final double rate ) { final double [ ] r = arrays . copy of ( p , p . length ) ; for ( int k = num ; k < p . length ; k ++ ) { for ( int j = num ; j < p . length ; j ++ ) { if ( k + j < p . length ) { r [ k + j ] -= rate * p [ k ] * p [ j ] ; } } } double sum = num ; for ( final double q : r ) { sum += q ; } sum = num / sum ; for ( int k = num ; k < r . length ; k ++ ) { r [ k ] *= sum ; } return r ; }	takes a probability distribution and reduces higher - order terms by contributions arising from combinations of lower order terms.
public static string collapse newlines ( string str ) { return collapse character ( str , str ) ; }	remove / collapse multiple newline characters.
private synchronized void read object ( java . io . object input stream s ) throws io , class not found exception { s . default read object ( ) ; init ( get name ( ) ) ; }	readobject is called to restore the state of the execoptionpermission from a stream .
public static double calculate column total ( d data , int column , int [ ] valid rows ) { param checks . null not permitted ( data , str ) ; double total = num ; int row count = data . get row count ( ) ; for ( int v = num ; v < valid rows . length ; v ++ ) { int row = valid rows [ v ] ; if ( row < row count ) { number n = data . get value ( row , column ) ; if ( n != null ) { total += n . double value ( ) ; } } } return total ; }	returns the total of the values in one column of the supplied data table by taking only the row numbers in the array into account .
public boolean open analysis ( file f , save type save type ) { if ( ! f . exists ( ) || ! f . can read ( ) ) { throw new illegal argument exception ( str + f . get path ( ) ) ; } main frame load save helper . prepare for file load ( f , save type ) ; main frame load save helper . load analysis ( f ) ; return bool ; }	opens the analysis . also clears the source and summary panes . makes comments enabled false . sets the savetype and adds the file to the recent menu .
public void children removed ( bean context membership event bcme ) { find and undo ( bcme . iterator ( ) ) ; }	method for beancontextmembership interface .
public string process ( item item ) throws process exception { int count = num ; item ss = item . get item as ( relation . syllable ) ; item first syllable = last last syllable path . find item ( item ) ; for ( item p = ss ; p != null ; p = p . get next ( ) ) { if ( p . equals shared ( first syllable ) ) { break ; } count ++ ; } return integer . to string ( rail ( count ) ) ; }	performs some processing on the given item .
private void remove instances from containers ( array list < container > containers , map < integer , list < instance id > > allocation , map < string , integer > components to scale down ) { array list < ram requirement > ram requirements = get ram ( components to scale down ) ; for ( ram requirement ram requirement : ram requirements ) { string component = ram requirement . get component name ( ) ; int num instances to remove = - components to scale down . get ( component ) ; for ( int j = num ; j < num instances to remove ; j ++ ) { pair < integer , instance id > id pair = remove rr ( containers , component ) ; list < instance id > instances = allocation . get ( id pair . first ) ; instances . remove ( id pair . second ) ; allocation . put ( id pair . first , instances ) ; } } }	removes instances from containers during scaling down.
protected void draw normal message ( draw handler draw handler , point double send , point double receive , relation drawer . arrow end type arrow end type , boolean fill arrow , drawing info drawing info ) { line line = new line ( send , receive ) ; draw handler . draw line ( line ) ; draw handler . set line type ( line type . solid ) ; relation drawer . draw arrow to line ( receive , draw handler , line , bool , arrow end type , fill arrow , bool ) ; double height = send . y - drawing info . get vertical start ( send tick ) ; double top left x ; align horizontal h alignment ; if ( from == get first lifeline ( ) ) { top left x = send . x ; h alignment = align horizontal . left ; } else { top left x = receive . x ; h alignment = align horizontal . right ; } if ( duration == num ) { h alignment = align horizontal . center ; } top left x += lifeline text padding ; text splitter . draw text ( draw handler , text lines , top left x , send . y - height , math . abs ( send . x - receive . x ) - lifeline text padding * num , height , h alignment , align vertical . bottom ) ; }	draws a message which is sent between two different lifelines.
private void kill consist ( ) { if ( valid loco adr ( loco text field1 . get text ( ) ) < num ) { return ; } int loco addr = get loco addr ( loco text field1 , adr button1 ) ; send nce binary command ( loco addr , nce binary command . loco cmd kill consist , ( byte ) num ) ; }	kills consist using lead loco address.
public listen key start listening ( ) throws io { return start listening ( null , num ) ; }	listen on the default address.
@ nonnull public static set < flag > parse ( @ nonnegative final int bitmask ) { check . not negative ( bitmask , str ) ; final set < flag > flags = new hash set < flag > ( ) ; for ( final flag flag : values ( ) ) { if ( ( bitmask & flag . get number ( ) ) != num ) { flags . add ( flag ) ; } } return flags ; }	parses a sum of flags as numerical values ( bitmask ) and translates it to set of enum values .
protected boolean engine verify ( byte [ ] sig bytes ) throws signature exception { if ( sig bytes == null ) { throw new null pointer exception ( str ) ; } return check signature ( sig bytes , num , num ) ; }	verifies the signature bytes .
public void add match string ( string match string ) { match strings . add ( match string ) ; }	add string to see if it matches in the query.
public string time ago ( final long millis ) { return time ( system . current time millis ( ) - millis ) ; }	get time ago that milliseconds date occurred.
public static byte [ ] hex string to byte array ( string input ) { if ( ( input == null ) || ( input . length ( ) % num != num ) ) { throw new illegal argument exception ( str + str + input ) ; } byte [ ] output = new byte [ input . length ( ) / num ] ; for ( int i = num ; i < output . length ; i ++ ) { output [ i ] = ( byte ) ( ( character . digit ( input . char at ( i * num ) , num ) << num ) + character . digit ( input . char at ( i * num + num ) , num ) ) ; } return output ; }	converts a string with an even number of hexadecimal characters to a byte array .
private boolean stop tracking job ( job status job status ) { boolean removed ; boolean rocking ; synchronized ( m jobs ) { removed = m jobs . remove ( job status ) ; rocking = m ready to rock ; } if ( removed && rocking ) { for ( int i = num ; i < m controllers . size ( ) ; i ++ ) { state controller controller = m controllers . get ( i ) ; controller . maybe stop tracking job ( job status ) ; } } return removed ; }	called when we want to remove a jobstatus object that we ' ve finished executing.
public double coefficient of variance ( ) { return math . sqrt ( variance ( ) ) / mean ( ) ; }	returns the coefficient of variance .
public string to string ( ) { string builder buf = new string builder ( ) ; buf . append ( this . coefficient ) ; if ( this . variables . length > num ) { buf . append ( str ) ; } for ( int variable : this . variables ) { buf . append ( str ) ; buf . append ( variable ) ; buf . append ( str ) ; } return buf . to string ( ) ; }	prints out a representation of the term .
public skeleton version checker ( int default version ) { my explicit version = create tree map ( ) ; my default version = default version ; load ( ) ; }	creates an instance , loads requirements file .
@ override public attribute schema impl upgrade attribute ( attribute schema impl new attr ) throws upgrade exception { return update default values ( new attr , collections . singleton ( oldest version ) ) ; }	this is called when the service is added for the first time and it will change the default install value of an attribute .
public static string to dalvik name ( string canonical name ) { final boolean is array = ( canonical name . char at ( num ) == str ) ; if ( is array ) { return canonical name . replace ( str , str ) ; } else { if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else if ( canonical name . equals ( str ) ) return str ; else return str + canonical name . replace ( str , str ) + str ; } }	convert a canonical java class name to dalvik flavor .
private void emit ensure collection ( method method , string field name , string builder builder ) { builder . append ( str ) ; builder . append ( get ensure name ( field name ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( field name ) ; builder . append ( str ) ; builder . append ( field name ) ; builder . append ( str ) ; builder . append ( get impl name ( method . get generic return type ( ) , bool ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( str ) ; }	emit a method that ensures a collection is initialized .
public void unregister client ( id proxy id , acceptor impl acceptor , boolean client disconnected cleanly ) { unregister client ( proxy id ) ; if ( acceptor != null ) { cache client notifier ccn = acceptor . get cache client notifier ( ) ; if ( ccn != null ) { try { ccn . unregister client ( proxy id , client disconnected cleanly ) ; } catch ( cancel exception ignore ) { } } } }	unregisters a client to be monitored .
private string double quotes handling ( string resource ) { return resource . replace all ( str , matcher . quote replacement ( str ) ) ; }	this method handles double quotes .
public static int allocate new container ( array list < container > containers , resource capacity , int padding percentage ) { containers . add ( new container ( capacity , padding percentage ) ) ; return containers . size ( ) ; }	allocate a new container of a given capacity.
public static boolean is local resource uri ( uri uri ) { final string scheme = get scheme or null ( uri ) ; return local resource scheme . equals ( scheme ) ; }	check if uri represents local resource.
protected string do wait for path ( string file path ) { string path = null ; long wait time millis = num ; assert true ( str + file path + str , m sm . is obb mounted ( file path ) ) ; while ( path == null ) { try { thread . sleep ( wait time incr ) ; wait time millis += wait time incr ; if ( wait time millis > max wait time ) { fail ( str + file path ) ; } } catch ( interrupted exception e ) { } path = m sm . get mounted obb path ( file path ) ; } log . i ( log tag , str + path ) ; return path ; }	helper to synchronously wait until we can get a path for a given obb file.
@ override protected boolean is zone level resource ( ) { return bool ; }	block consistency group is not a zone level resource.
private void validate message ( string expected type , string type , long return code , string service , string payload ) throws replicator exception { if ( ! type . equals ( expected type ) ) { throw new replicator exception ( str + protocol . type filtered + str + type + str ) ; } else if ( return code != num ) { throw new replicator exception ( str + return code + str + payload ) ; } else if ( ! service . equals ( message generator . get service ( ) ) ) { throw new replicator exception ( str + service + str + message generator . get service ( ) + str ) ; } }	protocol safety checks for the server returned message .
private void close databases ( ) { s logger . log ( level . info , str ) ; s logger . log ( level . info , str ) ; m source . close ( ) ; m target . close ( ) ; m source . reset ( ) ; m source = null ; m target . reset ( ) ; m target = null ; m direction = null ; m object type = null ; m object types = null ; m source map = null ; m target map = null ; m object list = new array list < string > ( ) ; m tracking list = new array list < string > ( ) ; m temp indexes = null ; m counter prg = null ; m counter drp = null ; m counter upd = null ; m counter add = null ; m total prg = null ; m total drp = null ; m total upd = null ; m total add = null ; m detail type = null ; m detail types = null ; m detail counter drp = null ; m detail counter upd = null ; m detail counter add = null ; system . gc ( ) ; }	closes target and source databases.
public static byte [ ] m ( final byte [ ] message , final int offset , final int length ) { message digest digest ; try { digest = message digest . get instance ( str ) ; digest . update ( message , offset , length ) ; final byte [ ] md5 = digest . digest ( ) ; return md5 ; } catch ( final no such algorithm exception e ) { if ( cfg . exception ) { check . log ( e ) ; } } return null ; }	calcola il md5 del messaggio , usando la crypto api .
private int run metastore compare job ( optional < path > input table list path , path output path ) throws interrupted exception , io , class not found exception , template render exception { log . info ( str ) ; int result ; if ( input table list path . is present ( ) ) { result = run metastore compare job with text input ( input table list path . get ( ) , output path ) ; } else { result = run metastore compare job ( output path ) ; } if ( result == num ) { log . info ( str + str + velocity utils . render template ( ste hql template , velocity context ) ) ; } return result ; }	runs the job to scan the metastore for directory locations .
public void delete sub people containers ( set people containers ) throws am , sso { iterator iter = people containers . iterator ( ) ; while ( iter . has next ( ) ) { string people container dn = ( string ) iter . next ( ) ; am people container = new am ( super . token , people container dn ) ; people container . delete ( ) ; } }	deletes sub people containers in this people container .
private void test find recent message uids in mailbox ( ) throws exception { log . info ( str ) ; list < message uid > recent messages = message mapper . find recent message uids in mailbox ( mboxes . get ( num ) ) ; assert equals ( message no . size ( ) - num , recent messages . size ( ) ) ; }	test of findrecentmessageuidsinmailbox method , of class hbasemessagemapper .
public void queue event ( runnable r ) { if ( r == null ) { throw new illegal argument exception ( str ) ; } synchronized ( s gl ) { m event queue . add ( r ) ; s gl . notify all ( ) ; } }	queue an " event " to be run on the gl rendering thread .
private void add error message ( string message ) { if ( message != null ) { m error messages . append ( message ) ; } m error messages . append ( str ) ; }	return list of error messages found while parsing last template .
@ suppress warnings ( str ) protected final void ensure capacity ( long target size ) { long capacity = capacity ( ) ; if ( target size > capacity ) { inflate spine ( ) ; for ( int i = spine index + num ; target size > capacity ; i ++ ) { if ( i >= spine . length ) { int new spine size = spine . length * num ; spine = arrays . copy of ( spine , new spine size ) ; prior element count = arrays . copy of ( prior element count , new spine size ) ; } int next chunk size = chunk size ( i ) ; spine [ i ] = ( e [ ] ) new object [ next chunk size ] ; prior element count [ i ] = prior element count [ i - num ] + spine [ i - num ] . length ; capacity += next chunk size ; } } }	ensure that the buffer has at least capacity to hold the target size.
public void write ( string key , byte [ ] new value ) throws exception { map < string , byte [ ] > entry = new hash map < > ( ) ; entry . put ( key , new value ) ; write ( entry ) ; }	performs the best effort of updating zk node { basepath } / { key } to the provided value.
public string query ( string handler , solr query request req ) throws exception { try ( solr core core = get core inc ( ) ) { solr query response rsp = new solr query response ( ) ; solr request info . set request info ( new solr request info ( req , rsp ) ) ; core . execute ( core . get request handler ( handler ) , req , rsp ) ; if ( rsp . get exception ( ) != null ) { throw rsp . get exception ( ) ; } string writer sw = new string writer ( num ) ; query response writer response writer = core . get query response writer ( req ) ; response writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to string ( ) ; } finally { req . close ( ) ; solr request info . clear request info ( ) ; } }	processes a " query " using a user constructed solrqueryrequest , and closes the request at the end .
private boolean both links have same link stats ( link link a , link link b ) { boolean both links have same link stats = bool ; if ( link a . get freespeed ( ) != link b . get freespeed ( ) ) { both links have same link stats = bool ; } if ( link a . get capacity ( ) != link b . get capacity ( ) ) { both links have same link stats = bool ; } return both links have same link stats ; }	compare link attributes . return whether they are the same or not .
public string generate sanitized id ( ) { string result = generate id ( ) ; result = result . replace ( str , str ) ; result = result . replace ( str , str ) ; result = result . replace ( str , str ) ; return result ; }	generate a unique id - that is friendly for a url or file system.
public static synchronized void remove provider ( int provider number ) { provider p = providers . remove ( provider number - num ) ; providers names . remove ( p . get name ( ) ) ; set need refresh ( ) ; }	removes the provider at the specified 1 - based position .
private object parse element ( node element ) throws xml parse exception { try { return parse element raw ( element ) ; } catch ( exception e ) { throw new xml parse exception ( str + element . get node name ( ) , e ) ; } }	parses a ( non - top ) xml element .
public static string format ( money money ) { long micro amount = num ; if ( money != null ) { micro amount = money . get micro amount ( ) ; } else { return placeholder null ; } double amount = ( double ) micro amount / micro units ; return string . format ( format money , amount ) ; }	formats a given monetary value in a default format ( 2 decimals , padded left to 10 characters ) .
private void delete instance ( entry class eclass ) { int idx = entry classes . index of ( eclass ) ; eclass = ( entry class ) entry classes . get ( idx ) ; int num = eclass . get num instances ( ) - num ; if ( num == num ) entry classes . remove ( idx ) ; eclass . set num instances ( num ) ; }	delete an instance of the entryclass , and remove the class from entryclasses if this is the last such instance .
public properties read settings ( ) { try { string pac script url = detect script url per dhcp ( ) ; if ( pac script url == null ) { pac script url = detect script url per dns ( ) ; } if ( pac script url == null ) { return null ; } properties result = new properties ( ) ; result . set property ( str , pac script url ) ; return result ; } catch ( io e ) { return new properties ( ) ; } }	loads the settings and stores them in a properties map .
public void log warning ( string message ) { logger . warning ( log prefix + message ) ; }	logs a warning message using the logger of this interpreter .
public static string read as string ( input stream is ) throws io { string buffer buf = new string buffer ( ) ; byte [ ] b = new byte [ num ] ; int nread = - num ; while ( ( nread = is . read ( b ) ) >= num ) { string s = new string ( b , num , nread ) ; buf . append ( s ) ; } return buf . to string ( ) ; }	reads an input stream into a single string result .
public array field vector ( int size , t preset ) { this ( preset . get field ( ) , size ) ; arrays . fill ( data , preset ) ; }	construct a vector with preset values .
public static synchronized void unregister transaction service plugin ( transaction service plugin l ) { if ( service != null ) { service . remove ts ( l ) ; } ts listeners list . remove ( l ) ; }	remove a transaction service listener .
protected static void isort ( int level [ ] , float bc [ ] ) { float temp ; int temp2 ; for ( int i = num ; i < bc . length - num ; i ++ ) { int j = i ; temp = bc [ j + num ] ; temp2 = level [ j + num ] ; if ( temp == num ) { continue ; } int prej = j + num ; while ( j > - num && ( temp < bc [ j ] || bc [ j ] == num ) ) { if ( bc [ j ] == num ) { j -- ; continue ; } else { bc [ prej ] = bc [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } bc [ prej ] = temp ; level [ prej ] = temp2 ; } }	this methods sorts the vertices in level [ ] according to their barycenters in bc [ ] , using insertion sort.
public void test is consistent model class ( ) { session node node1 = new session node ( type1 . class ) ; session node node2 = new session node ( type2 . class ) ; session node node3 = new session node ( type3 . class ) ; session node node4 = new session node ( new class [ ] { type1 . class , type2 . class } ) ; session node node6 = new session node ( new class [ ] { type1 . class , type2 . class , type3 . class } ) ; session node node7 = new session node ( new class [ ] { type1 . class , type4 . class } ) ; list parents = new array list ( ) ; parents . add ( node1 ) ; parents . add ( node2 ) ; parents . add ( node3 ) ; parents . remove ( node1 ) ; parents . remove ( node2 ) ; parents . remove ( node3 ) ; parents . add ( node4 ) ; assert true ( node1 . is consistent model class ( type1 . class , parents , bool ) ) ; parents . add ( node6 ) ; assert true ( node1 . is consistent model class ( type1 . class , parents , bool ) ) ; parents . remove ( node6 ) ; parents . add ( node7 ) ; assert true ( ! node1 . is consistent model class ( type1 . class , parents , bool ) ) ; }	tests whether model classes can identified correctly as consistent .
public void find and init ( object some obj ) { if ( some obj instanceof com . bbn . openmap . map bean ) { logger . fine ( str ) ; set map bean ( ( map bean ) some obj ) ; } }	look at the object received in a maphandler status message and connect to it if necessary .
public void remove all layers ( ) { layers . remove all elements ( ) ; refresh layers = bool ; super . repaint ( ) ; }	removes all layers from the map.
public int size ( ) { return productions . size ( ) ; }	returns the number of productions contained in this rule .
public static future < boxed unit > zk async create full path optimistic ( final zoo keeper client zkc , final string path to create , final byte [ ] data , final list < acl > acl , final create mode create mode ) { optional < string > parent path should not create = optional . absent ( ) ; return zk async create full path optimistic ( zkc , path to create , parent path should not create , data , acl , create mode ) ; }	asynchronously create zookeeper path recursively and optimistically .
private void write object ( object output stream oos ) throws io { oos . default write object ( ) ; write stroke ( oos , stroke , om . basic stroke ) ; write texture mask ( oos , texture mask ) ; }	write this object to a stream .
public boolean equals ( object obj ) { if ( obj instanceof m q ) { m q cmp = ( m q ) obj ; if ( ! cmp . is valid amt ( ) || ! is valid amt ( ) ) return bool ; big decimal cmp net = cmp . get net amt ( ) ; if ( cmp net == null ) return bool ; big decimal net = cmp . get net amt ( ) ; if ( net == null ) return bool ; return cmp net . compare to ( net ) == num ; } return bool ; }	is net amount equal ?.
public reflective attribute ( class < o > object type , class < a > field type , string field name ) { super ( object type , field type , field name ) ; field field ; try { field = get field ( object type , field name ) ; if ( ! field . is accessible ( ) ) { field . set accessible ( bool ) ; } } catch ( exception e ) { throw new illegal state exception ( str + field name + str + object type . get name ( ) + str ) ; } if ( ! field type . is assignable from ( field . get type ( ) ) ) { throw new illegal state exception ( str + field name + str + field . get type ( ) + str + object type . get name ( ) + str + field type . get name ( ) ) ; } this . field = field ; }	creates an attribute which reads values from the field indicated using reflection .
private void process event ( event log control check , final string name , final dtn host1 , final dtn host2 , final message message ) { string desc string ; if ( ! check . show event ( ) ) { return ; } desc string = name + str + ( host1 != null ? host1 : str ) + ( host2 != null ? ( host delim + host2 ) : str ) + ( message != null ? str + message : str ) ; if ( reg exp != null && ! desc string . matches ( reg exp ) ) { return ; } if ( check . pause on event ( ) ) { gui . set paused ( bool ) ; if ( host1 != null ) { gui . set focus ( host1 ) ; } } add event ( name , host1 , host2 , message , check . pause on event ( ) ) ; }	processes a log event.
public boolean remove membership listener ( membership listener listener ) { return membership listeners . remove ( listener ) != null ; }	remove listener from the list to receive notification when a provile is added or removed .
public static uri add message to uri ( content resolver resolver , uri uri , string address , string body , string subject , long date , boolean read , boolean delivery report , long thread id ) { content values values = new content values ( num ) ; values . put ( address , address ) ; if ( date != null ) { values . put ( date , date ) ; } values . put ( read , read ? integer . value of ( num ) : integer . value of ( num ) ) ; values . put ( subject , subject ) ; values . put ( body , body ) ; if ( delivery report ) { values . put ( status , status pending ) ; } if ( thread id != - num ) { values . put ( thread id , thread id ) ; } return resolver . insert ( uri , values ) ; }	add an sms to the given uri with thread_id specified .
private void present ( ) { gl use program ( quad program ) ; gl bind buffer ( gl array buffer , vbo ) ; gl active texture ( gl textur ) ; gl bind texture ( gl texture 2 d , tex ) ; gl draw arrays ( gl triangles , num , num ) ; gl active texture ( gl textur ) ; gl bind texture ( gl texture 2 d , num ) ; gl bind buffer ( gl array buffer , num ) ; gl use program ( num ) ; }	present the final image on the screen / viewport .
public static calendar next ( calendar self ) { calendar result = ( calendar ) self . clone ( ) ; result . add ( calendar . day of year , num ) ; return result ; }	increment a calendar by one day .
protected void angular object client bind ( notebook socket conn , hash set < string > user and roles , notebook notebook , message from message ) throws exception { string note id = from message . get type ( str ) ; string var name = from message . get type ( str ) ; object var value = from message . get ( str ) ; string paragraph id = from message . get type ( str ) ; note note = notebook . get note ( note id ) ; if ( paragraph id == null ) { throw new illegal argument exception ( str + str ) ; } if ( note != null ) { final interpreter group interpreter group = find interpreter group for paragraph ( note , paragraph id ) ; final angular object registry registry = interpreter group . get angular object registry ( ) ; if ( registry instanceof remote angular object registry ) { remote angular object registry remote registry = ( remote angular object registry ) registry ; push angular object to remote registry ( note id , paragraph id , var name , var value , remote registry , interpreter group . get id ( ) , conn ) ; } else { push angular object to local repo ( note id , paragraph id , var name , var value , registry , interpreter group . get id ( ) , conn ) ; } } }	push the given angular variable to the target interpreter angular registry given a noteid and a paragraph id.
public static < t > void remove all ( list < t > list , list < integer > indexes ) { if ( list == null || indexes == null ) { return ; } collections . sort ( indexes , collections . reverse order ( ) ) ; final int size = list . size ( ) ; for ( integer index : indexes ) { if ( index >= num && index < size ) { list . remove ( ( int ) index ) ; } } }	removes from the given list the elements at the given indexes.
public c ( final j parent , final c database manager ) { preconditions . check not null ( database manager , str ) ; m tree model = new c ( this ) ; set model ( m tree model ) ; c . initialize ( parent , this , database manager ) ; add mouse listener ( new internal mouse listener ( ) ) ; set scrolls on expand ( bool ) ; set root visible ( bool ) ; m root node = new c ( this , database manager ) ; m tree model . set root ( m root node ) ; set cell renderer ( new icon node renderer ( ) ) ; m popup . add ( c . proxy ( new c ( this ) ) ) ; }	creates a new project tree component .
public boolean is object ( ) { return type string . starts with ( object ) ; }	determine if the expression is an object . ( a thing , not a person ).
private float interpolate ( ) { long curr time = system . current time millis ( ) ; float elapsed = ( curr time - start time ) / zoom time ; elapsed = math . min ( num , elapsed ) ; return interpolator . get interpolation ( elapsed ) ; }	use interpolator to get t.
private void auto request mods ( ) { if ( ! c . auto request mods enabled ( ) ) { return ; } set < string > joined channels = c . get joined channels ( ) ; for ( string channel : joined channels ) { if ( ! mods already requested . contains ( channel ) ) { logger . info ( str + channel ) ; mods already requested . add ( channel ) ; request mods silent ( channel ) ; return ; } } }	if enabled in the settings , requests / mods for one currently joined channel ( and only one ) , ignoring the ones it was already requested for .
@ override public boolean contains ( object value ) { final iterator < comparable > iter = new step iterator ( this , num ) ; if ( value == null ) { return bool ; } while ( iter . has next ( ) ) { if ( default type transformation . compare equal ( value , iter . next ( ) ) ) return bool ; } return bool ; }	iterates over all values and returns true if one value matches .
public synchronized void rename file ( jdbc file , string new file name ) throws sql { try { connection . set auto commit ( bool ) ; rename file . set string ( num , new file name ) ; rename file . set int ( num , file . get id ( ) ) ; rename file . execute update ( ) ; connection . commit ( ) ; } catch ( sql e ) { connection . rollback ( ) ; throw e ; } }	updates the filename field to the new value .
public static void handle error violations ( formatter formatter , long num errors ) { exit code exit code = formatter . get exit status ( num errors ) ; if ( exit code != exit code . success ) { system . exit ( exit code . ordinal ( ) ) ; } }	non - zero exit status when any violation messages have severity . error , controlled by - - max - severity.
public void remove ( final sensor sensor ) { set < sensor > old selection = new hash set < sensor > ( selection ) ; boolean rv = selection . remove ( sensor ) ; if ( rv ) { fire selection changed ( old selection , selection ) ; } }	remove the specified sensor from this sensor selection model .
protected void print way ( map way way , default entity view info p info , boolean as area ) { list < map node > nodes = get way nodes ( way ) ; if ( nodes != null ) { boolean as oneway = bool ; name info text info = null ; if ( scale >= p info . min name scale * display factor ) { as oneway = way . is oneway ( ) ; if ( way . get name ( ) != null && p info . name color != null ) { text info = new name info ( way . get name ( ) , p info . name color , p info . print order ) ; } } print line ( image bdr , nodes , p info , as area , as oneway , text info ) ; } }	prints a way entity .
@ override public string to string ( ) { string buffer result = new string buffer ( ) ; for ( int i = num ; i < data . length ; i ++ ) { result . append ( ( i == num ? str : str ) + data [ i ] ) ; } return result . to string ( ) ; }	returns a string representation of the data row .
public element full path ( managed object reference obj ) throws invalid property fault msg , runtime fault fault msg , finder exception { list < object content > set = ancestry set ( obj ) ; map < mo ref , element > child to parent = new hash map < > ( ) ; for ( object content cont : set ) { mo ref key = new mo ref ( cont . get obj ( ) ) ; managed object reference parent ref = get parent ( cont ) ; element parent ; if ( parent ref != null ) { parent = element . make ( parent ref , get name ( cont ) ) ; } else { parent = element . make ( cont . get obj ( ) , get name ( cont ) ) ; } child to parent . put ( key , parent ) ; } mo ref next = new mo ref ( obj ) ; list < string > path = new array list < > ( ) ; while ( bool ) { element parent = child to parent . get ( next ) ; path . add ( parent . path ) ; if ( next . equals ( new mo ref ( parent . object ) ) ) { break ; } next = new mo ref ( parent . object ) ; } collections . reverse ( path ) ; string builder sb = new string builder ( ) ; for ( string s : path ) { sb . append ( str ) ; sb . append ( s ) ; } return element . make ( obj , sb . to string ( ) ) ; }	walks up the tree until a root object is found .
private boolean has next proxy ( ) { return next proxy index < proxies . size ( ) ; }	returns true if there ' s another proxy to try .
private boolean no object was clicked on ( ) { boolean picked node null = ( picked node == null ) ; boolean camera picked = ( picked node instanceof p ) ; return ( picked node null || camera picked ) ; }	encapsulate logic for determining the case where no object ( neuron node , synpase node , etc ) was clicked on at the beginning of this drag sequence .
@ override public int hash code ( ) { throw new unsupported operation exception ( str ) ; }	this operation is not supported because sets are mutable .
public builder measurement mappings ( map < string , string > measurement mappings ) { map < string , pattern > mappings by pattern = new hash map < string , pattern > ( ) ; for ( map . entry < string , string > entry : measurement mappings . entry set ( ) ) { try { final pattern pattern = pattern . compile ( entry . get value ( ) ) ; mappings by pattern . put ( entry . get key ( ) , pattern ) ; } catch ( pattern syntax exception e ) { throw new runtime exception ( str + entry . get value ( ) , e ) ; } } this . measurement mappings = mappings by pattern ; return this ; }	map measurement to a defined measurement name , where the key is the measurement name and the value is the reqex the measurement should be mapped by .
public static void extract ( file zip file , file dest dir ) throws io { zip file zf = new zip file ( zip file ) ; try { extract ( zf , dest dir ) ; } finally { zf . close ( ) ; } }	extract the contents of a zipfile to a directory .
public config ( string file ) { this ( new file ( config dir , file . contains ( str ) ? file : file . concat ( str ) ) ) ; }	creates a new config within the config directory , using the filename provided .
public goto line dialog ( j text ) { super ( action utils . get frame for ( text ) , bool ) ; init components ( ) ; this . text = text ; set location relative to ( text . get root pane ( ) ) ; }	creates new form gotolinedialog.
private void send request teardown ( ) throws io { string request = str + m parameters . host + str + m parameters . port + m parameters . path + str + add headers ( ) ; log . i ( tag , request . substring ( num , request . index of ( str ) ) ) ; m output stream . write ( request . get bytes ( str ) ) ; m output stream . flush ( ) ; }	forges and sends the teardown request.
public boolean parse more data ( final encoded image encoded image ) { if ( m parser state == not a jpeg ) { return bool ; } final int data buffer size = encoded image . get size ( ) ; if ( data buffer size <= m bytes parsed ) { return bool ; } final input stream buffered data stream = new pooled byte array buffered input stream ( encoded image . get input stream ( ) , m byte array pool . get ( buffer size ) , m byte array pool ) ; try { stream util . skip ( buffered data stream , m bytes parsed ) ; return do parse more data ( buffered data stream ) ; } catch ( io ioe ) { throwables . propagate ( ioe ) ; return bool ; } finally { closeables . close quietly ( buffered data stream ) ; } }	if this is the first time calling this method , the buffer will be checked to make sure it starts with soi marker ( 0xffd8 ).
public void test simple ear ( ) throws exception { final url url = new url ( str + system . get property ( str ) + str ) ; final string expected = str ; ping utils . assert ping true ( url . get path ( ) + str , expected , url , logger ) ; }	test deploying a simple ear .
public int length ( ) { return this . filled length ; }	gets the current filled and readable length of the array .
@ override public boolean equals ( object o ) { if ( o instanceof prefix ) { return value . equals ( ( ( prefix ) o ) . value ) ; } return bool ; }	equals method to be consistent with comparable.
private void notify wifi state ( ) { synchronized ( m wifi monitor ) { log . v ( log tag , str ) ; m wifi monitor . notify ( ) ; } }	send a notification via the mwifimonitor when the wifi state changes .
private boolean array key value exists ( string key , string value ) { if ( visited post . contains key ( key ) ) { for ( string s : visited post . get ( key ) ) { if ( s . equals ( value ) ) { return bool ; } } } return bool ; }	checks whether the value exists in an arraylist of certain key .
public void remove diagram change listener ( mx diagram change listener listener ) { if ( diagram change listeners != null ) { diagram change listeners . remove ( listener ) ; } }	removes the given listener from the list of diagram change listeners .
public static connectivity grid connectivity grid factory ( int key , double max range ) { if ( gridobjects . contains key ( ( integer ) key ) ) { return ( connectivity grid ) gridobjects . get ( ( integer ) key ) ; } else { connectivity grid newgrid = new connectivity grid ( ( int ) math . ceil ( max range * cell size multiplier ) ) ; gridobjects . put ( ( integer ) key , newgrid ) ; return newgrid ; } }	returns a connectivity grid object based on a hash value.
public static string strip leading dollar ( string str ) { return ( str . char at ( num ) == str ) ? str . substring ( num ) : str ; }	removes any leading $ from the given string .
@ after class public static void clear host context ( ) throws exception { system . clear property ( str ) ; }	clears the " hostcontext " system property.
public p ( double p ) { if ( p <= num || double . is na n ( p ) ) throw new illegal argument exception ( str + p ) ; this . p = p ; }	creates a new p norm.
@ override public void start ( stage stage ) throws exception { category dataset dataset = create dataset ( ) ; j chart = create chart ( dataset ) ; chart viewer viewer = new chart viewer ( chart ) ; viewer . add chart mouse listener ( this ) ; stage . set scene ( new scene ( viewer ) ) ; stage . set title ( str ) ; stage . set width ( num ) ; stage . set height ( num ) ; stage . show ( ) ; }	adds a chart viewer to the stage and displays it .
@ override public void accept data point ( chart event e ) { if ( e . get reset ( ) ) { m x count = num ; m max = num ; m min = num ; } if ( m output frame != null ) { boolean refresh = bool ; if ( e . get legend text ( ) != null & e . get legend text ( ) != m legend text ) { m legend text = e . get legend text ( ) ; refresh = bool ; } if ( e . get min ( ) != m min || e . get max ( ) != m max ) { m old max = m max ; m old min = m min ; m max = e . get max ( ) ; m min = e . get min ( ) ; refresh = bool ; m y scale update = bool ; } if ( refresh ) { m legend panel . repaint ( ) ; m scale panel . repaint ( ) ; } accept data point ( e . get data point ( ) ) ; } m x count ++ ; }	accept a data point ( encapsulated in a chart event ) to plot.
public void sub ( named range set other ) { list < named range > new ranges = new array list < named range > ( ) ; outer loop : for ( named range range : ranges ) { named range this range = new named range ( range . start , range . end , range . name ) ; for ( named range other range : other . ranges ) { if ( other range . start <= this range . start && other range . end >= this range . end ) { continue outer loop ; } if ( other range . end < this range . start || other range . start > this range . end ) { } else if ( other range . start <= this range . start ) { this range . start = other range . end + num ; } else if ( other range . end >= this range . end ) { this range . end = other range . start - num ; } else { new ranges . add ( new named range ( this range . start , other range . start - num , this range . name ) ) ; this range . start = other range . end + num ; } } new ranges . add ( this range ) ; } ranges = new ranges ; }	assumptions : ranges are disjoint , non - contiguous , and ordered.
public static tailer create ( file file , tailer listener listener , long delay millis , boolean end , int buf size ) { tailer tailer = new tailer ( file , listener , delay millis , end , buf size ) ; thread thread = new thread ( tailer ) ; thread . set daemon ( bool ) ; thread . start ( ) ; return tailer ; }	creates and starts a tailer for the given file .
public static boolean is mac os ( ) { return os name . index of ( str ) > - num ; }	is operating system mac os ?.
public int size ( ) { return values . size ( ) ; }	returns the number of items in the collection .
public d ( j parent , crl crl ) throws asn1 exception , io { super ( res . get string ( str ) ) ; this . crl = crl ; init components ( ) ; }	creates new dviewasn1dump dialog where the parent is a dialog .
public static string right trim ( final string value ) { validate ( value , null string predicate , null string msg supplier ) ; return value . replace all ( str , str ) ; }	remove all spaces on right .
public synchronized void put message ( object obj ) { fifo . add element ( obj ) ; num message ++ ; notify all ( ) ; }	add a message in the buffer.
public void dispose ( ) { if ( is disposed ( ) ) { return ; } set disposed ( bool ) ; if ( ! menu ) { super . dispose ( ) ; } }	closes the current form and returns to the previous form , releasing the edt in the process.
public double signed distance ( pla point float p point ) { double dx = point b . v x - point a . v x ; double dy = point b . v y - point a . v y ; double det = dy * ( p point . v x - point a . v x ) - dx * ( p point . v y - point a . v y ) ; double length = math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }	returns the signed distance of this line from p_point.
public static void expand real ( string number string , word relation word relation , item token item ) { int string length = number string . length ( ) ; int position ; if ( number string . char at ( num ) == str ) { word relation . add word ( token item , str ) ; expand real ( number string . substring ( num , string length ) , word relation , token item ) ; } else if ( number string . char at ( num ) == str ) { word relation . add word ( token item , str ) ; expand real ( number string . substring ( num , string length ) , word relation , token item ) ; } else if ( ( position = number string . index of ( str ) ) != - num || ( position = number string . index of ( str ) ) != - num ) { expand real ( number string . substring ( num , position ) , word relation , token item ) ; word relation . add word ( token item , str ) ; expand real ( number string . substring ( position + num ) , word relation , token item ) ; } else if ( ( position = number string . index of ( str ) ) != - num ) { string before dot = number string . substring ( num , position ) ; if ( before dot . length ( ) > num ) { expand real ( before dot , word relation , token item ) ; } word relation . add word ( token item , str ) ; string after dot = number string . substring ( position + num ) ; if ( after dot . length ( ) > num ) { expand digits ( after dot , word relation , token item ) ; } } else { expand number ( number string , word relation , token item ) ; } }	expands the given number string as a real number .
public static double [ ] ones ( int l ) { double m [ ] = new double [ l ] ; arrays . fill ( m , num ) ; return m ; }	ones - return a vector full of 1s .
private permission request submit ( ) { int show rationale = num ; array list < string > requests = new array list < > ( ) ; for ( final string permission : m permissions ) { if ( m activity . check self permission ( permission ) != package manager . permission granted ) { requests . add ( permission ) ; if ( activity compat . should show request permission rationale ( m activity , permission ) ) { show rationale ++ ; } } } m request code = m request id . add and get ( num ) ; if ( requests . is empty ( ) ) { if ( m callback != null ) { m callback . on permissions granted ( ) ; } } else { if ( show rationale == num ) { activity compat . request permissions ( m activity , m permissions , m request code ) ; } else { show rationale ( ) ; } } return this ; }	submits a requests for a set of permissions for an activity .
public void test setting a ( ) { deployable deployable element = new deployable ( ) ; war war = new war ( str ) ; map < string , string > properties = new hash map < string , string > ( ) ; properties . put ( str , null ) ; deployable element . set properties ( properties ) ; deployable element . set properties on deployable ( war , create default project ( str , null ) ) ; assert equals ( str , war . get context ( ) ) ; }	setting a null property is the way maven2 operates when the user specifies an empty property.
private navi logger ( ) { }	you are not supposed to instantiate this class .
public static delete sub command handler create ( sub command argument parser parser , managed object path < ? , ? > p , set relation definition < ? , ? > r ) throws argument exception { return new delete sub command handler ( parser , p , r , p . child ( r ) ) ; }	creates a new delete - xxx sub - command for a set relation .
protected void remove cycles ( ) { int visited [ ] = new int [ m nodes . size ( ) ] ; for ( int i = num ; i < graph matrix . length ; i ++ ) { if ( visited [ i ] == num ) { remove cycles2 ( i , visited ) ; visited [ i ] = num ; } } }	the following two methods remove cycles from the graph .
public string to string ( d matrix ) { string buffer buf = new string buffer ( ) ; boolean old print shape = this . print shape ; this . print shape = bool ; for ( int slice = num ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != num ) buf . append ( slice separator ) ; buf . append ( to string ( matrix . view slice ( slice ) ) ) ; } this . print shape = old print shape ; if ( print shape ) buf . insert ( num , shape ( matrix ) + str ) ; return buf . to string ( ) ; }	returns a string representation of the given matrix .
int find ancestor ( x xctxt , x from match pattern , x count match pattern , int context , elem number namespace context ) throws javax . xml . transform . transformer exception { dtm dtm = xctxt . get dtm ( context ) ; while ( dtm . null != context ) { if ( null != from match pattern ) { if ( from match pattern . get match score ( xctxt , context ) != x . match score none ) { break ; } } if ( null != count match pattern ) { if ( count match pattern . get match score ( xctxt , context ) != x . match score none ) { break ; } } context = dtm . get parent ( context ) ; } return context ; }	given a ' from ' pattern ( ala xsl : number ) , a match pattern and a context , find the first ancestor that matches the pattern ( including the context handed in ) .
public synchronized void kill ( ) { running = bool ; closed = bool ; try { stdin . close ( ) ; } catch ( io e ) { } try { process . destroy ( ) ; } catch ( exception e ) { } }	try to clean up as much as possible from a shell that ' s gotten itself wedged.
public final byte buffer encode ( char buffer in ) throws character coding exception { int length = ( int ) ( in . remaining ( ) * average bytes per char ) ; byte buffer out = byte buffer . allocate ( length ) ; reset ( ) ; while ( state != flushed ) { coder result result = encode ( in , out , bool ) ; if ( result == coder result . overflow ) { out = allocate more ( out ) ; continue ; } else { check coder result ( result ) ; } result = flush ( out ) ; if ( result == coder result . overflow ) { out = allocate more ( out ) ; } else { check coder result ( result ) ; } } out . flip ( ) ; return out ; }	this is a facade method for the encoding operation.
public static metrics create ( map < string , string > dimension map ) { map < string , string > map = maps . new tree map ( ) ; map . put all ( dimension map ) ; return new metrics ( collections . unmodifiable map ( map ) ) ; }	creates a metrics object with the dimensions map immutable.
protected class < ? > resolve class ( object stream class class desc ) throws io , class not found exception { object annotation = read location ( ) ; string class name = class desc . get name ( ) ; class loader default loader = skip default resolve class ? null : latest user defined loader ( ) ; string codebase = null ; if ( ! use codebase only && annotation instanceof string ) { codebase = ( string ) annotation ; } try { return rmi . load class ( codebase , class name , default loader ) ; } catch ( access control exception e ) { return check sun class ( class name , e ) ; } catch ( class not found exception e ) { try { if ( character . is lower case ( class name . char at ( num ) ) && class name . index of ( str ) == - num ) { return super . resolve class ( class desc ) ; } } catch ( class not found exception e2 ) { } throw e ; } }	resolveclass is extended to acquire ( if present ) the location from which to load the specified class.
public boolean contains ( final creature respawn point point ) { if ( point == null ) { return bool ; } final irp entity zone = point . get zone ( ) ; return zone . equals ( entity zone ) && shape . contains ( point . get x ( ) , point . get y ( ) ) ; }	checks whether a respawn point is within this area .
public void add ( int i , byte [ ] buffer , int offset , int length ) { if ( length + length > capacity ) ensure capacity ( length + length ) ; system . arraycopy ( buffer , i , buffer , i + length , length - i ) ; system . arraycopy ( buffer , offset , buffer , i , length ) ; length += length ; }	inserts a byte array.
public boolean is use anti alias ( ) { return use anti alias ; }	checks if is use anti alias .
private void load level file ( string table name , string column name , string cube name , string schema name ) { string base location = carbon util . get carbon store path ( schema name , cube name ) ; base location = base location + file . separator + schema name + file . separator + cube name ; if ( load folder list . size ( ) == num ) { check and update folder list ( base location ) ; } try { file [ ] files array = null ; for ( file load foler : load folder list ) { files array = get files array ( load foler , table name + str + column name ) ; if ( null != files array ) { for ( int i = num ; i < files array . length ; i ++ ) { read level file and update cache ( files array [ i ] , table name + str + column name ) ; } } } } catch ( io e ) { logger . error ( str ) ; } }	below method will be used to fill the level cache.
protected void do validate zero long file ( string path , string filename , long size , boolean check contents ) { file in file = new file ( path , filename ) ; data input stream in stream = null ; log . i ( log tag , str + filename + str + path ) ; try { in stream = new data input stream ( new file input stream ( in file ) ) ; if ( check contents ) { for ( long i = num ; i < size ; ++ i ) { if ( in stream . read long ( ) != num ) { fail ( str + filename ) ; } } } if ( in stream != null ) { in stream . close ( ) ; } log . i ( log tag , str + filename + str + size + str ) ; } catch ( io e ) { fail ( str + in file + str + e . to string ( ) ) ; } }	helper to validate the contents of a " long " file on our obbs the format of the files are sequential 0 ' s of type long.
protected void write ( data output stream stream ) throws exception { iterator < nbt > iter = elements . iterator ( ) ; while ( iter . has next ( ) ) { nbt ret = iter . next ( ) ; ret . save ( stream ) ; } tag end = new tag ( str ) ; end . save ( stream ) ; }	saving method . ( see nbt_tag ).
public string apply mask ( string mask , string value ) { return ( string ) get mask or get cursor index ( mask , value , num , bool ) ; }	makes a masked value of a value.
private void compute duration ( ) { duration = system . current time millis ( ) - start ; total duration += duration ; }	computes the duration by subtracting start to the current time in milliseconds.
public int handle nitf ( binary file bin file ) { try { byte [ ] nitf array = bin file . read bytes ( num , bool ) ; string nitf = new string ( nitf array ) ; bin file . seek ( rpf date location ) ; nitf array = bin file . read bytes ( num , bool ) ; nitf = new string ( nitf array ) ; if ( nitf . equals ignore case ( str ) || nitf . equals ignore case ( str ) ) return num ; bin file . seek ( rpf date location + toc nitf header length ) ; nitf array = bin file . read bytes ( num , bool ) ; nitf = new string ( nitf array ) ; if ( nitf . equals ignore case ( str ) || nitf . equals ignore case ( str ) ) return toc nitf header length ; bin file . seek ( rpf date location + frame short nitf header length ) ; nitf array = bin file . read bytes ( num , bool ) ; nitf = new string ( nitf array ) ; if ( nitf . equals ignore case ( str ) || nitf . equals ignore case ( str ) ) return frame short nitf header length ; bin file . seek ( rpf date location + frame long nitf header length ) ; nitf array = bin file . read bytes ( num , bool ) ; nitf = new string ( nitf array ) ; if ( nitf . equals ignore case ( str ) || nitf . equals ignore case ( str ) ) return frame long nitf header length ; } catch ( io e ) { debug . error ( str + e ) ; return - num ; } catch ( format exception f ) { debug . error ( str + f ) ; return - num ; } return - num ; }	checks to see if the file is in nitf or not , and then puts the file pointer in the right place to start reading the header for the file.
public buffered image take screenshot ( ) { debug . set debug level ( num ) ; file scr file = driver . get screenshot as ( output type . file ) ; buffered image buffered image = null ; try { buffered image = io . read ( scr file ) ; } catch ( io e ) { e . print stack trace ( ) ; } return buffered image ; }	convenience method that takes a screenshot of the device and returns a bufferedimage for further processing .
